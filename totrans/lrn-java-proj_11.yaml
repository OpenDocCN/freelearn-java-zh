- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is another fundamental concept of software development. An error
    happens when the program can’t or doesn’t know how to react to a certain situation.
    Error handling allows you to respond to unexpected events in your program gracefully.
    Without error handling, the application would crash and stop running when the
    error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we have different types of errors. The type of error that we deal with
    most is called an **exception**. In Java terms that we’ll learn later, an Exception
    is not an Error. This is related to the class hierarchy. However, sticking to
    daily linguistics it is not weird to think of an exception as some sort of error.
  prefs: []
  type: TYPE_NORMAL
- en: But, instead of talking about errors, we usually talk about exceptions. Errors
    occur as well, but errors are typically situations your application will not recover
    from. Your application should be capable of recovering from an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in Java allows you to manage problems and unexpected events
    in your programs. Mastering exception handling will not only improve the robustness
    of your code but also help you maintain and debug your applications more effectively.
    By understanding how exceptions work, you can write code that deals with unexpected
    situations without crashing or producing incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making sure that you have the necessary skills to manage exceptions in your
    applications is exactly what we’re going to learn in this chapter. Here’s an overview
    of what we’ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exceptions and their purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of exceptions – checked and unchecked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic I/O operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The catch or declare principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using try-catch blocks, try-catch-finally, and try-with-resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with inheritance and exception handling in method signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s dive in and explore the world of exceptions!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday life, we have to execute a lot of processes. And all the time, we
    have little hiccups that happen, and these should not ruin our day. These hiccups
    are not considered the happy path of events, but they happen often, and we recover
    from them and continue business as usual.
  prefs: []
  type: TYPE_NORMAL
- en: There are also more serious problems that can occur, for which we need to have
    a formal backup plan, such as evacuating a building in case of a fire.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in Java are like this. These are things that should not happen; sometimes,
    we are in control of them happening and sometimes, we are not. In some cases,
    we are obligated to specify a backup plan, and in other cases, we are not. First,
    let’s talk a bit more about what exceptions are.
  prefs: []
  type: TYPE_NORMAL
- en: What are exceptions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions are events that disrupt the normal flow of the program. They typically
    arise from errors or unexpected conditions that the program encounters while running.
    Exceptions in Java are objects. These exceptions are represented by instances
    of the `Exception` class or its subclasses. The `Exception` class is a subclass
    of the `Throwable` class.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs, the Java runtime system creates an exception object
    containing information about the error, such as its type and the state of the
    program when the error occurred. This process is known as *throwing an exception*.
    Dealing with an exception is called *catching* *an exception*.
  prefs: []
  type: TYPE_NORMAL
- en: If the exception is not caught and handled by the program, the Java runtime
    system will terminate the program, usually displaying an error message and the
    stack trace. So, let’s talk about the need for exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Stack trace
  prefs: []
  type: TYPE_NORMAL
- en: 'You might not know this term just yet, but you’re likely to have encountered
    one already. A stack trace shows up when an exception happens. It shows the “path”
    the code took to get to your error. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index
    0 out of bounds for` `length 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`at javabook.Example.printFirstValueArray(Example.java:21)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`at javabook.Example.main(Example.java:8)`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this example, the line that eventually triggered the exception
    is line 21 and the method name was `printFirstValueArray`. That method was called
    on line 8 in the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: Need for exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we don’t want our program to stop running every time it throws an exception,
    exception handling is a crucial aspect of programming. We typically separate the
    code logic from the exception-handling logic. This helps us create an application
    that is maintainable and resilient. When we have proper exception handling in
    place, our program can recover gracefully from unexpected situations. This is
    much more preferred than the program crashing and stopping, or even producing
    incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is so common, Java provides a built-in exception handling mechanism
    that allows us to catch and handle exceptions. This way, we can recover from the
    exception and continue executing the program. This mechanism encourages (or even
    forces) us to think about possible exceptional conditions that the program might
    encounter and write code to handle these exceptions effectively. Let’s talk about
    some situations in which we need exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Common situations that require exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many situations in which exceptions can occur. Some of these are within
    our control, but the most important ones where we absolutely must deal with the
    possibility of an exception are situations where we are not fully in control.
    We’ll address a few common situations before seeing the exception code.
  prefs: []
  type: TYPE_NORMAL
- en: File I/O operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common situation that requires exception handling is a piece of logic
    that deals with file I/O operations. When working with file I/O operations, exceptions
    can be used to handle situations where a file is not found or cannot be read or
    written. These are all situations that are not in the programmer’s control. Permissions
    for the program might not be right, a file may have been removed, or a file might
    already be in use – many other situations out of your control can also happen.
  prefs: []
  type: TYPE_NORMAL
- en: Java has specific subclasses to deal with these types of exceptions. The main
    subclass to deal with I/O operations is `IOException`. It has its own subclasses,
    such as `FileNotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: Database operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another type of situation where we depend on an external part is all sorts of
    database operations. A database can be down or altered and that’s out of your
    control as a developer. So, we need to deal with exceptions that can occur while
    connecting to, querying, or updating a database. For instance, `SQLException`
    can be thrown when there are issues with a database connection or when an invalid
    SQL query is executed or when a database constraint (a database specific rule)
    is violated. Proper exception handling allows your program to recover from these
    issues, such as by re-establishing the connection or rolling back a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: User input validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When your application requires user input, exceptions can be used to handle
    cases where the input is invalid or does not meet the expected format. For example,
    `NumberFormatException` can be thrown when attempting to parse a non-numeric string
    as an integer. Handling this kind of exception well can help your application
    provide helpful feedback to users and ensure they enter valid data while keeping
    the core logic separated from error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your program depends on external resources, such as memory and system resources.
    These resources can also be third-party services, such as APIs. And in all these
    situations, exceptions can occur. We need to handle situations where these resources
    are unavailable or exhausted. For example, when the `OutOfMemoryError` will be
    thrown, and `InterruptedException` can be used to handle cases where a thread
    is interrupted while waiting for a resource. Proper handling in these scenarios
    can help your application recover or gracefully degrade its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What might be striking is that we have an *error* for out-of-memory situations,
    but so far, we have been talking about *exceptions* instead of errors. Let’s have
    a look at the hierarchy to understand what’s going on here.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the exception hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java is an object-oriented language, and objects can form a hierarchy. In Java,
    all exceptions are subclasses of the `Throwable` class. Everything that can be
    thrown by the application in case of a problem is of the `Throwable` type. The
    `Throwable` class has two main subclasses: `Error` and `Exception`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Errors* represent severe issues that occur during the runtime system’s operation,
    and they typically indicate critical problems with the JVM or the application
    environment. Examples include `OutOfMemoryError` and `StackOverflowError`. Errors
    are usually not recoverable, and it is *not* recommended to catch and handle them
    in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `Exception` class and its subclasses represent exceptional
    conditions that a program can handle. There are two main categories of exceptions:
    checked and unchecked exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Checked exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`IOException`, `FileNotFoundException`, and `SQLException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Checked exceptions are subclasses of the `Exception` class, excluding `RuntimeException`
    and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unchecked exceptions** represent programming errors that do not need to be
    explicitly dealt with. These exceptions are typically thrown because of programming
    errors or situations that are not expected to occur during normal program execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Since unchecked exceptions usually indicate bugs in the code, the Java compiler
    assumes that your program should not need to catch or declare them explicitly.
    However, you can still choose to catch and handle unchecked exceptions. This can
    come in handy when you want to provide a more user-friendly error message or log
    the error for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of unchecked exceptions include `NullPointerException`, `IndexOutOfBoundsException`,
    and `IllegalArgumentException`. These unchecked exceptions are subclasses of `RuntimeException`.
    This class is a subclass of `Exception`. Unlike all the other subclasses of `Exception`,
    `RuntimeException` and its subclasses don’t need to be handled. (You can say it’s
    an… exception.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11**.1*, you can see this hierarchy in the form of a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Throwable hierarchy](img/B19793_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Throwable hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the exception hierarchy is essential for effectively handling
    exceptions. As you can see, there are different types of exceptions. Some of them
    (checked exceptions) need to be handled, while others do not (unchecked exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll be using I/O operations to demonstrate exceptions. This
    is something that we haven’t seen yet. So, let’s introduce I/O operations first.
  prefs: []
  type: TYPE_NORMAL
- en: Working with basic I/O operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll use I/O operations to illustrate how exceptions work. Therefore, before
    diving into exception handling, we’ll briefly introduce basic I/O operations.
    There are many ways to do this, but we’ll be using `FileReader` and `FileWriter
    - FileReader` and `FileWriter` are classes in the `java.io` package that allow
    you to read and write characters. We have chosen these two classes because they
    provide a simple way to work with text files in Java and are commonly used for
    file I/O operations in the real world as well. First things first, let’s read
    with `FileReader`.
  prefs: []
  type: TYPE_NORMAL
- en: Other classes for I/O operations
  prefs: []
  type: TYPE_NORMAL
- en: It is common to use other classes for I/O operations in common situations. For
    example, if you’re going to read lines from files, you may want to work with `BufferedReader`
    instead. This is not the focus of this chapter. We just want to understand enough
    of I/O operations to demonstrate some real situations for exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a file using FileReader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To read from a text file using `FileReader`, you first need to create a `FileReader`
    object and pass the file path as a parameter. You can then read characters from
    the file using the `read()` method. After using `FileReader`, you must close it
    to make sure you don’t lock the file and don’t use any unnecessary resources.
    Here’s an example of reading a file using `FileReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is reading from a file called `input.txt`. The *try-catch*
    block is something we’ll see later in this chapter; it’s for exception handling
    and you don’t need to understand it just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a new `FileReader` instance and passed it the path of our input
    file. For the read operation to work, `input.txt` has been placed in the project
    folder. For me, it looks like the structure shown in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Location of input.txt in the project](img/B19793_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Location of input.txt in the project
  prefs: []
  type: TYPE_NORMAL
- en: 'The most complicated snippet of the code that reads the file is probably the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`FileReader` is going to read the input file character by character. The `read()`
    method reads a character and moves the cursor. The cursor is the place where it
    starts reading next. So, we need to store the result of the reading in a variable
    to not lose the character. When the end of the file is reached, `read()` will
    return `-1`. This means we need to read until we reach `-1`. And that’s exactly
    what `while ((character = reader.read()) != -1)` is doing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `input.txt` file is going to be printed in the output. Of course, we can
    do more interesting things with the content of the file, but that’s not the goal
    here. All we want to see is how to deal with exceptions. The code will not run
    when it’s just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That’s how to read a file. Next up, we’ll learn how to write to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file using FileWriter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This may sound quite predictable, but to write to a text file, we can use `FileWriter`.
    The steps are similar to using `FileReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create a `FileWriter` object and pass the file path as a
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you can write characters or strings to the file using the `write()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, close `FileWriter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of writing to a file using `FileWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, first, we created an instance of `FileWriter`. Next, we created
    a variable of the `String` type called `content`. We wrote this variable to the
    `output.txt` file with the `write()` method. Again, ignore the try-catch part.
    We’ll get to that soon.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered basic file I/O operations, we can proceed with exceptions
    and exception handling. We are going to use `FileReader` and `FileWriter` as real-world
    examples for handling various types of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When something goes wrong, the program *throws an exception*. This is because
    someone that created Java or the library that you are using, at some point, coded
    it that way. A lot of the Java library is programmed to throw exceptions, such
    as in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When you try to access a field or method on a null instance, `NullPointerException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you try to divide by 0, `ArithmethicException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you try to access an index in an array that is not part of the array, `ArrayIndexOutOfBoundsException`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of the output of code that throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see the name of the exception in the output (`java.lang.ArithmeticException`),
    as well as the message, stating `/` `by zero`.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the exception, we can see the *stack trace*. A stack trace is the
    application’s steps to get to the exception. The top of the stack trace shows
    the line that triggered the exception. This is a very tiny stack trace because
    it went wrong directly in the main method, so we only have one line in there.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the Java library throws exceptions when problematic situations happen.
    This is done with the `throw` keyword. In the next section, we’re going to see
    how we can use this `throw` keyword to throw exceptions ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The throw keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can throw exceptions explicitly using the `throw` keyword. This is commonly
    used when your code detects an exceptional condition or when you want to enforce
    a specific constraint in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the syntax for throwing an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start with the `throw` keyword; after that, there’s an instance of `Throwable`.
    In this case, we throw a new `IllegalArgumentException` instance and specify in
    the message that age cannot be a negative value.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the normal execution of the program is interrupted,
    and control goes to the nearest matching catch block. If none are present, the
    program stops and displays the exception and stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and throwing custom exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java has a lot of built-in exceptions, but in some situations, you may need
    to have more specific exceptions. Great news – you can also create and throw your
    own custom exceptions! Custom exceptions are helpful when you want to provide
    more specific information about the problem that occurred, or when you want to
    handle certain types of exceptions differently in your catch blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom exception, you need to define a new class that extends the
    `Exception` class or one of its subclasses. Here’s an example of a custom exception
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We overwrite the following three constructors. This is recommended to support
    conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `no-args` constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor that takes `String` containing a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor that takes another exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InvalidAgeException` custom class extends the `Exception` class. Therefore,
    `InvalidAgeException` is a checked exception that needs to be handled. If it extended
    `RuntimeException` or one of its subclasses, it was an unchecked exception and
    it didn’t need to be handled. Let’s talk about catching and handling exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The catch or declare principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The catch or declare principle states that when a method can throw a checked
    exception, the method must catch the exception with a try-catch statement or declare
    that it throws the exception in its method signature. This rule ensures that checked
    exceptions are properly handled or propagated up the call stack so that the calling
    method can handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The catch or declare principle holds for checked exceptions. If a checked exception
    is not declared or caught, the code won’t compile. For unchecked exceptions, the
    catch or declare rule does not apply. They are usually caused by programming errors
    or unexpected situations that cannot be predicted or anticipated. Unchecked exceptions
    can be caught and handled, but it is not mandatory. Let’s see how we can declare
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to declare exceptions, let’s have a look at how to
    deal with exceptions with the try-catch statement.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring exceptions using throws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `throws` keyword is used to declare that a method may throw a certain exception.
    By using the `throws` keyword, you can indicate that a method may throw one or
    more checked exceptions. The method that calls the other method that declares
    the exception is responsible for handling them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring an exception is not difficult. You can simply add `throws` to the
    method signature followed by the exception type. Here’s an example of a piece
    of code using `FileReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `read` method declares that it may throw `IOException`.
    When another method calls this method, it is responsible for handling the exception.
    When you know how you want to deal with an exception, you can handle it with the
    try-catch statement instead of declaring it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions with try-catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a method declares a checked exception, the calling method is obligated
    to deal with it. This can be done by catching the exception or by declaring the
    exception in its own method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how to deal with exceptions using a try-catch block. Try-catch
    blocks come in different forms, but we’ll start with the most basic.
  prefs: []
  type: TYPE_NORMAL
- en: Basic try-catch block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A try-catch block is used to handle exceptions that might be thrown during
    the execution of a specific block of code. The code that might throw an exception
    is placed inside the `try` block, and the code to handle the exception is placed
    inside the corresponding `catch` block. Here’s the syntax of a try-catch block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s an example of a basic try-catch block that actually has some code
    that might throw an exception and some basic handling. We saw this when we were
    learning about `FileReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `FileReader` can throw multiple exceptions. For example, when
    the file does not exist, it will throw `FileNotFoundException`. This exception
    is an `IOException`, which, in turn, is an `Exception`. Therefore, `FileReader`
    might throw a checked exception. And checked exceptions need to be handled. Therefore,
    we must place the code that can throw the exception(s) in the try block. We handle
    `Exception` in the catch block by printing the stack trace. After handling the
    exception, the program’s execution continues normally.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify multiple catch blocks if we need to specify specific handling
    for different kinds of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple catch blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A block of code may throw multiple types of exceptions. We can handle different
    exceptions using *multiple catch blocks*. It’s important to have the most specific
    exception on top. If we were to start by catching `Exception`, for example, it
    would always go to that catch block. This is because all exceptions inherit from
    Exception and would be of type Exception. The `catch(Exception e)` would catch
    every possible exception, making the rest of the catch clauses unreachable. Therefore,
    it doesn’t compile if you try to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using multiple catch blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two catch blocks – one for `FileNotFoundException`
    and one for `IOException`. If an exception is thrown, the appropriate catch block
    will be executed based on the exception type.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want to clean up resources after the catch or perform other sorts
    of actions. We can do so with the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Try-catch-finally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `finally` block is an optional block of code that follows a try-catch block.
    It is executed regardless of whether an exception is thrown or not. The `finally`
    block is typically used to clean up resources. These resources could be file streams
    or network connections that need closing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using a `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `finally` block is executed after the `try-catch` block,
    regardless of whether an exception occurred. The only way to not execute the `finally`
    block is to stop the program completely before it completes the `try-catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the finally block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `finally` block can be used to clean up resources. This ensures that they
    are properly released, even if an exception is thrown. Here’s an example of using
    a `finally` block to close the instance of `FileReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is a little different. Let’s start with the most striking difference:
    we close the `readerin` the finally block now. This ensures that `readergets`
    closed, even if an exception occurs in the try block before it gets to that line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `reader` to be still in scope in the `finally` block, we have to declare
    it outside of the `try` block. That’s why we have this line on top of the `try`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can’t initialize it outside of the `try` block because that part needs to
    be in the `try` block since it may throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the flow of the code when no exception occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`: Initialize `FileReader` and read the file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`finally`: Close `reader`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue after the `finally` block with the rest of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here’s the flow of the code when an exception occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try`: Initialize `FileReader` and read the file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`catch`: Handle the exception.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`finally`: close the reader.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue after the `finally` block with the rest of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, regardless of whether an exception is thrown, the `finally` block ensures
    `reader` is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Closing `reader` might throw another exception, which is why we have another
    try-catch statement in the `finally` block. Arguably, this is not a very pretty
    syntax. A solution for many of these situations is using the **try-with-resources**
    statement instead.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions with try-with-resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 7 introduced the `finally` block for resource cleaning for many types of
    classes. The try-with-resources statement can be used without a catch or `finally`
    block. The normal `try` statement must have at least one of those.
  prefs: []
  type: TYPE_NORMAL
- en: What is try-with-resources?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The try-with-resources statement takes care of resource management for you.
    A resource is a special Java object that opens a channel that needs to be closed
    in order for the resource to be marked for cleanup by Java. We have seen that
    the FileReader objects are examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: The resources that are declared within the try-with-resources statement will
    be automatically closed when the `try` block completes. And of course, just like
    the `finally` block, it doesn’t matter whether or not an exception is thrown.
    The resources will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using try-with-resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The resources need to be opened between the parentheses following the `try`
    block. At the end of the `try` block, the resources will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open multiple ones separated with a semicolon, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to understand the details of the code in this example since we
    did not talk about `BufferedReader` and `BufferedWriter`. These classes are utility
    classes that provide buffering capabilities for reading and writing text files.
    With buffering, we can improve the performance of I/O operations by minimizing
    the number of system calls.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet uses `FileReader` and `BufferedReader` to read the
    contents of a file, while `FileWriter` and `BufferedWriter` are used to convert
    content (all uppercase) into `output.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The try-with-resources block ensures that all resources are automatically closed
    after their use. It does so in the opposite order of declaring them, so it starts
    by closing the last. This is important because, as you can see, we’re using `fileWriter`
    to create `bufferedWriter`. Closing them in a different order may cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: Please don’t forget, not all classes can be automatically closed. For Java to
    be able to automatically close a class, the class needs to implement the `AutoCloseable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AutoCloseable interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to use a (custom) class with the try-with-resources statement, the
    class should implement the `AutoCloseable` interface and override the `close()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own classes that can be automatically closed. Here’s an example
    of a custom resource that implements `AutoCloseable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This resource can now be used in a try-with-resources statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code opens `SomeResource` in the try-with-resources statement. We then
    call the `doSomething()` method, which prints a line to the console. At the end
    of the block, the resource is closed. We print another line in the `close()` method
    that we had to implement for the `AutoCloseable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it prints the line from the `doSomething()` method. The `close()`
    method also gets triggered. As we can see, the message that it prints in the output
    as well. We don’t trigger the `close()` method ourselves, this is done by the
    mechanism of the `try-with-resource` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the basics of the try-with-resources statement so that you can start
    working with it. It’s now time for a topic that is often considered to be quite
    challenging: dealing with inheritance and exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with inheritance and exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class inherits from another class, it can override the methods in this
    other class. There are some special rules for dealing with the declared exceptions
    and overriding methods. It’s important to understand this to successfully override
    methods that declare exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring exceptions in method signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a method can throw a checked exception that isn’t dealt with in that method
    by a try-catch, it is declared in the method’s signature. We have just learned
    that this is done with the `throws` keyword, followed by the exception type(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `readFile` method’s signature declares that it can throw `IOException`.
    When we extend the class that this method is in, we can override the `readFile`
    method. There are some important rules for how to deal with exceptions that are
    declared.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods and exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s step away from the code for a second here and think of this a little
    bit more abstractly and concretely at the same time. Let’s say you and I meet
    up next week to discuss a software application at your office, and I’m telling
    you I’ll have to bring my young kids due to daycare issues. You know that certain
    *exceptions* may occur: tantrums, fights between the kids, random food in your
    hair and on your clothes, and so on. However, you agree to meet me.'
  prefs: []
  type: TYPE_NORMAL
- en: If I’m planning on also bringing my three rottweilers because my dog sitter
    cancels, I may want to inform you about this beforehand so you can decide whether
    it’s still okay for me to come over with these new conditions. You have incorporated
    the *kids exceptions* in your decision already, but you haven’t decided whether
    you are also okay with *dog exceptions* yet. This includes muddy paws, drool,
    dog hair, and potentially accidentally sharing your cookie with one of the gentle
    giants.
  prefs: []
  type: TYPE_NORMAL
- en: It’s probably considered polite to inform you about bringing the cuddly protectors
    over beforehand. However, if I end up having a babysitter and I come by myself,
    I probably don’t need to mention that in advance because it makes it more convenient.
    (No, I don’t hate my kids.)
  prefs: []
  type: TYPE_NORMAL
- en: Alright – keep this in mind while we make the transition back to Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you override a method in a subclass, the overriding method must follow
    certain rules regarding exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: It cannot throw checked exceptions that weren’t declared in the signature of
    the method in the parent class. (We cannot bring the dogs without notice.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the overridden method declares a checked exception, the overriding method
    can declare the same exceptions, a subclass of that exception, or a subset of
    the exceptions. (Bringing just one kid instead of two).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing can also be considered a subset. So, we can also choose not to declare
    any exception in the child class that overrides the method. (Not bringing the
    kids.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of an override that declares a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Child` class overrides the `readStuff` method from the `Parent` class.
    Since the overridden method declares the `IOException`, the overriding method
    can declare the same exception or a subclass of it (for example, `FileNotFoundException`)
    or not declare any exception at all.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions can always be added. They don’t have any consequences for
    the calling code. At the same time, declaring them, in general, doesn’t make a
    lot of sense, since it’s not obligated to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s deal with some common unhappy path scenarios in our app. When these occur,
    we need our app to be able to recover from them:'
  prefs: []
  type: TYPE_NORMAL
- en: When reading and writing the dinosaur data, it is possible that the file cannot
    be opened due to different circumstances. Perhaps someone moved it, it’s in use,
    or something else. Your task is to simulate a situation where you’re trying to
    read from a file (that may not exist) and deal with the checked exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While updating dinosaur data, invalid values could sometimes be provided. Write
    an `updateDinosaurWeight` method that takes a weight value and a `Dinosaur` object.
    If the weight value is less than zero, the method should throw `IllegalArgumentException`.
    Use a try-catch block to handle this exception. The handling can be a simple `System.out.println`
    for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even in exceptional circumstances, certain operations should always execute.
    For example, a daily audit of dinosaurs’ health should happen, whether an exception
    occurs (for example due to the weight being too low) or not. Use a `finally` block
    in your program to demonstrate this. Code the logic so that even if there is an
    error in updating a dinosaur’s health record, a message about the daily audit
    completion should still be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our dinosaur park, data about dinosaurs’ diets is stored in external resources
    . In this case, that external resource is a file. Write a program where you use
    a try-with-resources block to read data from this file, ensuring the file is closed
    properly after use, even if an error occurs during data retrieval. Here’s a sample
    file called `DinoDiet.txt` that you can use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a dinosaur’s health score falls below a certain critical value, the program
    should throw a custom exception, named `CriticalHealthException`. Create this
    custom exception and use it in your program to handle this specific problematic
    condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a dinosaur park is filled with unexpected situations. Some are minor,
    such as running out of cheese-flavored potato chips. Some are major, such as an
    escaped T-Rex. The happiness, health, and safety of our dinosaurs and visitors
    are important, so our system should be able to handle exceptional situations.
  prefs: []
  type: TYPE_NORMAL
- en: Design a “dinosaur care system” for Mesozoic Eden that handles exceptional situations
    such as a dinosaur falling ill, enclosure breaches, and so on. Use appropriate
    exceptions to represent various error conditions and handle them properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java project in your IDE of choice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new package named exception.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create custom exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `DinosaurIllException` inside the exception package.
    This class should extend the `Exception` class and represent an error condition
    when a dinosaur falls ill.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, create `EnclosureBreachedException` for an error condition where
    an enclosure has been breached.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the dinosaur care system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `DinosaurCareSystem`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this class, create a method called `handleDinosaurHealth()` that throws
    `DinosaurIllException`. You can simulate random health conditions for the dinosaur.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, create a method called `handleEnclosureSecurity()` that throws `EnclosureBreachedException`.
    Using this, you can simulate the random security status of dinosaur enclosures.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve just explored the importance of exception handling. We now know how it
    allows us to separate the code logic from the error handling logic. We delved
    into the two main types of exceptions: checked and unchecked. Checked exceptions
    are exceptions that require explicit handling, whereas unchecked exceptions are
    usually caused by programming errors and do not need to be explicitly caught or
    declared.'
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the catch or declare principle, which requires checked exceptions
    to be caught in a try-catch block or declared in a method’s signature. The try-catch
    block allows us to handle exceptions by executing alternative code when an exception
    occurs. We also learned about using multiple catch blocks to handle different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we saw the `finally` block, which is executed regardless of whether an
    exception occurs. This block is useful for cleaning up resources and ensuring
    certain actions are always performed. This `finally` block is less common since
    Java 7 and try-with-resources is used whenever possible. This simplifies resource
    management by automatically closing resources when the `try` block finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined method exception signatures and how they relate to inheritance
    while focusing on the rules for checked exceptions when overriding methods.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a solid understanding of Java exception handling.
    Now, it’s time to learn a little more about the Java core API.
  prefs: []
  type: TYPE_NORMAL
