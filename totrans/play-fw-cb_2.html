<html><head></head><body><h1 id="e-G2Q6">Chapter 2. Using Controllers</h1>
<p id="e-Y5se">In this chapter, we will cover the following recipes:</p>
<ul id="e-ESCO">
<li id="e-BZpp">Using HTTP headers</li>
<li id="e-XUAN">Using HTTP cookies</li>
<li id="e-suJC">Using the session</li>
<li id="e-ZnSA">Using custom actions</li>
<li id="e-TeoH">Using filters</li>
<li id="e-FxcP">Using path binders</li>
<li id="e-p3xL">Serving JSON</li>
<li id="e-q1Po">Receiving JSON</li>
<li id="e-xDjA">Uploading files</li>
<li id="e-SkKx">Using futures and Akka actors</li>
</ul>
<h1 id="e-LB40">Introduction</h1>
<p id="e-luPd">In this chapter, we will dive in a little deeper into Play controllers and discuss some advanced topics regarding controllers in web applications. We will also learn how Play can handle and address more modern web app requirements besides the common use cases such as data manipulation and data retrieval. As we rely on controllers to route web requests and responses, we want to ensure that our controllers are as lightweight and as decoupled as possible, to ensure page responsiveness and predictable page load times. Providing a clean separation from the model and other data-related processing and services also provides developers a clearer understanding of what each layer's responsibilities are.</p>

<h1 id="e-wFbU">Using HTTP headers</h1>
<p id="e-lXZK">For this recipe, we will explore how Play applications can manipulate HTTP headers. We will use the <code>curl</code> tool to validate if our changes to the HTTP response headers were applied correctly. For Windows users, it is recommended to install Cygwin in order to have a unix-like environment for Windows machines (<a href="https://www.cygwin.com/">https://www.cygwin.com/</a>).</p>
<h2 id="e-avzD">How to do it…</h2>
<p id="e-bUlT">For Java, we need to take the following steps:</p>
<ol id="e-sGYj">
<li id="e-hkXf">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-lFJ2">&lt;span class="strong"&gt;&lt;strong&gt;    activator  "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-BkAr">Modify <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-MZ6W">public static Result modifyHeaders() {
       response().setHeader("ETag", "foo_java");
      return ok("Header Modification Example");
    }</pre>
</li>
<li id="e-Dn4F">Add a new <code>routes</code> entry for the newly-added action in <code>foo_scala/conf/routes</code>:<pre id="e-xI8g">&lt;span class="strong"&gt;&lt;strong&gt;  GET   /header_example    controllers.Application.modifyHeaders&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-TgMK">Request our new route and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-AFyk">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/header_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /header_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; ETag: foo_java&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 27&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Header Modification Example%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-KHq1">For Scala, we need to take the following steps:</p>
<ol id="e-nWri">
<li id="e-uL26">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-CYrd">&lt;span class="strong"&gt;&lt;strong&gt;  activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-uVZU">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-Lxll">def modifyHeaders = Action {
    Ok("Header Modification Example")
      .withHeaders(
        play.api.http.HeaderNames.ETAG -&amp;gt; "foo_scala"
      )
  }</pre>
</li>
<li id="e-SJX4">Add a new <code>routes</code> entry for the newly-added action in <code>foo_scala/conf/routes</code>:<pre id="e-dcLR">GET   /header_example    controllers.Application.modifyHeaders</pre>
</li>
<li id="e-aGmU">Request our new <code>routes</code> and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-DKOI">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/header_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /header_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; ETag: foo_scala&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 27&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Header Modification Example%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-YfMS">How it works…</h2>
<p id="e-Q7cl">In this recipe, we created a new URL route and action. Within the action, we added a new HTTP header and assigned an arbitrary value to it. We then accessed this new action using the command-line tool, <code>curl</code> so that we can view the response HTTP headers in raw text. The output should contain our custom header key and its assigned arbitrary value.</p>

<h1 id="e-uClS">Using HTTP cookies</h1>
<p id="e-YnwN">For this recipe, we will explore how Play applications can manipulate HTTP cookies. We will use the <code>curl</code> tool to validate our changes to the HTTP response headers containing the new cookie we added to the response.</p>
<h2 id="e-zg9z">How to do it…</h2>
<p id="e-LDB3">For Java, we need to take the following steps:</p>
<ol id="e-MMIT">
<li id="e-jIdg">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-T3Zf">Modify <code>foo_java/app/controllers/Application.scala</code> by adding the following action:<pre id="e-Azga">public static Result modifyCookies() {
        response().setCookie("source", "tw", (60*60));
        return ok("Cookie Modification Example");
     }</pre>
</li>
<li id="e-WpqJ">Add a new route entry for the newly-added action in <code>foo_java/conf/routes</code>:<pre id="e-bBe1">GET   /cookie_example    controllers.Application.modifyCookies</pre>
</li>
<li id="e-Wu4P">Request our new route and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-m4px">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/cookie_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /cookie_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Set-Cookie: source=tw; Expires=Sun, 23 Oct 2014 10:22:43 GMT; Path=/&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 27&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Cookie Modification Example%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-rwT5">For Scala, we need to take the following steps:</p>
<ol id="e-IRBb">
<li id="e-WkS6">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-IFem">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-Ng1C">def modifyCookies = Action {
      val cookie = Cookie("source", "tw", Some(60*60))
      Ok("Cookie Modification Example")
        .withCookies(cookie)
     }</pre>
</li>
<li id="e-fcdi">Add a new routes entry for the newly-added action in <code>foo_scala/conf/routes</code>:<pre id="e-Dej3">GET   /cookie_example    controllers.Application.modifyCookies</pre>
</li>
<li id="e-V1gl">Request our new route and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-m4nF">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/cookie_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /cookie_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Set-Cookie: source=tw; Expires=Sun, 23 Oct 2014 09:27:24 GMT; Path=/; HTTPOnly&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 27&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Cookie Modification Example%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-ovcB">How it works…</h2>
<p id="e-EGdR">In this recipe, we created a new URL route and action. Within the action, we added a new cookie named <code>source</code> and assigned it an arbitrary value "<code>tw</code>" and an optional expiration time (in this recipe, an hour):</p>
<pre id="e-MTkR">val cookie = Cookie("source", "tw", Some(60*60))</pre>
<p id="e-hsFe">We then accessed this new action using the command-line tool <code>curl</code> so that we can view the response HTTP headers in raw text. The output should contain the <code>Set-Cookie</code> header with the cookie name and value we assigned in the action.</p>

<h1 id="e-NlmN">Using the session</h1>
<p id="e-gWqf">For this recipe, we will explore how Play applications handle a session state. This sounds counterintuitive, as Play claims to be a stateless and lightweight web framework. However, as sessions and session states have become major components for web applications, Play implements sessions as cookies and therefore, are actually stored on the client side or the user browser.</p>
<h2 id="e-Q42G">How to do it…</h2>
<p id="e-isHa">For Java, we need to take the following steps:</p>
<ol id="e-OxM3">
<li id="e-c8Ed">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-URo3">Modify <code>foo_java/app/controllers/Application.scala</code> by adding the following action:<pre id="e-uLm0">public static Result modifySession() {
        final String sessionVar = "user_pref";
        final String userPref = session(sessionVar);
        if (userPref == null) {
        session(sessionVar, "tw");
        return ok("Setting session var: " + sessionVar);
        } else {
        return ok("Found user_pref: " + userPref);
        }
     }</pre>
</li>
<li id="e-dFwU">Add a new routes entry for the newly-added action in <code>foo_java/conf/routes</code>:<pre id="e-tSdC">GET   /session_example    controllers.Application.modifySession</pre>
<img data-width="700" data-height="547" src="RN4C8LXY.jpg"/>
</li>
<li id="e-n2Sj">Access this new URL route (<code>http://localhost:9000/session_example</code>) using a web browser. You should see the text <strong>Setting session var: user_pref</strong>:<img data-width="700" data-height="547" src="gYiaaaWd.jpg"/>
</li>
<li id="e-GwD3">Access this new URL route again using the same web browser and you see the text <strong>Found userPref: tw</strong>.</li>
<li id="e-rbQ1">Our new session variable is assigned using <code>curl</code>:<pre id="e-Ev8U">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/session_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /session_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Set-Cookie: PLAY_SESSION="cadbcca718bbfcc11af40a2cfe8e4c76716cca1f-user_pref=tw"; Path=/; HTTPOnly&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 30&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Setting session var: user_pref%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-zeAu">For Scala, we need to take the following steps:</p>
<ol id="e-YueB">
<li id="e-ELc8">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-qO6D">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-LmmP">def modifySession = Action { request =&amp;gt;
      val sessionVar = "user_pref"
      request.session.get(sessionVar) match {
        case Some(userPref) =&amp;gt; {
          Ok("Found userPref: %s".format(userPref))
        }
        case None =&amp;gt; {
      Ok("Setting session var: %s".format(sessionVar))
            .withSession(
              sessionVar -&amp;gt; "tw"
        )
        }
      }
     }</pre>
</li>
<li id="e-RQjD">Add a new routes entry for the newly-added <code>Action</code> in <code>foo_scala/conf/routes</code>:<pre id="e-AgXF">GET   /session_example    controllers.Application.modifySession</pre>
</li>
<li id="e-Taoc">Access this new URL route (<code>http://localhost:9000/session_example</code>) using a web browser and you should see the text <strong>Setting session var: user_pref</strong>
</li>
<li id="e-dj9k">Access this new URL route again using the same web browser and you see the text <strong>Found userPref: tw</strong>.</li>
<li id="e-aH69">You can also see how our new session variable is assigned using <code>curl</code>:<pre id="e-G4O7">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/session_example&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying 127.0.0.1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (127.0.0.1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /session_example HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Set-Cookie: PLAY_SESSION="64c6d2e0894a60dd28101e37b742f71ae332ed13-user_pref=tw"; Path=/; HTTPOnly&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 30&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Setting session var: user_pref%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-TvUU">How it works…</h2>
<p id="e-OcF0">In this recipe, we created a new URL route and action. Within the action, we added some logic to understand whether the session var "<code>user_pref</code>" already existed in the session or not. If the session variable was indeed set, we print out the value of the session variable in the response body. If the session variable was not found in the current session, it would add the session variable to the session and display text, notifying the requestor that it did not find the session variable. We validated this by using a web browser and requesting the same URL route twice; first, to set the session variable and second, to print the value of the session variable. We also used <code>curl</code> to see how the session variable was set to the current session as an HTTP cookie header.</p>

<h1 id="e-N2nA">Using custom actions</h1>
<p id="e-ABf2">For this recipe, we will explore how Play Framework provides the building blocks for creating reusable, custom actions.</p>
<h2 id="e-edr2">How to do it…</h2>
<p id="e-ZSvc">For Java, we need to take the following steps:</p>
<ol id="e-nBGU">
<li id="e-xb7b">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-vwVY">Modify <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-XsLg">@With(AuthAction.class)
    public static Result dashboard() {
        return ok("User dashboard");
    }
     public static Result login() {
        return ok("Please login");
    }</pre>
</li>
<li id="e-ALva">Add our new action class to <code>foo_java/app/controllers/AuthAction.java</code> as well:<pre id="e-lPMc">package controllers;
 import play.*;
import play.mvc.*;
import play.libs.*;
import play.libs.F.*;
 public class AuthAction extends play.mvc.Action.Simple {
    public F.Promise&amp;lt;Result&amp;gt; call(Http.Context ctx) throws Throwable {
        Http.Cookie authCookie = ctx.request().cookie("auth");
         if (authCookie != null) {
          Logger.info("Cookie: " + authCookie);
          return delegate.call(ctx);
         } else {
          Logger.info("Redirecting to login page");
          return Promise.pure(redirect(controllers.routes.
Application.login()));
        }
    }
}</pre>
</li>
<li id="e-gJhb">Add new routes for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-CsWH">GET   /dashboard      controllers.Application.dashboard
  GET   /login      controllers.Application.login</pre>
</li>
<li id="e-w0B7">Access the dashboard URL route using a web browser and notice that it redirects you to the login URL route. You will also notice a log entry in our console where the request is about to be redirected to the login page:<pre id="e-EZfN">[info] application - Redirecting to login page</pre>
</li>
</ol>
<p id="e-zvIB">For Scala, we need to take the following steps:</p>
<ol id="e-gXFL">
<li id="e-hWRy">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-EnHF">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-wTAS">def dashboard = AuthAction {
       Ok("User dashboard")
     }
      def login = Action {
       Ok("Please login")
     }</pre>
</li>
<li id="e-KDAT">Add our new action to <code>foo_scala/app/controllers/Application.scala</code> as well:<pre id="e-uaQ9">object AuthAction extends ActionBuilder[Request] {
  import play.api.mvc.Results._
  import scala.concurrent.Future
   def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt;     Future[Result]) = {
    request.cookies.get("auth") match {
      case Some(authCookie) =&amp;gt; {
        Logger.info("Cookie: " + authCookie)
        block(request)  
      }
      case None =&amp;gt; {
        Logger.info("Redirecting to login page")
        Future.successful(Redirect(routes.Application.login()))
      }
    }
  }
}</pre>
</li>
<li id="e-X67y">Add new routes for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-sdWN">GET   /dashboard      controllers.Application.dashboard
  GET   /login      controllers.Application.login</pre>
</li>
<li id="e-vCIx">Access the dashboard URL route using a web browser and notice that it redirects you to the login URL route. You will also notice a log entry in our console where the request is about to be redirected to the login page:<pre id="e-BcSp">[info] application - Redirecting to login page</pre>
</li>
</ol>
<h2 id="e-yKBV">How it works…</h2>
<p id="e-YqVm">In this recipe, we created two new URL routes and actions; one to display a user dashboard, and the other, to act as our login page. Within the dashboard action, we utilized our new action <code>AuthAction</code>. The <code>AuthAction</code> object checks for the existence of the <code>auth</code> cookie and if it does find the said cookie in the request, it calls the <code>ActionBuilder</code> in the chain:</p>
<pre id="e-VWzo">// Java
return delegate.call(ctx);
 // Scala
block(request)</pre>
<p id="e-N2PX">If the <code>auth</code> cookie is not found in the request, <code>AuthAction</code> redirects the current request to the <code>login</code> URL route, wrapping it around a completed <code>Future[Result]</code> object with <code>Future.successful()</code>:</p>
<pre id="e-c201">// Java
return Promise.pure(redirect(controllers.routes.Application.login()));
 // Scala
Future.successful(Redirect(routes.Application.login()))</pre>

<h1 id="e-MTel">Using filters</h1>
<p id="e-ACSW">For this recipe, we will explore how Play Framework provide APIs for HTTP request and response filters. HTTP filters provide a way to transparently decorate a HTTP request or response and is useful for lower-level services (such as response compression), gathering metrics, and more in-depth logging.</p>
<h3 id="e-mtZG">Note</h3>
<p id="e-hGZK">It is also worth noting that presently (as of Play 2.3.7), HTTP filters are best implemented using the Play Scala API with the <em>play.api.mvc.EssentialFilter</em> trait. So for this recipe, we will implement a Scala-based filter for our Java recipe.</p>
<h2 id="e-FJAa">How to do it…</h2>
<p id="e-oWpD">For Java, we need to take the following steps:</p>
<ol id="e-Bf8Z">
<li id="e-cEuT">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-ZhL0">Create a new filter object by creating the file <code>foo_java/app/ResponseTimeLogFilter.scala</code>, and adding the following contents:<pre id="e-rWFe">import play.api.mvc._
   object ResponseTimeLogFilter {
      def apply(): ResponseTimeLogFilter = {
         new ResponseTimeLogFilter()
       }
     }
   class ResponseTimeLogFilter extends Filter {
      import play.api.Logger
      import scala.concurrent.Future
      import play.api.libs.concurrent.Execution.Implicits.defaultContext
        def apply(f: (RequestHeader) =&amp;gt; Future[Result])(rh: RequestHeader): Future[Result] = {
         val startTime = System.currentTimeMillis
         val result = f(rh)
         result.map { result =&amp;gt;
           val currDate = new java.util.Date
           val responseTime = (currDate.getTime() - startTime) / 1000F
            Logger.info(s"${rh.remoteAddress} - [${currDate}] - ${rh.method} ${rh.uri}" +
           s" ${result.header.status} ${responseTime}")
            result
         }
       }
     }</pre>
</li>
<li id="e-p9cC">Utilize this new filter by declaring it in the <code>app/Global.java</code> file:<pre id="e-jbq9">import play.GlobalSettings;
    import play.api.mvc.EssentialFilter;
     public class Global extends GlobalSettings {
      public &amp;lt;T extends EssentialFilter&amp;gt; Class&amp;lt;T&amp;gt;[] filters() {
        return new Class[]{
    ResponseTimeLogFilter.class
     };
      }
    }</pre>
</li>
<li id="e-lw1f">Access any previous URL routes we've defined (<code>http://localhost:9000/session_example</code>) using a web browser. You will be able to see a new log entry with our response stats printed:<pre id="e-UroP">&lt;span class="strong"&gt;&lt;strong&gt;[info] application - 0:0:0:0:0:0:0:1 - [Mon Oct 24 23:58:44 PHT 2014] - GET /session_example 200 0.673&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-NDUT">For Scala, we need to take the following steps:</p>
<ol id="e-Ca6n">
<li id="e-MaZz">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-ufpY">Create a new filter object by creating the file <code>foo_scala/app/controllers/ResponseTimeLogFilter.scala</code> and adding the following contents:<pre id="e-dRcv">import play.api.Logger
  import play.api.mvc._
  import play.api.libs.concurrent.Execution.Implicits.defaultContext
   object ResponseTimeLogFilter extends EssentialFilter {
      def apply(nextFilter: EssentialAction) = new EssentialAction {
        def apply(requestHeader: RequestHeader) = {
          val startTime = System.currentTimeMillis
          nextFilter(requestHeader).map { result =&amp;gt;
            val currDate = new java.util.Date
            val responseTime = (currDate.getTime() - startTime) / 1000F
             Logger.info(s"${requestHeader.remoteAddress} - [${currDate}] - ${requestHeader.method} ${requestHeader.uri}" +
            s" ${result.header.status} ${responseTime}")
             result
          }
        }
      }
    }</pre>
</li>
<li id="e-hmGr">Utilize this new filter by declaring it in the <code>app/Global.scala</code> file:<pre id="e-Kbjz">import play.api._
    import play.api.mvc._
    import controllers.ResponseTimeLogFilter
     object Global extends WithFilters(ResponseTimeLogFilter) {
      override def onStart(app: Application) {
     Logger.info("Application has started")
      }
      override def onStop(app: Application) {
        Logger.info("Application shutdown...")
      }
    }</pre>
</li>
<li id="e-Zyk4">Access any previous URL routes we've defined (<code>http://localhost:9000/session_example</code>) using a web browser. You will be able to see a new log entry with our response stats printed:<pre id="e-fMIE">&lt;span class="strong"&gt;&lt;strong&gt;[info] application - 0:0:0:0:0:0:0:1 - [Mon Oct 24 23:58:44 PHT 2014] - GET /session_example 200 0.673&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-q0fg">How it works…</h2>
<p id="e-GElv">In this recipe, we created a new Scala-based filter. The filter simply calculates the total response time for request and prints it out in the log file. We then utilized the filter by referring to it in the global application configuration class <code>Global.java/Global.scala</code>. This will be applied to all requests of the Play application.</p>

<h1 id="e-nM75">Using path binders</h1>
<p id="e-cN9U">For this recipe, we will explore how Play applications allow us to use custom binders for path parameters. These come in handy when you want to simplify your declaration of routes and corresponding actions by dealing with model classes in the routes file and a method signature of actions instead of individual properties and fields declared as parameters.</p>
<h2 id="e-Tq6U">How to do it…</h2>
<p id="e-mbre">For Java, we need to take the following steps:</p>
<ol id="e-Sp4y">
<li id="e-Jff2">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-Xsyw">Create a new products controller as <code>foo_java/app/controllers/Products.scala</code>. Once created, add a product case class and companion object, the product form object, and two routes (the first to display our selected product in a form and the second as the PUT action for form update submission):<pre id="e-xpI1">package controllers;
 import play.*;
import play.mvc.*;
import play.data.*;
import views.html.*;
import models.*;
 public class Products extends Controller {
  private static Form&amp;lt;Product&amp;gt; productForm = Form.form(Product.class);
   public static Result edit(Product product) {
    return ok(views.html.products.form.render(product.sku, productForm.fill(product)));
  }
   public static Result update(String sku) {
    return ok("Received update request");
  }
}</pre>
</li>
<li id="e-Ph5R">Add our new product model in <code>foo_java/app/models/Product.java</code> as well:<pre id="e-pwtR">package models;
 import play.mvc.*;
 public class Product implements PathBindable&amp;lt;Product&amp;gt; {
  public String sku;
  public String title;
   private static final java.util.Map&amp;lt;String, String&amp;gt; productMap = new java.util.HashMap&amp;lt;String, String&amp;gt;();
  static {
    productMap.put("ABC", "8-Port Switch");
    productMap.put("DEF", "16-Port Switch");
    productMap.put("GHI", "24-Port Switch");
  }
     public static void add(Product product) {
      productMap.put(product.sku, product.title);
    }  
     public static java.util.List&amp;lt;Product&amp;gt; getProducts() {
      java.util.List&amp;lt;Product&amp;gt; productList = new java.util.ArrayList&amp;lt;Product&amp;gt;();
      for (java.util.Map.Entry&amp;lt;String, String&amp;gt; entry : productMap.entrySet()) {
        Product p = new Product();
        p.sku = entry.getKey();
        p.title = entry.getValue();
        productList.add(p);    
      }
      return productList;
    }
   public Product bind(String key, String value) {
    String product = productMap.get(value);
    if (product != null) {
      Product p = new Product();
      p.sku = value;
      p.title = product;
       return p;
    } else {
      throw new IllegalArgumentException("Product with sku " + value + " not found");
    }
  }
   public String unbind(String key) {
    return sku;
  }
   public String javascriptUnbind() {
    return "function(k,v) {\n" +
        "    return v.sku;" +
        "}";
  }
}</pre>
</li>
<li id="e-Lcnc">Add new routes for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-lbWg">GET   /products/:product   controllers.Products.edit(product: models.Product)
  PUT   /products/:sku     controllers.Products.update(sku)</pre>
</li>
<li id="e-o2aX">Create the product form view template in <code>foo_java/app/views/products/form.scala.html</code> with the following content:<pre id="e-AuVD">@(sku: String, productForm: Form[models.Product])
 @helper.form(action = routes.Products.update(sku)) {
  @helper.inputText(productForm("sku"))
  @helper.inputText(productForm("title"))
   &amp;lt;input type="submit" /&amp;gt;
}</pre>
</li>
<li id="e-nEyX">Access our edited products URL route (<code>http://localhost:9000/products/ABC</code>). You should be able to view the edit form for our first product. Access our next edit products URL route (<code>http://localhost:9000/products/DEF</code>) and you should see the relevant product details loading in the form.</li>
<li id="e-W7fK">Access the URL <code>http://localhost:9000/products/XYZ</code> and see how Play automatically generates the error message with the custom message we specified:<pre id="e-scRW">For request 'GET /products/XYZ' [Product with sku XYZ not found]</pre>
</li>
</ol>
<p id="e-cOVh">For Scala, we need to take the following steps:</p>
<ol id="e-Xhyb">
<li id="e-vOXW">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-iDD7">Create a new products controller as <code>foo_scala/app/controllers/Products.scala</code>. Once created, add a product case class and companion object, the product form object, and two routes (the first to display our selected product in a form and the second as the PUT action for the form update submission):<pre id="e-fUDh">package controllers
   import play.api._
  import play.api.data._
  import play.api.data.Forms._
  import play.api.mvc._
   case class Product(sku: String, title: String)
   object Product {
    implicit def pathBinder(implicit stringBinder: PathBindable[String]) = new PathBindable[Product] {
      override def bind(key: String, value: String): Either[String, Product] = {
        for {
          sku &amp;lt;- stringBinder.bind(key, value).right
          product &amp;lt;- productMap.get(sku).toRight("Product not found").right
        } yield product
      }
      override def unbind(key: String, product: Product): String = {
        stringBinder.unbind(key, product.sku)
      }
    }
     def add(product: Product) = productMap += (product.sku -&amp;gt; product)
     val productMap = scala.collection.mutable.Map(
      "ABC" -&amp;gt; Product("ABC", "8-Port Switch"),
      "DEF" -&amp;gt; Product("DEF", "16-Port Switch"),
      "GHI" -&amp;gt; Product("GHI", "24-Port Switch")
    )
  }
   object Products extends Controller {
    val productForm: Form[Product] = Form(
      mapping(
        "sku" -&amp;gt; nonEmptyText,
        "title" -&amp;gt; nonEmptyText
      )(Product.apply)(Product.unapply)
    )
     def edit(product: Product) = Action {
      Ok(views.html.products.form(product.sku, productForm.fill(product)))
    }
     def update(sku: String) = Action {
      Ok("Received update request")
    }
  }</pre>
</li>
<li id="e-m6GX">Add new routes for the newly-added action in <code>foo_scala/conf/routes</code>:<pre id="e-AFR9">GET   /products/:product   controllers.Products.edit(product: controllers.Product)
  PUT   /products/:sku     controllers.Products.update(sku)</pre>
</li>
<li id="e-Bxlp">Create the product form view template in <code>foo_scala/app/views/products/form.scala.html</code> with the following content:<pre id="e-j7ol">@(sku: String, productForm: Form[controllers.Product])
 @helper.form(action = routes.Products.update(sku)) {
  @helper.inputText(productForm("sku"))
  @helper.inputText(productForm("title"))
   &amp;lt;input type="submit" /&amp;gt;
}</pre>
</li>
<li id="e-XVcP">Access our edit product URL route (<code>http://localhost:9000/products/ABC</code>) and you should be able to view the edit form for our first product. Access our next edit product URL route (<code>http://localhost:9000/products/DEF</code>) and you should see the relevant product details loading in the form.</li>
<li id="e-Bp9X">Access the URL <code>http://localhost:9000/products/XYZ</code> and see how Play automatically generates the error message with the custom message we specified:<pre id="e-MX4z">For request 'GET /products/XYZ' [Product not found]</pre>
</li>
</ol>
<h2 id="e-S2Jy">How it works…</h2>
<p id="e-QuCe">In this recipe, we utilized Play's <code>PathBindable</code> interface to use custom path binders. We created a new route, controller, and model to represent a product. We implemented the <code>PathBindable</code> bind and unbind methods for the product:</p>
<p id="e-WB2N">Form binding is pretty straightforward for Java:</p>
<pre id="e-ODLr">// Java 
    private static Form&amp;lt;Product&amp;gt; productForm = Form.form(Product.class);
    public static Result edit(Product product) {
    return ok(views.html.products.form.render(product.sku, productForm.fill(product)));
   }</pre>
<p id="e-kZ8Q">As for Scala, we override two methods in the <code>PathBindable</code> class. During form binding, we first retrieve the product identifier <code>sku</code>, and then pass this same <code>sku</code> to retrieve the corresponding product in our product map:</p>
<pre id="e-Cozm">// Scala 
    implicit def pathBinder(implicit stringBinder: PathBindable[String]) = new PathBindable[Product] {
    override def bind(key: String, value: String): Either[String, Product] = {
      for {
        sku &amp;lt;- stringBinder.bind(key, value).right
        product &amp;lt;- productMap.get(sku).toRight("Product not found").right
      } yield product
    }
    override def unbind(key: String, product: Product): String = {
      stringBinder.unbind(key, product.sku)
    }
  }</pre>
<p id="e-q6Zv">We defined a route that required the custom path binding:</p>
<pre id="e-U7cN">GET   /products/:product   controllers.Products.edit(product: controllers.Product)</pre>
<p id="e-FNiV">You will notice that in defining the earlier route, we mapped its product parameter to a product instance. The <code>PathBindable</code> class does all the work here in converting the passed <code>sku</code> to a product instance.</p>

<h1 id="e-FHUX">Serving JSON</h1>
<p id="e-jzKh">For this recipe, we will explore how Play Framework allows us to easily convert our model objects to JSON. Being able to write web services that deliver data in the JSON data format has been a very common requirement for modern web applications. Play provides a JSON processing library that we will utilize in this recipe.</p>
<h2 id="e-F0CB">How to do it…</h2>
<p id="e-zcmS">For Java, we need to take the following steps:</p>
<ol id="e-eX0a">
<li id="e-zQAm">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-Vnkv">Modify the products controller in <code>foo_java/app/controllers/Products.java</code> by adding our product listing action:<pre id="e-QPYG">public static Result index() {
    return ok(Json.toJson(Product.getProducts()));
  }</pre>
</li>
<li id="e-AEXw">We need to add the following import statement for Play's JSON libraries:<pre id="e-Ewqp">import play.libs.Json;</pre>
</li>
<li id="e-ZkkD">Add a new route for the product listing action in <code>foo_java/conf/routes</code>:<pre id="e-c60w">GET   /products       controllers.Products.index</pre>
</li>
<li id="e-o2fd">Access our product listing URL route (<code>http://localhost:9000/products</code>) using <code>curl</code>:<pre id="e-hq1f">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 117&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[{"sku":"ABC","title":"8-Port Switch"},{"sku":"DEF","title":"16-Port Switch"},{"sku":"GHI","title":"24-Port Switch"}]%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-O6es">As we look at the output of our <code>curl</code> command, you will notice that our content type was automatically set accordingly (<code>application/json</code>) and that the response body contains an array of JSON products.</li>
</ol>
<p id="e-dMN8">For Scala, we need to take the following steps:</p>
<ol id="e-vYTE">
<li id="e-RVPA">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-An8f">Modify the products controller in <code>foo_scala/app/controllers/Products.scala</code> by adding our product listing action:<pre id="e-OLht">def index = Action {
    Ok(toJson(Product.productMap.values))
  }</pre>
</li>
<li id="e-GGRx">We need to add the following import statement for Play's JSON libraries:<pre id="e-oGQ9">import play.api.libs.json._
    import play.api.libs.json.Json._</pre>
</li>
<li id="e-hwLY">We also need to add our implementation of writes for our product model inside our products controller:<pre id="e-qc7y">implicit val productWrites = new Writes[Product] {
      def writes(product: Product) = Json.obj(
        "sku" -&amp;gt; product.sku,
        "title" -&amp;gt; product.title
      )
    }</pre>
</li>
<li id="e-gB6k">Add a new route for the product listing action in <code>foo_scala/conf/routes</code>:<pre id="e-MqmS">GET   /products       controllers.Products.index</pre>
</li>
<li id="e-KDn4">Access our product listing URL route (<code>http://localhost:9000/products</code>) using <code>curl</code>:<pre id="e-iZzg">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v http://localhost:9000/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; GET /products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 117&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[{"sku":"ABC","title":"8-Port Switch"},{"sku":"DEF","title":"16-Port Switch"},{"sku":"GHI","title":"24-Port Switch"}]%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-DgCj">As we look at the output of our <code>curl</code> command, you will notice that our content type was automatically set accordingly (<code>application/json</code>) and that the response body contains an array of JSON products.</li>
</ol>
<h2 id="e-x9tW">How it works…</h2>
<p id="e-T4am">In this recipe, we modified our products controller and added a new route that returns an array of products in the JSON format. We created the action in the controller and the new route entry in the <code>conf/routes</code> file. We then declared an implicit <code>writes</code> object which tells Play how to render our product model in the JSON format:</p>
<pre id="e-BkbT">implicit val productWrites = new Writes[Product] {
      def writes(product: Product) = Json.obj(
        "sku" -&amp;gt; product.sku,
        "title" -&amp;gt; product.title
      )
    }</pre>
<p id="e-RmpJ">In the preceding code snippet, we explicitly declare the JSON key labels for the rendered JSON.</p>
<p id="e-o1hD">The action then converts the retrieved product to JSON as the response to the action request:</p>
<pre id="e-NcfA">Ok(toJson(Product.productMap.values))</pre>

<h1 id="e-n4cX">Receiving JSON</h1>
<p id="e-QrkB">For this recipe, we will explore how Play Framework allow us to receive JSON objects easily and enable us to automatically convert them into model instances.</p>
<h2 id="e-owQx">How to do it…</h2>
<p id="e-pfpE">For Java, we need to take the following steps:</p>
<ol id="e-H1Yw">
<li id="e-BiCC">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-uP6K">Modify the products controller in <code>foo_java/app/controllers/Products.java</code> by adding our product creation action:<pre id="e-Osmd">@BodyParser.Of(BodyParser.Json.class)
  public static Result postProduct() {
    JsonNode json = request().body().asJson();
    String sku = json.findPath("sku").textValue();
    String title = json.findPath("title").textValue();
     Product p = new Product();
    p.sku = sku;
    p.title = title;
    Product.add(p);
    return created(Json.toJson(p));
  }</pre>
</li>
<li id="e-d3pw">We need to add the following import statement for Play's JSON libraries:<pre id="e-saQq">import com.fasterxml.jackson.databind.JsonNode;</pre>
</li>
<li id="e-BqRk">Add a new route for the product listing action in <code>foo_java/conf/routes</code>:<pre id="e-o9Zd">POST   /products       controllers.Products.postProduct</pre>
</li>
<li id="e-gKOQ">Access our product creation URL route (<code>http://localhost:9000/products</code>) using <code>curl</code>:<pre id="e-ENx6">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" --data '{"sku":"JKL", "title":"VPN/Router"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; POST /products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-Length: 35&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* upload completely sent off: 35 out of 35 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 34&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"sku":"JKL","title":"VPN/Router"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-jvua">As we look at the output of our <code>curl</code> command, you will notice that our response body now contains our newly added product.</li>
</ol>
<p id="e-j0q5">For Scala, we need to take the following steps:</p>
<ol id="e-IRpI">
<li id="e-uyuJ">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-oea5">Modify the products controller in <code>foo_scala/app/controllers/Products.scala</code> by adding our product creation action:<pre id="e-mKYQ">def postProduct = Action(BodyParsers.parse.json) { request =&amp;gt;
    val post = request.body.validate[Product]
    post.fold(
      errors =&amp;gt; {
        BadRequest(Json.obj("status" -&amp;gt;"error", "message" -&amp;gt; JsError.toFlatJson(errors)))
      },
      product =&amp;gt; {
        Product.add(product)
        Ok(toJson(product))
      }
    )
  }</pre>
</li>
<li id="e-c52k">We need to add the following import statement for Play's JSON libraries:<pre id="e-aJlo">import play.api.libs.functional.syntax._</pre>
</li>
<li id="e-zdUq">We will also need to add our implementation of reads for our product model inside our products controller:<pre id="e-F6TG">implicit val productReads: Reads[Product] = (
    (JsPath \ "sku").read[String] and
    (JsPath \ "title").read[String]
  )(Product.apply _)</pre>
</li>
<li id="e-EBM5">Add a new route for the product listing action in <code>foo_scala/conf/routes</code>:<pre id="e-UWWn">POST   /products       controllers.Products.postProduct</pre>
</li>
<li id="e-SKHN">Access our product creation URL route (<code>http://localhost:9000/products</code>) using <code>curl</code>:<pre id="e-Hoy3">&lt;span class="strong"&gt;&lt;strong&gt;$ curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" --data '{"sku":"JKL", "title":"VPN/Router"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; POST /products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-Length: 35&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* upload completely sent off: 35 out of 35 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 34&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"sku":"JKL","title":"VPN/Router"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-L8LD">As we look at the output of our <code>curl</code> command, you will notice that our response body now contains our newly added product.</li>
</ol>
<h2 id="e-AO0f">How it works…</h2>
<p id="e-Ea5a">In this recipe, we looked into how we can use Play to consume JSON objects by using the JSON <code>BodyParser</code> and be able to convert them to the appropriate model objects. For Java, we traversed the JSON tree, retrieved each property value, and assigned it to our local variables:</p>
<pre id="e-FCnJ">JsonNode json = request().body().asJson();
    String sku = json.findPath("sku").textValue();
   String title = json.findPath("title").textValue();</pre>
<p id="e-YE6j">For Scala, this was a little more straightforward, using the JSON <code>BodyParser</code> from Play:</p>
<pre id="e-RsGF">val post = request.body.validate[Product]
     post.fold(
      errors =&amp;gt; {
        BadRequest(Json.obj("status" -&amp;gt;"error", "message" -&amp;gt; JsError.toFlatJson(errors)))
      },
      product =&amp;gt; {
        Product.add(product)
        Ok(toJson(product))
      }
    )</pre>

<h1 id="e-bLej">Uploading files</h1>
<p id="e-by6g">For this recipe, we will learn how to upload files in Play applications. The ability to upload files is one of the more important aspects of web applications, and we will see here how Play makes file uploads straightforward and easy to handle.</p>
<h2 id="e-jsyf">How to do it…</h2>
<p id="e-dRs4">For Java, we need to take the following steps:</p>
<ol id="e-GrqE">
<li id="e-yzr9">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-ueKx">Add a new view template in <code>foo_java/app/views/form.scala.html</code> for the file upload form with the following contents:<pre id="e-I3nh">@helper.form(action = routes.Application.handleUpload, 'enctype -&amp;gt; "multipart/form-data") {
    Profile Photo: &amp;lt;input type="file" name="profile"&amp;gt;
    
    &amp;lt;div&amp;gt;
        &amp;lt;input type="submit"&amp;gt;
    &amp;lt;/div&amp;gt;
    
}</pre>
</li>
<li id="e-tflk">Modify <code>foo_java/app/controllers/Application.java</code> by adding the following actions:<pre id="e-Y2p0">import play.mvc.Http.MultipartFormData;
    import play.mvc.Http.MultipartFormData.FilePart;
    import java.nio.file.*;
    import java.io.*;    public static Result uploadForm() {
        return ok(form.render());
    }
     public static Result handleUpload() {
        MultipartFormData body = request().body().asMultipartFormData();
        FilePart profileImage = body.getFile("profile");
         if (profileImage != null) {
            try {
                String fileName = profileImage.getFilename();
                String contentType = profileImage.getContentType();
                File file = profileImage.getFile();
                 Path path = FileSystems.getDefault().getPath("/tmp/" + fileName);
                Files.write(path, Files.readAllBytes(file.toPath()));
                return ok("Image uploaded");
            } catch(Exception e) {
                return internalServerError(e.getMessage());
            }
        } else {
            flash("error", "Please upload a valid file");
            return redirect(routes.Application.uploadForm());    
        }
    }</pre>
</li>
<li id="e-agWU">Add a new routes entry for the newly-added action in <code>foo_java/conf/routes</code>:<pre id="e-OOJ2">GET   /upload_form    controllers.Application.uploadForm
  POST   /upload      controllers.Application.handleUpload</pre>
</li>
<li id="e-UIM0">Access the upload form URL route (<code>http://localhost:9000/upload_form</code>) using a web browser. You will now be able to select a file to upload in your filesystem.</li>
<li id="e-Q97k">You can verify that the file was indeed uploaded by taking a look at the <code>/tmp</code> directory:<pre id="e-BQii">&lt;span class="strong"&gt;&lt;strong&gt;$ ls /tmp&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;B82BE492-0BEF-4B2D-9A68-2664FB9C2A97.png&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-FNaV">For Scala, we need to take the following steps:</p>
<ol id="e-VqkP">
<li id="e-JYQe">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-ZwYA">Add a new view template in <code>foo_scala/app/views/form.scala.html</code> for the file upload form with the following contents:<pre id="e-rtil">@helper.form(action = routes.Application.handleUpload, 'enctype -&amp;gt; "multipart/form-data") {
    
    Profile photo: &amp;lt;input type="file" name="profile"&amp;gt;
    
    &amp;lt;div&amp;gt;
        &amp;lt;input type="submit"&amp;gt;
    &amp;lt;/div&amp;gt;
    
}</pre>
</li>
<li id="e-ZsDR">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-WlWw">def uploadForm = Action {
    Ok(views.html.form())
  }
   def handleUpload = Action(parse.multipartFormData) { request =&amp;gt;
    import java.io.File
     request.body.file("profile") match {
      case Some(profileImage) =&amp;gt; {
        val filename = profileImage.filename
        val contentType = profileImage.contentType
        profileImage.ref.moveTo(new File(s"/tmp/$filename"))
        Ok("Image uploaded")
      }
      case None =&amp;gt; {
        Redirect(routes.Application.uploadForm).flashing(
          "error" -&amp;gt; "Please upload a valid file")
      }
    }
  }</pre>
</li>
<li id="e-jRdt">Add a new routes entry for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-QgFw">GET   /upload_form    controllers.Application.uploadForm
  POST   /upload      controllers.Application.handleUpload</pre>
</li>
<li id="e-b4yS">Access the upload form URL route (<code>http://localhost:9000/upload_form</code>) using a web browser. You will now be able to select a file to upload in your filesystem.</li>
<li id="e-aB1h">You can verify that the file was indeed uploaded, by taking a look at the <code>/tmp</code> directory:<pre id="e-PbKD">&lt;span class="strong"&gt;&lt;strong&gt;$ ls /tmp&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;B82BE492-0BEF-4B2D-9A68-2664FB9C2A97.png&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-pPlh">How it works…</h2>
<p id="e-NCI8">In this recipe, we created two new actions and URL routes; the first to display our upload form template and the second to handle the actual file upload action. We added our upload view form template <code>form.scala.html</code> in the <code>app/views</code> directory. We then handled the actual file upload submission by using Play's helper methods to retrieve the uploaded file, and then proceeded to store the file in a predefined location.</p>

<h1 id="e-iz2K">Using futures with Akka actors</h1>
<p id="e-qcUY">For this recipe, we will explore how Play Framework allows us to create asynchronous controllers using futures, in conjunction with Akka actors. The ability to create asynchronous controllers provides a way for developers to trigger background jobs and execute long-running operations asynchronously without sacrificing endpoint responsiveness. Adding Akka to the mix brings a new dimension to fault-tolerant, resilient data services, which become valuable tools in a developer's toolchain in the age of maturing and sophisticating web application requirements.</p>
<h2 id="e-D1dU">How to do it…</h2>
<p id="e-hKn3">For Java, we need to take the following steps:</p>
<ol id="e-p87f">
<li id="e-AFTz">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-IJpH">Modify the application controller in <code>foo_java/app/controllers/Application.java</code> by adding the following contents:<pre id="e-Sx5x">public static Promise&amp;lt;Result&amp;gt; asyncExample() {
      ActorRef fileReaderActor = Akka.system().actorOf(Props.create(FileReaderActor.class));
      FileReaderProtocol words = new FileReaderProtocol("/usr/share/dict/words");
       return Promise.wrap(ask(fileReaderActor, words, 3000)).map(
            new Function&amp;lt;Object, Result&amp;gt;() {
                public Result apply(Object response) {
                    return ok(response.toString());
                }
            }
        );
    }</pre>
</li>
<li id="e-n2lN">We need to add the following import statement to include the necessary libraries, specifically the <code>Akka</code> libraries that we will be utilizing for this recipe:<pre id="e-YCCN">import java.util.*;
    import play.libs.Akka;
    import play.libs.F.Function;
    import static play.mvc.Results.*;
    import static akka.pattern.Patterns.ask;
    import play.libs.F.Promise;
    import akka.actor.*;</pre>
</li>
<li id="e-G0f0">We also need to add our Akka actor in <code>foo_java/app/actors/FileReaderActor.java</code> with the following contents:<pre id="e-unxf">package actors;
     import java.util.*;
    import java.util.concurrent.Callable;
    import java.nio.charset.*;
    import java.nio.file.*;
    import java.io.*;
    import scala.concurrent.ExecutionContext;
    import scala.concurrent.Future;
    import scala.concurrent.Await;
    import scala.concurrent.duration.*;
    import akka.dispatch.*;
    import akka.util.Timeout;
    import akka.actor.*;
    import play.libs.Akka;
     import static akka.dispatch.Futures.future;
     public class FileReaderActor extends UntypedActor {
      public void onReceive(Object message) throws Exception {
        if (message instanceof FileReaderProtocol) {
          final String filename = ((FileReaderProtocol) message).filename;
           Future&amp;lt;String&amp;gt; future = future(new Callable&amp;lt;String&amp;gt;() {
         public String call() {
       try {
         Path path = Paths.get(filename);
          List&amp;lt;String&amp;gt; list = Files.readAllLines(path, StandardCharsets.UTF_8);
         String[] contents = list.toArray(new String[list.size()]);
           return Arrays.toString(contents);
        } catch(Exception e) {
      throw new IllegalStateException(e);
        }
    }
        }, Akka.system().dispatcher());
      akka.pattern.Patterns.pipe(
    future, Akka.system().dispatcher()).to(getSender());
      }
    }
  }</pre>
</li>
<li id="e-jGcR">We also need to create our actor protocol class for the <code>FileReaderActor</code> in <code>foo_java/app/actors/FileReaderProtocol.java</code> with the following content:<pre id="e-Xba7">package actors;
     public class FileReaderProtocol implements java.io.Serializable {
      public final String filename;
      public FileReaderProtocol(String filename) { this.filename = filename; }
    }</pre>
</li>
<li id="e-Pcvr">Add a new route for the async example action in <code>foo_java/conf/routes</code>:<pre id="e-UpqC">GET   /async_example     controllers.Application.asyncExample</pre>
</li>
<li id="e-OKAm">Add the default <code>Akka</code> configs in <code>foo_java/conf/application.conf</code>:<pre id="e-qmjw">akka.default-dispatcher.fork-join-executor.pool-size-max = 64
    akka.actor.debug.receive = on</pre>
</li>
<li id="e-TqzR">Access the async example URL route (<code>http://localhost:9000/async_example</code>) using a web browser. You should see the contents of the local file <code>/usr/share/dict/words</code> displayed in the web browser.</li>
</ol>
<p id="e-xB60">For Scala, we need to take the following steps:</p>
<ol id="e-WP4X">
<li id="e-TuX4">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-ilVd">Modify the application controller in <code>foo_scala/app/controllers/Application.scala</code> by adding the following contents:<pre id="e-k5p2">val fileReaderActor = Akka.system.actorOf(Props[FileReaderActor], name = "fileReader")    
      def asyncExample = Action.async {
      implicit val timeout = Timeout(3 seconds)
      
       (fileReaderActor ? FileReaderProtocol("/usr/share/dict/words")).mapTo[String].map{ words =&amp;gt;
        Ok("Words: \n" + words)
      }
    }</pre>
</li>
<li id="e-yjXt">We need to add the following import statements to include the necessary libraries, specifically the <code>Akka</code> libraries we will be utilizing for this recipe:<pre id="e-K4eb">import play.api.libs.concurrent.Akka
    import play.api.Play.current
    import akka.pattern.ask
    import akka.pattern.pipe
    import akka.util.Timeout
    import akka.actor.{Props, Actor, ActorLogging}
    import scala.concurrent.duration._
    import scala.concurrent._
    import play.api.libs.concurrent.Execution.Implicits.defaultContext</pre>
</li>
<li id="e-D2Jg">We also need to add our Akka actor in the application controller for convenience:<pre id="e-Imur">case class FileReaderProtocol(filename: String)
     class FileReaderActor extends Actor with ActorLogging {
      
       def receive = {
        case FileReaderProtocol(filename) =&amp;gt; {
          val currentSender = sender
          val contents = Future {
            scala.io.Source.fromFile(filename).mkString
          }
          contents pipeTo currentSender
        }
      }
    }</pre>
</li>
<li id="e-OJbi">Add a new route for the async example action in <code>foo_scala/conf/routes</code>:<pre id="e-Cx7C">GET   /async_example     controllers.Application.asyncExample</pre>
</li>
<li id="e-ptHp">Add the default <code>Akka</code> configs in <code>foo_scala/conf/application.conf</code>:<pre id="e-oXRn">akka.default-dispatcher.fork-join-executor.pool-size-max = 64
    akka.actor.debug.receive = on</pre>
</li>
<li id="e-s0yJ">Access the async example URL route (<code>http://localhost:9000/async_example</code>) using a web browser. You should see the contents of the local file <code>/usr/share/dict/words</code> displayed in the web browser.</li>
</ol>
<h2 id="e-K6L6">How it works…</h2>
<p id="e-YTVs">In this recipe, we modified our application controller and added a new route that returns the contents of a local file <code>/usr/share/dict/words</code>. We created the action in the controller and the new route entry in the <code>conf/routes</code> file. We then created the Akka actor class and protocol class that will do the actual work of reading the file and returning its contents.</p>
<p id="e-HIHg">For Java, we need to take the following steps:</p>
<pre id="e-qH08">// Java
    Path path = Paths.get(filename);
    List&amp;lt;String&amp;gt; list = Files.readAllLines(path, StandardCharsets.UTF_8);</pre>
<p id="e-DW8Y">For Scala, we need to take the following steps:</p>
<pre id="e-za9k">// Scala
    val contents = Future {
      scala.io.Source.fromFile(filename).mkString
    }</pre>
<p id="e-qHsB">We then configured our new action to invoke the <code>Actor</code> and configured it in such a way that it returns the results asynchronously:</p>
<pre id="e-cafa">// Java
    return Promise.wrap(ask(fileReaderActor, words, 3000)).map(
      new Function&amp;lt;Object, Result&amp;gt;() {
        public Result apply(Object response) {
          return ok(response.toString());
        }
      }
    );
     // Scala
   (fileReaderActor ? FileReaderProtocol("/usr/share/dict/words"))       .mapTo[String].map{ words =&amp;gt;
       Ok("Words: \n" + words)
     }</pre>
<p id="e-zKao">We also added default <code>Akka</code> configuration settings in <code>conf/application.conf</code>:</p>
<pre id="e-FENN">akka.default-dispatcher.fork-join-executor.pool-size-max =64
    akka.actor.debug.receive = on</pre>
<p id="e-RcaV">The preceding settings allow us to set the maximum size of our default dispatcher's thread pool. In this recipe, it is set to 64. For more information about Akka dispatchers, please refer to <a href="http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html">http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html</a>.</p>
</body></html>