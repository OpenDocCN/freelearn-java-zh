<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Cameras and Game Controls"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Cameras and Game Controls</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a reusable character control</li><li class="listitem" style="list-style-type: disc">Attaching an input AppState object</li><li class="listitem" style="list-style-type: disc">Firing in FPS</li><li class="listitem" style="list-style-type: disc">Firing non-instant bullets</li><li class="listitem" style="list-style-type: disc">Creating an RTS camera AppState object</li><li class="listitem" style="list-style-type: disc">Selecting units in RTS</li><li class="listitem" style="list-style-type: disc">Making the camera follow units</li><li class="listitem" style="list-style-type: disc">Following a character with ChaseCamera</li><li class="listitem" style="list-style-type: disc">Adding a game controller and joystick input</li><li class="listitem" style="list-style-type: disc">Leaning around corners</li><li class="listitem" style="list-style-type: disc">Detecting cover automatically in a third-person game</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Introduction</h1></div></div></div><p>This chapter is about controlling avatars and cameras for various game types. Whether your game <a id="id101" class="indexterm"/>is a <span class="strong"><strong>first person shooter</strong></span> (<span class="strong"><strong>FPS</strong></span>), <span class="strong"><strong>role playing game</strong></span> (<span class="strong"><strong>RPG</strong></span>), or <a id="id102" class="indexterm"/>
<span class="strong"><strong>real-time strategy</strong></span> (<span class="strong"><strong>RTS</strong></span>) game, you'll learn some tricks that will help<a id="id103" class="indexterm"/> you get past tricky obstacles.</p><p>The chapter will rely heavily on the <code class="literal">ActionListener</code> and <code class="literal">AnalogListener</code> interfaces. These are essential when listening for the player input in jMonkeyEngine. The <code class="literal">ActionListener</code> interface will pick up any binary input such as keyboard keys or mouse<a id="id104" class="indexterm"/> buttons. The <code class="literal">AnalogListener</code> interface listens for mouse and joystick movements and other input that is either on or off.</p></div></div>
<div class="section" title="Creating a reusable character control"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating a reusable character control</h1></div></div></div><p>To<a id="id105" class="indexterm"/> start off the chapter, we will create a class that we can use for various character-controlled purposes. The example describes an FPS character, but the method is the same for any player-controlled character.</p><p>The <code class="literal">Control</code> class we'll build will be based on <code class="literal">BetterCharacterControl</code>. It might be a good idea to have a look at the class or the <code class="literal">TestBetterCharacter</code> example from the jMonkeyEngine test package if you want to find out how this works. Another good starting point would be the input examples from the same package.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Getting ready</h2></div></div></div><p>The <code class="literal">BetterCharacterControl</code> class is based on physics and requires a <code class="literal">BulletAppState</code> class to be set up in the application. The steps required to do this are described in the <span class="emphasis"><em>The ImageGenerator class</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>. To find out more about bullet and physics, refer to <a class="link" href="ch08.html" title="Chapter 8. Physics with Bullet">Chapter 8</a>, <span class="emphasis"><em>Physics with Bullet</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How to do it...</h2></div></div></div><p>Perform the following set of steps to create a reusable character control:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by creating a new class called <code class="literal">GameCharacterControl</code>, which extends <code class="literal">BetterCharacterControl</code>. This class also needs to implement <code class="literal">ActionListener</code> and <code class="literal">AnalogListener</code>. The idea here is to feed this class with actions that it can handle. To control the movement of a character, use a series of Booleans as follows:<div class="informalexample"><pre class="programlisting">boolean forward, backward, leftRotate, rightRotate, leftStrafe, rightStrafe;</pre></div></li><li class="listitem">Also, define a float field called <code class="literal">moveSpeed</code>, which will help you control how much the<a id="id106" class="indexterm"/> character will move in each update.<p>The control Booleans you added are set in the implemented <code class="literal">onAction</code> method. Note that a key will always trigger !isPressed when released (note that a key always triggers <code class="literal">isPressed == false</code> when released):</p><div class="informalexample"><pre class="programlisting">public void onAction(String action, boolean isPressed, float tpf) {
  if (action.equals("StrafeLeft")) {
    leftStrafe = isPressed;
  } else if (action.equals("StrafeRight")) {
      rightStrafe = isPressed;

  } else if (action.equals("MoveForward")) {
      forward = isPressed;

  } else if (action.equals("MoveBackward")) {
      backward = isPressed;

  } else if (action.equals("Jump")) {
      jump();
  } else if (action.equals("Duck")) {
      setDucked(isPressed);

  }
}</pre></div></li><li class="listitem">Now<a id="id107" class="indexterm"/> that you have handled the key input, put the control Booleans to be used in the <code class="literal">update</code> method. You might recognize the code if you've looked at <code class="literal">TestBetterCharacter</code>. The first thing it does is get the current direction the <code class="literal">spatial</code> object is facing in order to move forward and backwards. It also checks which direction is left for strafing, as follows:<div class="informalexample"><pre class="programlisting">public void update(float tpf) {
  super.update(tpf);
  Vector3f modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);
  Vector3f modelLeftDir = spatial.getWorldRotation().mult(Vector3f.UNIT_X);
  walkDirection.set(0, 0, 0);</pre></div></li><li class="listitem">Depending on your Booleans, the following code modifies <code class="literal">walkDirection</code>. Normally, you would multiply the result by <code class="literal">tpf</code> as well, but this is already handled in the <code class="literal">BetterCharacterControl</code> class as follows:<div class="informalexample"><pre class="programlisting">if (forward) {
  walkDirection.addLocal(modelForwardDir.mult(moveSpeed));
} else if (backward) {
  walkDirection.addLocal(modelForwardDir.negate().multLocal(moveSpeed));
}
if (leftStrafe) {
  walkDirection.addLocal(modelLeftDir.mult(moveSpeed));
} else if (rightStrafe) {
  walkDirection.addLocal(modelLeftDir.negate().multLocal(moveSpeed));
}</pre></div></li><li class="listitem">Finally, in the <code class="literal">setWalkDirection</code> method, apply <code class="literal">walkDirection</code> as follows:<div class="informalexample"><pre class="programlisting">BetterCharacterControl.setWalkDirection(walkDirection);</pre></div></li><li class="listitem">The preceding code handles moving forward, backward, and to the side. The turning and looking up and down actions of a character is normally handled by moving the mouse (or game controller), which is instead an analog input. This is handled by the <code class="literal">onAnalog</code> method. From<a id="id108" class="indexterm"/> here, we take the name of the input and apply its value to two new methods, <code class="literal">rotate</code> and <code class="literal">lookUpDown</code>, as follows:<div class="informalexample"><pre class="programlisting">public void onAnalog(String name, float value, float tpf) {
  if (name.equals("RotateLeft")) {
    rotate(tpf * value * sensitivity);
  } else if (name.equals("RotateRight")) {
  rotate(-tpf * value * sensitivity);
  } else if(name.equals("LookUp")){
  lookUpDown(value * tpf * sensitivity);
  } else if (name.equals("LookDown")){
  lookUpDown(-value * tpf * sensitivity);
  }
}</pre></div></li><li class="listitem">Now, start by handling the process of turning the character left and right. The <code class="literal">BetterCharacterControl</code> class <a id="id109" class="indexterm"/>already has<a id="id110" class="indexterm"/> nice support for turning the character (which, in this case, is the same thing as looking left or right), and you can access its <code class="literal">viewDirection</code> field directly. You should only modify the <span class="emphasis"><em>y</em></span> axis, which is the axis that goes from head to toe, by a small amount as follows:<div class="informalexample"><pre class="programlisting">private void rotate(float value){
  Quaternion rotate = new Quaternion().fromAngleAxis(FastMath.PI * value, Vector3f.UNIT_Y);
  rotate.multLocal(viewDirection);
  setViewDirection(viewDirection);
}</pre></div></li><li class="listitem">In order to handle looking up and down, you have to do some more work. The idea is to let the <code class="literal">spatial</code> object handle this. For this, you need to step back to the top of the class and add two more fields: a <code class="literal">Node</code> field called <code class="literal">head</code> and a float field called <code class="literal">yaw</code>. The <code class="literal">yaw</code> field will be the value with which you will <a id="id111" class="indexterm"/>control the rotation of the head up and down.</li><li class="listitem">In the constructor, set the location of the <code class="literal">head</code> node. The location is relative to the <code class="literal">spatial</code> object to an appropriate amount. In a normally scaled world, <code class="literal">1.8f</code> would correspond to <code class="literal">1.8</code> m (or about 6 feet):<div class="informalexample"><pre class="programlisting">head.setLocalTranslation(0, 1.8f, 0);</pre></div></li><li class="listitem">Next, you need to attach the <code class="literal">head</code> node to <code class="literal">spatial</code>. You can do this in the <code class="literal">setSpatial</code> method. When a <code class="literal">spatial</code> is supplied, first check whether it is a <code class="literal">Node</code> (or you wouldn't be able to add the head). If it is, attach the head as follows:<div class="informalexample"><pre class="programlisting">public void setSpatial(Spatial spatial) {
  super.setSpatial(spatial);
  if(spatial instanceof Node){
    ((Node)spatial).attachChild(head);
  }
}</pre></div></li><li class="listitem">Now that you have a head that can rotate freely, you can implement the method that handles looking up and down. Modify the <code class="literal">yaw</code> field with the supplied <a id="id112" class="indexterm"/>value. Then, clamp it so that it can't be rotated more than 90 degrees up or down. Not doing this might lead to weird results. Then, set the rotation for the head around the <span class="emphasis"><em>x</em></span> axis (think ear-to-ear) as follows:<div class="informalexample"><pre class="programlisting">private void lookUpDown(float value){
  yaw += value;
  yaw = FastMath.clamp(yaw, -FastMath.HALF_PI, FastMath.HALF_PI);
  head.setLocalRotation(new Quaternion().fromAngles(yaw, 0, 0));
}</pre></div></li><li class="listitem">Now, we have a character that can move and rotate like a standard FPS character. It still doesn't have a camera tied to it. To solve this, we're going to use the <code class="literal">CameraNode</code> class and hijack the application's camera. <code class="literal">CameraNode</code> gives you the ability to control the camera as if it were a node. With <code class="literal">setControlDir</code>, we instruct it to use the location and rotation of <code class="literal">spatial</code> as follows:<div class="informalexample"><pre class="programlisting">public void setCamera(Camera cam){
  CameraNode camNode = new CameraNode("CamNode", cam);
  camNode.setControlDir(CameraControl.ControlDirection.SpatialToCamera);
  head.attachChild(camNode);
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Cameras are logical objects and are not part of the scene graph. The <code class="literal">CameraNode</code> keeps an instance of Camera. It is a <code class="literal">Node</code> and propagates its own location to the Camera. It can also do the opposite and apply the Camera's location to <code class="literal">CameraNode</code> (and thus, any other <code class="literal">spatial</code> object attached to it).</p></div></div></li><li class="listitem">To use <code class="literal">GameCharacterControl</code> in an application, add the following lines of code in the <code class="literal">simpleInit</code> method of an application. Instantiate a new (invisible) <code class="literal">Node</code> instance that you can add to the <code class="literal">GameCharacterControl</code> class. Set the application's camera to be used as a character, and add it to <code class="literal">physicsSpace</code> as follows:<div class="informalexample"><pre class="programlisting">Node playerNode = new Node("Player");
GameCharacterControl charControl = new GameCharacterControl(0.5f, 2.5f, 8f);
charControl.setCamera(cam);
playerNode.addControl(charControl);
charControl.setGravity(normalGravity);

bulletAppState.getPhysicsSpace().add(charControl);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How it works...</h2></div></div></div><p>The <code class="literal">BetterCharacterControl</code> class of jMonkeyEngine already has a lot of the functionalities to handle the movement of a character. By extending it, we get access to it and we can implement the additional functionality on top of it.</p><p>The<a id="id113" class="indexterm"/> reason we use Booleans to control movement is that the events in <code class="literal">onAction</code> and <code class="literal">onAnalog</code> are not fired continuously; they are fired only when they're changed. So, pressing a key wouldn't generate more than two actions, one on pressing it and one on releasing it. With the Boolean, we ensure that the action will keep getting performed until the player releases the key.</p><p>This method waits for an action to happen, and depending on the binding parameter, it will set or unset one of our Booleans. By listening for actions rather than inputs (the actual key strokes), we can reuse this class for <span class="strong"><strong>non-player characters</strong></span> (<span class="strong"><strong>NPCs</strong></span>).</p><p>We can't handle looking up and down in the same way as we perform sideways rotations. The reason is that the latter changes the actual direction of the movement. When looking up or down, we just want the camera to look that way. The character is usually locked to the ground (it would be different in a flight simulator, though!).</p><p>As we can see, the <code class="literal">BetterCharacterControl</code> class already has ways to handle jumping and ducking. Nice!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>There's more...</h2></div></div></div><p>Let's say we would rather have a third-person game. How difficult would it be to modify this class to support that? In a later recipe, we will look at jMonkeyEngine's <code class="literal">ChaseCamera</code> class, but by inserting the following two lines of code at the end of our <code class="literal">setCamera</code> method, we will get a basic camera that follows the character:</p><div class="informalexample"><pre class="programlisting">camNode.setLocalTranslation(new Vector3f(0, 5, -5));
camNode.lookAt(head.getLocalTranslation(), Vector3f.UNIT_Y);</pre></div><p>It's all handled by <code class="literal">CamNode</code>, which offsets the camera's location in relation to its own (which follows the <code class="literal">head</code> node). After moving <code class="literal">CamNode</code>, we make sure that the camera also looks at <a id="id114" class="indexterm"/>the head (rather than the default forward).</p></div></div>
<div class="section" title="Attaching an input AppState object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Attaching an input AppState object</h1></div></div></div><p>In this <a id="id115" class="indexterm"/>recipe, we will make an <code class="literal">AppState</code> object, which will handle the player input for a character. It's a great way to add functionality to the application in a modular way. The <code class="literal">AppState</code> object we create here could easily be added during the game and removed or disabled during cut scenes or while in the game menu.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>We won't require any special assets for this recipe, but it will be beneficial to have a basic understanding of how AppState works and its purpose in jMonkeyEngine. This particular implementation of the recipe will use the character-control class created in the previous example. It can still be used to manipulate a <code class="literal">spatial</code> object directly without the <code class="literal">GameCharacterControl</code> class. This recipe will provide pointers on where to do this.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it...</h2></div></div></div><p>To attach an input <code class="literal">AppState</code> object, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start off by creating a class called <code class="literal">InputAppState</code>, extending <code class="literal">AbstractAppState</code>, and implementing <code class="literal">ActionListener</code> and <code class="literal">AnalogListener</code>.</li><li class="listitem">The <code class="literal">InputAppState</code> class needs a couple of fields to be functional. First of all, we're going to keep a reference to the application's <code class="literal">InputManager</code> in a field called <code class="literal">inputManager</code>. We're also adding a <code class="literal">GameCharacterControl</code> field called <code class="literal">character</code>. This can be replaced by any <code class="literal">spatial</code>. Lastly, we're going to have a value that controls the sensitivity of the analog controls. We do this with a float called sensitivity. Add getters and setters for character and sensitivity.</li><li class="listitem">Next, we'll set up the kinds of input we're going to handle. Strings are used by jMonkeyEngine for the mappings, but enums can be easier to manage across classes. Here, we'll use an <code class="literal">enum</code> and supply the name of the value as the mapping. We use it to create some basic FPS controls as follows:<div class="informalexample"><pre class="programlisting">public enum InputMapping{
  RotateLeft, RotateRight, LookUp, LookDown, StrafeLeft,
  StrafeRight, MoveForward, MoveBackward;
}</pre></div></li><li class="listitem">We create a method called <code class="literal">addInputMappings</code> to add these to <code class="literal">inputManager</code> and make sure it listens to them. To do this, we supply the name<a id="id116" class="indexterm"/> of the <code class="literal">enum</code> value as the mapping and bind it to a certain input as follows:<div class="informalexample"><pre class="programlisting">private void addInputMappings(){
  inputManager.addMapping(InputMapping.RotateLeft.name(), new MouseAxisTrigger(MouseInput.AXIS_X, true));
  inputManager.addMapping(InputMapping.RotateRight.name(), new MouseAxisTrigger(MouseInput.AXIS_X, false));
  inputManager.addMapping(InputMapping.LookUp.name(), new MouseAxisTrigger(MouseInput.AXIS_Y, false));
  inputManager.addMapping(InputMapping.LookDown.name(), new MouseAxisTrigger(MouseInput.AXIS_Y, true));
  inputManager.addMapping(InputMapping.StrafeLeft.name(), new KeyTrigger(KeyInput.KEY_A), new KeyTrigger(KeyInput.KEY_LEFT));
  inputManager.addMapping(InputMapping.StrafeRight.name(), new KeyTrigger(KeyInput.KEY_D), new KeyTrigger(KeyInput.KEY_RIGHT));
  inputManager.addMapping(InputMapping.MoveForward.name(), new KeyTrigger(KeyInput.KEY_W), new KeyTrigger(KeyInput.KEY_UP));
  inputManager.addMapping(InputMapping.MoveBackward.name(), new KeyTrigger(KeyInput.KEY_S), new KeyTrigger(KeyInput.KEY_DOWN));

}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>It's okay to assign several keys to the same mapping. For example, this recipe assigns both the arrow keys and the classical WASD pattern to the movement keys.</p></div></div></li><li class="listitem">Finally, in the same method, we tell <code class="literal">InputManager</code> to listen to the commands, or it won't actually fire on any of the inputs:<div class="informalexample"><pre class="programlisting">for (InputMapping i : InputMapping.values()) {
  inputManager.addListener(this, i.name());
}</pre></div></li><li class="listitem">Now, once <code class="literal">AppState</code> is attached, it runs the <code class="literal">initialize</code> method (in a thread-safe way). Here, we get the reference to the application's <code class="literal">InputManager</code> object and run the <code class="literal">addMappings</code> method we just created, as follows:<div class="informalexample"><pre class="programlisting">public void initialize(AppStateManager stateManager, Application app) {
  super.initialize(stateManager, app);
  this.inputManager = app.getInputManager();
  addInputMappings();
}</pre></div></li><li class="listitem">Once <code class="literal">InputManager</code> detects any of the actions and sends them our way, we will just forward them to the <code class="literal">GameCharacterControl</code> object by applying the sensitivity value to the analog input as follows: <div class="informalexample"><pre class="programlisting">public void onAnalog(String name, float value, float tpf) {
  if(character != null){
    character.onAnalog(name, value * sensitivity, tpf);
  }
}

public void onAction(String name, boolean isPressed, float tpf) {
  if(character != null){
    character.onAction(name, isPressed, tpf);
  }
}</pre></div></li><li class="listitem">We're actually almost done with this recipe. We just need to make sure that we reset everything when <code class="literal">AppState</code> is not to be used anymore. We do this by overriding the cleanup method. Here, we remove all the mappings and remove this instance from listeners of <code class="literal">inputManager</code> as follows:<div class="informalexample"><pre class="programlisting">public void cleanup() {
  super.cleanup();
  for (InputMapping i : InputMapping.values()) {
    if (inputManager.hasMapping(i.name())) {
      inputManager.deleteMapping(i.name());
    }
  }
  inputManager.removeListener(this);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works...</h2></div></div></div><p>The <code class="literal">AppState</code> object works <a id="id117" class="indexterm"/>with the application in a way that is similar to how <code class="literal">Control</code> works with <code class="literal">spatial</code>. They give extended functionalities in a modular way. Once it has been attached to <code class="literal">stateManager</code>, its <code class="literal">update</code> method will be called <a id="id118" class="indexterm"/>every cycle. This gives us access to the application's thread as well.<a id="id119" class="indexterm"/> It also has the <code class="literal">stateAttached</code> and <code class="literal">stateDetached</code> methods, which can be used to turn functionality on and off easily.</p></div></div>
<div class="section" title="Firing in FPS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Firing in FPS</h1></div></div></div><p>There <a id="id120" class="indexterm"/>are several ways to perform firing, and the requirements depend heavily on the type of game. This recipe will start off with the basics, which can then be extended to support the different forms of firing. We'll create the necessary functionalities to fire instant bullets; they are performance-friendly and suitable for a fairly close-quarters FPS.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Getting ready</h2></div></div></div><p>This example will be based on <code class="literal">GameCharacterControl</code> and <code class="literal">InputAppState</code> from the <span class="emphasis"><em>Creating a reusable character control</em></span> and <span class="emphasis"><em>Attaching an input AppState</em></span> <span class="emphasis"><em>object</em></span> recipes of this chapter, respectively. Familiarity with the recipes is beneficial. Further, we'll use the <code class="literal">Ray</code> class in combination with <code class="literal">CollisionResults</code> to check whether the bullet has hit anything or not.</p><p>Rays can be imagined as infinite lines and are very common in game development. This is a fast way of detecting intersections with game objects and is thus suitable for instant firing. The targets might consist of any kind of <code class="literal">spatial</code>. In this case, it's a bunch of spheres generated by the recipe's test class.</p><p>We will let<a id="id121" class="indexterm"/> the <code class="literal">InputAppState</code> class handle the firing logic, and the <code class="literal">GameCharacterControl</code> class will keep track of cool down time of the weapon, or how long it takes<a id="id122" class="indexterm"/> between each shot. The reason we don't keep everything in <code class="literal">AppState</code> is that this way, the class can be used for things other than the player's character.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How to do it...</h2></div></div></div><p>We will start by making some updates to the <code class="literal">GameCharacterControl</code> class. For the <code class="literal">GameCharacterControl</code> class, we introduce two new variables, <code class="literal">cooldownTime</code> and <code class="literal">cooldown</code>:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first is the time between shots.</li><li class="listitem">The second is the current countdown until the character can fire again. We need to add a getter for <code class="literal">cooldown</code> and the value itself is set in the following <code class="literal">onFire</code> method:<div class="informalexample"><pre class="programlisting">public void onFire(){
  cooldown = cooldownTime;
}</pre></div></li><li class="listitem">Lastly, in the update method, we need to subtract <code class="literal">cooldown</code> by <code class="literal">tpf</code> if it's more than zero.</li></ol></div><p>In <code class="literal">InputAppState</code>, we also have to make some changes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by introducing a <code class="literal">List&lt;Geometry&gt;</code> called <code class="literal">targets</code>. This is the list of things the fired rays will check for collisions against. In the <code class="literal">addInputMapping</code> method, add another mapping for <code class="literal">Fire</code>. A suitable button is the left mouse button. This is implemented as follows:<div class="informalexample"><pre class="programlisting">inputManager.addMapping(InputMapping.Fire.name(), new MouseButtonTrigger(MouseInput.BUTTON_LEFT));</pre></div></li><li class="listitem">In<a id="id123" class="indexterm"/> the <code class="literal">onAction</code> method, change the logic slightly. We add a new check for the fire action and we put the existing logic inside the <code class="literal">else</code> clause. We're telling <code class="literal">character</code> to handle all actions, except when we fire. This is implemented as follows:<div class="informalexample"><pre class="programlisting">if (name.equals("Fire")) {
  if (isPressed &amp;&amp; character.getCooldown() == 0f){
    fire();
  }
} else {
  character.onAction(name, isPressed, tpf);
}</pre></div></li><li class="listitem">Now, create a new method called <code class="literal">fire</code>. This is where we're going to add most of the new functionalities. Inside this, we first define a new <code class="literal">Ray</code> class that we place at the camera's location (if it is an FPS), and we set the direction to be the same as the camera's direction, as shown in the following code:<div class="informalexample"><pre class="programlisting">Ray r = new Ray(app.getCamera().getLocation(), app.getCamera().getDirection());</pre></div></li><li class="listitem">Then, create a new <code class="literal">CollisionResults</code> instance, which we will use to keep track of collisions. We parse through the target list to see whether <code class="literal">Ray</code> collides with any of them. All collisions are stored in the <code class="literal">CollisionResults</code> instance as follows:<div class="informalexample"><pre class="programlisting">CollisionResults collRes = new CollisionResults();
for(Geometry g: targets) {
  g.collideWith(r, collRes);
}</pre></div></li><li class="listitem">Afterwards, check whether there have been any collisions. If so, get the nearest one and display the location as follows:<div class="informalexample"><pre class="programlisting">if(collRes.size() &gt; 0){
  System.out.println("hit " + collRes.getClosestCollision().getContactPoint());
}</pre></div></li><li class="listitem">Finally, call the character's <code class="literal">onFire</code> method, <code class="literal">character.onFire();</code>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How it works...</h2></div></div></div><p>With this implementation, we handle most of the actual logic that happens when firing inside <code class="literal">InputAppState</code>. The <code class="literal">GameCharacterControl</code> class is left to keep control of whether firing is possible or not. Some further work on this could have the character play an animation and keep track of the ammunition.</p><p>The <code class="literal">Ray</code> object we're using is being fired out of the camera. This makes it easy to set both the<a id="id124" class="indexterm"/> location and direction. This would be the case for a game in iron sights or sniper mode. If you want to fire from the hip, for example, it would be slightly more complicated.</p><p>Rays are normally very fast. Using them can, however, become performance-demanding in large game worlds with complex collision shapes. This is one reason for keeping track of the items to be checked against in a list rather than using the whole <code class="literal">rootNode</code>. In other cases, it's good to first filter down the list, maybe based on the distance from the player.</p><p>The <code class="literal">CollisionResults</code> class<a id="id125" class="indexterm"/> stores collisions between <code class="literal">spatial</code> or <code class="literal">ray</code>. It contains a list of <code class="literal">CollisionResult</code> objects, which in turn has a number of useful methods for determining where a collision has occurred and between what.</p></div></div>
<div class="section" title="Firing non-instant bullets"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Firing non-instant bullets</h1></div></div></div><p>In the previous recipe, we implemented a basic form of firing that will work for many cases. The <a id="id126" class="indexterm"/>exit velocity for a bullet is usually around 300 m/s (or close to 1000 feet/s) and might seem near-instant at close range. For ranges over 30 m (approximately 90 feet), the delay starts to get noticeable though, and more realistic games might need another model. In this recipe, we'll look into a type of bullet that travels in the game world. It's still an invisible bullet, but it can easily be visualized if required.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>This recipe can be seen as a more advanced version of the previous recipe and won't require many changes to what we did there but will mainly contain additions. Almost all of the functionalities will be implemented in a new class, called <code class="literal">Bullet</code> (not to be confused with the physics engine with the same name that we use in a <a class="link" href="ch08.html" title="Chapter 8. Physics with Bullet">Chapter 8</a>, <span class="emphasis"><em>Physics with Bullet</em></span>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it...</h2></div></div></div><p>Perform the following steps to fire non-instant bullets:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's begin by defining our <code class="literal">Bullet</code> class. The <code class="literal">worldPosition</code> and <code class="literal">direction</code> variables are used by the <code class="literal">Ray</code> class as a starting position each step it takes. The <code class="literal">RANGE</code> field<a id="id127" class="indexterm"/> is a static field that defines the maximum range, inside which the bullet will be effective. The <code class="literal">distance</code> variable is the distance the<a id="id128" class="indexterm"/> bullet has traveled since it was instanced. It also needs to keep track of whether it's alive or not, for cleanup reasons. It should be said that this particular bullet is rather slow and short lived.<div class="informalexample"><pre class="programlisting">private Vector3f worldPosition;
private Vector3f direction;
private float speed = 10;
private Ray ray;
private final static int RANGE = 10;
private float distance;
private boolean alive = true;</pre></div></li><li class="listitem">To <a id="id129" class="indexterm"/>avoid unnecessary object creation, we instance <code class="literal">Ray</code> in the constructor as follows, which we'll reuse throughout the lifespan of the bullet:<div class="informalexample"><pre class="programlisting">ray = new Ray(origin, direction);
ray.setOrigin(worldPosition);</pre></div></li><li class="listitem">It's in the <code class="literal">update</code> method that most of the work is done. At the beginning, we set the ray's origin to be the current position of the bullet. The direction will stay the same, so no need to change that. We do, however, need to set limit factorized by the time passed for the update (<code class="literal">tpf</code>). The limit is also the distance the bullet has traveled since the last update, so we use this to update the current position of the bullet:<div class="informalexample"><pre class="programlisting">ray.setLimit (speed * tpf);
distance += ray.limit;
worldPosition.addLocal(direction.mult(ray.limit));</pre></div></li><li class="listitem">If the total distance is longer than the range, the bullet can be considered beyond its effective range. We set <code class="literal">alive</code> to <code class="literal">false</code> as follows so that it can be removed:<div class="informalexample"><pre class="programlisting">if(distance &gt;= RANGE){
  alive = false;
}</pre></div></li><li class="listitem">The <code class="literal">Bullet</code> class also has a <code class="literal">checkCollision</code> method. It takes a list of targets as input and tries a collision between each of them and the ray. If any collision is detected, <code class="literal">alive</code> will be set to <code class="literal">false</code> and the closest <code class="literal">CollisionResult</code> will be returned to the calling method as follows:<div class="informalexample"><pre class="programlisting">public CollisionResult checkCollision(List&lt;Collidable&gt; targets){
  CollisionResults collRes = new CollisionResults();
  for(Collidable g: targets){
    g.collideWith(ray, collRes);
  }
  if(collRes.size() &gt; 0){
    alive = false;
    return collRes.getClosestCollision();
  }
  return null;
}</pre></div></li><li class="listitem">Next, we'll add some code to the application class. It needs to keep track of <code class="literal">List&lt;Collidable&gt;</code>, called <code class="literal">targets</code> and <code class="literal">List&lt;Bullet&gt;</code>, called <code class="literal">bullets</code>.</li><li class="listitem">The <code class="literal">simpleUpdate</code> method updates the movement of all bullets by calling their<a id="id130" class="indexterm"/> update method before seeing whether any <a id="id131" class="indexterm"/>collisions have occurred or not. Any depleted bullets are removed in a way that avoids <code class="literal">ArrayIndexOutOfBounds</code> exceptions:<div class="informalexample"><pre class="programlisting">Bullet b = bullets.get(i);
b.update(tpf);
CollisionResult result = b.checkCollision(targets);
if(result != null){
  System.out.println("hit " + result);
}
if(!b.isAlive()){
  bullets.remove(b);
  bulletAmount--;
  if(i &gt; 0){
    i--;
  }
}</pre></div></li><li class="listitem">Create a<a id="id132" class="indexterm"/> <code class="literal">fire()</code> method that creates a new bullet by using the camera's location and direction as follows:<div class="informalexample"><pre class="programlisting">bullets.add(new Bullet(cam.getLocation().clone(), cam.getDirection().clone()));</pre></div></li><li class="listitem">The method is called from the InputAppState's <code class="literal">onAction</code> method, which is similar to how it looked in the previous recipe:<div class="informalexample"><pre class="programlisting">if (isPressed &amp;&amp; character.getCooldown() == 0f){
  <span class="strong"><strong>((CharacterInputTest_Firing_NonInstant) app ).fire();</strong></span>
  character.onFire();
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works...</h2></div></div></div><p>The <code class="literal">Bullet</code> class can almost be seen as a slow ray. The <code class="literal">Ray</code> instance we have in <code class="literal">Bullet</code> is mostly out of convenience, since it's already prepared to collide with targets. By incrementing the position of the ray and having a short limit for it, we have a <code class="literal">Ray</code> instance that takes<a id="id133" class="indexterm"/> little steps forward in the game world, checking for collisions in each update.</p><p>If a collision has occurred, the returned <code class="literal">CollisionResult</code> contains information about where the collision has occurred, with what, and whether it can be used to build further functionalities.</p></div></div>
<div class="section" title="Creating an RTS camera AppState object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Creating an RTS camera AppState object</h1></div></div></div><p>In this recipe, we'll try to mimic the camera and controls that are common in RTS games. The camera <a id="id134" class="indexterm"/>will mostly look down on the scene, and aside from basic movement and rotation of the camera, there will also be automatic scrolling when the mouse reaches the edges of the screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>Getting ready</h2></div></div></div><p>We're going to set up the camera and camera handling in this recipe. Loading a scene to make sure the camera works as expected would be helpful.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>How to do it...</h2></div></div></div><p>To create an RTS camera <code class="literal">AppState</code> object, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating a class that implements the <code class="literal">AnalogListener</code> and <code class="literal">ActionListener</code> interfaces so that we can receive user input from the mouse and keyboard. We'll use these to control the camera as follows:<div class="informalexample"><pre class="programlisting">public class RTSCameraAppState extends AbstractAppState implements AnalogListener, ActionListener{</pre></div></li><li class="listitem">Next, we'll define what controls we'll handle. Using an <code class="literal">enum</code> will keep things tidy, so type the following code snippet:<div class="informalexample"><pre class="programlisting">public enum InputMapping{
MoveLeft, MoveRight, MoveUp, MoveDown,
    RotateLeft, RotateRight;
}</pre></div><p>The following screenshot shows you the difference between the camera's position above the ground (half circle) and the camera's focus point (at the center):</p><div class="mediaobject"><img src="graphics/6478OS_02_03.jpg" alt="How to do it..."/></div></li><li class="listitem">We<a id="id135" class="indexterm"/> then set up some things in the <code class="literal">initialize</code> method. Rather than having a completely top-down perspective, we give the camera a little tilt with <code class="literal">lookAtDirection</code> and a unit vector. Then, we move the <a id="id136" class="indexterm"/>camera further away from the ground with the <code class="literal">camDistance</code> variable. There is a reason we do this and don't simply set the camera's location. By doing it this way, we can more easily get the location the camera is looking at. This will come in handy if we want to add more advanced features:<div class="informalexample"><pre class="programlisting">private Vector3f camLocation = new Vector3f(0, 20, 0);
private Vector3f lookAtDirection = new Vector3f(0, -0.8f, -0.2f);

public void initialize(AppStateManager stateManager, Application app) {
  this.cam = app.getCamera();cam.lookAtDirection(lookAtDirection, Vector3f.UNIT_Y);
  camLocation.set(cam.getDirection().mult(-camDistance));
  cam.setLocation(camLocation);
  this.inputManager = app.getInputManager();
  addInputMappings();
}</pre></div></li><li class="listitem">Lastly, add the keys that we'll listen to <code class="literal">inputManager</code>:<div class="informalexample"><pre class="programlisting">private void addInputMappings(){
  inputManager.addMapping(InputMapping.MoveLeft.name(), new KeyTrigger(KeyInput.KEY_A), new KeyTrigger(KeyInput.KEY_LEFT));
  inputManager.addMapping(InputMapping.MoveRight.name(), new KeyTrigger(KeyInput.KEY_D), new KeyTrigger(KeyInput.KEY_RIGHT));
...[repeat for all keys]... InputMapping.MoveDown.name(),InputMapping.RotateLeft.name(),InputMapping.RotateRight.name()});
}</pre></div></li><li class="listitem">Now to the <code class="literal">onAction</code> method, where any calls to these mappings will end up. Since <a id="id137" class="indexterm"/>we have an <code class="literal">enum</code>, we can use a switch to see what kind of input it is and set our Booleans accordingly:<div class="informalexample"><pre class="programlisting">public void onAction(String name, boolean isPressed, float tpf) {
  InputMapping input = InputMapping.valueOf(name);
  switch(input){
    case MoveUp:
      moveUp = isPressed;
      break;
      [repeat for all actions]      case RotateRight:
      rotateRight = isPressed;
      break;
  }
}</pre></div></li><li class="listitem">Let's have a look at the <code class="literal">update</code> method, where we will put these Booleans to use. An <a id="id138" class="indexterm"/><code class="literal">update</code> method is called automatically every frame, and we also get to know how much time (in seconds) has passed since the last update, in <code class="literal">tpf</code>. We start by storing the camera's current location and initialize a <code class="literal">Vector3f</code> object, which we'll use for our movement delta as follows:<div class="informalexample"><pre class="programlisting">public void update(float tpf) {
  super.update(tpf);
  camLocation = cam.getLocation();
  Vector3f tempVector = new Vector3f();</pre></div></li><li class="listitem">Next, we look to see if any of our <code class="literal">movement</code> Booleans are <code class="literal">true</code> and apply this to <code class="literal">tempVector</code> as follows:<div class="informalexample"><pre class="programlisting">if(moveUp){
  tempVector.addLocal(0, 0, 1f);
} else if(moveDown){
  tempVector.addLocal(0, 0, -1f);
}
if(moveLeft){
  tempVector.addLocal(1f, 0, 0);
} else if (moveRight){
  tempVector.addLocal(-1f, 0, 0);
}</pre></div></li><li class="listitem">To keep the movement speed constant, regardless of the frame rate, we multiply <code class="literal">tempVector</code> by the <code class="literal">tpf</code>, and then we also multiply it by our <code class="literal">moveSpeed</code> variable. Then, we add it to <code class="literal">camLocation</code> as follows:<div class="informalexample"><pre class="programlisting">tempVector.multLocal(tpf).multLocal(moveSpeed);
camLocation.addLocal(tempVector);</pre></div></li><li class="listitem">At the end of the method, we set the camera's location to the modified stored location as follows:<div class="informalexample"><pre class="programlisting">cam.setLocation(camLocation);</pre></div></li><li class="listitem">If we try <code class="literal">AppState</code> now, we would be able to scroll across the scene with our keys. We still have mouse controls and rotation to take care of.</li><li class="listitem">Let's begin<a id="id139" class="indexterm"/> with rotation. We will handle it <a id="id140" class="indexterm"/>through a method called <code class="literal">rotate</code>. The supplied value is our <code class="literal">rotateSpeed</code> variable, from which we'll extract a <code class="literal">Quaternion</code> rotated around the <span class="emphasis"><em>y</em></span> axis. We then multiply the Quaternion with the camera's rotation as follows:<div class="informalexample"><pre class="programlisting">private void rotate(float value){
  Quaternion rotate = new Quaternion().fromAngleAxis(FastMath.PI * value, Vector3f.UNIT_Y);
  rotate.multLocal(cam.getRotation());
  cam.setRotation(rotate);
}</pre></div></li><li class="listitem">Furthermore, we need to make a few alterations to the <code class="literal">update</code> method. First, we look to see whether the user has pressed any of the rotation keys and call the <code class="literal">rotate</code> method:<div class="informalexample"><pre class="programlisting">if(rotateLeft){
  rotate(rotateSpeed);
} else if (rotateRight){
  rotate(-rotateSpeed);
}</pre></div></li><li class="listitem">The next piece is a bit trickier, and we perform it just above the line where we multiply <code class="literal">tempVector</code> by <code class="literal">moveSpeed</code> (highlighted). We multiply <code class="literal">tempVector</code> by the camera's rotation to make sure that we get the movement across the correct axes. Then, since the camera is slightly tilted, we negate any movement along the <span class="emphasis"><em>y</em></span> axis. The best way to understand what would happen is to probably remove this line and try it out as follows:<div class="informalexample"><pre class="programlisting">cam.getRotation().multLocal(tempVector);
tempVector.multLocal(1, 0, 1).normalizeLocal();
<span class="strong"><strong>tempVector.multLocal(tpf).multLocal(moveSpeed);</strong></span>
</pre></div></li><li class="listitem">That's rotation taken care of! It's pretty common in RTS or top-down games to scroll by moving the mouse to the extremes of the screen. So, let's add functionalities for that. The following code snippet should be added in the <code class="literal">update</code> method above the rotation checks:<div class="informalexample"><pre class="programlisting">Vector2f mousePos2D = inputManager.getCursorPosition();
if(mousePos2D.x &gt; 0 &amp;&amp; mousePos2D.x &lt; cam.getWidth() / 10f){
  tempVector.addLocal(1f, 0, 0);
} else if(mousePos2D.x &lt; cam.getWidth() &amp;&amp; mousePos2D.x &gt; cam.getWidth() - cam.getWidth() / 10f){
  tempVector.addLocal(-1f, 0, 0);
}
if(mousePos2D.y &gt; 0 &amp;&amp; mousePos2D.y &lt; cam.getHeight() / 10f){
  tempVector.addLocal(0, 0, -1f);
} else if(mousePos2D.y &lt; cam.getHeight() &amp;&amp; mousePos2D.y &gt; cam.getHeight() - cam.getHeight() / 10f){
  tempVector.addLocal(0, 0, 1f);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How it works...</h2></div></div></div><p>The <code class="literal">AppState</code> object listens for the input from the player via <code class="literal">InputManager</code> and applies it to<a id="id141" class="indexterm"/> the application's camera. In just one short class, we've produced an RTS-like camera behavior.</p><p>Lastly, in this recipe, we added functionalities to pan the camera if the mouse cursor was near the edges of the screen. We used <code class="literal">InputManager.getCursorPosition()</code>, which is a very<a id="id142" class="indexterm"/> convenient method that returns the position of the mouse in the screen space. The bottom-left part of the screen has an x,y coordinate of 0,0. The top-left part of the screen has an <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span> coordinate that is the same as the height and width of the screen in pixels. The next <code class="literal">if</code> statements check whether the<a id="id143" class="indexterm"/> cursor is in the 10 percent of the outermost portion of the camera (which in this case is the same as the screen) and modify <code class="literal">tempVector</code> accordingly.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>There's more...</h2></div></div></div><p>That's nice and all, but if we have terrain in our scene, which is not flat, the camera might very well end up below the ground level. How can we remedy this? An easy way is to use ray casting to check for the height of the terrain where the camera is looking. This can be implemented as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to make sure the terrain has <code class="literal">CollisionShape</code>:<div class="informalexample"><pre class="programlisting">terrain.addControl(new RigidBodyControl(0));</pre></div></li><li class="listitem">By supplying <code class="literal">0</code> to <code class="literal">RigidBodyControl</code>, we say that it doesn't have any mass (and it won't be affected by gravity, if there were any). Since we're not supplying <code class="literal">CollisionShape</code>, <code class="literal">MeshCollisionShape</code> will be created. Since the terrain is of an irregular shape, a primitive (such as a box) isn't usable.</li><li class="listitem">Next, we need to create a field for the terrain in <code class="literal">AppState</code> and a setter as well.</li><li class="listitem">To actually find out the height of the terrain, we create a method called <code class="literal">checkHeight</code>, which<a id="id144" class="indexterm"/> returns the height as float.</li><li class="listitem">Inside <code class="literal">checkHeight</code>, we shoot <code class="literal">Ray</code>, which originates from the camera's location in the direction the camera is facing. An alternative could be to shoot it down to get the height directly below the camera, as follows:<div class="informalexample"><pre class="programlisting">Ray ray = new Ray(cam.getLocation(), cam.getDirection());
CollisionResults results = new CollisionResults();terrain.collideWith(ray, results);</pre></div></li><li class="listitem">If we<a id="id145" class="indexterm"/> get a result from our ray, we get the <code class="literal">y</code> value from the collision point and return it as follows:<div class="informalexample"><pre class="programlisting">height = results.getClosestCollision().getContactPoint().y;</pre></div></li><li class="listitem">Now, in the <code class="literal">update</code> method, just above the line where we set the location, we call the <code class="literal">checkHeight</code> method. Be sure to apply the <code class="literal">camDistance</code> variable in order to get the correct offset! This is implemented as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>camLocation.setY(checkHeight() + camDistance);</strong></span>
cam.setLocation(camLocation);</pre></div></li></ol></div></div></div>
<div class="section" title="Selecting units in RTS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Selecting units in RTS</h1></div></div></div><p>In this<a id="id146" class="indexterm"/> recipe, we'll show you how the selection of units in an RTS can <a id="id147" class="indexterm"/>work and also implement functionalities to show you when a unit has been selected. We'll use <code class="literal">AppState</code>, which handles mouse selection and we will also create a new <code class="literal">Control</code> class to be used by any <code class="literal">spatial</code> we want to be made selectable. In the recipe, Control will display a marker at the feet of the selected <code class="literal">spatial</code>, but it can easily be extended to do other things as well.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>Getting ready</h2></div></div></div><p>This recipe will work fine if you have already started creating a game where you would like to select things by clicking on them or if you've completed the previous recipe. The least you will need for this recipe is a scene with something to click on. In the text, we will refer to <code class="literal">TestScene</code>, which was created in <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>, and the Jaime model which is used in it. It is assumed that you have some experience in action handling. If not, it's recommended that you refer to the <span class="emphasis"><em>Attaching an input AppState object</em></span> recipe of this chapter to get an introduction to it.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How to do it...</h2></div></div></div><p>Perform the following steps to select units in RTS:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by creating the Control class and name it <code class="literal">SelectableControl</code>. It should extend <code class="literal">AbstractControl</code>.</li><li class="listitem">The class only has two fields: selected, which keeps track of whether the <code class="literal">spatial</code> field is selected or not (duh), and marker, which is another <code class="literal">spatial</code> field to show when selected is true.</li><li class="listitem">The <a id="id148" class="indexterm"/>only logic in the <a id="id149" class="indexterm"/>class is in the <code class="literal">setSelected</code> method; we let it handle attaching or detaching the marker:<div class="informalexample"><pre class="programlisting">public void setSelected(boolean selected) {
  this.selected = selected;
  if (marker != null) {
    if (this.selected) {
      ((Node) spatial).attachChild(marker);
    } else {
      ((Node) spatial).detachChild(marker);
    }
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>The method assumes that the <code class="literal">spatial</code> is actually a <code class="literal">Node</code>. If it is not a <code class="literal">Node</code>, the class can do other things, such as changing the color parameter of <code class="literal">Material</code> to indicate that it is selected.</p></div></div></li><li class="listitem">We might want to display different markers for different types of selections, so let's make it flexible by adding a setter method for the marker.</li><li class="listitem">Now, we create a new <code class="literal">AppState</code> class called <code class="literal">SelectAppState</code>. It should extend <code class="literal">AbstractAppState</code> and<a id="id150" class="indexterm"/> implement <code class="literal">ActionListener</code> to receive mouse click events.</li><li class="listitem">We'll add two fields, one static string to represent the mouse click, and a <code class="literal">List&lt;Spatial&gt;</code> called <code class="literal">selectables</code> where it will store anything that is selectable, as follows:<div class="informalexample"><pre class="programlisting">private static String LEFT_CLICK = "Left Click";
private List&lt;Spatial&gt; selectables = new ArrayList&lt;Spatial&gt;();</pre></div></li><li class="listitem">The <code class="literal">initialize</code> method should look familiar if you've read any of the other game control recipes. We add a mapping for <code class="literal">LEFT_CLICK</code> and register it with the application's <code class="literal">InputManager</code> to ensure it listens for it.</li><li class="listitem">The only thing the <code class="literal">onAction</code> method will currently do is to trigger the <code class="literal">onClick</code> method when the left mouse button is pressed.</li><li class="listitem">Mouse selection (or picking) works by shooting <code class="literal">Ray</code> from the position of the mouse cursor into the screen. We begin by getting the position of the mouse cursor on the screen as follows:<div class="informalexample"><pre class="programlisting">private void onClick() {
  Vector2f mousePos2D = inputManager.getCursorPosition();</pre></div></li><li class="listitem">Then, we<a id="id151" class="indexterm"/> get the position this represents in the game <a id="id152" class="indexterm"/>world as follows:<div class="informalexample"><pre class="programlisting">Vector3f mousePos3D = app.getCamera().getWorldCoordinates(mousePos2D, 0f);</pre></div></li><li class="listitem">Now, we can see what direction this would be by extending the position deeper into the camera's projection, as follows:<div class="informalexample"><pre class="programlisting">Vector3f clickDir = mousePos3D.add(app.getCamera().getWorldCoordinates(mousePos2D, 1f)).normalizeLocal();</pre></div><p>The following figure shows you how <code class="literal">BoundingVolume</code>, in the shape of a box, can enclose the character:</p><div class="mediaobject"><img src="graphics/6478OS_02_04.jpg" alt="How to do it..."/></div></li><li class="listitem">We define <code class="literal">Ray</code> using <code class="literal">mousePos3D</code> as the origin and <code class="literal">clickDir</code> as the direction and a <code class="literal">CollisionResults</code> instance to store any collisions that will occur.</li><li class="listitem">Now, we can define a <code class="literal">for</code> loop that goes through our <code class="literal">selectables</code> list and checks whether <code class="literal">Ray</code> intersects with any of <code class="literal">BoundingVolumes</code>. The <code class="literal">CollisionResults</code> instance adds them to a list, and we can then retrieve the closest collision which, for most cases, is the most relevant one, as follows:<div class="informalexample"><pre class="programlisting">for (Spatial spatial : selectables) {
  spatial.collideWith(ray, results);
}

CollisionResult closest = results.getClosestCollision();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>It's a good idea to have a look at the <code class="literal">CollisionResults</code> class as well as <code class="literal">CollisionResult</code>, as these classes already keep track of many useful things that will save valuable coding time.</p></div></div></li><li class="listitem">After this, we can parse through our <code class="literal">selectable</code> list to see whether the <code class="literal">spatial</code> that was clicked on has any of the items in the list. If it is, we call the following code:<div class="informalexample"><pre class="programlisting">spatial.getControl(SelectableControl.class).setSelected(true);</pre></div></li><li class="listitem">Depending on the requirements, we might want to deselect all other spatials at this<a id="id153" class="indexterm"/> point. If we're using nodes, we might also <a id="id154" class="indexterm"/>need to see whether it is any of the spatial's children that were hit by the ray as well.</li><li class="listitem">To test this, we can use the same class used in the previous recipe, with a few additional lines.</li><li class="listitem"> First of all, we need to create and attach <code class="literal">SelectAppState</code> as follows:<div class="informalexample"><pre class="programlisting">SelectAppState selectAppState = new SelectAppState();
stateManager.attach(selectAppState);</pre></div></li><li class="listitem">Create <code class="literal">SelectableControl</code> and something that can be used as a marker (in this case, it will be a simple Quad).</li><li class="listitem">Lastly, we need to add <code class="literal">SelectableControl</code> to our Jaime model, and then add Jaime as a selectable to <code class="literal">AppState</code> as follows:<div class="informalexample"><pre class="programlisting">jaime.addControl(selectableControl);
selectAppState.addSelectable(jaime);</pre></div></li><li class="listitem">If we now run the example and click on Jaime, the Quad should be rendered near his feet.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How it works...</h2></div></div></div><p>This example shows you one of the strengths of using <code class="literal">Control</code> and <code class="literal">AppState</code>, as it's easy to add functionalities to a <code class="literal">spatial</code> object as long as the logic is kept modular. Another (although possibly less effective) way of performing the selection would be to run a collision check against all <code class="literal">spatial</code> objects in a scene and use <code class="literal">Spatial.getControl (SelectableControl.class)</code> to see whether any of the spatials should be possible to select.</p><p>In this recipe, the items in the <code class="literal">selectables</code> list extend the <code class="literal">Spatial</code> class, but the only actual requirement is that the objects implement the <code class="literal">Collidable</code> interface.</p><p>When shooting the ray, we get the position of the mouse cursor from <code class="literal">InputManager</code>. It's a <code class="literal">Vector2f</code> object, where <code class="literal">0,0</code> is the bottom-left corner, and the top-right corner equals the height and width of the screen (in units). After this, we use <code class="literal">Camera.getWorldCoordinates</code> to give us a 3D position of the mouse click (or any position on the screen). To do this, we must supply a depth value. This is between 0, which is<a id="id155" class="indexterm"/> closest to the screen, and 1f, into infinity. The direction would<a id="id156" class="indexterm"/> then be the difference between the nearest and farthest value, and it would be normalized.</p></div></div>
<div class="section" title="Making the camera follow units"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Making the camera follow units</h1></div></div></div><p>This recipe will cover some principles on how to make the camera follow something in the game<a id="id157" class="indexterm"/> world. While it might seem like an easy task at first, there are some tricky bits too.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>Getting ready</h2></div></div></div><p>The recipe will build upon the <span class="emphasis"><em>Creating an RTS camera AppState object</em></span> recipe of this chapter. All of the steps described in this recipe will be applied to <code class="literal">AppState</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>How to do it...</h2></div></div></div><p>To make the camera follow units, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by adding two new variables, which we'll use for the new functionality. A Vector3f variable, called <code class="literal">targetLocation</code>, will be used to track<a id="id158" class="indexterm"/> the target, and a Boolean variable called <code class="literal">follow</code>, will be used to declare whether the camera should track the target or not. These are set from external classes.</li><li class="listitem">Out of convenience, we also define a final Vector3f variable, called <code class="literal">UNIT_XZ</code>, which we set to<code class="literal">(1f, 0, 1f)</code>. We'll use this to convert 3D positions to 2D.</li><li class="listitem">Then, we need to add some functionality in the <code class="literal">update</code> method just before <code class="literal">cam.setLocation(camLocation);</code>.</li><li class="listitem">First, we add a check to see whether the camera has been moved by the player. If so, we turn off the tracking as follows:<div class="informalexample"><pre class="programlisting">if(tempVector.length() &gt; 0){
  follow = false;
}</pre></div></li><li class="listitem">Since the camera is up in the air and the target is (most likely) on the ground, we transform the camera's location to a position on the same horizontal plane as the target. The <code class="literal">targetLocation</code> vector is pretty simple to handle. We just flatten it by zeroing on the <code class="literal">Y</code> value as follows:<div class="informalexample"><pre class="programlisting">Vector3f targetLocation2D = targetLocation.mult(UNIT_XZ);</pre></div></li><li class="listitem">The <a id="id159" class="indexterm"/>camera is a bit trickier; since we're interested in the target's position in relation to the point the camera is looking at, we need to first find out where it is looking. First, we get the relative position of the point the camera is looking at by multiplying the height with the direction as follows:<div class="informalexample"><pre class="programlisting">Vector3f camDirOffset = cam.getDirection().mult(camDistance);</pre></div></li><li class="listitem">Then, we add it to the camera's location (you can say that we project it on the ground) to get its world position. Finally, we flatten this as well with <code class="literal">UNIT_XZ</code> as follows:<div class="informalexample"><pre class="programlisting">Vector3f camLocation2D = camLocation.add(camDirOffset).multLocal(UNIT_XZ);</pre></div></li><li class="listitem">We're using a linear interpolation that moves the camera's focus point 30 percent closer to the target location each cycle. Then, we reverse the addition we did earlier (or unproject) to get a new 3D position for the camera. The distance check is optional, but since we're going to use interpolation, we might save a few calculations by only interpolating if the distance is above a certain threshold as follows:<div class="informalexample"><pre class="programlisting">if(targetLocation2D.distance(camLocation2D) &gt; 0.01f){
  camLocation2D.interpolate(targetLocation2D, 0.3f);
  camLocation.set(camLocation2D);
  camLocation.subtractLocal(camDirOffset);</pre></div></li><li class="listitem">To show that these changes work, we need to change a few things in our test application. We can grab Jaime from our scene and use his translation as the target location. We use <code class="literal">worldTranslation</code> and not <code class="literal">localTranslation</code> in this case:<div class="informalexample"><pre class="programlisting">appState.setTargetLocation(jaime.getWorldTranslation());
appState.setFollow(true);</pre></div></li><li class="listitem">Then, in the <code class="literal">update</code> method of the test case, we make him slowly move along the <span class="emphasis"><em>x</em></span> axis as follows:<div class="informalexample"><pre class="programlisting">jaime.move(0.2f * tpf, 0, 0);</pre></div></li><li class="listitem">While running the application, we should see the camera follow Jaime until we move it manually.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How it works...</h2></div></div></div><p>Another way of handling it would be not to move the camera during the input but the actual point it looks at, and have the camera troll along. No matter which way you choose to do it though, practicing and thus getting a better understanding of these trigonometric problems is always a good idea.<a id="id160" class="indexterm"/>
</p><p>Since we're using linear interpolation here, <code class="literal">camLocation2D</code> will never actually reach <code class="literal">targetLocation</code>; it'll just get infinitely closer. This is why an <code class="literal">if</code> statement can be useful in these cases to see whether it's worth actually changing the distance or not. Finding the right threshold to break off is empiric and varies from case to case.</p></div></div>
<div class="section" title="Following a character with ChaseCamera"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Following a character with ChaseCamera</h1></div></div></div><p>In this recipe, we'll explore jMonkeyEngine's <code class="literal">ChaseCamera</code> class. This camera is a bit different <a id="id161" class="indexterm"/>from the previous cameras we've explored <a id="id162" class="indexterm"/>since we don't have direct control over its position. It is not like the camera-on-a-stick method we tried in the <span class="emphasis"><em>Creating a reusable character control</em></span> recipe. While it still follows and looks at the character, it can float around the character more freely and also be controlled by the player.</p><p>The default control for the camera is to hold down the left mouse button and drag it to rotate the camera around the character. This is a very common control pattern in third-person games on consoles, where you rotate the camera with the left stick and control the character with the right.</p><p>We will implement a behavior where the character moves in the direction the camera is facing rather than the direction the character is facing when you press the forward key. This is common in console games.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>Getting ready</h2></div></div></div><p>Out of convenience, we'll extend, or modify, the <code class="literal">GameCharacterControl</code> class from earlier. This way, we'll get some of the basic functionality and save some time.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>How to do it...</h2></div></div></div><p>To start off, we can create a new <code class="literal">SimpleApplication</code> class in which we'll apply the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To initialize the camera, you supply the application's camera, <code class="literal">spatial</code>, to be followed, and the input manager, as follows:<div class="informalexample"><pre class="programlisting">ChaseCamera chaseCam = new ChaseCamera(cam, playerNode, inputManager);</pre></div></li><li class="listitem">The <code class="literal">ChaseCamera</code> class has lots of settings to suit different kinds of games. To start off, we turn off the need to hold down the left mouse button to rotate the camera. It's not something we want for this recipe. This is implemented as follows:<div class="informalexample"><pre class="programlisting">chaseCam.setDragToRotate(false);</pre></div></li><li class="listitem">We do, however, want smooth movement for the camera. For this, type the following line of code:<div class="informalexample"><pre class="programlisting">chaseCam.setSmoothMotion(true);</pre></div></li><li class="listitem">By <a id="id163" class="indexterm"/>default, the camera will focus<a id="id164" class="indexterm"/> on the origin point of <code class="literal">spatial</code>, which in this case, would be Jaime's feet. We can easily make it look at a higher-up point, such as <code class="literal">waist.chaseCam.setLookAtOffset(new Vector3f(0, 1f, 0));</code>.</li><li class="listitem">Next, we set some distance restrictions for the camera. There is no guarantee that it will stay within those boundaries though. It especially seems to violate <code class="literal">minDistance</code>:<div class="informalexample"><pre class="programlisting">chaseCam.setDefaultDistance(7f);
chaseCam.setMaxDistance(8f);
chaseCam.setMinDistance(6f);</pre></div></li><li class="listitem">The <code class="literal">ChasingSensitivity</code> method defines how quickly the camera will follow<a id="id165" class="indexterm"/> <code class="literal">spatial</code>. If it's <code class="literal">1</code>, it will follow slowly and if it's <code class="literal">5</code>, it will follow quickly. We want the camera to be pretty responsive in this recipe:<div class="informalexample"><pre class="programlisting">chaseCam.setChasingSensitivity(5);</pre></div></li><li class="listitem">The following<code class="literal"> RotationSpeed</code> method defines how quickly the camera moves <a id="id166" class="indexterm"/>when moving it:<div class="informalexample"><pre class="programlisting">chaseCam.setRotationSpeed(10);</pre></div></li><li class="listitem">Now, we have a basic setup for <code class="literal">ChaseCamera</code>. Let's see what we need to do to the <code class="literal">GameCharacterControl</code> class to suit this kind of game.</li><li class="listitem">We can easily apply the behavior where forward is the direction of the camera by replacing the two lines, and setting <code class="literal">modelForwardDir</code> and <code class="literal">modelLeftDir</code> in the <code class="literal">update</code> method:<div class="informalexample"><pre class="programlisting">Vector3f modelForwardDir = cam.getRotation().mult(Vector3f.UNIT_Z).multLocal(1, 0, 1);
Vector3f modelLeftDir = cam.getRotation().mult(Vector3f.UNIT_X);</pre></div></li><li class="listitem">Since we don't directly control the characters' view direction anymore, we can set it to always be the last direction the character faced (when moving) as follows:<div class="informalexample"><pre class="programlisting">viewDirection.set(walkDirection);</pre></div></li><li class="listitem">At the end of the method, we mustn't forget to apply it to <code class="literal">PhysicsCharacter</code> as follows:<div class="informalexample"><pre class="programlisting">setViewDirection(viewDirection);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How it works...</h2></div></div></div><p>The <code class="literal">ChaseCamera</code> class<a id="id167" class="indexterm"/> is a convenient class that offloads a lot of camera handling from the coder. It has a lot of settings that can be tweaked to get the desired behavior. Camera tweaking is a delicate and time-consuming matter, and if you're working in a team, this is something a designer might do if the properties would be exposed in a text file and loaded during startup.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>There's more…</h2></div></div></div><p>If you <a id="id168" class="indexterm"/>press forward and then rotate the camera, the <a id="id169" class="indexterm"/>character will move in that direction, instead. In many games of this type, however, the character would keep running in the direction it had before the player rotated the camera. We can apply this behavior to our character with a few tweaks.</p><p>To do this, we need to change <code class="literal">modelForwardDir</code> and <code class="literal">modelLeftDir</code> into private fields in the class. Then, we make sure we only update these when the character isn't receiving any input from the player. In this recipe, this would mean an <code class="literal">if</code> statement, as follows:</p><div class="informalexample"><pre class="programlisting">if(!forward &amp;&amp; !backward &amp;&amp; !leftStrafe &amp;&amp; !rightStrafe){
  modelForwardDir = cam.getRotation().mult(Vector3f.UNIT_Z).multLocal(1, 0, 1);
  modelLeftDir = cam.getRotation().mult(Vector3f.UNIT_X);
}</pre></div></div></div>
<div class="section" title="Adding a game controller or joystick input"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Adding a game controller or joystick input</h1></div></div></div><p>So far, we've <a id="id170" class="indexterm"/>used the mouse and keyboard for input. It's the most common <a id="id171" class="indexterm"/>way to handle controls on a PC, but let's explore the game controller and joystick support in jMonkeyEngine a bit. Writing code for a game controller is not very difficult. The tricky part is being agnostic enough to support the wide range of devices out there. Gone are the days when a joystick only had four directions and a fire button.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>Getting ready</h2></div></div></div><p>Like in many recipes in this chapter, we'll use <code class="literal">InputAppState</code> from the <span class="emphasis"><em>Attaching an input AppState object</em></span> recipe. This recipe will be fine to apply to any input handling class. Naturally, some kind of input device is necessary as well.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How to do it...</h2></div></div></div><p>To add a <a id="id172" class="indexterm"/>game controller or joystick input, perform the following <a id="id173" class="indexterm"/>steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, any controllers that the system recognizes will be available through <code class="literal">inputManager.getJoysticks()</code>. We'll create a new method called <code class="literal">assignJoysticks()</code> where we apply this.</li><li class="listitem">These controllers might turn up differently, in no particular order. It also seems as if they can sometimes show duplicate axes or some axes as separate controls. How can we handle this? The safest way might just be to have a <code class="literal">for</code> loop, parsing all controllers and trying to map them to the controls as follows:<div class="informalexample"><pre class="programlisting">Joystick[] joysticks = inputManager.getJoysticks();
  if (joysticks != null){
    for( Joystick j : joysticks ) {
      for(JoystickAxis axis : j.getAxes()){</pre></div></li><li class="listitem">A difference between keyboard and mouse mapping is that we don't actually need to add new mappings to <code class="literal">InputManager</code>. Instead, we tell the joystick what actions to emit. In this case, it's the <span class="emphasis"><em>x</em></span> axis on the left stick that is assigned the strafing action as follows:<div class="informalexample"><pre class="programlisting">axis.assignAxis(InputMapping.StrafeRight.name(), InputMapping.StrafeLeft.name());</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>The <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes are often simple to map, usually on the left stick on the controller. The right one might not be as obvious. In this example, it's mapped to the rotation-X and rotation-Y axes, but might be mapped to the <span class="emphasis"><em>z</em></span> axis, or rotation-Z as well.</p></div></div></li><li class="listitem">In the same way, we can assign buttons to emit specific actions:<div class="informalexample"><pre class="programlisting">button.assignButton("Fire");</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>How it works...</h2></div></div></div><p>A joystick is an input device, just like the mouse or keyboard. While there is a way to map the actions in the same way, with <code class="literal">InputManager.addMapping()</code>, the recommended way is to do the reverse and assign actions to the joystick instead. Remember that <code class="literal">InputManager</code> still needs to listen to the mappings.</p><p>Mapping buttons is even trickier than axes. First of all, there are two types of buttons, analog <a id="id174" class="indexterm"/>and digital. On a controller, usually the lower-right and<a id="id175" class="indexterm"/> left buttons controlled by the index fingers are analog, whereas all other buttons usually are digital. In jMonkeyEngine, everything analog is an axis. So, you will find that most likely, these will be reported as an axis.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>On my controller, a Razer Hydra, left and right triggers are reported as the <span class="emphasis"><em>z</em></span> axis.</p></div></div><p>As if that's not enough, all you have to work with is a button index. Fortunately, with most game controllers emulating one of the big brands of console makers, some kind of standard can be expected. However, there are exceptions, and for any serious game, an interface where the user can remap their device is a must.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>There's more…</h2></div></div></div><p>There's a good, visual test example in the jMonkeyEngine project called <code class="literal">TestJoystick</code>, where you <a id="id176" class="indexterm"/>can instantly see the mapping of the attached controller and the corresponding action of each input.</p><p>The following figure shows you a view in the TestJoystick example:</p><div class="mediaobject"><img src="graphics/6478OS_02_02.jpg" alt="There's more…"/></div></div></div>
<div class="section" title="Leaning around corners"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Leaning around corners</h1></div></div></div><p>If you're<a id="id177" class="indexterm"/> making a sneaker or tactical shooter game, a common feature is to be able to lean around corners. This is used to scout without being seen or shooting without exposing yourself too much. In this recipe, we'll develop a way to do this with our <code class="literal">GameCharacterControl</code> class. We will implement functionalities to both handle leaning with keys (such as the shoulder buttons on a gamepad) and freeform leaning with the mouse.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>Getting ready</h2></div></div></div><p>This recipe <a id="id178" class="indexterm"/>will expand on the <code class="literal">GameCharacterControl</code> and <code class="literal">InputAppState</code> classes from the beginning of the chapter, but it should be easy to adapt to your own project. It is mostly used in FPS games, and this is what we will build it for.</p><p>Leaning in this example will emulate the player character moving the upper body. To achieve this and to save us some calculations on how much the camera should be offset when leaning, we will use the built-in behavior of spatials and how translation and rotation is propagated through in a node.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need a new <code class="literal">Node</code> instance called <code class="literal">centerPoint</code> in our <code class="literal">GameCharacterControl</code>. This will be the origin of our leaning, so to speak:<div class="informalexample"><pre class="programlisting">private Node centerPoint = new Node("Center");</pre></div></li><li class="listitem">We set the translation to be pretty much in the center of the character's body (half the distance to the camera). We also attach the head node to <code class="literal">centerPoint</code>. In the <code class="literal">setSpatial</code> method, we add the following lines of code:<div class="informalexample"><pre class="programlisting">if(spatial instanceof Node){
  ((Node)spatial).attachChild(centerPoint);
  centerPoint.setLocalTranslation(0, 0.9f, 0);
  centerPoint.attachChild(head);
}</pre></div><p>The following figure shows you the relation between the <code class="literal">head</code> and <code class="literal">centerPoint</code> nodes:</p><div class="mediaobject"><img src="graphics/6478OS_02_01.jpg" alt="How to do it..."/></div></li><li class="listitem">We continue to follow the pattern we have used in <code class="literal">GameCharacterControl</code> and use Booleans to define whether an action should happen and then handle any<a id="id179" class="indexterm"/> changes in the <code class="literal">update</code> method. So, let's start by adding three new Booleans to handle leaning as follows:<div class="informalexample"><pre class="programlisting">private boolean leanLeft, leanRight, leanFree;</pre></div></li><li class="listitem">Now, before we add the actual leaning functionality, we need to introduce two more <a id="id180" class="indexterm"/>fields. The <code class="literal">leanValue</code> field stores the current amount of leaning for the character. We use the <code class="literal">maxLean</code> field to have <a id="id181" class="indexterm"/>some kind of limit to how much the player can lean. This is in radians and is set to corresponding 22.5 degrees. Sounds too little? Feel free to experiment using the following lines of code:<div class="informalexample"><pre class="programlisting">private float leanValue;
private float maxLean = FastMath.QUARTER_PI * 0.5f;</pre></div></li><li class="listitem">In the <code class="literal">onAction</code> method, we make sure that we handle the corresponding input. Again, after setting the Booleans like this, make sure our actions stay on until the key is released:<div class="informalexample"><pre class="programlisting">if (binding.equals("LeanLeft")){
  leanLeft = value;
} else if (binding.equals("LeanRight")){
  leanRight = value;
} else if (binding.equals("LeanFree")){
  leanFree = value;
}</pre></div></li><li class="listitem">Applying the leaning value is pretty straightforward. We do this in a method called <code class="literal">lean</code>, which takes a float value as the input. First, we clamp <code class="literal">leanValue</code> to make sure we don't exceed our <code class="literal">maxLean</code> value. Then, we set the rotation along the <span class="emphasis"><em>z</em></span> axis to the negative value as follows:<div class="informalexample"><pre class="programlisting">private void lean(float value){
  FastMath.clamp(value, -maxLean, maxLean);
  centerPoint.setLocalRotation(new Quaternion().fromAngles(0, 0, -value));
}</pre></div></li><li class="listitem">One bit left now, and that's where to call this method from. In the <code class="literal">update</code> method, we add two blocks of code. This reads as: if the button for leaning left is pressed and the leaning value is less than the maximum leaning value, lean more. Otherwise, if the button for free leaning is not pressed and the lean value is more than 0, lean less:<div class="informalexample"><pre class="programlisting">if(leanLeft &amp;&amp; leanValue &lt; maxLean){
  lean(leanValue+= 0.5f * tpf);
} else if(!leanFree &amp;&amp; leanValue &gt; 0f){
  lean(leanValue-= 0.5f * tpf);
}</pre></div></li><li class="listitem">This <a id="id182" class="indexterm"/>code block then needs to be mirrored to lean in the other direction.</li><li class="listitem">That's it for controlling leaning with buttons only. To add leaning using the mouse when <code class="literal">leanFree</code> is pressed, the <code class="literal">onAnalog</code> method needs a bit of work as well. We need to hijack the <code class="literal">RotateLeft</code> and <code class="literal">RotateRight</code> inputs when <code class="literal">leanFree</code> is set to <code class="literal">true</code>. The character shouldn't turn then, but it should lean instead. This is easily done with an <code class="literal">if</code> statement. We apply the lean value instantly in this case. The code we added previously in the <code class="literal">update</code> method will take care of returning the leaning to zero when the button is released:<div class="informalexample"><pre class="programlisting">if(leanFree){
  if (name.equals("RotateLeft")) {
    leanValue += value * tpf;
  } else if (name.equals("RotateRight")) {
    leanValue -= value * tpf;
  }
  lean(leanValue);
}</pre></div></li><li class="listitem">We already have <code class="literal">InputAppState</code>, which handles our input, so let's add a few more buttons to it. Three more values to our <code class="literal">InputMapping</code> enum are <code class="literal">LeanLeft</code>, <code class="literal">LeanRight</code>, and <code class="literal">LeanFree</code>.</li><li class="listitem">Then, we assign those to <span class="emphasis"><em>Q</em></span> and <span class="emphasis"><em>E</em></span> keys to lean left and right, and V for free, or analog leaning.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How it works...</h2></div></div></div><p>This is an easy way to handle leaning since we have very few calculations to do. The scene graph takes care of that for us. This works for the same reason; the turning of the <code class="literal">head</code> node in the <span class="emphasis"><em>Creating a reusable character control</em></span> recipe could control the camera, which is normally not available in the scene graph. By attaching the <code class="literal">head</code> node to the center point (which, in turn, is attached to the main player node), any rotation or movement that the node <a id="id183" class="indexterm"/>does will be propagated to the <code class="literal">head</code> node, and thus, the camera.</p></div></div>
<div class="section" title="Detecting cover automatically in a third-person game"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Detecting cover automatically in a third-person game</h1></div></div></div><p>Cover shooters is an ever-popular genre in today's console games. How does one code a system that<a id="id184" class="indexterm"/> recognizes and allows players to take cover? There are several ways to do this, but basically, there are two main branches, each with their benefits and drawbacks. The first branch is one where a level designer places logical cover items around the environments or where they are baked into models by an artist. This could be as simple as a bounding volume, or it could be complex with directional data as well. This has a benefit for the programmer in that it's easy to recognize when a player is inside them by comparing bounding volumes. Another benefit is that the designer has full control over where there is cover and where there isn't. A drawback is that it is labor-intensive for the designer or artist and might be inconsistent to the player.</p><p>The method we'll implement is one where there is no pregenerated cover, and it's checked in runtime. No additional work is required for a designer or artist, except that the models that are used need to be of a certain height to be recognized as cover (and work with animations).</p><p>Normally, there <a id="id185" class="indexterm"/>are two different kinds of cover: a low cover that characters <a id="id186" class="indexterm"/>can crouch behind and shoot over. The other one is full height cover, where <a id="id187" class="indexterm"/>characters stand next to the edge of it and shoot <a id="id188" class="indexterm"/>around the corner. In some games, it's only possible to use full height covers where it's also possible to shoot from them, such as corners.</p><p>Once the character is in cover, certain movement restrictions usually apply. In most games, the player can move sideways along the cover. In some games, moving backwards will release the character from the cover, while in others, you have to toggle the cover button. We'll implement the latter.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>Getting ready</h2></div></div></div><p>Let's define in more detail what we'll implement and how. We'll use <code class="literal">Rays</code> to detect whether the player is covered or not and <code class="literal">KeyTrigger</code> to toggle the entering or exiting cover. If you're not familiar with the concept of Rays, you can, for example, have a look at the <span class="emphasis"><em>Firing in FPS</em></span> or <span class="emphasis"><em>Selecting units in RTS</em></span> recipes in this chapter. Cover can be anything in the scene above a certain height. All of the action in this recipe will be handled by <code class="literal">GameCharacterControl</code> from the <span class="emphasis"><em>Following a character with ChaseCamera</em></span> recipe. There are two separate areas we need to look at. One is the cover detection itself, and the other is related to how the character should behave when in cover.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>How to do it...</h2></div></div></div><p>To implement automatic cover detection, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">There are <a id="id189" class="indexterm"/>a few new fields we need to introduce to keep track of things. It's not enough to simply send one ray from the center to detect the cover, so we'll need to cast from the edges or near edges of the player model as well. We call this offset <code class="literal">playerWidth</code>. The <code class="literal">inCover</code> variable<a id="id190" class="indexterm"/> is used to keep track of whether the player is in <a id="id191" class="indexterm"/>cover mode or not (toggled). The <code class="literal">hasLowCover</code> and <code class="literal">hasHighCover</code> variables are set in the cover-detection<a id="id192" class="indexterm"/> method and are a way for us to know whether the player is currently within limits of a cover (but not <a id="id193" class="indexterm"/>necessarily in the cover mode). The <code class="literal">lowHeight</code> and <code class="literal">highHeight</code> variables are the heights where we'll cast <code class="literal">Ray</code> from in<a id="id194" class="indexterm"/> order to check for cover. The <code class="literal">structures</code> variable is everything we should check for cover against. Don't supply <code class="literal">rootNode</code> here or we'll end up colliding with ourselves:<div class="informalexample"><pre class="programlisting">private float playerWidth = 0.1f;
private boolean inCover, hasLowCover, hasHighCover;
private float lowHeight = 0.5f, highHeight = 1.5f;
private Node structures;</pre></div></li><li class="listitem">Now let's move to the fun part, which is detecting cover. A new method called <code class="literal">checkCover</code> needs to be created. It takes <code class="literal">Vector3f</code> as the input and is the position from where the rays originate need to be originated.</li><li class="listitem">Next, we define a new <code class="literal">Ray</code> instance. We don't set the origin yet; we just set the direction to be the same as the character's <code class="literal">viewDirection</code> and a maximum length for it (and this may vary depending on the context and game) as follows:<div class="informalexample"><pre class="programlisting">Ray ray = new Ray();
ray.setDirection(viewDirection);
ray.setLimit(0.8f);</pre></div></li><li class="listitem">We<a id="id195" class="indexterm"/> define<a id="id196" class="indexterm"/> two integer fields called <code class="literal">lowCollisions</code> and <code class="literal">highCollisions</code> to keep a track of how many collisions we've had.</li><li class="listitem">Next, we populate a new field called <code class="literal">leftDir</code>. This is the direction that is to the left of the character. We multiply this by <code class="literal">playerWidth</code> to get the left extreme to look for cover in, as follows:<div class="informalexample"><pre class="programlisting">Vector3f leftDir = spatial.getWorldRotation().getRotationColumn(0).mult(playerWidth);</pre></div></li><li class="listitem">We'll start by checking for low covers and set <code class="literal">y</code> to <code class="literal">lowHeight</code> as follows:<div class="informalexample"><pre class="programlisting">leftDir.setY(lowHeight);</pre></div></li><li class="listitem">Then, we<a id="id197" class="indexterm"/> create a <code class="literal">for</code> loop that sends three Rays: one at the left extreme of the player, one in the center, and one to the right. This is done by multiplying <code class="literal">leftDir</code> with <code class="literal">i</code>. The loop must then be duplicated for the upper Rays as well:<div class="informalexample"><pre class="programlisting">for(int i = -1; i &lt; 2; i++){
  leftDir.multLocal(i, 1, i);
  ray.setOrigin(position.add(leftDir));
  structures.collideWith(ray, collRes);
  if(collRes.size() &gt; 0){
  lowCollisions++;
  }
  collRes.clear();
}</pre></div></li><li class="listitem">In order to be considered to be inside range of a cover, all three (left, middle, and right) Rays must hit something. A high cover always has a low cover as well, so we can check to see whether we've hit the low cover first. If we did, we do one more Ray check to find out the normal of the actual triangle hit. This will help us align the model with the cover:<div class="informalexample"><pre class="programlisting">if(lowCollisions == 3){
  ray.setOrigin(spatial.getWorldTranslation().add(0, 0.5f, 0));
  structures.collideWith(ray, collRes);

  Triangle t = new Triangle();
  collRes.getClosestCollision().getTriangle(t);</pre></div></li><li class="listitem">The opposite of the triangle's normal should be the character's new <code class="literal">viewDirection</code>:<div class="informalexample"><pre class="programlisting">viewDirection.set(t.getNormal().negate());</pre></div></li><li class="listitem">Finally, we check whether we also have high cover and set the <code class="literal">hasLowCover</code> and <code class="literal">hasHighCover</code> fields accordingly.</li><li class="listitem">To restrict movement, the <code class="literal">onAction</code> method needs some modifications. The first criterion we check is whether the toggle cover button is pressed. If we're already in cover, we'll release the character from the cover. If we're not in cover, we check whether it's possible to go into cover:<div class="informalexample"><pre class="programlisting">if(binding.equals("ToggleCover") &amp;&amp; value){
  if(inCover){
    inCover = false;
  } else {
    checkCover(spatial.getWorldTranslation());
    if(hasLowCover || hasHighCover){
      inCover = true;
    }
  }</pre></div></li><li class="listitem">In the following bracket, we limit movement to left and right if we're inside cover. If neither of the preceding statements applies, movement should be handled as usual. If we didn't want the player to be able to move inside cover, we'd be done by now.</li><li class="listitem">Since we want to mimic popular cover-based games though, we have some more work ahead of us.</li><li class="listitem">At the <a id="id198" class="indexterm"/>top of the update method, we have code to set the direction of the character based on the camera's rotation. We need to change this a bit, since once the character is inside cover, it should move based on the direction of the cover rather than the camera. To achieve this, we add a <code class="literal">!inCover</code> criterion to the original <code class="literal">if</code> statement, since outside cover, this should work like it worked previously.</li><li class="listitem">Then, if we are in cover, we base <code class="literal">modelForwardDir</code> and <code class="literal">modelLeftDir</code> on the rotation of the spatial, as follows:<div class="informalexample"><pre class="programlisting">modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);
modelLeftDir = spatial.getWorldRotation().mult(Vector3f.UNIT_X);</pre></div></li><li class="listitem">Once the movement has been applied to the <code class="literal">walkDirection</code> vector but before it is applied it to the character, we check whether the character will still be inside cover after moving:<div class="informalexample"><pre class="programlisting">if(walkDirection.length() &gt; 0){
 if(inCover){
 checkCover(spatial.getWorldTranslation().add(walkDirection.multLocal(0.2f).mult(0.1f)));
    if(!hasLowCover &amp;&amp; !hasHighCover){
      walkDirection.set(Vector3f.ZERO);
    }
  }</pre></div></li><li class="listitem">We add the<a id="id199" class="indexterm"/> current <code class="literal">walkDirection</code> vector to the position of the player and check for cover at that position. If there is none, the movement is not allowed and we set <code class="literal">walkDirection</code> to <code class="literal">0</code>.</li><li class="listitem">Now all that's needed is a new mapping for <code class="literal">ToggleCover</code>, which is added to <code class="literal">InputAppState</code>:<div class="informalexample"><pre class="programlisting">inputManager.addMapping(InputMapping.ToggleCover.name(), new KeyTrigger(KeyInput.KEY_V));</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>How it works...</h2></div></div></div><p>Each time the player presses the <code class="literal">ToggleCover</code> key or button, a check will be run to see whether there is cover within range. Three rays are cast forward from a low height, one at the left edge of the model, one from the center, and one from the right. Since <code class="literal">leftDir</code> is multiplied by -1, 0, and 1 on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>z</em></span> axes, we get the offset to the left- and right-hand side of the center position. To be considered inside cover, all three must have collided with something. This ensures that the player model is wholly covered.</p><p>The Ray won't stop just because it collides with something, and if the cover is thin, it might continue through the back side of it, generating additional collisions. We only want to count one collision per ray, though (the closest), which is why we only increase <code class="literal">lowCollisions</code> by one.</p><p>The high <a id="id200" class="indexterm"/>cover is checked after the low cover, because in general, there is never any cover that only covers the upper body.</p><p>Once it's decided that the character is inside cover and the player wants to move, we need to check whether the player will still be inside cover at the new position. This is so that the player doesn't accidentally exit cover and end up getting killed. To avoid unnecessary performance hits, we don't want to do this every frame. We do this only if there has actually been some movement happening.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To get the most out of this, we will need suitable animations. Refer to <a class="link" href="ch04.html" title="Chapter 4. Mastering Character Animations">Chapter 4</a>, <span class="emphasis"><em>Mastering Character Animations</em></span>, to get a few ideas on how to do this.</li></ul></div></div></div></body></html>