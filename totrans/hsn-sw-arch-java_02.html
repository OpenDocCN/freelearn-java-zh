<html><head></head><body>
		<div id="_idContainer014">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor013"/>Chapter 1: Designing Software Architectures in Java – Methods and Styles</h1>
			<p>In this chapter, we will focus on some core concepts that we can use as a base to build on in the upcoming chapters. We will explore different ways to represent the software architecture, paying attention to the intended audience and their specific point of view. Additionally, we will elaborate on the importance of a proper architectural design and its role in the software development life cycle. Following this, we will move on to the Java ecosystem, which is the core topic of this book, to discover why it’s a good choice for implementing a complete enterprise application.</p>
			<p>In particular, we will cover the following topics:</p>
			<ul>
				<li>The importance of software architecture</li>
				<li>Different types of architecture design – from doodling on paper to more accurate modeling</li>
				<li>Other kinds of architectural diagrams</li>
				<li>The changing role of Java in cloud-native applications</li>
				<li>Case studies and examples</li>
				<li>Software components diagram</li>
			</ul>
			<p>By the end of this chapter, you should have a clear view of why design is a critical part of the software development process and what the main types of architecture schemas are. Additionally, you will become familiar with the role of Java technology in modern application development.</p>
			<p>These skills are crucial for implementing functional and elegant software solutions. It will also be a good basis for personal development and career enhancement.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor014"/>The importance of software architecture</h1>
			<p>Often, software<a id="_idIndexMarker000"/> development is all about cost and time. No one knows exactly why, but the software industry is almost always associated with tight deadlines, insufficient resources, and long hours. Under this kind of pressure, it’s common to question the importance of everything that is not strictly <em class="italic">coding</em>. Testing is a common victim of this, along with documentation and, of course, design. But of course, these phases are essential for the success of a project. While we will quickly touch on most of those aspects, architecture design is the core of this book, and I believe that by understanding the practices and goals, the need for it will become clear to everybody.</p>
			<p>In this section, we will discover what the fundamental objects of a properly designed architecture are. Highlighting those simple but crucial points is useful in raising awareness about the importance of this phase. If you start advocating those good practices in your team, the quality of your software deliverables will increase.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor015"/>The objectives of architecture design in the software life cycle</h2>
			<p>The ultimate goal of this<a id="_idIndexMarker001"/> book is not to define the architecture <em class="italic">per se</em>; there are plenty of papers and interesting things available on that matter, including the awesome work of Martin Fowler. Nevertheless, there are a couple of considerations that we need to bear in mind.</p>
			<p>The architecture should support the crucial decisions within our software project. However, the architecture itself is actually a loose concept, often including different plans (such as physical, logical, network, and more) and points of view (such as users, business logic, machine-to-machine interactions, and more).</p>
			<p>Let’s take the most overused metaphor as an example: a software project is like a building. And similarly to a construction project, we require many different points of view, with different levels of detail, ranging from general overviews to detailed calculations and the bills of materials. A general overview is useful to give us an idea of where we are and where we want to go. In addition to this, it is an essential tool for being sure we are on the right path. However, a system overview doesn’t provide enough details for teams such as networking, security, sysops, and, ultimately, the developers that require a more substantiated and quantitative view to drive their day-to-day decisions.</p>
			<p>The main goals of <a id="_idIndexMarker002"/>designing a proper software architecture include the following:</p>
			<ul>
				<li>Prospecting<a id="_idIndexMarker003"/> a <strong class="bold">birds-eye view</strong> to project sponsors and investors. While it is not a good practice to drive a business discussion (for example, an elevator pitch) toward technical elements too soon, a higher level of management, venture capitalists, and the like are becoming increasingly curious about technical details, so a high-level overview of the application components can be crucial for winning this kind of discussion.</li>
				<li>Defining a <strong class="bold">shared lingo</strong> for<a id="_idIndexMarker004"/> components of our solution, which is crucial for collaborating across the team.</li>
				<li>Providing <strong class="bold">guidance for technological choices</strong> since putting our design decisions on paper will clarify important traits of our application. <em class="italic">Will data be central?</em> <em class="italic">Do we need to focus on multiple geographies?</em> <em class="italic">Are user interactions the most common use case?</em> Some of those reasonings will change over time. However, correctly designing our application will drive some crucial technology choices, in terms of choosing components and stacks to rely on.</li>
				<li>Splitting <strong class="bold">roles and responsibilities</strong>. While a proper project plan, a statement of work, or a <strong class="bold">Responsible</strong>, <strong class="bold">Accountable</strong>, <strong class="bold">Consulted</strong>, <strong class="bold">Informed</strong> (<strong class="bold">RACI</strong>) (which is a classical way to categorize who does what) table will be used for real project management, writing the software backbone down on paper is our first look at who we have to involve for proper project execution.</li>
			</ul>
			<p>Indeed, the architecture is an excellent example of planning in advance. However, a proper software architecture should be much more than a technological datasheet.</p>
			<p>Architecture, as with buildings, is more about the styles and guidelines to be followed all around the project. The final goal of a piece of software architecture is to find elegant solutions to the problems that will arise during the project plan. Ultimately, it will act as guidance throughout the project’s life cycle. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor016"/>The software architect – role and skills</h2>
			<p>As a role, the<a id="_idIndexMarker005"/> software architect is often identified as the more senior technical resource in the IT team. In fact, the job role of an architect is almost always seen as a career progression for developers, especially in enterprise environments. While not necessary, being good at coding is crucial for a complete comprehension of the overall functioning of the system. </p>
			<p>There are several different <a id="_idIndexMarker006"/>other skills that are required to be a successful architect, including creativity, the ability to synthesize, and vision. However, above all, experience is what it takes to become an architect.  </p>
			<p>This includes firsthand experience on many different projects, solving real-world issues: what a proper software design looks like and how the design has evolved. This skillset is very useful to have in the background of the architect.</p>
			<p>Additionally, it’s vital to have a huge library of solutions to choose from in order to avoid reinventing the wheel. While we love to think that our problem is very unique, it’s very unlikely to be so.</p>
			<p>This leads us to the approach that we will use in this book: we will not focus on just one aspect or technology to drill down on, but we will take a <em class="italic">horizontal</em> approach, discussing a number of different topics and offering ideas on how to approach potential problems. We hope to act as a handbook to support you when making real-world choices.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor017"/>Is architecture design still relevant in modern development?</h2>
			<p>There will <a id="_idIndexMarker007"/>be a couple of chapters dedicated to<a id="_idIndexMarker008"/> discussing <strong class="bold">Microservices</strong>, <strong class="bold">DevOps</strong>, and <a id="_idIndexMarker009"/>the cloud-native avalanche, but it’s safe to assume that in one form or another, you will have plenty of opportunities to hear something about them.</p>
			<p>As you might have gathered, most of these concepts are not really new. The <strong class="bold">Agile Manifesto</strong>, which<a id="_idIndexMarker010"/> is a seminal work detailing some of the practices commonly used in modern development techniques, was published in 2001, yet most of the common-sense principles it contains are misinterpreted. When I was working in IT consulting back in 2008, a common joke among development teams was "<em class="italic">Yes, we do agile. We skip documentation and testing.</em>" </p>
			<p>Of course, that’s just an opinion based on personal experience. There are plenty of teams who do not underestimate the importance of proper planning and documentation <a id="_idIndexMarker011"/>and are doing wonderfully while working with Agile. Yet, in some cases, less structured development methodologies have been taken as an excuse to skip some crucial steps of the development life cycle.</p>
			<p>As we will <a id="_idIndexMarker012"/>elaborate, in <a href="B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring the Most Common Development Models</em>, Agile is much more than slimming down boring phases of the project. Indeed, testing and documentation are still very relevant, and Agile is no excuse to skip that.</p>
			<p>There are plenty of reflections you can take in terms of how to adapt your design techniques to DevOps, Agile, and more, and we will discuss this topic later in this book. However, one thing is certain: <em class="italic">architecture matters</em>. <em class="italic">Design is very relevant</em>. We have to spend the correct amount of time planning our choices, revisiting them when needed, and generally, sticking with some well-defined guiding principles. The alternative is poor quality deliverables or no deliverables at all. </p>
			<p>Now, let’s take a look at what the first phases of software design usually look like.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor018"/>Different types of architecture design – from doodling on paper to more accurate modeling</h1>
			<p>When we<a id="_idIndexMarker013"/> start to shape the architecture of a new application, the result is often familiar.</p>
			<p>I would say that across different geographies, industries, and application types, some elements are common. The architectural sketches are usually made of boxes and lines, with labels, arrows, and similar artifacts. That’s an intuitive way to shape our thoughts on paper. </p>
			<p>However, in the following section, we will go through <em class="italic">different</em> ways of expressing those concepts. This will make us aware of available styles and techniques and will make our diagram clearer and, ultimately, easier to share and understand. </p>
			<p>But first, let’s find out what the characteristics of architectural sketching actually are.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor019"/>Sketching the main architectural components</h2>
			<p>As we discussed earlier, there<a id="_idIndexMarker014"/> are a number of different components that are recurrent in a high-level architectural sketch. Let’s examine them one by one:</p>
			<ul>
				<li><strong class="bold">Boxes</strong>: These<a id="_idIndexMarker015"/> represent the software components. They can refer to one complete application or specific subcomponents (such as packages, modules, or similar things).</li>
				<li><strong class="bold">Lines</strong>: These <a id="_idIndexMarker016"/>describe the relationships between the boxes. Those links imply some sort of communication, commonly in the form of APIs. The lines can also represent inheritance or a grouping of some sort. A direction (that is, <em class="italic">an arrow</em>) can also be specified.</li>
				<li><strong class="bold">Layers</strong>: These<a id="_idIndexMarker017"/> are a dotted or dashed line, grouping components and their relationships. They are used to identify logical slices of the architecture (such as the frontend, backend, and more), the grouping of subcomponents (for example, validation and business logic), network segments (such as the intranet and DMZ), physical data centers, and more.</li>
				<li><strong class="bold">Actors</strong>: Simulating<a id="_idIndexMarker018"/> the interactions of users within the systems, actors are usually represented as stickmen, sitting on top of some components (usually frontends or UIs of some sort). It is not uncommon to observe different channels represented, in the form of laptops or mobile phones, depending on the industry and type of application (for example, ATMs, branch offices, and physical industrial plants).</li>
			</ul>
			<p>Now, let’s view an<a id="_idIndexMarker019"/> example sketch:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B16354.jpg" alt="Figure 1.1 – The common components on a first architectural sketch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The common components on a first architectural sketch</p>
			<p>As we’ve already<a id="_idIndexMarker020"/> mentioned, the quick and dirty representation shown in this diagram is useful since it’s an easy way to start thinking about how our application should look. However,  on a closer look, there are some common inaccuracies:</p>
			<ul>
				<li>The software components (that is, our boxes) might be represented with different levels of zoom: sometimes representing applications, sometimes features, and sometimes software modules. This is inconsistent and could generate confusion.</li>
				<li>Some components are specialized (for example, databases), while others are not. As noted in the preceding point, this leads to an inhomogeneous view. </li>
				<li>In some parts of the diagram, we are representing use cases or information flows (for example, with the actors), while elsewhere, we are drawing a static picture of the components.</li>
				<li>Some points of view don’t cope well with others because we might be representing <a id="_idIndexMarker021"/>network firewalls but not referencing any other networking setup.</li>
			</ul>
			<p>Now that we’ve learned what a naïve representation looks like and what its limits are, let’s take a look at some other types of diagrams and how they represent alternative points of view.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor020"/>Other kinds of architectural diagrams</h1>
			<p>As we<a id="_idIndexMarker022"/> discovered in the previous section, the first sketches of a piece of architecture often end up as an intuitive and naïve view, lacking essential details. In this section, we will look at an overview of different types of architectural diagrams. This will help us to pick the right diagram for the right situation, defining a clearer view of our architecture. So, let’s dig into some details.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor021"/>Common types of architectural diagrams</h2>
			<p>In order to define a <a id="_idIndexMarker023"/>clearer and more detailed view of what our software will look like, it’s essential to start picking layers and points of view to represent. This will naturally lead us to focus on more tailored designs. While not exhaustive, a list of possible architectural diagrams includes the following:</p>
			<ul>
				<li><strong class="bold">Software components</strong>: This kind <a id="_idIndexMarker024"/>of schema <a id="_idIndexMarker025"/>includes different software modules (such as applications or other components) and the interaction between them (for example, read from, write to, listen, and more). One particular instance of this diagram could include protocols and formats of communication between those components, becoming close to a complete API documentation:</li>
			</ul>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.2_B16354.jpg" alt="Figure 1.2 – Software components diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Software components diagram</p>
			<ul>
				<li><strong class="bold">Network architecture</strong>: This<a id="_idIndexMarker026"/> is a pretty common <a id="_idIndexMarker027"/>design type and is often considered the more <em class="italic">scientific</em> and detailed one. It includes data such as network segments (<strong class="bold">DMZ</strong> and <strong class="bold">INTRANET</strong>), <strong class="bold">Firewall</strong>, IP addressing, and more:</li>
			</ul>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.3_B16354.jpg" alt="Figure 1.3 – Network architecture diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Network architecture diagram</p>
			<ul>
				<li><strong class="bold">Physical architecture</strong>: This <a id="_idIndexMarker028"/>is a <a id="_idIndexMarker029"/>mapping of software modules into server deployments. Usually, it’s complete with information about the server hardware and model. In the case of a multiple datacenter setup (which is pretty common in enterprise environments), it can also contain details about racks and rooms. Storage is another relatively common component. Depending on the implementation, this architecture might include information about virtualization technology (for example, the mapping of VMS to the physical servers that are hosting it). Additionally, it could, where relevant, include references to cloud or container deployments:</li>
			</ul>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.4_B16354.jpg" alt="Figure 1.4 – Physical architecture diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Physical architecture diagram</p>
			<p>These <a id="_idIndexMarker030"/>are the very basic points of view in an architecture diagram and an essential starting point when detailing the design of your <a id="_idIndexMarker031"/>application. Diving further into the application specification life, other kinds of diagrams, often derivatives of those, could be elaborated (for example, cloud deployment diagrams, software modules, and more) depending on your specific needs. In the next section, we will focus on Java technology, which is the other fundamental topic of this book and crucial for completing our architectural view of modern applications.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor022"/>The changing role of Java in cloud-native applications</h1>
			<p>Now that we’ve briefly<a id="_idIndexMarker032"/> touched on the various kinds of designs and diagrams of an application, let’s focus on the other fundamental topic of this<a id="_idIndexMarker033"/> book: the Java language.</p>
			<p>It’s not uncommon to hear that Java is dead. However, if you are reading this book, you probably agree that this is far from the truth.</p>
			<p>Of course, the panorama of software development languages for enterprise applications is now wider and more complicated than the golden age of Java; nevertheless, the language is still alive and widespread, especially in some areas.</p>
			<p>In this section, we will explore the usage of Java technology in the enterprise software landscape. Then, we will <a id="_idIndexMarker034"/>take a quick glance at the history of <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">JEE</strong>). This will be a good foundation to understand existing enterprise architectures and model modern, cloud-native applications based on this technology.</p>
			<p>Now, let’s examine why Java technology is still thriving.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor023"/>Why Java technology is still relevant today</h2>
			<p>The most important <a id="_idIndexMarker035"/>reason for Java’s popularity is probably the availability of skill. There are plenty of experts on this language, as many polls and studies show (for example, PYPL and Tiobe). Another crucial point is the relevance of the ecosystem, in terms of the quantity and quality of libraries, resources, and tooling available for the Java platform.</p>
			<p>Rewriting complex applications (including their dependencies) from Java to another language could probably take years, and, long story short, there might be no reason to do that. Java just works, and it’s an incredibly productive platform. It might be slow and resource-intensive in some scenarios, but this is balanced by its stability. The language has been battle-tested, is feature-rich, and essentially, covers all the use cases required in an enterprise, such as transactionality, integration with legacy environments, and manageability.</p>
			<p>Now, let’s take a look at where and how Java technology is used in enterprise environments. This can be very useful to understand existing scenarios and fit new applications into existing application landscapes.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor024"/>Java usage in enterprise environments</h2>
			<p>In order to fit<a id="_idIndexMarker036"/> our Java application in the overall architecture, it’s important to understand the typical context of a large enterprise, from a software architecture perspective.</p>
			<p>Of course, the enterprise architecture depends a lot on the industry domain (for instance, banking, telecommunications, media, and more), geography, and the tenure of the organization, so my vision might be slightly biased toward the segment I have worked with for the longest (a large enterprise in the EMEA area). Still, I think we can summarize it as follows:</p>
			<ul>
				<li><strong class="bold">Legacy</strong>: Big<a id="_idIndexMarker037"/> applications, usually running very core functions of the enterprise for many years (at least more than 10 and commonly more than 20). Needless to say, the technology here is not the most <a id="_idIndexMarker038"/>current (<strong class="bold">Cobol</strong> is widespread in this area, but it is not uncommon to see other things such as <strong class="bold">PL SQL</strong>, huge<a id="_idIndexMarker039"/> batch scripts, and even <strong class="bold">C</strong>/<strong class="bold">C++</strong> code). However, the language is seldom an <a id="_idIndexMarker040"/>issue here. Of course, nowadays, those skills are very rare to find on the job market, but usually, the software <em class="italic">just works</em>. The point here is that most of the time, nobody exactly knows what the software does, as it’s poorly documented and tested. Moreover, you usually don’t have automated release procedures, so every time you perform a bugfix, you have to cross your fingers. Needless to say, a proper testing environment has never been utilized, so most of the things have to be tested in production.</li>
				<li><strong class="bold">Web (and mobile)</strong>: This<a id="_idIndexMarker041"/> is another big chunk of the enterprise architecture. Usually, it is easier to govern than legacy but still very critical. Indeed, by design, these applications are heavily customer-facing, so you can’t afford downtime or critical bugs. In terms of technologies, the situation here is more fragmented. Newer deployments are almost exclusively made of <strong class="bold">Single-Page Applications</strong> (<strong class="bold">SPAs</strong>) based<a id="_idIndexMarker042"/> on JavaScript (implemented with frameworks such as Angular, Vue, and React). Backends are REST services implemented in JavaScript (<strong class="bold">Node.js</strong>) or <a id="_idIndexMarker043"/>Java. </li>
				<li><strong class="bold">Business applications</strong>: Often, the <a id="_idIndexMarker044"/>gap between web applications and business applications is very thin. Here, the rule of thumb is that business applications are less web-centric (even if they often have a web GUI), and usually, they are not customer exposed. The most common kind of business application is the management of internal back-office processes. It’s hard to find a recurrent pattern in business applications since it’s an area that contains very different things (such as CRMs, HR applications, branch office management, and more). </li>
				<li><strong class="bold">BigData</strong>: Under <a id="_idIndexMarker045"/>various names and nuances (such as data warehouses, data lakes, and AI), BigData is commonly a very huge workload in terms of the resources required. Here, the technologies are often packaged software, while custom development is done using various languages, depending on the core <a id="_idIndexMarker046"/>engine chosen. The most common languages in this area are Java (Scala), <strong class="bold">R</strong> (which is decreasing in popularity), and <strong class="bold">Python</strong> (which is increasing in popularity). In <a id="_idIndexMarker047"/>some implementations, a big chunk of SQL is used to stitch calculations together.</li>
				<li><strong class="bold">Middlewares and infrastructure</strong>: Here falls everything that glues the other apps together. The<a id="_idIndexMarker048"/> most common pattern here is the integration (synchronous or asynchronous). The keywords are ESB, SOA, and messaging. Other things such <a id="_idIndexMarker049"/>as <strong class="bold">Single Sign-On</strong> and identity providers can be included here.</li>
			</ul>
			<p>As I mentioned, this is just a coarse-grained classification, useful as reference points regarding where our application will fit and which other actor our application will be interacting with.</p>
			<p>Notice <a id="_idIndexMarker050"/>that the technologies mentioned are mostly <em class="italic">traditional</em> ones. With the emergence of modern paradigms (such as the cloud, microservices, and serverless), new languages and stacks are quickly gaining their place. Notable examples are Go in the microservice development area and Rust for system programming. </p>
			<p>However, those technologies and approaches are often just evolutions (or brand-new applications) belonging to the same categories. Here, the most interesting exception is in the middleware area, where some approaches are decreasing in popularity (for example, SOA) in favor of lighter alternatives. We will discuss this in <a href="B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Middleware and Frameworks</em>.</p>
			<p>Now that we’ve explored the widespread usage of Java in an enterprise context, let’s take a look at its recent history.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor025"/>JEE evolution and criticism</h2>
			<p>JEE, as <a id="_idIndexMarker051"/>we have learned, is still central in common enterprise applications. The heritage of this language is just great. The effort that has been done in terms of standardizing a set of APIs for common features (such as transactionality, web services, and persistence) is just amazing, and the cooperation between different vendors, to provide interoperability and reference implementation, has been a very successful one.</p>
			<p>However, in the last couple of years, a different set of needs has emerged. The issue with JEE is that in order to preserve long-term stability and cross-vendor compatibility, the evolution of the technology is not very quick. With the emergence of cloud and more modular applications, features such as observability, modular packaging, and access to no SQL databases have become essential for modern applications. Of course, standards and committees have also had their moments, with developers starting to move away from vanilla implementations and using third-party libraries and non-standard approaches.</p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">The objective of this book is not to recap the history and controversy of the JEE platform. However, organizational issues (culminating with the donation of the project to the Eclipse Foundation) and less frequent releases have contributed to the decrease in popularity of the platform.</p>
			<p>The upcoming of the <strong class="bold">Platform-as-a-Service</strong> (<strong class="bold">PaaS</strong>) paradigm is another important event that is<a id="_idIndexMarker052"/> changing the landscape. Modern orchestration platforms (with Kubernetes as the most famous example), both in the cloud or on-premises, are moving toward a different approach. We <a id="_idIndexMarker053"/>will examine this in greater detail later, but essentially, the core concept is that for the sake of scalability and control, some of the typical features of the application server (for example, clustering and the service registry) are delegated to the platform itself. This has a strict liaison with the microservice approach and the benefits they bring. In the JEE world, this means that those features become duplicated. </p>
			<p>Another <a id="_idIndexMarker054"/>point is about containerization. One of the focal points of container technology is immutability and its impacts in terms of stability and the quality of the applications. You package one application into a container and easily move it between different environments. Of course, this is, not in the same direction as JEE servers, which have been engineered to host multiple applications, managing hot deploys and live changes of configurations.</p>
			<p>A further consideration regarding application servers is that they are, by design, optimized for transaction throughput (often at the expense of startup times), and their runtime is general-purpose (including libraries covering many different use cases). Conversely, the cloud-native approach is usually aimed at a faster startup time and a runtime that is as small as possible, bringing only the features needed by that particular application. This will be the focus of our next section.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor026"/>Introducing cloud-native Java</h2>
			<p>Since the inception<a id="_idIndexMarker055"/> of the microservices concept, in the Java development community, the paradigm has increasingly shifted toward the <em class="italic">fat jar approach</em>. This concept<a id="_idIndexMarker056"/> is nothing new, as the first examples of <em class="italic">uber jars</em> (a synonym of the fat jar) have been around since the early 2000s, mainly in the desktop development area. The idea around them is pretty simple: instead of using dynamic loading of libraries at runtime, let’s package them all together into an executable jar to simplify the distribution of our application. This is actually the opposite of the model of the application servers, which aim to create an environment as configurable as possible, supporting things such as hot deployment and the hot-swapping of libraries, privileging the uptime to immutability (and predictability).</p>
			<p>In container-based and cloud-native applications, fat jar approaches have begun to be viewed as the perfect candidate for the implementation of cloud-native, microservices-oriented <a id="_idIndexMarker057"/>applications. This is for many different reasons:</p>
			<ul>
				<li><strong class="bold">Testability</strong>: You <a id="_idIndexMarker058"/>can easily run and test the application in a local environment (it’s enough to have a compatible <strong class="bold">Java Virtual Machine</strong> or <strong class="bold">JVM</strong>). Moreover, if<a id="_idIndexMarker059"/> the interface is properly defined and documented, it’s easy to mock other components and simulate integration testing.</li>
				<li><strong class="bold">Ease of installation</strong>: The <a id="_idIndexMarker060"/>handover of the application to ops groups (or to testers) is pretty easy. Usually, it’s enough to have the <strong class="source-inline">.jar</strong> file and configuration (normally, on a text file or environment variable).</li>
				<li><strong class="bold">Stability across environments</strong>: Since <a id="_idIndexMarker061"/>everything is self-contained, it’s easy to avoid the <em class="italic">works-on-my-machine</em> effect. The <a id="_idIndexMarker062"/>development execution environment (usually, the developer machine) is designed pretty similarly to the production environment (aside from the configuration, which is usually well separated from the code, and of course, the external systems such as the databases). This behavior mirrors what is provided by containers, and it’s probably one of the most important reasons for the adoption of this approach in the development of microservices.</li>
			</ul>
			<p>There is one last important consideration to pay attention to: curiously enough, the all-in-one fat jar approach, in contrast with what I’ve just said, is theoretically conflicting with the optimization provided by the containerization.</p>
			<p>Indeed, one of the benefits provided by every<a id="_idIndexMarker063"/> container technology is <em class="italic">layerization</em>. Put simply, every container is composed by starting with a <em class="italic">base image</em> and just adding what’s needed. A pretty common scenario in the Java world is to create the application as a tower composed of the operating system plus the JVM plus dependencies plus the application artifact. Let’s take a glance at what this looks like in the following diagram. In gray, you will see the base image, which doesn’t change with a new release of the application. Indeed, a change to the application artifact means only redeploying the last layer on top of the underlying <strong class="bold">Base Image</strong>:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.5_B16354.jpg" alt="Figure 1.5 – Layering container images "/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Layering container images </p>
			<p>As you can<a id="_idIndexMarker064"/> see in the preceding diagram, the release in this scenario is as light as simply replacing the <strong class="bold">Application Artifact</strong> layer (that is, the top layer).</p>
			<p>By using the fat jar approach, you cannot implement this behavior. If you change something in your application but nothing in the dependencies, you have to rebuild the whole <strong class="bold">Fat JAR</strong> and put it on top of the JVM layer. You can observe what this look like in the following diagram:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.6_B16354.jpg" alt="Figure 1.6 – Layering container images and fat jars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Layering container images and fat jars</p>
			<p>In this scenario, the<a id="_idIndexMarker065"/> release includes all of the application dependencies, other than the application by itself.</p>
			<p>While this might appear to be a trivial issue, it could mean hundreds of megabytes copied back and forth into your environment, impacting the development and release time since most of the things composing the container cannot be cached by the container runtime. </p>
			<p>Some ecosystems do <a id="_idIndexMarker066"/>a bit of experimentation in the field of <em class="italic">hollow jars</em> to essentially replicate an approach similar to the application server. Here, the composed (fat) jar is split between the application layer and the dependencies layer in order to avoid having to repackage/move everything each time. However, this approach is far from being widespread.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor027"/>The Java microservices ecosystem</h2>
			<p>One last <a id="_idIndexMarker067"/>consideration goes to the ecosystem in the Java microservices world. As we were beginning to mention earlier, the approach here is to delegate more things to <em class="italic">the platform</em>. The service itself becomes simpler, having only the dependency that is required (to reduce the size and the resource footprint) and focusing only on the business logic.</p>
			<p>However, some of the features delegated to the application server are still required. The service registry, clustering, and configuration are the simplest examples that come to mind.</p>
			<p>Additionally, other, newer needs start to emerge: </p>
			<ul>
				<li><strong class="bold">HealthCheck</strong> is the<a id="_idIndexMarker068"/> first need. Since there is no application server to ensure your application is up and running, and the application is implemented as more than one running artifact, you will end up having to monitor every single microservice and possibly restarting it (or doing something different) if it becomes unhealthy. </li>
				<li><strong class="bold">Visibility</strong> is another <a id="_idIndexMarker069"/>need. I might want to visualize the network of connections and dependencies, the traffic flowing between components, and more. </li>
				<li>Last but not least: <strong class="bold">resiliency</strong>. This is <a id="_idIndexMarker070"/>often translated as the circuit breaker even if it’s not the only pattern to help with that. If something in the chain of calls fails, you don’t want the failure to cascade.</li>
			</ul>
			<p>So, as we will discover in the upcoming chapters, a new ecosystem will be needed to survive outside the JEE world. </p>
			<p>Microservices has been a groundbreaking innovation in the world of software architectures, and it has started a whole new trend in the world of so-called cloud-native architectures (which is the main topic of this book). With this in mind, I cannot avoid mentioning <a id="_idIndexMarker071"/>another very promising paradigm: <strong class="bold">Serverless</strong>. </p>
			<p>Serverless <a id="_idIndexMarker072"/>borrows some concepts from microservices, such as standardization and horizontal scaling, and takes it to the extreme, by relieving the developer of any responsibility outside the code itself and delegating aspects such as packaging and deployment to an underlying platform. Serverless, as a trend, has become popular as a proprietary technology on cloud platforms, but it is increasingly used in hybrid cloud scenarios.</p>
			<p>Java is not famous in the serverless world. The need for compilation and the weight added by the JVM has, traditionally, been seen as a showstopper in the serverless world. However, as we will explore further in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, Java technology is now also gaining some momentum in that area.</p>
			<p>And now, in order to better clarify different architectural designs, we will examine some examples based on a reference case study.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor028"/>Case studies and examples</h1>
			<p>Following<a id="_idIndexMarker073"/> up on the handbook approach, each time we face a complex concept, I will try to clarify it by providing case studies. Of course, while the <a id="_idIndexMarker074"/>cases are not real (for reasons you can imagine), the challenges closely resemble several first-hand experiences I’ve incurred in my professional history.</p>
			<p>In this section, we will start from scratch by designing a piece of software architecture. Then, we will add details to portray a more precise view. This will help you to better understand the first steps in the design of a complex piece of architecture.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor029"/>Case study – mobile payments</h2>
			<p>In this <a id="_idIndexMarker075"/>case study, we<a id="_idIndexMarker076"/> will simulate the architecture design of a mobile payment solution. As contextual background, let’s suppose that a huge bank, in order to increase the service offering toward their customers and following some market research, wants to implement a <a id="_idIndexMarker077"/>mobile payment application. By definition, a mobile payment is a pretty broad term, and it includes many different use cases involving financial transactions completed using smartphones.</p>
			<p>In this <a id="_idIndexMarker078"/>particular implementation, we will consider the use case of paying with your smartphone by charging you via your mobile phone bill.</p>
			<p>Essentially, this means implementing a client-server architecture (with the clients implemented as a mobile application), interacting both with existing enterprise applications and external systems exposed by telecommunication operators. Now, let’s now try to analyze some use cases related to this scenario and model it by using the different schemas we’ve discussed so far.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor030"/>Whiteboarding the overall architecture</h2>
			<p>Beginning on<a id="_idIndexMarker079"/> white space, let’s start whiteboarding the overall architecture. As we’ve learned, the first step is usually to sketch, at a<a id="_idIndexMarker080"/> high level, the relevant modules and the relationships between them. It’s not important to be super detailed, nor to use a particular style. We are just brainstorming the first shapes on paper:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.7_B16354.jpg" alt="Figure 1.7 – Architecture whiteboarding&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Architecture whiteboarding</p>
			<p>Here, we have drafted a birds-eye view of the use case. We now know where the transaction starts, where the data is saved, and how the user interacts with the system. </p>
			<p>Additionally, we<a id="_idIndexMarker081"/> have identified the main components of the application:</p>
			<ul>
				<li>The <a id="_idIndexMarker082"/>mobile application (represented together with the user)</li>
				<li>The <strong class="bold"> </strong>(<strong class="bold">CDN</strong>) to <a id="_idIndexMarker083"/>serve static resources to the application</li>
				<li>The (<strong class="bold">CMS</strong>) to <a id="_idIndexMarker084"/>configure content to be delivered to the app</li>
				<li>The <a id="_idIndexMarker085"/>backend (<strong class="bold">mobile Backend as a Service</strong> or <strong class="bold">mBaaS</strong>) to proxy requests and responses</li>
				<li>The <a id="_idIndexMarker086"/>business logic of the application</li>
				<li><strong class="bold">Session</strong> and <strong class="bold">Cache</strong>, to store<a id="_idIndexMarker087"/> non-persistent data of<a id="_idIndexMarker088"/> the users</li>
				<li><strong class="bold">Database</strong>, to<a id="_idIndexMarker089"/> store persistent data</li>
				<li>Other parts<a id="_idIndexMarker090"/> of the application: reporting <a id="_idIndexMarker091"/>and data warehousing, authentication, <strong class="bold">Transactional Backend</strong>, and <strong class="bold">Customer Relationship Management</strong> (<strong class="bold">CRM</strong>)</li>
			</ul>
			<p>As expected, this kind of design has <a id="_idIndexMarker092"/>some intrinsic issues:</p>
			<ul>
				<li>You can observe mixed-use cases (both of the mobile user and the CMS administrator), which can be foreseen by the arrows between different components, but it’s barely designed.</li>
				<li>There is a view in the project timeline regarding the implementation of components (reporting and data warehousing appear to be optional in the first phase of the project).</li>
			</ul>
			<p>Some protocols in the interactions are named (for example, SOAP and REST), but it’s not an API specification, nor a network schema. Anyway, even if it’s not super detailed, this schema is a good starting point. It helps us to define the main application boundaries, it gives a high-level overview of the integration points, and overall, it’s a good way to kick off a more detailed analysis. We will improve on this in the next section.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor031"/>Software components diagram</h1>
			<p>In order to address <a id="_idIndexMarker093"/>some of the issues highlighted in the previous section, I’ve modeled the same system by focusing on software components. This<a id="_idIndexMarker094"/> does not follow any specific standard even if is pretty similar to the <strong class="bold">C4</strong> approach (where <strong class="bold">C4</strong> stands for <strong class="bold">Context, Containers, Components, and Code</strong>; we will discuss this further in later chapters):</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.8_B16354.jpg" alt="Figure 1.8 – Software components diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Software components diagram</p>
			<p>As you can see, this <a id="_idIndexMarker095"/>schema is more homogeneous and better organized than the first sketch. At a first glance, you can view what features are provided to the user. Additionally, it highlights how the system interacts with each other in a structured way (for example, using API calls, reads and writes, and more).</p>
			<p>Compared to the first sketch, there are <a id="_idIndexMarker096"/>some considerations that we can observe:</p>
			<ul>
				<li>The components are almost the same as the other schema.</li>
				<li>The diagram is less focused on the use case, even if the user is still represented (together with a high-level recap of the features available to them).</li>
				<li>There is no view on the project phases. This helps you to focus on just one point of view (architectural components), making the schema less confusing.</li>
				<li>No protocols are named, only high-level interactions (such as reads, writes, and API calls).</li>
				<li>Some technical components are preserved (the database), while others are skipped since they have less impact on the functional view (for example, the CDN, which is probably more relevant on a network schema).</li>
			</ul>
			<p>In this section, we learned how to approach the first design of our mobile payments application; first, with a more naïve view, then by trying to detail the view in a more structured way. In the upcoming chapters, we will discuss how to further clarify and enrich those views.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor032"/>Summary</h1>
			<p>In this first chapter, we just scratched the surface on the two most essential topics of this book: the different types of architectural design and the relevance of Java technology in the enterprise world. </p>
			<p>We have discovered what the first sketches of our software architecture look like and why they are relevant, even if they are not very detailed. Then, we moved on to different schemas (such as software components, the infrastructure, and the network) to get a glimpse of other schema styles, which is useful to address specific areas of interest. On the Java side, we made some considerations about the role of Java in the enterprise landscape and how the language is evolving to meet the challenges of modern cloud environments.</p>
			<p>These concepts will be useful starting points for the two core concepts of this book. On the architectural side, we’ve grasped how complex and important it is to view, analyze, and design a proper architecture. From a technological point of view, we’ve learned how Java, the technology we will focus on for the rest of this book, is very widespread in the enterprise context and how it is still relevant for building modern, cloud-native applications.</p>
			<p>In the next chapter, we will start working with requirements. Requirement gathering and specifications are essential in order to rework our architectural design, adding more details and ensuring the final product will meet customer expectations.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor033"/>Further reading</h1>
			<ul>
				<li><em class="italic">Who Needs an Architect?</em> by Martin Fowler (<a href="http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf">http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf</a>)</li>
				<li><em class="italic">Don’t Put Fat Jars in Docker Images</em> by Philipp Hauer (<a href="https://phauer.com/2019/no-fat-jar-in-docker-image">https://phauer.com/2019/no-fat-jar-in-docker-image</a>)</li>
			</ul>
		</div>
	</body></html>