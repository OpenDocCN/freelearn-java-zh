<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. JSON, HATEOAS, and Documentation</h1></div></div></div><p class="calibre7">In this last chapter, we're going to look a bit deeper into a couple of important parts of REST. We'll start with a more in-depth explanation of the different JSON libraries that are available, and after that, we'll explore the HATEOAS concept and explain how you can apply that principle to the frameworks explained in this book.</p><p class="calibre7">Let's start with JSON.</p></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec47" class="calibre1"/>Working with JSON</h1></div></div></div><p class="calibre7">There are many different <a id="id333" class="calibre1"/>JSON frameworks available for Scala. In this chapter, we'll look at four of the most important and most used frameworks. The following table gives a short introduction to the frameworks that we'll use:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Framework</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Argonaut</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Argonaut<a id="id334" class="indexterm"/> is an extensive JSON library that offers a functional approach to working with JSON. It has a very extensive <a id="id335" class="indexterm"/>JSON traversal and search functionality. You can find out more about it at <a class="indexterm" href="http://argonaut.io">http://argonaut.io</a>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Json4s</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Json4s is a<a id="id336" class="indexterm"/> library that provides a standard way of parsing and rendering JSON. It provides a standardized interface on top of the existing libraries, <a id="id337" class="indexterm"/>such as lift-json and Jackson. You can find out more about it at <a class="indexterm" href="http://json4s.org/">http://json4s.org/</a>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Play JSON</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Play JSON <a id="id338" class="indexterm"/>provides JSON support for the Play 2 framework. This library, however, can also be used in a standalone manner, and provides a very easy to use way of working with <a id="id339" class="indexterm"/>JSON. You can find out more about it at <a class="indexterm" href="https://www.playframework.com/documentation/2.4.x/ScalaJson">https://www.playframework.com/documentation/2.4.x/ScalaJson</a>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">spray-json</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">spray-json is a lightweight JSON framework, which provides some basic<a id="id340" class="indexterm"/> functions for processing JSON. It was part of the<a id="id341" class="indexterm"/> Spray framework, but can also be used as a standalone. You can find out more about it at <a class="indexterm" href="https://github.com/spray/spray-json">https://github.com/spray/spray-json</a>.</p>
</td></tr></tbody></table></div><p class="calibre7">For each framework, we<a id="id342" class="calibre1"/> will look at how you can accomplish the following steps:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Parse from string to JSON object</strong></span>: The input for this step is a string. We'll show you how <a id="id343" class="calibre1"/>you can use the JSON frameworks to convert this string into a JSON object.</li><li class="listitem"><span class="strong"><strong class="calibre8">Output JSON object as a string</strong></span>: When you've got a JSON object, a common<a id="id344" class="calibre1"/> requirement is to print it as a string. All the frameworks provide support for this functionality.</li><li class="listitem"><span class="strong"><strong class="calibre8">Create a JSON object by hand</strong></span>: Sometimes, you want to create a JSON object by<a id="id345" class="calibre1"/> hand (for example, when serializing part of a complex object). In this step, we'll explain how to do this.</li><li class="listitem"><span class="strong"><strong class="calibre8">Query a JSON object</strong></span>: After converting a string in to a JSON object, a common<a id="id346" class="calibre1"/> requirement is to get specific values out of the JSON string. In this step, we'll show you the different ways in which this is supported.</li><li class="listitem"><span class="strong"><strong class="calibre8">Converting to and from a case class</strong></span>: In the previous chapters, we already saw how case<a id="id347" class="calibre1"/> classes can be converted to and from JSON. All the frameworks provide explicit support for this functionality, and we'll explore how this works in this step.</li></ul></div><p class="calibre7">Before we look at the code, we first have to make sure we have all the required libraries. Each of the JSON libraries can be added just by including a single SBT dependency. The following set of dependencies adds all the libraries:</p><div class="informalexample"><pre class="programlisting">  val backendDeps = Seq (
    "io.argonaut" %% "argonaut" % "6.0.4",
    "org.json4s" %% "json4s-native" % "3.2.10",
    "io.spray" %%  "spray-json" % "1.3.2",
    "com.typesafe.play" %% "play-json" % "2.4.0"
  )</pre></div><p class="calibre7">The first step we explain for each of the frameworks is how to convert a string to a JSON object. For each of the frameworks, we'll use the following input string:</p><div class="informalexample"><pre class="programlisting">  val json = """{
    "id": 1,
    "title": "The Title",
    "content": "This is the data to create a new task",
    "assignedTo": {
      "name": "pietje"
    },
    "notes": [],
    "status": {
      "status": "New"
    }
  }"""</pre></div><p class="calibre7">You can also directly<a id="id348" class="calibre1"/> run the code from the various libraries. You can find the sources in the <code class="email">chapter7</code> folder and run the examples by running SBT. From SBT, run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">&gt; chapter07/run-main chapter7.json.PlayJson</strong></span>
<span class="strong"><strong class="calibre8">&gt; chapter07/run-main chapter7.json.Argonaut</strong></span>
<span class="strong"><strong class="calibre8">&gt; chapter07/run-main chapter7.json.Json4S</strong></span>
<span class="strong"><strong class="calibre8">&gt; chapter07/run-main chapter7.json. SprayJson</strong></span>
</pre></div><p class="calibre7">Now let's look at the first JSON library, Json4s.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON">
<div class="book" title="Working with Json4s"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec29" class="calibre1"/>Working with Json4s</h2></div></div></div><p class="calibre7">First, we'll show how to parse the string value we just saw:</p><div class="informalexample"><pre class="programlisting">  val parsedJson = parse(json);</pre></div><p class="calibre7">All you have to do<a id="id349" class="calibre1"/> is call the <code class="email">parse</code> function on the string and the result is a <code class="email">JValue</code> object. If the string can't be parsed, a <code class="email">ParseException</code> will be thrown. The result, when printed, looks similar to this:</p><div class="informalexample"><pre class="programlisting">JObject(List((id,JInt(1)), (title,JString(The Title)), (content,JString(This is the data to create a new task)), (assignedTo,JObject(List((name,JString(pietje))))), (notes,JArray(List())), (status,JObject(List((status,JString(New)))))))</pre></div><p class="calibre7">As you can see, the string is parsed into a set of Json4s-specific classes. Now that we have got a <code class="email">JValue</code> object, we can also convert it back to a string again:</p><div class="informalexample"><pre class="programlisting">  pretty(render(parsedJson)); // or compact</pre></div><p class="calibre7">By calling <code class="email">pretty(render(parsedJson)</code>, you get a <code class="email">pretty</code> printed string value. If you want a compact string, you can call <code class="email">compact(render(parsedJson))</code> instead. The result of the <code class="email">pretty</code> function is shown here:</p><div class="informalexample"><pre class="programlisting">{
  "id":1,
  "title":"The Title",
  "content":"This is the data to create a new task",
  "assignedTo":{
    "name":"pietje"
  },
  "notes":[],
  "status":{
    "status":"New"
  }
}</pre></div><p class="calibre7">The next step is creating a JSON object (a <code class="email">JValue</code> object) by hand. Json4s provides a very convenient<a id="id350" class="calibre1"/> way to do this:</p><div class="informalexample"><pre class="programlisting">val notesList = Seq[Note](Note(1,"Note 1"), Note(2, "Note 2"))
  val jsonManually =
    ("id" -&gt; 1) ~
    ("title" -&gt; "title") ~
    ("content" -&gt; "the content") ~
    ("assignedTo" -&gt;
      ("name" -&gt; "pietje")) ~
    ("notes" -&gt;
      notesList.map { note =&gt;
            (("id" -&gt; note.id) ~
             ("content" -&gt; note.content))}) ~
    ("status" -&gt;
      ("status" -&gt; "new"))</pre></div><p class="calibre7">As you can see, you only need to specify the key and provide a value; Json4s will automatically create the corresponding JSON objects. And when we print it, this time using the <code class="email">compact</code> function, we will see the following:</p><div class="informalexample"><pre class="programlisting">{"id":1,"title":"title","content":"the content","assignedTo":{"name":"pietje"},"notes":[{"id":1,"content":"Note 1"},{"id":2,"content":"Note 2"}],"status":{"status":"new"}}</pre></div><p class="calibre7">To query a JSON object, Json4s provides two approaches. You can use an XPath-like expression, as we have in the following code fragment, or you can use a comprehension (more info on that can be found at the Json4s website):</p><div class="informalexample"><pre class="programlisting">  println(jsonManually \\ "content") // all the content
  println(jsonManually \ "assignedTo" \ "name") // single name

  // allows unboxing

  println(jsonManually \\ "id" \\ classOf[JInt])</pre></div><p class="calibre7">In this code fragment, we use the <code class="email">\</code> and <code class="email">\\</code> operators to search through the JSON object. With the <code class="email">\</code> operator, we select a single node, and with the <code class="email">\\</code> operator, we search through all the children. The result of the previous <code class="email">println</code> statement is this:</p><div class="informalexample"><pre class="programlisting">JObject(List((content,JString(the content)), (content,JString(Note 1)), (content,JString(Note 2))))
JString(pietje)
List(1, 1, 2)</pre></div><p class="calibre7">Besides these operators, Json4s also provides a number of functions to search through a JSON object. You can see the available functions by looking at the <code class="email">MonadicJValue</code> class. The final feature we look at is how to convert case classes to and from JSON. If we've already got a Json4s <a id="id351" class="calibre1"/>JSON object, we can use the extract function:</p><div class="informalexample"><pre class="programlisting">  implicit val formats = DefaultFormats
  val task = jsonManually.extract[Task]</pre></div><p class="calibre7">The result of this is a <code class="email">Task</code> instance. You can also serialize it directly to and from a string value:</p><div class="informalexample"><pre class="programlisting">  import org.json4s.native.Serialization
  import org.json4s.native.Serialization.{read, write}
  implicit val autoFormat = Serialization.formats(NoTypeHints)

  val taskAsJson: String = write(task)
  val backToTask: Task = read[Task](taskAsJson)
}</pre></div><p class="calibre7">Using Json4s is really very straightforward. It provides the core functionality to easily create, query, and serialize JSON. Next up is Argonaut.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON">
<div class="book" title="Working with Argonaut"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec30" class="calibre1"/>Working with Argonaut</h2></div></div></div><p class="calibre7">Argonaut follows a <a id="id352" class="calibre1"/>more functional approach to create and parse JSON as you'll see in the following examples. We start again by converting a string object in to a JSON object:</p><div class="informalexample"><pre class="programlisting"> val parsed = json.parse // returns a scalaz disjunction
 val parsedValue = parsed | jString("Error parsing")</pre></div><p class="calibre7">Argonaut extends the string object with a <code class="email">parse</code> function. The result of this function is a <code class="email">\/</code> instance:</p><div class="informalexample"><pre class="programlisting">\/-({"id":1,"status":{"status":"New"},"content":"This is the data to create a new task","notes":[],"title":"The Title","assignedTo":{"name":"pietje"}})</pre></div><p class="calibre7">This is similar to an <code class="email">Either</code> object, but where an <code class="email">Either</code> object isn't right or left-biased, the <code class="email">\/</code> instance is right-biased (which means you can also easily use it in <code class="email">for</code> comprehensions). To get the value out of the <code class="email">\/</code> instance, we use the <code class="email">|</code> operator.</p><p class="calibre7">Once we have a JSON value, we can easily convert it in to a string:</p><div class="informalexample"><pre class="programlisting">  println(parsedValue.spaces4)</pre></div><p class="calibre7">This results in the following output:</p><div class="informalexample"><pre class="programlisting">{
    "id" : 1,
    "status" : {
        "status" : "New"
    },
    "content" : "This is the data to create a new task",
    "notes" : [
        
    ],
    "title" : "The Title",
    "assignedTo" : {
        "name" : "pietje"
    }
}</pre></div><p class="calibre7">For output that is <a id="id353" class="calibre1"/>more compact, you can also use <code class="email">spaces2</code> or <code class="email">nospaces</code>. Argonout also provides a flexible way of creating JSON objects manually:</p><div class="informalexample"><pre class="programlisting">  val notesList = List[Note](Note(1,"Note 1"), Note(2, "Note 2"))
  val jsonObjectBuilderWithCodec: Json =
      ("status" := Json("status" := "New")) -&gt;:
      ("notes" := notesList.map(
                  note =&gt; Json("id" := note.id, 
                               "content" := note.content)) ) -&gt;:
      ("assignedTo" := Json("name" := "Someone")) -&gt;:
      ("content" := "This is the content") -&gt;:
      ("title" := "The Title") -&gt;:
      ("id" := 1) -&gt;: jEmptyObject</pre></div><p class="calibre7">Argonaut provides a number of operators you can use to build a JSON object:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Operator</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">-&gt;:</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This prepends<a id="id354" class="indexterm"/> the given value to a JSON object.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">-&gt;?</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This prepends the given optional value to a JSON object if it is set.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">--&gt;&gt;:</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This prepends the given value to a JSON array.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">--&gt;&gt;:?</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This prepends the<a id="id355" class="indexterm"/> given optional value to a JSON array if it is set.</p>
</td></tr></tbody></table></div><p class="calibre7">On the Argonaut website, a couple of alternative ways of creating JSON objects can also be found.</p><p class="calibre7">Querying objects with Argonaut can also be done in a couple of different ways. For our example, we'll query using a lens:</p><div class="informalexample"><pre class="programlisting">val innerKey2StringLens = jObjectPL &gt;=&gt;   
    jsonObjectPL("notes") &gt;=&gt;          
      jArrayPL &gt;=&gt;                      
      jsonArrayPL(0) &gt;=&gt;            
        jObjectPL &gt;=&gt;              
        jsonObjectPL("id") &gt;=&gt;         
          jStringPL</pre></div><p class="calibre7">With this piece of code, we have defined a lens that matches a specific element in a JSON object. We always start with a <code class="email">jObjectPL</code> function, which selects the root node of a JSON object. Next, we use the <code class="email">jsonObjectPL("notes")</code> function to select the value of the <code class="email">"notes"</code> key. By using <code class="email">jArrayPL</code>, we convert the value to an array and use <code class="email">jsonArrayPL(0)</code> to select the first element of the array. Finally, we use <code class="email">JObjectPL</code> again to convert it in to an object, on which we query the <code class="email">"id"</code> key and finally, convert it in to a string. Now that we have a lens, we can use it on a specific JSON object to extract the value (as an <code class="email">Option[String]</code> instance):</p><div class="informalexample"><pre class="programlisting">val res = innerKey2StringLens.get(jsonObjectBuilderWithCodec))</pre></div><p class="calibre7">Argonaut, of course, also<a id="id356" class="calibre1"/> supports converting to and from case classes. The first thing we have to do is define a codec. A codec defines how a case class maps to the keys of a JSON object:</p><div class="informalexample"><pre class="programlisting">object Encodings {

    implicit def StatusCodecJson: CodecJson[Status] =
      casecodec1(Status.apply, Status.unapply)("status")
    implicit def NoteCodecJson: CodecJson[Note] =
      casecodec2(Note.apply, Note.unapply)("id", "content")
    implicit def PersonCodecJson: CodecJson[Person] =
      casecodec1(Person.apply, Person.unapply)("name")
    implicit def TaskCodecJson: CodecJson[Task] =
      casecodec6(Task.apply, Task.unapply)("id", "title", 
                    "content", "assignedTo", "notes", "status")
  }

  import Encodings._</pre></div><p class="calibre7">Note that we make the codecs implicit. This way, Argonaut will pick them up when it needs to convert a string in to a case class and back again:</p><div class="informalexample"><pre class="programlisting">  val task = new Task(
    1, "This is the title", "This is the content",
    Some(Person("Me")),
    List[Note](Note(1,"Note 1"), Note(2, "Note 2")), Status("new"))

  val taskAsJson: Json = task.asJson

  val taskBackAgain: Task =
               Parse.decodeOption[Task](taskAsJson.spaces4)</pre></div><p class="calibre7">When you've defined a codec for a specific case class, you can just call the <code class="email">asJson</code> function to convert the case class in to a <code class="email">Json</code> object. To convert from a JSON string to a case class we can use the <code class="email">Parse.decodeOption</code> function (Argonaut also provide a <code class="email">decodeEither</code> function, a <code class="email">decodeValidation</code> and a <code class="email">decodeOr</code> if you want other wrappers instead of <code class="email">Option</code>).</p><p class="calibre7">In the chapter on Akka HTTP, we already mentioned that, for JSON support, we use the spray-json library. In<a id="id357" class="calibre1"/> the following section, we'll dive a bit deeper into this library.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON">
<div class="book" title="Working with spray-json"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec31" class="calibre1"/>Working with spray-json</h2></div></div></div><p class="calibre7">spray-json provides a very easy way to work with JSON strings. To parse a string to a JSON object you can<a id="id358" class="calibre1"/> just call <code class="email">parseJson</code> on the string value.</p><div class="informalexample"><pre class="programlisting">  import spray.json._

  val parsed = json.parseJson</pre></div><p class="calibre7">The result, when printed, looks similar to this:</p><div class="informalexample"><pre class="programlisting">{"id":1,"status":{"status":"New"},"content":"This is the data to create a new task","notes":[],"title":"The Title","assignedTo":{"name":"pietje"}}</pre></div><p class="calibre7">Of course, we can also convert a JSON object back to a string by using either the <code class="email">prettyPrint</code> or <code class="email">compactPrint</code> functions:</p><div class="informalexample"><pre class="programlisting">println(parsed.prettyPrint) // or .compactPrint</pre></div><p class="calibre7">The result from <code class="email">prettyPrint</code> looks similar to this:</p><div class="informalexample"><pre class="programlisting">{
  "id": 1,
  "status": {
    "status": "New"
  },
  "content": "This is the data to create a new task",
  "notes": [],
  "title": "The Title",
  "assignedTo": {
    "name": "pietje"
  }
}</pre></div><p class="calibre7">When you want to create a JSON object by hand, spray-json provides a number of basic classes you can use for that (<code class="email">JsObject</code>, <code class="email">JsString</code>, <code class="email">JsNumber</code>, and <code class="email">JsArray</code>):</p><div class="informalexample"><pre class="programlisting">val notesList = Seq[Note](Note(1,"Note 1"), Note(2, "Note 2"))
  val manually = JsObject(
    "id" -&gt; JsNumber(1),
    "title" -&gt; JsString("title"),
    "content" -&gt; JsString("the content"),
    "assignedTo" -&gt; JsObject("name" -&gt; JsString("person")),
    "notes" -&gt; JsArray(
      notesList.map({ note =&gt;
        JsObject(
        "id" -&gt; JsNumber(note.id),
        "content" -&gt; JsString(note.content)
        )
      }).toVector),
   "status" -&gt; JsObject("status" -&gt; JsString("new"))
  )</pre></div><p class="calibre7">The result is pretty <a id="id359" class="calibre1"/>much the same object we saw in the first example of the section:</p><div class="informalexample"><pre class="programlisting">{"id":1,"status":{"status":"new"},"content":"the content","notes":[{"id":1,"content":"Note 1"},{"id":2,"content":"Note 2"}],"title":"title","assignedTo":{"name":"person"}}</pre></div><p class="calibre7">The next step we'll look at is how we can query a JSON object for a specific field. This is something for which spray-json doesn't provide specific functions or operators. The only way to access a specific field or value is by using the <code class="email">getFields</code> or <code class="email">fields</code> functions:</p><div class="informalexample"><pre class="programlisting">println(manually.getFields("id"));
println(manually.fields)</pre></div><p class="calibre7">The <code class="email">getFields</code> function returns a <code class="email">Vector</code> object, containing all the fields on the current object that match this name. The fields function returns a <code class="email">Map</code> object of all the fields.</p><p class="calibre7">The last feature we look at in each of the frameworks is how we can use it to convert from case classes to JSON and back again. In the chapter on Akka HTTP, we already showed you how to do this with spray-json:</p><div class="informalexample"><pre class="programlisting">val task = new Task(
    1, "This is the title", "This is the content", 
    Some(Person("Me")),
    List[Note](Note(1,"Note 1"), Note(2, "Note 2")), Status("new"))

  object MyJsonProtocol extends DefaultJsonProtocol {
    implicit val noteFormat = jsonFormat2(Note)
    implicit val personFormat = jsonFormat1(Person)
    implicit val statusFormat = jsonFormat1(Status)
    implicit val taskFormat = jsonFormat6(Task)
  }

  import MyJsonProtocol._
  val taskAsString = task.toJson

  // and back to a task again
  val backToTask = taskAsString.convertTo[Task]</pre></div><p class="calibre7">What we do is extend the <code class="email">DefaultJsonProtocol</code> and define, for each of our case classes, how they should be mapped through and from JSON. spray-json provides us with a very convenient helper function called <code class="email">jsonFormat#(object)</code>, where the <code class="email">#</code> corresponds to the number of arguments of the case class. With this function, we can define the default marshalling for our case classes, like we did in the preceding example. To use these implicit conversions, all we have to do is bring them in scope, and we can use the <code class="email">toJson</code> function on our case classes to serialize them to <code class="email">Json</code>, and use <code class="email">convertTo</code> to convert<a id="id360" class="calibre1"/> JSON back to our case class.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON">
<div class="book" title="Working with Play JSON"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec32" class="calibre1"/>Working with Play JSON</h2></div></div></div><p class="calibre7">The final JSON library<a id="id361" class="calibre1"/> is also one we have touched upon in the previous chapters—Play JSON. As you'll see in the code, the way this library works closely resembles the spray-json library. Let's start by looking at converting from a string into a JSON object:</p><div class="informalexample"><pre class="programlisting">import play.api.libs.json._
import play.api.libs.functional.syntax._

val fromJson = Json.parse(json)</pre></div><p class="calibre7">Very simple, just call the <code class="email">parse</code> function and provide the JSON, and the result is the following JSON object (when printed):</p><div class="informalexample"><pre class="programlisting">{"id":1,"title":"The Title","content":"This is the data to create a new task","assignedTo":{"name":"pietje"},"notes":[],"status":{"status":"New"}}</pre></div><p class="calibre7">To convert the JSON object to a string, we can either call the <code class="email">stringify</code> function directly on the JSON object or use the <code class="email">Json.prettyPrint</code> function:</p><div class="informalexample"><pre class="programlisting">println(Json.prettyPrint(fromJson))</pre></div><p class="calibre7">The <code class="email">prettyPrint</code> function returns the following result:</p><div class="informalexample"><pre class="programlisting">{
  "id" : 1,
  "title" : "The Title",
  "content" : "This is the data to create a new task",
  "assignedTo" : {
    "name" : "pietje"
  },
  "notes" : [ ],
  "status" : {
    "status" : "New"
  }
}</pre></div><p class="calibre7">Nothing too special so far. The same goes for creating JSON objects manually. Just like spray-json, Play JSON provides you <a id="id362" class="calibre1"/>with a set of base classes (<code class="email">JsObject</code>, <code class="email">JsNumber</code>, <code class="email">JsString</code>, <code class="email">JsObject</code>, and <code class="email">JsArray</code>) that you can use to create your JSON object:</p><div class="informalexample"><pre class="programlisting">// 3. Create JSON object by hand.
val notesList = Seq[Note](Note(1,"Note 1"), Note(2, "Note 2"))
val manually = JsObject(Seq(
  "id" -&gt; JsNumber(1),
  "title" -&gt; JsString("title"),
  "content" -&gt; JsString("the content"),
  "assignedTo" -&gt; JsObject(Seq("name" -&gt; JsString("person"))),
  "notes" -&gt; JsArray(
    notesList.map({ note =&gt;
      JsObject(Seq(
        "id" -&gt; JsNumber(note.id),
        "content" -&gt; JsString(note.content)
      ))
    })),
  "status" -&gt; JsObject(Seq("status" -&gt; JsString("new")))
))</pre></div><p class="calibre7">Now, let's go to querying. This is where Play JSON provides us with a couple of very useful operators:</p><div class="informalexample"><pre class="programlisting">println(manually \\ "content")
println(manually \ "assignedTo" \ "name")
println((manually \\ "id" )(2))</pre></div><p class="calibre7">With the <code class="email">\\</code> operator, we look for all the fields in the complete tree matching the field and return that as a <code class="email">List</code> object, and with the single <code class="email">\</code> operator, we look for a field in the current object. What makes this very easy to use is that these operators can easily be nested as you can see from the previous code fragment. When we look at the output, we see the following:</p><div class="informalexample"><pre class="programlisting">List("the content", "Note 1", "Note 2")
JsDefined("person")
2</pre></div><p class="calibre7">Converting to and from case classes is also very straightforward with this library. We first define a set of implicit conversions, simply by calling <code class="email">Json.format[T]</code>:</p><div class="informalexample"><pre class="programlisting">object Formats {
  implicit val noteFormat = Json.format[Note]
  implicit val statusFormat = Json.format[Status]
  implicit val personFormat = Json.format[Person]
  implicit val taskFormat = Json.format[Task]
}</pre></div><p class="calibre7">And with these<a id="id363" class="calibre1"/> implicit conversions defined, we can use the <code class="email">toJson</code> and <code class="email">fromJson[T]</code> functions to convert our case classes to and from JSON:</p><div class="informalexample"><pre class="programlisting">import Formats._

val task = new Task(
  1, "This is the title", "This is the content", Some(Person("Me")),
  List[Note](Note(1,"Note 1"), Note(2, "Note 2")), Status("new"))

val toJson = Json.toJson(task)
val andBackAgain = Json.fromJson[Task](toJson)</pre></div><p class="calibre7">Let's quickly recap the frameworks before we move on to the next subject.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;JSON, HATEOAS, and Documentation">
<div class="book" title="Working with JSON">
<div class="book" title="JSON frameworks summary"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch07lvl2sec33" class="calibre1"/>JSON frameworks summary</h2></div></div></div><p class="calibre7">So, which JSON framework is the best? Well, the general answer, of course, is it depends. All the<a id="id364" class="calibre1"/> frameworks have their advantages and disadvantages. If I do have to make a choice, I'd say that for simple JSON needs, Json4s is a really great choice. It provides a very easy way to create JSON objects from scratch, has an intuitive way of querying data, and allows you to easily convert to and from case classes. If you have more complex requirements, Argonaut is a very interesting choice. It provides a very functional way of JSON processing and has a number of interesting features for creating new JSON objects and querying the existing ones.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="HATEOAS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec48" class="calibre1"/>HATEOAS</h1></div></div></div><p class="calibre7">In the first chapter, we<a id="id365" class="calibre1"/> looked at the definition of what a RESTful service is. Part of that definition is that a REST service should use HATEOAS, which is an acronym for Hypertext As The Engine Of Application State. What this means is that to be truly RESTful, our services doesn't just need to provide more information than simply the JSON representation of a resource, but it should also provide information about the state of the application. When we talk about HATEOAS, we have to deal with the following two main principles:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Hypermedia/mime-types/media-types/content-types</strong></span>: The hypermedia of a resource describes the current state of a resource. You can look at this as a sort of contract that describes the resource we're working with. So, instead of setting the type <a id="id366" class="calibre1"/>of a resource to <code class="email">application/json</code>, you define a custom content-type like <code class="email">application/vnd.restwithscala.task+json</code>.</li><li class="listitem"><span class="strong"><strong class="calibre8">Links</strong></span>: The second <a id="id367" class="calibre1"/>part of HATEOAS is that a resource representation needs to have links to other states of the resource and actions that can be executed on that resource.</li></ul></div><p class="calibre7">For instance, the following code provides information about the current response through the <code class="email">self</code> link and uses media-types to indicate what to expect from these links:</p><div class="informalexample"><pre class="programlisting">{
  "_links" : [ {
    "rel" : "self",
    "href" : "/tasks/123",
    "media-type" : "application/vnd.restwithscala.task+json"
  }, {
    "rel" : "add",
    "href" : "/project/123/note",
    "media-type" : "application/vnd.restwithscala.note+json"
  } ],
  "id" : 1,
  "title" : "This is the title",
  "content" : "This is the content",
  "assignedTo" : {
    "name" : "Me"
  },
  "notes" : [ {
    "id" : 1,
    "content" : "Note 1"
  }, {
    "id" : 2,
    "content" : "Note 2"
  } ],
  "status" : {
    "status" : "new"
  }
}</pre></div><p class="calibre7">Since media-types are an important part of the resource, we don't just need to be able to set the media-type on the response, but also filter based on the incoming media-type, since a different media-type on a specific endpoint can have a different meaning.</p></div>

<div class="book" title="HATEOAS">
<div class="book" title="Handling media-types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec34" class="calibre1"/>Handling media-types</h2></div></div></div><p class="calibre7">Now let us <a id="id368" class="calibre1"/>walk through the frameworks discussed in this book and see how they handle media-types. You can, of course, run all these examples from<a id="id369" class="calibre1"/> the code provided with this book. You can use the following commands to start the various servers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">sbt runCH07-Finch</strong></span>
<span class="strong"><strong class="calibre8">sbt runCH07-Unfiltered</strong></span>
<span class="strong"><strong class="calibre8">sbt runCH07-Scalatra</strong></span>
<span class="strong"><strong class="calibre8">sbt runCH07-akkahttp</strong></span>
<span class="strong"><strong class="calibre8">sbt runCH07-play</strong></span>
</pre></div><p class="calibre7">We have also provided a number of requests in Postman that you can use to test whether media handling works. You can find these in the <span class="strong"><strong class="calibre8">Chapter 07</strong></span> collection:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Handling media-types" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The first framework we'll explore is Finch.</p><div class="book" title="Handling media-types with Finch"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec01" class="calibre1"/>Handling media-types with Finch</h3></div></div></div><p class="calibre7">To handle media-types<a id="id370" class="calibre1"/> with Finch, we're going to create a filter. This<a id="id371" class="calibre1"/> filter, and the code to glue everything together, is shown here:</p><div class="informalexample"><pre class="programlisting">  val MediaType = "application/vnd.restwithscala.task+json"
  val filter = new SimpleFilter[HttpRequest, HttpResponse] {
    def apply(req: HttpRequest, 
              service: Service[Request, HttpResponse])
                                        : Future[HttpResponse] = {
      req.contentType match {
        case Some(MediaType) =&gt; service.apply(req).map({ resp =&gt;
          resp.setContentType(MediaType, "UTF-8")
          resp
        })
        case Some(_) =&gt; Future
          {BadRequest(s"Media type not understood, use $MediaType")}
        case None =&gt; Future
          {BadRequest(s"Media type not present, use $MediaType")}
      }
    }
  }

  val matchTaskFilter: Matcher = "tasksFilter"
  val createTask = CreateNewTask()
  val createNewTaskFilter = filter andThen createTask

  val taskCreateAPI =
     Post / matchTaskFilter /&gt; createNewTaskFilter</pre></div><p class="calibre7">You can create a<a id="id372" class="calibre1"/> filter by extending the <code class="email">SimpleFilter</code> class. This<a id="id373" class="calibre1"/> filter provides access to the incoming <code class="email">HttpRequest</code> instance and the outgoing <code class="email">HttpResponse</code> instance. In this filter, we check whether the media-type is the correct one, and if this is the case, we process the request. If not, we return a <code class="email">BadRequest</code> response. To give the client an indication of the type of response they are dealing with, we also set the media-type on the response object. With the filter defined, we create our route and invoke the <code class="email">createNewTaskFilter</code> instance, which first calls the <code class="email">filter</code> instance and then the <code class="email">createTask</code> service. Now whenever a request with the correct media-type comes in, it is processed in the correct manner.</p></div><div class="book" title="Handling media-types with Unfiltered"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec02" class="calibre1"/>Handling media-types with Unfiltered</h3></div></div></div><p class="calibre7">Filtering on media-types is very easy to do in Unfiltered. We use some basic Scala pattern matching<a id="id374" class="calibre1"/> to check whether the <code class="email">POST</code> on a specific<a id="id375" class="calibre1"/> path contains the correct media-type:</p><div class="informalexample"><pre class="programlisting">val MediaType = "application/vnd.restwithscala.task+json"

case req @ Path("/tasks") =&gt; (req, req) match {
  case (req @ POST(_), (RequestContentType(MediaType))) =&gt; handleCreateTask(req).map(Ok ~&gt; ResponseHeader("content-type",
                              Set(MediaType)) ~&gt; ResponseString(_))</pre></div><p class="calibre7">As you can see, all we do is pattern match two request properties, the verb (<code class="email">POST</code>) and the content-type of the request; when those match, we process the request, and set the correct header on the response.</p></div><div class="book" title="Handling media-types with Scalatra"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec03" class="calibre1"/>Handling media-types with Scalatra</h3></div></div></div><p class="calibre7">The next one to discuss on the list of frameworks is Scalatra. As we have seen when discussing Scalatra, it provides <a id="id376" class="calibre1"/>a way to define a <code class="email">before</code> function and an <code class="email">after</code> function for a specific path. We use that functionality to check<a id="id377" class="calibre1"/> in the <code class="email">before</code> function whether the media-type matches, and in the <code class="email">after</code> function, we update the content-type:</p><div class="informalexample"><pre class="programlisting">before("/tasks") {
    (request.getMethod, request.contentType) match {
      case ("POST", Some(MediaType)) =&gt; // do nothing
      case ("POST", _) =&gt; halt(status = 400, reason = "Unsupported Mimetype")
      case (_,_) =&gt; // do nothing since it isn't a post
    }
  }
  
  after("/task") {
    request.getMethod match {
      case "POST" =&gt; response.setContentType(MediaType)
      case _ =&gt; // do nothing since it isn't a post
    }    
  }</pre></div><p class="calibre7">As you can see, we <a id="id378" class="calibre1"/>use pattern matching to match a specific verb and content-type. This means that if we have a <code class="email">POST</code> verb and the correct content-type, we execute the request. If the verb matches but the content-type doesn't, we respond with a bad request and if the verb doesn't match, we just process it normally.</p></div><div class="book" title="Handling media-types with Akka HTTP"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec04" class="calibre1"/>Handling media-types with Akka HTTP</h3></div></div></div><p class="calibre7">Using media-types with Akka HTTP takes a bit more work. The reason is that Akka HTTP extracts the <a id="id379" class="calibre1"/>content-type out of the headers and adds it to the entity. This means we have to check the entity for the existence of a specific <a id="id380" class="calibre1"/>content-type instead of just checking a header. The first thing we do is define the content-type we're looking for, and a function, which we can use to transform the response object and set the correct type on the response:</p><div class="informalexample"><pre class="programlisting">  val CustomContentType = 
  MediaType.custom("application/vnd.restwithscala.task+json",
                    Encoding.Fixed(HttpCharsets.`UTF-8`))

  def mapEntity(entity: ResponseEntity): ResponseEntity = entity match {
    case HttpEntity.Strict(contentType, data) =&gt;
      HttpEntity.Strict(CustomContentType, data)
    case _ =&gt; throw new IllegalStateException(
       "Unexpected entity type")
  }</pre></div><p class="calibre7">As you can see, the <code class="email">mapEntity</code> function takes a <code class="email">ResponseEntity</code> instance as its parameters, and returns a new one <a id="id381" class="calibre1"/>with the correct content-type. In the next code fragment, we'll show how you can check the incoming request for the correct content-type and use the previously-defined function to set the response:</p><div class="informalexample"><pre class="programlisting">            post {
                (entity(as[String]) &amp; (extractRequest)) { 
                  (ent, request) =&gt;
                request.entity.contentType() match {
                  case ContentType(MediaType(
                      "application/vnd.restwithscala.task+json")
                      , _) =&gt;
                    mapRequest({ req =&gt; req.copy(entity = 
                      HttpEntity.apply(MediaTypes.`application/json`,
                      ent)) }) {
                      (entity(as[Task])) {
                        task =&gt; {
                          mapResponseEntity(mapEntity) {
                            complete {
                              TaskService.insert(task)
                            }
                          }
                        }
                      }
                    }
                  case _ =&gt; complete(StatusCodes.BadRequest,
                                     "Unsupported mediatype")
                }
            }
          }</pre></div><p class="calibre7">A lot is happening here, so let's look at the directives we use here and why:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we extract the request and the entity of the request (the body and content-type) with the <code class="email">entity</code> and <code class="email">extractRequest</code> directives.</li><li class="listitem" value="2">Next, we match the <code class="email">request.entity.contentType</code> property of the entity, and if it matches, we create a new entity with the <code class="email">application/json</code> content-type. We do this so that the standard JSON-to-case-class mapping of Akka HTTP still works.</li><li class="listitem" value="3">Next, we <a id="id382" class="calibre1"/>convert the entity in to a <code class="email">Task</code> instance, call the service, and create a response.</li><li class="listitem" value="4">Before the response is returned, the <code class="email">mapResponseEntity</code> function is called, which sets the content-type to our original value.</li></ol><div class="calibre13"/></div><p class="calibre7">Note that instead <a id="id383" class="calibre1"/>of an approach using directives, we could also have redefined the required implicits to make the JSON conversion work with our own custom content-type.</p></div><div class="book" title="Handling media-types with Play 2"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec05" class="calibre1"/>Handling media-types with Play 2</h3></div></div></div><p class="calibre7">To implement custom <a id="id384" class="calibre1"/>media-types in Play 2, we'll use an <code class="email">ActionBuilder</code> approach. With an <code class="email">ActionBuilder</code> approach, we can change the way an action is invoked. The following code shows what the <code class="email">ActionBuilder</code> approach<a id="id385" class="calibre1"/> of this example looks like:</p><div class="informalexample"><pre class="programlisting">object MediaTypeAction extends ActionBuilder[Request] {

  val MediaType = "application/vnd.restwithscala.task+json"

  def invokeBlock[A](request: Request[A], block: (Request[A]) =&gt; Future[Result]) = {
    request.headers.get("Content-Type") match  {
      case Some(MediaType) =&gt; {
          block(request)
      }
      case _ =&gt; Future{BadRequest("Unsupported mimetype")}
    }
  }
}</pre></div><p class="calibre7">Here, we define a new type of action, called a <code class="email">MediaTypeAction</code>. When we use this action instead of the normal <code class="email">Action</code> class, first the content-type of the incoming message is checked; if it matches, the request is processed; if not, the request is ignored and a <code class="email">BadRequest</code> response is generated.</p><p class="calibre7">We can use this new <code class="email">MediaTypeAction</code> in the following manner:</p><div class="informalexample"><pre class="programlisting">  def createTask = MediaTypeAction.async((parse.tolerantJson)) { request =&gt;

    val body = request.body.validate[Task]

    // option defines whether we have a JSON body or not.
    body match {
        case JsSuccess(task, _) =&gt; TaskService.insert(task).map(
           b =&gt; Ok(Json.toJson(b)).as(MediaTypeAction.MediaType))
        case JsError(errors) =&gt; Future{BadRequest(errors.mkString("\n"))}
    }
  }</pre></div><p class="calibre7">As you can see, we just replace the <code class="email">Action</code> with <code class="email">MediaTypeAction</code> and that's it. When this action is called, first the code from <code class="email">MediaTypeAction</code> is executed, then the code is provided to the <code class="email">Action</code>. To properly convert the incoming data to a JSON object, we need to make some small changes to the way we handle JSON. We use an explicit body parser (<code class="email">parse.tolerantJson</code>) to parse the incoming JSON. With the function, we don't check whether the provided content-type is <code class="email">application/json</code>, but just convert the body.</p><p class="calibre7">In the beginning <a id="id386" class="calibre1"/>of this section, we explained two important parts of HATEOAS: media-type handling and supporting links. In the next section, we'll show<a id="id387" class="calibre1"/> a way you can add links to your case classes easily.</p></div></div></div>

<div class="book" title="HATEOAS">
<div class="book" title="Using links"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec35" class="calibre1"/>Using links</h2></div></div></div><p class="calibre7">For the links, we're going<a id="id388" class="calibre1"/> to create a very simple extension to our model. Instead of just sending the case class serialized to JSON, we're adding a <code class="email">_links</code> object. This object can contain different links. For instance, it can not only define a link to the resource itself, but also can contain links to actions that can be executed on this resource. The final JSON we're aiming for looks similar to this:</p><div class="informalexample"><pre class="programlisting">{
  "_links" : [ {
    "rel" : "self",
    "href" : "/tasks/123",
    "media-type" : "application/vnd.restwithscala.task+json"
  } ],
  "id" : 1,
  "title" : "This is the title",
  "content" : "This is the content",
  "assignedTo" : {
    "name" : "Me"
  },
  "notes" : [ {
    "id" : 1,
    "content" : "Note 1"
  }, {
    "id" : 2,
    "content" : "Note 2"
  } ],
  "status" : {
    "status" : "new"
  }
}</pre></div><p class="calibre7">As an example, we'll use Play JSON, but pretty much the same approach can be used with the other JSON libraries explored in this chapter. The first thing we do is define what the links will look like. For this, we define a trait and a case class:</p><div class="informalexample"><pre class="programlisting">import org.restwithscala.common.model.{Note, Person, Status, Task}
import play.api.libs.json._
import play.api.libs.functional.syntax._

object PlayJsonLinks extends App {

  trait HasLinks {
    val links: List[Links]
  }

  case class Links(rel: String, href: String, `media-type`: String)</pre></div><p class="calibre7">When we create a new <code class="email">Task</code>, we can extend from this trait to add links. As we have explained before, Play<a id="id389" class="calibre1"/> JSON uses implicit values to determine how to serialize a specific class to JSON. For this scenario, we define the following implicit values:</p><div class="informalexample"><pre class="programlisting">  trait LowPriorityWritesInstances {

    // use standard writes for the case classes
    implicit val statusWrites = Json.writes[Status]
    implicit val noteWrites = Json.writes[Note]
    implicit val personWrites = Json.writes[Person]
    implicit val taskWrites = Json.writes[Task]
    implicit val linkWrites = Json.writes[Links]

    // and a custom one for the trait
    implicit object hiPriorityWrites extends OWrites[HasLinks] {
      def writes(hi: HasLinks) = Json.obj("_links" -&gt; hi.links)
    }
  }

  /**
   * The write instance which we include
   */
  object WritesInstances extends LowPriorityWritesInstances {
  implicit val taskWithLinksWrites = new Writes[Task with HasLinks] {
      def writes(o: Task with HasLinks) = {
        (implicitly[OWrites[HasLinks]].writes(o)) ++ 
                    taskWrites.writes(o).as[JsObject]
      }
    }
  }</pre></div><p class="calibre7">What happens here is that we define the standard implicits for the various parts of our model, including our new <code class="email">HasLinks</code> trait. Besides that, we also define a very specific implicit that <a id="id390" class="calibre1"/>matches <code class="email">Tasks</code> that extend the <code class="email">HasLinks</code> trait. So, when we call the <code class="email">toJson</code> function on a <code class="email">Task</code> that extends <code class="email">HasLinks</code>, the <code class="email">taskWithLinksWrites</code> will match. In the <code class="email">writes</code> function, we first convert the <code class="email">Links</code> object and combine this with the converted <code class="email">Task</code>.</p><p class="calibre7">To use this, all we have to do is define a new <code class="email">Task</code> and use with <code class="email">HasLinks</code> to add any links we have:</p><div class="informalexample"><pre class="programlisting">val task = new Task(
    1, "This is the title", "This is the content", 
    Some(Person("Me")), List[Note](Note(1,"Note 1"), 
       Note(2, "Note 2")), Status("new")) with HasLinks {
         val links = 
             List(Links("self",
                        "/tasks/123",        
                        "application/vnd.restwithscala.task+json"))
  }

  // import the implicit convertors
  import WritesInstances._

  println(Json.prettyPrint(Json.toJson(task)))
}</pre></div><p class="calibre7">Now, after importing the correct implicits, we can convert the <code class="email">Task</code> with <code class="email">HasLinks</code> to JSON, just like we do other objects.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec49" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this final chapter, we looked at a couple of important aspects of REST. We explored the various JSON libraries that can be used in your REST services for converting objects to and from JSON. Besides that, we looked at a very important aspect of REST called HATEOAS. The most important aspect of HATEOAS is the ability to detect and filter on media-type (content-type) and to add links to your resources to create self-describing APIs. We saw how to detect and work with media-types in the frameworks discussed in this book, and how to add links with one of the JSON frameworks explored in this chapter.</p><p class="calibre7">With this last section on adding links to a JSON response, we have reached the end of this book. In the various chapters, we explored the most important features of a number of REST frameworks that are available in the Scala ecosystem.</p><p class="calibre7">In the previous chapters, we tried to show you the most important features of these frameworks and explain how to use these features to create scalable, asynchronous, and maintainable REST services. Please keep in mind that each of these frameworks has many more features than we could explore in this book.</p><p class="calibre7">I hope you have had fun reading the book and experimenting with the examples. If you like them, feel free to use them, expand them, and share the results!</p></div></body></html>