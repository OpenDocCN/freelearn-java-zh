<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Understanding WebSockets and Server-sent Events in Detail"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Understanding WebSockets and Server-sent Events in Detail</h1></div></div></div><p>WebSocket<a id="id235" class="indexterm"/> is one of the most promising features that HTML5<a id="id236" class="indexterm"/> has to offer. As covered in <a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, the traditional request-response model incurred an overhead due to the HTTP headers. With WebSockets, once the initial handshake is done the client and server or peers can communicate directly without the use of headers. This reduces the network latency and gives a reduction in HTTP header traffic.</p><p>
<a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, also introduced Server-sent Events and provides a comparison between SSE and WebSockets.</p><p>Server-sent Events<a id="id237" class="indexterm"/> define an API where the server communicates and pushes events to the clients as they occur. It is a one-directional communication from the server to the client and has more benefits as compared to traditional polling and long polling techniques.</p><p>This chapter covers advanced concepts of WebSockets and Server-sent Events and covers the following sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Encoders and decoders in Java API for WebSockets</li><li class="listitem" style="list-style-type: disc">Java WebSockets Client API</li><li class="listitem" style="list-style-type: disc">Sending different types of data such as Blob and Binary using Java API for WebSockets</li><li class="listitem" style="list-style-type: disc">Security and WebSockets</li><li class="listitem" style="list-style-type: disc">Best practices for WebSockets-based applications</li><li class="listitem" style="list-style-type: disc">Developing Server-sent Events clients using Jersey API</li><li class="listitem" style="list-style-type: disc">Best practices for Server-sent Events</li></ul></div><div class="section" title="Encoders and decoders in Java API for WebSockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Encoders and decoders in Java API for WebSockets</h1></div></div></div><p>As seen in the <a id="id238" class="indexterm"/>previous chapter<a id="id239" class="indexterm"/>, the class-level annotation <code class="literal">@ServerEndpoint</code> indicates that a Java class is a WebSocket endpoint at runtime. The value attribute is used to specify a URI mapping for the endpoint. Additionally the user can add encoder and decoder attributes to encode application objects into WebSocket messages and WebSocket messages into application objects.</p><p>The following table summarizes<a id="id240" class="indexterm"/> the <code class="literal">@ServerEndpoint</code> annotation and its attributes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ServerEndpoint</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>This<a id="id241" class="indexterm"/> class-level annotation signifies that the Java class is a WebSockets server endpoint.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id242" class="indexterm"/>value is the URI with a leading <code class="literal">'/.'</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">encoders</code>
</p>
</td><td style="text-align: left" valign="top">
<a id="id243" class="indexterm"/>
<p>Contains a list of Java classes that act as encoders for the endpoint. The classes must implement the Encoder interface.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">decoders</code>
</p>
</td><td style="text-align: left" valign="top">
<a id="id244" class="indexterm"/>
<p>Contains a list of Java classes that act as decoders for the endpoint. The classes must implement the Decoder interface.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">configurator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id245" class="indexterm"/>configurator attribute allows the developer to plug in their implementation of <code class="literal">ServerEndpoint.Configurator</code> that is used when configuring the server endpoint.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">subprotocols</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id246" class="indexterm"/>sub protocols attribute contains a list of sub protocols that the endpoint can support.</p>
</td></tr></tbody></table></div><p>In this section we shall look at providing encoder and decoder implementations for our WebSockets endpoint.</p><div class="mediaobject"><img src="graphics/8125ENT_03_01.jpg" alt="Encoders and decoders in Java API for WebSockets"/></div><p>The preceding diagram shows<a id="id247" class="indexterm"/> how encoders<a id="id248" class="indexterm"/> will take an application object and convert it to a WebSockets message. Decoders<a id="id249" class="indexterm"/> will take a WebSockets message and convert<a id="id250" class="indexterm"/> to an application object. Here is a simple example where a client sends a WebSockets message to a WebSockets java endpoint that is annotated with <code class="literal">@ServerEndpoint</code> and decorated with encoder and decoder class. The decoder will decode the WebSockets message and send back the same message to the client. The encoder will convert the message to a WebSockets message. This sample is also included in the code bundle for the book.</p><p>Here is the code to define <code class="literal">ServerEndpoint</code> with value for encoders and decoders:</p><div class="informalexample"><pre class="programlisting">@ServerEndpoint(value="/book", encoders={MyEncoder.class}, decoders = {MyDecoder.class} )
public class BookCollection {
    @OnMessage
    public void onMessage(Book book,Session session) {
        
        try {
session.getBasicRemote().sendObject(book);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    @OnOpen
       public void onOpen(Session session) {
           System.out.println("Opening socket" +session.getBasicRemote() );
       }

       @OnClose
       public void onClose(Session session) {
           System.out.println("Closing socket" + session.getBasicRemote());
       }
} </pre></div><p>In the preceding code snippet, you can see the class <code class="literal">BookCollection</code> is annotated with <code class="literal">@ServerEndpoint</code>. The <code class="literal">value=/book</code> attribute provides URI mapping for the endpoint.  The <code class="literal">@ServerEndpoint</code> also takes the encoders and decoders to be used during the WebSocket transmission. Once a WebSocket connection has been established, a session is created and the method annotated with <code class="literal">@OnOpen</code> <a id="id251" class="indexterm"/>will be called. When the WebSocket endpoint receives a message, the method annotated with <code class="literal">@OnMessage</code> <a id="id252" class="indexterm"/>will be called. In our sample the method simply sends the book object using the <code class="literal">Session.getBasicRemote()</code> which will get a reference to the <code class="literal">RemoteEndpoint</code> and send the message synchronously.</p><p>Encoders<a id="id253" class="indexterm"/> can be <a id="id254" class="indexterm"/>used to convert a <a id="id255" class="indexterm"/>custom user-defined object in a text message, <code class="literal">TextStream</code>, <code class="literal">BinaryStream</code>, or <code class="literal">BinaryMessage</code> format.</p><p>An implementation of an encoder class for text messages is as follows:</p><div class="informalexample"><pre class="programlisting">public class MyEncoder implements Encoder.Text&lt;Book&gt; {
    @Override
<span class="strong"><strong>        public String encode(Book book) throws EncodeException {</strong></span>
            return book.getJson().toString();
        }
}</pre></div><p>As shown in the preceding code, the encoder class implements <code class="literal">Encoder.Text&lt;Book&gt;</code>. There is an encode method that is overridden and which converts a book and sends it as a JSON string. (More on JSON APIs is covered in detail in the next chapter)</p><p>Decoders<a id="id256" class="indexterm"/> can be used<a id="id257" class="indexterm"/> to decode WebSockets messages in custom user-defined objects. They can decode in text, <code class="literal">TextStream</code>, and binary or <code class="literal">BinaryStream</code> format.</p><p>Here is a code for a decoder class:</p><div class="informalexample"><pre class="programlisting">public class MyDecoder implements Decoder.Text&lt;Book&gt; {
    @Override
<code class="literal"> </code><span class="strong"><strong>   public Book decode(String string) throws DecodeException {</strong></span>
           javax.json.JsonObject jsonObject = javax.json.Json.createReader(new StringReader(string)).readObject();
        return new Book(jsonObject);
    }
    @Override
    public boolean willDecode(String string) {
        try {
            javax.json.Json.createReader(new StringReader(string)).readObject();
            return true;
        } catch (Exception ex) { }
        return false;
        }</pre></div><p>In the preceding code snippet, the <code class="literal">Decoder.Text</code> needs two methods to be overridden. The <code class="literal">willDecode()</code> method<a id="id258" class="indexterm"/> checks if it can handle this object and decode it. The <code class="literal">decode()</code> method<a id="id259" class="indexterm"/> decodes the string into an object of type <code class="literal">Book</code> by using the JSON-P API <code class="literal">javax.json.Json.createReader()</code>.</p><p>The following code snippet shows the user-defined class <code class="literal">Book</code>:</p><div class="informalexample"><pre class="programlisting">public class Book {
    public Book() {}
    JsonObject jsonObject;
    public Book(JsonObject json) {
        this.jsonObject = json;
    }
    public JsonObject getJson() {
        return jsonObject;
    }
    public void setJson(JsonObject json) {
        this.jsonObject = json;
    }

    public Book(String message) {
        jsonObject = Json.createReader(new StringReader(message)).readObject();
    }
    public String toString () {
        StringWriter writer = new StringWriter();
        Json.createWriter(writer).write(jsonObject);
        return writer.toString();
    }
}</pre></div><p>The <code class="literal">Book</code> class<a id="id260" class="indexterm"/> is a user-defined class that takes the JSON object sent by the client. Here is an example of how the JSON details are sent to the WebSockets endpoints from JavaScript.</p><div class="informalexample"><pre class="programlisting">var json = JSON.stringify({
                    "name": "Java 7 JAX-WS Web Services",
                "author":"Deepak Vohra",
                "isbn": "123456789"
                });
function addBook() {
                websocket.send(json);
            }</pre></div><p>The client sends the <a id="id261" class="indexterm"/>message using <code class="literal">websocket.send()</code> which will cause the <code class="literal">onMessage()</code> of the <code class="literal">BookCollection.java</code> to be invoked. The <code class="literal">BookCollection.java</code> will return the same book to the client. In the process, the decoder will decode the WebSockets message when it is received. To send back the same <code class="literal">Book</code> object, first the encoder will encode the <code class="literal">Book</code> object to a WebSockets message and send it to the client.</p></div></div>
<div class="section" title="The Java WebSocket Client API"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>The Java WebSocket Client API</h1></div></div></div><p>
<a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, covered the Java WebSockets client API. Any POJO can be transformed into a <a id="id262" class="indexterm"/>WebSockets client by annotating it with <code class="literal">@ClientEndpoint</code>.</p><p>Additionally the user can add encoders and decoders attributes to the <code class="literal">@ClientEndpoint</code> annotation to encode application objects into WebSockets messages and WebSockets messages into application objects.</p><p>The following table shows the<a id="id263" class="indexterm"/> <code class="literal">@ClientEndpoint</code> annotation<a id="id264" class="indexterm"/> and its attributes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ClientEndpoint</code>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>This class-level annotation signifies that the Java class is a WebSockets client that will connect to a WebSockets server endpoint.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id265" class="indexterm"/>value is the URI with a leading <code class="literal">/</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">encoders</code>
</p>
</td><td style="text-align: left" valign="top">
<a id="id266" class="indexterm"/>
<p>Contains a list of Java classes that act as encoders for the endpoint. The classes must implement the encoder interface.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">decoders</code>
</p>
</td><td style="text-align: left" valign="top">
<a id="id267" class="indexterm"/>
<p>Contains a list of Java classes that act as decoders for the endpoint. The classes must implement the decoder interface.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">configurator</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id268" class="indexterm"/>configurator attribute allows the developer to plug in their implementation of <code class="literal">ClientEndpoint.Configurator</code>, which is used when configuring the client endpoint.</p>
</td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>
<code class="literal">subprotocols</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The <a id="id269" class="indexterm"/>sub protocols attribute contains a list of sub protocols that the endpoint can support.</p>
</td></tr></tbody></table></div></div>
<div class="section" title="Sending different kinds of message data: blob/binary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Sending different kinds of message data: blob/binary</h1></div></div></div><p>Using JavaScript we can <a id="id270" class="indexterm"/>traditionally send JSON or XML as strings. However, HTML5 allows applications to work with binary data to improve performance. WebSockets <a id="id271" class="indexterm"/>supports two <a id="id272" class="indexterm"/>kinds of binary data</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binary Large Objects (<code class="literal">blob</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">arraybuffer</code></li></ul></div><p>A WebSocket can work with only one of the formats at any given time.</p><p>Using the <code class="literal">binaryType</code> property of a WebSocket, you can switch between using blob or <code class="literal">arraybuffer</code>:</p><div class="informalexample"><pre class="programlisting">websocket.binaryType = "blob";
// receive some blob data

websocket.binaryType = "arraybuffer";
// now receive ArrayBuffer data</pre></div><p>The following code snippet shows how to display images sent by a server using WebSockets.</p><p>Here is a code snippet for how to send binary data with WebSockets:</p><div class="informalexample"><pre class="programlisting">websocket.binaryType = 'arraybuffer';</pre></div><p>The <a id="id273" class="indexterm"/>preceding<a id="id274" class="indexterm"/> code snippet sets the <code class="literal">binaryType</code> property of <code class="literal">websocket</code> to <code class="literal">arraybuffer</code>.</p><div class="informalexample"><pre class="programlisting">websocket.onmessage = function(msg) {
        var arrayBuffer = msg.data;
        var bytes = new Uint8Array(arrayBuffer);

        var image = document.getElementById('image');
        image.src = 'data:image/png;base64,'+encode(bytes);
    }</pre></div><p>When the <code class="literal">onmessage</code> is called the <code class="literal">arrayBuffer</code> is initialized to the <code class="literal">message.data</code>. The <code class="literal">Uint8Array</code> type represents an array of 8-bit unsigned integers. The <code class="literal">image.src</code> value is in line using the data URI scheme.</p></div>
<div class="section" title="Security and WebSockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Security and WebSockets</h1></div></div></div><p>WebSockets are secured <a id="id275" class="indexterm"/>using the web container security model. A WebSockets developer can declare whether the access to the WebSocket server endpoint needs to be authenticated, who can access it, or if it needs an encrypted connection.</p><p>A WebSockets endpoint which is mapped to a <code class="literal">ws://</code> URI is protected under the deployment descriptor with <code class="literal">http:// URI</code> with the same <code class="literal">hostname,port</code> path since the initial handshake is from the HTTP connection. So, WebSockets developers can assign an authentication scheme, user roles, and a transport guarantee to any WebSockets endpoints.</p><p>We will take the same sample as we saw in <a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, and make it a secure WebSockets application.</p><p>Here is the <code class="literal">web.xml</code> for a secure WebSocket endpoint:</p><div class="informalexample"><pre class="programlisting">&lt;web-app version="3.0"  
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;BookCollection&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;
            &lt;http-method&gt;PUT&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
            &lt;http-method&gt;DELETE&lt;/http-method&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;
            &lt;user-data-constraint&gt;
            &lt;description&gt;SSL&lt;/description&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
&lt;/web-app&gt;</pre></div><p>As you can see in the preceding snippet, we used <code class="literal">&lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;</code>.</p><p>The Java EE <a id="id276" class="indexterm"/>specification followed by application servers provides different levels of transport guarantee on the communication between clients and application server. The three levels are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data Confidentiality (CONFIDENTIAL)</strong></span>: We use<a id="id277" class="indexterm"/> this level to guarantee that all communication between client and server goes through the SSL layer and connections won't be accepted over a non-secure channel.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data Integrity (INTEGRAL)</strong></span>: We <a id="id278" class="indexterm"/>can use this level when a full encryption is not required but we want our data to be transmitted to and from a client in such a way that, if anyone changed the data, we could detect the change.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Any type of connection (NONE)</strong></span>: We can use this level to force the container to accept connections on HTTP and HTTPs.</li></ul></div><p>The following steps should be followed for setting up SSL and running our sample to show a secure WebSockets application deployed in Glassfish.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate the server certificate:<div class="informalexample"><pre class="programlisting">keytool -genkey -alias server-alias -keyalg RSA -keypass changeit --storepass changeit -keystore keystore.jks</pre></div></li><li class="listitem">Export the generated server certificate in <code class="literal">keystore.jks</code> into the file <code class="literal">server.cer</code>:<div class="informalexample"><pre class="programlisting">keytool -export -alias server-alias -storepass changeit -file server.cer -keystore keystore.jks</pre></div></li><li class="listitem">Create the trust-store file <code class="literal">cacerts.jks</code> and add the server certificate to the trust store:<div class="informalexample"><pre class="programlisting">keytool -import -v -trustcacerts -alias server-alias -file server.cer  -keystore cacerts.jks -keypass changeit -storepass changeit</pre></div></li><li class="listitem">Change the following JVM options so that they point to the location and name of the new keystore. Add this in <code class="literal">domain.xml</code> under <code class="literal">java-config</code>:<div class="informalexample"><pre class="programlisting">&lt;jvm-options&gt;-Djavax.net.ssl.keyStore=${com.sun.aas.instanceRoot}/config/keystore.jks&lt;/jvm-options&gt;
        &lt;jvm-options&gt;-Djavax.net.ssl.trustStore=${com.sun.aas.instanceRoot}/config/cacerts.jks&lt;/jvm-options&gt;</pre></div></li><li class="listitem">Restart <a id="id279" class="indexterm"/>GlassFish. If you go to <code class="literal">https://localhost:8181/helloworld-ws/</code>, you can see the secure WebSocket application.</li><li class="listitem">Here is how the the headers look under Chrome Developer Tools:<div class="mediaobject"><img src="graphics/8125ENT_03_02.jpg" alt="Security and WebSockets"/></div></li><li class="listitem">Open Chrome Browser and click on <span class="strong"><strong>View</strong></span> and then on <span class="strong"><strong>Developer Tools</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Network</strong></span>.</li><li class="listitem">Select <span class="strong"><strong>book</strong></span> under element name and click on <span class="strong"><strong>Frames</strong></span>.</li></ol></div><p>As you can see in the preceding screenshot, since the application is secured using SSL the WebSockets URI, it also contains <code class="literal">wss://</code>, which means WebSockets over SSL.</p><p>So far we have seen the encoders and decoders for WebSockets messages. We also covered how to send binary data using WebSockets. Additionally we have demonstrated a sample on how to secure WebSockets based application. We shall now cover the best practices for <a id="id280" class="indexterm"/>WebSocket based-applications.</p></div>
<div class="section" title="Best practices for WebSockets based applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Best practices for WebSockets based applications</h1></div></div></div><p>This section will cover <a id="id281" class="indexterm"/>best practices for <a id="id282" class="indexterm"/>WebSockets based applications. The following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Throttling the rate of sending data</li><li class="listitem" style="list-style-type: disc">Controlling the maximum size of the message</li><li class="listitem" style="list-style-type: disc">Working with proxy servers and WebSockets</li></ul></div><div class="section" title="Throttling the rate of sending data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Throttling the rate of sending data</h2></div></div></div><p>After the WebSocket<a id="id283" class="indexterm"/> connection is opened, messages can be sent using the send function.</p><p>WebSockets have a <code class="literal">bufferedAmount</code> attribute that can be used to control the rate of sending data. Using the <code class="literal">bufferedAmount</code> attribute you can check the number of bytes that have been queued but not yet sent to the server.</p><p>Here is a snippet to test for the <code class="literal">bufferedAmount</code> attribute of WebSocket.</p><div class="informalexample"><pre class="programlisting">// This snippet checks for amount of data buffered but not sent yet 
// in case it is less than a predefined THRESHOLD the webSocket 
// can send the data

if (webSocket.bufferedAmount &lt; THRESHOLD)
     webSocket.send(someData);
};</pre></div><p>This can be done periodically using the <code class="literal">setInterval</code> function. As you can see, the developer can periodically check for the <code class="literal">bufferedAmount</code> attribute to see if the number of bytes in the queue to be sent to the server exceeds some threshold. In that case it should delay sending messages. Once the buffered amount is less than the threshold it should send more messages.</p><p>This is a good practice to check for the <code class="literal">bufferedAmount</code> and then send data.</p></div><div class="section" title="Controlling the maximum size of the message"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Controlling the maximum size of the message</h2></div></div></div><p>The <code class="literal">maxMessageSize</code> attribute <a id="id284" class="indexterm"/>on the <code class="literal">@OnMessage</code> annotation in Java class annotated with <code class="literal">@ServerEndpoint</code> or <code class="literal">@ClientEndpoint</code> allows the developer to specify the maximum size of message in bytes that can be handled by the <code class="literal">ClientEndpoint</code> or <code class="literal">ServerEndpoint</code>.</p><p>If the incoming message exceeds the maximum size then the connection is closed. This is a good practice to control the maximum size of a message so that the client does not deplete its resources while trying to handle a message, which it can't process.</p></div><div class="section" title="Working with proxy servers and WebSockets"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Working with proxy servers and WebSockets</h2></div></div></div><p>
<a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Event</em></span>, covered how the WebSocket upgrade handshake looks. Not all <a id="id285" class="indexterm"/>proxy <a id="id286" class="indexterm"/>servers may support WebSockets; thus, proxy servers may not allow unencrypted WebSocket traffic to flow through. The clients use a <code class="literal">CONNECT</code> call which would never be allowed. The correct approach would be to send the request over https on the standard port <code class="literal">443</code>. Here is an example of the HTTP Connect sent by the browser client to <code class="literal">foo.com</code> on port <code class="literal">443</code>.</p><div class="informalexample"><pre class="programlisting">CONNECT: foo.com:443
Host: foo.com</pre></div><p>Since the traffic is encrypted there is a greater chance to pass through the proxy server. Then the <code class="literal">CONNECT</code> statements will work and there will be an end-to-end encrypted tunnel for WebSockets.</p><p>The following diagram shows how clients can send HTTPS requests which get past the proxy server and firewall; the WebSocket secure scheme will work:</p><div class="mediaobject"><img src="graphics/8125ENT_03_03.jpg" alt="Working with proxy servers and WebSockets"/></div><p>It is a good practice to use WebSocket-based applications with SSL so that the Proxy server does not impede WebSocket communication.</p></div></div>
<div class="section" title="Server-sent Events"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Server-sent Events</h1></div></div></div><p>We covered <a id="id287" class="indexterm"/>Server-sent Events in <a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, and compared and contrasted client/server polling alternatives as well as WebSockets. In this chapter we will cover more advanced topics such as developing a Server-sent Events client using Jersey API and best practices for Server-sent Events.</p><div class="section" title="Developing a Server-sent Event client using Jersey API"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Developing a Server-sent Event client using Jersey API</h2></div></div></div><p>
<a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, gave a brief introduction to the Server-sent Events and <a id="id288" class="indexterm"/>JavaScript API. In this <a id="id289" class="indexterm"/>chapter we will cover the Java Client API for Server-sent Events, which is provided by Jersey. Jersey is an implementation of JAX-RS 2.0. In addition to the features of the JAX-RS 2.0 specification, Jersey has provided support for Server-sent Events.</p><p>
<code class="literal">EventSource</code> is the class for reading <code class="literal">InboundEvents</code>:</p><p>The following snippet shows how to use the <code class="literal">EventSource</code> API:</p><div class="informalexample"><pre class="programlisting">   WebTarget webTarget = client.target(new URI(TARGET_URI));
EventSource eventSource = new EventSource(webTarget) {
@Override
public void onEvent(InboundEvent inboundEvent) {
    System.out.println("Data " + inboundEvent.getData(String.class);
     
}</pre></div><p>The <code class="literal">EventSource</code> object is created with <code class="literal">WebTarget</code>. We covered <code class="literal">WebTarget</code> in <a class="link" href="ch01.html" title="Chapter 1. Building RESTful Web Services Using JAX-RS">Chapter 1</a>, <span class="emphasis"><em>Building RESTful Web Services using JAX-RS</em></span>.</p><p>When a Server-sent <a id="id290" class="indexterm"/>Event is received by the client <a id="id291" class="indexterm"/>the <code class="literal">onEvent()</code> method<a id="id292" class="indexterm"/> of the <code class="literal">EventSource</code> is invoked. The <code class="literal">InboundEvent</code> has the <code class="literal">getData()</code> method<a id="id293" class="indexterm"/> that takes the <code class="literal">String.class</code> that is the type of the message data. You can add any custom defined class here. The JAX-RS <code class="literal">MessagebodyReader</code> will be used to read the type of the message. Thus you can see the similarity in the code between using JavaScript API and the Jersey Client API. <a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>Restful Web Services by Example</em></span>, will show a complete example using the Server Sent Event Jersey Client API.</p></div></div>
<div class="section" title="Best practices for applications based on Server-sent Events"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Best practices for applications based on Server-sent Events</h1></div></div></div><p>The following chapter covers the best practices for applications based on Server-sent Events<a id="id294" class="indexterm"/>. The following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking if the event source's origin is as expected</li><li class="listitem" style="list-style-type: disc">Working with proxy servers and Server-sent Events</li><li class="listitem" style="list-style-type: disc">Handling fault tolerance for Server-sent Events</li></ul></div><div class="section" title="Checking if the event source's origin is as expected"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Checking if the event source's origin is as expected</h2></div></div></div><p>The following snippet shows <a id="id295" class="indexterm"/>how to check for the origin of the event source so that it matches the application's origin.</p><div class="informalexample"><pre class="programlisting">if (e.origin != 'http://foo.com') {
alert('Origin was not http://foo.com');
return;</pre></div><p>An event stream from an origin distinct from the origin of the content consuming the event stream can result in information leakage. When the events are obtained from the server, it is good practice to check for the events originator to see if it is as expected.</p></div><div class="section" title="Working with proxy servers and Server-sent Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Working with proxy servers and Server-sent Events</h2></div></div></div><p>Proxy servers <a id="id296" class="indexterm"/>can drop <a id="id297" class="indexterm"/>HTTP connections after a short timeout. To avoid such dropped connections it may be a good idea to send a comment periodically.</p><p>This is how a comment is<a id="id298" class="indexterm"/> sent using<a id="id299" class="indexterm"/> Server-sent Events.</p><div class="informalexample"><pre class="programlisting">: this is a comment

OutboundEvent event =  new OutboundEvent.Builder().comment("this is a comment").build();</pre></div><p>The <code class="literal">Outboundevent.Builder</code> API<a id="id300" class="indexterm"/> will send a comment to the client.</p><p>The comment will fire nothing yet will make sure that connections do not get dropped between client and server.</p></div><div class="section" title="Handling fault tolerance for Server-sent Events"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Handling fault tolerance for Server-sent Events</h2></div></div></div><p>
<a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>, covered <a id="id301" class="indexterm"/>how you <a id="id302" class="indexterm"/>can associate IDs with events. The server can send event ids with events by using the following snippet:</p><div class="informalexample"><pre class="programlisting">   id: 123\n
   data : This is an event stream \n\n</pre></div><p>The client keeps the connection <a id="id303" class="indexterm"/>alive and tries to reconnect if the connection is dropped. Setting an ID lets the browser keep track of the last event fired so when the connection between the client and server is dropped, on reconnect by the client to the server the <span class="strong"><strong>Last-Event-ID</strong></span>
<a id="id304" class="indexterm"/> will be sent back to the server. This ensures the client does not miss any messages. The server can then send events that occur after the Last-Event-ID.</p><p>The server may need a message queue to keep track of the different clients connected, check for reconnections, and send messages based on the Last-Event-ID.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter we looked at advanced topics for WebSockets and Server-sent Events. We demonstrated with code snippets how to use encoders and decoders and how to receive different kinds of data using WebSockets. We also demonstrated a sample that showed how WebSockets will work with SSL so that when working with proxy servers, the communication is encrypted.</p><p>We also discussed best practices for implementing Server-sent Events and WebSockets. We learned how to ensure messages are not lost in Server-sent Events by associating IDs with events. We covered the Jersey Client API for Server-sent Events.</p><p>In the next chapter, we will cover more advanced topics such as JSON API in Java EE and the aspects of asynchronous programming to improve scalability with respect to various Java EE specifications such as JAX-RS 2.0, EJB and Servlets.</p></div></body></html>