- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Comparing Hexagonal Architecture with Layered Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较六边形架构与分层架构
- en: Hexagonal architecture is just one of several software architecture approaches.
    Among these approaches, one that stands out is the so-called layered architecture,
    which has been widely used in enterprise software development for years. Its vast
    adoption is because it’s reasonably simple to apply the layered architecture principles
    and also because this is one of the patterns that may naturally emerge when there
    is no conscious decision made regarding which architectural approach to use for
    new projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构只是几种软件架构方法之一。在这些方法中，一个突出的是所谓的分层架构，它在企业软件开发中已经广泛使用多年。其广泛采用的原因在于分层架构原则相对简单易用，并且这是在未做出关于新项目应使用哪种架构方法的有意识决策时可能自然出现的模式之一。
- en: Understanding layered architecture and being aware of its differences when comparing
    it to hexagonal architecture is good to help us make more informed decisions regarding
    which software architecture approach to use when starting or refactoring a software
    project. That’s why in this chapter, we will begin by reviewing layered architecture
    ideas. Then, based on those ideas, we will implement a simple application to learn
    how to apply the layered architecture concepts. We will then proceed by refactoring
    that simple application using hexagonal architecture ideas so we can better grasp
    the contrasts between the two architectures. Finally, we will finish by assessing
    the advantages and disadvantages of hexagonal and layered architectures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解分层架构并意识到其在与六边形架构比较时的差异，这对我们做出更明智的决定很有帮助，即在选择开始或重构软件项目时使用哪种软件架构方法。这就是为什么在本章中，我们将首先回顾分层架构的概念。然后，基于这些概念，我们将实现一个简单的应用程序来学习如何应用分层架构的概念。接下来，我们将使用六边形架构的概念重构这个简单的应用程序，以便我们更好地掌握两种架构之间的对比。最后，我们将评估六边形和分层架构的优缺点。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reviewing the layered architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查分层架构
- en: Creating an application using the layered architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分层架构创建应用程序
- en: Rewriting a layered architecture application into a hexagonal one
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分层架构应用程序重写为六边形架构
- en: Assessing the benefits and disadvantages of hexagonal and layered architectures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估六边形和分层架构的利弊
- en: By the end of this chapter, you will understand the difference between layered
    and hexagonal architecture, enabling you to make better, informed decisions on
    your next software project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解分层架构和六边形架构之间的区别，这将使您在下一个软件项目中做出更好的、有信息量的决策。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, Mac, and Windows operating systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中提供的代码示例，您需要在您的计算机上安装最新的**Java SE 开发工具包**和**Maven 3.8**。它们适用于 Linux、Mac
    和 Windows 操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，网址为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15)。
- en: Reviewing the layered architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查分层架构
- en: Layered architecture, in my view, may emerge when a group of developers in charge
    of a project do not stop to think about which kind of architecture is more suitable
    for the software they want to develop. I have observed this scenario in projects
    where without conscious team planning, the code structure would evolve to some
    level of separation of concerns where the presentation/API code would be somewhat
    isolated from the business and infrastructure code. You would not see core business
    logic in the classes responsible for providing a REST endpoint, for example. You
    may notice, in such projects, packages named `model`, `repository`, `service`,
    and `controller` as hints to a system based on the layered architecture ideas.
    They are hints because each of those packages usually represents an intent to
    allocate a specific software responsibility. The code present in the `model` package
    is used to represent database entities. The `repository` package contains classes
    showing which kind of database operations the system can do based on the model
    entities. `service` is a package where some business logic is executed over the
    data retrieved from the database using classes from the `repository` package.
    Finally, the `controller` package contains classes exposing API endpoints to allow
    triggering one of the supported application behaviors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，当负责一个项目的开发者群体没有停下来思考哪种架构更适合他们想要开发的软件时，分层架构可能会出现。我观察到在项目中，如果没有有意识的团队规划，代码结构会发展到一定程度的关注点分离，其中表示层/API代码将与业务和基础设施代码相对隔离。例如，你不会在负责提供REST端点的类中看到核心业务逻辑。你可能会注意到，在这样的项目中，名为`model`、`repository`、`service`和`controller`的包作为基于分层架构思想的提示。它们是提示，因为每个包通常代表将特定软件责任分配的意图。`model`包中存在的代码用于表示数据库实体。`repository`包包含显示系统可以基于模型实体执行哪种数据库操作的类。`service`是一个包含一些业务逻辑的包，这些业务逻辑是在使用`repository`包中的类从数据库检索数据时执行的。最后，`controller`包包含暴露API端点的类，允许触发支持的应用程序行为之一。
- en: 'As a form of layered architecture, we can see the code structure based on the
    `model`, `repository`, `service`, and `controller` packages. Each package represents
    a layer with its responsibility that depends directly on the code from the package/layer
    that comes next or is below it. The controller depends on the service, which depends
    on the repository, which depends on the model. It’s not uncommon to see slight
    variations of this pattern where more layers are introduced, even though the general
    idea of downward dependency is always there. There may even be situations where
    a layer bypasses the next layer and relies on the classes from another layer.
    We can see how a backend application based on layered architecture is usually
    structured in the following figure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为分层架构的一种形式，我们可以看到基于`model`、`repository`、`service`和`controller`包的代码结构。每个包代表一个层，其责任直接依赖于来自下一个包/层或其下层的代码。控制器依赖于服务，服务依赖于仓库，仓库依赖于模型。看到这种模式略有变化并不罕见，即使引入了更多层，但向下依赖的一般思想始终存在。甚至可能存在某些情况下，一个层绕过下一层并依赖于另一层的类。以下图中我们可以看到基于分层架构的后端应用程序通常是如何结构的：
- en: '![Figure 15.1 – Layered architecture example](img/B19777_15_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – 分层架构示例](img/B19777_15_01.jpg)'
- en: Figure 15.1 – Layered architecture example
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 分层架构示例
- en: Instead of a presentation layer, which would make sense if we were developing
    a web application, we have the API layer containing classes with REST endpoint
    logic. These classes are responsible for receiving the client request and triggering
    some application behavior in the service layer. This layer usually contains business
    logic that depends on external data. To handle external data, we have the data
    layer containing classes responsible for getting, persisting, and mapping external
    data. I don’t use the term persistence here to avoid implying the data source
    will be a database. The data can come from anywhere, including a database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与开发网络应用时可能需要的表示层不同，我们拥有包含具有REST端点逻辑的类的API层。这些类负责接收客户端请求并在服务层触发一些应用行为。这一层通常包含依赖于外部数据的业务逻辑。为了处理外部数据，我们拥有包含负责获取、持久化和映射外部数据的类的数据层。在这里我不使用“持久化”这个词，以避免暗示数据源将是数据库。数据可以来自任何地方，包括数据库。
- en: I have seen this pattern being employed in a few software development projects
    in large enterprises and start-ups. Curiously, if you ask developers involved
    in the project which architecture they used, they would probably say no specific
    architecture was applied, even though their code suggests the software was developed
    based on the layered architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我在大型企业和初创企业的几个软件开发项目中看到了这种模式的运用。有趣的是，如果你问参与项目的开发者他们使用了哪种架构，他们可能会说没有应用特定的架构，尽管他们的代码表明软件是基于分层架构开发的。
- en: Because layered architecture has existed for many years, it has kind of become
    a standard architecture for enterprise software projects. The idea of segregating
    responsibilities based on high-level system components seems to accommodate a
    good deal of the necessities we see in enterprise software, usually because this
    kind of software follows, most of the time, the same pattern of receiving input,
    getting data from somewhere, performing data processing, and then persisting or
    sending that data to another system. Given that many enterprise applications are
    developed following this pattern, what significantly changes between those applications
    is the data-processing part containing the business rules specific to a given
    application. The other parts may also change but not so considerably because how
    APIs are exposed and how data is retrieved/persisted may be standardized across
    different applications of the same organization, especially when the same team
    maintains those applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分层架构已经存在多年，它已经逐渐成为企业级软件项目的标准架构。基于高级系统组件划分责任的想法似乎能够满足我们在企业软件中看到的大部分需求，通常是因为这类软件大多数时候遵循相同的模式：接收输入，从某处获取数据，执行数据处理，然后将数据持久化或发送到另一个系统。鉴于许多企业应用程序都是按照这种模式开发的，这些应用程序之间显著的不同在于包含特定应用业务规则的数据处理部分。其他部分也可能发生变化，但变化并不大，因为API的暴露方式和数据检索/持久化的方式可能在不同组织的同一应用程序中标准化，尤其是在同一个团队维护这些应用程序时。
- en: Although layered architecture helps to provide some level of decoupling, it
    does not entirely avoid situations where changes in one layer may also require
    changes in another. When you have the business/service layer depending on the
    persistence layer, changes on the latter can impact the former. Next, I will share
    an experience using the layered architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分层架构有助于提供一定程度的解耦，但它并不能完全避免在某一层的变化也可能需要另一层做出改变的情况。当你有业务/服务层依赖于持久化层时，后者的变化可能会影响到前者。接下来，我将分享一个使用分层架构的经验。
- en: I recall a situation where the team I was working with decided to change the
    database technology in the middle of the project. During the implementation, it
    turned out that an ORM feature available for the previous database technology
    was unavailable to the new database. The problem was that the system had some
    business rules that relied directly on that missing feature from the new database.
    Ultimately, we had to adjust our approach by significantly changing how those
    business rules would be processed. This application, in particular, evolved without
    a team discussion on what architectural principles should have been followed.
    Eventually, the project evolved into something with layered architecture characteristics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得有一次，我所在的团队在项目进行到中途时决定更改数据库技术。在实施过程中，我们发现新数据库技术中可用的ORM功能在新数据库中不可用。问题是系统中有一些业务规则直接依赖于新数据库中缺失的这个功能。最终，我们不得不通过显著改变这些业务规则的处理方式来调整我们的方法。这个应用程序，特别是，在没有团队讨论应该遵循哪些架构原则的情况下演变而来，最终演变成了具有分层架构特征的项目。
- en: To better understand the layered architecture, let’s develop an application
    based on this architecture idea.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解分层架构，让我们基于这个架构理念开发一个应用程序。
- en: Creating an application using the layered architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分层架构创建应用程序
- en: 'In the previous section, we saw how a backend application based on layered
    architecture can be structured. Our example has three layers: API, service, and
    data. Following this structure, we will develop a simple user application that
    allows user registration and login. We will implement the data layer, then proceed
    to the service layer, and then the API layer. The application will be based on
    Quarkus, so we can rely on the framework to provide REST endpoints and connect
    to a database.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了基于分层架构的后端应用程序是如何结构的。我们的示例有三个层：API、服务和数据。遵循这个结构，我们将开发一个简单的用户应用程序，允许用户注册和登录。我们将实现数据层，然后进行服务层，最后是API层。该应用程序将基于Quarkus，因此我们可以依赖框架提供REST端点和连接到数据库。
- en: Implementing the data layer
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现数据层
- en: 'The data layer is responsible for allowing getting, persisting, and mapping
    external data. We rely on a database for the user application to store user information:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层负责允许获取、持久化和映射外部数据。我们依赖数据库来存储用户应用程序的用户信息：
- en: 'So, let’s start by preparing Quarkus to enable us to use an H2 in-memory database:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们首先准备Quarkus，以便我们能够使用H2内存数据库：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `quarkus.datasource.db-kind` property tells Quarkus to use the H2 driver.
    `quarkus.datasource.jdbc.url` configures an in-memory database that will live
    while the application is running. Finally, we set `quarkus.hibernate-orm.database.generation`
    to allow the automatic creation of the database on the application startup.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus.datasource.db-kind`属性告诉Quarkus使用H2驱动程序。`quarkus.datasource.jdbc.url`配置了一个在应用程序运行期间存在的内存数据库。最后，我们将`quarkus.hibernate-orm.database.generation`设置为允许在应用程序启动时自动创建数据库。'
- en: 'In the `dev.davivieira.layered.data.entity` package, we create the `User` ORM
    entity class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev.davivieira.layered.data.entity`包中，我们创建`User` ORM实体类：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`User` is an ORM entity because the Jakarta `@Entity` annotation is placed
    on top of the class. The `id` attribute is annotated with `@GeneratedValue`, so
    the underlying database generates the `id` value. We finished the implementation
    with the `email` and `password` attributes required for new user registration
    and login.'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`User`是一个ORM实体，因为Jakarta的`@Entity`注解放置在类顶部。`id`属性被注解为`@GeneratedValue`，因此底层数据库生成`id`值。我们通过`email`和`password`属性完成了实现，这些属性对于新用户注册和登录是必需的。'
- en: 'In the `dev.davivieira.layered.data.repository` package, we create the `UserRepository`
    class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev.davivieira.layered.data.repository`包中，我们创建`UserRepository`类：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By implementing `PanacheRepository`, we get predefined standard database operations
    to allow fetching, saving, and deleting data. In addition to those predefined
    operations, we create `findByEmail` to search `User` entities using the email
    address. If no data is found, it returns an empty `Optional`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过实现`PanacheRepository`，我们获得预定义的标准数据库操作，以允许获取、保存和删除数据。除了这些预定义的操作之外，我们还创建了`findByEmail`来使用电子邮件地址搜索`User`实体。如果没有找到数据，它将返回一个空的`Optional`。
- en: The `User` entity and repository comprise the data layer, allowing us to persist
    and retrieve user data from a database. Let’s now implement the service layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体和仓库构成了数据层，使我们能够从数据库中持久化和检索用户数据。现在让我们实现服务层。'
- en: Implementing the service layer
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务层
- en: 'We need a place to put the logic to check whether the email address already
    exists when registering a new user or validating the user credentials during the
    login. The service layer is where we place that logic:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个地方来放置逻辑，以检查在注册新用户或登录过程中验证用户凭据时电子邮件地址是否已存在。服务层是我们放置该逻辑的地方：
- en: 'In the `dev.davivieira.layered.service` package, we start the implementation
    of the `UserService` class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev.davivieira.layered.service`包中，我们开始实现`UserService`类：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We inject `UserRepository` to enable the service class to handle external data
    through the data layer.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们注入`UserRepository`以使服务类能够通过数据层处理外部数据。
- en: 'We won’t map client requests directly to an ORM entity when receiving them.
    Instead, we map those requests to a `UserDto` class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到客户端请求时，我们不会直接将请求映射到ORM实体。相反，我们将这些请求映射到一个`UserDto`类：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `record` class will automatically generate the class constructor, getters,
    and setters for the email and password fields.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`record`类将自动生成电子邮件和密码字段的类构造函数、获取器和设置器。'
- en: 'Continuing with the `UserService` class, we implement the `createAccount` and
    `isEmailAlreadyUsed` methods:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现`UserService`类，我们实现了`createAccount`和`isEmailAlreadyUsed`方法：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `createAccount` method receives the `UserDto` parameter. We get the email
    from this parameter and pass it to the `isEmailAlreadyUsed` method, which uses
    `findByEmail` from `UserRepository` to check whether the email already exists.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`createAccount`方法接收`UserDto`参数。我们从该参数中获取电子邮件并将其传递给`isEmailAlreadyUsed`方法，该方法使用`UserRepository`的`findByEmail`来检查该电子邮件是否已存在。'
- en: 'To finish the `UserService` implementation, we create the `login` and `isThePasswordValid`
    methods:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成`UserService`的实现，我们创建了`login`和`isThePasswordValid`方法：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `login` method, we get the email from `UserDto` and use it to check whether
    the user account exists for that email. If not, we return the invalid credentials
    message. Otherwise, we check whether the password from `UserDto` matches the password
    from the `User` entity retrieved from the database using `UserRepository`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`login`方法中，我们从`UserDto`获取电子邮件并使用它来检查是否存在该电子邮件的用户账户。如果没有，我们返回无效凭证信息。否则，我们检查`UserDto`中的密码是否与从数据库中通过`UserRepository`检索到的`User`实体中的密码匹配。
- en: Creating a user account and validating the user credentials for login are the
    responsibilities of the service layer. It accomplishes that by relying on the
    data layer to get user data from the database. Now we need to expose an API to
    allow clients to send requests to our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户账户和验证登录凭证是服务层的责任。它通过依赖数据层从数据库获取用户数据来完成。现在我们需要公开一个API，以便客户端可以向我们的应用程序发送请求。
- en: Implementing the API layer
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API层
- en: 'The last layer, the API layer, is where we implement REST endpoints for user
    creation and user login requests:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个层，API层，是我们实现用户创建和用户登录请求的REST端点：
- en: 'In the `dev.davivieira.layered.api` package, we start the implementation of
    the `UserEndpoint` class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`dev.davivieira.layered.api`包中，我们开始实现`UserEndpoint`类：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We inject `UserService` to access the `createAccount` and `login` methods from
    the service layer.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们注入`UserService`以访问服务层的`createAccount`和`login`方法。
- en: 'We first define the register endpoint:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义注册端点：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is a straightforward REST endpoint implementation, receiving a JSON payload
    mapped to `UserDto` and returning plain text. `UserDto` is passed directly to
    the `createAccount` method from the `UserService` class on the service layer.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的REST端点实现，接收映射到`UserDto`的JSON有效负载并返回纯文本。`UserDto`直接从服务层的`UserService`类传递到`createAccount`方法。
- en: 'Finally, we define the login endpoint:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义登录端点：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we did in the previous register endpoint, here we are simply exposing the
    REST endpoint and passing the DTO directly to the service layer.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像我们在之前的注册端点中所做的那样，这里我们只是公开REST端点并将DTO直接传递到服务层。
- en: The API layer is responsible only for exposing the REST endpoints and nothing
    more. We avoid putting any business logic on this layer to ensure we separate
    the concerns among this and the other layers.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: API层只负责公开REST端点，不再做其他事情。我们避免在这个层上放置任何业务逻辑，以确保我们在这层和其他层之间分离关注点。
- en: Let’s see now how we can test this layered application.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们来看看如何测试这个分层应用。
- en: Testing the layered application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试分层应用
- en: 'We will test the service layer by focusing only on the logic that checks whether
    the email already exists and the credentials are valid. The following is what
    one of the tests would look like:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过仅关注检查电子邮件是否已存在和凭证是否有效的逻辑来测试服务层。以下是一个测试示例：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding test checks whether an exception is thrown when the email address
    already exists. Note that for this test to work, the service layer depends on
    the data layer, which requires a database to persist data. So, the core system
    logic, present in the service layer, depends directly on the data layer that is
    composed of the ORM entity and repository classes. How we handle external data
    dictates what we can do in the service layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试检查当电子邮件地址已存在时是否会抛出异常。请注意，为了使此测试正常工作，服务层依赖于数据层，这需要数据库来持久化数据。因此，存在于服务层中的核心系统逻辑直接依赖于由ORM实体和仓库类组成的数据层。我们如何处理外部数据决定了我们在服务层中能做什么。
- en: Suppose we want to avoid creating this dependency, where the core system’s logic
    depends on and sits so close to data-handling code. In that case, hexagonal architecture
    can help us with a different arrangement where the core system’s logic does not
    depend on anything and provides the flexibility to evolve that core logic without
    any concerns regarding how external data is handled. Let’s see how that can be
    done by refactoring our layered architecture application into a hexagonal one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要避免创建这种依赖，即核心系统逻辑依赖于并且紧邻数据处理代码。在这种情况下，六边形架构可以帮助我们以不同的安排来实现，其中核心系统逻辑不依赖于任何东西，并且提供了在无需担心外部数据处理方式的情况下演进核心逻辑的灵活性。让我们看看如何通过将我们的分层架构应用程序重构为六边形架构来实现这一点。
- en: Refactoring a layered architecture application into a hexagonal one
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将分层架构应用程序重构为六边形架构
- en: By now, we have an idea of how to implement a layered architecture application.
    Let’s refactor this application we have just developed into a hexagonal one. This
    exercise will highlight the significant differences between the two architectures.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对如何实现分层架构应用程序有了概念。让我们将我们刚刚开发的应用程序重构为六边形架构。这个练习将突出两种架构之间的显著差异。
- en: Implementing the Domain hexagon
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现领域六边形
- en: 'The Domain hexagon contains data and behaviors with core system logic. In the
    following steps, we’ll see how to refactor some data and behaviors from the layered
    application using the hexagonal approach:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 领域六边形包含具有核心系统逻辑的数据和行为。在以下步骤中，我们将看到如何使用六边形方法从分层应用程序中重构一些数据和行为的示例：
- en: 'While using the layered architecture, we started developing the system by implementing
    the data layer. We’ll refactor it into a Domain hexagon containing only a `User`
    domain entity class:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用分层架构时，我们通过实现数据层开始开发系统。我们将将其重构为一个仅包含`User`领域实体类的领域六边形：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The major difference is that this entity is not an ORM used to map database
    entities. This entity is a POJO that contains not only data but also behaviors.
    Let’s implement these behaviors.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要区别在于这个实体不是一个用于映射数据库实体的ORM。这个实体是一个POJO，它不仅包含数据，还包含行为。让我们实现这些行为。
- en: 'In the `User` entity class, we implement the `isEmailAlreadyUsed` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`User`实体类中，我们实现了`isEmailAlreadyUsed`方法：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`isEmailAlreadyUsed` receives an `Optional<User>` parameter. If the value is
    present, then we throw an exception.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`isEmailAlreadyUsed`方法接收一个`Optional<User>`参数。如果值存在，则抛出异常。'
- en: 'To finish the `User` entity class implementation, we create the `login` and
    `isPasswordValid` methods:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成`User`实体类的实现，我们创建了`login`和`isPasswordValid`方法：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The logic is similar to the methods we implemented in the layered application,
    but instead of using a `UserDto` class, we operate directly on the `User` domain
    entity class.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑与我们在分层应用程序中实现的方法类似，但不同的是，我们不是使用`UserDto`类，而是直接在`User`领域实体类上操作。
- en: Following a DDD approach, we pushed logic from the Service Layer into the Domain
    hexagon in the hexagonal application. Methods containing core system logic that
    used to be on the service layer are now part of the `User` domain entity class
    in the Domain hexagon.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在六边形应用程序中，我们遵循领域驱动设计（DDD）方法，将逻辑从服务层推入领域六边形。原来在服务层上的包含核心系统逻辑的方法现在成为了领域六边形中`User`领域实体类的一部分。
- en: The significant difference here is that the Domain hexagon does not depend on
    anything. In contrast, in the layered architecture approach, the Service layer
    containing the core system logic depends on the data layer.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的重要区别在于领域六边形不依赖于任何东西。相比之下，在分层架构方法中，包含核心系统逻辑的服务层依赖于数据层。
- en: Implementing the Application hexagon
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现应用程序六边形
- en: 'We implemented the `User` domain entity class on the Domain hexagon containing
    core logic to handle user registration and login. We need to define how, in an
    agnostic way, the behaviors will be triggered and how external data will be retrieved.
    By agnostic, I mean expressing the need for external data without going into the
    technology details to provide such data. We employ use cases and input and output
    ports in the Application hexagon:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在包含核心逻辑以处理用户注册和登录的领域六边形上实现了`User`领域实体类。我们需要定义以无差别的方式触发行为以及如何检索外部数据。这里的无差别是指表达对外部数据的需求，而不涉及提供此类数据的技术细节。我们在应用程序六边形中使用了用例和输入输出端口：
- en: 'Let’s start by defining the `UserAccessUserCase` interface:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义`UserAccessUserCase`接口：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating an account and being able to log in are the two use cases supported
    by our application.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建账户和能够登录是我们应用程序支持的两种用例。
- en: 'To allow handling external data, we define the `UserAccessOutputPort` interface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许处理外部数据，我们定义了`UserAccessOutputPort`接口：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This interface is just a POJO containing the `findByEmail` and `persist` method
    definitions. In the layered architecture approach, we had these methods as part
    of the repository class in the data layer. In the repository class, it was implied
    that the data would come from a database. In the hexagonal approach, we express,
    through the output port interface, that the data can come from anywhere.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此接口仅包含`findByEmail`和`persist`方法定义的POJO。在分层架构方法中，我们把这些方法作为数据层中仓库类的一部分。在仓库类中，数据来自数据库是隐含的。在六边形方法中，我们通过输出端口接口表达数据可以来自任何地方。
- en: 'We finish by implementing the `UserAccessInputPort` class:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以实现`UserAccessInputPort`类结束：
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`UserAccessInputPort` implements the `UserAccessUseCase` interface. Note we
    are injecting `UserAccessOutputPort`. It’s through this output port that the input
    port will handle external data. The `createAccount` method checks whether the
    email already exists by relying on the logic provided by the `isEmailAlreadyUsed`
    method from the `User` domain entity class. The `login` method also relies on
    the Domain hexagon by calling the `login` method present in the `User` domain
    entity class.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UserAccessInputPort`实现了`UserAccessUseCase`接口。注意我们正在注入`UserAccessOutputPort`。正是通过这个输出端口，输入端口将处理外部数据。`createAccount`方法通过依赖`User`领域实体类中提供的`isEmailAlreadyUsed`方法的逻辑来检查电子邮件是否已存在。`login`方法也依赖于领域六边形，通过调用存在于`User`领域实体类中的`login`方法。'
- en: The Application hexagon allowed us to express how the system should handle external
    data in conjunction with the core system’s logic from the Domain hexagon. Contrary
    to what we did in the layered architecture approach, the core system logic and
    external data handling have been defined without specifying whether the data is
    coming from a database or somewhere else.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应用六边形允许我们表达系统应该如何处理外部数据，同时结合领域六边形的核系统逻辑。与我们在分层架构方法中所做的方法相反，核心系统逻辑和外部数据处理已经被定义，而没有指定数据是来自数据库还是其他地方。
- en: This approach of expressing, through output ports, what data the system needs
    without exposing how the system will get that data is a significant difference
    between layered and hexagonal architecture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输出端口表达系统需要哪些数据，而不暴露系统将如何获取这些数据的方法，这是分层架构和六边形架构之间的重要区别。
- en: Implementing the Framework hexagon
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现框架六边形
- en: 'The Application hexagon orchestrates external data with core system logic from
    the Domain hexagon. Still, we need to provide a way to get that external data.
    In the layered architecture approach, the data layer allowed us to get data from
    a database, and the API layer exposed REST endpoints. In the Framework hexagon,
    we use input adapters to provide the REST endpoints and output adapters to get
    data from a database. Let’s implement it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用六边形协调来自领域六边形的核系统逻辑和外部数据。然而，我们需要提供一种获取这些外部数据的方法。在分层架构方法中，数据层允许我们从数据库获取数据，API层暴露了REST端点。在框架六边形中，我们使用输入适配器提供REST端点，使用输出适配器从数据库获取数据。让我们来实现它：
- en: 'We start with the `UserAccessInputAdapter` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`UserAccessInputAdapter`类开始：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We inject `UserAccessUseCase` to access the operations available in the Application
    hexagon.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们注入`UserAccessUseCase`以访问应用六边形中可用的操作。
- en: 'In the `UserAccessInputAdapter` class, we implement the `register` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserAccessInputAdapter`类中，我们实现`register`方法：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We map `UserDto` directly to the `User` domain entity class. Then, we pass it
    to the `createAccount` method from `UserAccessUseCase`.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们直接将`UserDto`映射到`User`领域实体类。然后，我们将它传递给`UserAccessUseCase`中的`createAccount`方法。
- en: 'To finish the `UserAccessInputAdapter` implementation, we create the `login`
    method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成`UserAccessInputAdapter`的实现，我们创建`login`方法：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we did in the register method, we map `UserDto` to the `User` domain entity
    class and then pass it to the `login` method.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们在`register`方法中所做的那样，我们将`UserDto`映射到`User`领域实体类，然后将其传递给`login`方法。
- en: We still need to implement the output adapter. Let’s do that.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们仍然需要实现输出适配器。让我们来做这件事。
- en: '`UserAccessOutputAdapter` implements `UserAccessOutputPort`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserAccessOutputAdapter`实现了`UserAccessOutputPort`：'
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By injecting `UserRepository`, we are effectively turning this output adapter
    into one that deals with databases.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过注入`UserRepository`，我们实际上将这个输出适配器转变为处理数据库的适配器。
- en: 'We need to implement the `findByEmail` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现`findByEmail`方法：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We use `UserRepository` when implementing `findByEmail` from the `UserAccessOutputPort`
    interface. `UserMapper` is a helper class to map the ORM entity class called `UserData`
    into the `User` domain entity class.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当从`UserAccessOutputPort`接口实现`findByEmail`时，我们使用`UserRepository`。`UserMapper`是一个辅助类，用于将ORM实体类`UserData`映射到`User`领域实体类。
- en: 'Finally, we implement the `persist` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现`persist`方法：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We again use the `UserMapper` helper class to map the `User` domain entity class
    into the `UserData` ORM entity class. That is required because we cannot persist
    the domain entity. So, we pass the `UserData` ORM entity class to the `persist`
    method from `UserRepository`.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次使用`UserMapper`辅助类将`User`领域实体类映射到`UserData`ORM实体类。这是必需的，因为我们不能持久化领域实体。因此，我们将`UserData`ORM实体类传递给`UserRepository`中的`persist`方法。
- en: Introducing the Framework hexagon allows clients to access the system’s API
    provided by input adapters and connect the hexagonal application to an external
    data source, a database in our case. The input adapter from the Framework hexagon
    does not differ much when compared to the REST endpoints provided by the API layer.
    Both approaches expose similar methods, rely on DTO classes to map client requests,
    and send them downstream to either the service layer or the Application hexagon.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引入框架六边形允许客户端访问由输入适配器提供的系统API，并将六边形应用程序连接到外部数据源，在我们的例子中是一个数据库。与API层提供的REST端点相比，框架六边形的输入适配器没有太大区别。两种方法都公开了类似的方法，依赖于DTO类来映射客户端请求，并将它们发送到服务层或应用程序六边形。
- en: What significantly changes is how external data is handled. In the hexagonal
    approach, the output adapter implements an output port, which provides flexibility
    with the output port abstraction. A new output adapter can be implemented without
    disrupting the core system’s logic. On the other hand, there is no such abstraction
    in the layered architecture approach. The service layer relies directly on the
    repository classes from the data layer.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显著变化的是外部数据是如何处理的。在六边形方法中，输出适配器实现了一个输出端口，提供了输出端口抽象的灵活性。可以不干扰核心系统逻辑实现一个新的输出适配器。另一方面，在分层架构方法中没有这样的抽象。服务层直接依赖于数据层的仓库类。
- en: Let’s see now how we can test the hexagonal application.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们来看看如何测试六边形应用程序。
- en: Testing the hexagonal application
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试六边形应用程序
- en: 'Because the core system’s logic is part of the Domain hexagon, we can create
    unit tests to validate the `User` domain entity behaviors. The following is what
    one of those unit tests would look like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为核心系统逻辑是领域六边形的一部分，我们可以创建单元测试来验证`User`领域实体行为。以下是一个这样的单元测试的例子：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the layered approach, we had to inject a service class and provide a database
    to test whether the email was already being used. In the hexagonal approach, we
    are testing the logic directly from the `User` domain entity class. Moving the
    core system logic from the service layer, in the layered architecture, to the
    Domain hexagon in the hexagonal architecture provided the flexibility to run more
    constrained tests without dependencies on external resources.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在分层方法中，我们必须注入一个服务类并提供一个数据库来测试电子邮件是否已经被使用。在六边形方法中，我们直接从`User`领域实体类测试逻辑。将核心系统逻辑从分层架构的服务层移动到六边形架构的领域六边形，提供了在不依赖外部资源的情况下运行更受限制的测试的灵活性。
- en: Based on our implementation of the same application using layered and hexagonal
    architecture, let’s assess the pros and cons of each architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们使用分层和六边形架构实现相同应用程序的实践，让我们评估每种架构的优缺点。
- en: Assessing the benefits and disadvantages of hexagonal and layered architectures
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估六边形和分层架构的优缺点
- en: The structure of a layered application is more straightforward than a hexagonal
    one. In the layered approach, we have the service layer depending directly on
    the data layer. This dependence implies that the core system logic relies on the
    ORM entity and repository classes from the data layer. Contrary to the hexagonal
    approach, there is no abstraction regarding external data access, and the core
    system logic is embedded with code that handles external data. Is this good or
    bad? As with most things in software development, it depends on your context.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 分层应用程序的结构比六边形应用程序更简单。在分层方法中，我们有服务层直接依赖于数据层。这种依赖意味着核心系统逻辑依赖于数据层的ORM实体和仓库类。与六边形方法相反，没有关于外部数据访问的抽象，核心系统逻辑与处理外部数据的代码嵌入在一起。这是好是坏？就像软件开发中的大多数事情一样，这取决于你的上下文。
- en: The experience I shared at the beginning of the chapter, where my team had to
    change the database technology in the middle of the project, is an example where
    employing the hexagonal approach would have been beneficial. If you expect considerable
    requirement changes in your project, then the hexagonal approach may be a good
    idea to make it easier for your application to accommodate those changes. Otherwise,
    the layered architecture is a good choice, given it’s fast to bootstrap a new
    application with such architecture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头分享的经验，即我的团队在项目中途不得不更改数据库技术，是一个例子，说明采用六边形方法将是有益的。如果你预计你的项目会有相当大的需求变化，那么六边形方法可能是一个好主意，以便使你的应用程序更容易适应这些变化。否则，分层架构是一个不错的选择，因为使用这种架构快速启动新应用程序是很快的。
- en: The layered architecture provides a simple and fast approach to developing new
    applications. Most backend developers are acquainted with having an API layer
    to expose endpoints, a service layer containing core system logic, and the data
    layer usually providing database access. So, it’s a small undertaking to onboard
    new team members to maintain applications based on this architecture. The trade-off
    is that this architecture offers less flexibility when infrastructure components
    need to change.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构提供了一种简单快捷的方法来开发新应用程序。大多数后端开发者都熟悉有一个API层来暴露端点，一个包含核心系统逻辑的服务层，以及通常提供数据库访问的数据层。因此，让新团队成员加入维护基于这种架构的应用程序是一项小任务。权衡的是，当需要更改基础设施组件时，这种架构提供的灵活性较少。
- en: On the other hand, the hexagonal architecture allows us to decouple the core
    system logic code from the infrastructure/external data-handling code. Still,
    this decoupling does not come for free. Hexagonal architecture slightly increases
    the code complexity due to additional components, such as the ports, use cases,
    and adapters we use to ensure the decoupling. The major benefit is a change-tolerant
    application shielded from the unpredictability of unexpected system requirements.
    Onboarding new team members may represent an additional effort because hexagonal
    architecture is less widely used than its layered counterpart. Hence, people need
    more time to grasp the hexagonal approach ideas to start contributing to the project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，六边形架构使我们能够将核心系统逻辑代码与基础设施/外部数据处理代码解耦。然而，这种解耦并非免费获得。由于增加了诸如端口、用例和适配器等额外组件，六边形架构略微增加了代码复杂性，这些组件我们使用以确保解耦。主要好处是具有变化容忍度的应用程序，可以免受意外系统需求不可预测性的影响。由于六边形架构不如其分层对应物广泛使用，因此吸纳新团队成员可能需要额外的努力。因此，人们需要更多的时间来掌握六边形方法的思想，以便开始为项目做出贡献。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored layered architecture and its differences from hexagonal
    architecture. We started by reviewing the purpose of layered architecture to provide
    some level of separation of concerns through logical layers containing code with
    specific responsibilities. After reviewing the idea of the layered approach, we
    dirtied our hands by implementing a simple user access application from scratch
    containing the API, service, and data layers. To highlight the differences between
    the layered and hexagonal architectures, we refactored the user access application
    to use the hexagonal approach. By doing so, we saw that the layered architecture
    does not entirely protect the application from major changes, such as those that
    touch on infrastructure components such as external data access handling. Finally,
    we assessed the advantages and disadvantages of the layered and hexagonal architectures,
    concluding that the layered one is a good choice when no significant project requirement
    changes are expected, and the hexagonal architecture is recommended when one needs
    a more change-tolerable application capable to accommodate considerable system
    changes, especially at the infrastructure level. In the next chapter, we will
    explore how SOLID principles can be used with hexagonal architecture.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了分层架构及其与六边形架构的不同之处。我们首先回顾了分层架构的目的，即通过包含具有特定职责的代码的逻辑层，提供一定程度的关注点分离。在回顾了分层方法的概念之后，我们亲自动手从头开始实现了一个简单的用户访问应用程序，其中包含API、服务和数据层。为了突出分层架构和六边形架构之间的差异，我们将用户访问应用程序重构为使用六边形方法。通过这样做，我们发现分层架构并不能完全保护应用程序免受重大变化的影响，例如那些触及基础设施组件，如外部数据访问处理的变化。最后，我们评估了分层架构和六边形架构的优缺点，得出结论：当预期项目需求没有重大变化时，分层架构是一个不错的选择；而当需要更易于适应变化的应用程序，能够容纳相当大的系统变化，尤其是在基础设施层面时，建议使用六边形架构。在下一章中，我们将探讨如何将SOLID原则与六边形架构结合使用。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why would you choose layered architecture over hexagonal architecture in a new
    project?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会选择在新的项目中使用分层架构而不是六边形架构？
- en: Although layered architecture provides some level of separation of concerns,
    it does not completely decouple core system logic from infrastructure code. Why?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然分层架构提供了一定程度的关注点分离，但它并没有完全解耦核心系统逻辑与基础设施代码。为什么？
- en: In which scenario does using hexagonal architecture instead of layered architecture
    make sense?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪种场景下使用六边形架构而不是分层架构是有意义的？
- en: Answers
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: It provides a simple and fast way to bootstrap new applications.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一种简单快捷的方式来启动新应用程序。
- en: Because the core system logic depends directly on the infrastructure code, usually
    when there is a service layer depending on a data layer.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于核心系统逻辑直接依赖于基础设施代码，通常当存在依赖于数据层的服务层时。
- en: When project requirements are expected to change, using hexagonal architecture
    allows the creation of change-tolerable applications capable of accommodating
    those requirements.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当预期项目需求会发生变化时，使用六边形架构可以创建能够适应那些需求的易于适应变化的应用程序。
