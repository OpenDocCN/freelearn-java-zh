- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing Hexagonal Architecture with Layered Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hexagonal architecture is just one of several software architecture approaches.
    Among these approaches, one that stands out is the so-called layered architecture,
    which has been widely used in enterprise software development for years. Its vast
    adoption is because it’s reasonably simple to apply the layered architecture principles
    and also because this is one of the patterns that may naturally emerge when there
    is no conscious decision made regarding which architectural approach to use for
    new projects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding layered architecture and being aware of its differences when comparing
    it to hexagonal architecture is good to help us make more informed decisions regarding
    which software architecture approach to use when starting or refactoring a software
    project. That’s why in this chapter, we will begin by reviewing layered architecture
    ideas. Then, based on those ideas, we will implement a simple application to learn
    how to apply the layered architecture concepts. We will then proceed by refactoring
    that simple application using hexagonal architecture ideas so we can better grasp
    the contrasts between the two architectures. Finally, we will finish by assessing
    the advantages and disadvantages of hexagonal and layered architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the layered architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application using the layered architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting a layered architecture application into a hexagonal one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessing the benefits and disadvantages of hexagonal and layered architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the difference between layered
    and hexagonal architecture, enabling you to make better, informed decisions on
    your next software project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layered architecture, in my view, may emerge when a group of developers in charge
    of a project do not stop to think about which kind of architecture is more suitable
    for the software they want to develop. I have observed this scenario in projects
    where without conscious team planning, the code structure would evolve to some
    level of separation of concerns where the presentation/API code would be somewhat
    isolated from the business and infrastructure code. You would not see core business
    logic in the classes responsible for providing a REST endpoint, for example. You
    may notice, in such projects, packages named `model`, `repository`, `service`,
    and `controller` as hints to a system based on the layered architecture ideas.
    They are hints because each of those packages usually represents an intent to
    allocate a specific software responsibility. The code present in the `model` package
    is used to represent database entities. The `repository` package contains classes
    showing which kind of database operations the system can do based on the model
    entities. `service` is a package where some business logic is executed over the
    data retrieved from the database using classes from the `repository` package.
    Finally, the `controller` package contains classes exposing API endpoints to allow
    triggering one of the supported application behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a form of layered architecture, we can see the code structure based on the
    `model`, `repository`, `service`, and `controller` packages. Each package represents
    a layer with its responsibility that depends directly on the code from the package/layer
    that comes next or is below it. The controller depends on the service, which depends
    on the repository, which depends on the model. It’s not uncommon to see slight
    variations of this pattern where more layers are introduced, even though the general
    idea of downward dependency is always there. There may even be situations where
    a layer bypasses the next layer and relies on the classes from another layer.
    We can see how a backend application based on layered architecture is usually
    structured in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Layered architecture example](img/B19777_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Layered architecture example
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a presentation layer, which would make sense if we were developing
    a web application, we have the API layer containing classes with REST endpoint
    logic. These classes are responsible for receiving the client request and triggering
    some application behavior in the service layer. This layer usually contains business
    logic that depends on external data. To handle external data, we have the data
    layer containing classes responsible for getting, persisting, and mapping external
    data. I don’t use the term persistence here to avoid implying the data source
    will be a database. The data can come from anywhere, including a database.
  prefs: []
  type: TYPE_NORMAL
- en: I have seen this pattern being employed in a few software development projects
    in large enterprises and start-ups. Curiously, if you ask developers involved
    in the project which architecture they used, they would probably say no specific
    architecture was applied, even though their code suggests the software was developed
    based on the layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Because layered architecture has existed for many years, it has kind of become
    a standard architecture for enterprise software projects. The idea of segregating
    responsibilities based on high-level system components seems to accommodate a
    good deal of the necessities we see in enterprise software, usually because this
    kind of software follows, most of the time, the same pattern of receiving input,
    getting data from somewhere, performing data processing, and then persisting or
    sending that data to another system. Given that many enterprise applications are
    developed following this pattern, what significantly changes between those applications
    is the data-processing part containing the business rules specific to a given
    application. The other parts may also change but not so considerably because how
    APIs are exposed and how data is retrieved/persisted may be standardized across
    different applications of the same organization, especially when the same team
    maintains those applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although layered architecture helps to provide some level of decoupling, it
    does not entirely avoid situations where changes in one layer may also require
    changes in another. When you have the business/service layer depending on the
    persistence layer, changes on the latter can impact the former. Next, I will share
    an experience using the layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: I recall a situation where the team I was working with decided to change the
    database technology in the middle of the project. During the implementation, it
    turned out that an ORM feature available for the previous database technology
    was unavailable to the new database. The problem was that the system had some
    business rules that relied directly on that missing feature from the new database.
    Ultimately, we had to adjust our approach by significantly changing how those
    business rules would be processed. This application, in particular, evolved without
    a team discussion on what architectural principles should have been followed.
    Eventually, the project evolved into something with layered architecture characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the layered architecture, let’s develop an application
    based on this architecture idea.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application using the layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how a backend application based on layered
    architecture can be structured. Our example has three layers: API, service, and
    data. Following this structure, we will develop a simple user application that
    allows user registration and login. We will implement the data layer, then proceed
    to the service layer, and then the API layer. The application will be based on
    Quarkus, so we can rely on the framework to provide REST endpoints and connect
    to a database.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data layer is responsible for allowing getting, persisting, and mapping
    external data. We rely on a database for the user application to store user information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start by preparing Quarkus to enable us to use an H2 in-memory database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quarkus.datasource.db-kind` property tells Quarkus to use the H2 driver.
    `quarkus.datasource.jdbc.url` configures an in-memory database that will live
    while the application is running. Finally, we set `quarkus.hibernate-orm.database.generation`
    to allow the automatic creation of the database on the application startup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `dev.davivieira.layered.data.entity` package, we create the `User` ORM
    entity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`User` is an ORM entity because the Jakarta `@Entity` annotation is placed
    on top of the class. The `id` attribute is annotated with `@GeneratedValue`, so
    the underlying database generates the `id` value. We finished the implementation
    with the `email` and `password` attributes required for new user registration
    and login.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `dev.davivieira.layered.data.repository` package, we create the `UserRepository`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By implementing `PanacheRepository`, we get predefined standard database operations
    to allow fetching, saving, and deleting data. In addition to those predefined
    operations, we create `findByEmail` to search `User` entities using the email
    address. If no data is found, it returns an empty `Optional`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `User` entity and repository comprise the data layer, allowing us to persist
    and retrieve user data from a database. Let’s now implement the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a place to put the logic to check whether the email address already
    exists when registering a new user or validating the user credentials during the
    login. The service layer is where we place that logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dev.davivieira.layered.service` package, we start the implementation
    of the `UserService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject `UserRepository` to enable the service class to handle external data
    through the data layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We won’t map client requests directly to an ORM entity when receiving them.
    Instead, we map those requests to a `UserDto` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `record` class will automatically generate the class constructor, getters,
    and setters for the email and password fields.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continuing with the `UserService` class, we implement the `createAccount` and
    `isEmailAlreadyUsed` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `createAccount` method receives the `UserDto` parameter. We get the email
    from this parameter and pass it to the `isEmailAlreadyUsed` method, which uses
    `findByEmail` from `UserRepository` to check whether the email already exists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish the `UserService` implementation, we create the `login` and `isThePasswordValid`
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `login` method, we get the email from `UserDto` and use it to check whether
    the user account exists for that email. If not, we return the invalid credentials
    message. Otherwise, we check whether the password from `UserDto` matches the password
    from the `User` entity retrieved from the database using `UserRepository`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a user account and validating the user credentials for login are the
    responsibilities of the service layer. It accomplishes that by relying on the
    data layer to get user data from the database. Now we need to expose an API to
    allow clients to send requests to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last layer, the API layer, is where we implement REST endpoints for user
    creation and user login requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `dev.davivieira.layered.api` package, we start the implementation of
    the `UserEndpoint` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject `UserService` to access the `createAccount` and `login` methods from
    the service layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We first define the register endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is a straightforward REST endpoint implementation, receiving a JSON payload
    mapped to `UserDto` and returning plain text. `UserDto` is passed directly to
    the `createAccount` method from the `UserService` class on the service layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we define the login endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we did in the previous register endpoint, here we are simply exposing the
    REST endpoint and passing the DTO directly to the service layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The API layer is responsible only for exposing the REST endpoints and nothing
    more. We avoid putting any business logic on this layer to ensure we separate
    the concerns among this and the other layers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see now how we can test this layered application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing the layered application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will test the service layer by focusing only on the logic that checks whether
    the email already exists and the credentials are valid. The following is what
    one of the tests would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test checks whether an exception is thrown when the email address
    already exists. Note that for this test to work, the service layer depends on
    the data layer, which requires a database to persist data. So, the core system
    logic, present in the service layer, depends directly on the data layer that is
    composed of the ORM entity and repository classes. How we handle external data
    dictates what we can do in the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to avoid creating this dependency, where the core system’s logic
    depends on and sits so close to data-handling code. In that case, hexagonal architecture
    can help us with a different arrangement where the core system’s logic does not
    depend on anything and provides the flexibility to evolve that core logic without
    any concerns regarding how external data is handled. Let’s see how that can be
    done by refactoring our layered architecture application into a hexagonal one.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a layered architecture application into a hexagonal one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have an idea of how to implement a layered architecture application.
    Let’s refactor this application we have just developed into a hexagonal one. This
    exercise will highlight the significant differences between the two architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Domain hexagon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Domain hexagon contains data and behaviors with core system logic. In the
    following steps, we’ll see how to refactor some data and behaviors from the layered
    application using the hexagonal approach:'
  prefs: []
  type: TYPE_NORMAL
- en: 'While using the layered architecture, we started developing the system by implementing
    the data layer. We’ll refactor it into a Domain hexagon containing only a `User`
    domain entity class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The major difference is that this entity is not an ORM used to map database
    entities. This entity is a POJO that contains not only data but also behaviors.
    Let’s implement these behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `User` entity class, we implement the `isEmailAlreadyUsed` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isEmailAlreadyUsed` receives an `Optional<User>` parameter. If the value is
    present, then we throw an exception.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish the `User` entity class implementation, we create the `login` and
    `isPasswordValid` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The logic is similar to the methods we implemented in the layered application,
    but instead of using a `UserDto` class, we operate directly on the `User` domain
    entity class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following a DDD approach, we pushed logic from the Service Layer into the Domain
    hexagon in the hexagonal application. Methods containing core system logic that
    used to be on the service layer are now part of the `User` domain entity class
    in the Domain hexagon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The significant difference here is that the Domain hexagon does not depend on
    anything. In contrast, in the layered architecture approach, the Service layer
    containing the core system logic depends on the data layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the Application hexagon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We implemented the `User` domain entity class on the Domain hexagon containing
    core logic to handle user registration and login. We need to define how, in an
    agnostic way, the behaviors will be triggered and how external data will be retrieved.
    By agnostic, I mean expressing the need for external data without going into the
    technology details to provide such data. We employ use cases and input and output
    ports in the Application hexagon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the `UserAccessUserCase` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating an account and being able to log in are the two use cases supported
    by our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To allow handling external data, we define the `UserAccessOutputPort` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This interface is just a POJO containing the `findByEmail` and `persist` method
    definitions. In the layered architecture approach, we had these methods as part
    of the repository class in the data layer. In the repository class, it was implied
    that the data would come from a database. In the hexagonal approach, we express,
    through the output port interface, that the data can come from anywhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We finish by implementing the `UserAccessInputPort` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`UserAccessInputPort` implements the `UserAccessUseCase` interface. Note we
    are injecting `UserAccessOutputPort`. It’s through this output port that the input
    port will handle external data. The `createAccount` method checks whether the
    email already exists by relying on the logic provided by the `isEmailAlreadyUsed`
    method from the `User` domain entity class. The `login` method also relies on
    the Domain hexagon by calling the `login` method present in the `User` domain
    entity class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Application hexagon allowed us to express how the system should handle external
    data in conjunction with the core system’s logic from the Domain hexagon. Contrary
    to what we did in the layered architecture approach, the core system logic and
    external data handling have been defined without specifying whether the data is
    coming from a database or somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of expressing, through output ports, what data the system needs
    without exposing how the system will get that data is a significant difference
    between layered and hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Framework hexagon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Application hexagon orchestrates external data with core system logic from
    the Domain hexagon. Still, we need to provide a way to get that external data.
    In the layered architecture approach, the data layer allowed us to get data from
    a database, and the API layer exposed REST endpoints. In the Framework hexagon,
    we use input adapters to provide the REST endpoints and output adapters to get
    data from a database. Let’s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `UserAccessInputAdapter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We inject `UserAccessUseCase` to access the operations available in the Application
    hexagon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `UserAccessInputAdapter` class, we implement the `register` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We map `UserDto` directly to the `User` domain entity class. Then, we pass it
    to the `createAccount` method from `UserAccessUseCase`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish the `UserAccessInputAdapter` implementation, we create the `login`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we did in the register method, we map `UserDto` to the `User` domain entity
    class and then pass it to the `login` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We still need to implement the output adapter. Let’s do that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UserAccessOutputAdapter` implements `UserAccessOutputPort`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By injecting `UserRepository`, we are effectively turning this output adapter
    into one that deals with databases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to implement the `findByEmail` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `UserRepository` when implementing `findByEmail` from the `UserAccessOutputPort`
    interface. `UserMapper` is a helper class to map the ORM entity class called `UserData`
    into the `User` domain entity class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we implement the `persist` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We again use the `UserMapper` helper class to map the `User` domain entity class
    into the `UserData` ORM entity class. That is required because we cannot persist
    the domain entity. So, we pass the `UserData` ORM entity class to the `persist`
    method from `UserRepository`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Introducing the Framework hexagon allows clients to access the system’s API
    provided by input adapters and connect the hexagonal application to an external
    data source, a database in our case. The input adapter from the Framework hexagon
    does not differ much when compared to the REST endpoints provided by the API layer.
    Both approaches expose similar methods, rely on DTO classes to map client requests,
    and send them downstream to either the service layer or the Application hexagon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What significantly changes is how external data is handled. In the hexagonal
    approach, the output adapter implements an output port, which provides flexibility
    with the output port abstraction. A new output adapter can be implemented without
    disrupting the core system’s logic. On the other hand, there is no such abstraction
    in the layered architecture approach. The service layer relies directly on the
    repository classes from the data layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s see now how we can test the hexagonal application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing the hexagonal application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the core system’s logic is part of the Domain hexagon, we can create
    unit tests to validate the `User` domain entity behaviors. The following is what
    one of those unit tests would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the layered approach, we had to inject a service class and provide a database
    to test whether the email was already being used. In the hexagonal approach, we
    are testing the logic directly from the `User` domain entity class. Moving the
    core system logic from the service layer, in the layered architecture, to the
    Domain hexagon in the hexagonal architecture provided the flexibility to run more
    constrained tests without dependencies on external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Based on our implementation of the same application using layered and hexagonal
    architecture, let’s assess the pros and cons of each architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the benefits and disadvantages of hexagonal and layered architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of a layered application is more straightforward than a hexagonal
    one. In the layered approach, we have the service layer depending directly on
    the data layer. This dependence implies that the core system logic relies on the
    ORM entity and repository classes from the data layer. Contrary to the hexagonal
    approach, there is no abstraction regarding external data access, and the core
    system logic is embedded with code that handles external data. Is this good or
    bad? As with most things in software development, it depends on your context.
  prefs: []
  type: TYPE_NORMAL
- en: The experience I shared at the beginning of the chapter, where my team had to
    change the database technology in the middle of the project, is an example where
    employing the hexagonal approach would have been beneficial. If you expect considerable
    requirement changes in your project, then the hexagonal approach may be a good
    idea to make it easier for your application to accommodate those changes. Otherwise,
    the layered architecture is a good choice, given it’s fast to bootstrap a new
    application with such architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The layered architecture provides a simple and fast approach to developing new
    applications. Most backend developers are acquainted with having an API layer
    to expose endpoints, a service layer containing core system logic, and the data
    layer usually providing database access. So, it’s a small undertaking to onboard
    new team members to maintain applications based on this architecture. The trade-off
    is that this architecture offers less flexibility when infrastructure components
    need to change.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the hexagonal architecture allows us to decouple the core
    system logic code from the infrastructure/external data-handling code. Still,
    this decoupling does not come for free. Hexagonal architecture slightly increases
    the code complexity due to additional components, such as the ports, use cases,
    and adapters we use to ensure the decoupling. The major benefit is a change-tolerant
    application shielded from the unpredictability of unexpected system requirements.
    Onboarding new team members may represent an additional effort because hexagonal
    architecture is less widely used than its layered counterpart. Hence, people need
    more time to grasp the hexagonal approach ideas to start contributing to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored layered architecture and its differences from hexagonal
    architecture. We started by reviewing the purpose of layered architecture to provide
    some level of separation of concerns through logical layers containing code with
    specific responsibilities. After reviewing the idea of the layered approach, we
    dirtied our hands by implementing a simple user access application from scratch
    containing the API, service, and data layers. To highlight the differences between
    the layered and hexagonal architectures, we refactored the user access application
    to use the hexagonal approach. By doing so, we saw that the layered architecture
    does not entirely protect the application from major changes, such as those that
    touch on infrastructure components such as external data access handling. Finally,
    we assessed the advantages and disadvantages of the layered and hexagonal architectures,
    concluding that the layered one is a good choice when no significant project requirement
    changes are expected, and the hexagonal architecture is recommended when one needs
    a more change-tolerable application capable to accommodate considerable system
    changes, especially at the infrastructure level. In the next chapter, we will
    explore how SOLID principles can be used with hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why would you choose layered architecture over hexagonal architecture in a new
    project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although layered architecture provides some level of separation of concerns,
    it does not completely decouple core system logic from infrastructure code. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which scenario does using hexagonal architecture instead of layered architecture
    make sense?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It provides a simple and fast way to bootstrap new applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the core system logic depends directly on the infrastructure code, usually
    when there is a service layer depending on a data layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When project requirements are expected to change, using hexagonal architecture
    allows the creation of change-tolerable applications capable of accommodating
    those requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
