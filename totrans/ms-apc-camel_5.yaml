- en: Chapter 5. Enterprise Integration Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how a processor or a bean can be used to
    implement behavioral changes on the messages.
  prefs: []
  type: TYPE_NORMAL
- en: However, some of those functions provide ways to implement solutions to common
    problems and, instead of reimplementing the same function in different routes,
    we can reuse an existing one. Some of these generic message operations are described
    in the Enterprise Integration Patterns (EIPs) from Gregor Hohpe and Bobby Woolf
    ([http://www.enterpriseintegrationpatterns.com/](http://www.enterpriseintegrationpatterns.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce the most used EIPs provided by Camel:'
  prefs: []
  type: TYPE_NORMAL
- en: The messaging systems EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messaging channels EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message construction EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message routing EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message transformation EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The messaging endpoints EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system management EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these generic message operations are described in the Enterprise Integration
    Patterns (EIPs) from Gregor Hohpe and Bobby Woolf. It describes the patterns,
    Camel provides the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: EIP processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of an EIP pattern is to apply a change on the message or create
    a new message:'
  prefs: []
  type: TYPE_NORMAL
- en: A change on the content of the message itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change on the destination endpoint of the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change on the routing depending on the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new message or exchange
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen how Camel processors and beans can be
    used to implement such changes.
  prefs: []
  type: TYPE_NORMAL
- en: To provide support of EIPs, Camel actually provides ready-to-use processors,
    with the DSL language to directly use those processors.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of reimplementing your own same processor in multiple routes, you
    can directly use an EIP processor provided by Camel.
  prefs: []
  type: TYPE_NORMAL
- en: The EIPs are classified in different categories, depending on the change performed
    on the message and the routing function implemented. We will be covering each
    category in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging systems EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging systems EIPs gather all patterns related to the delivery of messages,
    which are moving along in the routing logic.
  prefs: []
  type: TYPE_NORMAL
- en: Message Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Channel EIP is the generic name for the communication between endpoints
    in a Camel route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples of the previous chapters, we used endpoints with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, we can have a route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This route uses two endpoints (`timer` and `log`). Camel implicitly creates
    a Message Channel between the two endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose is to decouple the endpoint producing the message from the application
    consuming the message.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is actually used in basically all routes in an implicit way (you don't
    have to use a special notation to use Message Channel, it's in Camel).
  prefs: []
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another implicit EIP in Camel is the Message EIP.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is basically implemented by the Camel message interface and wrapped
    in an exchange.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is used in combination with the Message Channel one—the message channel
    transports messages.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the Exchange message wrapper, Camel implements the whole Message EIP,
    including support of the message exchange patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Camel Exchange, we have the following pattern property:'
  prefs: []
  type: TYPE_NORMAL
- en: If the pattern is set to `InOnly`, Camel implements an event message (a single
    inbound message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the pattern is set to `InOut`, Camel implements a `request-reply` with an
    inbound and outbound message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first endpoint of a Camel route (the `from`) is responsible for the creation
    of the exchange and hence, the message with the corresponding pattern. Each endpoint
    defines the expected pattern (and so if one is waiting for an outbound message
    to return to the client or not).
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the Pipeline EIP is to apply a series of actions using the message.
    For that, we move the message through different steps, like in a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a pipeline in two ways with Camel:'
  prefs: []
  type: TYPE_NORMAL
- en: The implicit pipeline is what we used in previous chapters. We simply define
    the steps in the route definition itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The explicit pipeline uses the pipeline DSL syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implicit pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implicit pipeline is the default Camel behavior—the route definition containing
    the chain of different processors and endpoints is actually a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, we create an example containing a Camel route written with
    the Blueprint DSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `pom.xml` file is very simple—it just packages our route as an OSGi bundle
    that we will deploy into the Apache Karaf container. In the project, we create
    two very simple beans that just display a message when they receive the `in` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first bean is named `Step1Bean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second bean is named `Step2Bean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create the Blueprint XML describing the route (in `src/main/resources/OSGI-INF/blueprint/route.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see the pipeline here; Camel will route the exchange from the timer's
    endpoint to the `step1` bean, next to the `step2` bean, and finally to the `log`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: It's an implicit pipeline. We can see the route in action by building and deploying
    the bundle into Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the bundle packaging both the route and the beans, we simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start a Karaf container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We install the `camel-blueprint` support in Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Very quickly, we can see the route execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can note the pipeline behavior where the message flows from the timer endpoint
    to the different steps of the route execution.
  prefs: []
  type: TYPE_NORMAL
- en: The explicit pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to use the pipeline EIP is by explicitly defining it with the corresponding
    DSL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The different steps are defined with the `pipeline` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, we will create a route exactly like the previous one (a
    message created by a timer is sent to two beans and a log endpoint) but this time
    using the `<pipeline/>` element in the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven `pom.xml` file is similar to the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have our two beans that display the `in` message. The first bean is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The second bean that displays the `in` message is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the Blueprint XML describing the route is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in the previous example, we build the OSGi bundle using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We deploy our bundle in Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the route execution is exactly the same as it is in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the routes are exactly the same internally in Camel, only the notation
    is different.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, we use the implicit pipeline (default behavior) which allows
    you to simplify the route definition.
  prefs: []
  type: TYPE_NORMAL
- en: Message router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Message Router EIP moves a message to different destinations depending on
    a condition.
  prefs: []
  type: TYPE_NORMAL
- en: The condition is actually a predicate defined using one of the languages supported
    by Camel (simple, header, xpath, xquery, mvel, ognl, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The predicate can use any data to implement the condition. If it uses the content
    of the message itself, we talk about Content Based Router (which we will see later
    in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the Message Router EIP, we create a route that will consume files
    and copy the files to different output folders depending on the file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We directly write this route using the Blueprint DSL to a `route.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see the usage of the `<choice/>` element, which is the notation of the
    Message Router EIP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this choice, we define two conditional routings:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `simple` language, we define the first predicate checking whether
    the file extension is `.xml`. If so, the message is routed to a file endpoint
    creating an output file in the `/tmp/out/xml` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second condition also uses the simple language. This predicate checks whether
    the file extension is `.txt`. If so, the message is routed to a file endpoint
    creating an output file in the `/tmp/out/txt` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the two first conditions are not matched, the message is routed to a file
    endpoint creating an output file in the `/tmp/out/binaries` folder. We start Karaf
    and install the `camel-blueprint` support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now simply drop the `route.xml` file in the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the `/tmp/in` folder, we create three files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file is `file.xml`, which contains :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file is `file.txt`, which contains :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The third file is `file.csv`, which contains :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the `/tmp/out` directory that the three folders have been created
    and they contain the expected files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Message Translator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Translator EIP is basically the transformation of the message content.
  prefs: []
  type: TYPE_NORMAL
- en: Some steps of the route change the content of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Camel, you have three ways to implement a message translator:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the transform DSL notation to call any language supported by Camel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the purpose of the translator is to convert from one data format to another,
    you can use the marshalling/unmarshalling functions provided by Camel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want complete control and implement complex transformation, you can use
    your own processor or bean to implement the transformation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transform notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to use any language supported by Camel (`simple`, `ruby`, `groovy`,
    and so on) in the `transform` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The external language is used to apply a transformation on the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the usage of the transform notation, we can create a Camel route
    using the following Blueprint descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This Camel route uses a Message Translator EIP to prepend `Hello` to the body
    of the `in` message.
  prefs: []
  type: TYPE_NORMAL
- en: The route consumes files from the `/tmp/in` folder (thanks to the `from` file
    endpoint), uses the transform notation with the simple language, and writes the
    message to a file in the `/tmp/out` folder (thanks to the `to` file endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We just drop the Blueprint XML file in the Karaf `deploy` folder. We create
    the `test.txt` file in the `/tmp/in` folder, only containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Camel route creates a `test.txt` file in the `/tmp/out` folder, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can note that the Message Translator EIP changed the body of the `in` message
    (from `World` to `Hello World`).
  prefs: []
  type: TYPE_NORMAL
- en: Using processor or bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous chapters, we have already used a Camel processor or a bean to change
    the body of the `in` message.
  prefs: []
  type: TYPE_NORMAL
- en: We perform the same task as we did in the previous example using a processor.
  prefs: []
  type: TYPE_NORMAL
- en: This time, a simple Blueprint XML file is not enough, we have to package the
    Blueprint XML and the processor in an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This Maven `pom.xml` file is very simple, it just defined the `camel-core` dependency
    (required by our Camel processor) and the OSGi bundle packaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `PrependProcessor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This processor is actually the implementation of the Message Translator EIP—it
    prepends `Hello` to the inbound message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use this processor in a Camel route written using the Blueprint
    DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We use Maven to build and package our OSGi bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We install our bundle in Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous example, we will put a `test.txt` file in the `/tmp/in`
    folder, which contains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can see `/tmp/in/test.txt` containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, we implemented the same Message Translator EIP but this time using a processor.
  prefs: []
  type: TYPE_NORMAL
- en: A processor or a bean gives you complete control of the Camel Exchange, and
    allows you to implement very complex message transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling/umarshalling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of changing the content of the message itself, the Message Translator
    EIP can be used to convert the message from one data format to another.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports different data formats and provides functions to directly convert
    from one data format to another.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate marshalling and unmarshalling, we create a route that consumes
    XML files and unmarshal/marshal the XML messages as JSON messages, which are sent
    to another file endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the Camel Blueprint DSL to define the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This route uses the `xmljson` Camel data format. The marshal element is the
    implementation of the Message Translator EIP, which converts the message from
    XML to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` and `camel-xmljson` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We directly drop our `route.xml` in the `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/tmp/in` folder, we create the following `person.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `/tmp/out` folder, we can see a `person.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Our Message Translator EIP has been executed, using marshalling/unmarshalling
    to different data formats.
  prefs: []
  type: TYPE_NORMAL
- en: Message Endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Endpoint EIP just defines the way an application can produce or
    consume messages in the routing system. Basically, in Camel, it's directly implemented
    and described by the `endpoint` interface. An endpoint is created by a component
    and described by an URI.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging channels EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging Channel EIPs gather all the patterns moving data from one point to
    another, using a communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: Point To Point Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Point To Point Channel EIP ensures that only one receiver consumes a message.
  prefs: []
  type: TYPE_NORMAL
- en: In Camel, the support of this EIP is dedicated to the components.
  prefs: []
  type: TYPE_NORMAL
- en: Some components are designed to implement and support this EIP.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, this is the case for:'
  prefs: []
  type: TYPE_NORMAL
- en: The SEDA and VM components, for communication between routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JMS component, when working with JMS queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the Point To Point Channel EIP, we create three routes using
    the Camel Blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: The first route starts with a timer and produces a message in a JMS queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third routes consume messages from the JMS queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see that one message will only be consumed by one consumer route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following `route.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We define a JMS connection factory that embeds an Apache ActiveMQ JMS broker.
    This connection factory is used in different Camel JMS endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start a Karaf instance and we install the `camel-blueprint` and `activemq-camel`
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now directly drop the `route.xml` file into the Karaf `deploy` folder.
    In the log (`$KARAF_HOME/data/log`), we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can see that each message is consumed by one route, illustrating the Point
    To Point Channel EIP.
  prefs: []
  type: TYPE_NORMAL
- en: Publish Subscribe Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Publish Subscribe Channel EIP is similar to the Point To Point Channel EIP,
    but instead of being consumed by only one consumer, each message is consumed by
    multiple consumers.
  prefs: []
  type: TYPE_NORMAL
- en: The message is duplicated to all consumers.
  prefs: []
  type: TYPE_NORMAL
- en: As in the Point To Point Channel EIP, Camel supports the Publish Subscribe Channel
    at a component level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some components are designed to implement and support this EIP, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The JMS component when working with JMS topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SEDA/VM components when working with `multipleConsumers=true` on the endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate this EIP, we update the previous example to use a topic instead
    of a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did in the previous example, we start Karaf and install the `camel-blueprint`
    and `activemq-camel` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route.xml` directly into the `deploy` folder. Now, we can see
    the following in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can note that each message has been consumed by the two routes (see the timestamps).
  prefs: []
  type: TYPE_NORMAL
- en: Dead Letter Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dead Letter Channel EIP allows you to reroute a message to another destination
    when the actual destination delivery fails.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is related to the management of errors in Camel routes.
  prefs: []
  type: TYPE_NORMAL
- en: Camel uses extensive support for error management, thanks to different error
    handlers and policies. We will see error handlers and hence, the Dead Letter Channel
    EIP, in [Chapter 7](ch07.html "Chapter 7. Error Handling"), *Error Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: Guaranteed Delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guaranteed Delivery ensures that we don't lose any message. It means basically
    that the messages are persistent and stored in a persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to create some checkpoints in your route—if a route stops, the
    messages are stored. As soon as the route restarts, the *pending* messages are
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel, by itself, doesn''t provide storage for messages, but you can use endpoints
    allowing the storage of the messages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: File endpoints, where the messages are produced as files on the filesystem by
    a route, and consumed by routes. The store is actually the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMS endpoints, where the messages (flagged as durable messages) are added into
    a JMS queue by a route, and consumed by other routes. The message store is actually
    the broker persistent messages store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA endpoints, where the messages are produced and stored in a database, and
    other routes poll the database. The message store is actually the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can illustrate this EIP using two routes sharing a directory on the filesystem
    to store the messages.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose is to see that, even if the second route is stopped, the messages
    are persistent and taken by the route as soon as it's started again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a first `route1.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route1.xml` into the `deploy` folder. We can see the first files
    coming into the `/tmp/exchange` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a `route2.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We drop this `route2.xml` file into the `deploy` folder of Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can see the following in the Karaf log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So even if the second route is not deployed, the messages are not lost and stored
    on the filesystem. It's an implementation of the Guaranteed Delivery EIP.
  prefs: []
  type: TYPE_NORMAL
- en: Message Bus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Bus EIP describes the architecture to plug and play applications
    that have to interact. This EIP gathers the messaging infrastructure, and the
    other layers required to implement routing.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, Camel itself is an implementation of the Message Bus EIP.
  prefs: []
  type: TYPE_NORMAL
- en: Message Construction EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These EIPs are responsible for creating messages in response to other messages.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Message EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Event Message EIP describes how to use messaging to transmit events from
    one application to another.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by the use of the Message Exchange Pattern in the exchange.
    When defined as `InOnly`, it means that we deal with a one way event message.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, the Event Message EIP means one directional messages.
  prefs: []
  type: TYPE_NORMAL
- en: The first endpoint of the route defines the expected Exchange pattern, but,
    at any point in the route, you can force the Exchange pattern to `InOnly` to make
    it act as an Event Message EIP.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you have to use the `inOnly` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `setExchangePattern` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to define the pattern as an attribute of the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The Request Reply EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Request Reply EIP is like the Event Message EIP, but this time, a response
    is expected from the target application.
  prefs: []
  type: TYPE_NORMAL
- en: As it does with Event Message, Camel supports this EIP using the Message Exchange
    pattern defined as `InOut`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the `from` endpoint defines the pattern that it expects. For instance,
    a CXF endpoint will define the pattern as `InOut` as it has to return something
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: As in the `InOnly` pattern, you can *force* the pattern to `InOut`, using the
    same notations.
  prefs: []
  type: TYPE_NORMAL
- en: The Correlation Identifier EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Correlation Identifier EIP is useful when used with the Request Reply pattern.
    With this pattern, an identifier can be added to a message, which can be used
    to correlate the response message with the request message.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by defining a dedicated header in the message or a property
    on the exchange. This header (or a property) is actually the Correlation Identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Some other EIPs (that we will see later) leverage this header to correlate multiple
    messages all together. For instance, the Splitter EIP defines the Correlation
    Identifier as a property of the exchanges resulting from the split (for instance,
    to be able to aggregate the messages).
  prefs: []
  type: TYPE_NORMAL
- en: The Return Address EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Return Address EIP describes how a target endpoint knows where it has to
    send a response. This EIP has to be used in combination with the Request Reply
    pattern, as we expect a response from the target endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by populating a `JMSReplyTo` header in the message in
    the case of the JMS endpoints involved.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the JMS component, this `JMSReplyTo` header is directly used
    and transported by the broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to use the `ReplyTo` option on the JMS endpoint to populate
    the `JMSReplyTo` header on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Message Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These EIPs are the core routing patterns. It's mostly where Camel provides specific
    syntax to handle routing.
  prefs: []
  type: TYPE_NORMAL
- en: The Content Based Router EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Content Based Router EIP is a special case of the Message Router EIP.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen previously, the Message Router EIP is a generic routing EIP defining
    a conditional routing on the message.
  prefs: []
  type: TYPE_NORMAL
- en: The Content Based Router EIP is used in cases where the condition is based on
    the content of the body of the message itself. In the Message Router example,
    the condition was on the extension of the consumed files.
  prefs: []
  type: TYPE_NORMAL
- en: Here, to illustrate the Content Based Router EIP, we create an example that
    will route the files depending on an `XPath` predicate in the body of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following `route.xml` Blueprint description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The route consumes files from the `/tmp/in` folder. The message body contains
    the contents of the file. We use the `XPath` predicates to test the `address`
    element in the message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the address is France, the message is routed to the `/tmp/out/france` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the address is USA, the message is routed to the `/tmp/out/usa` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the address is not France or USA, the message is routed to the `/tmp/out/others`
    folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route.xml` into the Karaf `deploy` folder. In the `/tmp/in` folder,
    we create the `first.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We also drop the `second.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We also drop the `third.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the files have been routed to different folders, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The Message Filter EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Filter EIP describes how to select only the messages that we want
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: We define a predicate to match and process the messages. If the messages don't
    match, their predicate will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: As in the Message Router EIP, we can use any language supported by Camel to
    write the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Message Filter EIP, we use the following `route.xml` Blueprint
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first route consumes the files from the `/tmp/in` folder. If the file contains
    the name element with `jbonofre`, the message is moved forward to the second route
    (thanks to the `direct` endpoint).
  prefs: []
  type: TYPE_NORMAL
- en: If the `XPath` predicate is not matched, the message is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the `/tmp/in` folder, we create the same three files as we did in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `first.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `second.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `third.xml` file, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This means that only the message from the `first.xml` file has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamic Router EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dynamic Router EIP describes how to dynamically route the message. When
    using the Message Router EIP, the different routing destinations and the conditions
    are statically defined at design time.
  prefs: []
  type: TYPE_NORMAL
- en: With the Dynamic Router EIP, the condition and the destinations are evaluated
    at runtime, and so, can be changed dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to send the message to multiple destinations on one condition.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this EIP, we create a route that uses a dynamic router. The dynamic
    router uses a bean to evaluate the condition and define the routing destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a very simple Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This Maven `pom.xml` file just packages the route and the bean as an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the `DynamicRouterBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This bean randomly and dynamically routes the message to two endpoints—if the
    generated random number is greater than `500`, the message is routed to the `direct:large`
    endpoint, otherwise, the message is routed to the `direct:small` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create the route using a Blueprint descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This route uses the bean in the `dynamicRouter` notation. We create the two
    routes corresponding to the target endpoints of the dynamic router.
  prefs: []
  type: TYPE_NORMAL
- en: 'We build our OSGi bundle with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is now ready to be deployed in Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We deploy and start our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Multicast and Recipient List EIPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Recipient List EIP describes how to send the same message to multiple destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two kinds of Recipient List:'
  prefs: []
  type: TYPE_NORMAL
- en: When the destinations are statically defined (at design time), we talk about
    the static Recipient List or multicast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the destinations are dynamically defined (at runtime), we talk about the
    dynamic recipient list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Multicast EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with a first example of the Multicast EIP (or a static recipient
    list).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following `route.xml` Blueprint descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The first route creates a `Hello chapter5m` message every 5 seconds. This message
    is sent to three destinations, `france`, `usa`, and `spain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We drop our `route.xml` file into the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can see that each message has been sent to the three destinations.
  prefs: []
  type: TYPE_NORMAL
- en: The Recipient List EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To illustrate a dynamic recipient list, we create a route that uses a bean to
    dynamically define the target destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a simple Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This Maven `pom.xml` file just packages our route and the bean as an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a simple `RouterBean` class that randomly changes the recipient list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If the random integer is greater than `500`, the message is routed to the `direct:one`,
    `direct:two`, and `direct:three` endpoints. Otherwise, the message is just routed
    to the `direct:one` and `direct:two` endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use this bean to populate a header in a route. This header is used
    by the recipient list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We build our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is ready to be deployed in Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We install our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the destinations dynamically change, depending on the result
    of the randomized integer.
  prefs: []
  type: TYPE_NORMAL
- en: The Splitter and Aggregator EIPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These EIPs are responsible for splitting a big message into chunks, or aggregating
    small chunks in one whole message.
  prefs: []
  type: TYPE_NORMAL
- en: The Splitter EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Splitter EIP describes how to split big messages into multiple chunks, processed
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP, allowing you to define the splitting logic using any
    supported language or a processor/bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Splitter EIP, we create the following `route.xml` Blueprint
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This route consumes files from the `/tmp/in` folder, and splits the content
    using `XPath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We drop the `route.xml` into the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/tmp/in` folder, we create the following `persons.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the *big* file has been split into *small* messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Camel supports multiple split strategies (using languages, tokens, custom beans,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Aggregator EIP is the exact opposite of the Splitter EIP—we receive multiple
    *small* messages that we want to aggregate into one *big* message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP. You have to provide two things to the aggregator:'
  prefs: []
  type: TYPE_NORMAL
- en: A bean implementing Camel `AggregationStrategy`, which defines the way you aggregate
    the new message with the previously aggregated message (the *message growing*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aggregation completion, which defines when we consider the aggregation to
    be complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You have different alternatives for the completion of the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: The `completionTimeout` is an inactivity timeout. If no new exchanges come into
    the aggregator after this timeout, the aggregation is considered to be complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `completionInterval` considers the aggregation to be complete after a given
    amount of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `completionSize` is a static number of exchanges to aggregate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `completionPredicate` is the most evolved. The aggregation is considered
    to be complete when the predicate is true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the Aggregator EIP, we create a route that aggregates a static
    number of messages.
  prefs: []
  type: TYPE_NORMAL
- en: We package the bean (used for the aggregation strategy) and the route definition
    as an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the `StringAggregator` class, which implements an aggregation strategy
    appending strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the route using the Blueprint DSL with an aggregator with our `StringAggregator`
    and a `completionSize` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The messages correlation (to identify that we are in the same aggregation unit)
    is defined using the header ID. This route aggregates five messages together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We build our OSGi bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is ready to be deployed in Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We install and start our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our route aggregated 5 `Hello chapter5p` messages.
  prefs: []
  type: TYPE_NORMAL
- en: The Resequencer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Resequencer EIP describes how to sort the processing of the messages. It
    uses a comparator to define the sequence of the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Camel uses an expression to create the comparator. It means that the comparator
    can use the body of the message, a header, and so on. You define the expression
    in the Camel resequencer notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Resequencer EIP, we use the following `route.xml` Blueprint
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Two routes generate a message every 2 seconds. Both routes send the message
    to the resequencer route. The resequencer uses a string comparator on the body
    of the messages, to guarantee the same processing order, `one` first, `two` after.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We drop the `route.xml` file into the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the messages are always processed in the same sequence, `one`
    first, `two` after.
  prefs: []
  type: TYPE_NORMAL
- en: The Composed Message Processor EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Composed Message Processor EIP is a combination of the Splitter EIP and
    the Aggregator EIP. The purpose is:'
  prefs: []
  type: TYPE_NORMAL
- en: To split a big message into chunk messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To process each chunk independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To reaggregate each chunk response as a big message again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Camel supports this EIP in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a pure combination of the Splitter and Aggregator EIPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using only Splitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The later is the easiest to use. It allows you to define the aggregation strategy
    directly on the splitter. The aggregation completion is defined by the Splitter
    as he knows the number of chunks he has created.
  prefs: []
  type: TYPE_NORMAL
- en: We illustrate the splitter-based Composed Message Processor EIP with an example
    that splits a `persons.xml` file with `XPath`, processes each person individually,
    and reaggregates the resulting message as a big one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a custom aggregation strategy, `MyAggregator`, that works directly
    using the message string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a route using the Blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This route consumes files from the `/tmp/in` folder, splits the messages using
    an `XPath` expression, and reaggregates after using the `MyAggregator` strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now compile our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We install and start our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the splitter isolated each person that has been processed individually.
    After the split, the messages have been reaggregated again, as we can see in the
    latest `log` message.
  prefs: []
  type: TYPE_NORMAL
- en: The Scatter-Gather EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Scatter-Gather EIP is similar to the Composed Message Processor EIP, but
    instead of splitting and aggregating, we first use a recipient list (static or
    dynamic) and an aggregator with the response coming from the different recipients.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP with the combination of recipient list/multicast and
    aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: The Routing Slip EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Routing Slip EIP describes how to dynamically define the processing steps
    of a message.
  prefs: []
  type: TYPE_NORMAL
- en: In a Camel route, the routing steps are statically defined; it's the route itself.
    However, you can use the `routingSlip` notation to define the next steps of the
    routing at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: It's exactly like a dynamic recipient list, but the processing is not in parallel,
    it's in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this EIP, we create a route that uses a bean to position a header
    containing the next processing steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the following `RoutingSlipBean` class, which randomly defines the
    next steps of the routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this bean in a Camel route written using the Blueprint DSL to define
    a `slip` header. This header is used by `routingslip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We now build our OSGi bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Our bundle is ready to be deployed in Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We install and start our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We can see (with the timestamps) that, sometimes, both one and two steps/routes
    are called, and sometimes only one is called.
  prefs: []
  type: TYPE_NORMAL
- en: The Throttler and Sampling EIPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These EIPs provide support of messaging Quality of Service (QoS). This allows
    you to implement some Service Level Agreement (SLA), limiting the threshold on
    some endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The Throttler EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Throttler EIP describes how to limit the number of messages reaching an
    endpoint, to avoid it. This allows you to guarantee SLA on routes, parts of routes,
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by providing the `throttle` notation. On the Throttle,
    you define a given period, and the maximum number of messages (or requests) allowed
    in the period. This number of messages can be static, or dynamic (using a header
    for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Throttler EIP, we create the following `route.xml` Blueprint
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We drop the `route.xml` into the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We can note the timestamp where we have only one message every two seconds,
    whereas the timer creates a message every 0.5 seconds; we have here an illustration
    of the Throttler EIP.
  prefs: []
  type: TYPE_NORMAL
- en: The Sampling EIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Sampling EIP is related to the Throttler EIP. The purpose is to take a
    message sample periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: Every given number of messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every given time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the *other* traffic is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP via the usage of the `sample` notation. The sample notation
    supports the `messageFrequency` or `samplePeriod` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Sampling EIP, we create the following `route.xml` blueprint
    XML descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The first route creates a message every 0.5 seconds. We log with the `regular`
    log. We use a `sample` notation to send the fifth message to the frequency route
    (so every five messages, we send the sample).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: We drop our `route.xml` file into the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: So, we can see that the frequency route gets a `sample` notation for every five
    messages of regular load.
  prefs: []
  type: TYPE_NORMAL
- en: The Delayer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Delayer EIP allows you to add some kind of pause in the delivery of a message.
    It's like a sleep in the routing.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP using the `delay` notation. The delay notation accepts
    an expression to get the pause time. You can use any language supported by Camel
    for this expression.
  prefs: []
  type: TYPE_NORMAL
- en: We used this EIP in the `chapter5g` and `chapter5h` examples.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we used a constant to define the delay time. It's also possible
    to use an expression returning the delay time. As always, the expression can be
    written using any language supported by Camel.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the Delayer EIP with a dynamic delay time, we create a route that
    uses a bean to define the delay time (randomly).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the following Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: This Maven `pom.xml` file is very simple, just packaging the Blueprint XML definition
    of the route and the bean as an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a simple bean that randomly creates the delay time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a route using the blueprint DSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This route creates a message every second with a timer, and uses the bean in
    the `delay` notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We build our OSGi bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Our OSGi bundle is ready to be deployed in Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'We deploy our OSGi bundle in Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look in the Karaf `log` file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We can note that the message is delivered randomly (see the timestamp), showing
    the Delayer EIP in action.
  prefs: []
  type: TYPE_NORMAL
- en: The Load Balancer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Load Balancer EIP dispatches the load of messages to different endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP with the `loadBalance` notation, which also supports
    different balancing policies such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The round-robin policy uses a kind of *circle* between the different endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The random policy picks up one endpoint randomly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sticky policy uses an expression to select the target endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topic policy sends the message to all the endpoints (like a JMS topic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The failover policy forwards the message to the next endpoint if the first target
    failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The weighted round-robin policy is like the round-robin policy, but you can
    give a ratio to the different endpoints to use them on high priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The weighted random policy is like the random policy, but you can give a ratio
    to the different endpoints to use them on high priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom policy allows you to implement your own load balancing policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the Load Balancer EIP, we use the following `route.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route creates a message every second. The message is load balanced
    with the round-robin policy to the three endpoints: `direct:one`, `direct:two`,
    and `direct:three`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route.xml` file into the Karaf `deploy` folder. In the Karaf `log`
    file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Here, we note that each message is load balanced to the three endpoints in a
    round-robin manner.
  prefs: []
  type: TYPE_NORMAL
- en: The Loop EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Loop EIP describes how to iterate a message on the same endpoint multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP using the `loop` notation. The number of iterations
    can be a constant, or the result of an expression (using any language supported
    by Camel).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Loop EIP, we create the following `route.xml` blueprint descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This route creates a message every second and logs this message. The message
    is sent to a loop performing three iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route.xml` file into the Karaf `deploy` folder. In the Karaf `log`
    file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We can note that the message has been processed three times by the loop route.
  prefs: []
  type: TYPE_NORMAL
- en: Message Transformation EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These EIPs are extensions of the Message Translator EIP, and are dedicated to
    some special use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Content Enricher EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Content Enricher EIP describes how to enrich the message with another system.
    For instance, the message contains an identifier, and you want to populate the
    data associated with this ID from a database.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this EIP, you can use a bean or a processor as you do in the Message
    Translator EIP.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use an endpoint that uses a transformation tool (such as `Velocity`,
    `Xslt`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Camel provides two notations dedicated to content enrichment. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enrich` uses a producer endpoint to retrieve the data and use an aggregation
    strategy (like in the Aggregator EIP) to merge the data. For instance, `enrich`
    is used to call a webservice or another direct endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollEnrich`, on the other hand, uses a consumer endpoint to poll the data
    and use an aggregation strategy to merge the data. For instance, `pollEnrich`
    is used when polling a file on the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Content Filter EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Content Filter EIP describes how to remove part of the content of the message
    when the message is too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP by:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a bean or a processor as in the Message Translator EIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `setBody` notation containing a filter expression (such as `XPath`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Claim Check EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Claim Check EIP describes how to replace the content of the message with
    a claim check (unique key), which you can use later to retrieve the message again.
    The message content is identified by the identifier and stored temporarily in
    a store such as a database or the filesystem. This pattern is really interesting
    to deal with very large messages that you don't want to transport to all parts
    of the routing.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by combining Pipeline and a dedicated bean to store
    and retrieve the message using the identifier.
  prefs: []
  type: TYPE_NORMAL
- en: The Normalizer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Normalizer EIP is a combination of the Message Router EIP to deal with multiple
    message formats, and transform the messages into a canonical and normalized message
    format. One *classic* use is to transform all messages into a unique canonical
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by combining a content-based router and a series of
    beans to translate the message into the normalized format.
  prefs: []
  type: TYPE_NORMAL
- en: The Sort EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sort EIP sorts the content of the message. Basically, it applies a comparator
    to the message body.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP using the `sort` notation. You can provide what you
    want to sort (basically the body) and optionally, the comparator to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Validate EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Validate EIP uses an expression or a predicate to validate the content of
    the message. This EIP allows you to validate the payload of a message before processing
    it. Thanks to this, you avoid mistakes due to an invalid format.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP with the `validate` notation. The validate notation
    expects an expression, which is defined using any language supported by Camel.
  prefs: []
  type: TYPE_NORMAL
- en: The Messaging Endpoints EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Messaging Endpoints EIPs are related to endpoints in a Camel route. Camel
    supports them implicitly by using the different features provided by the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The Messaging Mapper EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Messaging Mapper EIP is actually the same thing as the Message Translator
    EIP, just located at the endpoint level.
  prefs: []
  type: TYPE_NORMAL
- en: In Camel, it just means that you use a bean or a processor in the same way that
    you do to implement the Message Translator EIP.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Driven Consumer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Event Driven Consumer EIP describes an endpoint that listens for incoming
    messages. The endpoint reacts when it gets a message.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by providing the components' bootstrapping endpoints
    that can work this way. It's the case for the CXF or JMS components, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is supported implicitly by Camel (you don't have to use any special
    notation).
  prefs: []
  type: TYPE_NORMAL
- en: The Polling Consumer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Polling Consumer EIP describes an endpoint that periodically polls a system
    (database, file system) to generate messages.
  prefs: []
  type: TYPE_NORMAL
- en: As in the Event Driven Consumer EIP, Camel supports this EIP by providing the
    components' bootstrapping endpoints that can work this way. This is the case for
    the file or FTP components, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This EIP is supported implicitly by Camel (you don't have to use any special
    notation).
  prefs: []
  type: TYPE_NORMAL
- en: The Competing Consumer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Competing Consumer EIP describes how to use multiple concurrent consumers
    on a single endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP on some components. For instance, the SEDA, VM, and
    JMS components support this EIP using the `concurrentConsumers` property (with
    a value greater than `1`).
  prefs: []
  type: TYPE_NORMAL
- en: The Message Dispatcher EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Dispatcher EIP describes how to dispatch a message to different
    endpoints, depending on some conditions. It's basically the same as the Message
    Router EIP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports the Message Dispatcher EIP in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Content Based Router EIP (and so, the `choice` notation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JMS component (and a message selector)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Selective Consumer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Selective Consumer EIP describes how an endpoint can consume only some messages,
    based on a filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Message Filter EIP (and the `filter` notation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a message selector on the JMS component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Durable Subscriber EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Durable Subscriber EIP describes how to use a publish-subscribe model, where
    the messages are stored when the subscriber is not connected, which are waiting
    to be delivered when they are back online.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP using the JMS component. A JMS endpoint consumer on
    a topic supports the `clientId` and `durableSubscriptionName` properties, allowing
    it to act as a durable subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: The Idempotent Consumer EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Idempotent Consumer EIP is used to filter duplicate messages, by identifying
    each message uniquely. It acts as a message filter to filter the duplicated messages.
    Basically, each message identifier is stored in a backend, and the EIP checks
    each incoming message, if it's not already present in the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP with the `idempotentConsumer` notation. Different message
    stores are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MemoryIdempotentRepository` stores the messages in a HashMap in the memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileIdempotentRepository` stores the messages on the filesystem (in a property
    file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HazelcastIdempotentRepository` stores the messages on a Hazelcast-distributed
    HashMap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JdbcMessageIdRepository` stores the messages in a database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Transactional Client EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Transactional Client EIP describes how an endpoint can participate in a
    transaction. This means that it's possible that the client explicitly performs
    commit and rollback on a transaction. The client can be considered to be a transactional
    resource and can therefore manage a two-phase commit.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by providing the components' supporting transactions.
    This is the case for the JMS endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The Message Gateway and Service Activator EIPs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message Gateway EIP describes how to wrap a message format to another message
    format. Basically, it wraps a Java interface as a message exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP by providing components that support such wrapping,
    for instance, the Bean and CXF components.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the Service Activator EIP is very similar to the Message Gateway
    EIP.
  prefs: []
  type: TYPE_NORMAL
- en: System Management EIPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These EIPs are not directly related to the messages. They provide a very convenient
    way to implement system and are useful in analyzing and managing the routing system
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The ControlBus EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the ControlBus EIP is to be able to manage and control the routing
    system itself. This means being able to stop the routing system, start it again,
    get details about the routing activity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides a lot of JMX MBeans, where you can find a lot of metrics and
    control the involved routes, processors, components, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel provides a `controlbus` component that you can use to manage the Camel
    routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `controlbus` endpoint, you can send a message, for instance, to stop
    or start a route.
  prefs: []
  type: TYPE_NORMAL
- en: The Detour EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Detour EIP allows you to send messages on additional and specific steps
    when a control condition is met. You can use it to add extra validation, test,
    and debug steps when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP with a message router. The condition of the message
    router is implemented with a bean; this bean implements the logic to define whether
    the detour is needed or not.
  prefs: []
  type: TYPE_NORMAL
- en: The Wire Tap EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Wire Tap EIP allows you to send a copy of the message to a specific endpoint,
    without impacting the main route. This EIP is very useful to implement logging
    or auditing system.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP with the `wireTap` notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the Wire Tap EIP, we create the following `route.xml` blueprint
    descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The first route creates a message every 5 seconds. The Wire Tap EIP sends a
    copy of the message to the `wiretap` route. The main route keeps on processing,
    using a delay of 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop our `route.xml` into the Karaf `deploy` folder. In the Karaf `log`
    file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The wire tap message has been logged, whereas the main route is still on the
    fly. We note here that the `wire tap route` doesn't impact the main one (in terms
    of performances or blocking messages).
  prefs: []
  type: TYPE_NORMAL
- en: The Wire Tap EIP is especially interesting when the logging backend can take
    time (using a JDBC appender for instance).
  prefs: []
  type: TYPE_NORMAL
- en: The Message History EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Message History EIP is used to analyze and debug the flow of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, it means attaching a history to a message that provides the list
    of all the endpoints that the message passed through.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports this EIP with the Camel Tracer feature. The Tracer is basically
    an interceptor on the channels; it traces all exchange details.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this information, you can see where the message passed through the body
    of the message on each endpoint, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Every Camel route embeds the Tracer feature, but it's disabled by default. You
    can enable the Tracer via JMX on the route MBean.
  prefs: []
  type: TYPE_NORMAL
- en: The Log EIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Log EIP allows you to create a log message with all or part of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel supports this EIP in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the log component, as we did in most of the examples of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the `log` notation, allowing you to specify the log message format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the Log EIP, we create the following `route.xml` blueprint descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: We can see here the two ways to log—using the log component or using the `log`
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` notation (EIP) gives you complete control over what you want to log,
    the log level, the logger name, and possibly the log markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Karaf and install the `camel-blueprint` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop our `route.xml` file into the Karaf `deploy` folder. In the Karaf `log`
    file, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the log messages generated by the log component and the Log
    EIP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that Camel supports all kinds of Enterprise Integration Patterns;
    from Messaging Systems EIPs to System Management EIPs, you are now ready to use
    the patterns that you need, and can easily implement them in your routes.
  prefs: []
  type: TYPE_NORMAL
- en: The notations are a very convenient way to describe and specify complex routing
    behaviors. The combination of the connectivity components and the Enterprise Integration
    Patterns makes Camel the most flexible and powerful routing system available.
  prefs: []
  type: TYPE_NORMAL
- en: And, if the provided components or patterns don't suit your requirements, you
    can always create your own specific component, as we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
