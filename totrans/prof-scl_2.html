<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Basic Language Features"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Basic Language Features</h1></div></div></div><p>In the previous chapter, we learned the various aspects of setting up the development environment wherein we covered the structure of a Scala project and identified the use of 
<code class="literal">sbt</code> for building and running projects. We covered REPL, which is a command-line interface for running Scala code, and how to develop and run code over the IDEA IDE. Finally, we implemented interactions with our simple 
<code class="literal">chatbot</code> application.
</p><p>In this chapter, we will explore the so-called 'OO' part of Scala, which allows us to build constructions similar to analogs in any mainstream language, such as Java or C++. The object-oriented part of Scala will cover classes and objects, traits, pattern matching, case class, and so on. Finally, we will implement the object-oriented concepts that we learn to our chatbot application.</p><p>Looking at the history of programming paradigms, we will notice that the first generation of high-level programming languages (Fortran, C, Pascal) were procedure oriented, without OO or FP facilities. Then, OO become a hot topic in programming languages in the 1980s.</p><p>By the end of this chapter, you will be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the structure of non-trivial Scala programs</li><li class="listitem" style="list-style-type: disc">Identify how to use main object-oriented facilities: objects, classes, and traits</li><li class="listitem" style="list-style-type: disc">Recognize the details of function call syntax and parameter-passing modes</li></ul></div><div class="section" title="Objects, Classes, and Traits"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Objects, Classes, and Traits</h1></div></div></div><p>Scala is a
<a class="indexterm" id="id49"/> multiparadigm language, which unites functional and OO programming. Now, we will explore Scala's traditional object-oriented programming facilities: object, classes, and traits.
</p><p>These facilities are similar in the sense that each one contains some sets of data and methods, but they are different regarding life cycle and instance management:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Objects are <a class="indexterm" id="id50"/>used when we need a type with one instance  (such as singletons)</li><li class="listitem" style="list-style-type: disc">Classes are <a class="indexterm" id="id51"/>used when we need to have many instances, which can <a class="indexterm" id="id52"/>be created with the help of the new operator</li><li class="listitem" style="list-style-type: disc">Traits are <a class="indexterm" id="id53"/>used <a class="indexterm" id="id54"/>for mix-ins into other classes</li></ul></div><p>Note that it is not worth navigating through code, as this is exposed in examples.</p><div class="section" title="Object"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Object</h2></div></div></div><p>We have 
<a class="indexterm" id="id55"/>seen 
<a class="indexterm" id="id56"/>an object in the previous chapter. Let's scroll through our codebase and open the file named 
<code class="literal">Main</code> in 
<code class="literal">Lesson 2/3-project</code>:
</p><div class="informalexample"><pre class="programlisting">object Chatbot3 {
val effects = DefaultEffects
def main(args: Array[String]): Unit = {
   ….}
   def createInitMode() = (Bye or CurrentDate or CurrentTime) otherwise InterestingIgnore
}</pre></div><p>It's just a set
<a class="indexterm" id="id57"/> of definitions, grouped into one object, which is available statically. That is, the implementation of a singleton pattern: we only have one instance of an object of a given type.
</p><p>Here, we can 
<a class="indexterm" id="id58"/>see the definition of the value (
<code class="literal">val effects</code>) and main functions. The syntax is more-or-less visible. One non-obvious thing is that the 
<code class="literal">val</code> and 
<code class="literal">var</code> definitions that are represented are not plain field, but internal field and pairs of functions: the 
<code class="literal">getter</code> and 
<code class="literal">setter</code> functions for 
<code class="literal">var-s</code>. This allows overriding 
<code class="literal">def-s</code> by 
<code class="literal">val-s</code>.
</p><p>Note that the name in the object definition is a name of an object, not a name of the type. The type of the object, 
<code class="literal">Chatbot3</code>, can be accessed as 
<code class="literal">Chatb</code>
<code class="literal">ot3.type.</code>
</p><p>Let's define the 
<a class="indexterm" id="id59"/>object and call a method. We will also try to assign the object to a variable.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>You should have 
<code class="literal">project-3</code> opened in IDEA.
</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to the project structure and find the <code class="literal">com.packt.courseware.l3</code> package. </li><li class="listitem">Right-click and select <code class="literal">create class</code> in the context menu.</li><li class="listitem">Enter <code class="literal">ExampleObject</code> in the name field and choose <code class="literal">object</code> in the kind field of the form.</li><li class="listitem">IDEA will <a class="indexterm" id="id60"/>generate the file in the object.</li><li class="listitem">Insert the following in the object definition:<div class="informalexample"><pre class="programlisting">   def hello(): Unit = {
       println("hello")
    }
  - navigate to main object
   Insert before start of main method:
    val example = ExampleObject
   Insert at the beginning of the main method:
     example.hello()</pre></div></li></ol></div></div><div class="section" title="Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Classes</h2></div></div></div><p>Classes
<a class="indexterm" id="id61"/> form 
<a class="indexterm" id="id62"/>the next step in abstractions. Here is an example of a class definition:
</p><div class="informalexample"><pre class="programlisting">package com.packt.courseware.l4
import math._
class PolarPoint(phi:Double, radius:Double) extends Point2D
{
require(phi &gt;= - Pi &amp;&amp; phi &lt; Pi )
require(radius &gt;= 0)
def this(phi:Double) = this(phi,1.0)
override def length = radius
def x: Double = radius*cos(phi)
def y: Double = radius*sin(phi)
def * (x:Double) = PolarPoint(phi,radius*x)
}</pre></div><p>Here is a class 
<a class="indexterm" id="id63"/>with parameters (
<code class="literal">phi</code>, 
<code class="literal">radius</code>) specified in the class definition. Statements outside the class methods (such as require statements) constitute the body of a primary constructor.
</p><p>The next definition is a secondary constructor, which must call the primary constructor at the first statement.</p><p>We can create an object instance using the 
<code class="literal">new </code>operator:
</p><div class="informalexample"><pre class="programlisting">val p = new PolarPoint(0)</pre></div><p>By default, member 
<a class="indexterm" id="id64"/>access modifiers are 
<code class="literal">public</code>, so once we have created an object, we can use its methods. Of course, it is possible to define the method as 
<code class="literal">protected</code> or 
<code class="literal">private</code>.
</p><p>Sometimes, we want to have constructor parameters available in the role of class members. A special syntax for this exists:</p><div class="informalexample"><pre class="programlisting">case class PolarPoint(val phi:Double, val radius:Double) extends Point2D</pre></div><p>If we write 
<code class="literal">val</code> as a modifier of the constructor argument (
<code class="literal">phi</code>), then 
<code class="literal">phi</code> becomes a member of the class and will be available as a field.
</p><p>If you browse the source code of a typical Scala project, you will notice that an object with the
<a class="indexterm" id="id65"/> same name as a class is often defined along with the class definition. Such objects are called 
<code class="literal">companion</code> objects of a class:
</p><div class="informalexample"><pre class="programlisting">object PolarPoint{
def apply(phi:Double, r:Double) = new PolarPoint(phi,r)
}</pre></div><p>This is a typical place for utility functions, which in the Java world are usually represented by 
<code class="literal">static</code> methods.
</p><p>Method names also exist, which allow you to use special syntax sugar on the call side. We will tell you about all of these methods a bit later. We will talk about the 
<code class="literal">apply</code> method now.
</p><p>When a method is named 
<code class="literal">apply</code>, it can be called via functional call braces (for example, 
<code class="literal">x(y)</code> is the same as 
<code class="literal">x.apply(y),</code> if 
<code class="literal">apply</code> is defined in 
<code class="literal">x</code>).
</p><p>Conventionally, the 
<code class="literal">apply</code> method in the companion object is often used for instance creation to allow the syntax without the 
<code class="literal">new</code> operator. So, in our example, 
<code class="literal">PolarPoint(3.0,5.0)</code> will be demangled to 
<code class="literal">PolarPoint.apply(3.0,5.0)</code>.
</p><p>Now, let's define a case class, CartesianPoint, with the method length.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Ensure<a class="indexterm" id="id66"/> that the <code class="literal">Lesson 2/4-project</code> project is open in IDE.</li><li class="listitem">Create a new Scala class with the name <code class="literal">CartesianPoint</code>.</li><li class="listitem">The code should be something like this:<div class="informalexample"><pre class="programlisting">case class CartesianPoint(x:Double, y:Double) extends Point2D {
override def length(): Double = x*x + y*y
}</pre></div></li></ol></div></div><div class="section" title="Equality and Case Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Equality and Case Classes</h2></div></div></div><p>In general, two
<a class="indexterm" id="id67"/> flavors of equality exist:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Extensional</strong></span>, where two objects are equal when all external properties are equal.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In JVM, a user can override equals and <code class="literal">hashCode</code> methods of an object to achieve such a behavior.</li><li class="listitem" style="list-style-type: disc">In a Scala expression, <code class="literal">x == y</code> is a shortcut of <code class="literal">x.equals(y)</code> if <code class="literal">x</code> is a reference type (for example, a class or object).</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Intentional</strong></span> (or reference), where two objects with the same properties can be different because they had been created in a different time and context.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In JVM, this is the comparison of references; <code class="literal">(x == y)</code> in Java and <code class="literal">(x eq y)</code> in Scala.</li></ul></div></li></ul></div><p>Looking at our 
<code class="literal">PolarPoint</code>, it looks as though if we want 
<code class="literal">PolarPoint(0,1)</code> to be equal 
<code class="literal">PolarPoint(0,1)</code>, then we must override 
<code class="literal">equals</code> and 
<code class="literal">hashCode</code>.
</p><p>The Scala language provides a flavor of classes, which will do this work (and some others) automatically.</p><p>Let's see
<a class="indexterm" id="id68"/> the 
<code class="literal">case</code> classes:
</p><div class="informalexample"><pre class="programlisting">case class PolarPoint(phi:Double, radius:Double) extends Point2D</pre></div><p>When we mark a class as a case class, the Scala compiler will generate the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">equals</code> and <code class="literal">hashCode</code> methods, which will compare classes by components</li><li class="listitem" style="list-style-type: disc"><code class="literal">A toString</code> method which will output components</li><li class="listitem" style="list-style-type: disc"><code class="literal">A copy</code> method, which will allow you to create a copy of the class, with some of the fields changed:<div class="informalexample"><pre class="programlisting">val p1 = PolarPoint(Pi,1)
val p2 = p1.copy(phi=1)</pre></div></li><li class="listitem" style="list-style-type: disc">All parameter constructors will become class values (therefore, we do not need to write <code class="literal">val</code>)</li><li class="listitem" style="list-style-type: disc">The companion object of a<a class="indexterm" id="id69"/> class with the apply method (for constructor shortcuts) and <code class="literal">unapply</code> method (for deconstruction in case patterns)</li></ul></div><p>Now, we'll look at illustrating the differences between value and reference equality.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">test/com.packt.courseware.l4</code>, create a worksheet.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>To create a worksheet, navigate to package, and right-click and choose create a Scala worksheet from the drop-down menu.</p></div></div></li><li class="listitem">Define a non-case class with fields in this file after import:<div class="informalexample"><pre class="programlisting">
class NCPoint(val x:Int, val y:Int)
val ncp1 = new NCPoint(1,1)
val ncp2 = new NCPoint(1,1)
ncp1 == ncp2
ncp1 eq ncp2</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Notice that the results are 
<code class="literal">false</code>.
</p></div></div></li><li class="listitem">Define the case class with the same fields:<div class="informalexample"><pre class="programlisting">case class CPoint(x:Int, y:Int)</pre></div></li><li class="listitem">Write a similar test. Note the differences:<div class="informalexample"><pre class="programlisting">val cp1 = CPoint(1,1)val cp2 = CPoint(1,1)cp1 == cp2cp1 eq cp2</pre></div></li></ol></div></div><div class="section" title="Pattern Matching"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Pattern Matching</h2></div></div></div><p>
<span class="strong"><strong>Pattern matching</strong></span>
<a class="indexterm" id="id70"/> is a construction that was first
<a class="indexterm" id="id71"/> introduced into the ML language family near 1972 (another similar technique can also be viewed as a pattern-matching predecessor, and this was in REFAL language in 1968). After Scala, most new mainstream programming languages (such as Rust and Swift) also started to include pattern-matching constructs.
</p><p>Let's look at 
<a class="indexterm" id="id72"/>pattern-matching usage:
</p><div class="informalexample"><pre class="programlisting">val p = PolarPoint(0,1)
val r = p match {
case PolarPoint(_,0) =&gt; "zero"
case x: PolarPoint if (x.radius == 1) =&gt; s"r=1, phi=${x.phi}"
case v@PolarPoint(x,y) =&gt; s"(x=${x},y=${y})"
case _ =&gt; "not polar point"
}</pre></div><p>On the second line, we see a match/case expression; we match 
<code class="literal">p</code> against the sequence of case-e clauses. Each case clause contains a pattern and body, which is evaluated if the matched expression satisfies the appropriative pattern.
</p><p>In this example, the first case pattern will match any point with a radius of 
<code class="literal">0</code>, that is, 
<code class="literal">_</code> match any.
</p><p>Second–This will satisfy any 
<code class="literal">PolarPoint</code> with a radius of one, as specified in the optional pattern condition. Note that the new value (
<code class="literal">x</code>) is introduced into the body context.
</p><p>Third – This will match any point; bind 
<code class="literal">x</code> and 
<code class="literal">y</code> to
<code class="literal"> phi </code>and the 
<code class="literal">radius</code> accordingly, and 
<code class="literal">v</code> to the pattern (
<code class="literal">v</code> is the same as the original matched pattern, but with the correct type).
</p><p>The final case 
<a class="indexterm" id="id73"/>expression is a 
<code class="literal">default</code> case, which matches any value of 
<code class="literal">p</code>.
</p><p>Note that the patterns can be nested.</p><p>As we can see, case classes can participate in case expression and provide a method for pushing matched values into the body's content (which is deconstructed).</p><p>Now, it's time to use match/case statements.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a class file in the test sources of the  current project with the name <code class="literal">Person</code>.</li><li class="listitem">Create a case class called <code class="literal">Person</code> with the members <code class="literal">firstName</code> and <code class="literal">lastName:</code><div class="informalexample"><pre class="programlisting">case class Person(firstName:String,lastName:String)</pre></div></li><li class="listitem">Create a companion object and add a method which accepts <code class="literal">person</code> and returns <code class="literal">String:</code><div class="informalexample"><pre class="programlisting">def classify(p:Person): String = {
// insert match code here .???
}
}</pre></div></li><li class="listitem">Create a <code class="literal">case</code> statement, which will print:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">"<code class="literal">A</code>" if the person's first name is "<code class="literal">Joe</code>"</li><li class="listitem" style="list-style-type: disc">"<code class="literal">B</code>" if the person does not satisfy other cases</li><li class="listitem" style="list-style-type: disc">"<code class="literal">C</code>" if the <code class="literal">lastName</code> starts in lowercase</li></ul></div></li><li class="listitem">Create a test-case<a class="indexterm" id="id74"/> for this method:<div class="informalexample"><pre class="programlisting">class PersonTest extends FunSuite {
test("Persin(Joe,_) should return A") {
assert( Person.classify(Person("Joe","X")) == "A" )
}
}
}</pre></div></li></ol></div></div><div class="section" title="Traits"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Traits</h2></div></div></div><p>Traits are 
<a class="indexterm" id="id75"/>used for grouping methods and values which can be used in other classes. The functionality of traits is mixed into other traits 
<a class="indexterm" id="id76"/>and classes, which in other languages are appropriative constructions called 
<code class="literal">mixins</code>. In Java 8, interfaces are something similar to traits, since it is possible to define default implementations. This isn't entirely accurate, though, because Java's default method can't fully participate in inheritance.
</p><p>Let's 
<a class="indexterm" id="id77"/>look at the following code:
</p><div class="informalexample"><pre class="programlisting">trait Point2D {
def x: Double
def y: Double
def length():Double = x*x + y*y}</pre></div><p>Here is a trait, which can be extended by the 
<code class="literal">PolarPoint</code> class, or with the 
<code class="literal">CartesianPoint</code> with the next definition:
</p><div class="informalexample"><pre class="programlisting">case class CartesianPoint(x:Double, y:Double) extends Point2D</pre></div><p>Instances of traits cannot be created, but it is possible to create anonymous classes extending the trait:</p><div class="informalexample"><pre class="programlisting">val p = new Point2D {override def x: Double = 1
override def y: Double = 0}
assert(p.length() == 1)</pre></div><p>Here is an
<a class="indexterm" id="id78"/> example of a trait:
</p><div class="informalexample"><pre class="programlisting">trait A {
def f = "f.A"
}
trait B {def f = "f.B"def g = "g.B"
}
trait C extends A with B {override def f = "f.C" // won't compile without override.
}</pre></div><p>As we can see, the conflicting method must be overridden:</p><p>Yet one puzzle:</p><div class="informalexample"><pre class="programlisting">
trait D1 extends B1 with C{override def g = super.g}
trait D2 extends C with B1{override def g = super.g}</pre></div><p>The 
<a class="indexterm" id="id79"/>result of 
<code class="literal">D1.g</code> will be 
<code class="literal">g.B</code>, and 
<code class="literal">D2.g</code> will be 
<code class="literal">g.C</code>. This is because traits are linearized into sequence, where each trait overrides methods from the previous one.
</p><p>Now, let's try to represent the diamond in a trait hierarchy.</p><p>Create the following entities:</p><p>
<code class="literal">Component</code> – A 
<code class="literal">base</code> class with the 
<code class="literal">description()</code> method, which outputs the description of a component.
</p><p>
<code class="literal">Transmitter</code> – A component which generates a signal and has a method called 
<code class="literal">generateParams</code>.
</p><p>
<code class="literal">Receiver </code>– A component which accepts a signal and has a method called 
<code class="literal">receiveParams</code>.
</p><p>Radio – A 
<code class="literal">Transmitter</code> and 
<code class="literal">Receiver</code>. Write a set of traits, where 
<code class="literal">A</code> is modelled as inheritance. 
</p><p>The answer to this should be as follows:</p><div class="informalexample"><pre class="programlisting">trait Component{
def description(): String
}
trait Transmitter extends Component{
def generateParams(): String
}
trait Receiver extends Component{
def receiverParame(): String
}
trait Radio extends Transmitter with Receiver</pre></div></div><div class="section" title="Self-Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Self-Types</h2></div></div></div><p>In Scale-trait, you
<a class="indexterm" id="id80"/> can sometimes see the self-types 
<a class="indexterm" id="id81"/>annotation, for example:
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>For full code, refer to 
<code class="literal">Code Snippets/Lesson 2.scala</code> file.
</p></div></div><div class="informalexample"><pre class="programlisting">trait Drink
{
 def baseSubstation: String
 def flavour: String
 def description: String
}


trait VanillaFlavour
{
 thisFlavour: Drink =&gt;

 def flavour = "vanilla"
 override def description: String = s"Vanilla ${baseSubstation}"
}

trait SpecieFlavour
{
 thisFlavour: Drink =&gt;

 override def description: String = s"${baseSubstation} with ${flavour}"
}

trait Tee
{
  thisTee: Drink =&gt;

  override def baseSubstation: String = "tee"

  override def description: String = "tee"


    def withSpecies: Boolean = (flavour != "vanilla")
}</pre></div><p>Here, we see the 
<code class="literal">identifier =&gt; {typeName}</code> prefix, which is usually a self-type annotation.
</p><p>If the type
<a class="indexterm" id="id82"/> is specified, that trait can only be mixed-in to this type. For example, 
<code class="literal">VanillaTrait</code> can only be mixed in with Drink. If we try to mix this with another object, we will receive an error.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>If 
<code class="literal">Flavor</code> is not extended from 
<code class="literal">Drink</code>, but has access to 
<code class="literal">Drink</code> methods such as looks, as in 
<code class="literal">Flavor,</code> we situate it inside Drink.
</p></div></div><p>Also, self-annotation can be used without specifying a type. This can be useful for nested traits when we want to call "this" of an enclosing trait:</p><div class="informalexample"><pre class="programlisting">trait Out{
thisOut =&gt;

trait Internal{def f(): String = thisOut.g()
  def g(): String = .
  }
def g(): String = ….
}</pre></div><p>Sometimes, we can see the organization of some big classes as a set of traits, grouped around 
<a class="indexterm" id="id83"/>one 'base'. We can visualize this as 'Cake', which consists of the 'Pieces:' self-annotated trait. We can change one piece to another by changing the mix-in traits. Such an organization of code is named the 'Cake pattern'. Note that using the Cake pattern is often controversial, because it's relative easy to create a 'God object'. Also note that the refactor class hierarchy with the cake-pattern inside is harder to
<a class="indexterm" id="id84"/> implement.
</p><p>Now, let's explore annotations.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an instance of Drink with Tee with <code class="literal">VanillaFlavour</code> which refers to <code class="literal">description</code>:<div class="informalexample"><pre class="programlisting">val tee = new Drink with Tee with VanillaFlavour
val tee1 = new Drink with VanillaFlavour with Tee
tee.description
tee1.description</pre></div></li><li class="listitem">Try to override the description in the <code class="literal">Tee</code> class:<p>Uncomment 
<code class="literal">Tee</code>: 
<code class="literal">def description = plain tee</code> in the 
<code class="literal">Drinks</code> file.
</p><p>Check if any error message arises.</p></li><li class="listitem">Create the third object, derived from <code class="literal">Drink</code> with <code class="literal">Tee</code> and <code class="literal">VanillaFlavour</code> with an overloaded description:<div class="informalexample"><pre class="programlisting">val tee2 = new Drink with Tee with VanillaFlavour{
override def description: String ="plain vanilla tee"
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>For full code, refer to 
<code class="literal">Code Snippets/Lesson 2.scala</code> file.
</p></div></div></li></ol></div><p>Also note that special syntax for methods exists, which must be 'mixed' after the overriding method, for example:</p><div class="informalexample"><pre class="programlisting">trait Operation
{

  def doOperation(): Unit

}

trait PrintOperation
{
  this: Operation =&gt;

  def doOperation():Unit = Console.println("A")
}

trait LoggedOperation extends Operation
{
  this: Operation =&gt;

  abstract override def doOperation():Unit = {
    Console.print("start")
    super.doOperation()
    Console.print("end")
  }
}</pre></div><p>Here, we see 
<a class="indexterm" id="id85"/>that the methods marked as 
<code class="literal">abstract override</code> can call 
<code class="literal">super</code> methods, which are actually defined in traits, not in this base class. This is a relatively rare technique.
</p></div><div class="section" title="Special Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Special Classes</h2></div></div></div><p>There are a 
<a class="indexterm" id="id86"/>few classes with special syntax, which play a significant role in the Scala type system. We will cover this in detail later, but now let's just enumerate some:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functions</strong></span>: In <a class="indexterm" id="id87"/>Scala, this can be coded as <code class="literal">A =&gt; B</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tuples</strong></span>: In<a class="indexterm" id="id88"/> Scala, this can be coded as <code class="literal">(A,B), (A,B,C)</code> … and so on, which is a syntax sugar for <code class="literal">Tuple2[A,B]</code>, <code class="literal">Tuple3[A,B,C],</code> and so on</li></ul></div></div></div></div>
<div class="section" title="OO in Our Chatbot"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>OO in Our Chatbot</h1></div></div></div><p>Now that you know the theoretical basics, let's look at these facilities and how they are 
<a class="indexterm" id="id89"/>used in our program. Let's open 
<code class="literal">Lesson 2/3-project</code> in our IDE and extend our chatbot, which was developed in the previous chapter.
</p><div class="section" title="Decoupling Logic and Environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Decoupling Logic and Environment</h2></div></div></div><p>To do this, we
<a class="indexterm" id="id90"/> must decouple the environment and logic, and integrate only one in the 
<code class="literal">main</code> method.
</p><p>Let's open the 
<code class="literal">EffectsProvider</code> class:
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>For full code, refer to 
<code class="literal">Code Snippets/Lesson 2.scala</code> file.
</p></div></div><div class="informalexample"><pre class="programlisting">trait EffectsProvider extends TimeProvider {

 def input: UserInput

 def output: UserOutput

}

object DefaultEffects extends EffectsProvider
{
 override def input: UserInput = ConsoleInput

 override def output: UserOutput = ConsoleOutput

 override def currentTime(): LocalTime = LocalTime.now()

 override def currentDate(): LocalDate = LocalDate.now()
}</pre></div><p>Here, we encapsulate all of the effects into our traits, which can have different implementations.</p><p>For example, let's look at 
<code class="literal">UserOutput</code>:
</p><p>For full code, refer to 
<code class="literal">Code Snippets/Lesson 2.scala</code> file.
</p><div class="informalexample"><pre class="programlisting">trait UserOutput {

 def write(message: String): Unit

 def writeln(message: String): Unit = {
  write(message)
  write("\n")
 }

}


object ConsoleOutput extends UserOutput
{

 def write(message: String): Unit = {
  Console.print(message)
 }
}</pre></div><p>Here, we can 
<a class="indexterm" id="id91"/>see the trait and object, which implement the current trait. This way, when we need to accept commands that are not from standard input, but from the chatbot API or from Twitter, we only need to change the implementation of the 
<code class="literal">UserOutput</code>/
<code class="literal">ConsoleOutput</code> interfaces.
</p><p>It's now time to implement 
<code class="literal">ConsoleOutput</code> and 
<code class="literal">DefaultTimeProvider</code>.
</p><p>Replace 
<code class="literal">???</code> in main with the appropriative constructor.
</p><p>These steps for
<a class="indexterm" id="id92"/> implementing 
<code class="literal">ConsoleOutput</code> and 
<code class="literal">DefaultTimeProvider</code> are as follows:
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Ensure that <code class="literal">Lesson 2/3-project</code> is open in IDE.</li><li class="listitem">In the <a class="indexterm" id="id93"/><code class="literal">UserOutput</code> file, find the <code class="literal">ConsoleOutput</code> file and change <code class="literal">???</code> to the <a class="indexterm" id="id94"/>body of the <code class="literal">write</code> method. The resulting method should look like this:<div class="informalexample"><pre class="programlisting">object ConsoleOutput extends UserOutput{
def write(message: String): Unit = {
Console.print(message)
}
}
}</pre></div></li><li class="listitem">In the <code class="literal">TimeProvider</code> file, add the <code class="literal">DefaultTimeProvide</code> object which <a class="indexterm" id="id95"/>extends from <code class="literal">TimeProvider</code> and implements the <code class="literal">currentTime</code> and <code class="literal">currentDate</code> functions. The resulting code should look like this:<div class="informalexample"><pre class="programlisting">object DefaultTimeProvider extends TimeProvider {
override def currentTime(): LocalTime = LocalTime.now()

  override def currentDate(): LocalDate = LocalDate.now()
  }

 }</pre></div></li></ol></div></div><div class="section" title="Sealed Traits and Algebraic Datatypes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Sealed Traits and Algebraic Datatypes</h2></div></div></div><p>Let's deal 
<a class="indexterm" id="id96"/>with the second issue—let's encapsulate the logic of chatbot modes into the trait, which will only deal with logic and nothing else. Look at the following definition:
</p><div class="informalexample"><pre class="programlisting">trait ChatbotMode {
def process(message: String, effects: EffectsProvider): LineStepResult
def or(other: ChatbotMode): ChatbotMode = Or(this,other)
def otherwise(other: ChatbotMode): ChatbotMode = Otherwise(this,other)
}</pre></div><p>For now, let's ignore 
<code class="literal">or</code> and 
<code class="literal">otherwise</code> combinators and look at the 
<code class="literal">process</code> method. It accepts input messages and effects and returns the processing result, which can be a failure or message sent to a user with the next state of the mode:
</p><div class="informalexample"><pre class="programlisting">sealed trait LineStepResultcase class Processed(
  answer:String,
  nextMode: ChatbotMode,
 endOfDialog:Boolean) extends LineStepResult
case object Failed extends LineStepResult</pre></div><p>Here, we can see a new modifier: 
<code class="literal">sealed</code>.
</p><p>When a trait (or class) is sealed, it can only be extended in the same file, where it is defined. Due to this, you can be sure that, in your family of classes, nobody will be able to add a new class to somewhere in your project. If you do use case analysis with the help of the match/case expression, a compiler can do exhaustive checking: all of the variants are present.</p><p>Constructions from a family of case classes/objects, extended from a 
<code class="literal">sealed</code> trait, is often named an Algebraic Data Type (ADT).
</p><p>This term comes 
<a class="indexterm" id="id97"/>to us from the HOPE language (1972, Edinburg University), where all types can be created from an initial set of types with the help of algebraic operations: among them was a named 
<code class="literal">product</code> (which looks like a case class in Scala) and 
<code class="literal">distinct union</code> (modeled by the sealed trait with subtyping).
</p><p>Using ADT in domain modeling is rewarding because we can do evident case analysis for the domain model and have no weak abstraction; we can implement various designs which can be added to our model in the future.</p><p>Returning to our 
<code class="literal">ChatbotMode</code>.
</p><p>On 
<code class="literal">bye</code>, we must exit the program.
</p><p>This is easy—just define the appropriative object:</p><div class="informalexample"><pre class="programlisting">object Bye extends ChatbotMode {
 override def process(message: String, effects: EffectsProvider): LineStepResult =
  if (message=="bye") {
   Processed("bye",this,true)
  } else Failed
}</pre></div><p>Now, we'll look at creating the same modes for the 
<code class="literal">CurrentTime</code> query.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The code for this exercise can be found in 
<code class="literal">Lesson 2/3-project</code>.
</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file in the <code class="literal">CurrentTime</code> modes package.</li><li class="listitem">Add one<a class="indexterm" id="id98"/> to the chain of modes in <code class="literal">Main</code> (for example, the Modify definition of <code class="literal">createInitMode</code>).</li><li class="listitem">Make sure that <code class="literal">test</code>, which checks the time functionality, is passed.</li></ol></div><p>The next step is to make a bigger mode from a few simpler modes. Let's look at the mode, which extends two modes and can select a mode which is able to process incoming messages:</p><div class="informalexample"><pre class="programlisting">case class Or(frs: ChatbotMode, snd: ChatbotMode) extends ChatbotMode
{
override def process(message: String, effects: EffectsProvider): LineStepResult ={
frs.process(message, effects) match {
case Processed(answer,nextMode,endOfDialog) =&gt; Processed(answer, Or(nextMode,snd),endOfDialog)
case Failed =&gt; snd.process(message,effects) match {
case Processed(answer,nextMode,endOfDialog) =&gt; Processed(answer, Or(nextMode,frs),endOfDialog)
case Failed =&gt; Failed}}
 }}</pre></div><p>Here, if 
<code class="literal">frs</code> can process a message, then the result of processing this is returned. It will contain an answer. 
<code class="literal">NextMode</code> (which will accept the next sequence) is the same 
<code class="literal">or</code> with 
<code class="literal">nextMode</code> from 
<code class="literal">frs,</code> processing the result and 
<code class="literal">snd</code>.
</p><p>If 
<code class="literal">frs</code> can't answer this, then we try 
<code class="literal">snd</code>. If 
<code class="literal">snd's</code> processing is successful, then, in the next dialog step, the first message processor will be a 
<code class="literal">nextStep</code>, received from 
<code class="literal">snd</code>. This 
<a class="indexterm" id="id99"/>allows modes to form their own context of the dialog, like a person who understands your language. This will be the first thing you will ask next time.
</p><p>We can chain simple modes into complex ones with the help of such combinators. Scala allows us to use fancy syntax for chains: any method with one parameter can be used as a binary operator. So, if we define the 
<code class="literal">or</code> method in 
<code class="literal">ChatbotMode</code>, we will be able to combine our modes:
</p><div class="informalexample"><pre class="programlisting">def or(other: ChatbotMode): ChatbotMode = Or(this,other)</pre></div><p>And later in 
<code class="literal">main</code>, we can write this:
</p><div class="informalexample"><pre class="programlisting"> def createInitMode() = (Bye or CurrentDate or CurrentTime) otherwise InterestingIgnore</pre></div><p>
<code class="literal">Otherwise</code> looks very similar, with one difference: the second mode must always be second.
</p><p>When we write one, it looks like this.</p><div class="informalexample"><pre class="programlisting">def main(args: Array[String]): Unit = {
val name = StdIn.readLine("Hi! What is your name? ")
println(s" $name, tell me something interesting, say 'bye' to end the talk")
var mode = createInitMode()
var c = Processed("",mode,false)
while(!c.endOfDialog){
c = c.nextMode.process(effects.input.read(),effects) match {
case next@Processed(_,_,_) =&gt; next
case Failed =&gt; // impossible, but let be here as extra control.
      Processed("Sorry, can't understand you",c.nextMode,false)}
  effects.output.writeln(c.answer)}}</pre></div><p>We can 
<a class="indexterm" id="id100"/>make this a little better: let's move first the interaction (where the program asks the user for their name) to mode.
</p><p>Now, we'll move the frst interaction to mode.</p><p>Here, we will make 
<code class="literal">mode</code>, which remembers your name and can make one for you.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a new object, which implements the <code class="literal">chatbot</code> trait and when running the first words, <code class="literal">my name is</code>, accepts a name and answers <code class="literal">hi</code>, and then tells you your name:<div class="informalexample"><pre class="programlisting">case class Name(name:String) extends ChatbotMode {
override def process(message: String, effects: EffectsProvider): LineStepResult = {
message match {
case "my name" =&gt; if (name.isEmpty) {
effects.output.write("What is your name?")
val name = effects.input.read()
Processed("hi, $name", Name(name), false)
} else {
Processed(s"your name is $name",this,false)}case _ =&gt;  Failed
}
}
}
}</pre></div></li><li class="listitem">Add this object to the sequence of nodes in <code class="literal">main:</code><div class="informalexample"><pre class="programlisting">def createInitMode() = (Bye or CurrentDate or CurrentTime or Name("")) otherwise InterestingIgnore</pre></div></li><li class="listitem">Add a test<a class="indexterm" id="id101"/> with this functionality to testcase. Notice the usage of custom effects:<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>For full code, refer to 
<code class="literal">Code Snippets/Lesson 2.scala</code> file.
</p></div></div><div class="informalexample"><pre class="programlisting">test("step of my-name") {
  val mode = Chatbot3.createInitMode()
  val effects = new EffectsProvider {
    override val output: UserOutput = (message: String) =&gt; {}

    override def input: UserInput = () =&gt; "Joe"

    override def currentDate(): LocalDate = Chatbot3.effects.currentDate()

    override def currentTime(): LocalTime = Chatbot3.effects.currentTime()
  }
  val result1 = mode.process("my name",effects)
  assert(result1.isInstanceOf[Processed])
  val r1 = result1.asInstanceOf[Processed]
  assert(r1.answer == "Hi, Joe")
  val result2 = r1.nextMode.process("my name",effects)
  assert(result2.isInstanceOf[Processed])
  val r2 = result2.asInstanceOf[Processed]
  assert(r2.answer == "Your name is Joe")

}</pre></div></li></ol></div></div></div>
<div class="section" title="Function Calls"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Function Calls</h1></div></div></div><p>Now, we'll look at how function calls are implemented in Scala.</p><div class="section" title="Syntax Goodies"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Syntax Goodies</h2></div></div></div><p>Scala 
<a class="indexterm" id="id102"/>provides flexible syntax and it is worth dedicating a few minutes to this concept.
</p><div class="section" title="Named Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Named Parameters</h3></div></div></div><p>The following is 
<a class="indexterm" id="id103"/>a function, 
<code class="literal">f(a:Int, b:Int)</code>. We can call this 
<a class="indexterm" id="id104"/>function using the named parameter syntax: 
<code class="literal">f(a = 5, b=10)</code>. If we swap the parameters but leave the correct names, the method will still be correct.
</p><p>It is possible to combine positional and named function calls—the first few arguments can be positional.</p><p>For example:</p><div class="informalexample"><pre class="programlisting">def f(x:Int, y:Int) = x*2 + y
f(x=1,y=2) // 4
f(y=1,x=2) // 5</pre></div></div><div class="section" title="Default Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Default Parameters</h3></div></div></div><p>When specifying a function, we 
<a class="indexterm" id="id105"/>can set default
<a class="indexterm" id="id106"/> parameters. Then, later, when we call this function, we can omit parameters and the compiler will substitute defaults:
</p><div class="informalexample"><pre class="programlisting">def f(x:Int, y:Int=2) = x*2 + y
f(1) // 4</pre></div><p>It is possible to create a comfortable API with the help of the combination of named and default arguments. For
<a class="indexterm" id="id107"/> example, for case classes with N components, the compiler generates a copy method with N arguments; all of them have defaults:
</p><div class="informalexample"><pre class="programlisting">case class Person(firstName: String, lastName: String)
val p1 = Person("Jon","Bull")
val p2 = p1.copy(firstName = "Iyan")</pre></div><p>Now, let's transform code in the 
<code class="literal">Or</code> and 
<code class="literal">Otherwise</code> combinators to use the 
<code class="literal">copy</code> method instead of the 
<code class="literal">Processed</code> constructor.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change the case expression to type, checking <code class="literal">(processed:Processed)</code> or adding the <code class="literal">bind</code> variable to the case class pattern (<code class="literal">processed@Processed(… )</code>)</li><li class="listitem">In the case body, use the <code class="literal">copy</code> method instead of the <code class="literal">Processed</code> constructor:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The resulting code should be as per the following cases:</li><li class="listitem" style="list-style-type: disc">If the student uses type check in the case expression:<div class="informalexample"><pre class="programlisting">   case processed:Processed =&gt;processed.copy(nextMode = Or(processed.nextMode,snd))</pre></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the student uses bind variable:<div class="informalexample"><pre class="programlisting">  case processed@Processed(answer,nextMode,endOfDialog) =&gt;
     processed.copy(nextMode = Or(nextMode,snd))</pre></div></li></ul></div></li><li class="listitem"> Do the same transformation for the second match statement.</li></ol></div><p>The full code looks like this:</p><div class="informalexample"><pre class="programlisting">case class Or(frs: ChatbotMode, snd: ChatbotMode) extends ChatbotMode{
override def process(message: String, 
           effects: EffectsProvider): LineStepResult = {
   frs.process(message, effects) match {
   case processed@Processed(answer,nextMode,endOfDialog) =&gt;
   processed.copy(nextMode = Or(nextMode,snd))
   case Failed =&gt; snd.process(message,effects) match {
   case processed@Processed(answer,nextMode,endOfDialog) =&gt;
   processed.copy(nextMode=Or(nextMode,frs))
   case Failed =&gt; Failed
   }
   }
   }
   }
}</pre></div></div><div class="section" title="Currying Forms (Multiple Argument Lists)"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Currying Forms (Multiple Argument Lists)</h3></div></div></div><p>Currying is a term used for describing the
<a class="indexterm" id="id108"/> transformation of a function with multiple
<a class="indexterm" id="id109"/> arguments into a function
<a class="indexterm" id="id110"/> with one argument. We will describe this process in detail in the next chapter.
</p><p>It is vital for syntax 
<a class="indexterm" id="id111"/>that we can use multiple argument lists:
</p><div class="informalexample"><pre class="programlisting">def f1(x:Int,y:Int) = x + y 
def f2(x:Int)(y:Int) = x + y</pre></div><p>Here, 
<code class="literal">f2</code> is in its curried form. It has the same semantics as 
<code class="literal">f1</code>, but can be called with a  different syntax. This is useful when you need visually separate arguments.
</p></div><div class="section" title="Special Magic Methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Special Magic Methods</h3></div></div></div><p>The following
<a class="indexterm" id="id112"/> table shows the various
<a class="indexterm" id="id113"/> magic methods:
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>x.apply(y,z)</p>
</td><td style="text-align: left" valign="top">
<p>x(y,z)</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>x.update(y,z)</p>
</td><td style="text-align: left" valign="top">
<p>x(y)=z</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>x.y_=(z)</p>
</td><td style="text-align: left" valign="top">
<p>x.y=z</p>
</td><td style="text-align: left" valign="top">
<p>Method y must be also defined.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>x.unary-</p>
</td><td style="text-align: left" valign="top">
<p>-x</p>
</td><td style="text-align: left" valign="top">
<p>The same for +, ~, !</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>x = x + y</p>
</td><td style="text-align: left" valign="top">
<p>x += y</p>
</td><td style="text-align: left" valign="top">
<p>The same for -,*,/,|,&amp;</p>
</td></tr></tbody></table></div></div></div><div class="section" title="Implementing + in CartesianPoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Implementing + in CartesianPoint</h2></div></div></div><p>Open the previous project from 
<code class="literal">Lesson2</code> and implement 
<code class="literal">+</code> in 
<code class="literal">CartesianPoint</code>. 
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your IDE, open the previous project (4-project, named <code class="literal">coordinates</code>). </li><li class="listitem">In the <code class="literal">CartesianPoint.scala</code> file, add the <code class="literal">+</code> method with the following definition:<div class="informalexample"><pre class="programlisting"> def +(v:CartesianPoint) = CartesianPoint(x+v.x,y+v.y)</pre></div></li></ol></div></div><div class="section" title="Parameter-Passing Mode"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Parameter-Passing Mode</h2></div></div></div><p>In this 
<a class="indexterm" id="id114"/>section, we will learn the types of parameters which are in passing mode: 
<code class="literal">by value</code>, 
<code class="literal">by name,</code> and 
<code class="literal">by need</code>.
</p></div><div class="section" title="By Value"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>By Value</h2></div></div></div><p>In previous 
<a class="indexterm" id="id115"/>chapters, we used default the 
<a class="indexterm" id="id116"/>parameters of passing mode: 
<code class="literal">by value</code>, which is the default in most programming languages.
</p><p>In this model, the function call expression is evaluated in the following manner:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, all arguments are evaluated from left to right</li><li class="listitem" style="list-style-type: disc">Then, the function is called, and parameters are referred to as evaluated arguments:<div class="informalexample"><pre class="programlisting">def f(x:Int) = x + x + 1
f({ println("A "); 10 }) // A res: 21</pre></div></li><li class="listitem" style="list-style-type: disc">Sometimes, we hear about Java parameter mode, where values are passed <code class="literal">by value</code>, and references are <code class="literal">by reference </code>(for example, if we pass <code class="literal">reference</code> to an object as a <code class="literal">value</code>)</li></ul></div></div><div class="section" title="By Name"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>By Name</h2></div></div></div><p>The
<a class="indexterm" id="id117"/> essence of the 
<code class="literal">by name</code> parameter passing
<a class="indexterm" id="id118"/> mode is that arguments are not evaluated before the function call, but every time the name of the parameter is used in the target function:
</p><div class="informalexample"><pre class="programlisting">def f(x: =&gt;Int) = x + x + 1
f({ println("A "); 10 }) // A A res: 21</pre></div><p>The name term comes to us from Algol68: passing parameters by name was described as a
<a class="indexterm" id="id119"/> substitution of name by the parameter body. This was a challenge for compiler writers for many years.
</p><p>By name 
<a class="indexterm" id="id120"/>parameters can be used for defining control-flow expressions:
</p><div class="informalexample"><pre class="programlisting">def until(condition: =&gt;Boolean)(body: =&gt;Unit) ={
while(!condition) body
}</pre></div><p>Note that constructor parameters can also be passed by name:</p><div class="informalexample"><pre class="programlisting">class RunLater(x: =&gt;Unit){
def run(): Unit = x
}
}</pre></div></div><div class="section" title="By Need"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>By Need</h2></div></div></div><p>
<code class="literal">By </code>
<a class="indexterm" id="id121"/>
<code class="literal">need</code> evaluates
<a class="indexterm" id="id122"/> the parameter once, only if it is necessary. This can be emulated with the by name call and lazy val:
</p><div class="informalexample"><pre class="programlisting">def f(x: =&gt;Int): Int = {lazy val nx = xnx + nx + 1
}
f({ println("A "); 10 }) // A res: 21</pre></div><p>We see the 
<a class="indexterm" id="id123"/>lazy modifier for val. A lazy value is evaluated at the time of the first usage and then stored in memory as a value.
</p><p>Lazy values can be 
<a class="indexterm" id="id124"/>components of traits, classes, and objects: this is this usual way to define lazy initialization.
</p></div><div class="section" title="Creating a Runnable Construction"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Creating a Runnable Construction</h2></div></div></div><p>Let's create a
<a class="indexterm" id="id125"/> runnable construction, with the same syntax as 
<code class="literal">Scalatest FunSuite</code>, and 
<code class="literal">executor</code>, which will return 
<code class="literal">true</code>, if the code inside the 
<code class="literal">test</code> argument was evaluated without exceptions.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the parent class with variables where the code will be captured. One possible example is as follows:<div class="informalexample"><pre class="programlisting">class DSLExample {val name: String = "undefined"var code: ()=&gt;Unit = { () =&gt; () }
}</pre></div></li><li class="listitem">Define <a class="indexterm" id="id126"/>the function with the name and by-name parameter, which will fill this variable:<div class="informalexample"><pre class="programlisting">def test(testName:String)(testCode: =&gt;Unit):Unit = {
name = testName
 code = () =&gt; testCode }</pre></div></li><li class="listitem">Define <code class="literal">executor</code> method, which uses named parameter inside try/catch block.<div class="informalexample"><pre class="programlisting">
def run(): Boolean = {
try {
 code()
 true} catch {
case ex: Exception =&gt; 
ex.printStackTrace()
false
	}
}
</pre></div></li></ol></div></div><div class="section" title="Printing the log Argument to the Console and File"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Printing the log Argument to the Console and File</h2></div></div></div><p>Let's create
<a class="indexterm" id="id127"/> a 
<code class="literal">log</code> statement, which prints arguments to the console and to file, but only if the parameter with the name enabled in the logger constructor is set to true.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the <code class="literal">logger</code> with the parameter and class. The signature must be something like this:<div class="informalexample"><pre class="programlisting">class Logger(outputStream:PrintStream, dupToConsole: Boolean, enabled: Boolean) {
 
     …. Inset method here
    
}</pre></div></li><li class="listitem">Define the method with the by-need parameter, which is only used when the logger is enabled:<div class="informalexample"><pre class="programlisting">def log(message: =&gt; String): Unit = {
if (enabled) {
	val evaluatedMessage = message
	if (dupToConsole) {
Console.println(evaluatedMessage)
}
outputStream.println(evaluatedMessage)
	}
}
</pre></div></li></ol></div><p>Let's make
<a class="indexterm" id="id128"/>
<code class="literal">mode</code> command, which understands the 
<code class="literal">store name </code>definition and 
<code class="literal">remind</code> definition.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a new object which implements the <code class="literal">ChatbotMode</code> trait and has a data structure (a sealed trait which forms a linked list) as a state.</li><li class="listitem">On the processing <code class="literal">store,</code> modify the state and answer <code class="literal">ok.</code> On processing, <code class="literal">remind</code> – answer.</li><li class="listitem">Add test to <code class="literal">testcase.</code></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>We have now reached the end of this chapter. In this chapter, we covered the object-oriented aspects of Scala such as classes, objects, pattern matching, self-types, case classes, and so on. We also implemented object-oriented concepts that we learned in our chatbot application.</p><p>In the next chapter, we will cover functional programming with Scala and how object-oriented and functional approaches complete each other. We will also cover generic classes, which are often used with pattern matching. We will also cover how to create user-defined pattern matching and why is it useful.</p></div></body></html>