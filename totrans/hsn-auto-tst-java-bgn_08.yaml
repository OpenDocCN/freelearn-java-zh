- en: Importance of the super and this Keywords and Exceptions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at two keywords: `super` and `this`. We
    will pick examples and explain how they are put to use in various situations while
    writing our Java code. We will also take a look at exceptions and how we can use
    them to handle situations where the code fails due to some error. We''ll wrap
    up the chapter with a section on the `finally` block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The super keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical usage of the super keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of the this keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different kinds of exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The try...catch mechanism to handle exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of the finally block in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The super keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, when people inherit properties from a different class, there might
    be a redundancy if the same variable names are used in both the parent and child
    class. To differentiate between parent variables and child variables, we use the
    `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain this using an example. Let's create two classes and name them
    `childDemo` and `parentDemo`. In the `parentDemo` class, we define a string called
    `name` and assign the `'rahul'` string to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `childDemo` class, we inherit the properties of `parentDemo`. We
    know how to inherit the properties of a parent class using the `extends` keyword,
    which we learned in [Chapter 5](68ddb76d-14d4-4e50-a93d-adef97af0b23.xhtml), *Everything
    You Need to Know About Interfaces and Inheritance*. The code to inherit the properties
    is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `childDemo` is taking the properties of `parentDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a string in the `childDemo` class, call it `name`, and assign the `QAClickAcademy`
    string to it. We then define a method called `public void getStringdata()` inside
    the `childDemo` class and give a statement to print the value of `name` as the
    output. We define another method, called `public static void main(String[] args)`,
    outside `getStringdata()` and create an object for the child class, `childDemo
    cd = new childDemo();`. Once the object is created, we add another line of code
    below it: `cd.getStringdata();`. This calls the `getrStringdata()` method, so
    obviously the name is printed as the output, which is `QAClickAcademy`. Even though
    we are inheriting the properties of the `parentDemo` class, which also contains
    a string with the same name, the print statement calls the value of string in
    `childDemo`. This is because Java gives preference to the local variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever there is a collision between the variable names of the parent and
    the child, it gives preference to the local variable, in this case the `childDemo`
    class. What if we are working on a project where we need to print the string name
    in the `parentDemo` class as well? For this, we use the `super` keyword to refer
    to the `parentDemo` class, from which we inherit the properties to the `childDemo`
    class. So, if we want to call the name variable from the `parentDemo` class, we
    add a print statement and add a `super` keyword before the variable we want to
    print—this will get the value from `parentDemo`. When we run the code now, we
    get both the parent object and the child object as an output as we have left a
    print statement for the name string in both classes. The code for the `parentDemo`
    class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the `childDemo` class is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The final output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Practical usage of the super keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the different ways to use the `super`
    keyword in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Using the super keyword for methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to handle the parent variable with the help of the `super` keyword.
    In this section, we will see how to handle two methods if their names are the
    same in the `parentDemo` and `childDemo` classes. We'll use the previous example
    in this section too.
  prefs: []
  type: TYPE_NORMAL
- en: In the `parentDemo` class, add a method called `getData()`, and inside the method
    give a print statement to display the `"I am in parent class"` message. If we
    want to execute the `getData()` method in the `childDemo` class, we write `cd.getData()`
    in the `main` method of the `childDemo` class. We can access `getData()` as we
    are inheriting the properties of the `parentDemo` class. If we run the `childDemo`
    class, we will receive the previous example's output as well as the new sentence
    we added in the `parentDemo` class, `I am in parent class`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `childDemo` class, we will define another method with the same name as
    that of the `parentDemo` class and add a print statement to display the `I am
    in child class` message. If we run the `childDemo` class, we will get the previous
    example's output and then `I am in child class` is displayed. This is because
    preference is given to the local class, so the `getData()` method in the `childDemo`
    class overrides the `getData()` method in the `parentDemo` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to use the `getData()` method of the `parentDemo` class in the
    `childDemo` class. To do this, we simply do what we did for variables: add `super.getData()`
    inside the `getData()` method of the `childDemo` class. When we run the `childDemo()`
    class, we get the previous example''s output followed by `I am in parent class`
    and then `I am in child class`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the super keyword for constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use the `super` keyword for constructors in this section. We'll use the
    previous example here too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `parentDemo` class, we define a constructor, `parentDemo()`, and add
    a print statement to print: `Parent class constructor`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `childDemo`, we define a constructor `childDemo()` and add a print statement
    to print: `Child class constructor`. If we want to use the `parentDemo` class
    constructor in the `childDemo` class, we add the `super()` method in the `childDemo()`
    constructor. This makes the controller invoke the constructor in the `parentDemo`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important rule we need to follow when working with constructors:
    whenever you use a `super` constructor in a child constructor, it should always
    be the first line in it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the `childDemo` class, the controller first executes the `super()`
    method. It goes to the `parentDemo()` constructor and executes it and then `childDemo()`.
    So the final output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Importance of the this keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one more keyword in Java that is just like the `super` keyword: `this`.
    In this section, we will take a look at the `this` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the `this` keyword with an example. Create a class named `thisDemo`
    and declare a variable, `a`, and assign the value `2` to it. We define a `getData()`
    method in its class, declare the `a` variable inside it, and assign the value
    `3` to it. We also add a print statement in it. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the value of `a` is `2` in the entire class, but in one specific
    method, `getData()`, we want the value of the variable to be `3`. In this code,
    we want to call both values of `a`, that is, `2` and `3`. We create an object
    in the main method and add the `td` object in it. The code for the `td` object
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we run the code, the output we get is `3`. But we want to print the value
    of `a` as `2` in the same block too. This is when the `this` keyword comes into
    play. The scope of the class object will be at the class level and not the method
    level. So we say that the `getData()` method refers to the current object and
    the object scope lies in the class level. So `a= 2` is valid for the entire class,
    and `a=3` is valid just for the `getData()` method. This is why we call the `a`
    variable in the `getData()` method, a local variable, and and the `a` variable
    in the class, a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the global variable of the example that we are working on, we need
    to add a print statement in the `getData()` method and we add `this.a` in the
    print statement. The print statement will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This wraps up our example on the this variable. Now let's learn about exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Different kinds of exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how we can handle exceptions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if there is an error in the code, we need to catch it and print
    a message without failing; this can be done using the `try...catch` mechanism.
    So in general, when we try to write code and we suspect that there might be an
    error in it, we will use that error for exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explain it with the help of an exercise. Let's create a new class, `exceptionDemo`,
    and inside the `main` block we declare the `a`, `b`, and `c` variables and assign
    values of `4`, `7`, and `0`, respectively, to them. We add a `try` block inside
    the main block and we declare an integer variable, `k`, which is equal to `b`
    divided by `c`. Whenever we add anything in the `try` block, we are trying to
    see whether the code works. If it fails, the controller will come out of this
    `try` block and enter into the `catch` block that contains the exception. An important
    point to remember is that the `catch` block comes right after the `try` block.
    Inside the `catch` block, we write a print message to display `I caught the error/exception`.
  prefs: []
  type: TYPE_NORMAL
- en: When the controller goes into the `k` variable line, the script fails because
    `7/0` is infinity, which is an arithmetic exception but the script will not fail
    immediately. If we don't write the `try...catch` block, we see a different kind
    of error.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take out the `try...catch` block, run the code, and see the error we get.
    We see an error in the output section, `Java.lang.ArithmeticException`; this is
    because we cannot divide `7` by `0`, so the script fails abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we initially feel that we will get an error in our code, we can simply make
    a script to pass and catch the error by putting a proper debug message that can
    be handled with the help of the `try...catch` mechanism. Now, let''s add the `try...catch`
    blocks again and debug the entire code. The output will be `I caught the error/exception`;
    this is because `7` divided by `0` is infinity so here the script should fail,
    but we did not see any error in the output section saying the code has failed.
    This is because the controller simply moves to the `catch` block and executes
    it. The final code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The try...catch mechanism to handle exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use one `try` followed by multiple `catch` blocks.
    There are different types of exceptions in Java, and for each exception we can
    add separate `catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain this using the previous example. The exception written for the
    previous code is a general exception, so for any error in the `try` block, the
    general exception is executed. Now let''s try and catch a specific exception.
    We can add a `catch` block under the `try` block, and add a specific exception
    and a print statement to print, `I caught the Arithmeticerror/exception`. The
    code for the specific catch block is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We see that, when we ran the code, the controller went to the `catch` block,
    because the `catch` block is specifically written for an arithmetic exception,
    and the error thrown also belongs to arithmetic errors. So once the controller
    receives an error, the `try` block will see which kind of `catch` block is related
    to it and run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other exceptions in Java: we can just Google and take a look
    at them.'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of the finally block in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one more block that is just like the `try...catch` block: is the `finally`
    block. The `finally` block will be executed irrespective of whether an exception
    is thrown. This block is executed if the program runs successfully, and even executed
    if the program doesn''t run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll explain this using the example we used in the *The try...catch mechanism
    to handle exceptions* section. We just add a `finally` block after the `catch`
    blocks and we give a print statement in it saying, `delete cookies`. The code
    block will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One important point is that `finally` can work with or without the `catch` block;
    all it needs is to be written below a `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at the `super` and `this` keywords. We also
    looked at examples to explain where we can use these keywords to overcome certain
    obstacles. We learned about exceptions, and implemented them in various instances
    where the code failed due to an error. We also learned about the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deep into the collections framework, which
    consists of interfaces and classes. We will also take a look at the three major
    collections: `List`, `Set` and `Map`.
  prefs: []
  type: TYPE_NORMAL
