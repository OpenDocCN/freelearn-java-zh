- en: Chapter 7. Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any integrated system, there are numerous reasons for errors to happen. Many
    are unforeseen, not easy to predict, and not easy to simulate. As an integrated
    framework, Camel provides extensive support for error handling, which is very
    flexible and able to deal with very different kinds of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The kind of errors that we can deal with using Camel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different Camel error handlers available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration of the error handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can distinguish two main types of errors—recoverable and irrecoverable. Let's
    have a look at these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Recoverable errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recoverable error is a temporary error. It means that this error might be
    recovered *automatically* after a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: An example would be a network connection that is temporarily down, resulting
    in `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the exceptions are represented as recoverable errors in Camel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, Camel stores the exceptions (the recoverable errors) in the exchange
    using the `setException` (throwable cause) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we will see later, an exchange containing an exception will be caught by
    an error handler, which will react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Irrecoverable errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An irrecoverable error is an error that remains an error no matter how many
    times you try to perform the same action.
  prefs: []
  type: TYPE_NORMAL
- en: An example would be trying to access a nonexistent table in a database, or accessing
    a JMS queue that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'An irrecoverable error is represented as a message with its `setFault` flag
    set to `true`. The fault message is the normal message body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Programmers can set a fault message so Camel can react accordingly and stop
    routing the message.
  prefs: []
  type: TYPE_NORMAL
- en: The question could be, in which case do we use an exception in the exchange
    and in which case do we use the fault flag on the message?
  prefs: []
  type: TYPE_NORMAL
- en: The first reason for the presence of the fault flag is that the Camel API was
    designed around JBI, which includes a `Fault` message concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is that we might want to handle some errors in a different
    way. For instance, using exceptions in an exchange will use an `ErrorHandler`,
    meaning that for an `InOut` exchange the next endpoint of the route won't ever
    get an `out` message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the fault flag allows you to handle this kind of error in a specific way.
    For instance, with a CXF endpoint, it could make sense to create and return a
    SOAP fault. However, we will see that all kinds of errors can be handled by the
    Camel error handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Camel error handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw, Camel stores the exceptions in the exchange using the `setException(Throwable
    cause)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides ready-to-use error handlers, depending of the mechanism that
    you have to implement. These error handlers will only react to the exceptions
    set in the exchange. By default, the error handlers won't react if an irrecoverable
    error has been set as the fault message. We will see, further in the chapter,
    that Camel provides an option to handle irrecoverable errors.
  prefs: []
  type: TYPE_NORMAL
- en: In order to react, the error handler *lives* on the route channels. Actually,
    an error handler is an interceptor (on the channel), that analyzes the exchange,
    and verifies that the exception attribute of the exchange is not null.
  prefs: []
  type: TYPE_NORMAL
- en: If the exception is not null, the error handler *reacts*. This means that the
    error handler will *catch* any uncaught exception thrown during the routing or
    processing of messages within Camel.
  prefs: []
  type: TYPE_NORMAL
- en: Camel provides different kinds of error handlers, depending on your need.
  prefs: []
  type: TYPE_NORMAL
- en: Non-transacted error handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The non-transacted error handlers are mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: DefaultErrorHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DefaultErrorHandler` is the default error handler. It doesn't support dead
    letter queues it propagates back to the caller. The exchange ends immediately.
  prefs: []
  type: TYPE_NORMAL
- en: It's very similar to the dead letter error handler, but the payload is lost
    (whereas the DLQ keeps the payload for processing).
  prefs: []
  type: TYPE_NORMAL
- en: This means that it supports redelivery policies. As we will see later, we can
    configure the error handler with some options.
  prefs: []
  type: TYPE_NORMAL
- en: This error handler covers most use cases. It catches exceptions in the processors
    and propagates them back to the previous channel, where the error handler can
    catch it. This gives Camel the chance to react accordingly, for instance, to reroute
    the message to a different route path, try a redelivery, or give up and propagate
    the exception back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you don't explicitly specify an error handler, Camel will implicitly
    create a `DefaultErrorHandler`, without redelivery, no handle (see error handlers
    features for details about handle), and no dead letter queue (as it's not supported
    by the `DefaultErrorHandler`).
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the `DefaultErrorHandler`, we create a simple Camel route that
    will expose a HTTP service (using Jetty).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the following Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The route is pretty simple. It exposes an HTTP service using the Camel Jetty
    component and validates the submitted message using a bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'We write this route using the Blueprint DSL. We add the following `src/main/resources/OSGI-INF/blueprint/route.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `checker bean` is pretty simple. It takes the message received on the Jetty
    endpoint and checks whether it's valid. The message is an HTTP parameter `key=value`.
    If the parameter has the format message=... it's valid, or else we throw an `IllegalArgumentException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `checker` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build our bundle using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now start our Apache Karaf container and install the `camel-blueprint` and
    `camel-jetty` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can submit a valid message using curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we submit an invalid message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file (`data/karaf.log`), we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So we can see that the `DefaultErrorHandler` reacted for the `IllegalArgumentException`.
    The delivery failed and has been logged. By default (as handled is false), the
    exception is thrown back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: DeadLetterChannel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DeadLetterChannel` error handler implements the Dead Letter Channel EIP.
    It supports the redelivery policy, and the redelivery sends the message to a dead
    letter endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Even then, the dead letter endpoint, the `DeadLetterChannel` behaves like the
    `DefaultErrorHandler`. To illustrate this, we update our previous example to use
    a `DeadLetterChannel` that calls an error route when an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: So the `DeadLetterChannel` error handler will catch the exception, try to redeliver,
    and if it still fails the message will be sent to a dedicated route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `checker` bean is exactly the same as before. The route definition (using
    the Blueprint DSL) is different as we define the `DeadLetterChannel` error handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we use the `myDeadLetterErrorHandler` in the `main` route. The
    `myDeadLetterErrorHandler` is constructed using the `DeadLetterChannelBuilder`
    builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following attributes are set:'
  prefs: []
  type: TYPE_NORMAL
- en: The `deadLetterUri` containing the endpoint is set where we send the message
    if the delivery fails. Here, we define the endpoint `direct:error` to call the
    corresponding route.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `redeliveryPolicy` is set to define the way we try to redeliver the message.
    The `myRedeliveryPolicy` defines the number of attempts (3 in the example), and
    the delay between each attempt (5 seconds here). It means that after 3 attempts
    (so, a maximum of 15 seconds), if the message still fails it will be sent to the
    endpoint defined in the dead letter URI (so `direct:error`, in our case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `error` route just logs the failed message. It means that the `main` route
    won't fail, it will just return the `in` message to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We build our new bundle using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our Apache Karaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously done, we install the `camel-blueprint` and `camel-jetty` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can deploy our bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we send a valid message using curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It works as before, nothing has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we send an invalid message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can note that curl is waiting for a response; it''s normal as we defined
    a redelivery policy in our dead letter error handler. Finally, we receive the
    original in message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look in the Karaf `log` file, we can see the following code corresponding
    to the `error` route execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: LoggingErrorHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `LoggingErrorHandler` logs the failed message along with the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Camel will, by default, log the failed message and the exception using the
    log name `LoggingErrorHandler` at `ERROR` level. To illustrate the behavior of
    the `LoggingErrorHandler`, we update the previous route `blueprint` XML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We define a `LoggingErrorHandler` in the `main` route. This error handler will
    just intercept and log the exception in the `packt` logger, with `ERROR` as the
    log level. The exchange ends, and the exception is sent back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'After deploying our bundle in Apache Karaf, and submitting an invalid message,
    we can see that the client (curl) gets the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception is logged in the Karaf `log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: NoErrorHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NoErrorHandler` completely disables error handling; this means that any
    exception is not intercepted and is just returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we update the Blueprint XML of our sample like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we submit an invalid message, the exchange doesn't end, we don't have anything
    in the log, and the exception is just returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: TransactedErrorHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TransactedErrorHandler` is used when a route is *flagged* with transacted.
  prefs: []
  type: TYPE_NORMAL
- en: It's basically the same as the `DefaultErrorHandler` (it's actually inherited
    from the `DefaultErrorHandler`). The difference is that the `TransactedErrorHandler`
    will look for a transaction manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the following mechanism to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: If one (and only one) bean in the registry has the `org.apache.camel.spi.TransactedPolicy`
    type, it uses it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a bean in the registry has the `ID PROPAGATION_REQUIRED` and the `org.apache.camel.spi.TransactedPolicy`
    type, it uses it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one (and only one) bean in the registry has `org.springframework.transaction.PlatformTransactionManager`,
    it uses it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also *force* the transaction manager that you want to use, as the transacted
    notation accepts a bean ID.
  prefs: []
  type: TYPE_NORMAL
- en: Error handlers scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An error handler can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: At the Camel Context level (Camel Context scope), which means that all routes
    in this Camel Context will use this error handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the route level (route scope), possibly overwritten the error handler defined
    using the Camel Context scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the scope, it's possible to define a default error handler (Camel
    Context scope), and, possibly define an error handler specific to one particular
    route.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the following Blueprint XML contains two routes with two different
    error handlers—one with the Camel Context scope and another with `route` scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Error handler features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basically, all error handlers extend the `DefaultErrorHandler`. The `DefaultErrorHandler`
    provides a set of interesting features allowing you to use very fine-grained management
    of the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Redelivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DefaultErrorHandler` (and so the `DeadLetterErrorHandler` and `TransactedErrorHandler`)
    supports a redelivery mechanism that you can configure via a redelivery policy.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the following Blueprint XML creates a Camel route that systematically
    throws an `IllegalArgumentException` (with `Booooommmmm` message). As we don't
    explicitly define an error handler, the route uses the `DefaultErrorHandler`.
    We just configure the redelivery policy of the `DefaultErrorHandler`, trying to
    redeliver the message three times, waiting two seconds between each attempt. If
    it still fails at the fourth attempt, the exchange ends and the exception is sent
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our Apache Karaf container and install the `camel-blueprint` and `camel-jetty`
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We just drop our `route.xml` in the Karaf `deploy` folder, and we call the
    service using curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After some time, we can see the exception (`IllegalArgumentException` with
    `Booooommmmm` message) returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the redelivery policy has been used and the exchange fails at
    the fourth attempt (which is exhausted after delivery attempt number four).
  prefs: []
  type: TYPE_NORMAL
- en: Exception policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DefaultErrorHandler` (and so `DeadLetterChannel` and `TransactedErrorHandler`)
    supports the exception policy. The exception policies are used to intercept and
    handle specific exceptions in particular ways.
  prefs: []
  type: TYPE_NORMAL
- en: The exception policies are specified with the `onException` syntax. Camel will
    traverse the exception hierarchy from the bottom up to the root searching for
    an `onException` that matches the actual exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `onException` with error handler defined at `CamelContext` scope
    or route scope. For instance, in the following `route.xml`, we have two different
    routes:'
  prefs: []
  type: TYPE_NORMAL
- en: The first route throws an `IllegalArgumentException` (`Boooommmm`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second route throws an `IllegalStateException` (`Kabooommmm`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want to react differently for the two exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `IllegalArgumentException`, we want to define a specific redelivery
    policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `IllegalStateException`, we want to redirect the message to a specific
    endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For both exceptions, the exchange ends and the exception is sent back to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the Apache Karaf container and install the `camel-blueprint` and `camel-jetty`
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We drop the `route.xml` in the Karaf `deploy` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you access the HTTP endpoint corresponding to the first route, the
    `IllegalArgumentException` is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access the HTTP endpoint corresponding to the second route, the `IllegalStateException`
    is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Karaf `log` file, we can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `onException` used there, redirecting the exchange to the `error`
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Handling and ignoring exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When handling an exception, Camel breaks out of route execution.
  prefs: []
  type: TYPE_NORMAL
- en: With a `handled` flag the exception is not sent back to the caller, and you
    can define an `error` message.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, with the following `route.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The handled flag on the `onException` prevents to send back the exception to
    the caller. In that case, we define an error message using a constant string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start Apache Karaf and install the `camel-blueprint` and `camel-jetty` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We drop the `route.xml` in the Karaf `deploy` folder. If we access the HTTP
    endpoint, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, it''s possible to completely ignore an exception using the
    `continued` flag. For instance, with the following `route.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We ignore the `IllegalArgumentException` thrown by the route. It means that
    if we access the HTTP endpoint with curl, we just have a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `IllegalArgumentException` has been ignored, thanks to the
    `continued` flag.
  prefs: []
  type: TYPE_NORMAL
- en: A failover solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DefaultErrorHandler` (and so the `DeadLetterChannel` and `TransactedErrorHandler`)
    supports routing of the failed exchange to a specific endpoint. Thanks to this
    mechanism we can implement a kind of failover solution, or route that could undo
    previous changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `route.xml` implements such a failover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We try to upload local files to an FTP server. If in the FTP server, an `IOException`
    is thrown, we react to the `IOException` (meaning that something is wrong with
    the FTP server), trying to redeliver three times on the same FTP server. Finally,
    we redirect to a fallback (another) FTP server.
  prefs: []
  type: TYPE_NORMAL
- en: onWhen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If `onException` allows you to filter the exceptions and react depending on
    the exception, it''s also possible to add another condition to react to one particular
    exception. It''s what you can do with the `onWhen` syntax, accepting a predicate.
    You have an even more fine-grained way to filter exceptions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: onRedeliver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `onRedeliver` syntax allows you to execute some code before the message
    is redelivered. For instance, you can call a processor for redelivery, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: retryWhile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of defining a static number of redeliveries, you can use the `retryWhile`
    syntax. It allows you, at runtime, to determine whether or not to continue redelivery
    or to give up.
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to have fine-grained redelivery control.
  prefs: []
  type: TYPE_NORMAL
- en: Try, Catch, and Finally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have used error handlers (most of the time the `DefaultErrorHandler`),
    which applies to all channels in the routes. You might want to *square* the exception
    handling to some part of a route.
  prefs: []
  type: TYPE_NORMAL
- en: It's similar to the `try/catch/finally` Java statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Camel error handling is disabled. When using `doTry` .. `doCatch` .. `doFinally`,
    the regular Camel error handler does not apply. This means any `onException` or
    the likes does not trigger. The reason is that `doTry` .. `doCatch` .. `doFinally`
    is in fact its own error handler and it aims to mimic and work like `try/catch/finally`
    works in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, error handling is hard. That's why Camel provides a large
    panel of features around error handling. Even if you can use the `doTry/doCatch/doFinally`
    syntax, most of the time it's better to separate the routing logic from the error
    handling itself.
  prefs: []
  type: TYPE_NORMAL
- en: When possible, good practice is to try to recover. It's always a good idea to
    use strategies for recovery. It's strongly recommended to build unit tests to
    simulate errors. It's what we will see in the next chapter—testing with Camel.
  prefs: []
  type: TYPE_NORMAL
