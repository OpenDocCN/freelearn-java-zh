- en: Content Marshalling with JSON-B and JSON-P
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the data structures and payloads of web services.
    You will learn how to properly use content types and content negotiation for your
    web services, how to use the new JSON-B APIs for easy data binding, how JSON-P
    API can be used for very flexible JSON processing, and how it can be used to implement
    hypermedia-driven REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to content types and content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy data binding using JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible JSON processing with JSON-P
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing hypermedia-driven REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to content types and content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at using the `@Produces` and `@Consumes`
    annotations to specify the content types. We'll also learn about API versioning
    using custom content types, smart content negotiation using a quality from server
    factor, and how you can serve and upload binary content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to code and open our IDE. Let''s take a look at the small REST
    service that we have prepared. As you already know, you can specify the `@Produces`
    or `@Consumes` annotations to specify what your REST service will consume as a
    content type and what content type your REST service will produce. What we do
    here is we specify `application/json`. This is what we usually do. We implement
    this method and return a simple `Map` with the status code `ok`. Using JAX-RS,
    we''ll make sure that this `Map` is serialized to proper JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to implement a second version of this? We can do that by implementing
    the method called `v2` and returning something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this here will not work correctly because we have two methods producing
    the same content type. What we can do is specify a custom `MediaType`. We will
    specify `MediaType v1` and `MediaType v2` of type `"application"`, and we will
    use the custom subtype. We have one subtype for version one and the JSON format
    (`"vnd.version.v1+json"`), and another one for version two and the JSON format
    (`"vnd.version.v2+json"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use those custom content types with `v1` and `v2`. Since this is done,
    we have an API version for `v1` and `v2` using content types. This is the way
    it should be if we use an API version. `v1` supports application JSON and also
    supports the content type `v1` in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'How does the client specify or know which content type it accepts? Well, basically,
    they can specify the accept header for this specific content type. If they don''t,
    we specify a factor which is called **quality from server**, that is, `qs`, `qs=0.75`,
    and `qs=1`. If the client does not specify the content type, `"application/vnd.version.v1+json"`will
    always win because it has the higher factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at using binary content. We will prepare two methods: serving a
    JPEG image and a GIF image. All we have to do is just open a file and send the
    file back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can also do is implement and upload a mechanism by using the HTTP `POST`
    method. We will consume `MULTIPART_FORM_DATA`. While you are referencing the form
    with a parameter called `"file"`, which is an input stream, to get the filename,
    you can also reference `@FormDataParam` and use `FormDataContentDisposition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open our REST API. We do not specify anything; we just send the
    version and receive `"v1"`, which is the default setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/943b3a68-6d03-4209-9bc7-442939d63f38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also get `"v1"` because I''ve explicitly set the Accept header here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43954a70-c83e-43a0-9acc-625bd44b994a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To obtain `"v2"`, we must specify the Accept header with the `application/vnd.version.v2+json`
    content type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a81c7b2-780c-49b8-8238-a68de3bdc4bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can see that the serving of GIF images and JPEGs is also working.
    We can request a GIF image and, as you can see here, we have the magic of content
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a110088b-3ced-48aa-b651-0cf592b195d2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will talk about easy data binding using JSON-B.
  prefs: []
  type: TYPE_NORMAL
- en: Easy data binding using JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at using JSON-B for marshalling
    and unmarshalling of your JSON and POJO data structures, how you can use JSON-B
    annotations on POJOs such as `@JsonbProperty`, `@JsonbNumberFormat`, `@JsonbDateFormat`,
    `@JsonbTransient`, and `@JsonbPropertyOrder`, and finally how you can explicitly
    create `JsonbConfig` and `Jsonb` instances using `JsonbBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and switch to code. We will create a `JsonResource` class.
    This is our basic REST resource and we want to implement our basic methods that
    return JSON structures from a POJO and that unmarshall our POJO from JSON structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first bit is easy; first up, we''re implementing a basic `@GET` method.
    We call it `marshall` and it returns a `JsonbPojo`. `JsonbPojo` is a plane POJO
    object: it''s a plane class. We''ll use the `@Produces` application for JSON and
    JAX-RS, and Java EE 8 will make sure that this POJO is marshalled properly to
    JSON using JSON-B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for unmarshalling. Let''s assume that we want to `POST` a
    `JsonbPojo` to this REST resource. At the class level, we make sure that we use
    the `@Consumes` application JSON. If you `POST` a proper JSON to this REST resource,
    JAX-RS and Java EE 8 will make sure that this JSON structure is then deserialized
    and unmarshalled into a `JsonbPojo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t like the default serialization, what you can always do is take
    care of the marshalling yourself using the `jsonb` instance. It offers a method
    called `toJson`, which you can pass to any object and it will return the string
    as an output, and vice versa. You can say that it expects the JSON string as the
    first parameter and the class of the final POJO as the second parameter. If everything
    goes the way you want it to, you''ll receive the unmarshalled object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a closer look at using this `jsonb`. We will prepare simple unit
    tests here. What we can always do is create and use JSON-B standalone without
    any JAX-RS resources. The one thing you should do is use `JsonbConfig` and make
    sure that we import everything in there. We will create a new `JsonbConfig` and
    on this `JsonbConfig`, we can set several parameters. For example, you can specify
    a property ordering strategy where we use `LEXICOGRAPHICAL`. You can also specify
    `REVERSE` and `ANY` in any case as well. We can specify if we want to marshall
    null values, use a property naming strategy, in this case, `LOWERCASE_CASE_WITH_DASHES`,
    we can specify whether the produced JSON is formatted or not, you can specify
    a default date format, you can specify how to handle binary data, and you can
    specify the overall locale. Using `jsonbConfig` is pretty straightforward; we
    use the JSON-B builder (`JsonbBuilder`) and call the `create` method on it and
    pass `create` (`jsonbConfig`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we obtain this JSON-B instance, in the test methods, we use `jsonb.toJson(pojo)`
    and we get the string JSON-B from JSON. Pass it the string data and a class you
    want and the `pojo` will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for plain POJOs and POJOs that have not been specifically annotated.
    If we want to overwrite these default configurations, we can annotate our POJO
    like we did previously using `@JsonbPropertyOrder`. For example, to specify the
    very explicit property order, we can say `@JsonbProperty` to give it a different
    name, `@JNumberFormat` to specify the number format to use, `@JsonbDateFormat`
    to specify a different date, or `@JsonbTransient`, which tells JSON-B to ignore
    this property during marshalling and unmarshalling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take this test and run our thing. Our test should hopefully be green,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b59eeaa3-b404-4bec-bc9d-ea1a35bc12d3.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we saw that using JSON-B is really simple and straightforward.
    In the next section, we'll talk about flexible JSON processing with JSON-P.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible JSON processing with JSON-P
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at using JSON-P builders to construct
    JSON arrays and objects. We'll see how you can use JSON-P in REST resources for
    marshalling and unmarshalling data, how to use JSON Pointers to access JSON structures,
    and have a closer look at JSON Patch and JSON Diff to modify JSON structures.
    We will also be using the `@PATCH` annotation and the `application/json-patch+json`
    content type to apply patches in our REST resources, so there's lots of content
    ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started. As usual, we prepare a small REST resource as a template
    to start. The first thing we do is create arrays for JSON and JSON objects using
    the associated builders, so let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using the `createArrayBuilder` to create an array builder, and we're
    using the `add` method to add JSON objects. Here, you can use `Json.createObjectBuilder`
    to obtain an object builder. On this object builder, we then call different `add`
    methods to add a string, an integer, a Boolean, or maybe a null value using the
    special `JsonValue`. That's all there is to it. Using these two builders, you
    can create complex JSON structures quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we do with this? The first thing we do is we return `jsonArray`; this
    is really straightforward. You can explicitly and directly return this `jsonArray`
    for marshalling. To do this, we will produce an `APPLICATION_JSON` as our content
    type and JAX-RS will make sure that our `jsonArray` is serialized and marshalled
    to the corresponding JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true if we want to unmarshall the data using JSON-P. We will consume
    the `APPLICATION_JSON`, get the `InputStream` which is basically `jsonBody`, and
    we''re going to use `JsonReader` Here, we''re going to use `Json.CreateReader(jsonBody)`
    from the `InputStream`, obtain a `JsonReader`, and on the `reader`, we can read
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what else there is in JSON-P. Well, first up there are JSON Pointers.
    Let''s look into JSON Pointers. Let''s assume we have a simple JSON structure.
    In this test, we''ll create a reader using a string, and we''ll obtain a `JsonObject`
    from the reader and a `JsonArray` from this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to access an array value by index? For this, we use a JSON Pointer.
    We'll use `Json.createPointer`, and using this annotation here basically specifies
    the path and the index of the value we want to reference. We'll also create a
    `jsonPointer`, and on the `jsonPointer` we can then set `getValue` and pass it
    the `JsonObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this, we''ll get back a `jsonValue` and what we can do is we can check
    that the values of the `JsonNumber` and `jsonArray` instances are correct as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the JSON Pointer to replace objects in the array, for example,
    or in the JSON structure. We use `jsonPointer.replace`, give it the original `jsonObject`,
    and we specify the new `createValue(42)` value we want to replace the pointer
    value with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the JSON Pointer to remove things from the JSON''s structure.
    Here, we can use the JSON Pointer, say, on `remove(jsonObject)`, and a new JSON
    object will be returned. If we check the JSON array, the size is smaller than
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Something else regarding JSON-P is JSON Patch. We will create a JSON object
    first, a `jsonReader`, pass it a string, and read the object from the reader.
    We will create a `JsonPatch`. For this, we will use the `createPatchBuilder` and
    on the `patch` we want to say, please replace the element `"/aString"` with the
    `"Patched Json-P."` value and please remove this from `"/arrayOfInt/1"`. Therefore,
    you can use JSON Patch to specify modifying operations, such as replacing, removing,
    and adding values to JSON structures. On the `patch`, we call the `apply` method
    and we''ll pass it as a parameter to the JSON structure we want to apply the patch
    to. This will return a new and modified JSON object. Here, we can make sure that
    the modification is done properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Something else that''s quite nice is the JSON Diff feature. Let''s assume that
    we have a `source` and a `target` object. As you can see, they''re both kind of
    the same—they have one element called `"aString"`, but the values differ. What
    we then do is create a `diff`, say, `Json.createDiff(source, target)`, and what
    we get back is a `JsonPatch` describing the necessary changes it needs to apply
    to `source` so that we can get the `target` object. If we have a look at our JSON
    Diff, we can see all that is required is a `replace` operation. For the following
    path, we do the same with `"/aString"`, and we need to replace the `"value"` with
    `"xyz"`. If we apply this patch to the `source` object, we get the `target` object,
    and we do that by taking the `diff` and applying it to the `source`. We get back
    a new object and we assert that the `source` is equal to the `target`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use JSON Patch in your JAX-RS resources as well. For this, we
    have to use the following two annotations. First up, we use `@PATCH` and then
    specify `@Consumes` with a media type of `APPLICATION_JSON_PATCH_JSON`. The structure
    we send this in is a `JsonArray`, and from that `JsonArray`, we create a `jsonPatch`
    that we can use to apply it to our data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That was a lot of content for covering JSON-P. In the next section, we are going
    to implement a hypermedia-driven REST API using what we've learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing hypermedia-driven REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at how you can traverse REST resources
    using hypermedia (with links and URIs). We'll see how to use JSON-P to construct
    hypermedia enabled JSON structures. We'll use the `@Context` and `UriInfo` objects
    to construct resource URIs programmatically. We will also have a look at how to
    set link headers with URIs on the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and switch to our IDE. We will prepare a resource, and this
    resource will be serving books and authors; both are individual REST resources.
    Obviously, books are written by authors, so we should be able to navigate from
    books to the authors and vice versa. This is what we can use hypermedia for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to our book resource. In here, we have the method to serve a specific
    book. First up, we''ll obtain the book and then we can construct the URI for this
    book. `createBookResourceUri` is the URI to use to reference this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to construct the author URI for this book. If you look in here
    into one of those methods, you''ll see that we use the `uriInfo` object and that
    we obtain a base URI builder from it. We then use the `path` methods to actually
    build the final URI. Using these `path` methods, we can construct the path from
    the `@Path` annotations of our resources and resource methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final result, we have a URI that references the actual resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, what we do is create a JSON object from `book` from our `bookUri`,
    and this is where hypermedia comes into play. Let''s have a look at them. We''ll
    use JSON-P to create an object builder and add `"isbn"` and `"title"` to it. However,
    there''s one bit missing and that bit makes the final hypermedia enabled JSON
    structure. We will add an additional object called `"_links"` which is a JSON
    object, and this JSON object contains two other JSON objects which are called `"self"`
    and `"author"`. `"self"` describes the URI of the REST resource itself, which
    in this case is the type of book. Then, we specify `"author"`, and we give it
    an `"href"` attribute which points to `authorUri`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we return the JSON object, and on the `response` object you can also
    set the link HTTP headers as well so that you have two options. You can either
    specify the link header on the HTTP `response` or embed the URIs, which adds a
    linked JSON structure here. We've completed the books.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pretty much do almost the same thing for authors; the code this is pretty
    much copy/paste. This kind of follows the same procedure: we get the authors and
    then construct the URI for the author and the books. We construct our JSON object
    where we''re going to embed the links to `"self"`, which is `"books"` itself,
    and do the same for the `booksUri`. Finally, you return the response of this JSON
    object and we can also embed the `link` HTTP headers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s put this API to the test. Open our Postman and issue a `GET` request
    for the list of books. In here, you will see that the book has a title and that
    it also contains a list of links. For `"self"`, this is the book itself and for
    `"author"`, we get the author of the book, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aee538a-1f94-468c-98d8-4560e1bb6597.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s click on the book, that is, the URI present in `"self"`, to get information
    about this book in particular. As you can see, this returns a single book structure.
    If you want to navigate to the author, we can use the author link. Here, we have
    the author of this book, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b575a269-e5c8-4d97-ac28-539aa98574f3.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to obtain the list of books that this author has written, we can
    use the `"books"` link, which gets all the books from this author's ID, as shown
    in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to have a look at this book again, you can navigate from those
    two books. What you can also see here in the headers is that we have the two links
    for the author and the book itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7adbe647-433e-4c27-b0d4-798bb2ac86f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's summarize what we have learned in this chapter. First up, we had a look
    at how we can use custom content types and content negotiation in our web services.
    Next up, we had a look at JSON-B and how we can use it for easy data binding of
    your POJOs to and from JSON. We also had a look at JSON-P for very flexible JSON
    processing, and how we can create JSON structures and retrace these structures
    using JSON-P. Then, we looked at how to use JSON Pointers, JSON Patch, and JSON
    Diff for more flexible JSON processing, and finally, we had a look at implementing
    hypermedia enabled REST APIs using JSON-P and `UriInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about building asynchronous web services.
  prefs: []
  type: TYPE_NORMAL
