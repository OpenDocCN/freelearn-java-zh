- en: 7\. Databases and JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you will learn how to use **Java Database Connectivity**
    (**JDBC**) to access relational databases from your Java applications. This begins
    with creating tables in relational databases to store and sort data. Only then
    can you manipulate these tables by writing basic SQL queries to retrieve and modify
    that data. Once this baseline is established, you'll be able to apply these skills
    to Java applications, specifically, in order to access databases and run queries
    from JDBC. You will further practice using the JDBC PreparedStatement interface
    to allow for parameterized SQL statements, boosting your speed by cutting out
    time-consuming and repetitive keystrokes. By the end of this chapter, you will
    know how to insert and update data from the JDBC, and handle any exceptions it
    throws with confidence and skill.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases—especially relational databases—are used in thousands of applications,
    from small home-based applications to huge enterprise systems. To help us write
    applications that access databases, Java provides a few very handy tools, starting
    with **Java Database Connectivity** (**JDBC**).
  prefs: []
  type: TYPE_NORMAL
- en: '**JDBC** allows Java applications to connect to a myriad of databases, provided
    you have the correct driver: a Java library designed to communicate with a given
    database. Once connected, JDBC provides an API for accessing databases in a manner
    that is mostly generic. You''ll only encounter a few areas where you need to know
    the specifics of the underlying database implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Originally defined by E. F. Codd, relational databases store data in tables,
    made up of columns and rows. For example, the following table could be used to
    store customer information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: A database table of customers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: A database table of customers'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this customer table example, each row has four columns: an ID, a username,
    a first name, and a last name.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In addition to celebrities such as Sting, Cher, and Bono, some ethnic groups
    use just one name. You will not always have first and last names.
  prefs: []
  type: TYPE_NORMAL
- en: Each row needs a unique way to distinguish that row from all others, called
    a **unique primary key**. In this case, the ID column acts as a unique key. In
    this table, you could also use the username as a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: Some tables use a single column as a key, while others use the values in multiple
    columns to form the key, called a **composite key**.
  prefs: []
  type: TYPE_NORMAL
- en: Most databases use more than one table. You can relate tables to other tables
    based on information within a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in an online system, each customer might have multiple email addresses.
    You can model this relationship using a separate table for email addresses, as
    shown in Table 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: A database table for email addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: A database table for email addresses'
  prefs: []
  type: TYPE_NORMAL
- en: In table 2, each row has its own unique ID, with the `EMAIL_ID` column. Each
    row also links back to the customer table by holding an ID for the user table
    in the `CUSTOMER_ID` column. This allows the `EMAIL` table to link to the `CUSTOMER`
    table. User `bobmarley`, for example, has two email addresses in the system, one
    for home and one for work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: These email addresses are not real.
  prefs: []
  type: TYPE_NORMAL
- en: In this hypothetical example, there may also be tables for postal addresses,
    customer preferences, billing, and other things. Each table would likely relate
    back to the customer table.
  prefs: []
  type: TYPE_NORMAL
- en: To use a relational database, you need a **Relational Database Management System**
    (**RDBMS**), the software that manages the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Database Management Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most common RDBMSes include Oracle, MySQL, SQL Server, PostgreSQL,
    and DB2\. In each case, you have software that runs on a server (or servers) to
    manage the data, along with separate client software to query and manipulate the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: To use an RDMS, you first need to install the database software.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we'll use an open-source database called H2\. H2 is written
    entirely in Java, so you can run it wherever you run a JVM, such as in Windows,
    Linux, or macOS systems. On account of its portability and simplicity, H2 works
    well for the database tables we'll create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: H2 has some nice features in that it comes with a browser-based database console
    that you can use to access the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: H2 can also be used inside your applications as an embedded in-memory database.
    In this case, the database server and client both exist within your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: To install H2, go to [https://packt.live/2MYw1XX](https://packt.live/2MYw1XX)
    and download the `h2`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `h2` folder, you will see sub-folders named `bin`, `docs`, `service`,
    and `src`. The documentation in the `docs` folder is also available online.
  prefs: []
  type: TYPE_NORMAL
- en: The bin folder contains the H2 database software bundled into a JAR file. It
    also contains a Windows batch file and a Unix/Linux shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Running the H2 Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have installed the database, the next step is to get the database
    up and running. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the H2 database, you can use one of the scripts in the `bin` folder,
    or simply run the `jar` file. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Regardless of how you launch the H2 database, you can access it from a browser.
    On some systems, such as macOS, H2 will open the database console in your default
    browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If it does not open automatically, you can simply point your browser to `http://10.0.1.7:8082/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the login pane with the information filled in, as shown in *Figure
    7.1*:![Figure 7.3: The login pane for the web database console'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C13927_07_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.3: The login pane for the web database console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the information should be filled in correctly when you start. The database
    driver (discussed later in this chapter) is `org.h2.Driver`, the JDBC URL is `jdbc:h2:~/test`,
    the username is `sa` (for system administrator), and the password is empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Obviously, on a real database, you'd use an actual password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click `Connect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a few moments, you'll see the main console pane, and you're in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, H2 will store databases in your home directory. With this database
    named `test`, you should see two files in your home directory with names starting
    with `test` and ending with `db`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have the H2 database installed and running, the next step is to start
    creating tables. To do so, you need to write commands in a language called SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structured Query Language** (**SQL** and often pronounced "sequ-el") provides
    a common language for querying and manipulating data in relational databases.
    While there are a few differences, SQL mostly works the same in relational database
    systems such as Oracle, SQL Server, MySQL, and H2.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do is to create a table. To do so, use the `CREATE
    TABLE` SQL command. To create a table, you must provide the name of the table,
    the names and types of the columns, and any constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Creating the customer Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the SQL `CREATE TABLE` command to create a `customer` table. It should contain
    the customer ID and the users' first and last names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following SQL commands in the upper-right input pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After entering the SQL command, click on the `Run` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 7.2* shows the main database console window:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.4: The H2 database console after creating a table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: The H2 database console after creating a table'
  prefs: []
  type: TYPE_NORMAL
- en: Notice in *Figure 7.4* that once the table is created, you see the table name,
    `CUSTOMER`, in the left-hand pane. You can click on the `+` symbol to expand the
    table entry and see the columns, as shown in *Figure 7.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CREATE TABLE` command can be broken down into its component parts. The
    command starts with `CREATE TABLE`. After that, `IF NOT EXISTS` means to not attempt
    to recreate the table if it already exists (the `ALTER TABLE` command is used
    to change the structure of an existing table):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next comes the table name, `customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a parenthesis, you will see the definition of the columns and then the
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `CUSTOMER_ID` column is of the `long` type, like the Java `long` type. This
    column will be the unique primary key.
  prefs: []
  type: TYPE_NORMAL
- en: The `USERNAME`, `FIRST_NAME`, and `LAST_NAME` columns are all of the `varchar`
    type. The `varchar` type holds variable-length character (text) data up to a maximum
    number of characters, specified here as `255` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `USERNAME` column must be unique, and the `CUSTOMER_ID` column is the primary
    key. (The primary key must also be unique.) The database will enforce these constraints
    when you insert data. Note that you can list multiple columns names, separated
    by commas, to create a composite primary key. This means that the combination
    of values in those columns must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: The entire command ends with a closing parenthesis and a semicolon. SQL uses
    a semicolon in the same way as Java to indicate the end of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data into a Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To insert data into a table, use the `INSERT INTO` command. The basic syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You first list the columns and then provide values for those columns. You must
    provide a value for all columns that do not allow nulls. In this case, the `CUSTOMER_ID`
    and the `USERNAME` are required. Each must also be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: SQL uses a single quote character to delimit strings. If you need to enter a
    quote character, use two together, such as `Java''s`. Don't try smart quotes,
    as are used in some word processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Inserting Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise again uses the H2 web console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following SQL in the upper-right input pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After entering the SQL command, click on the `Run` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat these two steps with the following two SQL statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most RDBMSs support types that will automatically manage ID numbers for a primary
    key. The syntax does differ in different database software, however. Refer to
    [https://packt.live/2J6z5Qt](https://packt.live/2J6z5Qt) for the `IDENTIIY` type
    for H2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Retrieving Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve data from a table (or tables), use the `SELECT` command. The SQL
    `SELECT` command lets you query for data. You must specify what you are looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide a comma-delimited list of columns to return, or use an asterisk,
    `*`, to indicate you want all the columns returned. The simplest query follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see all the rows returned, as displayed in *Figure 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Querying all the rows from the customer table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Querying all the rows from the customer table'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refine your query with a `WHERE` clause. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will return all rows that have a `first_name` column value equal to `Bob`,
    which, so far, would be just one row.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a wild card query with the `LIKE` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This query returns all rows where the username has an `e`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, the percent sign acts as a wild card. This example has a wild card
    at the beginning of the value, and another at the end. You can use just one wild
    card, for example, to query for the end of a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example queries for all records that have a username value that ends in
    `ey`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a more detailed query using `OR` or `AND` in the `WHERE` clause.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example returns all rows where the `first_name` is `Peter` or the `last_name`
    is `Cliff`, which is two rows in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an `OR` operator, the `SELECT` statement returns all rows that match either
    of the criteria. With an `AND` operator, both parts of the criteria must match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example will return zero rows since no row matches both criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far, we''ve used an asterisk to indicate that we want all columns returned.
    You can specify a comma-delimited list of column names instead. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This example also uses the `ORDER BY` clause to tell the database to return
    the records in a certain order, in this case, sorted by `last_name` and then `first_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL uses two dashes, `--`, to indicate the start of a comment, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: SQL queries can get quite complex. These examples just provide a small taste.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on SQL, you can refer to the following Packt video: [https://packt.live/33KIi8S](https://packt.live/33KIi8S).'
  prefs: []
  type: TYPE_NORMAL
- en: Relating Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most databases include multiple tables, and many of these tables will be related.
    From the earlier example, we can relate the customer table to a separate table
    for email addresses. In the previous example, each row in the email table included
    the ID of the related row in the customer table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Creating the email Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise uses the H2 web console. In this exercise, we will create an email
    table and insert some values into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following SQL in the upper-right input pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After entering the SQL command, click the `Run` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following `INSERT` statement, and then click the `Run` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following `INSERT` statement, and then click on the `Run` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Include the following `INSERT` statement, and then click on the `Run` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we must manage the IDs, both `EMAIL_ID` and the related `CUSTOMER_ID`.
    This can become tedious. Java libraries, such as Hibernate, that map Java objects
    to relational tables can help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate is considered an ORM, or Object-Relational Mapper. For more information
    on Hibernate, refer to [https://packt.live/2Bs5z3k](https://packt.live/2Bs5z3k).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have data in multiple related tables, you can query from multiple tables
    at once, joining the results together.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Data from Multiple Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the SQL select statement to query data from multiple tables, you
    need to list all the columns (from all the tables) that you wish to be returned,
    along with the criteria to search in the `WHERE` clause. In the `WHERE` clause,
    you will need to join the two tables on some common value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `email` table has a `customer_id` column to join back to the
    `customer` table. To join that, write a query along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this query, we ask for the `username` from the customer table, along with
    the `email_address` from the email table. The `FROM` section lists both the customer
    and email tables.
  prefs: []
  type: TYPE_NORMAL
- en: The `WHERE` clause gets more interesting. This query looks for all email addresses
    where the type is `HOME`. To join this back to the customer table, and to ensure
    you are getting the right customer, the query adds a join where the `customer_id`
    email table column corresponds to the `customer_id` customer table column. This
    ensures that you get the correct customers aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Existing Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UPDATE` command lets you modify existing rows. To update data, you need
    to specify which rows to change, along with the values to change. The basic syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 5: Modifying email Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a user, such as `bobmarley`, switches to a different work email, you would
    need to update the email table. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the H2 database console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following SQL query, and then click `Run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command lets you see what values are in the table now before we change
    anything.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, enter the following `UPDATE` statement, and then click `Run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This query changes the `email_address` entry for the customer, `bobmarley`,
    but just the `WORK` email.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the select query again (and click `Run`) to see how the table has
    changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now see the results as shown in the following table:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.6: Output of the query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Output of the query'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove data from a table, use the `DELETE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to remove the work email for the customer, `bobmarley`, you would
    use a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you have tables that are related, deleting data becomes trickier. If you
    delete a customer, for example, you need to delete all rows from the email table
    for this customer, too. In this example, the email table depends on the customer
    table, but the opposite is not true.
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples so far in this chapter, we've used SQL in the H2 console
    to work with the data in a test database. In your Java applications, you will
    use JDBC to accomplish much the same goals.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC—Accessing Databases from Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JDBC provides a common API to work with databases. Mostly, JDBC works with relational
    databases, but you can work with any data source for which you have a **JDBC driver**,
    the Java library that communicates with the data source and implements the JDBC
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One of the best parts of JDBC is that most driver libraries are written in Java,
    so you can use these drivers from any platform that runs the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do with JDBC is connect to a data source, typically
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to connect to a database using JDBC is to use the `getConnection()`
    method on the `java.sql.DriverManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The JDBC URL, which starts with `jdbc:h2` tells `DriverManager` to look for
    an H2 JDBC driver. `~/test` tells H2 to look for a database named `test` in the
    current user's home directory. (This is the user—you—running the Java program.)
    `test` is the default database name created by H2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username to connect under, in this case, `sa`, for the system administrator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password, in this case, is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other than H2, you will likely never have an empty password when connecting
    to a database. H2 sets up the `sa` account that you can use for testing by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `getConnection()` method returns a `java.sql.Connection` object, which you
    can use as a starting point for working with a database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to connect to a database, especially when using connection
    pools, described later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every JDBC operation can throw a `java.sql.SQLException`, so you will
    usually wrap JDBC calls in a try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done with a JDBC connection, you should close the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Querying Data with JDBC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To query from a database with JDBC, create `java.sql.Statement` and then execute
    a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a statement using the `Connection` object. You can then execute a SQL
    query using the `executeQuery()` method, which returns a `java.sql.ResultSet`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `ResultSet` API can be confusing at first. It is based on the idea of a
    cursor, a record of the program's position within the data. By calling `next()`
    on a `ResultSet`, you move the cursor to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the normal flow for a query will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`ResultSet` starts with a position—the cursor—prior to the first row, so you
    need to call `next()` to get the very first row of data. The `next()` method returns
    false when it has reached the end of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Part of the reason for iterating through a `ResultSet` like this is because
    some database tables hold so many records that you could not hold them all in
    memory at the same time. Hence, the general technique is to process one row at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With each row of data, call `get` methods on the `ResultSet`. For example,
    to get a string value, call `getString()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we pass the name of the column to `getString()`. It returns
    the value of the `USERNAME` column for the current row.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass the position of the column in the results. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The position number is the position of the column in the results, which is dependent
    on the query.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unlike almost everything else in Java, JDBC columns start counting at 1, not
    0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to know the type of data in the column to call the proper `get` method.
    For example, to get a `long` value, call `getLong()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can call `getObject()` if you are unsure of the type of data in the column.
  prefs: []
  type: TYPE_NORMAL
- en: When done with a `ResultSet`, call `close()`. Similarly, when you're done with
    a statement, call `close()`. Calling the `close()` method on these objects frees
    up resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Querying Data with JDBC'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will create an IntelliJ project, bring in a dependency for the
    H2 database JDBC driver, and then query the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `New` and then `Project…` from the `File` menu in IntelliJ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Gradle` for the type of project. Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `Group Id`, enter `com.packtpub.db`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `Artifact Id`, enter `customers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `Version`, enter `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default on the next pane. Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the project name as `customers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call up `build.gradle` in the IntelliJ text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `sourceCompatibility` to `12`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the plugins block with the following, just as we did in *Chapter 6*,
    *Libraries, Packages, and Modules*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following dependency to incorporate the H2 library in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the same jar file that provides the JDBC driver also includes the
    entire database software.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following to the end of the project''s `build.gradle` file to define
    the main class for the executable jar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `src/main/java` folder, create a new Java package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `com.packtpub.db` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on this package in the `Project` pane and create a new Java class
    named `Query`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main()` method for the `Query` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This program establishes a connection to an H2 database. Notice how all the
    JDBC calls are wrapped in a try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: After establishing a `connection`, the program asks the `Connection` to create
    a `Statement`. Calling `executeQuery()` on the `Statement` runs the query, returning
    a `ResultSet`. With a `while` loop, the program iterates over each row in the
    `ResultSet`, extracting data, and printing.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the program closes the resources used.
  prefs: []
  type: TYPE_NORMAL
- en: This sets up an executable jar that will run the `Query` class. Remember to
    run the `shadowJar` Gradle task to build the executable jar with dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this program, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the query asked the database to order the results by username.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are connected to the database from the H2 web console, you will see
    an error like the following when you run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You should also see the full stack trace for the error. This error indicates
    that you are already logged into the database as user `sa`. Click on the disconnect
    icon in the upper-left corner of the H2 web console to close the web console's
    connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Query` class in *Exercise 6*, *Querying Data with JDBC*, we used a string
    for the SQL query. That works fine when your program generates the entire SQL
    statement itself. However, if you accept user input and then build a string for
    the SQL, your program may be vulnerable to SQL injection attacks, where a malicious
    user inputs SQL syntax designed to cause havoc to your database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed look at SQL injection vulnerabilities, refer to [https://packt.live/2OYGF3g](https://packt.live/2OYGF3g).
  prefs: []
  type: TYPE_NORMAL
- en: Because of this risk, you should sanitize any user input prior to placing it
    in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing User Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To sanitize user input:'
  prefs: []
  type: TYPE_NORMAL
- en: You can properly sanitize the data yourself. You could disallow characters that
    could form SQL syntax, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `PreparedStatement` interface and set the values on the prepared
    statement. JDBC will then sanitize the input for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Prepared Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JDBC prepared statement takes in a SQL statement with placeholders for the
    data values. With most databases, JDBC sends the SQL to the database to be compiled.
    When you send a SQL statement to a database, the database needs to compile the
    SQL into an internal format that is native to the database, from which the database
    can execute the statement.
  prefs: []
  type: TYPE_NORMAL
- en: With a regular statement, you can provide a SQL statement to methods such as
    `executeQuery()` and `executeUpdate()`. You can reuse the `Statement` and provide
    a completely different SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: With a `PreparedStatement`, on the other hand, you prepare the statement with
    a SQL string, and that is all you get. Luckily, though, you provide placeholders
    for the data values. This means that you can reuse a `PreparedStatement` to insert
    multiple records into a table, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'From *Exercise 5*, *Modifying email Data*, we use an `UPDATE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With a `PreparedStatement`, you would use a question mark, `?` as a placeholder
    for the input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a prepared statement, you do not need to place single quotes around string
    placeholders. JDBC will take care of that for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'These placeholders need to be filled in prior to using `PreparedStatement`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Pass your SQL string, with placeholders, to the `prepareStatement()` method
    on a connection. Then, call `setString()`, `setLong()`, and so on, to fill in
    the placeholder values. With each set method call, you pass the index of the placeholder
    to fill, starting with `1` for the first placeholder. Then, pass the value to
    fill in. JDBC will handle the prevention of SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: As for a regular `Statement`, you can call `executeQuery()` to perform a SQL
    query, or `executeUpdate()` to modify the database. The `executeUpdate()` method
    handles `INSERT`, `UPDATE`, and `DELETE SQL` statements.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `executeUpdate()` returns the number of rows in the table that
    was modified.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary benefits of using prepared statements is that JDBC will sanitize
    the input values so that you don't have to. The other primary benefit is improved
    performance. If you execute the same SQL statement again and again, or a nearly
    similar statement with just different values, then using a prepared statement
    will speed things up, mostly due to pre-compiling the statement.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and Rollback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In relational databases, transaction groups a set of SQL statements together.
    Either all the statements succeed, or the transaction will get rolled back, undoing
    the statements. In addition, databases treat all the statements within a transaction
    as happening at the same time, which helps to ensure that the data has integrity.
  prefs: []
  type: TYPE_NORMAL
- en: In JDBC, a transaction continues until you call `commit()` on the connection.
    If there is a failure, you should call `rollback()` on the connection to restore
    the data to the state it held prior to the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, a JDBC connection starts in auto-commit mode. This means that each
    JDBC connection gets committed one at a time. If you want to group a few statements
    together in a transaction, you first need to turn off auto-commit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After turning off auto-commit mode, you should turn it back on when done accessing
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to end a transaction and commit the results to the database,
    call `commit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If an `SQLException` gets thrown, you''ll want to roll back the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code shows one of the most tedious parts of working with JDBC. In your
    exception handler for a `SQLException`, the calls made—`rollback()`, for instance—can
    also throw another `SQLException`, which you need to catch. You'll find that JDBC
    code is full of `try`-`catch`-`finally` blocks with nested `try`-`catch` blocks.
    *Exercise 7*, *Using Prepared Statements with Transactions* shows this technique
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Using Prepared Statements with Transactions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll create another Java class that uses a JDBC `PreparedStatement`
    to update data in the email table and wrap that update in a JDBC transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In IntelliJ, create a new class named `Prepared` and create a `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the required libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter the following code in the `Prepared` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Prepared` class starts by defining a `SQL UPDATE` statement using placeholders.
    This SQL statement will later get placed in a `PreparedStatement`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first try-catch block, the program gets a `Connection` to the database
    and then calls `setAutoCommit()` with a parameter of `false` to turn off auto-commit
    mode. JDBC now expects the program to manage transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the `main()` method, you should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Just one row should be modified.
  prefs: []
  type: TYPE_NORMAL
- en: The program passes the SQL string to the connection's `prepareStatement()` method.
    This creates a `PreparedStatement` initialized with the given SQL. Next, the program
    fills in the placeholder values in the `PreparedStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: When it's done, the program calls `executeUpdate()` on the statement, commits
    the transaction and then tells us the number of rows that were changed.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the JDBC calls throws an `SQLException`, the catch block prints the
    stack trace and then calls `rollback()` on the connection. Calling `rollback()`
    can also throw `SQLException`, so the program catches that as well, printing the
    stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` block from the original try-catch-finally block restores auto-commit
    transaction mode, and then calls `close()` on the `PreparedStatement` and the
    connection, each of which might also result in an `SQLException`.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying JDBC Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the examples, programming with JDBC is tedious. Because
    of that, a lot of projects have developed wrappers over the JDBC API in order
    to simplify making JDBC calls.
  prefs: []
  type: TYPE_NORMAL
- en: Java itself contains a number of utility classes, such as `JdbcRowSet`, which
    wrap `ResultSet` objects and provide a somewhat simpler API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Spring framework provides a number of utilities to simplify JDBC programming.
    Refer to [https://packt.live/35PalWP](https://packt.live/35PalWP) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: By far the most popular way to access databases without the inconvenience of
    the JDBC API is to use object-relational mapping software.
  prefs: []
  type: TYPE_NORMAL
- en: Using Object-Relational Mapping Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, **object-relational mapping**, or **ORM**, software maps
    between the world of objects and the world of relational tables. With an ORM,
    you typically write a Java class that represents one row of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following class could represent a row in the customer table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `Customer` class is what is often called a **Plain Old Java Object** (**POJO**).
    ORM software then allows you to use query tables and get back a list of POJOs,
    or fill in data in a POJO and then persist that object to the database. In the
    majority of cases, ORM software uses reflection to discover the fields in the
    class and map those to columns in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 19* covers reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Persistence API**, or **JPA**, provides a standardized API to define
    the mapping between objects and database tables using annotations to describe
    the mapping. JPA also defines an API for persisting POJOs to database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath the standard Java Persistence API, you need to use a JPA provider,
    a library that implements the JPA. The most commonly used JPA provider is called
    **Hibernate**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on JPA, refer to [https://packt.live/2OZjHsP](https://packt.live/2OZjHsP).
    JPA is part of the **Java Enterprise Edition** (**JavaEE**).
  prefs: []
  type: TYPE_NORMAL
- en: Database Connection Pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DriverManager.getConnection()` method can take a good bit of time to establish
    a connection to a database. To help with this, you can use a database connection
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pools set up multiple and managed connections to a database. Your
    application can then request a free connection from the pool. Your code uses the
    connection and then returns it to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the main connection pool software libraries are:'
  prefs: []
  type: TYPE_NORMAL
- en: HikariCP, from [https://packt.live/2Bw7gg5](https://packt.live/2Bw7gg5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Commons DBCP, from [https://packt.live/31p4xQg](https://packt.live/31p4xQg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C3p0, from [https://packt.live/2pw1vN0](https://packt.live/2pw1vN0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tomcat connection pool, from [https://packt.live/31pGgcJ](https://packt.live/31pGgcJ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-Relational, or NoSQL, Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases work well when you have data that works well with the columns
    and rows in SQL database tables. In the real world, not all data fits neatly into
    this model. This has led to the creation of NoSQL databases, database management
    software that does not support relational tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Oddly enough, some NoSQL databases support a SQL-like language for accessing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases all differ, and some of the categories to describe these databases
    overlap. Terrastore, [https://packt.live/2P23i7e](https://packt.live/2P23i7e),
    and MongoDB, [https://packt.live/31qJVY0](https://packt.live/31qJVY0), are considered
    document storage databases. In these systems, you store a full document, typically
    a structured document.
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra, [https://packt.live/2MtDtej](https://packt.live/2MtDtej), and HBase,
    [https://packt.live/2VWebsp](https://packt.live/2VWebsp), are sometimes referred
    to as column-store or column family databases, which store data in columns as
    opposed to storing data in rows, as is done with most SQL databases. If you organize
    the columns properly, these databases can very quickly retrieve data. You can
    also store a huge number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j, [https://packt.live/2o51EXm](https://packt.live/2o51EXm), is a graph
    database. In a graph database, you retrieve data by following relationships between
    elements. These relationships form a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Track Your Progress'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will set up database tables in the H2 database to track
    your progress through this course. These steps will help us complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a table called `student`, where each record holds information on a student,
    such as you. Define the ID, first name, and last name columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table called `chapter`, where each record holds information on a chapter.
    Define columns for an ID (use the chapter number) and chapter title. For simplicity,
    you can just enter the chapters up to and including this one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a table to relate students to chapters, called `student_progress`. This
    table should have columns for the ID of a student, the ID of a chapter, and a
    date for when the chapter was completed. Use the `SQL DATE` type and pass the
    data as `yyyy-MM-dd`. This table should have a composite primary key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the H2 web console to create the tables and insert records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create two Java programs that use JDBC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the first to query all the chapters a given student has completed, and
    when. Take as inputs the student''s first and last name. This should generate
    output like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the second program to insert chapter completion. Take as inputs the student's
    first and last name, along with a chapter number. The program should mark that
    chapter as having been completed today.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because both programs take in user input, be sure to use a `PreparedStatement`
    in each to handle potentially malicious input data. You can create these programs
    as part of the customer's project created previously in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for the activity can be found on page 548.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced relational database management systems (RDBMSs) and
    the SQL language, which is used for working with relational databases. We used
    an all-Java database called H2\. SQL is a language that's used to retrieve and
    modify data stored in a relational database. JDBC is a Java API that communicates
    with a relational database. You can use SQL commands to retrieve and modify data.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to databases than can be presented in a single chapter,
    but after working through the exercises, you should be able to start working with
    databases using SQL and JDBC. A book or training course on SQL can help you delve
    into advanced database topics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The Packt video SQL Beginner to Guru: MySQL Edition - Master SQL with MySQL:
    [https://packt.live/33KIi8S](https://packt.live/33KIi8S) will help you advance
    your SQL skills.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about networking and files using Java.
  prefs: []
  type: TYPE_NORMAL
