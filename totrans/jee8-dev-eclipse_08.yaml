- en: Creating Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web服务
- en: In the last chapter, we learned how to create web applications in Java using
    MVC frameworks. In this chapter, we will learn how to implement web services in
    Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用MVC框架在Java中创建Web应用程序。在本章中，我们将学习如何在Java中实现Web服务。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Java object binding and serialization using JAXB and JSON-B
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JAXB和JSON-B进行Java对象绑定和序列化
- en: Implementing and consuming RESTful web services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和消费RESTful Web服务
- en: Implementing and consuming SOAP web services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和消费SOAP Web服务
- en: What is a web service?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Web服务？
- en: In [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Applications with EJB*, we learned that EJBs can be used to create distributed
    applications. EJBs can act as glue and help different JEE applications in the
    enterprise to communicate with each other. However, what if the enterprise wants
    to let its partners or customers make use of some of the application functionality?
    For example, an airline might want to let its partners make online reservations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)，“使用EJB创建JEE应用程序”中，我们学习了EJB可以用来创建分布式应用程序。EJB可以作为粘合剂，帮助企业中的不同JEE应用程序相互通信。然而，如果企业希望其合作伙伴或客户使用某些应用程序功能，会怎样呢？例如，航空公司可能希望让其合作伙伴进行在线预订。
- en: One option is for the partner to redirect its customers to the airline website,
    but this would not provide a unified experience to users. A better way to handle
    this would be for the airline to expose its reservation APIs to partners, who
    can integrate these APIs into their own applications, providing a unified user
    experience. This is an example of a distributed application, and EJBs can be used
    for this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是让合作伙伴将其客户重定向到航空公司网站，但这不会为用户提供统一的使用体验。更好的处理方式是航空公司将其预订API暴露给合作伙伴，合作伙伴可以将这些API集成到自己的应用程序中，从而提供统一的使用体验。这是一个分布式应用程序的例子，可以使用EJB来实现。
- en: However, for EJBs to work in such scenarios, where API calls cross enterprise
    boundaries, the clients of the APIs also need to be implemented in Java. As we
    know, this is not practical. Some of the airline partners in this example may
    have their applications implemented using different programming platforms, such
    as .NET and PHP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了在API调用跨越企业边界的情况下使EJBs工作，API的客户端也需要用Java实现。正如我们所知，这并不实用。在这个例子中，一些航空合作伙伴可能使用不同的编程平台实现其应用程序，例如.NET和PHP。
- en: 'Web services are useful in situations such as the one mentioned here. Web services
    are self-contained APIs that are based on open standards and are platform independent.
    They are widely used for communication between disparate systems. There are mainly
    two types of web service implementations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提到的情况下，Web服务非常有用。Web服务是基于开放标准的自包含API，且与平台无关。它们广泛用于不同系统之间的通信。主要有两种Web服务实现方式：
- en: Simple Object Access Protocol (SOAP)-based
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于简单对象访问协议（SOAP）
- en: Representational State Transfer (RESTful) services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表现性状态转移（RESTful）服务
- en: For many years, SOAP-based web services were quite popular, but recently, RESTful
    services have been gaining ground because of the simplicity in their implementation
    and consumption.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，基于SOAP的Web服务相当流行，但最近，由于实现和消费的简单性，RESTful服务已经开始占据优势。
- en: Web services provide a common integration platform and offer **service-oriented
    architecture** (**SOA**) in which certain components expose services for consumption
    by other components or applications. The consumer of such services can create
    an entire application by assembling a number of such loosely coupled services,
    possibly from different sources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务提供了一个通用的集成平台，并提供了**面向服务的架构**（**SOA**），其中某些组件暴露服务供其他组件或应用程序消费。此类服务的消费者可以通过组装多个此类松散耦合的服务来创建整个应用程序，这些服务可能来自不同的来源。
- en: In this chapter, we will see how to develop and consume both SOAP and RESTful
    services by using JEE and Eclipse. However, first it would be useful to understand
    how to convert Java objects to XML and JSON, and vice versa, because both REST
    and SOAP web service implementations need to perform these operations. First,
    we will take a look at JAXB, Java XML binding, using which you can bind Java objects
    to both XML and JSON. Then we will take a look at JSON-B (a new specification
    added in JEE 8) for Java JSON binding.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用 JEE 和 Eclipse 开发和消费 SOAP 和 RESTful 服务。然而，首先了解如何将 Java 对象转换为 XML
    和 JSON，以及反向操作将是有用的，因为 REST 和 SOAP 网络服务实现都需要执行这些操作。首先，我们将探讨 JAXB（Java XML 绑定），使用它可以绑定
    Java 对象到 XML 和 JSON。然后我们将探讨 JSON-B（JEE 8 中添加的新规范）用于 Java JSON 绑定。
- en: JAXB
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAXB
- en: JAXB provides an easy way to convert XML or JSON representations of data into
    Java objects and vice versa. Using simple annotations, you can have a JAXB implementation
    create XML or JSON data from a Java object or create a Java object from XML or
    JSON.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JAXB 提供了一种简单的方法将数据的 XML 或 JSON 表示转换为 Java 对象，反之亦然。使用简单的注解，你可以让 JAXB 实现从 Java
    对象创建 XML 或 JSON 数据，或者从 XML 或 JSON 创建 Java 对象。
- en: To understand how Java data types are mapped to XML schema types in JAXB, refer
    to [https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Java 数据类型如何在 JAXB 中映射到 XML 架构类型，请参阅 [https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html)。
- en: 'The following are a few important JAXB annotations:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的 JAXB 注解：
- en: '`@XmlRootElement`: This annotation specifies the root element of the XML document
    and is typically used at the class level.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XmlRootElement`: 这个注解指定了 XML 文档的根元素，通常用于类级别。'
- en: '`@XmlElement`: This annotation specifies an XML element that is not a root
    element. Java class members can be marked as `XMLElement` when the class is annotated
    with `@XmlRootElement`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XmlElement`: 这个注解指定了一个非根元素的 XML 元素。当类被 `@XmlRootElement` 注解时，Java 类成员可以被标记为
    `XMLElement`。'
- en: '`@XmlAttribute`: This annotation marks a member of the Java class as an attribute
    of the parent XML element.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XmlAttribute`: 这个注解将 Java 类的成员标记为父 XML 元素的属性。'
- en: '`@XmlAccessorType`: This annotation is specified at the class level. It lets
    you control how class fields are serialized to XML or JSON. Valid values are `XmlAccessType.FIELD`
    (every non-static and non-`@XmlTransient` field is serialized), `XmlAccessType.PROPERTY`
    (every pair of getter/setter that is not annotated with `@XmlTransient` is serialized),
    `XmlAccessType.NONE` (no fields are serialized, unless specific fields are annotated
    for serialization), and `XmlAccessType.PUBLIC_MEMBER` (all public getter/setter
    pairs are serialized, unless annotated with `@XmlTransient`).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XmlAccessorType`: 这个注解在类级别指定。它允许你控制类字段如何序列化为 XML 或 JSON。有效值包括 `XmlAccessType.FIELD`（每个非静态和非
    `@XmlTransient` 字段都会被序列化）、`XmlAccessType.PROPERTY`（每个未用 `@XmlTransient` 注解的 getter/setter
    对都会被序列化）、`XmlAccessType.NONE`（没有字段会被序列化，除非特定的字段被注解为序列化）、以及 `XmlAccessType.PUBLIC_MEMBER`（所有公共
    getter/setter 对都会被序列化，除非它们被 `@XmlTransient` 注解）。'
- en: '`@XMLTransient`: This annotation specifies a member or getter/setter pair that
    is not to be serialized.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@XMLTransient`: 这个注解指定了一个成员或 getter/setter 对，这些成员不应该被序列化。'
- en: For the complete list of JAXB annotations, refer to [https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB](https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JAXB 注解的完整列表，请参阅 [https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB](https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB)。
- en: A JAXB example
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAXB 示例
- en: 'Let''s create a Maven project to try out JAXB APIs. Select the File | Maven
    Project menu:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Maven 项目来尝试使用 JAXB API。选择 File | Maven Project 菜单：
- en: '![](img/00188.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00188.jpeg)'
- en: 'Figure 9.1: Create a Maven project for a JAXB example'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：为 JAXB 示例创建 Maven 项目
- en: 'Make sure that the project is configured to use JRE 1.7 or later. Let''s now
    create two classes, `Course` and `Teacher`. We want to serialize instances of
    these classes to XML and back. Create these classes in the `packt.jee.eclipse.jaxb.example`
    package. Here is the source code of the `Course` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保项目配置为使用 JRE 1.7 或更高版本。现在让我们创建两个类，`Course` 和 `Teacher`。我们希望将这些类的实例序列化为 XML
    并反向操作。在 `packt.jee.eclipse.jaxb.example` 包中创建这些类。以下是 `Course` 类的源代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When a `Course` is marshalled to an XML document, we want the `course` element
    to be the root. Therefore, the class is annotated with `@XmlRootElement`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `Course` 被序列化为 XML 文档时，我们希望 `course` 元素作为根。因此，该类被注解为 `@XmlRootElement`。
- en: Marshalling is the process of writing the data, typically an object, to a format
    link XML or JSON. Unmarshalling is the process of reading the data from a format
    and creating an object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将数据（通常是对象）写入格式（如XML或JSON）的过程。反序列化是从格式中读取数据并创建对象的过程。
- en: 'You can specify a different name for the root element (other than the class
    name) by specifying the `name` attribute, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定`name`属性来为根元素指定不同的名称（除了类名），例如：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `id` field is marked as an attribute of the root element. You don't have
    to mark fields specifically as elements if there are public getters/setters for
    them. However, if you want to set additional attributes, then you need to annotate
    them with `@XmlElement`. For example, we have specified a namespace for the `name`
    field. The `credits` field is not annotated, but it will still be marshalled as
    an XML element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段被标记为根元素的一个属性。如果这些字段有公共的getter/setter方法，你不需要特别将字段标记为元素。然而，如果你想设置额外的属性，那么你需要用`@XmlElement`注解它们。例如，我们为`name`字段指定了一个命名空间。`credits`字段没有被注解，但它仍然会被作为XML元素进行序列化。'
- en: 'Here is the source code for the `Teacher` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Teacher`类的源代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are not annotating the `Teacher` class for JAXB because we are not going
    to marshal it directly. It will be marshalled by JAXB when an instance of `Course`
    is marshalled.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为`Teacher`类添加JAXB注解，因为我们不打算直接序列化它。它将在`Course`实例被序列化时由JAXB进行序列化。
- en: 'Let''s create the `JAXBExample` class with the `main` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建带有`main`方法的`JAXBExample`类：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To marshal or unmarshal using JAXB, we first create `JAXBContext`, passing
    it a Java class that needs to be worked on. Then, we create the marshaller or
    unmarshaller, set the relevant properties, and perform the operation. The code
    is quite simple. We first marshal the `Course` instance to XML, and then use the
    same XML output to unmarshal it back to a `Course` instance. Right-click on the
    class and select Run As | Java Application. You should see the following output
    in the console:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JAXB进行序列化或反序列化，我们首先创建`JAXBContext`，传递给它需要处理的Java类。然后，我们创建marshaller或unmarshaller，设置相关属性，并执行操作。代码相当简单。我们首先将`Course`实例序列化为XML，然后使用相同的XML输出将其反序列化回`Course`实例。在类上右键单击并选择Run
    As | Java Application。你应该在控制台看到以下输出：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's now see how to marshal a Java object to JSON and back. JSON support in
    JAXB is not available out of the box in JDK. We will have to use an external library
    that supports JAXB APIs with JSON. One such library is EclipseLink MOXy ([https://eclipse.org/eclipselink/#moxy](https://eclipse.org/eclipselink/#moxy)).
    We will use this library to marshal an instance of `Course` to JSON.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何将Java对象序列化为JSON然后再反序列化。JAXB在JDK中默认不支持JSON。我们将不得不使用一个支持JAXB API和JSON的外部库。这样的库之一是EclipseLink
    MOXy ([https://eclipse.org/eclipselink/#moxy](https://eclipse.org/eclipselink/#moxy))。我们将使用这个库将`Course`实例序列化为JSON。
- en: 'Open `pom.xml` and add the dependency on EclipseLink:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pom.xml`并添加对EclipseLink的依赖项：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to set the `javax.xml.bind.context.factory` property to make the
    JAXB implementation use EclipseLink''s `JAXBContextFactory`. Create the `jaxb.properties`
    file in the same package as the classes whose instances are to be marshalled.
    In this case, create the file in the `packt.jee.eclipse.jaxb.example` package.
    Set the following property in this file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置`javax.xml.bind.context.factory`属性，以便JAXB实现使用EclipseLink的`JAXBContextFactory`。在要序列化的实例的类所在的包中创建`jaxb.properties`文件。在这种情况下，在`packt.jee.eclipse.jaxb.example`包中创建该文件。在这个文件中设置以下属性：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is very important. If you do not set this property, then the example won''t
    work. Next, open `JAXBExample.java` and add the following method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要。如果你不设置这个属性，那么示例将无法工作。接下来，打开`JAXBExample.java`并添加以下方法：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Much of the code is the same as in the `doJAXBXml` method. Specific changes
    are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码与`doJAXBXml`方法中的代码相同。具体更改如下：
- en: We set the `marshaller` property for generating the JSON output (`application/json`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置了`marshaller`属性以生成JSON输出（`application/json`）
- en: We set another `marshaller` property to include the JSON root in the output
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们设置另一个`marshaller`属性以在输出中包含JSON根元素
- en: We set the corresponding properties on `unmarshaller`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`unmarshaller`上设置了相应的属性
- en: 'Modify the main method to call `doJAXBJson`, instead of `doJAXBXml`. When you
    run the application, you should see the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 修改主方法以调用`doJAXBJson`，而不是`doJAXBXml`。当你运行应用程序时，你应该看到以下输出：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have covered the basics of JAXB in this chapter. For a detailed tutorial
    on JAXB, refer to [https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了 JAXB 的基础知识。有关 JAXB 的详细教程，请参阅 [https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html)。
- en: JSON-B
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-B
- en: JSON-B is a new specification included in JEE 8\. Using a simple annotation
    you can convert Java objects to JSON and vice versa. JSON-B has one important
    annotation, `@JsonProperty`. Specifying this annotation for a class member marks
    it for serialization to or from JSON.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B 是 JEE 8 中包含的新规范。使用简单的注解，您可以转换 Java 对象到 JSON，反之亦然。JSON-B 有一个重要的注解，`@JsonProperty`。为类成员指定此注解，将其标记为序列化到或从
    JSON。
- en: JSON-B provides the `JsonbBuilder` class, using which you can perform actual
    serialization. Let's learn how to use JSON-B with a simple application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B 提供了 `JsonbBuilder` 类，使用它可以执行实际的序列化。让我们通过一个简单的应用程序来学习如何使用 JSON-B。
- en: A JSON-B example
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 JSON-B 示例
- en: 'Let''s create a Maven project, with Group Id as JAXBExample and Artifact Id
    as JSONBExampleProject. JSON-B is not a part of the JDK, so we will need to add
    Maven dependencies for libraries that provide JSON-B APIs and their implementation.
    In this example, we will use Eclipse''s Yasson ([https://projects.eclipse.org/projects/ee4j.yasson](https://projects.eclipse.org/projects/ee4j.yasson))
    implementation of JSON-B. We will add the following dependencies in `pom.xml`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Maven 项目，组 ID 为 JAXBExample，工件 ID 为 JSONBExampleProject。JSON-B 不是 JDK
    的一部分，因此我们需要添加提供 JSON-B API 和其实现的库的 Maven 依赖项。在这个例子中，我们将使用 Eclipse 的 Yasson ([https://projects.eclipse.org/projects/ee4j.yasson](https://projects.eclipse.org/projects/ee4j.yasson))
    对 JSON-B 的实现。我们将在 `pom.xml` 中添加以下依赖项：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dependency on `javax.json` from GlassFish is added because the `yasson` implementation
    depends on its JSON-P implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `yasson` 实现依赖于其 JSON-P 实现，因此添加了对 `javax.json` 的依赖。
- en: 'Let''s now create the `Course` and `Teacher` classes as we created them in
    the previous section for JAXB, but with JSON-B annotations. Create both classes
    in the `packt.jee.eclipse.jsonb.example` package. Here is the source code for the
    `Course` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建 `Course` 和 `Teacher` 类，就像我们在上一节中为 JAXB 创建它们一样，但这次使用 JSON-B 注解。在 `packt.jee.eclipse.jsonb.example`
    包中创建这两个类。以下是 `Course` 类的源代码：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have annotated members of the `Course` class with `@JsonbProperty`. If you
    want to change the name of the field in JSON then you can specify it as a parameter
    to `@JsonbProperty`; for example, in the previous code we are mapping the `teacher`
    field to the `course_teacher` name in JSON.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 `@JsonbProperty` 注解了 `Course` 类的成员。如果您想更改 JSON 中字段的名称，可以将它指定为 `@JsonbProperty`
    的参数；例如，在上面的代码中，我们将 `teacher` 字段映射到 JSON 中的 `course_teacher` 名称。
- en: 'The `Teacher` class is the same as the one we created in the section for JAXB.
    Let''s now create the main application class, called `JSONBExample`, in which
    we will convert an instance of `Course` to `String` and then from `String` back
    to an instance of the `Course` object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Teacher` 类与我们在 JAXB 部分创建的类相同。现在让我们创建主应用程序类，称为 `JSONBExample`，在其中我们将 `Course`
    类的实例转换为 `String`，然后再从 `String` 转换回 `Course` 对象的实例：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To serialize an instance of the `Course` class, we are first creating an instance
    of `JsonBuilder` and then calling the `toJson` method on that. To de-serialize the
    JSON representation of the `Course` class from String, we are calling `fromJson`
    on the same instance of `JsonBuilder`. If you run the application, you should
    see a JSON string for the course object we created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化 `Course` 类的实例，我们首先创建一个 `JsonBuilder` 实例，然后在该实例上调用 `toJson` 方法。要从 `Course`
    类的 JSON 表示形式反序列化字符串，我们在同一个 `JsonBuilder` 实例上调用 `fromJson`。如果您运行应用程序，应该会看到我们创建的课程对象的
    JSON 字符串。
- en: For further details on JSON-B, refer to [http://json-b.net/index.html.](http://json-b.net/index.html)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON-B 的更多详细信息，请参阅 [http://json-b.net/index.html.](http://json-b.net/index.html)
- en: RESTful web services
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful 网络服务
- en: 'We will start learning web services with RESTful services because they are
    widely used and are easy to implement. REST is not necessarily a protocol but
    an architectural style, and is typically based on HTTP. RESTful web services act
    on resources on the server, and actions are based on HTTP methods (`Get`, `Post`,
    `Put`, and `Delete`). The state of resources is transferred over HTTP in either
    XML or JSON format, although JSON is more popular. Resources on the server are
    identified by URLs. For example, to get details of a course with ID `10`, you
    can use the HTTP `GET` method with the following URL: `http://<server_address>:<port>/course/10`.
    Notice that the parameter is part of the base URL. To add a new `Course` or modify
    a `Course`, you can use either `POST` or `PUT` methods. Furthermore, the `DELETE`
    method can be used to delete a `Course` by using the same URL as that used for
    getting the course, that is, `http://<server_address>:<port>/course/10`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从RESTful服务开始学习Web服务，因为它们被广泛使用且易于实现。REST不一定是一个协议，而是一种架构风格，通常基于HTTP。RESTful
    Web服务在服务器上对资源进行操作，操作基于HTTP方法（`Get`、`Post`、`Put`和`Delete`）。资源的状态以XML或JSON格式通过HTTP传输，尽管JSON更受欢迎。服务器上的资源通过URL进行标识。例如，要获取ID为`10`的课程详细信息，你可以使用以下URL的HTTP
    `GET`方法：`http://<server_address>:<port>/course/10`。请注意，参数是基本URL的一部分。要添加新的`Course`或修改`Course`，你可以使用`POST`或`PUT`方法。此外，可以使用`DELETE`方法通过相同的URL删除`Course`，即用于获取课程的URL，即`http://<server_address>:<port>/course/10`。
- en: 'Resource URLs in RESTful web services can be nested too; for example, to get
    all courses in a particular department (with, say, an ID of `20`), the REST URL
    can be as follows: `http://<server_address>:<port>/department/20/courses`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务中的资源URL也可以嵌套；例如，要获取特定部门（例如ID为`20`）的所有课程，REST URL可以是以下形式：`http://<server_address>:<port>/department/20/courses`。
- en: Refer to [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)
    for more details on the properties of RESTful web services and HTTP methods used
    for acting on REST resources on the server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RESTful Web服务的属性和用于在服务器上操作REST资源的HTTP方法的更多详细信息，请参阅[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)。
- en: The Java specification for working with RESTful web services is called JAX-RS,
    Java API for RESTful services ([https://jax-rs-spec.java.net/](https://jax-rs-spec.java.net/)).
    Project Jersey ([https://jersey.java.net/](https://jersey.java.net/)) is the reference
    implementation of this specification. We will use this reference implementation this
    chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理RESTful Web服务的Java规范称为JAX-RS，即Java API for RESTful services ([https://jax-rs-spec.java.net/](https://jax-rs-spec.java.net/))。Project
    Jersey ([https://jersey.java.net/](https://jersey.java.net/))是该规范的参考实现。我们将使用这个参考实现在本章中。
- en: Creating RESTful web services using Jersey
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jersey创建RESTful Web服务
- en: We will create a web service for the *Course Management* example that we have
    been developing in this book. The web service will have methods to get all courses
    and create a new course. To keep the example simple, we will not write the data
    access code (you can use the JDBC or JDO APIs that we learned in previous chapters),
    but will hardcode the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本书中一直在开发的*课程管理*示例创建一个Web服务。该Web服务将包含获取所有课程和创建新课程的方法。为了使示例简单，我们不会编写数据访问代码（你可以使用我们在前几章中学到的JDBC或JDO
    API），而是将数据硬编码。
- en: 'First, create a Maven web project. Select File | New | Maven Project. Select
    the Create a Simple Project checkbox on the first page of the wizard and click
    Next:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个Maven Web项目。选择File | New | Maven Project。在向导的第一页上选择Create a Simple Project复选框，然后点击Next：
- en: '![](img/00189.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00189.jpeg)'
- en: 'Figure 9.2: Create a Maven project for a RESTful web service'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：为RESTful Web服务创建Maven项目
- en: Enter the project configuration details and click Finish. Make sure that the
    packaging is `war`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输入项目配置详细信息并点击Finish。确保打包方式为`war`。
- en: 'Since we are going to use the `Jersey` library for the JAX-RS implementation,
    we will add its Maven dependency into the project. Open `pom.xml` and add the
    following dependency:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`Jersey`库来实现JAX-RS，我们将将其Maven依赖项添加到项目中。打开`pom.xml`文件，并添加以下依赖项：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the JAX-RS `@Path` annotation, we can convert any Java class into a REST
    resource. The value passed to the `@Path` annotation is a relative URI of the
    resource. Methods in the implementation class, to be executed for different HTTP
    methods, are annotated with one of the following annotations: `@GET`, `@PUT`,
    `@POST`, or `@DELETE`. The `@Path` annotation can also be used at the method level
    for a sub-resource path (the main resource or the root resource path is at the
    class level, again using the `@Path` annotation). We can also specify the MIME
    type that previous methods produce/consume by using the `@Produces` or `@Consumes`
    annotations, respectively.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 的 `@Path` 注解，我们可以将任何 Java 类转换为 REST 资源。传递给 `@Path` 注解的值是该资源的相对 URI。实现类中的方法，用于执行不同的
    HTTP 方法，被以下注解之一标注：`@GET`、`@PUT`、`@POST` 或 `@DELETE`。`@Path` 注解也可以用于方法级别，用于子资源路径（主资源或根资源路径在类级别，再次使用
    `@Path` 注解）。我们还可以通过使用 `@Produces` 或 `@Consumes` 注解来分别指定先前方法产生的/消费的 MIME 类型。
- en: Before we create a web service implementation class, let's create some utility
    classes, more specifically in this case DTOs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建网络服务实现类之前，让我们创建一些实用类，更具体地说，在这个案例中是 DTOs。
- en: 'Create the `Course` and `Teacher` classes in the `packt.jee.eclipse.rest.ws.dto`
    package. We will also annotate them with the JAXB annotations. Here is the source code
    for the `Teacher` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `packt.jee.eclipse.rest.ws.dto` 包中创建 `Course` 和 `Teacher` 类。我们还将它们标注为 JAXB
    注解。以下是 `Teacher` 类的源代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the source code for the `Course` class, which we will use
    for marshalling to XML and JSON in the subsequent sections:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 `Course` 类的源代码，我们将在后续章节中将它用于序列化为 XML 和 JSON：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have annotated the `id` fields in both classes as `@XMLAttribute`. If objects
    of these classes are marshalled (converted from Java objects) to XML, `Course
    id` and `Teacher id` would be attributes (instead of elements) of the root element
    (`Course` and `Teacher`, respectively). If no field annotation is specified and
    if public getters/setters for an attribute are present, then it is considered
    an XML element with the same name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个类中的 `id` 字段上标注了 `@XMLAttribute`。如果这些类的对象被序列化（从 Java 对象转换为 XML），则 `Course
    id` 和 `Teacher id` 将是根元素（分别对应 `Course` 和 `Teacher`）的属性（而不是元素）。如果没有指定字段注解，并且存在属性的公共
    getter/setter，则它被视为具有相同名称的 XML 元素。
- en: We have specifically used the `@XMLElement` annotation for `name` fields because
    we want to rename them as `course_name` or `teacher_name` when marshalled to XML.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别使用了 `@XMLElement` 注解来标注 `name` 字段，因为我们希望在将它们序列化为 XML 时将它们重命名为 `course_name`
    或 `teacher_name`。
- en: Implementing a REST GET request
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 REST GET 请求
- en: 'Let''s now implement the RESTful web service class. Create the `CourseService`
    class in the `packt.jee.eclipse.rest.ws.services` package:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现 RESTful 网络服务类。在 `packt.jee.eclipse.rest.ws.services` 包中创建 `CourseService`
    类：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@Path` annotation specifies that resources made available by this class
    will be accessible by relative URI `"/course"`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Path` 注解指定了由此类提供的资源可以通过相对 URI `"/course"` 访问。'
- en: The `getCourse` method has many annotations. Let's discuss them one at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCourse` 方法有许多注解。让我们逐一讨论它们。'
- en: The `@GET` annotation specifies that when the relative URI (as specified by
    `@Path` on `CourseService` class) `"/course"` is called using the HTTP `GET` method,
    then this method will be invoked.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GET` 注解指定，当使用 HTTP `GET` 方法调用由 `CourseService` 类上的 `@Path` 指定的相对 URI `"/course"`
    时，将调用此方法。'
- en: '`@Produces` (`MediaType.APPLICATION_JSON`) specifies that this method generates
    a JSON output. If the client specifies the accepted MIME types, then this annotation
    would be used to resolve the method to be called, if more than one method is annotated
    with `@GET` (or, for that matter, any of the other HTTP method annotations). For
    example, if we have a method called `getCourseJSON` annotated with `@GET` , but
    producing data with different MIME types (as specified by `@Produces`), then the
    appropriate method will be selected on the basis of the MIME type requested by
    the client. The MIME type in the `@Produces` annotation also tells the JAX-RS
    implementation MIME type of the response to be created, when marshalling the Java
    object that is returned from that method. For example, in the `getCourse` method
    we return an instance of `Course`, and the MIME type specified in `@Produces`
    tells Jersey to generate an XML representation of this instance.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces` (`MediaType.APPLICATION_JSON`) 指定此方法生成 JSON 输出。如果客户端指定了接受的 MIME
    类型，则此注解将用于解析要调用的方法，如果多个方法都注有 `@GET`（或任何其他 HTTP 方法注解）。例如，如果我们有一个名为 `getCourseJSON`
    的方法，它注有 `@GET` 并生成具有不同 MIME 类型（由 `@Produces` 指定）的数据，则将根据客户端请求的 MIME 类型选择适当的方法。`@Produces`
    注解中的 MIME 类型还告诉 JAX-RS 实现当将返回给该方法的 Java 对象进行序列化时，要创建的响应的 MIME 类型。例如，在 `getCourse`
    方法中，我们返回 `Course` 类的实例，`@Produces` 中指定的 MIME 类型告诉 Jersey 生成此实例的 XML 表示形式。'
- en: The `@Path` annotation can also be used at the method level to specify sub-resources.
    The value specified in `@Path` at the method level is relative to the path value
    specified at the class level. The resource (in this case, `Course`) with ID `20`
    can be accessed as `/course/get/20`. The complete URL can be `http://<server-address>:<port>/<app-name>/course/get/10`.
    Parameter names in the path value are enclosed in `{}` in annotations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Path` 注解也可以在方法级别上使用，以指定子资源。在方法级别上指定的 `@Path` 值相对于类级别上指定的路径值是相对的。具有 ID `20`
    的资源（在这种情况下，`Course`）可以通过 `/course/get/20` 访问。完整的 URL 可以是 `http://<server-address>:<port>/<app-name>/course/get/10`。路径值中的参数名称在注解中以
    `{}` 包围。'
- en: Path parameters need to be identified in method arguments by using the `@PathParam`
    annotation and the name of the parameter as its value. The JAX-RS implementation
    framework matches the path parameters with arguments matching `@PathParam` annotations
    and appropriately passes parameter values to the method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 需要通过使用 `@PathParam` 注解和参数名称作为其值来在方法参数中标识路径参数。JAX-RS 实现框架将路径参数与匹配 `@PathParam`
    注解的参数进行匹配，并适当地将参数值传递给方法。
- en: To keep the example simple and to keep the focus on implementation of RESTful
    web services, we are not going to implement any business logic in this method.
    We could get data from the database by using, for example, JDO or JDBC APIs (and
    we have seen examples of how to use these APIs in earlier chapters), but we are
    just going to return some hardcoded data. The method returns an instance of the `Course`
    class. The JAX-RS implementation would convert this object into an XML representation
    by using JAXB when the data is finally returned to the client.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例简单并保持对 RESTful 网络服务实现的关注，我们不会在这个方法中实现任何业务逻辑。我们可以通过使用 JDO 或 JDBC API（我们在前面的章节中已经看到了如何使用这些
    API 的示例）从数据库中获取数据，但我们只是将返回一些硬编码的数据。该方法返回 `Course` 类的实例。当数据最终返回给客户端时，JAX-RS 实现将使用
    JAXB 将此对象转换为 XML 表示形式。
- en: 'We need to tell the Jersey framework what packages it needs to scan to look
    for REST resources. There are two ways to do this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉 Jersey 框架它需要扫描哪些包以查找 REST 资源。有两种方法可以做到这一点：
- en: Configuring the Jersey servlet in `web.xml` (see [https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet](https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet)).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `web.xml` 中配置 Jersey servlet（见 [https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet](https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet)）。
- en: For Servlet 3.x containers, we could create a subclass of `javax.ws.rs.core.Application`.
    Tomcat 8.0, which we have been using in this book, is a Servlet 3.x container.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Servlet 3.x 容器，我们可以创建 `javax.ws.rs.core.Application` 的子类。我们在这本书中使用过的 Tomcat
    8.0 是一个 Servlet 3.x 容器。
- en: We will use the second option to create a subclass of `Application`. However,
    instead of directly subclassing `Application`, we will subclass the `ResourceConfig`
    class of Jersey, which in turn extends `Application`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二种选项来创建 `Application` 的子类。然而，我们不会直接继承 `Application`，而是会继承 Jersey 的 `ResourceConfig`
    类，它反过来又扩展了 `Application`。
- en: 'Create the `CourseMgmtRESTApplication` class in the `packt.jee.eclipse.rest.ws`
    package:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `packt.jee.eclipse.rest.ws` 包中创建 `CourseMgmtRESTApplication` 类：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have used the `@ApplicationPath` annotation to specify URL mapping for REST
    services implemented using JAX-RS. All `@Path` URIs on resource implementation
    classes will be relative to this path. For example, the `"/course"` URI that we
    specified for the `CourseService` class would be relative to `"services"`, specified
    in the `@ApplicationPath` annotation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `@ApplicationPath` 注解来指定使用 JAX-RS 实现的 REST 服务的 URL 映射。资源实现类上的所有 `@Path`
    URI 都将相对于此路径。例如，我们为 `CourseService` 类指定的 `"/course"` URI 将相对于在 `@ApplicationPath`
    注解中指定的 `"services"` 路径。
- en: Before we deploy the application and test our service, we need to generate `web.xml`.
    Right-click on the project in Project Explorer and select Java EE Tools | Generate
    Deployment Descriptor Stub. This will create `web.xml` in the `WEB-INF` folder.
    We don't need to modify it for this example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序并测试我们的服务之前，我们需要生成 `web.xml`。在项目资源管理器中右键单击项目，选择 Java EE Tools | Generate
    Deployment Descriptor Stub。这将创建 `WEB-INF` 文件夹中的 `web.xml`。对于此示例，我们不需要修改它。
- en: Configure Tomcat in Eclipse as described in the *Installing Tomcat* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*, and in the *Configuring Tomcat in Eclipse* section of [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. To deploy the web application, right-click on the configured
    Tomcat server in the Servers view and select the Add and Remove option. Add the
    current project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第 1 章 *安装 Tomcat* 部分中 *介绍 JEE 和 Eclipse* 的说明，以及第 2 章 *在 Eclipse 中配置 Tomcat*
    部分中的说明配置 Eclipse 中的 Tomcat。要部署 Web 应用程序，在 Servers 视图中右键单击配置的 Tomcat 服务器，并选择 Add
    and Remove 选项。添加当前项目。
- en: Start the Tomcat server by right-clicking on the configured server in the `Servers`
    view and selecting Start.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `Servers` 视图中右键单击配置的服务并选择启动来启动 Tomcat 服务器。
- en: Testing the REST GET request in the browser
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中测试 REST GET 请求
- en: In this section, we will test the web service we created in the previous section
    in the browser. To test the web service, browse to `http://localhost:8080/CourseManagementREST/services/course/get/10`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试上一节创建的 Web 服务。要测试 Web 服务，请浏览到 `http://localhost:8080/CourseManagementREST/services/course/get/10`。
- en: 'You should see the following XML displayed in the browser:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在浏览器中看到以下 XML：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead of generating an XML response, let''s say we want to create a JSON
    response, because it would be much easier to consume a JSON response from JavaScript
    in a web page than an XML response. To create a JSON response, we need to change
    the value of the `@Produces` annotation in the `CourseService` class. Currently,
    it is set to `MediaType.APPLICATION_XML` and we want to set it to `MediaType.APPLICATION_JSON`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想生成 XML 响应，而是想创建一个 JSON 响应，因为从网页中的 JavaScript 消费 JSON 响应比 XML 响应要容易得多。要创建
    JSON 响应，我们需要更改 `CourseService` 类中 `@Produces` 注解的值。目前，它设置为 `MediaType.APPLICATION_XML`，我们希望将其设置为
    `MediaType.APPLICATION_JSON`：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to add libraries to create the JSON response. Open the `pom.xml`
    of the project and add the following dependency:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加库来创建 JSON 响应。打开项目的 `pom.xml` 文件并添加以下依赖项：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Restart the Tomcat server and browse to the `http://localhost:8080/CourseManagementREST/services/course/get/10`
    URL again. This time, you should see a JSON response:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 Tomcat 服务器，再次浏览到 `http://localhost:8080/CourseManagementREST/services/course/get/10`
    URL。这次，你应该看到一个 JSON 响应：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s create two versions of the `getCourse` method, one that produces XML
    and the other that produces JSON. Replace the `getCourse` function with the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `getCourse` 方法的两个版本，一个生成 XML，另一个生成 JSON。用以下代码替换 `getCourse` 函数：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have added the `createDummyCourse` method, which has the same code that
    we had earlier in the `getCourse` method. We now have two versions of the `getCourse`
    method: `getCourseXML` and `getCourseJSON`, producing the XML and JSON responses,
    respectively.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `createDummyCourse` 方法，该方法与我们之前在 `getCourse` 方法中使用的代码相同。现在我们有两个版本的 `getCourse`
    方法：`getCourseXML` 和 `getCourseJSON`，分别生成 XML 和 JSON 响应。
- en: Creating a Java client for the REST GET web service
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 REST GET 网络服务创建 Java 客户端
- en: 'Let''s now create a Java client application that calls the previous web service.
    Create a simple Maven project and call it `CourseManagementRESTClient`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个 Java 客户端应用程序，该应用程序调用先前的 Web 服务。创建一个简单的 Maven 项目，并将其命名为 `CourseManagementRESTClient`：
- en: '![](img/00190.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00190.jpeg)'
- en: 'Figure 9.3: Create a JAX-RS client project'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：创建JAX-RS客户端项目
- en: 'Open `pom.xml` and add a dependency for the Jersey client module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `pom.xml` 并添加对 Jersey 客户端模块的依赖项：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a Java class called `CourseManagementRESTClient` in the `packt.jee.eclipse.rest.ws.client`
    package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `packt.jee.eclipse.rest.ws.client` 包中创建一个名为 `CourseManagementRESTClient` 的
    Java 类：
- en: '![](img/00191.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00191.jpeg)'
- en: 'Figure 9.4: Create a REST client main class'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：创建REST客户端主类
- en: 'You could invoke a RESTful web service using `java.net.HttpURLConnection` or
    other external HTTP client libraries. But JAX-RS client APIs make this task a
    lot easier, as you can see in the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `java.net.HttpURLConnection` 或其他外部 HTTP 客户端库来调用 RESTful Web 服务。但 JAX-RS
    客户端 API 使这项任务变得容易得多，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For a detailed description of how to use the JAX-RS client APIs, refer to [https://jersey.java.net/documentation/latest/client.html](https://jersey.java.net/documentation/latest/client.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用 JAX-RS 客户端 API 的详细说明，请参阅 [https://jersey.java.net/documentation/latest/client.html](https://jersey.java.net/documentation/latest/client.html)。
- en: Implementing a REST POST request
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现REST POST请求
- en: We saw an example of how to implement an HTTP `GET` request by using JAX-RS.
    Let's now implement a `POST` request. We will implement a method to add a course
    in the `CourseService` class, which is our web service implementation class in the `CourseManagementREST`
    project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用 JAX-RS 实现HTTP `GET` 请求的示例。现在让我们实现一个 `POST` 请求。我们将在 `CourseService`
    类中实现一个添加课程的方法，这是我们的 `CourseManagementREST` 项目中的 Web 服务实现类。
- en: 'As in the case of the `getCourse` method, we won''t actually access the database
    but will simply write a dummy method to save the data. Again, the idea is to keep
    the example simple and focus only on the JAX-RS APIs and implementation. Open
    `CourseService.java` and add the following methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `getCourse` 方法的情况一样，我们实际上不会访问数据库，而只是简单地编写一个虚拟方法来保存数据。再次强调，我们的目的是保持示例简单，并仅关注
    JAX-RS API 和实现。打开 `CourseService.java` 并添加以下方法：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `addCourse` method produces and consumes JSON data. It is invoked when
    the resource path (web service endpoint URL) has the following relative path:
    `"/course/add"`. Recall that the `CourseService` class is annotated with the following
    path: `"/course"`. So, the relative path for the `addCourse` method becomes the
    path specified at the class level and at the method level (which in this case
    is `"add"`). We are returning a new instance of `Course` from `addCourse`. Jersey
    creates the appropriate JSON representation of this class on the basis of JAXB
    annotations in the `Course` class. We have already added the dependency in the
    project on a Jersey module that handles JSON format (in `pom.xml`, we added a
    dependency on `jersey-media-json-jackson`).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCourse` 方法生成并消费 JSON 数据。当资源路径（Web 服务端点 URL）具有以下相对路径时调用它：`"/course/add"`。回想一下，`CourseService`
    类注解了以下路径：`"/course"`。因此，`addCourse` 方法的相对路径成为类级别和方法级别（在这种情况下是 `"add"`)指定的路径。我们从
    `addCourse` 返回 `Course` 的新实例。Jersey 根据类 `Course` 中的 JAXB 注解创建此类的适当 JSON 表示形式。我们已经在项目中添加了对处理
    JSON 格式的 Jersey 模块的依赖项（在 `pom.xml` 中，我们添加了对 `jersey-media-json-jackson` 的依赖项）。'
- en: Restart the Tomcat server for these changes to take effect.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动 Tomcat 服务器以使这些更改生效。
- en: Writing a Java client for the REST POST web service
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 REST POST Web 服务客户端
- en: 'We will now add a test method in the `CourseManagementClient` class, in the `CourseManagementRESTClient` project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 `CourseManagementClient` 类中添加一个测试方法，在 `CourseManagementRESTClient` 项目中：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need to send input data (`Course` information) in JSON format. Although we
    have hardcoded JSON in our example, you could use JAXB or any other library that
    converts a Java object into JSON.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以 JSON 格式发送输入数据（`Course` 信息）。尽管我们在示例中硬编码了 JSON，但你也可以使用 JAXB 或其他任何将 Java
    对象转换为 JSON 的库。
- en: 'Note that we are executing the request using the HTTP `POST` method `webTarget.request().post(...)`.
    We have also set the content type of the request to `"application/JSON"`, because
    our web service to add `Course` consumes the JSON format. We have done this by
    creating the entity and setting its content type to `JSON`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 HTTP `POST` 方法执行请求 `webTarget.request().post(...)`。我们还已将请求的内容类型设置为
    `"application/JSON"`，因为我们的 Web 服务添加 `Course` 消费 JSON 格式。我们通过创建实体并设置其内容类型为 `JSON`
    来完成此操作：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now modify the `main` method of the `CourseManagementClient` class to call the `testAddCourseJSON`
    method. Right-click on the class and select Run As | Java Application. You should
    see `Course` information in JSON format printed in the console. Also, check the
    Tomcat console in Eclipse. There, you should see the console message that we printed
    in the `CourseService.dummyAddCourse` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 `CourseManagementClient` 类的 `main` 方法以调用 `testAddCourseJSON` 方法。在类上右键单击并选择
    Run As | Java Application。你应该在控制台看到以 JSON 格式打印的 `Course` 信息。同时，检查 Eclipse 中的 Tomcat
    控制台。在那里，你应该看到我们在 `CourseService.dummyAddCourse` 方法中打印的控制台消息。
- en: Invoking a POST RESTful web service from JavaScript
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 JavaScript 调用 POST RESTful 网络服务
- en: 'Here is a simple example of how to invoke our RESTful web service to add a
    course from JavaScript:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何从 JavaScript 调用我们的 RESTful 网络服务以添加课程的简单示例：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you want to test this code, create an HTML file, say `addCourseJSON.html`,
    in the `src/main/webapp` folder of the `CourseManagementREST` project. Then, browse
    to `http://localhost:8080/CourseManagementREST/addCourseJSON.html`. Click the Add
    Course using JSON button. The response is displayed in the same page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试这段代码，请创建一个 HTML 文件，例如 `addCourseJSON.html`，在 `CourseManagementREST` 项目的
    `src/main/webapp` 文件夹中。然后，浏览到 `http://localhost:8080/CourseManagementREST/addCourseJSON.html`。点击“使用
    JSON 添加课程”按钮。响应将在同一页面上显示。
- en: Creating a RESTful web service with form POST
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单 POST 创建 RESTful 网络服务
- en: 'We have created RESTful web services so far with HTTP `GET` and `POST` methods.
    The web service using the `POST` method took input in the JSON format. We can
    also have the `POST` method in the web service take input from HTML form elements.
    Let''s create a method that handles the data posted from a HTML form. Open `CourseService.java`
    from the `CourseManagementREST` project. Add the following method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止已经创建了使用 HTTP `GET` 和 `POST` 方法的 RESTful 网络服务。使用 `POST` 方法的网络服务以 JSON 格式接收输入。我们也可以让网络服务的
    `POST` 方法从 HTML 表单元素接收输入。让我们创建一个处理从 HTML 表单提交的数据的方法。打开 `CourseManagementREST`
    项目的 `CourseService.java` 文件。添加以下方法：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method is marked to handle form data by specifying the `@Consume` annotation
    with the following value: `"application/x-www-form-urlencoded"`. Just as we mapped
    parameters in the path in the `getCourse` method with `@PathParam`, we map the
    form fields to method arguments using the `@FormParam` annotation. Finally, once
    we successfully save the course, we want the client to be redirected to `addCourseSuccess.html`.
    We do this by calling the `Response.seeOther` method. The `addCourseFromForm`
    method returns the `Response` object.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过指定具有以下值的 `@Consume` 注解来标记处理表单数据：`"application/x-www-form-urlencoded"`。正如我们在
    `getCourse` 方法中使用 `@PathParam` 映射路径参数一样，我们使用 `@FormParam` 注解将表单字段映射到方法参数。最后，一旦我们成功保存课程，我们希望客户端重定向到
    `addCourseSuccess.html`。我们通过调用 `Response.seeOther` 方法来实现这一点。`addCourseFromForm`
    方法返回 `Response` 对象。
- en: Refer to [https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html)
    for more information on how to configure `Response` from the web service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何配置网络服务中的 `Response` 的更多信息，请参阅 [https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html)。
- en: 'We need to create `addCourseSuccess.html` to complete this example. Create
    this file in the `src/main/webapp` folder of the `CourseManagementREST` project
    with the following content:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建 `addCourseSuccess.html` 以完成此示例。在 `CourseManagementREST` 项目的 `src/main/webapp`
    文件夹中创建此文件，并包含以下内容：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating a Java client for a form-encoded RESTful web service
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为表单编码的 RESTful 网络服务创建 Java 客户端
- en: 'Let''s now create a test method for calling the previous web service that consumes
    form-encoded data. Open `CourseManagementClient.java` from the `CourseManagementRESTClient`
    project and add the following method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为调用之前消耗表单编码数据的网络服务创建一个测试方法。打开 `CourseManagementRESTClient` 项目的 `CourseManagementClient.java`
    文件并添加以下方法：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that the form data is created by creating an instance of the `Form`
    object and setting its parameters. The `POST` request is encoded with `MediaType.APPLICATION_FORM_URLENCODED`,
    which has the following value: `"application/x-www-form-urlencoded"`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表单数据是通过创建 `Form` 对象的实例并设置其参数来创建的。`POST` 请求使用 `MediaType.APPLICATION_FORM_URLENCODED`
    编码，其值为 `"application/x-www-form-urlencoded"`。
- en: Now, modify the `main` method to call `testAddCourseForm`. Then, run the application
    by right-clicking the class and selecting Run As | Java Application. You should
    see the success message (from `addCourseSuccess.html`) printed in the console.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改`main`方法以调用`testAddCourseForm`。然后，通过右键单击类并选择“运行方式”|“Java应用程序”来运行应用程序。你应该在控制台中看到成功消息（来自`addCourseSuccess.html`）被打印出来。
- en: A RESTful web service using JSON-B
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON-B的RESTful网络服务
- en: In the previous section, we implemented the RESTful web service using JAXB.
    As mentioned earlier, JEE 8 has added a new specification for JSON binding, called
    JSON-B. In this section, we will learn how to modify our web service to use JSON-B.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用JAXB实现了RESTful网络服务。如前所述，JEE 8增加了一个新的JSON绑定规范，称为JSON-B。在本节中，我们将学习如何修改我们的网络服务以使用JSON-B。
- en: 'There is really not much that we need to change in the code to switch from
    JAXB to JSON-B. We will need to use the `@JsonbProperty` annotation of JSON-B
    to specify field binding in the `Course` class, instead of the` @XmlAttribute`
    annotation of JAXB. Then, we will need to add Maven dependencies to include libraries
    that provide JSON-B APIs and its implementations. Replace the dependencies section
    in pom.xml with the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从JAXB切换到JSON-B，实际上我们不需要在代码中做太多更改。我们需要使用JSON-B的`@JsonbProperty`注解在`Course`类中指定字段绑定，而不是使用JAXB的`@XmlAttribute`注解。然后，我们需要添加Maven依赖项以包含提供JSON-B
    API及其实现的库。将pom.xml中的依赖项部分替换为以下内容：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Dependency on `jersey-container-servlet` has not changed. However, we have
    replaced dependency on `jersey-media-json-jackson` with` jersey-media-json-binding` and `jersey-hk2`.
    The Jersey framework automatically handles conversion of Java objects to JSON
    when the web service method is annotated with:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对`jersey-container-servlet`的依赖没有改变。然而，我们已经用`jersey-media-json-binding`和`jersey-hk2`替换了对`jersey-media-json-jackson`的依赖。当网络服务方法被注解时，Jersey框架会自动处理Java对象到JSON的转换：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is specified in the `CourseService` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`CourseService`类中进行了指定。
- en: A separate project for this section, named `CourseManagementREST-JSONB`, is
    made available in the accompanying source code for this chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的配套源代码中，为这一节创建了一个名为`CourseManagementREST-JSONB`的独立项目。
- en: SOAP web services
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP网络服务
- en: '**Simple Object Access Protocol** (**SOAP**) is a specification from **World
    Wide Web Consortium** (**W3C**) ([http://www.w3.org/TR/2007/REC-soap12-part0-20070427/](http://www.w3.org/TR/2007/REC-soap12-part0-20070427/)).
    Although we are referring to SOAP-based web services here, SOAP is one of the
    specifications used to implement XML-based web services. There are a few other
    specifications required to implement SOAP web services, which we will see later.
    One of the premises of SOAP web services is the dynamic discovery and invocation
    of services. For example, an application can look for a service from the central
    directory and invoke it dynamically. However, in practice, very few enterprises
    would be willing to invoke services dynamically without testing them, so this
    aspect of SOAP web services is less utilized.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）是来自**万维网联盟**（**W3C**）的规范（[http://www.w3.org/TR/2007/REC-soap12-part0-20070427/](http://www.w3.org/TR/2007/REC-soap12-part0-20070427/)）。尽管我们在这里讨论的是基于SOAP的网络服务，但SOAP是实现基于XML的网络服务所使用的规范之一。还有几个其他规范是实现SOAP网络服务所必需的，我们将在后面看到。SOAP网络服务的一个前提是服务的动态发现和调用。例如，一个应用程序可以从中央目录中查找服务并动态调用它。然而，在实践中，很少有企业愿意在没有测试的情况下动态调用服务，因此SOAP网络服务的这一方面使用较少。'
- en: W3C has defined many specifications for SOAP web services, for example, specifications
    for messages, auto discovery, security, and service orchestration. However, at
    a minimum, we need to understand the following specification before we develop
    SOAP web services.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: W3C为SOAP网络服务定义了许多规范，例如消息、自动发现、安全和服务编排的规范。然而，在开发SOAP网络服务之前，我们至少需要了解以下规范。
- en: SOAP
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP
- en: 'SOAP defines the format of a message exchange between the web service provider
    and the consumer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP定义了网络服务提供者和消费者之间消息交换的格式：
- en: '![](img/00192.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00192.jpeg)'
- en: 'Figure 9.5: SOAP message structure'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：SOAP消息结构
- en: The top element in a **SOAP Message** is **SOAP Envelope**. It contains a **SOAP
    Header (Optional)** and a **SOAP Body**. The **SOAP Body** actually contains the
    message payload (for processing by the consumer) and optionally **SOAP Fault (Optional)**,
    if there is any error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP消息**的顶级元素是**SOAP Envelope**。它包含一个可选的**SOAP Header**和一个**SOAP Body**。实际上，**SOAP
    Body**包含消息有效负载（供消费者处理）以及可选的**SOAP Fault**（可选），如果有任何错误。'
- en: The SOAP header provides extensibility to the SOAP message. It can contain information
    such as user credentials, transaction management, and message routing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP头部为SOAP消息提供了扩展性。它可以包含用户凭据、事务管理和消息路由等信息。
- en: WSDL
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WSDL
- en: 'As the name suggests, **Web Service Description Language** (**WSDL**) describes
    web services; in particular, it describes data types used (schemas), input and
    output messages, operations (methods), and binding and service endpoints:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**Web服务描述语言**（**WSDL**）描述Web服务；特别是，它描述了使用的数据类型（模式）、输入和输出消息、操作（方法）以及绑定和服务端点：
- en: '![](img/00193.gif)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00193.gif)'
- en: 'Figure 9.6: WSDL structure'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：WSDL结构
- en: 'Although you don''t necessarily need to understand the details of WSDL when
    creating web services in Java, it is good to know the basic structure of WSDL.
    WSDLs are typically meant to be produced and processed by programs, and developers
    are not expected to hand-code them. Here are some of the elements in WSDL:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Java中创建Web服务时您不一定需要了解WSDL的详细信息，但了解WSDL的基本结构是很好的。WSDL通常旨在由程序生成和处理，开发者不期望手动编写它们。以下是WSDL中的一些元素：
- en: '`definitions`: This is the root element of WSDL.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`定义`: 这是WSDL的根元素。'
- en: '`Import`: This element allows you to import elements from an external file.
    This way, you can make the WSDL file modular.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`导入`: 此元素允许您从外部文件导入元素。这样，您可以使WSDL文件模块化。'
- en: '`Types`: This element defines the schema for different data types used in the
    WSDL.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`: 此元素定义了WSDL中使用的不同数据类型的模式。'
- en: '`Messages`: This element defines the format of input and output messages exchanged
    between the web service and the client.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`消息`: 此元素定义了Web服务和客户端之间交换的输入和输出消息的格式。'
- en: '`PortType`: This defines methods or operations supported by the web service.
    Each operation in `PortType` can declare request and response messages. Operations
    in `PortType` refer to messages defined in a message element.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortType`: 此定义了Web服务支持的方法或操作。`PortType`中的每个操作都可以声明请求和响应消息。`PortType`中的操作引用在消息元素中定义的消息。'
- en: Although in *Figure 9.6*, the `binding` element looks the same as `PortType`,
    it actually specifies the transport protocol bound to operations and message type
    (**remote procedure call** or **document type**) and encoding (encoded or literal)
    for messages of each operation declared in `PortType`. The typical transport protocol
    is HTTP, but it could be other protocols such as JMS and SMTP. The difference
    between the RPC and document types is that the RPC message type contains the name
    of the remote method in the message, whereas the document type does not contain
    the method name. The name of the method to process the payload in a document type
    message is either derived from the endpoint URL or from information in the header.
    However, there is another type called **document wrapped**, which does contain the
    name of the method as the enclosing element for the actual message payload.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在*图9.6*中，`绑定`元素看起来与`PortType`相同，但它实际上指定了绑定到操作和消息类型（**远程过程调用**或**文档类型**）以及消息的编码（编码或文本）的传输协议，这些操作和消息类型是在`PortType`中声明的。典型的传输协议是HTTP，但它也可能是其他协议，如JMS和SMTP。RPC和文档类型之间的区别在于，RPC消息类型包含消息中的远程方法名称，而文档类型不包含方法名称。处理文档类型消息中的有效负载的方法名称要么是从端点URL中派生的，要么是从头部信息中获取的。然而，还有一种称为**文档包装**的类型，它确实包含方法名称作为实际消息有效负载的封装元素。
- en: The `Service` element contains the actual location of each web service endpoint.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`服务`元素包含每个Web服务端点的实际位置。'
- en: UDDI
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDDI
- en: '**Universal Description, Discovery and Integration** (**UDDI**) is a directory
    of web services where you can publish your own web services or search for existing
    web services. The directory could be global or could be local to the enterprise.
    UDDI is also a web service with operations supported for publishing and searching
    contents.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用描述、发现与集成**（**UDDI**）是一个Web服务目录，您可以在其中发布自己的Web服务或搜索现有的Web服务。该目录可以是全球性的，也可以是企业本地的。UDDI也是一个支持发布和搜索内容的Web服务。'
- en: We will not be focusing on UDDI in this book, but you can visit [http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226](http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226)
    for more information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将不会重点介绍UDDI，但您可以访问[http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226](http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226)获取更多信息。
- en: Developing web services in Java
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中开发Web服务
- en: There are many frameworks around for developing web services in Java. New frameworks
    have evolved as specifications have changed. Some of the popular frameworks for
    developing web services in Java over the years are Apache Axis ([https://axis.apache.org/axis/](https://axis.apache.org/axis/)),
    Apache Axis2 ([http://axis.apache.org/axis2/java/core/](http://axis.apache.org/axis2/java/core/)),
    Apache CFX ([http://cxf.apache.org/](http://cxf.apache.org/)), and GlassFish Metro
    ([https://metro.java.net/](https://metro.java.net/)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中开发网络服务有许多框架。随着规范的改变，新的框架不断涌现。多年来，Java 开发网络服务的流行框架包括 Apache Axis ([https://axis.apache.org/axis/](https://axis.apache.org/axis/))、Apache
    Axis2 ([http://axis.apache.org/axis2/java/core/](http://axis.apache.org/axis2/java/core/))、Apache
    CFX ([http://cxf.apache.org/](http://cxf.apache.org/)) 和 GlassFish Metro ([https://metro.java.net/](https://metro.java.net/))。
- en: Earlier implementations of web service frameworks were based on the **JAX-RPC**
    (**Java API for XML-based RPC**) specification ([http://www.oracle.com/technetwork/java/docs-142876.html](http://www.oracle.com/technetwork/java/docs-142876.html)).
    JAX-RPC was replaced with **Java API for XML Web Services** (**JAX-WS**) in JEE
    5\. JAX-WS makes development of web services easier by supporting annotations.
    In this chapter, we will learn how to create and consume web services using JAX-WS.
    Continuing with the example (*Course Management*) that we have been following
    in this book, we will create web services to get all courses and add new courses.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 早期网络服务框架的实现基于 **JAX-RPC** （**基于 XML 的 RPC 的 Java API**）规范 ([http://www.oracle.com/technetwork/java/docs-142876.html](http://www.oracle.com/technetwork/java/docs-142876.html))。JAX-RPC
    在 JEE 5 中被 **Java API for XML Web Services** （**JAX-WS**）所取代。JAX-WS 通过支持注解使网络服务的开发变得更加容易。在本章中，我们将学习如何使用
    JAX-WS 创建和消费网络服务。继续使用本书中一直跟踪的示例（*课程管理*），我们将创建网络服务以获取所有课程并添加新课程。
- en: 'First, let''s create a Maven web project. Select File | New | Maven Project.
    Select the Create a simple project option:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 Maven 网络项目。选择 File | New | Maven Project。选择创建一个简单项目的选项：
- en: '![](img/00194.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00194.jpeg)'
- en: 'Figure 9.7: New Maven Project'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：新 Maven 项目
- en: 'Click Next. Enter Group Id, Artifact id, and Version in the next page. Select
    the `war` packaging:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”。在下一页中输入 Group Id、Artifact id 和 Version。选择 `war` 打包方式：
- en: '![](img/00195.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00195.jpeg)'
- en: 'Figure 9.8: Enter artifact details'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：输入工件详情
- en: Click Finish to complete the wizard.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“完成”以完成向导。
- en: Creating a web service implementation class
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络服务实现类
- en: JAX-WS annotations were added in Java EE 5.0\. Using these annotations, we can
    turn any Java class (including POJOs) into a web service. Use the `@Webservice`
    annotation to make any Java class a web service. This annotation can be used either
    on an interface or on a Java class. If a Java class is annotated with `@Webservice`,
    then all public methods in the class are exposed in the web service. If a Java
    interface is annotated with `@Webservice`, then the implementation class still
    needs to be annotated with `@Webservice` and with the `endpointInterface` attribute
    and its value as the interface name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS 注解是在 Java EE 5.0 中添加的。使用这些注解，我们可以将任何 Java 类（包括 POJOs）转换为网络服务。使用 `@Webservice`
    注解将任何 Java 类转换为网络服务。这个注解可以用于接口或 Java 类上。如果一个 Java 类被 `@Webservice` 注解，那么该类中所有的公共方法都会在网络服务中暴露。如果一个
    Java 接口被 `@Webservice` 注解，那么实现类仍然需要被 `@Webservice` 注解，并且需要 `endpointInterface`
    属性及其值为接口名称。
- en: 'Before we create the web service implementation class, let''s create a few
    helper classes. The first one is the `Course` data transfer object. This is the
    same class that we created in previous chapters. Create the `Course` class in
    the `packt.jee.eclipse.ws.soap` package:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建网络服务实现类之前，让我们创建几个辅助类。第一个是 `Course` 数据传输对象。这是我们在前几章中创建的相同类。在 `packt.jee.eclipse.ws.soap`
    包中创建 `Course` 类：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now create the web service implementation class `CourseManagementService`
    in the `packt.jee.eclipse.ws.soap` package:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `packt.jee.eclipse.ws.soap` 包中创建网络服务实现类 `CourseManagementService`：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`CourseManagementService` has the following two methods: `getCourses` and `getCourse`.
    To keep the example simple, we have hardcoded the values, but you can very well
    fetch data from a database, for example, using the JDBC or JDO APIs that we have
    discussed earlier in this book. The class is annotated with `@WebService`, which
    tells the JAX-WS implementation to treat this class as a web service. All methods
    in this class will be exposed as web service operations. If you want a specific
    method to be exposed, you could use `@WebMethod`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseManagementService`有两个方法：`getCourses`和`getCourse`。为了使示例简单，我们硬编码了值，但你完全可以从数据库中获取数据，例如使用我们在这本书前面讨论过的JDBC或JDO
    API。该类使用`@WebService`注解，这告诉JAX-WS实现将此类视为网络服务。这个类中的所有方法都将公开作为网络服务操作。如果你想公开特定的方法，可以使用`@WebMethod`。'
- en: Using JAX-WS reference implementation (Glassfish Metro)
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAX-WS参考实现（Glassfish Metro）
- en: Annotating a class with `@WebService` is not enough to implement a web service.
    We need a library that implements JAX-WS specification. There are a number of
    JAX-WS frameworks available, for example, Axis2, Apache CFX, and Glassfish Metro.
    In this chapter, we will use the Glassfish Metro implementation, which is also
    a reference implementation ([https://jax-ws.java.net/](https://jax-ws.java.net/))
    of JAX-WS from Oracle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`@WebService`注解一个类不足以实现网络服务。我们需要一个实现JAX-WS规范的库。有多个JAX-WS框架可供选择，例如Axis2、Apache
    CFX和Glassfish Metro。在本章中，我们将使用Glassfish Metro实现，它也是Oracle提供的JAX-WS参考实现([https://jax-ws.java.net/](https://jax-ws.java.net/))。
- en: 'Let''s add Maven dependency for the JAX-WS framework. Open `pom.xml` and add
    the following dependency:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加JAX-WS框架的Maven依赖项。打开`pom.xml`并添加以下依赖项：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the previous version number with the latest version of the framework.
    The Metro framework also requires you to declare web service endpoints in the
    configuration file called `sun-jaxws.xml`. Create the `sun-jaxws.xml` file in the `src/main/webapp/WEB-INF`
    folder and add the endpoint as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前的版本号替换为框架的最新版本。Metro框架还要求你在名为`sun-jaxws.xml`的配置文件中声明网络服务端点。在`src/main/webapp/WEB-INF`文件夹中创建`sun-jaxws.xml`文件，并按如下方式添加端点：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The endpoint implementation is the fully qualified name of our web service implementation
    class. `url-pattern` is just like servlet mapping that you specify in `web.xml`.
    In this case, any relative URL starting with `/courseService` would result in
    the invocation of our web service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 端点实现是我们网络服务实现类的完全限定名称。`url-pattern`就像你在`web.xml`中指定的servlet映射。在这种情况下，任何以`/courseService`开头的相对URL都会导致调用我们的网络服务。
- en: Inspecting WSDL
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查WSDL
- en: 'We are done with implementing our web service. As you can see, JAX-WS really
    makes it very easy to develop web services. Let''s now inspect the WSDL of our
    web service. Configure Tomcat in Eclipse as described in *Installing Tomcat* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse* and in the *Configuring Tomcat in Eclipse* section of [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. To deploy the web application, right-click on the configured
    Tomcat server in Servers view and select the Add and Remove option:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了网络服务的实现。正如你所看到的，JAX-WS确实使得开发网络服务变得非常容易。现在让我们检查一下我们网络服务的WSDL。按照[第1章](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中“安装Tomcat”部分和[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中“在Eclipse中配置Tomcat”部分的描述，在Eclipse中配置Tomcat。要部署网络应用程序，在服务器视图中右键单击配置的Tomcat服务器，并选择添加和移除选项：
- en: '![](img/00196.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00196.jpeg)'
- en: 'Figure 9.9: Add a project to Tomcat'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：将项目添加到Tomcat
- en: Add the project and click Finish.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目并点击完成。
- en: Start the Tomcat server by right-clicking on the configured server in the Servers
    view and selecting Start.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在服务器视图中右键单击配置的服务并选择启动来启动Tomcat服务器。
- en: 'To inspect the WSDL of our web service, browse to `http://localhost:8080/CourseMgmtWSProject/courseService?wsdl`
    (assuming that Tomcat is running on port `8080`). The following WSDL should be
    generated (see the description following *Figure 9.6* in the <q class="calibre207">WSDL</q> section
    to understand the structure of the WSDL generated here):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们网络服务的WSDL，请浏览到`http://localhost:8080/CourseMgmtWSProject/courseService?wsdl`（假设Tomcat运行在端口`8080`）。以下WSDL应该被生成（参见WSDL部分中*图9.6*之后的描述，以了解此处生成的WSDL的结构）：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice that the schema (see the definitions of the `/types/xsd:schemas` element)
    for this web service is imported in the previous WSDL. You can see the schema
    generated at `http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此Web服务的模式（参见`/types/xsd:schemas`元素的定义）已导入到之前的WSDL中。您可以在`http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`中看到生成的模式：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The schema document defines data types for the `getCourse` and `getCourses`
    methods and their responses (`getCoursesResponse` and `getCourseResponse`), and
    also for the `Course` class. It also declares members of the `Course` data type
    (`id`, `credits`, and `name`). Notice that the `getCourse` data type has one child
    element (which is an argument to the call to the `getCourse` method in `CourseManagementService`)
    called `arg0`, which is actually the course ID of the `int` type. Further, notice the
    definition of `getCoursesResponse`. In our implementation class, `getCourses`
    returns `List<Course>`, which is translated in WSDL (or types in WSDL) as a sequence
    of course types.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模式文档定义了`getCourse`和`getCourses`方法及其响应（`getCoursesResponse`和`getCourseResponse`）以及`Course`类的数据类型。它还声明了`Course`数据类型的成员（`id`、`credits`和`name`）。请注意，`getCourse`数据类型有一个子元素（它是`CourseManagementService`中对`getCourse`方法的调用参数），称为`arg0`，实际上是`int`类型的课程ID。此外，请注意`getCoursesResponse`的定义。在我们的实现类中，`getCourses`返回`List<Course>`，在WSDL（或WSDL中的类型）中将其转换为课程类型的序列。
- en: The following four messages are defined in the previous WSDL: `getCourses`,
    `getCoursesResponse`, `getCourse`, and `getCourseResponse`. Each message contains
    a part element that refers to data types declared in types (or schema).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的WSDL中定义了以下四个消息：`getCourses`、`getCoursesResponse`、`getCourse`和`getCourseResponse`。每个消息都包含一个部分元素，该元素引用在`types`（或schema）中声明的数据类型。
- en: The `PortType` name is the same as the web service implementation class called
    `CourseManagementService` and operations of the port are the same as public methods
    of the class. The input and output of each operation refers to messages already
    defined in the WSDL.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`PortType`名称与名为`CourseManagementService`的Web服务实现类相同，端口的操作与类的公共方法相同。每个操作的输入和输出都引用WSDL中已定义的消息。'
- en: The binding defines the network transport type, which in this case is HTTP,
    and the style of message in the SOAP body, which is of the document type. We have
    not defined any message type in our web service implementation, but the JAX-WS
    reference implementation (Glassfish Metro) has set a default message type to `document`.
    Binding also defines the message encoding type for the input and output messages
    of each operation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定定义了网络传输类型，在这个例子中是HTTP，以及SOAP体中的消息样式，它是文档类型。在我们的Web服务实现中，我们没有定义任何消息类型，但JAX-WS参考实现（Glassfish
    Metro）已将默认消息类型设置为`document`。绑定还定义了每个操作的输入和输出消息的消息编码类型。
- en: Finally, the `Service` element specifies the location of the port, which is
    the URL that we access to invoke the web service.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Service`元素指定了端口的地址，即我们访问以调用Web服务的URL。
- en: Implementing a web service using an interface
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口实现Web服务
- en: 'All methods declared in our web service implementation class, `CourseManagementService`,
    are exposed as web service operations. However, if you want to expose only a limited
    set of methods from the web service implementation class, then you can use the
    Java interface. For example, if we want to expose only the `getCourses` method
    as a web service operation, then we can create an interface, let''s say `ICourseManagementService`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Web服务实现类`CourseManagementService`中声明的所有方法都作为Web服务操作公开。然而，如果你想只公开Web服务实现类中的有限方法集，则可以使用Java接口。例如，如果我们只想公开`getCourses`方法作为Web服务操作，则可以创建一个接口，比如`ICourseManagementService`：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation class also needs to be annotated with `@WebService`, with the `endpointInterface`
    attribute set to the interface name:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类也需要使用`@WebService`注解，并将`endpointInterface`属性设置为接口名称：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, restart Tomcat and inspect the WSDL. You will notice that only the `getCourses`
    operation is defined in the WSDL.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动Tomcat并检查WSDL。你会注意到在WSDL中只定义了`getCourses`操作。
- en: Consuming a web service using JAX-WS
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAX-WS消费Web服务
- en: 'Let''s now create a simple Java console app to consume the web service we created
    earlier. Select File | New | Maven Project. Select the Create a simple project
    option on the first page and click Next. Enter the following configuration details:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个简单的Java控制台应用程序来消费我们之前创建的Web服务。选择File | New | Maven Project。在第一页上选择“Create
    a simple project”选项并点击Next。输入以下配置详细信息：
- en: '![](img/00197.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00197.jpeg)'
- en: 'Figure 9.10: Create a Maven project for the web service client'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：为网络服务客户端创建Maven项目
- en: Make sure that the Packaging type is `jar`. Click Finish.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 确保打包类型为`jar`。点击完成。
- en: We will now generate a stub and a supporting class on the client side for invoking
    the web service. We will use the **wsimport** tool to generate client classes.
    We will specify the package for the generated classes by using the `-p` option
    and the WSDL location to generate client classes. The wsimport tool is part of
    the JDK and should be available in the `<JDK_HOME>/bin` folder, if you are using
    JDK 1.7 or later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在客户端生成一个存根和支持类以调用网络服务。我们将使用`wsimport`工具生成客户端类。我们将使用`-p`选项指定生成类的包，并使用WSDL位置生成客户端类。`wsimport`工具是JDK的一部分，如果使用JDK
    1.7或更高版本，它应该位于`<JDK_HOME>/bin`文件夹中。
- en: 'Change the folder to `<project_home>/src//main/java` and run the following
    command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件夹更改为`<project_home>/src//main/java`并运行以下命令：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `-keep` flag instructs `wsimport` to keep the generated file and not delete
    it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`-keep`标志指示`wsimport`保留生成的文件，而不是删除它。'
- en: The `-p` option specifies the package name for the generated classes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项指定生成类的包名。'
- en: The last argument is the WSDL location for the web service. In Package Explorer
    or Project Explorer of Eclipse, refresh the client project to see the generated
    files. The files should be in the `packt.jee.eclipse.ws.soap.client` package.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是网络服务的WSDL位置。在Eclipse的包资源管理器或项目资源管理器中，刷新客户端项目以查看生成的文件。这些文件应在`packt.jee.eclipse.ws.soap.client`包中。
- en: '`wsimport` generates a client-side class for each type defined in the schema
    (in the types element of WSDL). Therefore, you will find `Course`, `GetCourse`,
    `GetCourseResponse`, `GetCourses`, and `GetCoursesResponse` classes. Furthermore,
    it generates classes for the `portType` (`CourseManagementService`) and `service`
    (`CourseManagementServiceService`) elements of the WSDL. Additionally, it creates
    an `ObjectFactory` class that creates Java objects from XML using JAXB.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsimport`为模式中定义的每个类型（在WSDL的类型元素中）生成客户端类。因此，您将找到`Course`、`GetCourse`、`GetCourseResponse`、`GetCourses`和`GetCoursesResponse`类。此外，它还为WSDL的`portType`（`CourseManagementService`）和`service`（`CourseManagementServiceService`）元素生成类。此外，它还创建了一个`ObjectFactory`类，该类使用JAXB从XML创建Java对象。'
- en: 'Let''s now write the code to actually call the web service. Create the `CourseMgmtWSClient`
    class in the `packt.jee.eclipse.ws.soap.client.test` package:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写实际调用网络服务的代码。在`packt.jee.eclipse.ws.soap.client.test`包中创建`CourseMgmtWSClient`类：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We first create the `Service` object and then get the port from it. The `port`
    object has operations defined for the web service. We then call the actual web
    service method on the `port` object. Right-click on the class and select Run As
    | Java Application. The output should be the name of the course that we hardcoded
    in the web service implementation, which is `Course-1`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`Service`对象，然后从中获取端口。`port`对象定义了网络服务的操作。然后我们在`port`对象上调用实际的网络服务方法。在类上右键单击并选择运行方式
    | Java应用程序。输出应该是我们在网络服务实现中硬编码的课程名称，即`Course-1`。
- en: Specifying an argument name in a web service operation
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络服务操作中指定参数名称
- en: 'As mentioned earlier, when WSDL was created for our `Course` web service, the
    argument for the `getCourse` operation name was created as `arg0`. You can verify
    this by browsing to `http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`
    and checking the `getCourse` type:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当为我们的`Course`网络服务创建WSDL时，`getCourse`操作名称的参数被创建为`arg0`。您可以通过浏览到`http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`并检查`getCourse`类型来验证这一点：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Thus, the client-side-generated code (by `wsimport`) in `CourseManagementService.getCourse`
    also names the argument as `arg0`. It would be nice to give a meaningful name
    to arguments. This could be done easily be adding the `@WSParam` annotation in
    our web service implementation class, `CourseManagementService`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端生成的代码（由`wsimport`生成）在`CourseManagementService.getCourse`中也命名参数为`arg0`。给参数起一个有意义的名称会很好。这可以通过在我们的网络服务实现类`CourseManagementService`中添加`@WSParam`注解轻松完成：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Restart Tomcat after this change and browse to the WSDL schema URL (`http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`)
    again. You should now see a proper argument name in the `getCourse` type:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改后重新启动Tomcat，并再次浏览到WSDL模式URL（`http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`）。现在您应该能在`getCourse`类型中看到正确的参数名称：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Generate the client-side code again by using `wsimport`, and you will see that
    argument of the `getCourse` method is named `courseId`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`wsimport`生成客户端代码，你会看到`getCourse`方法的参数被命名为`courseId`。
- en: Inspecting SOAP messages
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查SOAP消息
- en: Although you don't necessarily need to understand the SOAP messages passed between
    the web service and the client, sometimes inspecting SOAP messages exchanged between
    the two could help debug some of the issues.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不必一定理解Web服务和客户端之间传递的SOAP消息，但有时检查两者之间交换的SOAP消息可以帮助调试一些问题。
- en: 'You can print request and response SOAP messages when running the client quite
    easily by setting the following system property:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行客户端时，你可以通过设置以下系统属性轻松地打印请求和响应SOAP消息：
- en: '`com.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
- en: 'In Eclipse, right-click on the `CourseMgmtWSClient` class and select Run As
    | Run Configurations. Click on the Arguments tab and specify the following VM
    argument:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，右键单击`CourseMgmtWSClient`类，选择“运行”|“运行配置”。单击“参数”选项卡，并指定以下VM参数：
- en: '`Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
- en: '![](img/00198.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00198.jpeg)'
- en: 'Figure 9.11: Set VM arguments'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：设置VM参数
- en: 'Click Run. You will see request and response SOAP messages printed in the Console
    window in Eclipse. After formatting the request message, this is what the request
    SOAP message looks like:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运行。你将在Eclipse的控制台窗口中看到请求和响应SOAP消息被打印出来。在格式化请求消息后，这是请求SOAP消息的外观：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The response is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Handling interfaces in RPC-style web services
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC样式Web服务中的接口处理
- en: 'Recall that the message style for our web service implementation class is `Document`
    and the encoding is `literal`. Let''s change the style to RPC. Open `CourseManagementService.java`
    and change the style of the SOAP binding from `Style.DOCUMENT` to `Style.RPC`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们Web服务实现类的消息风格是`Document`，编码是`literal`。让我们将风格更改为RPC。打开`CourseManagementService.java`，将SOAP绑定的风格从`Style.DOCUMENT`更改为`Style.RPC`：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Restart Tomcat. In the Tomcat console, you might see the following error:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Tomcat。在Tomcat控制台中，你可能会看到以下错误：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This problem is caused by the following method definition in the `CourseManagementService`
    class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是由`CourseManagementService`类中的以下方法定义引起的：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In RPC-style SOAP binding, JAX-WS uses JAXB, and JAXB cannot marshal interfaces
    very well. A blog entry at [https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces](https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces)
    tries to explain the reason for this. The workaround is to create a wrapper for
    `List` and annotate it with `@XMLElement`. So, create a new class called `Courses`
    in the same package:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在RPC样式的SOAP绑定中，JAX-WS使用JAXB，而JAXB不能很好地序列化接口。一篇博客文章[https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces](https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces)试图解释这一原因。解决方案是为`List`创建一个包装器，并用`@XMLElement`注解它。因此，在同一个包中创建一个名为`Courses`的新类：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, modify the `getCourses` method of `CourseManagementService` to return the `Courses`
    object instead of `List<Course>`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`CourseManagementService`的`getCourses`方法修改为返回`Courses`对象而不是`List<Course>`：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Restart Tomcat. This time, the application should be deployed in Tomcat without
    any error. Re-generate the client classes by using `wsimport`, run the client
    application, and verify the results.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Tomcat。这次，应用程序应该在Tomcat中无错误地部署。使用`wsimport`重新生成客户端类，运行客户端应用程序，并验证结果。
- en: Handling exceptions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: In JAX-WS, a Java exception thrown from a web service is mapped to SOAP fault
    when the XML payload is sent to the client. On the client side, JAX-WS maps SOAP
    fault to either `SOAPFaultException` or to the application-specific exception.
    The client code could wrap the web service call in a `try...catch` block to handle
    exceptions thrown from the web service.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在JAX-WS中，当XML有效载荷发送到客户端时，从Web服务抛出的Java异常被映射为SOAP故障。在客户端，JAX-WS将SOAP故障映射为`SOAPFaultException`或映射为特定于应用程序的异常。客户端代码可以在`try...catch`块中包装Web服务调用以处理Web服务抛出的异常。
- en: For a good description of how SOAP exceptions are handled in JAX-WS, refer to
    [https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624](https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何在JAX-WS中处理SOAP异常的详细描述，请参阅[https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624](https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624)。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Web services are a very useful technology for enterprise application integration.
    They allow disparate systems to communicate with each other. Web service APIs
    are typically self-contained and lightweight.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是企业应用集成的一种非常有用的技术。它们允许不同的系统相互通信。Web服务API通常是自包含且轻量级的。
- en: 'There are broadly two types of web services: SOAP-based and RESTful. SOAP-based
    web services are XML-based and provide many features such as security, attachments,
    and transactions. RESTful web services can exchange data by using XML or JSON.
    RESTful JSON web services are quite popular because they can be easily consumed
    from JavaScript code.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务大致分为两种类型：基于SOAP的和RESTful的。基于SOAP的Web服务是基于XML的，并提供许多功能，如安全性、附件和事务。RESTful
    Web服务可以通过使用XML或JSON交换数据。RESTful JSON Web服务非常受欢迎，因为它们可以从JavaScript代码中轻松消费。
- en: In this chapter, we learned how to develop and consume RESTful and SOAP-based
    web services by using the latest Java specifications, JAX-RS and JAX-WS.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用最新的Java规范JAX-RS和JAX-WS来开发和消费基于SOAP和RESTful的Web服务。
- en: 'In the next chapter, we will take a look at another technology for application
    integration: asynchronous programming using **Java Messaging Service** (**JMS**).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种应用集成技术：使用**Java消息服务**（**JMS**）的异步编程。
