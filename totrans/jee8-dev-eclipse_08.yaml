- en: Creating Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned how to create web applications in Java using
    MVC frameworks. In this chapter, we will learn how to implement web services in
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java object binding and serialization using JAXB and JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and consuming RESTful web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and consuming SOAP web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a web service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Applications with EJB*, we learned that EJBs can be used to create distributed
    applications. EJBs can act as glue and help different JEE applications in the
    enterprise to communicate with each other. However, what if the enterprise wants
    to let its partners or customers make use of some of the application functionality?
    For example, an airline might want to let its partners make online reservations.
  prefs: []
  type: TYPE_NORMAL
- en: One option is for the partner to redirect its customers to the airline website,
    but this would not provide a unified experience to users. A better way to handle
    this would be for the airline to expose its reservation APIs to partners, who
    can integrate these APIs into their own applications, providing a unified user
    experience. This is an example of a distributed application, and EJBs can be used
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: However, for EJBs to work in such scenarios, where API calls cross enterprise
    boundaries, the clients of the APIs also need to be implemented in Java. As we
    know, this is not practical. Some of the airline partners in this example may
    have their applications implemented using different programming platforms, such
    as .NET and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web services are useful in situations such as the one mentioned here. Web services
    are self-contained APIs that are based on open standards and are platform independent.
    They are widely used for communication between disparate systems. There are mainly
    two types of web service implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Object Access Protocol (SOAP)-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representational State Transfer (RESTful) services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For many years, SOAP-based web services were quite popular, but recently, RESTful
    services have been gaining ground because of the simplicity in their implementation
    and consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Web services provide a common integration platform and offer **service-oriented
    architecture** (**SOA**) in which certain components expose services for consumption
    by other components or applications. The consumer of such services can create
    an entire application by assembling a number of such loosely coupled services,
    possibly from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to develop and consume both SOAP and RESTful
    services by using JEE and Eclipse. However, first it would be useful to understand
    how to convert Java objects to XML and JSON, and vice versa, because both REST
    and SOAP web service implementations need to perform these operations. First,
    we will take a look at JAXB, Java XML binding, using which you can bind Java objects
    to both XML and JSON. Then we will take a look at JSON-B (a new specification
    added in JEE 8) for Java JSON binding.
  prefs: []
  type: TYPE_NORMAL
- en: JAXB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAXB provides an easy way to convert XML or JSON representations of data into
    Java objects and vice versa. Using simple annotations, you can have a JAXB implementation
    create XML or JSON data from a Java object or create a Java object from XML or
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how Java data types are mapped to XML schema types in JAXB, refer
    to [https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/bind.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few important JAXB annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@XmlRootElement`: This annotation specifies the root element of the XML document
    and is typically used at the class level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@XmlElement`: This annotation specifies an XML element that is not a root
    element. Java class members can be marked as `XMLElement` when the class is annotated
    with `@XmlRootElement`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@XmlAttribute`: This annotation marks a member of the Java class as an attribute
    of the parent XML element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@XmlAccessorType`: This annotation is specified at the class level. It lets
    you control how class fields are serialized to XML or JSON. Valid values are `XmlAccessType.FIELD`
    (every non-static and non-`@XmlTransient` field is serialized), `XmlAccessType.PROPERTY`
    (every pair of getter/setter that is not annotated with `@XmlTransient` is serialized),
    `XmlAccessType.NONE` (no fields are serialized, unless specific fields are annotated
    for serialization), and `XmlAccessType.PUBLIC_MEMBER` (all public getter/setter
    pairs are serialized, unless annotated with `@XmlTransient`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@XMLTransient`: This annotation specifies a member or getter/setter pair that
    is not to be serialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the complete list of JAXB annotations, refer to [https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB](https://jaxb.java.net/tutorial/section_6_1-JAXB-Annotations.html#JAXB).
  prefs: []
  type: TYPE_NORMAL
- en: A JAXB example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Maven project to try out JAXB APIs. Select the File | Maven
    Project menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Create a Maven project for a JAXB example'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the project is configured to use JRE 1.7 or later. Let''s now
    create two classes, `Course` and `Teacher`. We want to serialize instances of
    these classes to XML and back. Create these classes in the `packt.jee.eclipse.jaxb.example`
    package. Here is the source code of the `Course` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When a `Course` is marshalled to an XML document, we want the `course` element
    to be the root. Therefore, the class is annotated with `@XmlRootElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling is the process of writing the data, typically an object, to a format
    link XML or JSON. Unmarshalling is the process of reading the data from a format
    and creating an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify a different name for the root element (other than the class
    name) by specifying the `name` attribute, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `id` field is marked as an attribute of the root element. You don't have
    to mark fields specifically as elements if there are public getters/setters for
    them. However, if you want to set additional attributes, then you need to annotate
    them with `@XmlElement`. For example, we have specified a namespace for the `name`
    field. The `credits` field is not annotated, but it will still be marshalled as
    an XML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code for the `Teacher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are not annotating the `Teacher` class for JAXB because we are not going
    to marshal it directly. It will be marshalled by JAXB when an instance of `Course`
    is marshalled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `JAXBExample` class with the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To marshal or unmarshal using JAXB, we first create `JAXBContext`, passing
    it a Java class that needs to be worked on. Then, we create the marshaller or
    unmarshaller, set the relevant properties, and perform the operation. The code
    is quite simple. We first marshal the `Course` instance to XML, and then use the
    same XML output to unmarshal it back to a `Course` instance. Right-click on the
    class and select Run As | Java Application. You should see the following output
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's now see how to marshal a Java object to JSON and back. JSON support in
    JAXB is not available out of the box in JDK. We will have to use an external library
    that supports JAXB APIs with JSON. One such library is EclipseLink MOXy ([https://eclipse.org/eclipselink/#moxy](https://eclipse.org/eclipselink/#moxy)).
    We will use this library to marshal an instance of `Course` to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `pom.xml` and add the dependency on EclipseLink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to set the `javax.xml.bind.context.factory` property to make the
    JAXB implementation use EclipseLink''s `JAXBContextFactory`. Create the `jaxb.properties`
    file in the same package as the classes whose instances are to be marshalled.
    In this case, create the file in the `packt.jee.eclipse.jaxb.example` package.
    Set the following property in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very important. If you do not set this property, then the example won''t
    work. Next, open `JAXBExample.java` and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of the code is the same as in the `doJAXBXml` method. Specific changes
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the `marshaller` property for generating the JSON output (`application/json`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set another `marshaller` property to include the JSON root in the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the corresponding properties on `unmarshaller`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify the main method to call `doJAXBJson`, instead of `doJAXBXml`. When you
    run the application, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have covered the basics of JAXB in this chapter. For a detailed tutorial
    on JAXB, refer to [https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html](https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-B is a new specification included in JEE 8\. Using a simple annotation
    you can convert Java objects to JSON and vice versa. JSON-B has one important
    annotation, `@JsonProperty`. Specifying this annotation for a class member marks
    it for serialization to or from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B provides the `JsonbBuilder` class, using which you can perform actual
    serialization. Let's learn how to use JSON-B with a simple application.
  prefs: []
  type: TYPE_NORMAL
- en: A JSON-B example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Maven project, with Group Id as JAXBExample and Artifact Id
    as JSONBExampleProject. JSON-B is not a part of the JDK, so we will need to add
    Maven dependencies for libraries that provide JSON-B APIs and their implementation.
    In this example, we will use Eclipse''s Yasson ([https://projects.eclipse.org/projects/ee4j.yasson](https://projects.eclipse.org/projects/ee4j.yasson))
    implementation of JSON-B. We will add the following dependencies in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Dependency on `javax.json` from GlassFish is added because the `yasson` implementation
    depends on its JSON-P implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the `Course` and `Teacher` classes as we created them in
    the previous section for JAXB, but with JSON-B annotations. Create both classes
    in the `packt.jee.eclipse.jsonb.example` package. Here is the source code for the
    `Course` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have annotated members of the `Course` class with `@JsonbProperty`. If you
    want to change the name of the field in JSON then you can specify it as a parameter
    to `@JsonbProperty`; for example, in the previous code we are mapping the `teacher`
    field to the `course_teacher` name in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Teacher` class is the same as the one we created in the section for JAXB.
    Let''s now create the main application class, called `JSONBExample`, in which
    we will convert an instance of `Course` to `String` and then from `String` back
    to an instance of the `Course` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To serialize an instance of the `Course` class, we are first creating an instance
    of `JsonBuilder` and then calling the `toJson` method on that. To de-serialize the
    JSON representation of the `Course` class from String, we are calling `fromJson`
    on the same instance of `JsonBuilder`. If you run the application, you should
    see a JSON string for the course object we created.
  prefs: []
  type: TYPE_NORMAL
- en: For further details on JSON-B, refer to [http://json-b.net/index.html.](http://json-b.net/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start learning web services with RESTful services because they are
    widely used and are easy to implement. REST is not necessarily a protocol but
    an architectural style, and is typically based on HTTP. RESTful web services act
    on resources on the server, and actions are based on HTTP methods (`Get`, `Post`,
    `Put`, and `Delete`). The state of resources is transferred over HTTP in either
    XML or JSON format, although JSON is more popular. Resources on the server are
    identified by URLs. For example, to get details of a course with ID `10`, you
    can use the HTTP `GET` method with the following URL: `http://<server_address>:<port>/course/10`.
    Notice that the parameter is part of the base URL. To add a new `Course` or modify
    a `Course`, you can use either `POST` or `PUT` methods. Furthermore, the `DELETE`
    method can be used to delete a `Course` by using the same URL as that used for
    getting the course, that is, `http://<server_address>:<port>/course/10`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource URLs in RESTful web services can be nested too; for example, to get
    all courses in a particular department (with, say, an ID of `20`), the REST URL
    can be as follows: `http://<server_address>:<port>/department/20/courses`.'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)
    for more details on the properties of RESTful web services and HTTP methods used
    for acting on REST resources on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The Java specification for working with RESTful web services is called JAX-RS,
    Java API for RESTful services ([https://jax-rs-spec.java.net/](https://jax-rs-spec.java.net/)).
    Project Jersey ([https://jersey.java.net/](https://jersey.java.net/)) is the reference
    implementation of this specification. We will use this reference implementation this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating RESTful web services using Jersey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a web service for the *Course Management* example that we have
    been developing in this book. The web service will have methods to get all courses
    and create a new course. To keep the example simple, we will not write the data
    access code (you can use the JDBC or JDO APIs that we learned in previous chapters),
    but will hardcode the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a Maven web project. Select File | New | Maven Project. Select
    the Create a Simple Project checkbox on the first page of the wizard and click
    Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Create a Maven project for a RESTful web service'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the project configuration details and click Finish. Make sure that the
    packaging is `war`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to use the `Jersey` library for the JAX-RS implementation,
    we will add its Maven dependency into the project. Open `pom.xml` and add the
    following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the JAX-RS `@Path` annotation, we can convert any Java class into a REST
    resource. The value passed to the `@Path` annotation is a relative URI of the
    resource. Methods in the implementation class, to be executed for different HTTP
    methods, are annotated with one of the following annotations: `@GET`, `@PUT`,
    `@POST`, or `@DELETE`. The `@Path` annotation can also be used at the method level
    for a sub-resource path (the main resource or the root resource path is at the
    class level, again using the `@Path` annotation). We can also specify the MIME
    type that previous methods produce/consume by using the `@Produces` or `@Consumes`
    annotations, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we create a web service implementation class, let's create some utility
    classes, more specifically in this case DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Course` and `Teacher` classes in the `packt.jee.eclipse.rest.ws.dto`
    package. We will also annotate them with the JAXB annotations. Here is the source code
    for the `Teacher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the source code for the `Course` class, which we will use
    for marshalling to XML and JSON in the subsequent sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have annotated the `id` fields in both classes as `@XMLAttribute`. If objects
    of these classes are marshalled (converted from Java objects) to XML, `Course
    id` and `Teacher id` would be attributes (instead of elements) of the root element
    (`Course` and `Teacher`, respectively). If no field annotation is specified and
    if public getters/setters for an attribute are present, then it is considered
    an XML element with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: We have specifically used the `@XMLElement` annotation for `name` fields because
    we want to rename them as `course_name` or `teacher_name` when marshalled to XML.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST GET request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now implement the RESTful web service class. Create the `CourseService`
    class in the `packt.jee.eclipse.rest.ws.services` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `@Path` annotation specifies that resources made available by this class
    will be accessible by relative URI `"/course"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `getCourse` method has many annotations. Let's discuss them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The `@GET` annotation specifies that when the relative URI (as specified by
    `@Path` on `CourseService` class) `"/course"` is called using the HTTP `GET` method,
    then this method will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Produces` (`MediaType.APPLICATION_JSON`) specifies that this method generates
    a JSON output. If the client specifies the accepted MIME types, then this annotation
    would be used to resolve the method to be called, if more than one method is annotated
    with `@GET` (or, for that matter, any of the other HTTP method annotations). For
    example, if we have a method called `getCourseJSON` annotated with `@GET` , but
    producing data with different MIME types (as specified by `@Produces`), then the
    appropriate method will be selected on the basis of the MIME type requested by
    the client. The MIME type in the `@Produces` annotation also tells the JAX-RS
    implementation MIME type of the response to be created, when marshalling the Java
    object that is returned from that method. For example, in the `getCourse` method
    we return an instance of `Course`, and the MIME type specified in `@Produces`
    tells Jersey to generate an XML representation of this instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Path` annotation can also be used at the method level to specify sub-resources.
    The value specified in `@Path` at the method level is relative to the path value
    specified at the class level. The resource (in this case, `Course`) with ID `20`
    can be accessed as `/course/get/20`. The complete URL can be `http://<server-address>:<port>/<app-name>/course/get/10`.
    Parameter names in the path value are enclosed in `{}` in annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Path parameters need to be identified in method arguments by using the `@PathParam`
    annotation and the name of the parameter as its value. The JAX-RS implementation
    framework matches the path parameters with arguments matching `@PathParam` annotations
    and appropriately passes parameter values to the method.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the example simple and to keep the focus on implementation of RESTful
    web services, we are not going to implement any business logic in this method.
    We could get data from the database by using, for example, JDO or JDBC APIs (and
    we have seen examples of how to use these APIs in earlier chapters), but we are
    just going to return some hardcoded data. The method returns an instance of the `Course`
    class. The JAX-RS implementation would convert this object into an XML representation
    by using JAXB when the data is finally returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tell the Jersey framework what packages it needs to scan to look
    for REST resources. There are two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Jersey servlet in `web.xml` (see [https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet](https://jersey.java.net/nonav/documentation/latest/user-guide.html#deployment.servlet)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Servlet 3.x containers, we could create a subclass of `javax.ws.rs.core.Application`.
    Tomcat 8.0, which we have been using in this book, is a Servlet 3.x container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the second option to create a subclass of `Application`. However,
    instead of directly subclassing `Application`, we will subclass the `ResourceConfig`
    class of Jersey, which in turn extends `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `CourseMgmtRESTApplication` class in the `packt.jee.eclipse.rest.ws`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `@ApplicationPath` annotation to specify URL mapping for REST
    services implemented using JAX-RS. All `@Path` URIs on resource implementation
    classes will be relative to this path. For example, the `"/course"` URI that we
    specified for the `CourseService` class would be relative to `"services"`, specified
    in the `@ApplicationPath` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we deploy the application and test our service, we need to generate `web.xml`.
    Right-click on the project in Project Explorer and select Java EE Tools | Generate
    Deployment Descriptor Stub. This will create `web.xml` in the `WEB-INF` folder.
    We don't need to modify it for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Configure Tomcat in Eclipse as described in the *Installing Tomcat* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*, and in the *Configuring Tomcat in Eclipse* section of [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. To deploy the web application, right-click on the configured
    Tomcat server in the Servers view and select the Add and Remove option. Add the
    current project.
  prefs: []
  type: TYPE_NORMAL
- en: Start the Tomcat server by right-clicking on the configured server in the `Servers`
    view and selecting Start.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the REST GET request in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will test the web service we created in the previous section
    in the browser. To test the web service, browse to `http://localhost:8080/CourseManagementREST/services/course/get/10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following XML displayed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of generating an XML response, let''s say we want to create a JSON
    response, because it would be much easier to consume a JSON response from JavaScript
    in a web page than an XML response. To create a JSON response, we need to change
    the value of the `@Produces` annotation in the `CourseService` class. Currently,
    it is set to `MediaType.APPLICATION_XML` and we want to set it to `MediaType.APPLICATION_JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add libraries to create the JSON response. Open the `pom.xml`
    of the project and add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Tomcat server and browse to the `http://localhost:8080/CourseManagementREST/services/course/get/10`
    URL again. This time, you should see a JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create two versions of the `getCourse` method, one that produces XML
    and the other that produces JSON. Replace the `getCourse` function with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the `createDummyCourse` method, which has the same code that
    we had earlier in the `getCourse` method. We now have two versions of the `getCourse`
    method: `getCourseXML` and `getCourseJSON`, producing the XML and JSON responses,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Java client for the REST GET web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create a Java client application that calls the previous web service.
    Create a simple Maven project and call it `CourseManagementRESTClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Create a JAX-RS client project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `pom.xml` and add a dependency for the Jersey client module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Java class called `CourseManagementRESTClient` in the `packt.jee.eclipse.rest.ws.client`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Create a REST client main class'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could invoke a RESTful web service using `java.net.HttpURLConnection` or
    other external HTTP client libraries. But JAX-RS client APIs make this task a
    lot easier, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For a detailed description of how to use the JAX-RS client APIs, refer to [https://jersey.java.net/documentation/latest/client.html](https://jersey.java.net/documentation/latest/client.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST POST request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw an example of how to implement an HTTP `GET` request by using JAX-RS.
    Let's now implement a `POST` request. We will implement a method to add a course
    in the `CourseService` class, which is our web service implementation class in the `CourseManagementREST`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the case of the `getCourse` method, we won''t actually access the database
    but will simply write a dummy method to save the data. Again, the idea is to keep
    the example simple and focus only on the JAX-RS APIs and implementation. Open
    `CourseService.java` and add the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addCourse` method produces and consumes JSON data. It is invoked when
    the resource path (web service endpoint URL) has the following relative path:
    `"/course/add"`. Recall that the `CourseService` class is annotated with the following
    path: `"/course"`. So, the relative path for the `addCourse` method becomes the
    path specified at the class level and at the method level (which in this case
    is `"add"`). We are returning a new instance of `Course` from `addCourse`. Jersey
    creates the appropriate JSON representation of this class on the basis of JAXB
    annotations in the `Course` class. We have already added the dependency in the
    project on a Jersey module that handles JSON format (in `pom.xml`, we added a
    dependency on `jersey-media-json-jackson`).'
  prefs: []
  type: TYPE_NORMAL
- en: Restart the Tomcat server for these changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Java client for the REST POST web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add a test method in the `CourseManagementClient` class, in the `CourseManagementRESTClient` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We need to send input data (`Course` information) in JSON format. Although we
    have hardcoded JSON in our example, you could use JAXB or any other library that
    converts a Java object into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are executing the request using the HTTP `POST` method `webTarget.request().post(...)`.
    We have also set the content type of the request to `"application/JSON"`, because
    our web service to add `Course` consumes the JSON format. We have done this by
    creating the entity and setting its content type to `JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now modify the `main` method of the `CourseManagementClient` class to call the `testAddCourseJSON`
    method. Right-click on the class and select Run As | Java Application. You should
    see `Course` information in JSON format printed in the console. Also, check the
    Tomcat console in Eclipse. There, you should see the console message that we printed
    in the `CourseService.dummyAddCourse` method.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a POST RESTful web service from JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple example of how to invoke our RESTful web service to add a
    course from JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you want to test this code, create an HTML file, say `addCourseJSON.html`,
    in the `src/main/webapp` folder of the `CourseManagementREST` project. Then, browse
    to `http://localhost:8080/CourseManagementREST/addCourseJSON.html`. Click the Add
    Course using JSON button. The response is displayed in the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service with form POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created RESTful web services so far with HTTP `GET` and `POST` methods.
    The web service using the `POST` method took input in the JSON format. We can
    also have the `POST` method in the web service take input from HTML form elements.
    Let''s create a method that handles the data posted from a HTML form. Open `CourseService.java`
    from the `CourseManagementREST` project. Add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is marked to handle form data by specifying the `@Consume` annotation
    with the following value: `"application/x-www-form-urlencoded"`. Just as we mapped
    parameters in the path in the `getCourse` method with `@PathParam`, we map the
    form fields to method arguments using the `@FormParam` annotation. Finally, once
    we successfully save the course, we want the client to be redirected to `addCourseSuccess.html`.
    We do this by calling the `Response.seeOther` method. The `addCourseFromForm`
    method returns the `Response` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html)
    for more information on how to configure `Response` from the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create `addCourseSuccess.html` to complete this example. Create
    this file in the `src/main/webapp` folder of the `CourseManagementREST` project
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Java client for a form-encoded RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create a test method for calling the previous web service that consumes
    form-encoded data. Open `CourseManagementClient.java` from the `CourseManagementRESTClient`
    project and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the form data is created by creating an instance of the `Form`
    object and setting its parameters. The `POST` request is encoded with `MediaType.APPLICATION_FORM_URLENCODED`,
    which has the following value: `"application/x-www-form-urlencoded"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, modify the `main` method to call `testAddCourseForm`. Then, run the application
    by right-clicking the class and selecting Run As | Java Application. You should
    see the success message (from `addCourseSuccess.html`) printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful web service using JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we implemented the RESTful web service using JAXB.
    As mentioned earlier, JEE 8 has added a new specification for JSON binding, called
    JSON-B. In this section, we will learn how to modify our web service to use JSON-B.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is really not much that we need to change in the code to switch from
    JAXB to JSON-B. We will need to use the `@JsonbProperty` annotation of JSON-B
    to specify field binding in the `Course` class, instead of the` @XmlAttribute`
    annotation of JAXB. Then, we will need to add Maven dependencies to include libraries
    that provide JSON-B APIs and its implementations. Replace the dependencies section
    in pom.xml with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Dependency on `jersey-container-servlet` has not changed. However, we have
    replaced dependency on `jersey-media-json-jackson` with` jersey-media-json-binding` and `jersey-hk2`.
    The Jersey framework automatically handles conversion of Java objects to JSON
    when the web service method is annotated with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is specified in the `CourseService` class.
  prefs: []
  type: TYPE_NORMAL
- en: A separate project for this section, named `CourseManagementREST-JSONB`, is
    made available in the accompanying source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol** (**SOAP**) is a specification from **World
    Wide Web Consortium** (**W3C**) ([http://www.w3.org/TR/2007/REC-soap12-part0-20070427/](http://www.w3.org/TR/2007/REC-soap12-part0-20070427/)).
    Although we are referring to SOAP-based web services here, SOAP is one of the
    specifications used to implement XML-based web services. There are a few other
    specifications required to implement SOAP web services, which we will see later.
    One of the premises of SOAP web services is the dynamic discovery and invocation
    of services. For example, an application can look for a service from the central
    directory and invoke it dynamically. However, in practice, very few enterprises
    would be willing to invoke services dynamically without testing them, so this
    aspect of SOAP web services is less utilized.'
  prefs: []
  type: TYPE_NORMAL
- en: W3C has defined many specifications for SOAP web services, for example, specifications
    for messages, auto discovery, security, and service orchestration. However, at
    a minimum, we need to understand the following specification before we develop
    SOAP web services.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOAP defines the format of a message exchange between the web service provider
    and the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: SOAP message structure'
  prefs: []
  type: TYPE_NORMAL
- en: The top element in a **SOAP Message** is **SOAP Envelope**. It contains a **SOAP
    Header (Optional)** and a **SOAP Body**. The **SOAP Body** actually contains the
    message payload (for processing by the consumer) and optionally **SOAP Fault (Optional)**,
    if there is any error.
  prefs: []
  type: TYPE_NORMAL
- en: The SOAP header provides extensibility to the SOAP message. It can contain information
    such as user credentials, transaction management, and message routing.
  prefs: []
  type: TYPE_NORMAL
- en: WSDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, **Web Service Description Language** (**WSDL**) describes
    web services; in particular, it describes data types used (schemas), input and
    output messages, operations (methods), and binding and service endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00193.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: WSDL structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you don''t necessarily need to understand the details of WSDL when
    creating web services in Java, it is good to know the basic structure of WSDL.
    WSDLs are typically meant to be produced and processed by programs, and developers
    are not expected to hand-code them. Here are some of the elements in WSDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`definitions`: This is the root element of WSDL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Import`: This element allows you to import elements from an external file.
    This way, you can make the WSDL file modular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Types`: This element defines the schema for different data types used in the
    WSDL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Messages`: This element defines the format of input and output messages exchanged
    between the web service and the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PortType`: This defines methods or operations supported by the web service.
    Each operation in `PortType` can declare request and response messages. Operations
    in `PortType` refer to messages defined in a message element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although in *Figure 9.6*, the `binding` element looks the same as `PortType`,
    it actually specifies the transport protocol bound to operations and message type
    (**remote procedure call** or **document type**) and encoding (encoded or literal)
    for messages of each operation declared in `PortType`. The typical transport protocol
    is HTTP, but it could be other protocols such as JMS and SMTP. The difference
    between the RPC and document types is that the RPC message type contains the name
    of the remote method in the message, whereas the document type does not contain
    the method name. The name of the method to process the payload in a document type
    message is either derived from the endpoint URL or from information in the header.
    However, there is another type called **document wrapped**, which does contain the
    name of the method as the enclosing element for the actual message payload.
  prefs: []
  type: TYPE_NORMAL
- en: The `Service` element contains the actual location of each web service endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: UDDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Universal Description, Discovery and Integration** (**UDDI**) is a directory
    of web services where you can publish your own web services or search for existing
    web services. The directory could be global or could be local to the enterprise.
    UDDI is also a web service with operations supported for publishing and searching
    contents.'
  prefs: []
  type: TYPE_NORMAL
- en: We will not be focusing on UDDI in this book, but you can visit [http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226](http://docs.oracle.com/cd/E14571_01/web.1111/e13734/uddi.htm#WSADV226)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Developing web services in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many frameworks around for developing web services in Java. New frameworks
    have evolved as specifications have changed. Some of the popular frameworks for
    developing web services in Java over the years are Apache Axis ([https://axis.apache.org/axis/](https://axis.apache.org/axis/)),
    Apache Axis2 ([http://axis.apache.org/axis2/java/core/](http://axis.apache.org/axis2/java/core/)),
    Apache CFX ([http://cxf.apache.org/](http://cxf.apache.org/)), and GlassFish Metro
    ([https://metro.java.net/](https://metro.java.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Earlier implementations of web service frameworks were based on the **JAX-RPC**
    (**Java API for XML-based RPC**) specification ([http://www.oracle.com/technetwork/java/docs-142876.html](http://www.oracle.com/technetwork/java/docs-142876.html)).
    JAX-RPC was replaced with **Java API for XML Web Services** (**JAX-WS**) in JEE
    5\. JAX-WS makes development of web services easier by supporting annotations.
    In this chapter, we will learn how to create and consume web services using JAX-WS.
    Continuing with the example (*Course Management*) that we have been following
    in this book, we will create web services to get all courses and add new courses.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a Maven web project. Select File | New | Maven Project.
    Select the Create a simple project option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: New Maven Project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next. Enter Group Id, Artifact id, and Version in the next page. Select
    the `war` packaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Enter artifact details'
  prefs: []
  type: TYPE_NORMAL
- en: Click Finish to complete the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web service implementation class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAX-WS annotations were added in Java EE 5.0\. Using these annotations, we can
    turn any Java class (including POJOs) into a web service. Use the `@Webservice`
    annotation to make any Java class a web service. This annotation can be used either
    on an interface or on a Java class. If a Java class is annotated with `@Webservice`,
    then all public methods in the class are exposed in the web service. If a Java
    interface is annotated with `@Webservice`, then the implementation class still
    needs to be annotated with `@Webservice` and with the `endpointInterface` attribute
    and its value as the interface name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we create the web service implementation class, let''s create a few
    helper classes. The first one is the `Course` data transfer object. This is the
    same class that we created in previous chapters. Create the `Course` class in
    the `packt.jee.eclipse.ws.soap` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create the web service implementation class `CourseManagementService`
    in the `packt.jee.eclipse.ws.soap` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`CourseManagementService` has the following two methods: `getCourses` and `getCourse`.
    To keep the example simple, we have hardcoded the values, but you can very well
    fetch data from a database, for example, using the JDBC or JDO APIs that we have
    discussed earlier in this book. The class is annotated with `@WebService`, which
    tells the JAX-WS implementation to treat this class as a web service. All methods
    in this class will be exposed as web service operations. If you want a specific
    method to be exposed, you could use `@WebMethod`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using JAX-WS reference implementation (Glassfish Metro)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotating a class with `@WebService` is not enough to implement a web service.
    We need a library that implements JAX-WS specification. There are a number of
    JAX-WS frameworks available, for example, Axis2, Apache CFX, and Glassfish Metro.
    In this chapter, we will use the Glassfish Metro implementation, which is also
    a reference implementation ([https://jax-ws.java.net/](https://jax-ws.java.net/))
    of JAX-WS from Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add Maven dependency for the JAX-WS framework. Open `pom.xml` and add
    the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the previous version number with the latest version of the framework.
    The Metro framework also requires you to declare web service endpoints in the
    configuration file called `sun-jaxws.xml`. Create the `sun-jaxws.xml` file in the `src/main/webapp/WEB-INF`
    folder and add the endpoint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint implementation is the fully qualified name of our web service implementation
    class. `url-pattern` is just like servlet mapping that you specify in `web.xml`.
    In this case, any relative URL starting with `/courseService` would result in
    the invocation of our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting WSDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are done with implementing our web service. As you can see, JAX-WS really
    makes it very easy to develop web services. Let''s now inspect the WSDL of our
    web service. Configure Tomcat in Eclipse as described in *Installing Tomcat* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse* and in the *Configuring Tomcat in Eclipse* section of [Chapter
    2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating a Simple
    JEE Web Application*. To deploy the web application, right-click on the configured
    Tomcat server in Servers view and select the Add and Remove option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Add a project to Tomcat'
  prefs: []
  type: TYPE_NORMAL
- en: Add the project and click Finish.
  prefs: []
  type: TYPE_NORMAL
- en: Start the Tomcat server by right-clicking on the configured server in the Servers
    view and selecting Start.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inspect the WSDL of our web service, browse to `http://localhost:8080/CourseMgmtWSProject/courseService?wsdl`
    (assuming that Tomcat is running on port `8080`). The following WSDL should be
    generated (see the description following *Figure 9.6* in the <q class="calibre207">WSDL</q> section
    to understand the structure of the WSDL generated here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the schema (see the definitions of the `/types/xsd:schemas` element)
    for this web service is imported in the previous WSDL. You can see the schema
    generated at `http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The schema document defines data types for the `getCourse` and `getCourses`
    methods and their responses (`getCoursesResponse` and `getCourseResponse`), and
    also for the `Course` class. It also declares members of the `Course` data type
    (`id`, `credits`, and `name`). Notice that the `getCourse` data type has one child
    element (which is an argument to the call to the `getCourse` method in `CourseManagementService`)
    called `arg0`, which is actually the course ID of the `int` type. Further, notice the
    definition of `getCoursesResponse`. In our implementation class, `getCourses`
    returns `List<Course>`, which is translated in WSDL (or types in WSDL) as a sequence
    of course types.
  prefs: []
  type: TYPE_NORMAL
- en: The following four messages are defined in the previous WSDL: `getCourses`,
    `getCoursesResponse`, `getCourse`, and `getCourseResponse`. Each message contains
    a part element that refers to data types declared in types (or schema).
  prefs: []
  type: TYPE_NORMAL
- en: The `PortType` name is the same as the web service implementation class called
    `CourseManagementService` and operations of the port are the same as public methods
    of the class. The input and output of each operation refers to messages already
    defined in the WSDL.
  prefs: []
  type: TYPE_NORMAL
- en: The binding defines the network transport type, which in this case is HTTP,
    and the style of message in the SOAP body, which is of the document type. We have
    not defined any message type in our web service implementation, but the JAX-WS
    reference implementation (Glassfish Metro) has set a default message type to `document`.
    Binding also defines the message encoding type for the input and output messages
    of each operation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Service` element specifies the location of the port, which is
    the URL that we access to invoke the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a web service using an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All methods declared in our web service implementation class, `CourseManagementService`,
    are exposed as web service operations. However, if you want to expose only a limited
    set of methods from the web service implementation class, then you can use the
    Java interface. For example, if we want to expose only the `getCourses` method
    as a web service operation, then we can create an interface, let''s say `ICourseManagementService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation class also needs to be annotated with `@WebService`, with the `endpointInterface`
    attribute set to the interface name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart Tomcat and inspect the WSDL. You will notice that only the `getCourses`
    operation is defined in the WSDL.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a web service using JAX-WS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create a simple Java console app to consume the web service we created
    earlier. Select File | New | Maven Project. Select the Create a simple project
    option on the first page and click Next. Enter the following configuration details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Create a Maven project for the web service client'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the Packaging type is `jar`. Click Finish.
  prefs: []
  type: TYPE_NORMAL
- en: We will now generate a stub and a supporting class on the client side for invoking
    the web service. We will use the **wsimport** tool to generate client classes.
    We will specify the package for the generated classes by using the `-p` option
    and the WSDL location to generate client classes. The wsimport tool is part of
    the JDK and should be available in the `<JDK_HOME>/bin` folder, if you are using
    JDK 1.7 or later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the folder to `<project_home>/src//main/java` and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `-keep` flag instructs `wsimport` to keep the generated file and not delete
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` option specifies the package name for the generated classes.
  prefs: []
  type: TYPE_NORMAL
- en: The last argument is the WSDL location for the web service. In Package Explorer
    or Project Explorer of Eclipse, refresh the client project to see the generated
    files. The files should be in the `packt.jee.eclipse.ws.soap.client` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`wsimport` generates a client-side class for each type defined in the schema
    (in the types element of WSDL). Therefore, you will find `Course`, `GetCourse`,
    `GetCourseResponse`, `GetCourses`, and `GetCoursesResponse` classes. Furthermore,
    it generates classes for the `portType` (`CourseManagementService`) and `service`
    (`CourseManagementServiceService`) elements of the WSDL. Additionally, it creates
    an `ObjectFactory` class that creates Java objects from XML using JAXB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write the code to actually call the web service. Create the `CourseMgmtWSClient`
    class in the `packt.jee.eclipse.ws.soap.client.test` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We first create the `Service` object and then get the port from it. The `port`
    object has operations defined for the web service. We then call the actual web
    service method on the `port` object. Right-click on the class and select Run As
    | Java Application. The output should be the name of the course that we hardcoded
    in the web service implementation, which is `Course-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an argument name in a web service operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, when WSDL was created for our `Course` web service, the
    argument for the `getCourse` operation name was created as `arg0`. You can verify
    this by browsing to `http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`
    and checking the `getCourse` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the client-side-generated code (by `wsimport`) in `CourseManagementService.getCourse`
    also names the argument as `arg0`. It would be nice to give a meaningful name
    to arguments. This could be done easily be adding the `@WSParam` annotation in
    our web service implementation class, `CourseManagementService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart Tomcat after this change and browse to the WSDL schema URL (`http://localhost:8080/CourseMgmtWSProject/courseService?xsd=1`)
    again. You should now see a proper argument name in the `getCourse` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Generate the client-side code again by using `wsimport`, and you will see that
    argument of the `getCourse` method is named `courseId`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting SOAP messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you don't necessarily need to understand the SOAP messages passed between
    the web service and the client, sometimes inspecting SOAP messages exchanged between
    the two could help debug some of the issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print request and response SOAP messages when running the client quite
    easily by setting the following system property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Eclipse, right-click on the `CourseMgmtWSClient` class and select Run As
    | Run Configurations. Click on the Arguments tab and specify the following VM
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dcom.sun.xml.internal.ws.transport.http.client.HttpTransportPipe.dump=true`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Set VM arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Run. You will see request and response SOAP messages printed in the Console
    window in Eclipse. After formatting the request message, this is what the request
    SOAP message looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Handling interfaces in RPC-style web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that the message style for our web service implementation class is `Document`
    and the encoding is `literal`. Let''s change the style to RPC. Open `CourseManagementService.java`
    and change the style of the SOAP binding from `Style.DOCUMENT` to `Style.RPC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart Tomcat. In the Tomcat console, you might see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem is caused by the following method definition in the `CourseManagementService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In RPC-style SOAP binding, JAX-WS uses JAXB, and JAXB cannot marshal interfaces
    very well. A blog entry at [https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces](https://community.oracle.com/blogs/kohsuke/2006/06/06/jaxb-and-interfaces)
    tries to explain the reason for this. The workaround is to create a wrapper for
    `List` and annotate it with `@XMLElement`. So, create a new class called `Courses`
    in the same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `getCourses` method of `CourseManagementService` to return the `Courses`
    object instead of `List<Course>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Restart Tomcat. This time, the application should be deployed in Tomcat without
    any error. Re-generate the client classes by using `wsimport`, run the client
    application, and verify the results.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JAX-WS, a Java exception thrown from a web service is mapped to SOAP fault
    when the XML payload is sent to the client. On the client side, JAX-WS maps SOAP
    fault to either `SOAPFaultException` or to the application-specific exception.
    The client code could wrap the web service call in a `try...catch` block to handle
    exceptions thrown from the web service.
  prefs: []
  type: TYPE_NORMAL
- en: For a good description of how SOAP exceptions are handled in JAX-WS, refer to
    [https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624](https://docs.oracle.com/cd/E24329_01/web.1211/e24965/faults.htm#WSADV624).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services are a very useful technology for enterprise application integration.
    They allow disparate systems to communicate with each other. Web service APIs
    are typically self-contained and lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are broadly two types of web services: SOAP-based and RESTful. SOAP-based
    web services are XML-based and provide many features such as security, attachments,
    and transactions. RESTful web services can exchange data by using XML or JSON.
    RESTful JSON web services are quite popular because they can be easily consumed
    from JavaScript code.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to develop and consume RESTful and SOAP-based
    web services by using the latest Java specifications, JAX-RS and JAX-WS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will take a look at another technology for application
    integration: asynchronous programming using **Java Messaging Service** (**JMS**).'
  prefs: []
  type: TYPE_NORMAL
