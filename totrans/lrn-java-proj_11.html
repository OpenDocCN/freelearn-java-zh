<html><head></head><body>
		<div id="_idContainer172">
			<h1 id="_idParaDest-266" class="chapter-number"><a id="_idTextAnchor266"/>11</h1>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor267"/>Dealing with Exceptions</h1>
			<p>Error handling is another fundamental concept of software development. An error happens when the program can’t or doesn’t know how to react to a certain situation. Error handling allows you to respond to unexpected events in your program gracefully. Without error handling, the application would crash and stop running when the <span class="No-Break">error occurred.</span></p>
			<p>In Java, we have different types of errors. The type of error that we deal with most is called an <strong class="bold">exception</strong>. In Java terms that we’ll learn later, an Exception is not an Error. This is related to the class hierarchy. However, sticking to daily linguistics it is not weird to think of an exception as some sort <span class="No-Break">of error.</span></p>
			<p>But, instead <a id="_idIndexMarker802"/>of talking about errors, we usually talk about exceptions. Errors occur as well, but errors are typically situations your application will not recover from. Your application should be capable of recovering from <span class="No-Break">an exception.</span></p>
			<p>Exception handling<a id="_idIndexMarker803"/> in Java allows you to manage problems and unexpected events in your programs. Mastering exception handling will not only improve the robustness of your code but also help you maintain and debug your applications more effectively. By understanding how exceptions work, you can write code that deals with unexpected situations without crashing or producing <span class="No-Break">incorrect results.</span></p>
			<p>Making sure that you have the necessary skills to manage exceptions in your applications is exactly what we’re going to learn in this chapter. Here’s an overview of what <span class="No-Break">we’ll cover:</span></p>
			<ul>
				<li>Understanding exceptions and <span class="No-Break">their purpose</span></li>
				<li>Types of exceptions – checked <span class="No-Break">and unchecked</span></li>
				<li>Basic <span class="No-Break">I/O operations</span></li>
				<li><span class="No-Break">Throwing exceptions</span></li>
				<li>Creating <span class="No-Break">custom exceptions</span></li>
				<li>The catch or <span class="No-Break">declare principle</span></li>
				<li>Using try-catch blocks, try-catch-finally, <span class="No-Break">and try-with-resources</span></li>
				<li>Working with inheritance and exception handling in <span class="No-Break">method signatures</span></li>
			</ul>
			<p>So, let’s dive in and explore the world <span class="No-Break">of exceptions!</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor268"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor269"/>Understanding exceptions</h1>
			<p>In everyday life, we<a id="_idIndexMarker804"/> have to execute a lot of processes. And all the time, we have little hiccups that happen, and these should not ruin our day. These hiccups are not considered the happy path of events, but they happen often, and we recover from them and continue business <span class="No-Break">as usual.</span></p>
			<p>There are also more serious problems that can occur, for which we need to have a formal backup plan, such as evacuating a building in case of <span class="No-Break">a fire.</span></p>
			<p>Exceptions in Java are like this. These are things that should not happen; sometimes, we are in control of them happening and sometimes, we are not. In some cases, we are obligated to specify a backup plan, and in other cases, we are not. First, let’s talk a bit more about what <span class="No-Break">exceptions are.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor270"/>What are exceptions?</h2>
			<p>Exceptions are events that disrupt the normal flow of the program. They typically arise from errors or unexpected conditions that the program encounters while running. Exceptions in Java are objects. These exceptions are represented by instances of the <strong class="source-inline">Exception </strong>class or its subclasses. The <strong class="source-inline">Exception</strong> class is a subclass of the <span class="No-Break"><strong class="source-inline">Throwable</strong></span><span class="No-Break"> class.</span></p>
			<p>When an exception occurs, the Java runtime system creates an exception object containing information about the error, such as its type and the state of the program when the error occurred. This process is known as <em class="italic">throwing an exception</em>. Dealing with an exception is called <em class="italic">catching </em><span class="No-Break"><em class="italic">an exception</em></span><span class="No-Break">.</span></p>
			<p>If the <a id="_idIndexMarker805"/>exception is not caught and handled by the program, the Java runtime system will terminate the program, usually displaying an error message and the stack trace. So, let’s talk about the need for <span class="No-Break">exception handling.</span></p>
			<p class="callout-heading">Stack trace</p>
			<p class="callout">You might not know this term just yet, but you’re likely to have encountered one already. A stack trace shows up when an exception happens. It shows the “path” the code took to get to your error. Here’s <span class="No-Break">an example:</span></p>
			<p class="callout"><strong class="source-inline">Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for </strong><span class="No-Break"><strong class="source-inline">length 0</strong></span></p>
			<p class="callout">    <span class="No-Break"><strong class="source-inline">at javabook.Example.printFirstValueArray(Example.java:21)</strong></span></p>
			<p class="callout">    <span class="No-Break"><strong class="source-inline">at javabook.Example.main(Example.java:8)</strong></span></p>
			<p class="callout">As you can see in this example, the line that eventually triggered the exception is line 21 and the method name was <strong class="source-inline">printFirstValueArray</strong>. That method was called on line 8 in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor271"/>Need for exception handling</h2>
			<p>Since we don’t <a id="_idIndexMarker806"/>want our program to stop running every time it throws an exception, exception handling is a crucial aspect of programming. We typically separate the code logic from the exception-handling logic. This helps us create an application that is maintainable and resilient. When we have proper exception handling in place, our program can recover gracefully from unexpected situations. This is much more preferred than the program crashing and stopping, or even producing <span class="No-Break">incorrect results.</span></p>
			<p>Since this is <a id="_idIndexMarker807"/>so common, Java provides a built-in exception handling mechanism that allows us to catch and handle exceptions. This way, we can recover from the exception and continue executing the program. This mechanism encourages (or even forces) us to think about possible exceptional conditions that the program might encounter and write code to handle these exceptions effectively. Let’s talk about some situations in which we need <span class="No-Break">exception handling.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor272"/>Common situations that require exception handling</h2>
			<p>There are many <a id="_idIndexMarker808"/>situations in which exceptions can occur. Some of these are within our control, but the most important ones where we absolutely must deal with the possibility of an exception are situations where we are not fully in control. We’ll address a few common situations before seeing the <span class="No-Break">exception code.</span></p>
			<h3>File I/O operations</h3>
			<p>A very<a id="_idIndexMarker809"/> common situation that requires exception handling is a piece of logic that deals with file I/O operations. When working with file I/O operations, exceptions can be used to handle situations where a file is not found or cannot be read or written. These are all situations that are not in the programmer’s control. Permissions for the program might not be right, a file may have been removed, or a file might already be in use – many other situations out of your control can <span class="No-Break">also happen.</span></p>
			<p>Java has specific subclasses to deal with these types of exceptions. The main subclass to deal with I/O operations is <strong class="source-inline">IOException</strong>. It has its own subclasses, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">FileNotFoundException</strong></span><span class="No-Break">.</span></p>
			<h3>Database operations</h3>
			<p>Another type of situation where we depend on an external part is all sorts of database operations. A <a id="_idIndexMarker810"/>database can be down or altered and that’s out of your control as a developer. So, we need to deal with exceptions that can occur while connecting to, querying, or updating a database. For instance, <strong class="source-inline">SQLException</strong> can be thrown when there are issues with a database connection or when an invalid SQL query is executed or when a database constraint (a database specific rule) is violated. Proper exception handling allows your program to recover from these issues, such as by re-establishing the connection or rolling back <span class="No-Break">a transaction.</span></p>
			<h3>User input validation</h3>
			<p>When<a id="_idIndexMarker811"/> your application requires user input, exceptions can be used to handle cases where the input is invalid or does not meet the expected format. For example, <strong class="source-inline">NumberFormatException</strong> can be thrown when attempting to parse a non-numeric string as an integer. Handling this kind of exception well can help your application provide helpful feedback to users and ensure they enter valid data while keeping the core logic separated from <span class="No-Break">error handling.</span></p>
			<h3>Resource management</h3>
			<p>Your<a id="_idIndexMarker812"/> program depends on external resources, such as memory and system resources. These resources can also be third-party services, such as APIs. And in all these situations, exceptions can occur. We need to handle situations where these resources are unavailable or exhausted. For example, when<a id="_idIndexMarker813"/> the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) cannot find a memory block big enough to allocate a new object, <strong class="source-inline">OutOfMemoryError</strong> will be thrown, and <strong class="source-inline">InterruptedException</strong> can be used to handle cases where a thread is interrupted while waiting for a resource. Proper handling in these scenarios can help your application recover or gracefully degrade <span class="No-Break">its functionality.</span></p>
			<p>What might be striking is that we have an <em class="italic">error</em> for out-of-memory situations, but so far, we have been talking about <em class="italic">exceptions</em> instead of errors. Let’s have a look at the hierarchy to understand what’s going <span class="No-Break">on here.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor273"/>Understanding the exception hierarchy</h1>
			<p>Java is an <a id="_idIndexMarker814"/>object-oriented language, and objects can form a hierarchy. In Java, all exceptions are subclasses of the <strong class="source-inline">Throwable</strong> class. Everything that can be thrown by the application in case of a problem is of the <strong class="source-inline">Throwable</strong> type. The <strong class="source-inline">Throwable</strong> class has two main subclasses: <strong class="source-inline">Error</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Exception</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Errors</em> represent severe issues that occur during the runtime system’s operation, and they typically indicate critical problems with the JVM or the application environment. Examples<a id="_idIndexMarker815"/> include <strong class="source-inline">OutOfMemoryError</strong> and <strong class="source-inline">StackOverflowError</strong>. Errors are usually not recoverable, and it is <em class="italic">not</em> recommended to catch and handle them in <span class="No-Break">your code.</span></p>
			<p>On the other hand, the <strong class="source-inline">Exception</strong> class and its subclasses represent exceptional conditions that a program can handle. There are two main categories of exceptions: checked and <span class="No-Break">unchecked exceptions.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor274"/>Checked exceptions</h2>
			<p><strong class="bold">Checked exceptions</strong> are<a id="_idIndexMarker816"/> exceptions that can be expected to<a id="_idIndexMarker817"/> happen, such as situations where we are dealing with databases or files. When dealt with correctly, these are recoverable exceptions. They must be caught or declared in a method’s signature. We are going to learn how to do this in the<em class="italic"> catch or declare principle</em> section. The Java compiler requires you to handle or declare explicitly in your code. Examples include <strong class="source-inline">IOException</strong>, <strong class="source-inline">FileNotFoundException</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SQLException</strong></span><span class="No-Break">.</span></p>
			<p>Checked exceptions are subclasses of the <strong class="source-inline">Exception</strong> class, excluding <strong class="source-inline">RuntimeException</strong> and <span class="No-Break">its subclasses.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor275"/>Unchecked exceptions</h2>
			<p><strong class="bold">Unchecked exceptions</strong> represent <a id="_idIndexMarker818"/>programming errors that do not need to be explicitly dealt with. These exceptions are typically thrown<a id="_idIndexMarker819"/> because of programming errors or situations that are not expected to occur during normal <span class="No-Break">program execution.</span></p>
			<p>Since unchecked exceptions usually indicate bugs in the code, the Java compiler assumes that your program should not need to catch or declare them explicitly. However, you can still choose to catch and handle unchecked exceptions. This can come in handy when you want to provide a more user-friendly error message or log the error for <span class="No-Break">debugging purposes.</span></p>
			<p>Examples of <a id="_idIndexMarker820"/>unchecked exceptions include <strong class="source-inline">NullPointerException</strong>, <strong class="source-inline">IndexOutOfBoundsException</strong>, and <strong class="source-inline">IllegalArgumentException</strong>. These<a id="_idIndexMarker821"/> unchecked exceptions are subclasses of <strong class="source-inline">RuntimeException</strong>. This class is a subclass of <strong class="source-inline">Exception</strong>. Unlike all the other subclasses of <strong class="source-inline">Exception</strong>, <strong class="source-inline">RuntimeException</strong> and its subclasses don’t need to be handled. (You can say it’s <span class="No-Break">an… exception.)</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>, you can see this hierarchy in the form of <span class="No-Break">a diagram:</span></p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B19793_11_01.jpg" alt="Figure 11.1 – Throwable hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Throwable hierarchy</p>
			<p>Understanding the<a id="_idIndexMarker822"/> exception hierarchy <a id="_idIndexMarker823"/>is essential for effectively handling exceptions. As you can see, there are different types of exceptions. Some of them (checked exceptions) need to be handled, while others do not (<span class="No-Break">unchecked exceptions).</span></p>
			<p>In this chapter, we’ll be using I/O operations to demonstrate exceptions. This is something that we haven’t seen yet. So, let’s introduce I/O <span class="No-Break">operations first.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor276"/>Working with basic I/O operations</h1>
			<p>We’ll use I/O operations<a id="_idIndexMarker824"/> to illustrate how exceptions work. Therefore, before diving into exception handling, we’ll briefly introduce basic I/O operations. There are many ways to do this, but we’ll be using <strong class="source-inline">FileReader</strong> and <strong class="source-inline">FileWriter - FileReader</strong> and <strong class="source-inline">FileWriter</strong> are classes in the <strong class="source-inline">java.io</strong> package that allow you to read and write characters. We have chosen these two classes because they provide a simple way to work with text files in Java and are commonly used for file I/O operations in the real world as well. First things first, let’s read <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Other classes for I/O operations</p>
			<p class="callout">It is common to use other classes for I/O operations in common situations. For example, if you’re going to read lines from files, you may want to work with <strong class="source-inline">BufferedReader</strong> instead. This is not the focus of this chapter. We just want to understand enough of I/O operations to demonstrate some real situations for <span class="No-Break">exception handling.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor277"/>Reading from a file using FileReader</h2>
			<p>To read<a id="_idIndexMarker825"/> from a text file using <strong class="source-inline">FileReader</strong>, you first <a id="_idIndexMarker826"/>need to create a <strong class="source-inline">FileReader</strong> object and pass the file path as a parameter. You can then read characters from the file using the <strong class="source-inline">read()</strong> method. After using <strong class="source-inline">FileReader</strong>, you must close it to make sure you don’t lock the file and don’t use any unnecessary resources. Here’s an example of reading a file <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.io.FileReader;import java.io.IOException;
public class ReadFileExample {
    public static void main(String[] args) {
        try {
            FileReader reader = new
            FileReader("input.txt");
            int character;
            while ((character = reader.read()) != -1) {
                System.out.print((char) character);
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
			<p>This<a id="_idIndexMarker827"/> code snippet is reading from a file called <strong class="source-inline">input.txt</strong>. The <em class="italic">try-catch</em> block is something we’ll see later in this chapter; it’s for exception handling and you don’t need to understand it <span class="No-Break">just yet.</span></p>
			<p>We have created a new <strong class="source-inline">FileReader</strong> instance and passed it the path of our input file. For the read operation to work, <strong class="source-inline">input.txt</strong> has been placed in the project folder. For me, it looks like the structure shown in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B19793_11_02.jpg" alt="Figure 11.2 – Location of input.txt in the project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Location of input.txt in the project</p>
			<p>The most complicated snippet of the code that reads the file is probably the <span class="No-Break">following one:</span></p>
			<pre class="source-code">
int character;while ((character = reader.read()) != -1) {
    System.out.print((char) character);
}</pre>
			<p><strong class="source-inline">FileReader</strong> is going to <a id="_idIndexMarker828"/>read the input file character by character. The <strong class="source-inline">read()</strong> method reads a character and moves the cursor. The cursor is the place where it starts reading next. So, we need to store the result of the reading in a variable to not lose the character. When the end of the file is reached, <strong class="source-inline">read()</strong> will return <strong class="source-inline">-1</strong>. This means we need to read until we reach <strong class="source-inline">-1</strong>. And that’s exactly what <strong class="source-inline">while ((character = reader.read()) != -1)</strong> <span class="No-Break">is doing.</span></p>
			<p>Our <strong class="source-inline">input.txt</strong> file is going to be printed in the output. Of course, we can do more interesting things with the content of the file, but that’s not the goal here. All we want to see is how to deal with exceptions. The code will not run when it’s just <span class="No-Break">like this:</span></p>
			<pre class="source-code">
FileReader reader = new FileReader("input.txt");  int character;
while ((character = reader.read()) != -1) {
  System.out.print((char) character);
}
reader.close();</pre>
			<p>That’s how to read a file. Next up, we’ll learn how to write to <span class="No-Break">a file.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor278"/>Writing to a file using FileWriter</h2>
			<p>This may sound<a id="_idIndexMarker829"/> quite predictable, but to write to a text file, we can <a id="_idIndexMarker830"/>use <strong class="source-inline">FileWriter</strong>. The steps are similar to <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>First, you need to create a <strong class="source-inline">FileWriter</strong> object and pass the file path as <span class="No-Break">a parameter.</span></li>
				<li>Next, you can write characters or strings to the file using the <span class="No-Break"><strong class="source-inline">write()</strong></span><span class="No-Break"> method.</span></li>
				<li>Finally, <span class="No-Break">close </span><span class="No-Break"><strong class="source-inline">FileWriter</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Here’s an example of writing to a file <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">FileWriter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.io.FileWriter;import java.io.IOException;
public class WriteFileExample {
    public static void main(String[] args) {
        try {
            FileWriter writer = new
              FileWriter("output.txt");
            String content = "I can write!";
            writer.write(content);
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
			<p>As you <a id="_idIndexMarker831"/>can see, first, we created an instance of <strong class="source-inline">FileWriter</strong>. Next, we created a variable of the <strong class="source-inline">String</strong> type called <strong class="source-inline">content</strong>. We wrote this variable to the <strong class="source-inline">output.txt</strong> file with the <strong class="source-inline">write()</strong> method. Again, ignore the try-catch part. We’ll get to <span class="No-Break">that soon.</span></p>
			<p>Now that we’ve covered basic file I/O operations, we can proceed with exceptions and exception handling. We are going to use <strong class="source-inline">FileReader</strong> and <strong class="source-inline">FileWriter</strong> as real-world examples for handling various types <span class="No-Break">of exceptions.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor279"/>Throwing exceptions</h1>
			<p>When <a id="_idIndexMarker832"/>something goes wrong, the program <em class="italic">throws an exception</em>. This is because someone that created Java or the library that you are using, at some point, coded it that way. A lot of the Java library is programmed to throw exceptions, such as in the <span class="No-Break">following situations:</span></p>
			<ul>
				<li>When you try to access a field or method on a null <span class="No-Break">instance, </span><span class="No-Break"><strong class="source-inline">NullPointerException</strong></span></li>
				<li>When you try to divide by <span class="No-Break">0, </span><span class="No-Break"><strong class="source-inline">ArithmethicException</strong></span></li>
				<li>When you try to access an index in an array that is not part of the <span class="No-Break">array, </span><span class="No-Break"><strong class="source-inline">ArrayIndexOutOfBoundsException</strong></span></li>
			</ul>
			<p>Here’s an example of the output of code that throws <span class="No-Break">an exception:</span></p>
			<pre class="source-code">
int x = 2 / 0;</pre>			<p>This is <span class="No-Break">the output:</span></p>
			<pre class="console">
Exception in thread "main" java.lang.ArithmeticException: /by zero
    at ThrowingExceptions.main(ThrowingExceptions.java:3)</pre>
			<p>You can see the name of the exception in the output (<strong class="source-inline">java.lang.ArithmeticException</strong>), as well as the message, stating <strong class="source-inline">/ </strong><span class="No-Break"><strong class="source-inline">by zero</strong></span><span class="No-Break">.</span></p>
			<p>Underneath<a id="_idIndexMarker833"/> the exception, we can see the <em class="italic">stack trace</em>. A stack trace is<a id="_idIndexMarker834"/> the application’s steps to get to the exception. The top of the stack trace shows the line that triggered the exception. This is a very tiny stack trace because it went wrong directly in the main method, so we only have one line <span class="No-Break">in there.</span></p>
			<p>A lot of the Java library throws exceptions when problematic situations happen. This is done with the <strong class="source-inline">throw</strong> keyword. In the next section, we’re going to see how we can use this <strong class="source-inline">throw</strong> keyword to throw <span class="No-Break">exceptions ourselves.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor280"/>The throw keyword</h2>
			<p>We can<a id="_idIndexMarker835"/> throw <a id="_idIndexMarker836"/>exceptions explicitly using the <strong class="source-inline">throw</strong> keyword. This is commonly used when your code detects an exceptional condition or when you want to enforce a specific constraint in <span class="No-Break">your code.</span></p>
			<p>Here is the syntax for throwing <span class="No-Break">an exception:</span></p>
			<pre class="source-code">
throw new IllegalArgumentException("Age cannot benegative.");</pre>
			<p>We start with the <strong class="source-inline">throw</strong> keyword; after that, there’s an instance of <strong class="source-inline">Throwable</strong>. In this case, we throw a new <strong class="source-inline">IllegalArgumentException</strong> instance and specify in the message that age cannot be a <span class="No-Break">negative value.</span></p>
			<p>When an exception is thrown, the normal execution of the program is interrupted, and control goes to the nearest matching catch block. If none are present, the program stops and displays the exception and <span class="No-Break">stack trace.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor281"/>Creating and throwing custom exceptions</h2>
			<p>Java has a lot of built-in exceptions, but in some situations, you may need to have more specific exceptions. Great news – you can also create and throw your own custom exceptions! Custom exceptions are helpful when you want to provide more specific information about the problem that occurred, or when you want to handle certain types of exceptions differently in your <span class="No-Break">catch blocks.</span></p>
			<p>To<a id="_idIndexMarker837"/> create a<a id="_idIndexMarker838"/> custom exception, you need to define a new class<a id="_idIndexMarker839"/> that extends the <strong class="source-inline">Exception</strong> class or one of its subclasses. Here’s an <a id="_idIndexMarker840"/>example of a custom <span class="No-Break">exception class:</span></p>
			<pre class="source-code">
public class InvalidAgeException extends Exception {    public InvalidAgeException() {
        super();
    }
    public InvalidAgeException(String message) {
        super(message);
    }
    public InvalidAgeException(Exception e) {
        super(e);
    }
}</pre>
			<p>We overwrite the following three constructors. This is recommended to <span class="No-Break">support conventions:</span></p>
			<ul>
				<li>The <span class="No-Break"><strong class="source-inline">no-args</strong></span><span class="No-Break"> constructor</span></li>
				<li>The constructor that takes <strong class="source-inline">String</strong> containing <span class="No-Break">a message</span></li>
				<li>The constructor that takes <span class="No-Break">another exception</span></li>
			</ul>
			<p>The <strong class="source-inline">InvalidAgeException</strong> custom class <a id="_idIndexMarker841"/>extends the <strong class="source-inline">Exception</strong> class. Therefore, <strong class="source-inline">InvalidAgeException</strong> is a checked exception <a id="_idIndexMarker842"/>that needs to be handled. If it extended <strong class="source-inline">RuntimeException</strong> or one of its subclasses, it was an unchecked exception and it didn’t need to be handled. Let’s talk about catching and <span class="No-Break">handling exceptions.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor282"/>The catch or declare principle</h1>
			<p>The catch or declare principle<a id="_idIndexMarker843"/> states that when a method can throw a checked exception, the method must catch the exception with a try-catch statement or declare that it throws the exception in its method signature. This rule ensures that checked exceptions are properly handled or propagated up the call stack so that the calling method can <span class="No-Break">handle them.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor283"/>Understanding the principle</h2>
			<p>The catch <a id="_idIndexMarker844"/>or declare principle holds for checked exceptions. If a checked exception is not declared or caught, the code won’t compile. For unchecked exceptions, the catch or declare rule does not apply. They are usually caused by programming errors or unexpected situations that cannot be predicted or anticipated. Unchecked exceptions can be caught and handled, but it is not mandatory. Let’s see how we can <span class="No-Break">declare exceptions.</span></p>
			<p>Now that we have seen how to declare exceptions, let’s have a look at how to deal with exceptions with the <span class="No-Break">try-catch statement.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor284"/>Declaring exceptions using throws</h2>
			<p>The <strong class="source-inline">throws</strong> keyword <a id="_idIndexMarker845"/>is used to declare that a method may throw a certain exception. By using the <strong class="source-inline">throws</strong> keyword, you can indicate that a method may throw one or more checked exceptions. The method that calls the other method that declares the exception is responsible for <span class="No-Break">handling them.</span></p>
			<p>Declaring an exception is not difficult. You can simply add <strong class="source-inline">throws</strong> to the method signature followed by the exception type. Here’s an example of a piece of code <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
 public static void read(String fileName) <strong class="bold">throws</strong><strong class="bold">   IOException</strong> {
    FileReader = new FileReader(fileName);
}</pre>
			<p>In this example, the <strong class="source-inline">read</strong> method declares that it may throw <strong class="source-inline">IOException</strong>. When another method calls this method, it is responsible for handling the exception. When you know how you want to deal with an exception, you can handle it with the try-catch statement instead of <span class="No-Break">declaring it.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor285"/>Handling exceptions with try-catch</h2>
			<p>When a <a id="_idIndexMarker846"/>method declares a checked exception, the calling<a id="_idIndexMarker847"/> method is obligated to deal with it. This can be done by catching the exception or by declaring the exception in its own <span class="No-Break">method signature.</span></p>
			<p>Let’s have a look at how to deal with exceptions using a try-catch block. Try-catch blocks come in different forms, but we’ll start with the <span class="No-Break">most basic.</span></p>
			<h3>Basic try-catch block</h3>
			<p>A try-catch block<a id="_idIndexMarker848"/> is used to handle exceptions that might be thrown during the execution of a specific block of code. The code that might throw an exception is placed inside the <strong class="source-inline">try</strong> block, and the code to handle the exception is placed inside the corresponding <strong class="source-inline">catch</strong> block. Here’s the syntax of a <span class="No-Break">try-catch block:</span></p>
			<pre class="source-code">
try {  //... code that might throw an exception ...
} catch(SomeException e) {
  //... code that handles the exception ...
}</pre>
			<p>And here’s an<a id="_idIndexMarker849"/> example of a basic try-catch block that actually has some code that might throw an exception and some basic handling. We saw this when we were learning <span class="No-Break">about </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.io.FileReader;import java.io.IOException;
public class ReadingFile {
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader("input.txt");
            int character;
            while ((character = fr.read()) != -1) {
                System.out.print((char) character);
            }
            fr.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
			<p>In this<a id="_idIndexMarker850"/> code, <strong class="source-inline">FileReader</strong> can throw multiple exceptions. For example, when the file does not exist, it will throw <strong class="source-inline">FileNotFoundException</strong>. This exception is an <strong class="source-inline">IOException</strong>, which, in turn, is an <strong class="source-inline">Exception</strong>. Therefore, <strong class="source-inline">FileReader</strong> might throw a checked exception. And checked exceptions need to be handled. Therefore, we must place the code that can throw the exception(s) in the try block. We handle <strong class="source-inline">Exception</strong> in the catch block by printing the stack trace. After handling the exception, the program’s execution <span class="No-Break">continues normally.</span></p>
			<p>We can also specify multiple catch blocks if we need to specify specific handling for different kinds <span class="No-Break">of exceptions.</span></p>
			<h3>Multiple catch blocks</h3>
			<p>A block of code may<a id="_idIndexMarker851"/> throw multiple types of exceptions. We can <a id="_idIndexMarker852"/>handle different exceptions using <em class="italic">multiple catch blocks</em>. It’s important to have the most specific exception on top. If we were to start by catching <strong class="source-inline">Exception</strong>, for example, it would always go to that catch block. This is because all exceptions inherit from Exception and would be of type Exception. The <strong class="source-inline">catch(Exception e) </strong>would catch every possible exception, making the rest of the catch clauses unreachable. Therefore, it doesn’t compile if you try to <span class="No-Break">do that.</span></p>
			<p>Here’s an<a id="_idIndexMarker853"/> example of using<a id="_idIndexMarker854"/> multiple <span class="No-Break">catch blocks:</span></p>
			<pre class="source-code">
public class MultipleCatchExample {    public static void main(String[] args) {
        try {
            FileReader fr= new FileReader("input.txt");
            int character;
            while ((character = fr.read()) != -1) {
                System.out.print((char) character);
            }
            fr.close();
        } catch (FileNotFoundException e) {
            System.out.println("Not found:" +
              e.getMessage());
        } catch (IOException e) {
            System.out.println("IO error:" +
              e.getMessage());
        }
    }
}</pre>
			<p>In this example, we have two catch blocks – one for <strong class="source-inline">FileNotFoundException</strong> and one for <strong class="source-inline">IOException</strong>. If an exception is thrown, the appropriate catch block will be executed based on the <span class="No-Break">exception type.</span></p>
			<p>Sometimes, we want to clean up resources after the catch or perform other sorts of actions. We can do so with the <span class="No-Break"><strong class="source-inline">finally</strong></span><span class="No-Break"> block.</span></p>
			<h3>Try-catch-finally</h3>
			<p>The <strong class="source-inline">finally</strong> block is <a id="_idIndexMarker855"/>an optional block of code that follows a try-catch block. It is <a id="_idIndexMarker856"/>executed regardless of whether an exception is thrown or not. The <strong class="source-inline">finally</strong> block is typically used to clean up resources. These resources could be file streams or network connections that <span class="No-Break">need closing.</span></p>
			<p>Here’s an example of <a id="_idIndexMarker857"/>using a <span class="No-Break"><strong class="source-inline">finally</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
public class TryCatchFinallyExample {    public static void main(String[] args) {
        try {
            // Code that might throw an exception
        } catch (Exception e) {
            System.out.println("Oops: " + e.getMessage());
        } finally {
            System.out.println("This code will always
              run.");
        }
    }
}</pre>
			<p>In this example, the <strong class="source-inline">finally</strong> block is executed after the <strong class="source-inline">try-catch</strong> block, regardless of whether an exception occurred. The only way to not execute the <strong class="source-inline">finally</strong> block is to stop the program completely before it completes the <span class="No-Break"><strong class="source-inline">try-catch</strong></span><span class="No-Break"> block.</span></p>
			<h4>Use cases for the finally block</h4>
			<p>The <strong class="source-inline">finally</strong> block can <a id="_idIndexMarker858"/>be used to clean up resources. This ensures that they are properly released, even if an exception is thrown. Here’s an example of using a <strong class="source-inline">finally</strong> block to close the instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">FileReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.io.*; public class FileResourceCleanup {
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            reader = new FileReader("input.txt");
            int character;
            while ((character = reader.read()) !=-1){
                System.out.print((char) character);
            }
        } catch (IOException e) {
            System.out.println("Err: " + e.getMessage());
        } finally {
            if (reader != null){
                try {
                    reader.close();
                } catch (IOException e) {
                    System.out.println("Err closing: " +
                      e.getMessage());
                }
            }
        }
    }
}</pre>
			<p>This example is a little different. Let’s start with the most striking difference: we close the <strong class="source-inline">readerin</strong> the finally block now. This ensures that <strong class="source-inline">readergets</strong> closed, even if an exception occurs in the try block before it gets to <span class="No-Break">that line.</span></p>
			<p>For <strong class="source-inline">reader</strong> to be <a id="_idIndexMarker859"/>still in scope in the <strong class="source-inline">finally</strong> block, we have to declare it outside of the <strong class="source-inline">try</strong> block. That’s why we have this line on top of the <span class="No-Break"><strong class="source-inline">try</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
FileReader reader = null;</pre>			<p>We can’t initialize it outside of the <strong class="source-inline">try</strong> block because that part needs to be in the <strong class="source-inline">try</strong> block since it may throw <span class="No-Break">an exception.</span></p>
			<p>Here’s the flow of the code when no <span class="No-Break">exception occurs:</span></p>
			<ol>
				<li><strong class="source-inline">try</strong>: Initialize <strong class="source-inline">FileReader</strong> and read <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">finally</strong>: <span class="No-Break">Close </span><span class="No-Break"><strong class="source-inline">reader</strong></span><span class="No-Break">.</span></li>
				<li>Continue after the <strong class="source-inline">finally</strong> block with the rest of <span class="No-Break">the code.</span></li>
			</ol>
			<p>And here’s the flow of the code when an <span class="No-Break">exception occurs:</span></p>
			<ol>
				<li><strong class="source-inline">try</strong>: Initialize <strong class="source-inline">FileReader</strong> and read <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">catch</strong>: Handle <span class="No-Break">the exception.</span></li>
				<li><strong class="source-inline">finally</strong>: close <span class="No-Break">the reader.</span></li>
				<li>Continue after the <strong class="source-inline">finally</strong> block with the rest of <span class="No-Break">the code.</span></li>
			</ol>
			<p>So, regardless of whether an exception is thrown, the <strong class="source-inline">finally</strong> block ensures <strong class="source-inline">reader </strong><span class="No-Break">is closed.</span></p>
			<p>Closing <strong class="source-inline">reader</strong> might throw another exception, which is why we have another try-catch statement in the <strong class="source-inline">finally</strong> block. Arguably, this is not a very pretty syntax. A solution for many of these situations is using the<strong class="bold"> try-with-resources</strong> <span class="No-Break">statement instead.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor286"/>Handling exceptions with try-with-resources</h2>
			<p>Java 7 introduced the<a id="_idIndexMarker860"/> <strong class="bold">try-with-resources</strong> <a id="_idIndexMarker861"/>statement, which automatically manages resources such as file streams and network connections. This eliminates the need for the <strong class="source-inline">finally</strong> block for resource cleaning for many types of classes. The try-with-resources statement can be used without a catch or <strong class="source-inline">finally</strong> block. The normal <strong class="source-inline">try</strong> statement must have at least one <span class="No-Break">of those.</span></p>
			<h3>What is try-with-resources?</h3>
			<p>The try-with-resources<a id="_idIndexMarker862"/> statement takes care of resource management for you. A resource is a special Java object that opens a channel that needs to be closed in order for the resource to be marked for cleanup by Java. We have seen that the FileReader objects are examples <span class="No-Break">of this.</span></p>
			<p>The resources that are declared within the try-with-resources statement will be automatically closed when the <strong class="source-inline">try</strong> block completes. And of course, just like the <strong class="source-inline">finally</strong> block, it doesn’t matter whether or not an exception is thrown. The resources will <span class="No-Break">be closed.</span></p>
			<p>Here’s an example of <span class="No-Break">using try-with-resources:</span></p>
			<pre class="source-code">
try (FileReader fileReader = new FileReader("input.txt")) {    int character;
    StringBuilder content = new StringBuilder();
    while ((character = fileReader.read()) != -1) {
        content.append((char) character);
    }
    System.out.println(content.toString());
} catch (IOException e) {
    System.out.println("Oops: " + e.getMessage());
}</pre>
			<p>The resources need to be opened between the parentheses following the <strong class="source-inline">try</strong> block. At the end of the <strong class="source-inline">try</strong> block, the resources will <span class="No-Break">be closed.</span></p>
			<p>You can open multiple ones separated with a semicolon, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
try (FileReader fileReader = new FileReader("input.txt");     BufferedReader bufferedReader = new BufferedReader
       (fileReader);
     FileWriter fileWriter = new FileWriter("output.txt");
     BufferedWriter bufferedWriter = new BufferedWriter
       (fileWriter)) {
    String line;
    while ((line = bufferedReader.readLine()) != null) {
        String uppercaseLine = line.toUpperCase();
        bufferedWriter.write(uppercaseLine);
        bufferedWriter.newLine();
    }
} catch (IOException e) {
    System.out.println("Oops: " + e.getMessage());
}</pre>
			<p>You don’t <a id="_idIndexMarker863"/>need to understand the details of the code in this example since we did not talk about <strong class="source-inline">BufferedReader</strong> and <strong class="source-inline">BufferedWriter</strong>. These classes are utility classes that provide buffering capabilities for reading and writing text files. With buffering, we can improve the performance of I/O operations by minimizing the number of <span class="No-Break">system calls.</span></p>
			<p>The preceding code snippet uses <strong class="source-inline">FileReader</strong> and <strong class="source-inline">BufferedReader</strong> to read the contents of a file, while <strong class="source-inline">FileWriter</strong> and <strong class="source-inline">BufferedWriter</strong> are used to convert content (all uppercase) <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">output.txt</strong></span><span class="No-Break">.</span></p>
			<p>The <a id="_idIndexMarker864"/>try-with-resources block ensures that all resources are automatically closed after their use. It does so in the opposite order of declaring them, so it starts by closing the last. This is important because, as you can see, we’re using <strong class="source-inline">fileWriter</strong> to create <strong class="source-inline">bufferedWriter</strong>. Closing them in a different order may <span class="No-Break">cause issues.</span></p>
			<p>Please don’t forget, not all classes can be automatically closed. For Java to be able to automatically close a class, the class needs to implement the <span class="No-Break"><strong class="source-inline">AutoCloseable</strong></span><span class="No-Break"> interface.</span></p>
			<h3>Implementing the AutoCloseable interface</h3>
			<p>To be able to use a (custom) class with the try-with-resources statement, the class should<a id="_idIndexMarker865"/> implement the <strong class="source-inline">AutoCloseable</strong> interface and override the <span class="No-Break"><strong class="source-inline">close()</strong></span><span class="No-Break"> method.</span></p>
			<p>We can create our own classes that can be automatically closed. Here’s an example of a custom resource that <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">AutoCloseable</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class SomeResource implements AutoCloseable {    public void doSomething() {
        System.out.println("Doing something...");
    }
    @Override
    public void close() {
        System.out.println("Resource closed.");
    }
}</pre>
			<p>This resource can now be used in a <span class="No-Break">try-with-resources statement:</span></p>
			<pre class="source-code">
public class SomeResourceExample {    public static void main(String[] args) {
        try (SomeResource resource = new SomeResource()) {
            resource.doSomething();
        }
    }
}</pre>
			<p>This code opens <strong class="source-inline">SomeResource</strong> in the try-with-resources statement. We then call the <strong class="source-inline">doSomething()</strong> method, which prints a line to the console. At the end of the block, the resource is closed. We print another line in the <strong class="source-inline">close()</strong> method that we had to implement for the <span class="No-Break"><strong class="source-inline">AutoCloseable</strong></span><span class="No-Break"> interface.</span></p>
			<p>This is <span class="No-Break">the output:</span></p>
			<pre class="console">
Doing something...Resource closed.</pre>
			<p>As you can see, it<a id="_idIndexMarker866"/> prints the line from the <strong class="source-inline">doSomething()</strong> method. The <strong class="source-inline">close()</strong> method also gets triggered. As we can see, the message that it prints in the output as well. We don’t trigger the <strong class="source-inline">close()</strong> method ourselves, this is done by the mechanism of the <span class="No-Break"><strong class="source-inline">try-with-resource</strong></span><span class="No-Break"> statement.</span></p>
			<p>That’s the basics of the try-with-resources statement so that you can start working with it. It’s now time for a topic that is often considered to be quite challenging: dealing with inheritance <span class="No-Break">and exceptions.</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor287"/>Working with inheritance and exceptions</h1>
			<p>When a class inherits from another class, it can override the methods in this other class. There are some special <a id="_idIndexMarker867"/>rules for dealing with the <a id="_idIndexMarker868"/>declared exceptions and overriding methods. It’s important to understand this to successfully override methods that <span class="No-Break">declare exceptions.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>Declaring exceptions in method signatures</h2>
			<p>When a method can<a id="_idIndexMarker869"/> throw a checked exception that isn’t dealt with in that method by a try-catch, it is declared in the method’s signature. We have just learned that this is done with the <strong class="source-inline">throws</strong> keyword, followed by the <span class="No-Break">exception type(s).</span></p>
			<p>Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public void readFile(String filename) throws IOException {    // Read file code
}</pre>
			<p>The <strong class="source-inline">readFile</strong> method’s signature declares that it can throw <strong class="source-inline">IOException</strong>. When we extend the class that this method is in, we can override the <strong class="source-inline">readFile</strong> method. There are some important rules for how to deal with exceptions that <span class="No-Break">are declared.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/>Overriding methods and exception handling</h2>
			<p>Let’s step<a id="_idIndexMarker870"/> away from the code for a second here and think of this a little bit more abstractly and concretely at the same time. Let’s say <a id="_idIndexMarker871"/>you and I meet up next week to discuss a software application at your office, and I’m telling you I’ll have to bring my young kids due to daycare issues. You know that certain <em class="italic">exceptions</em> may occur: tantrums, fights between the kids, random food in your hair and on your clothes, and so on. However, you agree to <span class="No-Break">meet me.</span></p>
			<p>If I’m planning on also bringing my three rottweilers because my dog sitter cancels, I may want to inform you about this beforehand so you can decide whether it’s still okay for me to come over with these new conditions. You have incorporated the <em class="italic">kids exceptions</em> in your decision already, but you haven’t decided whether you are also okay with <em class="italic">dog exceptions</em> yet. This includes muddy paws, drool, dog hair, and potentially accidentally sharing your cookie with one of the <span class="No-Break">gentle giants.</span></p>
			<p>It’s probably considered polite to inform you about bringing the cuddly protectors over beforehand. However, if I end up having a babysitter and I come by myself, I probably don’t need to mention that in advance because it makes it more convenient. (No, I don’t hate <span class="No-Break">my kids.)</span></p>
			<p>Alright – keep this in mind while we make the transition back <span class="No-Break">to Java.</span></p>
			<p>When you override a method in a subclass, the overriding method must follow certain rules <span class="No-Break">regarding exceptions:</span></p>
			<ul>
				<li>It cannot throw checked exceptions that weren’t declared in the signature of the method in the parent class. (We cannot bring the dogs <span class="No-Break">without notice.)</span></li>
				<li>If the overridden method declares a checked exception, the overriding method can declare the same exceptions, a subclass of that exception, or a subset of the exceptions. (Bringing just one kid instead <span class="No-Break">of two).</span></li>
				<li>Nothing can also be considered a subset. So, we can also choose not to declare any exception in the child class that overrides the method. (Not bringing <span class="No-Break">the kids.)</span></li>
			</ul>
			<p>Here’s an example of an override that declares <span class="No-Break">a subclass:</span></p>
			<pre class="source-code">
class Parent {    public void readStuff() throws IOException {
        // Parent implementation
    }
}
class Child extends Parent {
    @Override
    public void readStuff () throws FileNotFoundException {
        // Child implementation
    }
}</pre>
			<p>The <strong class="source-inline">Child</strong> class <a id="_idIndexMarker872"/>overrides the <strong class="source-inline">readStuff</strong> method from the <strong class="source-inline">Parent</strong> class. Since the overridden method <a id="_idIndexMarker873"/>declares the <strong class="source-inline">IOException</strong>, the overriding method can declare the same exception or a subclass of it (for example, <strong class="source-inline">FileNotFoundException</strong>) or not declare any exception <span class="No-Break">at all.</span></p>
			<p>Unchecked exceptions can always be added. They don’t have any consequences for the calling code. At the same time, declaring them, in general, doesn’t make a lot of sense, since it’s not obligated to deal <span class="No-Break">with them.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor290"/>Exercises</h1>
			<p>Let’s deal with <a id="_idIndexMarker874"/>some common unhappy path scenarios in our app. When these occur, we need our app to be able to recover <span class="No-Break">from them:</span></p>
			<ol>
				<li>When reading and writing the dinosaur data, it is possible that the file cannot be opened due to different circumstances. Perhaps someone moved it, it’s in use, or something else. Your task is to simulate a situation where you’re trying to read from a file (that may not exist) and deal with the <span class="No-Break">checked exception.</span></li>
				<li>While updating dinosaur data, invalid values could sometimes be provided. Write an <strong class="source-inline">updateDinosaurWeight</strong> method that takes a weight value and a <strong class="source-inline">Dinosaur</strong> object. If the weight value is less than zero, the method should throw <strong class="source-inline">IllegalArgumentException</strong>. Use a try-catch block to handle this exception. The handling can be a simple <strong class="source-inline">System.out.println</strong> <span class="No-Break">for now.</span></li>
				<li>Even in <a id="_idIndexMarker875"/>exceptional circumstances, certain operations should always execute. For example, a daily audit of dinosaurs’ health should happen, whether an exception occurs (for example due to the weight being too low) or not. Use a <strong class="source-inline">finally</strong> block in your program to demonstrate this. Code the logic so that even if there is an error in updating a dinosaur’s health record, a message about the daily audit completion should still <span class="No-Break">be printed.</span></li>
				<li>In our dinosaur park, data about dinosaurs’ diets is stored in external resources . In this case, that external resource is a file. Write a program where you use a try-with-resources block to read data from this file, ensuring the file is closed properly after use, even if an error occurs during data retrieval. Here’s a sample file called <strong class="source-inline">DinoDiet.txt</strong> that you <span class="No-Break">can use:</span><pre class="source-code">
Tyrannosaurus: CarnivoreBrachiosaurus: HerbivoreTriceratops: HerbivoreVelociraptor: CarnivoreStegosaurus: HerbivoreSpinosaurus: CarnivoreAnkylosaurus: Herbivore</pre></li>				<li>If a dinosaur’s health score falls below a certain critical value, the program should throw a<a id="_idIndexMarker876"/> custom exception, named <strong class="source-inline">CriticalHealthException</strong>. Create this custom exception and use it in your program to handle this specific <span class="No-Break">problematic condition.</span></li>
			</ol>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor291"/>Project – dinosaur care system</h1>
			<p>Running a <a id="_idIndexMarker877"/>dinosaur park is filled with unexpected situations. Some are minor, such as running out of cheese-flavored potato chips. Some are major, such as an escaped T-Rex. The happiness, health, and safety of our dinosaurs and visitors are important, so our system should be able to handle <span class="No-Break">exceptional situations.</span></p>
			<p>Design a “dinosaur care system” for Mesozoic Eden that handles exceptional situations such as a dinosaur falling ill, enclosure breaches, and so on. Use appropriate exceptions to represent various error conditions and handle <span class="No-Break">them properly.</span></p>
			<p>Here are the steps to <span class="No-Break">do this:</span></p>
			<ol>
				<li>Set up <span class="No-Break">your project:</span><ol><li class="upper-roman">Create a new Java project in your IDE <span class="No-Break">of choice.</span></li><li class="upper-roman">Create a new package <span class="No-Break">named exception.</span></li></ol></li>
				<li>Create <span class="No-Break">custom exceptions:</span><ol><li class="upper-roman">Create a new class called <strong class="source-inline">DinosaurIllException</strong> inside the exception package. This class should extend the <strong class="source-inline">Exception</strong> class and represent an error condition when a dinosaur <span class="No-Break">falls ill.</span></li><li class="upper-roman">Similarly, create <strong class="source-inline">EnclosureBreachedException</strong> for an error condition where an enclosure has <span class="No-Break">been breached.</span></li></ol></li>
				<li>Create the dinosaur <span class="No-Break">care system:</span><ol><li class="upper-roman">Create a new class <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">DinosaurCareSystem</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Inside this class, create a method called <strong class="source-inline">handleDinosaurHealth()</strong> that throws <strong class="source-inline">DinosaurIllException</strong>. You can simulate random health conditions for <span class="No-Break">the dinosaur.</span></li><li class="upper-roman">Similarly, create a method called <strong class="source-inline">handleEnclosureSecurity()</strong> that throws <strong class="source-inline">EnclosureBreachedException</strong>. Using this, you can simulate the <a id="_idIndexMarker878"/>random security status of <span class="No-Break">dinosaur enclosures.</span></li></ol></li>
			</ol>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor292"/>Summary</h1>
			<p>We’ve just explored the importance of exception handling. We now know how it allows us to separate the code logic from the error handling logic. We delved into the two main types of exceptions: checked and unchecked. Checked exceptions are exceptions that require explicit handling, whereas unchecked exceptions are usually caused by programming errors and do not need to be explicitly caught <span class="No-Break">or declared.</span></p>
			<p>We discussed the catch or declare principle, which requires checked exceptions to be caught in a try-catch block or declared in a method’s signature. The try-catch block allows us to handle exceptions by executing alternative code when an exception occurs. We also learned about using multiple catch blocks to handle <span class="No-Break">different types.</span></p>
			<p>Next, we saw the <strong class="source-inline">finally</strong> block, which is executed regardless of whether an exception occurs. This block is useful for cleaning up resources and ensuring certain actions are always performed. This <strong class="source-inline">finally</strong> block is less common since Java 7 and try-with-resources is used whenever possible. This simplifies resource management by automatically closing resources when the <strong class="source-inline">try</strong> block <span class="No-Break">finishes executing.</span></p>
			<p>Finally, we examined method exception signatures and how they relate to inheritance while focusing on the rules for checked exceptions when <span class="No-Break">overriding methods.</span></p>
			<p>At this point, you should have a solid understanding of Java exception handling. Now, it’s time to learn a little more about the Java <span class="No-Break">core API.</span></p>
		</div>
	</body></html>