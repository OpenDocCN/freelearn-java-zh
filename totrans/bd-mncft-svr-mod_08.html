<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Making Your Plugin Configurable" id="1O8H61-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Making Your Plugin Configurable</h1></div></div></div><p class="calibre8">A configurable plugin can be very powerful. A single plugin will be able to function in different ways, depending on user preferences. Essentially, your plugin's configuration file will be similar to the <code class="email">bukkit.yml</code> file for your server. It will allow you to change settings for the plugin without modifying the Java code. This means that you need not rebuild the plugin JAR file every time you wish to change a small detail. If your plugin is public or used by someone else, adding a <code class="email">config</code> file may reduce the time spent on modifying code in the future. The users of your plugin can change the settings that are in the <code class="email">config</code> file by themselves and do not require any additional assistance from you as a developer.</p><p class="calibre8">To fully understand why we would want a variable to be configurable, let's look at one of the plugins that we previously talked about. In <code class="email">MobEnhancer</code>, we set the health of zombies to <code class="email">40</code> instead of <code class="email">20</code>. Someone else may wish to use your plugin, but they want to set the zombies' health to <code class="email">60</code>. You can create two versions of the plugin, which may become very confusing, or you can have one version that is configurable. In the <code class="email">config</code> file on your server, you will have the health of zombies set to <code class="email">40</code>. But on another server, the health will be set to <code class="email">60</code>. Even if your plugin will be used on only one server, configuration will allow for a quick and easy method of changing the amount of health.</p><p class="calibre8">There are five steps to making your plugin configurable, which are as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Decide exactly which aspects of your plugin will be configurable</li><li class="listitem" value="2">Create a <code class="email">config.yml</code> file that includes each setting and its default value</li><li class="listitem" value="3">Add code to save the default <code class="email">config</code> file as well as load/reload the file</li><li class="listitem" value="4">Read the configured values and store them in your plugin as class variables</li><li class="listitem" value="5">Ensure that your code references the class variables that the configuration settings are loaded into</li></ol><div class="calibre13"/></div><p class="calibre8">The steps need not be performed in this order, but we will discuss them in the following order in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Configurable data types</li><li class="listitem">Writing a <code class="email">config.yml</code> file</li><li class="listitem">Saving, loading, and reloading your plugin's configuration</li><li class="listitem">Reading values from the configuration</li><li class="listitem">Using the configured settings in your plugin</li><li class="listitem">Writing an <code class="email">ItemStack</code> value in the YAML format</li><li class="listitem">Understanding the YAML structure and hierarchy</li><li class="listitem">Storing configuration values locally</li><li class="listitem">Splitting one class into multiple classes and accessing variables and methods from another class</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Making Your Plugin Configurable" id="1O8H61-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Configurable data types"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec53" class="calibre1"/>Configurable data types</h1></div></div></div><p class="calibre8">You can easily make most <a id="id199" class="calibre1"/>variables in your plugin configurable. The following table comprises various data types and examples of why you may want them to be configurable:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Data Type</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">How It Can Be Used</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">
<code class="literal">int</code>
</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">To define the number of times an event should occur</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">
<code class="literal">double</code>
</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">To set the health of a mob when it spawns</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">
<code class="literal">boolean</code>
</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">To turn a specific feature on or off</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">
<code class="literal">String</code>
</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">To change a message that is sent to a player</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">
<code class="literal">ItemStack</code>
</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">To make a customized item appear</p>
</td></tr></tbody></table></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre8">Adding an <code class="email">ItemStack</code> value to a configuration file is complicated, but this will be explained towards the end of this chapter.</p></div><p class="calibre8">We are going to make <code class="email">MobEnhancer</code> configurable. We want to give the players a choice of setting the value of the zombies' health. This will simply be one <code class="email">double</code> value. Let's expand the plugin to support additional creature types. We will create the <code class="email">config</code> file first and then adapt the program to be able to modify different types of mobs. Therefore, we have decided that the <code class="email">config</code> file <a id="id200" class="calibre1"/>will include a single <code class="email">double</code> data type value for each type of mob. This <code class="email">double</code> value will be the mob's health.</p></div></div>
<div class="book" title="Writing a config.yml file" id="1P71O1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec54" class="calibre1"/>Writing a config.yml file</h1></div></div></div><p class="calibre8">Now, it is time to start<a id="id201" class="calibre1"/> writing the <code class="email">config.yml</code> file. Create a new <code class="email">YAML</code> file in the default package of <code class="email">MobEnhancer</code>. The name of this file must be <code class="email">config.yml</code> in order for it to be properly loaded by Spigot. The following is an example of how the <code class="email">config</code> file for <code class="email">MobEnhancer</code> will appear. Note the comments in the example indicated by the <code class="email">#</code> character. Remember to always include comments so that users know exactly what each setting is for:</p><div class="informalexample"><pre class="programlisting">#MobEnhancer Config
#Set the health of each Mob below 
#1.0 is equal to half a heart so a Player has 20.0 health
#A value of -1.0 will disable modifying the mob's health
#Hostile
ZOMBIE: 20.0
SKELETON: 20.0

#Passive
COW: 10.0
PIG: 10.0</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre8">Only a few mobs are included in this <code class="email">config</code> file, but the names of all the mob types can be found in the API documentation <a id="id202" class="calibre1"/>for the <code class="email">EntityType</code> class at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html</a>.</p></div><p class="calibre8">This is a simple <code class="email">YAML</code> file because it does not contain nested keys. Most of your configurations will be this simple, but we will go over some complicated ones later in this chapter.</p></div>
<div class="book" title="Saving, loading, and reloading the config file" id="1Q5IA1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec55" class="calibre1"/>Saving, loading, and reloading the config file</h1></div></div></div><p class="calibre8">Now that we<a id="id203" class="calibre1"/> have the <code class="email">config.yml</code> file and it is located in the default package <a id="id204" class="calibre1"/>of the plugin, we need to be able to save it to a user's server. Once the<a id="id205" class="calibre1"/> file is saved, the user will be able to edit it as they please. Saving the <code class="email">config</code> file is as simple as adding the following method call to the <code class="email">onEnable</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">saveDefaultConfig();</pre></div><p class="calibre8">This will copy <code class="email">config.yml</code> to <code class="email">plugins/MobEnhancer/config.yml</code>. If the file already exists, then this line of code will do nothing.</p><p class="calibre8">The loading of the <code class="email">config</code> file is done automatically by Spigot, and there is no need for you to do anything in addition to this in your plugin besides using <code class="email">getConfig</code> when you actually want to access the configuration file.</p><p class="calibre8">Reloading <code class="email">config.yml</code> is fairly simple to include; we will add it in the form of a command, as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public boolean onCommand(CommandSender sender, Command command, String alias, String[] args) {
    reloadConfig();
    sender.sendMessage("MobEnhancer config has been reloaded");
    return true; //The command was executed successfully
}</pre></div><p class="calibre8">We will put this<a id="id206" class="calibre1"/> method inside the <code class="email">main</code> class for now. Ensure that the class also <a id="id207" class="calibre1"/>implements <code class="email">CommandExecutor</code>. Do not forget to register the<a id="id208" class="calibre1"/> command with the following line:</p><div class="informalexample"><pre class="programlisting">getCommand("mobenhancerreload").setExecutor(this);</pre></div><p class="calibre8">The command should also be added to <code class="email">plugin.yml</code>, as always. It is a good idea to add a permission node at this point too. The new <code class="email">plugin.yml file</code> looks like this:</p><div class="informalexample"><pre class="programlisting">name: MobEnhancer
main: com.codisimus.mobenhancer.MobEnhancer
version: 0.2
description: Modifies Mobs as they spawn
commands:
  mobenhancerreload:
    description: Reloads the config.yml file of the plugin
    aliases: [mereload, merl]
    usage: /&lt;command&gt;
    permission: mobenhancer.rl
    permission-message: You do not have permission to do that
permissions:
  mobenhancer.rl:
    default: op</pre></div><p class="calibre8">Now, your plugin will have a <code class="email">reload</code> command. This means that when you edit <code class="email">config.yml</code>, you can reload the plugin rather than restarting the entire server.</p></div>
<div class="book" title="Reading and storing the configured values" id="1R42S1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec56" class="calibre1"/>Reading and storing the configured values</h1></div></div></div><p class="calibre8">Once your configuration<a id="id209" class="calibre1"/> file is loaded, you must be able to access the file and<a id="id210" class="calibre1"/> read the values that are set. The <code class="email">JavaPlugin</code> class, which is extended by the main class, has a <code class="email">getConfig</code> method, which returns <code class="email">FileConfiguration</code>. This <code class="email">FileConfiguration</code> class is what we will use to get the values that we are looking for. You will see that the <code class="email">FileConfiguration</code> class has methods such as <code class="email">getInt</code>, <code class="email">getDouble</code>, <code class="email">getString</code>, and <code class="email">getBoolean</code>; all of these methods take a string as a parameter. The <code class="email">string</code> parameter is the path to the value. To fully understand the path, we need to look at a YAML configuration that contains nested keys. An example of this is the <code class="email">plugin.yml</code> file that we were just working with. If we want to get the <code class="email">MobEnhancer</code> string from the configuration, then the path will be <code class="email">name</code>. If we want to retrieve the description of the <code class="email">mobenhancerreload</code> command, then the path will be <code class="email">commands.mobenhancerreload.description</code>. Therefore, the Java code needed to retrieve this value will be <code class="email">getString("commands.mobenhancerreload.description");</code>. The <code class="email">config.yml</code> file for <code class="email">MobEnhancer</code> is quite simple. In order to get one of the double values, we can use the <code class="email">getDouble()</code> method with the name of the mob as the path. For example, to get the value that is set for the <code class="email">ZOMBIE Entity</code>, we will use the following code:</p><div class="informalexample"><pre class="programlisting">double health = this.getConfig().getDouble("ZOMBIE");</pre></div><p class="calibre8">This will return a <code class="email">double</code> value from one of the following three sources:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">FileConfiguration</code> that has been loaded from <code class="email">plugins/MobEnhance/config.yml</code></li><li class="listitem">The default <code class="email">FileConfiguration</code>, which is the <code class="email">config.yml</code> file that is located within the default package of the <code class="email">MobEnhancer</code> JAR file</li><li class="listitem">The default value of the data type (<code class="email">0</code> for a <code class="email">double/integer</code> data type, <code class="email">false</code> for a Boolean value, and <code class="email">null</code> for a String/<code class="email">ItemStack</code>)</li></ul></div><p class="calibre8">The first result that doesn't fail will be returned. A result will fail due to an invalid path or an invalid value. In the previous statement, an invalid path will occur if the <code class="email">ZOMBIE</code> path is not within <code class="email">config.yml</code>. An invalid value will mean that the value of the given path is not a <code class="email">double data type</code>.</p><p class="calibre8">Now that we understand how to read the configured data, let's modify the plugin to use these customized values.</p></div>
<div class="book" title="Using configured settings within your plugin" id="1S2JE1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec57" class="calibre1"/>Using configured settings within your plugin</h1></div></div></div><p class="calibre8">The <a id="id211" class="calibre1"/>current <code class="email">EventHandler method</code> of the <code class="email">MobEnhancer</code> plugin <a id="id212" class="calibre1"/>sets the health of zombies to <code class="email">40</code>, where the number 40 is <a id="id213" class="calibre1"/>
<span class="strong"><strong class="calibre2">hardcoded</strong></span>. This means that the value of <code class="email">40</code> is a part of the code itself, and this cannot be changed after the code is compiled. We wish to make this value <a id="id214" class="calibre1"/>
<span class="strong"><strong class="calibre2">softcoded</strong></span>, that is, we want to retrieve the value from an external source, which is <code class="email">config.yml</code> in our case:</p><p class="calibre8">Currently, the <code class="email">onMobSpawn</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@EventHandler
public void onMobSpawn(CreatureSpawnEvent event) {
    if (event.getEntityType() == EntityType.ZOMBIE) {
        int health = 40;
        event.getEntity().setMaxHealth(health);
        event.getEntity().setHealth(health);
    }
}</pre></div><p class="calibre8">We will work from this <a id="id215" class="calibre1"/>existing code. The <code class="email">if</code> statement is no longer needed, because we don't want to limit the plugin to zombies only. As discussed earlier, we also want to replace the hardcoded <code class="email">40 value</code> with a <code class="email">double</code> value, which will be read from the <code class="email">config</code> file. Therefore, <code class="email">40</code> should be replaced with <code class="email">getConfig().getDouble(type)</code>. You will also have to change the variable type from <code class="email">int</code> to <code class="email">double</code>. The <code class="email">Type</code> in this statement will be a string of the <code class="email">Entity</code> type. Some examples of this are <code class="email">ZOMBIE</code>, <code class="email">SKELETON</code>, or any of the other entity types that are listed in <code class="email">config.yml</code>. We already know that we can <a id="id216" class="calibre1"/>get the type of the entity that was spawned by using <code class="email">event.getEntityType()</code>. However, this gives us <code class="email">EntityType</code> in the <code class="email">enum</code> form, and we require it in the <code class="email">string</code> form. The <code class="email">EntityType</code> page of the Bukkit API documentation informs us that we can call the <code class="email">getname</code> method to return the string that we are looking for. The new <code class="email">onMobSpawn</code> method is as follows:</p><div class="informalexample"><pre class="programlisting">@EventHandler
public void onMobSpawn(CreatureSpawnEvent event) {
    //Find the type of the Entity that spawned
    String type = event.getEntityType().name();

    //Retrieve the custom health amount for the EntityType
    //This will be 0 if the EntityType is not included in the config
    double health = getConfig().getDouble(type);
    event.getEntity().setMaxHealth(health);
    event.getEntity().setHealth(health);
}</pre></div><p class="calibre8">This <code class="email">EventHandler method</code> is nearly complete. We are allowing other people to set the <code class="email">health</code> value. We want to ensure that they are entering a valid number. We don't want the plugin to crash because it is being misused. We know that we are receiving a <code class="email">double</code> value because even if the user sets a non-numeric value, we will be given the default value of <code class="email">0</code> instead. However, not every valid double value will be useable in our situation. For example, we cannot set the health of an entity to a negative value. We also do not want to set the health to <code class="email">0</code>, because this will instantly kill the entity. Therefore, we should only modify the health if the new health is set to a positive number. This can be done with a simple <code class="email">if</code> statement, as follows:</p><div class="informalexample"><pre class="programlisting">if (health &gt; 0)</pre></div><p class="calibre8">The <code class="email">MobEnhancer</code> plugin <a id="id217" class="calibre1"/>is now configurable and supports<a id="id218" class="calibre1"/> any type of creature. It is no longer limited to just zombies. The finished code will be similar to the following:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.mobenhancer;

import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.CreatureSpawnEvent;
import org.bukkit.plugin.java.JavaPlugin;

public class MobEnhancer extends JavaPlugin implements Listener, CommandExecutor {
    @Override
    public void onEnable() {
        //Save the default config file if it does not already exist
        saveDefaultConfig();

        //Register all of the EventHandlers within this class
        getServer().getPluginManager().registerEvents(this, this);

        //Register this class as the Executor of the /merl command
        getCommand("mobenhancerreload").setExecutor(this);
    }

    @EventHandler
    public void onMobSpawn(CreatureSpawnEvent event) {
        //Find the type of the Entity that spawned
        String type = event.getEntityType().name();

        //Retrieve the custom health amount for the EntityType
        //This will be 0 if the EntityType is not in the config
        double health = getConfig().getDouble(type);

        //Mobs cannot have negative health
        if (health &gt; 0) {
            event.getEntity().setMaxHealth(health);
            event.getEntity().setHealth(health);
        }
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command,String alias, String[] args) {
        reloadConfig();
        sender.sendMessage("MobEnhancer config has been reloaded");
        return true; //The command was executed successfully
    }
}</pre></div></div>
<div class="book" title="ItemStack within a configuration" id="1T1401-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec58" class="calibre1"/>ItemStack within a configuration</h1></div></div></div><p class="calibre8">Next, we will expand the <code class="email">MobEnhancer</code> plugin even further by allowing the option of giving armor and weapons to zombies and skeletons. In order to do this, we must first learn how to add an <code class="email">ItemStack</code> object as an option in a configuration file. An <code class="email">ItemStack</code> method is more <a id="id219" class="calibre1"/>complicated than a simple integer or double. It is an object that has many nested values. It may also include a <a id="id220" class="calibre1"/>
<span class="strong"><strong class="calibre2">meta</strong></span> value, which will have more nested values. <span class="strong"><strong class="calibre2">Meta</strong></span><a id="id221" class="calibre1"/> contains additional information for the item, such as a custom display name or lines of text that make up the lore of the item. The following is a sample of an <code class="email">ItemStack</code> method in a <code class="email">YAML</code> file:</p><div class="informalexample"><pre class="programlisting">SampleItem:
  ==: org.bukkit.inventory.ItemStack
  type: DIAMOND_SWORD
  damage: 1500
  amount: 1
  meta:
    ==: ItemMeta
    meta-type: UNSPECIFIC
    display-name: §6Sample Item
    lore:
    - First line of lore
    - Second line of lore
    - §1Color §2support
    enchants:
      DAMAGE_ALL: 2
      KNOCKBACK: 7
      FIRE_ASPECT: 1</pre></div><p class="calibre8">Once loaded, the item in the results is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="ItemStack within a configuration" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Only the <span class="strong"><strong class="calibre2">type</strong></span> field is<a id="id222" class="calibre1"/> required. You can omit any other segment. The <span class="strong"><strong class="calibre2">type</strong></span> refers to the type of material. These materials can be found in the API documentation <a id="id223" class="calibre1"/>under <code class="email">org.bukkit.Material</code>, which can be viewed by visiting <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/Material.html</a>. The <span class="strong"><strong class="calibre2">damage</strong></span> is used to indicate how much damage an item has taken. For items such as <code class="email">wool</code>, this will set the color of the wool. The <span class="strong"><strong class="calibre2">amount</strong></span> will set the stack size. For example, I may have one sword or twenty logs. The <span class="strong"><strong class="calibre2">meta</strong></span> includes additional information such as the color and pattern of a banner or the author and number of pages of a book. Given the path, <code class="email">getConfig().getItemStack("SampleItem");</code> will retrieve the item.</p></div>
<div class="book" title="YAML configuration hierarchy" id="1TVKI1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec59" class="calibre1"/>YAML configuration hierarchy</h1></div></div></div><p class="calibre8">Note the hierarchy when <a id="id224" class="calibre1"/>working with <code class="email">ItemStack</code> in YAML. This is similar to how commands and permissions have nested values in the <code class="email">plugin.yml</code> files. We can utilize a hierarchy within the <code class="email">config</code> file to make it easier to use and understand.</p><p class="calibre8">We want to give items to two types of mobs, namely <code class="email">Zombie</code> and <code class="email">Skeleton</code>. Each type will have a unique armor and weapon. This means that we will need 10 different <code class="email">ItemStack</code> classes. We can name them <code class="email">ZombieHolding</code>, <code class="email">SkeletonHolding</code>, <code class="email">ZombieHelmet</code>, <code class="email">SkeletonHelmet</code>, and so on. However, a hierarchy will be much more efficient. We will have a <code class="email">Zombie</code> key and a <code class="email">Skeleton</code> key. Within each zombie and skeleton, we will have a key for each item. The following is a sample of the hierarchy of the mob armor segment of the <code class="email">config</code> file:</p><div class="informalexample"><pre class="programlisting">Zombie:
  holding:
    ==: org.bukkit.inventory.ItemStack
    type: STONE_SWORD
  helmet:
    ==: org.bukkit.inventory.ItemStack
    type: CHAINMAIL_HELMET

Skeleton:
  holding:
    ==: org.bukkit.inventory.ItemStack
    type: BOW
  helmet:
    ==: org.bukkit.inventory.ItemStack
    type: LEATHER_HELMET</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre8">The rest of the armor pieces can be added in the same way.</p></div><p class="calibre8">If we want to retrieve<a id="id225" class="calibre1"/> the <code class="email">ItemStack</code> method for the boots of a skeleton, we will use <code class="email">getConfig().getItemStack("Skeleton.boots");</code>. Remember that the hierarchy is conveyed using a period. Here is a section that will be appended to <code class="email">config.yml</code>, which includes mob armor, as discussed. We also have a <code class="email">GiveArmorToMobs</code> Boolean value, which will be included to easily disable the mob armor feature:</p><div class="informalexample"><pre class="programlisting">### MOB ARMOR ###
GiveArmorToMobs: true

Zombie:
  holding:
    ==: org.bukkit.inventory.ItemStack
    type: STONE_SWORD
  helmet:
    ==: org.bukkit.inventory.ItemStack
    type: CHAINMAIL_HELMET

Skeleton:
  holding:
    ==: org.bukkit.inventory.ItemStack
    type: BOW
    meta:
      ==: ItemMeta
      meta-type: UNSPECIFIC
      enchants:
        ARROW_FIRE: 1
  helmet:
    ==: org.bukkit.inventory.ItemStack
    type: LEATHER_HELMET
    color:
      ==: Color
      RED: 102
      BLUE: 51
      GREEN: 127</pre></div></div>
<div class="book" title="Storing configuration values as variables"><div class="book" id="1UU542-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec60" class="calibre1"/>Storing configuration values as variables</h1></div></div></div><p class="calibre8">Retrieving a value from <a id="id226" class="calibre1"/>your plugin's <code class="email">config</code> file requires more<a id="id227" class="calibre1"/> time and resources than is required to access a local variable. Therefore, if you will be accessing a specific value very often, it is best to store it as a variable. We will want to do just this with the <code class="email">GiveArmorToMobs</code> Boolean value. It is also a good idea to store the <code class="email">ItemStack</code> armor locally to prevent creating a new one every time it is used. Let's add the following variables above the methods of the main class:</p><div class="informalexample"><pre class="programlisting">private boolean giveArmorToMobs;
private ItemStack zombieHolding;
private ItemStack skeletonHolding;</pre></div><p class="calibre8">We will only write the code to set the item that a zombie or skeleton is holding. You can add the rest of the armor yourself, as it will be done the same way.</p><p class="calibre8">We want these values to be automatically stored whenever the <code class="email">config</code> file is reloaded. Note that when the <code class="email">config</code> file is initially loaded, it is actually being reloaded. To ensure that our data is saved every time the <code class="email">config</code> file is reloaded, we will add additional code to the <code class="email">reloadConfig</code> method of the plugin. This is the method that we call to execute the <code class="email">/merl</code> command. The <code class="email">reloadConfig</code> method is already included in every Java plugin, but we will modify it by overriding it. This is a lot like how we override the <code class="email">onEnable</code> method. Overriding a method will prevent the existing code from being executed. This is not an issue for <code class="email">onEnable</code>, because the method has no prior existing code. However, <code class="email">reloadConfig</code> has the code that we still wish to execute. Therefore, we will use the following line of code to execute the existing code that we are overriding:</p><div class="informalexample"><pre class="programlisting">super.reloadConfig();</pre></div><p class="calibre8">This line of code is very important. Once we have it, we can add our own code before or after it. In our case, we want to store the values after the <code class="email">config</code> file has been reloaded. Therefore, the additional code should be placed after the preceding line of code. The completed overridden <code class="email">reloadConfig</code> method looks like this:</p><div class="informalexample"><pre class="programlisting">/**
 * Reloads the config from the config.yml file
 * Loads values from the newly loaded config
 * This method is automatically called when the plugin is enabled
 */
@Override
public void reloadConfig() {
    //Reload the config as this method would normally do
    super.reloadConfig();

    //Load values from the config now that it has been reloaded
    giveArmorToMobs = getConfig().getBoolean("GiveArmorToMobs");
    zombieHolding = getConfig().getItemStack("Zombie.holding");
    skeletonHolding = getConfig().getItemStack("Skeleton.holding");
}</pre></div><p class="calibre8">The last code that we must write is to give armor to specific mobs. We will add this to the end of the <code class="email">onMobSpawn</code> method. We only want to do this if <code class="email">giveArmorToMobs</code> is set to <code class="email">true</code>. Therefore, the block of code will be placed inside an <code class="email">if</code> statement, as follows:</p><div class="informalexample"><pre class="programlisting">if (giveArmorToMobs) {

}</pre></div><p class="calibre8">We can retrieve the entity's armor using the following code:</p><div class="informalexample"><pre class="programlisting">EntityEquipment equipment = event.getEntity().getEquipment();</pre></div><p class="calibre8">This gives us their <a id="id228" class="calibre1"/>equipment slots even though they may<a id="id229" class="calibre1"/> not include anything in them at the moment. To know more about this object and what you can do with it, visit its <a id="id230" class="calibre1"/>API documentation at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/inventory/EntityEquipment.html</a>. Now that we have <code class="email">EntityEquipment</code>, setting the pieces of armor is simple.</p><p class="calibre8">We have two distinct sets of armor. Therefore, we must first check whether the entity is either a zombie, or a skeleton. We can do this by using an <code class="email">if/else</code> statement:</p><div class="informalexample"><pre class="programlisting">if (event.getEntityType() == EntityType.ZOMBIE) {
    //TODO - Give Zombie armor
} else if (event.getEntityType() == EntityType.SKELETON) {
    //TODO – Give Skeleton armor
}</pre></div><p class="calibre8">However, using a <code class="email">switch/case</code> block will be more efficient. Using <code class="email">switch/case</code> in this scenario will look like this:</p><div class="informalexample"><pre class="programlisting">switch (event.getEntityType()) {
case ZOMBIE:
    //TODO - Give Zombie armor
    break;
case SKELETON: 
    //TODO - Give Skeleton armor
    break;
default: //Any other EntityType
    //Do nothing
    break;
}</pre></div><p class="calibre8">The <code class="email">If/else</code> statements are used to check multiple conditions (<span class="strong"><em class="calibre9">Is the entity a zombie?</em></span> or <span class="strong"><em class="calibre9">Is the entity a skeleton?</em></span>). A <code class="email">switch/case statement</code> saves time by asking a single question (<span class="strong"><em class="calibre9">Which of the following is the type of the entity?</em></span>). The code within the correct <code class="email">case</code> condition will then be executed. When a <code class="email">break</code> condition is fulfilled, the <code class="email">switch</code> statement is exited. If you do not end the case with <code class="email">break</code>, then you will fall through to the next case and begin executing that code. In some circumstances, that is a good thing, but we do not want that to happen here. The default case, that is, if none of the other cases match, does not<a id="id231" class="calibre1"/> need to be included because there<a id="id232" class="calibre1"/> is no code in it. However, it does make the statement more conclusive, and the Java coding standards released by Oracle state that the default case should always be included.</p><p class="calibre8">Within each of these cases, we will want to equip the correct set of armor.</p><p class="calibre8">We should check each piece of armor to ensure that it is not <code class="email">null</code> before applying it using the following code. This will prevent the plugin from crashing due to an invalid configuration:</p><div class="informalexample"><pre class="programlisting">if (zombieHolding != null) {
    equipment.setItemInHand(zombieHolding.clone());
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre8">We used the <code class="email">clone</code> method here on the <code class="email">ItemStack</code>. We don't want to hand out a single <code class="email">ItemStack class</code> to every mob. Instead, we will create its clones so that each mob can have its own copy.</p></div><p class="calibre8">Equipping the remaining armor and equipping an armor to a skeleton is very similar. The overall block of code will look like this:</p><div class="informalexample"><pre class="programlisting">if (giveArmorToMobs) {
    //Retrieve the equipment object of the Entity
    EntityEquipment equipment = event.getEntity().getEquipment();

    switch (event.getEntityType()) {
    case ZOMBIE: 
        //Set each piece of equipment if they are not null
        if (zombieHolding != null) {
            equipment.setItemInHand(zombieHolding.clone());
        }
        //TODO – Add rest of armor
        break;

    case SKELETON: 
        //Set each piece of equipment if they are not null 
        if (skeletonHolding != null) {
            equipment.setItemInHand(skeletonHolding.clone());
        }
        //TODO – Add rest of armor
        break;

    default: //Any other EntityType
        //Do nothing
        break;
    }
}</pre></div><p class="calibre8">The <code class="email">clone</code> method should be called on each <code class="email">ItemStack</code> class so that the original items remain undamaged.</p><p class="calibre8">With this, the <code class="email">MobEnhancer</code> plugin now supports giving armor to mobs. Try it out on your server to see <a id="id233" class="calibre1"/>how it works. We only discussed giving<a id="id234" class="calibre1"/> armor to zombies and skeletons because most mobs, including creepers, spiders, and cows, cannot wear armor. If you want, try adding armor and items to other mobs to see what happens. Also, try giving mobs unique items. For example, skeletons can be given a sword or zombies can be given a bow. There is also a skull item that comes in different looks; you can make a mob wear it as a mask.</p><p class="calibre8">You can even create skulls that represent a specific player, such as Notch, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Storing configuration values as variables" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The meta for<a id="id235" class="calibre1"/> the <code class="email">NotchSkull</code> item<a id="id236" class="calibre1"/> is as follows:</p><div class="informalexample"><pre class="programlisting">NotchSkull:
  ==: org.bukkit.inventory.ItemStack
  type: SKULL_ITEM
  damage: 3
  meta:
    ==: ItemMeta
    meta-type: SKULL
    skull-owner: Notch</pre></div><p class="calibre8">Play around with your new plugin to see what crazy items you can give to zombies and other mobs. The following screenshot illustrates an example of what you can accomplish by modifying the configuration:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Storing configuration values as variables" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="Accessing variables from another class"><div class="book" id="1VSLM2-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec61" class="calibre1"/>Accessing variables from another class</h1></div></div></div><p class="calibre8">The <code class="email">MobEnhancer</code> class is growing in size. There is no need to place all the code within a single class. This <a id="id237" class="calibre1"/>class is currently extending the <code class="email">JavaPlugin</code> class as <a id="id238" class="calibre1"/>well as implementing both the <code class="email">Listener</code> and <code class="email">CommandExecutor</code> interfaces. The program will be easier to understand if we split these into three unique classes. This process is known as<a id="id239" class="calibre1"/> <span class="strong"><strong class="calibre2">refactoring</strong></span>. Throughout the process of developing software, you will come across code that may be outdated or inefficient and needs to be updated. Changing the code in this way is referred to as <span class="strong"><strong class="calibre2">refactoring</strong></span>. Don't be discouraged if you need to refactor your code in the future; it is a common occurrence in software development, and there are many reasons for it to happen.</p><div class="book"><ul class="itemizedlist"><li class="listitem">You learned how to write more efficient code</li><li class="listitem">API changes or new features require/allow code changes</li><li class="listitem">The existing code is difficult to read or debug</li><li class="listitem">A method/class has grown too large to manage</li><li class="listitem">The purpose of the code has changed and it should now do something it was not originally intended to do</li></ul></div><p class="calibre8">We will refactor <code class="email">MobEnhancer</code> to split the code into three more manageable classes.</p><p class="calibre8">Create two new classes named <code class="email">MobSpawnListener</code> and <code class="email">MobEnhancerReloadCommand</code>. <code class="email">MobEnhancer</code> will still be your main class. Therefore, it will still extend <code class="email">JavaPlugin</code>. However, the two new classes will implement <code class="email">Listener</code> and <code class="email">CommandExecutor</code> respectively. Move the appropriate methods to their new classes, that is, <code class="email">onMobSpawn</code> is an event handler and hence it belongs to the <code class="email">Listener</code> class, and <code class="email">onCommand</code> belongs to the <code class="email">CommandExecutor</code> class. When moving the methods, you will see that several errors are introduced. This is because your methods no longer have access to the necessary methods and variables. Let's first address the <code class="email">MobEnhancerReloadCommand</code> class, as it has only one error. This error occurs at the following line:</p><div class="informalexample"><pre class="programlisting">reloadConfig();</pre></div><p class="calibre8">The <code class="email">reloadConfig</code> method<a id="id240" class="calibre1"/> is in the <code class="email">JavaPlugin</code> class, which is<a id="id241" class="calibre1"/> no longer merged with the <code class="email">CommandExector</code> class. We need to access the <code class="email">JavaPlugin</code> object from this separate class. The easiest way to do this is by using a static variable. If a variable or method is static, then it does not change across different instances of the class. This allows us to refer to the variable from a static context. You have done this before when using the <code class="email">Bukkit</code> class. The methods that you called were static. Therefore, you could access them using the <code class="email">Bukkit</code> class and not a unique <code class="email">Bukkit</code> object.</p><p class="calibre8">To explain this better, let's imagine that you have a plugin that gives Minecraft players bank accounts. Therefore, you will have a class to represent a player's bank account. This class can be called <code class="email">PlayerAccount</code>. You will have numerous <code class="email">PlayerAccount</code> objects, one for each player on the server. Within this class, you may have a variable that defines a limit of how much money the account can hold. Let's name this variable <code class="email">accountLimit</code>. If we want each account to have a maximum amount of money of <code class="email">1000</code>, then the <code class="email">accountLimit</code> should be static. If we wish to increase the limit to <code class="email">2000</code>, then we set <code class="email">accountLimit</code> to <code class="email">2000</code> by using <code class="email">PlayerAccount.accountLimit = 2000;</code>. Then, all the players now have an account limit of <code class="email">2000</code>. If we want some players to have a limit of <code class="email">1000</code> and others to have a limit of <code class="email">2000</code>, then we should not use a static variable. Without <code class="email">accountLimit</code> being static, if we set <code class="email">accountLimit</code> to <code class="email">2000</code> for instance A of <code class="email">PlayerAccount</code>, it would still be <code class="email">1000</code> for instance B of <code class="email">PlayerAccount</code>.</p><p class="calibre8">Storing the plugin as a static variable within the main class will benefit us. Above your current variables, add a <code class="email">static</code> <code class="email">JavaPlugin</code> variable named <code class="email">plugin</code>, as follows:</p><div class="informalexample"><pre class="programlisting">public class MobEnhancer extends JavaPlugin {
    //Static plugin reference to allow access from other classes.
    static JavaPlugin plugin;</pre></div><p class="calibre8">We must also instantiate this variable within the <code class="email">onEnable</code> method. This can simply be done using <code class="email">plugin = this;</code>. Now, we can access the plugin instance by using <code class="email">MobEnhancer.plugin</code>. Therefore, where we previously had <code class="email">reloadConfig();</code>, we will now have <code class="email">MobEnhancer.plugin.reloadConfig()</code>. This will fix the errors in <code class="email">MobEnhancerReloadCommand</code>:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.mobenhancer;

import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;

public class MobEnhancerReloadCommand implements CommandExecutor {
    @Override
    public boolean onCommand(CommandSender sender, Command command, String alias, String[] args) {
        MobEnhancer.plugin.reloadConfig();
        sender.sendMessage("MobEnhancer config has been reloaded");
        return true; //The command executed successfully
    }
}</pre></div><p class="calibre8">
<code class="email">MobSpawnListener</code> requires <a id="id242" class="calibre1"/>a similar modification, as the plugin<a id="id243" class="calibre1"/> object is needed to call the <code class="email">getConfig</code> method.</p><p class="calibre8">You will continue seeing errors in <code class="email">MobSpawnListener</code>. It is attempting to access variables that are still in the main class. Let's move the mob armor variables to the <code class="email">Listener</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">public class MobSpawnListener implements Listener {
    private boolean giveArmorToMobs;
    private ItemStack zombieHolding;
    private ItemStack skeletonHolding;</pre></div><p class="calibre8">We must also modify the <code class="email">reload</code> method within <code class="email">MobEnhancer.java</code> to match the new location of the variables. For example, instead of <code class="email">giveArmorToMobs</code>, we should now have <code class="email">MobSpawnListener.giveArmorToMobs</code>:</p><div class="informalexample"><pre class="programlisting">public void reloadConfig() {
    //Reload the config as this method would normally do
    super.reloadConfig();

    //Load values from the config now that it has been reloaded
    MobSpawnListener.giveArmorToMobs = getConfig().getBoolean("GiveArmorToMobs");
    MobSpawnListener.zombieHolding = getConfig().getItemStack("Zombie.   holding");
    MobSpawnListener.skeletonHolding = getConfig(). getItemStack("Skeleton.holding");
}</pre></div><p class="calibre8">Even with this change, we will still be given an error, which reads <code class="email">giveArmorToMobs</code>
<span class="strong"><strong class="calibre2"> has private access in </strong></span>
<code class="email">MobSpawnListener</code>. Each variable is <code class="email">private</code>, which means that they cannot be accessed from another class. We wish to be able to access them from the other classes. Hence, we will remove the private modifier. After doing so, we will be given yet another error. This<a id="id244" class="calibre1"/> new error reads <span class="strong"><strong class="calibre2">non-static variable </strong></span>
<code class="email">giveArmorToMobs</code>
<span class="strong"><strong class="calibre2"> cannot be referenced from a static context</strong></span>. This happens because the<a id="id245" class="calibre1"/> variables are not defined as static variables. Before you simply change these variables so that they can be static, ensure that it makes sense for them to be static. Refer to the earlier discussion about when static variables should be used. In this situation, we will only have one value of each of these variables. Hence, we do want to make them static, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class MobSpawnListener implements Listener {
    static boolean giveArmorToMobs;
    static ItemStack zombieHolding;
    static ItemStack skeletonHolding;</pre></div><p class="calibre8">There are only two lines remaining in the code that require our attention. These two lines are used to register the event listener and command executor. When calling the <code class="email">registerEvents</code> method, two parameters are required. The first parameter is <code class="email">Listener</code>, and the second one is <code class="email">Plugin</code>. The <code class="email">this</code> keyword references the plugin. Therefore, it is fine as the second parameter. However, for the first parameter, you must pass an instance of the <code class="email">Listener</code> class. We have done this in <a class="calibre1" title="Chapter 7. The Bukkit Event System" href="part0051_split_000.html#1GKCM1-b66e70deee6e4ed481db4b113e303f23">Chapter 7</a>, <span class="strong"><em class="calibre9">The Bukkit Event System</em></span>, when creating the <code class="email">NoRain</code> plugin. The same applies to the command executor. We must pass an instance of the <code class="email">MobEnhancerReloadCommand</code> class:</p><div class="informalexample"><pre class="programlisting">//Register all of the EventHandlers
getServer().getPluginManager().registerEvents(new MobSpawnListener(), this);

//Register the Executor of the /mobenhancerreload command
getCommand("mobenhancerreload").setExecutor(new MobEnhancerReloadCommand());</pre></div><p class="calibre8">This gets rid of all the errors that resulted from splitting the project into multiple classes.</p></div>
<div class="book" title="Summary" id="20R681-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec62" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">You are now familiar with using a <code class="email">YAML</code> configuration file. You can load custom values from a <code class="email">config.yml</code> file and use them within the plugin. Doing so will greatly expand your ability to create unique projects that will be beneficial to multiple server administrators. Try adding configurable options to some of your previous projects. For instance, if you created the plugin that sends a message when a creeper is about to explode, add a configuration file to set the area within which the players must be in order to see the message. Now that you are introduced to <code class="email">FileConfiguration</code> which can be used with the Bukkit API, in the next chapter, we will save the plugin's data using the same <code class="email">FileConfiguration</code> method so that we can load it the next time the plugin is enabled.</p></div></body></html>