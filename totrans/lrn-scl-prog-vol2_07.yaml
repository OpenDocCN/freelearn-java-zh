- en: More on Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于函数的内容
- en: '"The problems are solved, not by giving new information, but by arranging what
    we have known since long."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “问题不是通过提供新信息来解决的，而是通过安排我们长期以来所知道的信息。”
- en: – Ludwig Wittgenstein
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ——路德维希·维特根斯坦
- en: 'One of the reasons we choose to write a function is because it can make our
    code more readable and look more concise. It''s also better, when providing a
    solution, to break our problem statements down into components/actions and form
    corresponding functions for them. In this manner, it''s going to be easier to
    solve problems with any programming language that provides function constructs
    (almost all languages provide such constructs because they are important). Scala
    provides a variety of ways in which we can write functions to achieve things.
    Our intention in this chapter is to learn *how.* If you remember correctly, we
    touched upon functions in Scala in [Chapter 4](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Giving Meaning to Programs with Functions*. We discussed how we can declare functions
    and call them using different sets of parameters. We''ve already learned about
    function evaluation strategies and the important concepts of function literals
    and partial functions, and these concepts will help us better understand what
    we''re going to learn in this chapter. Let''s take a look. We''ll continue with
    function literals then discuss the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择编写函数的一个原因是因为它可以使我们的代码更易于阅读，看起来更简洁。在提供解决方案时，将我们的问题陈述分解为组件/操作并为它们形成相应的函数也是更好的做法。这样，使用任何提供函数构造（几乎所有语言都提供这样的构造，因为它们很重要）的编程语言解决任何问题都会更容易。Scala提供了多种方式来编写函数以实现目标。我们在这章中的目的是学习*如何*。如果你记得正确，我们在[第4章](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84)中提到了Scala中的函数，即*通过函数给程序赋予意义*。我们讨论了如何声明函数以及使用不同的参数集调用它们。我们已经了解了函数评估策略和函数字面量和部分函数等重要概念，这些概念将帮助我们更好地理解本章将要学习的内容。让我们看一下。我们将继续讨论函数字面量，然后讨论以下内容：
- en: Methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Functions versus methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数与方法的区别
- en: Closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Higher-order functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Partially applied functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: Currying
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Higher-order functions take you to a new universe where it's fun to use functions,
    return functions, and find other ways we can use those functions. We'll end up
    our discussion in this chapter with higher-order functions. For now, let's continue
    our understanding of function literals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数带你进入一个新宇宙，在那里使用函数、返回函数和找到其他使用这些函数的方法都很有趣。我们将在本章的结尾讨论高阶函数。现在，让我们继续理解函数字面量。
- en: Function literals
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: 'A function literal, in simple terms, is a representation of an action that
    can be performed to specify the input and output parameter types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，函数字面量是表示可以执行以指定输入和输出参数类型的行为的表示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line represents a function literal, which is easily readable. It displays
    a function that takes two values, `value1` and `value2` of type `Int`, and returns
    another, `Int`*.* We''ve seen some examples of it, such as our `ColorPrinter`
    example where we were simply able to print color as well as simple black and white
    pages using just one function named `printPages`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代表一个函数字面量，它易于阅读。它显示了一个接受两个值，即类型为`Int`的`value1`和`value2`，并返回另一个`Int`类型的函数。我们已经看到了一些例子，例如我们的`ColorPrinter`示例，我们只需使用一个名为`printPages`的函数就能简单地打印彩色以及黑白页面：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `colorPrint` and `simplePrint` values are examples of function literals
    of the following type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`colorPrint`和`simplePrint`值是以下类型的函数字面量的例子：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Unit` type here represents the absence of a return type. In other words,
    don't expect any output from the function literal. We discussed this concept in
    [Chapter 4](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84), *Giving Meaning
    to Programs with Functions*, where we answered the *what* and *how* of function
    literals. So now, let's answer the *why*, and by *why* we mean the problem it
    solves. We'll take the preceding example of it. Take a closer look and you'll
    see that we abstracted the problem statement. If we had declared specific functions
    for simple and color pages, they would have spoken for themselves, such as in
    the following example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Unit`类型表示没有返回类型。换句话说，不要期望函数字面量有任何输出。我们在[第4章](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84)中讨论了这个概念，即*通过函数给程序赋予意义*，在那里我们回答了函数字面量的*是什么*和*如何*。现在，让我们回答*为什么*，这里的*为什么*指的是它解决的问题。我们将以先前的例子来说明。仔细观察，你会发现我们抽象了问题陈述。如果我们为简单和彩色页面声明了特定的函数，它们会自己说话，如下面的例子所示。
- en: 'Here''s a `printColorPages` function, which takes a `Document`, `lastIndex`
    page number, `startIndex` page number, and then prints color pages. The same goes
    for `printSimplePages`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`printColorPages`函数，它接受一个`Document`，`lastIndex`页面编号，`startIndex`页面编号，然后打印彩色页面。`printSimplePages`也是一样：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are code smells here and they are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码异味，它们如下：
- en: In both of these functions only the implementation part varies, that is, `colorPrint`
    and `simplePrint`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两个函数中，只有实现部分不同，即`colorPrint`和`simplePrint`
- en: In both of the implementations, input and output parameters do not vary
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两个实现中，输入和输出参数都没有变化
- en: 'Let''s take both implementations out and pass them as parameters. It''s going
    to be a function literal of the same form as the function:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们把这两个实现都取出来，并将它们作为参数传递。这将是一个与函数相同形式的函数字面量：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By answering these kinds of questions we get to our end function. It looks
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答这类问题，我们得到了最终函数。它看起来如下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I hope it''s now clear how we go through this kind of refactoring. The best
    thing about it is that it will all come easily to you once you write the code
    yourself. One more thing we would like to know about the representation is that
    when you specify these literals and assign them to a value, you should know how
    they differ. The following representation is going to help you do that. Let''s
    take a look at the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望现在你已经清楚我们如何进行这种重构。最好的事情是，一旦你自己编写了代码，这一切都会对你来说很容易。还有一点我们想了解的是，当你指定这些字面量并将它们赋值给一个值时，你应该知道它们之间的区别。下面的表示将帮助你做到这一点。让我们看看以下图示：
- en: '![](img/00031.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: Function values and function literals
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数值和函数字面量
- en: 'In the preceding figure, we can see two forms. The one on the left is called
    a function value and the one on the right is a function literal. Function values
    are runtime objects. The question arises, *runtime objects of which type*? The
    answer is a `Function1` type, which is a trait in Scala and declared in the following
    form:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到两种形式。左边的是函数值，右边的是函数字面量。函数值是运行时对象。问题来了，*运行时对象是哪种类型*？答案是`Function1`类型，它是Scala中的一个特质，以下是其声明形式：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In brackets, [], we have specified the type parameters; we''ll learn about
    these in [Chapter 10](part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84),
    *Advanced Functional Programming.* For now, just understand that these two specify
    that our implementation of `Function1` is going to take an input parameter of
    the first type `T1` and the output will be of type `R`*.* Basically, our literal
    representation is just an anonymous instantiation of this trait and we can verify
    how the compiled version of it looks. The `javap` representation of the previous
    function literal looks as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号`[]`中，我们指定了类型参数；我们将在[第10章](part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84)中学习这些内容，*高级函数式编程*。现在，只需理解这两者指定我们的`Function1`实现将接受第一个类型的输入参数`T1`，输出将是类型`R`*。基本上，我们的字面量表示只是这个特质的匿名实例化，我们可以验证编译后的版本看起来如何。之前函数字面量的`javap`表示如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding representation means that the following are equivalent:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表示意味着以下内容是等价的：
- en: '![](img/00032.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'Here, on the right-hand side, we override the `apply` method for the `Function1`
    trait*.* Does it look more concise written in a literal way? Yes! That''s why
    Scala has this syntax. Also, it means that a function value of this type is going
    to support all methods defined in `Function1`. We know that the trait has an `apply`
    method that''s an abstract member from the trait. We also have a few concrete
    members such as the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在右侧，我们重写了`Function1`特质的`apply`方法*。这样写起来更简洁吗？是的！这就是为什么Scala有这种语法。这也意味着这种类型的函数值将支持`Function1`中定义的所有方法。我们知道特质有一个`apply`方法，它是特质的一个抽象成员。我们还有一些具体的成员，如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take a look at the following for a better understanding:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下内容，以更好地理解：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This tells us that `isEven` is the function literal `g`*,* that is, of form
    `(R) => A`. The type `R` for our implementation is `Int` and X is `Boolean`. The
    return type of `andThen` is `g(apply(x))`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`isEven`是函数字面量`g`*，*，即形式为`(R) => A`。我们实现中的类型`R`是`Int`，而`X`是`Boolean`。`andThen`的返回类型是`g(apply(x))`。
- en: 'In the same manner, we can also find use cases for our `compose` function*.*
    The difference between `andThen` and `compose` can be understood with the help
    of two example functions—`f` and `g`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以为我们的`compose`函数找到用例。`andThen`和`compose`之间的区别可以通过两个示例函数——`f`和`g`来理解：
- en: In case of `andThen(g):f(x) == g(apply(x))`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`andThen(g):f(x) == g(apply(x))`的情况下
- en: 'In case of `compose(g): f(x) == apply(g(x))`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`compose(g): f(x) == apply(g(x))`的情况下'
- en: You can do the remaining mathematics, but it's fun forming such a pipeline of
    operations using literals because they are readable and easy to implement. This
    example brings our discussion of function literals to an end but believe me, we'll
    be using these a lot in practice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完成剩余的数学运算，但使用文字来形成这样的操作流水线很有趣，因为它们易于阅读和实现。这个例子结束了我们对函数文字的讨论，但请相信我，在实践中我们会大量使用这些。
- en: Up till now, we've been using the terms method and function interchangeably
    but the reality is a bit different. These two are different. The question is *how*,
    so let's start by talking about the methods to learn more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在将“方法”和“函数”这两个术语互换使用，但实际情况略有不同。这两个概念是不同的。问题是“如何”，所以让我们先从了解方法开始，以便了解更多。
- en: Methods
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'We''ve already seen Scala methods and used them many times so far. However,
    to differentiate between methods and functions, we''ll take a look at the Scala
    methods once again. What are methods in Scala? Throughout our discussion of methods,
    we''ll look at several definitions of what a method is. Let''s start with what
    a method may contain:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Scala方法，并且到目前为止已经多次使用过它们。然而，为了区分方法和函数，我们将再次查看Scala方法。Scala中的方法是什么？在我们对方法的讨论中，我们将查看几个关于方法是什么的定义。让我们从方法可能包含的内容开始：
- en: '![](img/00033.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: Method signature
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名
- en: 'As you can see, we start our method with a few modifiers such as annotations,
    or keywords such as `final` and so on. This is followed by a `def` keyword, method
    name, parameter list, and then a return type that is optional. Scala methods are
    intelligent enough to infer the return type. Usually, a return type for a method
    is what the last expression evaluates to. Check out the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的方法以一些修饰符开始，如注解，或者像`final`这样的关键字等。这之后是`def`关键字、方法名、参数列表，然后是一个可选的返回类型。Scala方法足够智能，可以推断出返回类型。通常，方法的返回类型是最后一个表达式评估的结果。查看以下示例：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, we have a method named `filePrinter`, which does
    nothing but print the filenames in the current directory one by one. It''s worth
    noticing a few things. We have used a `def` keyword*,* an assignment operator,
    and braces. We''ve preferred to omit specifying the return type, that is, `Unit`
    in our case. Methods which do not return any specific type except `Unit` can also
    be written in procedure syntax. In procedure syntax, we omit the assignment operator
    and directly define the method instead:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个名为`filePrinter`的方法，它除了逐个打印当前目录下的文件名外，不做任何其他操作。值得注意的是，我们使用了`def`关键字、赋值运算符和大括号。我们更喜欢省略指定返回类型，即在我们的情况下是`Unit`。除了`Unit`之外不返回任何特定类型的方法也可以用过程语法来编写。在过程语法中，我们省略了赋值运算符，直接定义方法：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we wrote a method that prints all the filenames from
    the current directory. Now, take a look at the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们编写了一个方法，用于打印当前目录下的所有文件名。现在，看看下面的内容：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have four representations for our `filePrinter` method in the form of different
    versions, from `V0` to `V3`. Our intention is the same for all four methods. We
    want to print the filenames in the current directory. Can you guess which ones
    will work?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以不同版本的形式对`filePrinter`方法有四种表示，从`V0`到`V3`。对于所有四种方法，我们的意图是相同的。我们想要打印当前目录下的文件名。你能猜出哪些会起作用吗？
- en: 'If you''re done with guessing, let''s take a look at the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜完了，让我们看看输出结果：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here's the output of our file printers. By taking a closer look, you'll see
    that for `filePrinter` versions `V0`, `V1`, and `V2`, the output is correct but
    for version `V3`, it's not. Plus, the sequence of evaluation tells us that from
    somewhere in our code, we're printing filenames. You might realize that it's because
    of the way we tried to define version v3 of our method. The `filePrinterV3` method
    defines only a simple `println`. The Scala compiler treats subsequent statements
    outside the scope of our method. Well, we can ensure these kind of mistakes don't
    happen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的文件打印器文件的输出。通过仔细观察，你会发现对于`filePrinter`版本`V0`、`V1`和`V2`，输出是正确的，但对于版本`V3`，输出是不正确的。此外，评估的顺序告诉我们，在我们的代码的某个地方，我们正在打印文件名。你可能会意识到这是因为我们尝试定义方法版本v3的方式。`filePrinterV3`方法只定义了一个简单的`println`。Scala编译器将方法作用域之外后续的语句视为错误。嗯，我们可以确保这类错误不会发生。
- en: We can do this by explicitly specifying the return type of our methods. Specifying
    the return type makes the Scala compiler take care of such mistakes and then notifies
    you at compile time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过显式指定方法的返回类型来实现这一点。指定返回类型会让Scala编译器负责处理这类错误，并在编译时通知你。
- en: A thing to note about methods in Scala is that they are **non-value** types.
    This means no instance or no object at runtime. This notion causes us to investigate
    what we mean by this and how it works. This statement also provides a major difference
    between functions and methods. Let's investigate the difference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Scala中的方法，需要注意的一点是它们是非值类型。这意味着在运行时没有实例或对象。这种概念让我们去探究我们究竟意味着什么以及它是如何工作的。这个声明也提供了函数和方法之间的一大区别。让我们来探究一下这个区别。
- en: Functions versus methods
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数与方法的比较
- en: At the beginning of the chapter, we mentioned that we usually use the terms
    **function** and **method** interchangeably. But the reality is different. In
    Scala, these two are different concepts altogether. We'll use several examples
    to help understand this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到我们通常将术语**函数**和**方法**互换使用。但现实情况并非如此。在Scala中，这两个是完全不同的概念。我们将使用几个例子来帮助理解这一点。
- en: 'We''ll take a look at all the differences, from syntactical differences to
    semantic differences. We''ll also look at when to use what: a function or a method.
    For now, let''s use a previous example. For the `colorPrinter` function, in both
    versions, we''ll define a method and give it the name, `colorPrintV3`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看所有差异，从语法差异到语义差异。我们还将探讨何时使用函数或方法：对于现在，让我们使用一个之前的例子。对于`colorPrinter`函数，在两个版本中，我们将定义一个方法并给它命名为`colorPrintV3`：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The way we can call these is similar. Syntactically there''s no difference:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式调用它们。在语法上没有区别：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `colorPrint` and `colorPrintV2` are functions and `colorPrintV3` is a
    method. In the preceding use case, we passed all these as literals. This looks
    similar, and it also works in a similar way. It also provides output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`colorPrint`和`colorPrintV2`是函数，而`colorPrintV3`是方法。在前面的用例中，我们将所有这些作为字面量传递。这看起来很相似，并且它以类似的方式工作。它也提供了输出：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We said that methods and functions in Scala are different, but the way we use
    them and the results are similar. This happens because the compiler helps to convert
    a method into a function dynamically when it sees the possibility of doing it.
    So this is our counter-statement to this conflicting situation. We better investigate
    this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说Scala中的方法和函数是不同的，但我们使用它们的方式和结果是相似的。这是因为编译器在看到可能进行转换的情况下会动态地将方法转换为函数。因此，这是我们对这种冲突情况的反证。我们最好调查一下。
- en: 'We''ll check class files generated by the compiler. Our intention is to investigate
    these three:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查编译器生成的类文件。我们的目的是调查这三个：
- en: '`colorPrint`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorPrint`'
- en: '`colorPrintV2`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorPrintV2`'
- en: '`colorPrintV3`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorPrintV3`'
- en: 'The files generated by the compiler is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的文件如下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we observe the preceding compiled class representation of the `colorPrint`
    series of functions, it becomes clear that the way Scala treats them internally
    is different. The takeaway points from this are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察前面编译的`colorPrint`函数系列的类表示时，我们可以清楚地看到Scala在内部处理它们的方式是不同的。从这个角度来看，我们可以得出以下结论：
- en: Scala function literals are compiled down to the form of a FunctionX trait (X
    here, is a placeholder for a number, meaning, the number of parameters this function
    is going to support). We've already seen that this FunctionX trait comes with
    more methods such as `apply`, `andThen`, and `compose`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala函数字面量被编译成FunctionX特质的形态（这里的X是一个占位符，代表一个数字，意味着这个函数将要支持的参数数量）。我们已经看到，这个FunctionX特质自带了更多方法，例如`apply`、`andThen`和`compose`。
- en: Scala methods are compiled down to normal Java methods.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 方法被编译成普通的 Java 方法。
- en: 'Finally, methods suited to the context of an object, for example, the `apply`
    method from the FunctionX trait, only get called on anonymous instances of FunctionX,
    so the following makes sense for the `apply` method:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，适合对象上下文的方法，例如 FunctionX 特质中的 `apply` 方法，仅在 FunctionX 的匿名实例上调用，因此以下对 `apply`
    方法是有意义的：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code is equivalent to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码等同于以下代码：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This tells us that Scala does some magic with the function syntax at compile
    time. Also, we know that our literals are *Ffunction objects* so we can perform
    operations like `toString`, as well as equality operations on them. Hence, the
    following is valid:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 Scala 在编译时对函数语法做了一些魔法操作。我们还知道我们的字面量是 *Ffunction objects*，因此我们可以对它们执行操作，如
    `toString`，以及等价操作。因此，以下操作是有效的：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, the compiler won''t let you perform the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器不会让你执行以下操作：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The reason for this is that `colorPrintV3` is a method and not a value type.
    Also if you try to call `toString` on `colorPrintV3`, the compiler will complain
    about it and won''t let you perform such operations on a method type. The Scala
    compiler automatically converts a method to its literal equivalent and provides
    a way to explicitly perform it. We use the following syntax for that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于 `colorPrintV3` 是一个方法而不是值类型。此外，如果你尝试在 `colorPrintV3` 上调用 `toString`，编译器会对此提出抱怨，并阻止你在方法类型上执行此类操作。Scala
    编译器会自动将方法转换为它的字面等价物，并提供了一种显式执行它的方式。我们使用以下语法来实现这一点：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take a look at the trailing underscore. This syntactic sugar is enough to tell
    the Scala compiler to convert the method to a function. Now, you may call `toString`,
    create a function pipeline, or use `andThen` or `compose` methods on `colorPrintV4`.
    We can even perform equality methods on it. So that's how methods and functions
    are different in Scala, but now the question arises when to choose what?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下后面的下划线。这种语法糖足以让 Scala 编译器将方法转换为函数。现在，你可以调用 `toString`，创建一个函数管道，或者在 `colorPrintV4`
    上使用 `andThen` 或 `compose` 方法。我们甚至可以在它上面执行等价方法。所以这就是 Scala 中方法和函数的不同之处，但现在问题来了，何时选择什么？
- en: Methods or functions?
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法还是函数？
- en: 'Now that you have an idea about the difference between a method and a function,
    you might be wondering where and when to use what. Should I prefer a function
    over a method or the opposite? Earlier, we defined a `colorPrinterV3` method and
    passed that to our higher-order `printPages` function (we''ll talk about higher-order
    functions in later sections)*.* Now that you know that the compiler has to put
    some extra effort into converting the method into its function equivalent, it
    becomes obvious that in use cases where we''re depending upon higher-order functions,
    it''s a good choice to have functions in scope so that we can communicate properly.
    Apart from that, it''s also obvious that defining a function instead of a method
    gives us more functionality options. We''ve seen examples of methods such as `andThen`
    and `compose`. These methods let us enhance the functionality. Performance-wise,
    there''s not much of a difference in the usage. There are a few scenarios where
    only methods are the solution:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了方法和函数之间的区别，你可能想知道在哪里以及何时使用什么。我应该更倾向于函数而不是方法，或者相反吗？早些时候，我们定义了一个 `colorPrinterV3`
    方法，并将其传递给我们的高阶 `printPages` 函数（我们将在后面的章节中讨论高阶函数）*。* 现在你已经知道编译器必须付出额外的努力将方法转换为它的函数等价物，因此很明显，在依赖于高阶函数的使用场景中，拥有函数的作用域是一个好的选择，这样我们才能正确地沟通。除此之外，很明显，定义函数而不是方法给我们提供了更多的功能选项。我们已经看到了
    `andThen` 和 `compose` 等方法的例子。这些方法让我们增强了功能。在性能方面，使用上没有太大的区别。有一些场景下，只有方法才是解决方案：
- en: We can provide default values for method parameters, but that's not possible
    for functions.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为方法参数提供默认值，但函数则不行。
- en: In a parent-child class relationship, when we override a method from a superclass,
    we can still access the parent class version of that method using a `super` call.
    However, once you override a function, you can't make a super call and are stuck
    with the implementation.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父类-子类关系中的父类方法重写，我们仍然可以使用 `super` 调用访问父类的该方法版本。然而，一旦你重写了函数，你就不能进行 `super` 调用，并且只能使用实现。
- en: So it's wise to choose which one to use depending on the requirements you have.
    Functions provide us with more chaining capabilities. We may choose to use whichever
    suits us the best.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据你的需求选择使用哪一个是很明智的。函数为我们提供了更多的链式操作能力。我们可能会选择最适合我们的任何一个。
- en: 'For now, let''s again take a look at the snippet we have, and see if we can
    make some more modifications:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次查看我们已有的代码片段，看看我们是否可以做一些修改：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I'm using this `Printer` example because it's easy to understand and we've already
    seen bits and pieces of it. So, when taking a look at the calling of the `printPages`
    function, we may want to do some refactoring. First, we know the logic that checks
    if the printer is ON or OFF by checking `printerSwitch` value. Moreover, every
    time we call `printPages`, we have to pass the `!printerSwitch` parameter. We
    want to omit this extra burden of telling the printer to check if it's on or not.
    We want the printer to already know that, that's what we're going to do. But in
    a programming context, is it possible to refer to `printerSwitch` from the inner
    scope of the `printPages` function? Yes, it's possible if we choose to use a closure.
    Let's discuss closures and how we can define them in Scala.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个`Printer`示例是因为它容易理解，我们之前已经看到了它的部分内容。所以，当我们查看`printPages`函数的调用时，我们可能想要进行一些重构。首先，我们知道通过检查`printerSwitch`值来检查打印机是开启还是关闭的逻辑。此外，每次我们调用`printPages`时，我们必须传递`!printerSwitch`参数。我们希望省略告诉打印机检查它是否开启的额外负担。我们希望打印机已经知道这一点，这正是我们要做的。但在编程环境中，是否可以从`printPages`函数的内层作用域引用`printerSwitch`？是的，如果我们选择使用闭包，这是可能的。让我们讨论闭包以及我们如何在Scala中定义它们。
- en: What are closures?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是闭包？
- en: 'We''ll solve the problem in the previous section using closures. But first,
    let''s explain the concept of a **closure***.* In programming terminology, a closure
    has more than one definition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用闭包解决上一节中的问题。但首先，让我们解释一下**闭包**的概念。在编程术语中，闭包有多个定义：
- en: A closure is simply a function value that gets created at runtime and encompasses
    a reference to a free variable that's not in the local scope
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包简单地说是在运行时创建的函数值，它包含对不在局部作用域中的自由变量的引用。
- en: A closure in practical terms is a function that you can pass around that retains
    the same scope and values as the ones it had at the time of creation
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际意义上，闭包是一个你可以传递的函数，它保留了在创建时相同的范围和值。
- en: 'What do we mean by these statements? Let''s check that using a very simple,
    but a fun example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这些话是什么意思？让我们用一个简单但有趣示例来检查一下：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, you're getting it, aren't you? Here, we created a function that expects
    a `showName` and plays it. That doesn't go so smoothly and we get to watch some
    advertisements. That's what is happening in the preceding code. It's obvious that
    the use case is not practical, but it's easy to understand the concept. We're
    trying to refer to a variable that's not in the local scope of our `playingShow`
    function*.* When we tried using this function for the first time, the runtime
    representation of `playingShow` was referring to the iPhone 7 advertisement. Then
    we time travel, and the second time we called `playingShow`, we watched an advertisement
    that was different from the previous one. The point to take away is the runtime
    representation of our `playingShow` is called a closure. Some terminology included
    with a closure are *open terms* and *closed terms.* Here, in our example, `advertisement`
    is called a free variable because it doesn't reside in the local scope of our
    *function*/*closure* whereas the `showName` parameter, which we explicitly referred
    to, is called a *bound* variable*.* When we try to form a function literal with
    only bound variables, it's called a closed term. And the other way around, when
    you include a free variable, it makes an open term.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你明白了，对吧？在这里，我们创建了一个期望一个`showName`并播放它的函数。这并不那么顺利，我们不得不观看一些广告。这就是前面代码中发生的事情。很明显，用例并不实用，但概念很容易理解。我们试图引用不在我们`playingShow`函数局部作用域中的变量。当我们第一次使用这个函数时，`playingShow`的运行时表示正在引用iPhone
    7广告。然后我们进行时间旅行，当我们第二次调用`playingShow`时，我们观看了一个与前一个不同的广告。要吸取的要点是，我们`playingShow`的运行时表示被称为闭包。与闭包相关的术语包括*开放项*和*封闭项*。在这里，在我们的例子中，`advertisement`被称为自由变量，因为它不在我们*函数*/*闭包*的局部作用域中，而`showName`参数，我们明确引用的，被称为*绑定变量*。当我们尝试仅使用绑定变量形成函数字面量时，它被称为封闭项。而反过来，当你包含一个自由变量时，它就变成了开放项。
- en: 'A closed term example is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个封闭项的例子如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An open term example is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开放项的例子如下：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One more thing to note is that a closure only keeps the reference to the free
    variables. That's the reason we were able to detect the change in the value of
    `advertisement`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点需要注意，闭包只保留对自由变量的引用。这就是我们能够检测到`advertisement`值变化的原因。
- en: 'Now that you''ve some idea about closures*,* let''s get back to the refactoring
    of the `printPages` function. Our intended behavior was that the printer should
    already know how to switch before printing. We can omit the function literal specified
    in `printPages`. Then there are two possible solutions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对闭包*有了些了解，*让我们回到`printPages`函数的重构上来。我们期望的行为是打印机在打印之前就应该知道如何切换。我们可以省略`printPages`中指定的函数字面量。然后有两种可能的解决方案：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What we've done in the second solution is we removed `isPrinterOn` from our
    `printPages` function's parameter list and put the implementation with `!printerSwitch`.
    This makes our `printPages` function a closure and somehow we were able to reduce
    code duplication in `colorPrint` and `colorPrintV2`. So this is another alternative
    we have to our solution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个解决方案中，我们所做的是从`printPages`函数的参数列表中移除了`isPrinterOn`，并将实现与`!printerSwitch`一起放置。这使得我们的`printPages`函数成为一个闭包，并且我们能够在`colorPrint`和`colorPrintV2`中减少代码重复。所以这是我们解决方案的另一种替代方案。
- en: I hope you get the idea of what a closure is and how it can be used. We also
    learned that closures don't solve any problems that can't be solved without them.
    They are just an alternative to getting things done in a concise manner. We also
    saw a closure carry state with them; this is a concept defined in many languages
    and in languages where there's no state present such as **Haskell**, hence these
    are used to carry *immutable state.* However, these are an essential and fun alternative
    to solving a particular problem. In Scala, there are several such tool type constructs
    available, using which we can make our code smell good, a closure is one of them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能理解闭包的概念以及它是如何被使用的。我们还了解到，闭包并不能解决那些没有它们就无法解决的问题。它们只是以简洁的方式完成任务的一种替代方案。我们还看到闭包会携带状态；这是一个在许多语言中定义的概念，在那些没有状态存在的语言（如**Haskell**）中，这些被用来携带*不可变状态*。然而，这些是解决特定问题的基本且有趣的替代方案。在Scala中，有几种这样的工具类型结构可用，使用这些结构我们可以使我们的代码更加优雅，闭包就是其中之一。
- en: We've talked a lot about functions, methods, and closures. During which we've
    come up with various higher-order functions. So now, we're kind of comfortable
    with the concept of higher-order functions. When we see one, it doesn't feel odd
    or doesn't make us feel uncomfortable. Great, then let's discuss them in detail.
    You already have some idea about the power of them in a functional programming
    context. We'll explore them more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于函数、方法和闭包的内容。在这个过程中，我们提出了各种高阶函数。所以现在，我们对高阶函数的概念已经相当熟悉了。当我们看到它时，不会觉得奇怪或感到不舒服。太好了，那么让我们详细讨论一下。你已经对它们在函数式编程环境中的强大功能有所了解。我们将进一步探索它们。
- en: Higher-order functions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'We know that we can only pass a first-class value object as an argument to
    a method or a function. For example, take this simple method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们只能将一等值对象作为参数传递给方法或函数。例如，看看这个简单的方法：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a method named `sum` and declares two parameters `a` and `b`. Now, to
    use this method, we will pass arguments. In the argument list, it's obvious we'll
    have to pass values of the integer type. It's clear that any type, if it's a value,
    can be declared as a function parameter and can be used as an argument while calling
    a function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`sum`的方法，声明了两个参数`a`和`b`。现在，要使用这个方法，我们将传递参数。在参数列表中，很明显我们必须传递整数值。显然，任何类型，如果它是一个值，都可以声明为函数参数，并在调用函数时用作参数。
- en: 'In Scala, function literals are nothing more than function trait objects, hence
    it''s obvious that we can declare them as parameters and use them as arguments.
    This gives rise to functions which contain functions as parameters, and function
    calls which contain function literals as arguments. These types of functions are
    called **higher-order functions** (**HOF**). Using higher-order functions has
    its own advantages. We''ve already seen a couple of those. Wherever we define
    abstract syntax in libraries, frameworks, or code, higher-order functions are
    used at large. If you think about how these behaviors/functions can be used in
    higher orders, you''ll come up with a few of the following scenarios:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，函数字面量不过是函数特质对象，因此很明显我们可以将它们声明为参数并用作参数。这产生了包含函数作为参数的函数，以及包含函数字面量作为参数的函数调用。这类函数被称为**高阶函数**（**HOF**）。使用高阶函数有其自身的优势。我们已经看到了其中的一些。无论我们在库、框架或代码中定义抽象语法的地方，高阶函数都得到了广泛的应用。如果你考虑这些行为/函数如何以高阶方式使用，你会想到以下几种场景：
- en: Function as an output
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为输出
- en: Function as an input
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为输入
- en: Function as a parameter
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为参数
- en: 'The preceding scenarios specify three conditions where we can use function
    literals as higher-order functions. Take a look at the following figure to get
    a clear picture:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的场景指定了三种我们可以使用函数字面量作为高阶函数的条件。看看下面的图，以获得清晰的画面：
- en: '![](img/00034.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: A few forms of higher-order functions
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数的几种形式
- en: 'As shown in the table, we have used a function literal of form `int => int`,
    which means a function that takes an integer as an input and gives back another
    integer after performing some operation on it. The first form in the figure takes
    an integer as an input parameter and returns a function literal of form `int ->
    int`. In the second form, we are taking a function literal of form `int -> int`,
    and giving an integer as an output. In the final form, we are expecting an integer
    and a function literal of the same form `int -> int` as a parameter. Let''s see
    a few examples to see things clearer:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如表所示，我们使用了形式为 `int => int` 的函数字面量，这意味着一个接受整数作为输入并在其上执行某些操作后返回另一个整数的函数。图中的第一种形式接受一个整数作为输入参数并返回一个形式为
    `int -> int` 的函数字面量。在第二种形式中，我们接受一个形式为 `int -> int` 的函数字面量，并给出一个整数作为输出。在最终形式中，我们期望一个整数和一个形式相同的
    `int -> int` 函数字面量作为参数。让我们看几个例子来更清楚地了解：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we defined all three forms. The first gives a function
    as an output, named `multiplier10`, the form itself is explanatory. It takes an
    integer and returns a function literal that is a multiplier of 10.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了所有三种形式。第一种形式输出一个函数，命名为 `multiplier10`，形式本身具有说明性。它接受一个整数并返回一个乘以
    10 的函数字面量。
- en: 'The second one is a higher-order method which takes a function literal as input
    and outputs an integer as a result. The `intOpPerformer` method, as the name suggests,
    performs an operation of type `Int => Int`, be it a multiplication operation or
    any other operation. Whichever we pass, it''s going to be used and the output
    will be an integer as mentioned in the signature. We can call the function by
    providing an input function literal:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个高阶方法，它接受一个函数字面量作为输入，并输出一个整数作为结果。`intOpPerformer` 方法，正如其名所示，执行类型为 `Int
    => Int` 的操作，无论是乘法操作还是任何其他操作。无论我们传递什么，它都将被使用，输出将如签名中所述的整数。我们可以通过提供一个输入函数字面量来调用该函数：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So this is another way we can utilize the higher-order nature of a function.
    There''s one more, the third version, where we pass this function literal as part
    of the parameter list and it applies the first parameter value to the second parameter
    function and gives an integer result. The `multiplicator` function is an example
    of such a construct. We have used the curried form of the function. We''ll learn
    about currying in subsequent sections:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们可以利用函数高阶性质的另一种方式。还有另一种，第三种版本，我们将这个函数字面量作为参数列表的一部分传递，它将第一个参数值应用于第二个参数函数，并给出一个整数结果。`multiplicator`
    函数是这种结构的例子。我们使用了函数的柯里化形式。我们将在后续章节中学习柯里化：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These are the ways we can incorporate higher-order functions and all of them
    solve certain problems. By removing code duplication, we can abstract out the
    pattern and make a higher-order version of our function. That's how we use them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以整合高阶函数的方式，并且它们都解决了某些问题。通过移除代码重复，我们可以抽象出模式，并创建我们函数的高阶版本。这就是我们使用它们的方式。
- en: 'Our famous `ColorPrinter` example also uses higher-order functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们著名的`ColorPrinter`示例也使用了高阶函数：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, `print` is a higher-order function that we are passing as a parameter.
    A close look will explain it better. The `colorPrint` argument itself is a function
    literal:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`print`是一个高阶函数，我们将其作为参数传递。仔细观察将更好地解释它。`colorPrint`参数本身就是一个函数字面量：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is possible just because `colorPrint` is a value object. While we are
    on the subject, sometimes you may read: "Functional languages treat functions
    as first class values." What do we mean by *first class values*? It means that
    the way we declare an integer or string value and use them as parameters. In the
    same way, we can declare a function literal and use it as a parameter in other
    functions.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是因为`colorPrint`是一个值对象。在此话题上，有时你可能读到：“函数式语言将函数视为一等值。”我们所说的*一等值*是什么意思？这意味着我们声明一个整数或字符串值并使用它们作为参数的方式。同样，我们可以声明一个函数字面量并将其用作其他函数的参数。
- en: Higher-order functions make it a lot easier to compose functions or chains of
    functions to perform a complex task in an easy and readable manner. Needless to
    say, utility functions such as `map`, `flatmap`, `filter`, `fold`, and so on are
    all higher-order functions. In Scala or any other programming language, functions
    such as `map`, `filter`, or `flatmap` are a result of trying to solve a particular
    pattern of problem. Hence, it's obvious that we take a part of a certain pattern
    from our functions and replace it with a higher-order function. The idea for this
    action is to abstract out the implementation in the form of a function literal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数使得以简单和可读的方式组合函数或函数链以执行复杂任务变得容易得多。不用说，像`map`、`flatmap`、`filter`、`fold`等这样的实用函数都是高阶函数。在Scala或其他任何编程语言中，像`map`、`filter`或`flatmap`这样的函数是试图解决特定模式问题的一个结果。因此，很明显，我们从函数中提取了某个模式的一部分，并用高阶函数替换了它。这个动作的想法是将实现抽象成函数字面量。
- en: 'A simple example, to get a better understanding, is a simple mathematical operation
    for two integers. Take a look at the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，一个简单的例子是对两个整数进行简单的数学运算。看看以下内容：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code are a few methods that take two input parameters and
    perform a particular operation. Using these is also pretty easy:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有几个方法接受两个输入参数并执行特定的操作。使用这些方法也很简单：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But as good programmers, it's our duty to check the implementation details,
    even if the solution is working. When you do that, you get to see that all four
    implementations have many things in common. All four methods have two parameters
    but the definition proves to be different as each method is performing a different
    operation. In a sense, we know we can abstract out the signature and implementation
    details in the form of function literals and form a higher-order function. So
    we take steps for that.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为优秀的程序员，检查实现细节是我们的职责，即使解决方案已经可行。当你这样做时，你会看到所有四种实现有许多共同之处。所有四种方法都有两个参数，但定义证明是不同的，因为每种方法执行的操作不同。从某种意义上说，我们知道我们可以将签名和实现细节抽象出来，以函数字面量的形式形成一个高阶函数。因此，我们为此采取步骤。
- en: 'First, we create function literal versions of all four implementations, which
    have a form of `(Int, Int) => Int` and we come up with something like the following:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了所有四种实现的功能字面量版本，它们的形式为`(Int, Int) => Int`，我们得到了以下类似的内容：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This ensures that we can pass these literals without worrying about internal
    dynamic conversions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了我们可以在不担心内部动态转换的情况下传递这些字面量。
- en: 'Then, we write the abstracted out method that takes one such function literal
    and two integer parameters to perform the operation on. The result looks something
    like the following:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们编写了一个抽象方法，它接受一个这样的函数字面量和两个整数参数来执行操作。结果看起来如下：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `operation` is the higher-order method which takes a function literal
    and two parameters and calls the function passed with the other parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`operation`是一个高阶方法，它接受一个函数字面量和两个参数，并调用传递给其他参数的函数。
- en: 'Now, using the higher-order method is as easy as calling any other function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用高阶方法就像调用任何其他函数一样简单：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You may ask whether this makes sense. We still wrote the same (with a couple
    of extra) lines of code. So let''s remove the literals we wrote, as those are
    just literals we named. We can directly use the functionality by providing what
    you intend to do dynamically to our `operation` function. Our code looks like
    the following after the final implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问这是否有意义。我们仍然写了同样（加上一些额外）的代码行。所以让我们移除我们写的字面量，因为那些只是我们命名的字面量。我们可以通过提供动态意图来直接使用
    `operation` 函数的功能。在最终实现之后，我们的代码看起来如下：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The real function required is just a one-liner, the `operation` higher-order
    function. The next few lines are the calls to the previous `operation` function.
    One thing to note, on the calling side of the `operation` function we didn't provide
    the `a` and `b` type of parameters. That's because Scala is powerful enough to
    understand that an `operation` functions first parameter expects the same type
    as we are providing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 真正需要的只是一个单行函数，即 `operation` 高阶函数。接下来的几行是对先前 `operation` 函数的调用。有一点需要注意，在 `operation`
    函数的调用端，我们没有提供 `a` 和 `b` 参数的类型。这是因为 Scala 足够强大，能够理解 `operation` 函数的第一个参数期望的类型与我们提供的类型相同。
- en: I hope this example helps you to understand the concept of higher-order functions.
    In practice, the more you use them, the more you get to see the power of them.
    A couple of forms exist, using which we solve problems.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子能帮助你理解高阶函数的概念。在实践中，你用得越多，就越能体会到它们的强大。存在几种形式，我们可以用它们来解决问题。
- en: Now that we've seen more than one representation and one use case of higher-order
    functions, let's take a look at another way of calling functions using currying.
    You may have heard about currying as a concept. Here, our motto is to understand
    what Currying is and what purpose it solves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了高阶函数的多个表示和用法，让我们看看另一种使用柯里化的方式来调用函数。你可能已经听说过柯里化这个概念。在这里，我们的座右铭是理解柯里化的含义以及它解决的问题。
- en: Currying
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Scala allows you to pass multiple parameters in functions or methods. We may
    want to create intermediate versions of such functions. This gives us more than
    one version of a single function. In other words, we can break down every function
    with multiple parameters into single parameter functions. Why would we want to
    create single parameter functions? The answer to this is, we can leverage it for
    function composition. For example, we can launch a website with the help of a
    domain name, hosting, and web platform. See the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 允许你在函数或方法中传递多个参数。我们可能想要创建这种函数的中间版本。这给了我们一个单一函数的多个版本。换句话说，我们可以将具有多个参数的每个函数分解为单参数函数。我们为什么要创建单参数函数呢？这个答案就是，我们可以利用它来进行函数组合。例如，我们可以借助域名、托管和网站平台来启动一个网站。请看以下示例：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you have a function that takes a domain name, another function that takes
    a website platform, and another function that takes a hosting platform as a parameter,
    you can compose them together to have a full-fledged website. Functional composition
    is powerful because it gives you more options together with intermediate functions.
    A normal function would look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个接受域名作为参数的函数，另一个接受网站平台作为参数的函数，以及另一个接受托管平台作为参数的函数，你可以将它们组合起来以拥有一个完整的网站。函数组合之所以强大，是因为它为你提供了更多的选项，同时结合了中间函数。一个普通的函数可能看起来像以下这样：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This form of a method does not provide you with the same power that you have
    when you compose a function. As mentioned, in Scala it''s possible to convert
    our functions to a curried form or convert functions with multiple parameters
    into a function with single parameters. For that Haskell Curry has provided the
    concept of currying. Here''s an example to help us understand this. We''ll take
    the same example of making a website. The problem statement is clear. We want
    to compose intermediate functions where we can pass multiple, single parameter
    lists. The end function should look like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的形式并不提供你在函数组合时所拥有的相同功能。如前所述，在 Scala 中，我们可以将我们的函数转换为柯里化形式，或者将具有多个参数的函数转换为单参数函数。为此，Haskell
    Curry 提供了柯里化的概念。以下是一个帮助我们理解这个概念的示例。我们将使用制作网站的相同示例。问题陈述很清晰。我们想要组合中间函数，在这些函数中我们可以传递多个单参数列表。最终函数应该看起来像以下这样：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, `WebsitePlatform`, `DomainName`, and `Host` are the types we choose to
    use. We can create these using Scala, providing the `type` keyword. A form of
    the preceding function is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`WebsitePlatform`、`DomainName`和`Host`是我们选择使用的类型。我们可以使用Scala，提供`type`关键字来创建这些类型。前面函数的一种形式如下：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Suppose you want to have an intermediate function that does not have to deal
    with the website platform, and simply creates a WordPress.com platform account
    for the intended account. The function should return something like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个中间函数，它不需要处理网站平台，只需为指定的账户创建一个WordPress.com平台账户。该函数应返回如下内容：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The same goes for the other two intermediate versions. For example, you want
    to create a dummy website with the default WordPress.com ([https://wordpress.com/](https://wordpress.com/))
    platform and a dummy WordPress URL for your website. The version then looks like
    the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个中间版本也是如此。例如，你想要创建一个使用默认WordPress.com ([https://wordpress.com/](https://wordpress.com/))
    平台和你的网站的默认WordPress URL的虚拟网站。该版本看起来如下：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final version deals with all the defaults using bluehost.com as the default
    hosting provider and creating a website for you. An example application would
    look like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最终版本使用bluehost.com作为默认托管提供商并为你创建网站来处理所有默认设置。一个示例应用看起来如下：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Did you take a look at the preceding code? We used composition, step-by-step,
    to make a default website creator that uses WordPress.com as a website platform,
    bluehost.com as hosting provider, and some dummy URI as URL. Let's try to understand
    how this is working. The first thing that we did was just add a syntactic enhancement
    for a better understanding. The three types we declared using the type keywords
    are just strings. These strings are, of course, for demonstration purposes. They
    can be of different types. Then we declared the curried version of a method that
    takes three different single parameter lists. The definition is not very important
    right now, we're just printing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你查看过前面的代码了吗？我们逐步使用了组合来制作一个默认网站创建器，该创建器使用WordPress.com作为网站平台，bluehost.com作为托管提供商，以及一些虚拟URI作为URL。让我们尝试理解这是如何工作的。我们首先做的是添加一个语法增强，以便更好地理解。我们使用类型关键字声明的三个类型只是字符串。当然，这些字符串是用于演示目的的。它们可以是不同类型的。然后我们声明了一个接受三个不同单参数列表的方法的柯里化版本。定义现在并不很重要，我们只是打印出来。
- en: Then comes the interesting part. We created an intermediate version of our function,
    named `wordPress`, and the return type of this function is `DomainName => Host
    => Unit`. In the very next step, we created another intermediate function named
    `wordPressDummyDotCom` that is particular to WordPress.com and uses a dummy URL.
    In the same way, we again composed another function that gives another default
    website component. The advantage of this is that we can create multiple versions
    with different website platforms and thus things will be easier for the client
    of your program, as you're providing multiple versions of default functions for
    almost every set of parameters. For that, we have used nothing more than the curried
    form of our function. It is so common to convert or write curried versions of
    your function in Scala, that the language has a default way of doing it. In Scala,
    it's possible to convert a function with multiple parameters to its curried counterpart.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是有趣的部分。我们创建了一个名为`wordPress`的函数的中间版本，该函数的返回类型是`DomainName => Host => Unit`。在接下来的步骤中，我们创建了一个名为`wordPressDummyDotCom`的另一个中间函数，该函数特定于WordPress.com并使用虚拟URL。同样，我们又组合了另一个函数，提供了另一个默认网站组件。这种做法的优势在于，我们可以创建具有不同网站平台的多个版本，从而使你的程序客户端更容易操作，因为你几乎为每一组参数提供了多个默认函数的版本。为此，我们使用的不过是函数的柯里化形式。在Scala中，转换或编写函数的柯里化版本非常常见，以至于该语言有默认的方式来做这件事。在Scala中，可以将具有多个参数的函数转换为它的柯里化对应版本。
- en: Converting a function with multiple parameters to curried form
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将具有多个参数的函数转换为柯里化形式
- en: 'In Scala, we have a function called `curried`*,* using which we can convert
    our functions to a curried form. Let''s see a simple example for a better understanding:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们有一个名为`curried`的函数，我们可以用它将我们的函数转换为柯里化形式。让我们通过一个简单的例子来更好地理解：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we defined a simple two-parameter function literal named `add`. Then,
    we used a Scala-provided function named `curried` to convert the function to its
    curried form. We named the result `addCurried`. With that, we were able to call
    both functions and got the same result.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个简单的两个参数函数字面量名为`add`。然后，我们使用Scala提供的名为`curried`的函数将函数转换为它的柯里化形式。我们将结果命名为`addCurried`。有了这个，我们能够调用这两个函数并得到相同的结果。
- en: 'There''s also a way to uncurry curried functions. We have this `uncurried`
    method, using which we can convert the curried function to uncurried form:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一种方法可以将柯里化函数取消柯里化。我们有这个`uncurried`方法，使用它可以转换柯里化函数为非柯里化形式：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The result is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is how we use currying in Scala. There are similar constructs that we can
    use in Scala to fulfill the same intentions, and we call them *partially applied
    functions*. These are different to currying. Let's discuss the topic in detail.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在Scala中使用柯里化的方式。在Scala中，我们可以使用类似的构造来满足相同的目的，我们称之为*部分应用函数*。这些与柯里化不同。让我们详细讨论这个话题。
- en: Partially applied functions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用函数
- en: Partially applied functions, as the name suggests, apply the functions partially.
    It means that for functions with multiple parameters in a parameter list, we don't
    provide a value for each of the parameters. If we don't want to provide parameters
    we just leave them blank. Now that we know this, let's look at a similar example
    to the one we looked at when learning currying. With this, you'll be able to differentiate
    between the two.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用函数，正如其名所示，只部分应用函数。这意味着对于参数列表中有多个参数的函数，我们不为每个参数提供一个值。如果我们不想提供参数，我们只需将它们留空。现在我们知道了这一点，让我们看看一个与我们在学习柯里化时看到的类似例子。有了这个，你将能够区分这两种情况。
- en: 'First, take a look at the multiple parameter functions, which we''ll convert
    to partially applied forms:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看多参数函数，我们将它们转换为部分应用形式：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, `makeWebsite`, as we have already seen, takes three parameters, `platform`,
    `domainName`, and `host`. Take a look at an application we can create with various
    intermediate or partially applied functions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`makeWebsite`，正如我们之前所看到的，接受三个参数，`platform`、`domainName`和`host`。看看我们可以使用各种中间或部分应用函数创建的应用程序：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'So, here we can see three partially applied functions. Take a look at the first
    one:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们可以看到三个部分应用函数。看看第一个：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The function name suggests what this does. We can expect this function to provide
    a partially applied function for `WebsitePlatform`, and that''s the reason the
    return type of the function is of the following form:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名暗示了它的作用。我们可以预期这个函数将提供一个针对`WebsitePlatform`的部分应用函数，这就是为什么函数的返回类型是以下形式：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To use this function, we simply provide the unapplied parameters and it works:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，我们只需提供未应用的参数即可，它就会工作：
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the same way, we also described other versions, let''s take a look at them.
    For one of them, we provided a default dummy URL for our website, the website
    platform, and hosting service that we can provide at the time of calling the same:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也描述了其他版本，让我们看看它们。对于其中一个，我们在调用时提供了一个默认的虚拟URL、网站平台和托管服务：
- en: '[PRE64]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The version returns back the type as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本返回的类型如下：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When we take a look at the implementation part, we see that the unapplied parameters
    are replaced with an underscore. We've also provided the types explicitly with
    the parameters. So, in a way, *partially applied functions* solve almost the same
    kind of problems that currying solved for us. Also, we know that *partial functions*
    have a similar concept. As we've already gone through *partial functions,* we
    must know that they are just functions that are defined for a particular set of
    input values. Hence, we should be able to differentiate between these three concepts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看实现部分时，我们看到未应用的参数被下划线替换。我们还明确地提供了参数的类型。因此，从某种意义上说，*部分应用函数*解决了柯里化为我们解决的问题。此外，我们知道*部分函数*有类似的概念。因为我们已经了解了*部分函数*，我们必须知道它们只是为特定的一组输入值定义的函数。因此，我们应该能够区分这三个概念。
- en: With this discussion of *partially applied functions*, we have come to the end
    of our chapter. Let's summarize what we have learned.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对*部分应用函数*的讨论，我们结束了本章的内容。让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we enhanced our knowledge of functions in Scala. We started
    with the basic method and function definitions, investigated the difference between
    them, and looked at how Scala treats them. We also saw that Scala is intelligent
    enough to convert a method to a function whenever needed. Then we took the discussion
    further and talked about closures. We got to know what *closures* are and then
    we had a solid discussion regarding higher-order functions in Scala. That was
    essential as we were already using higher-order functions and we saw multiple
    forms of them. Afterwards, we looked at currying and talked about *partially applied
    functions.* We know that partially applied functions are different from *partial
    functions* and *currying.* So now we have a solid understanding of functions in
    Scala because we have investigated them thoroughly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们增强了我们在 Scala 中对函数的知识。我们从基本的方法和函数定义开始，研究了它们之间的区别，并探讨了 Scala 如何处理它们。我们还看到
    Scala 足够智能，能够在需要时将方法转换为函数。然后我们进一步讨论，并谈到了闭包。我们了解了什么是 *闭包*，然后我们对 Scala 中的高阶函数进行了深入的讨论。这是必要的，因为我们已经在使用高阶函数，并且看到了它们的多种形式。之后，我们研究了柯里化，并讨论了
    *部分应用函数*。我们知道部分应用函数与 *部分函数* 和 *柯里化* 是不同的。因此，我们现在对 Scala 中的函数有了坚实的理解，因为我们已经彻底研究了它们。
- en: Now it's time to go further and learn about a few advanced functional constructs.
    The knowledge gained in this chapter will help us do that in the next chapter,
    where we'll learn about advanced functional constructs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更进一步，学习一些高级函数式结构了。本章获得的知识将帮助我们完成下一章的学习，我们将学习高级函数式结构。
