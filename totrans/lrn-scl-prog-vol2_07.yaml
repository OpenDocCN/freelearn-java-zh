- en: More on Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The problems are solved, not by giving new information, but by arranging what
    we have known since long."'
  prefs: []
  type: TYPE_NORMAL
- en: – Ludwig Wittgenstein
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons we choose to write a function is because it can make our
    code more readable and look more concise. It''s also better, when providing a
    solution, to break our problem statements down into components/actions and form
    corresponding functions for them. In this manner, it''s going to be easier to
    solve problems with any programming language that provides function constructs
    (almost all languages provide such constructs because they are important). Scala
    provides a variety of ways in which we can write functions to achieve things.
    Our intention in this chapter is to learn *how.* If you remember correctly, we
    touched upon functions in Scala in [Chapter 4](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Giving Meaning to Programs with Functions*. We discussed how we can declare functions
    and call them using different sets of parameters. We''ve already learned about
    function evaluation strategies and the important concepts of function literals
    and partial functions, and these concepts will help us better understand what
    we''re going to learn in this chapter. Let''s take a look. We''ll continue with
    function literals then discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions versus methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partially applied functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions take you to a new universe where it's fun to use functions,
    return functions, and find other ways we can use those functions. We'll end up
    our discussion in this chapter with higher-order functions. For now, let's continue
    our understanding of function literals.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function literal, in simple terms, is a representation of an action that
    can be performed to specify the input and output parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This line represents a function literal, which is easily readable. It displays
    a function that takes two values, `value1` and `value2` of type `Int`, and returns
    another, `Int`*.* We''ve seen some examples of it, such as our `ColorPrinter`
    example where we were simply able to print color as well as simple black and white
    pages using just one function named `printPages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `colorPrint` and `simplePrint` values are examples of function literals
    of the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Unit` type here represents the absence of a return type. In other words,
    don't expect any output from the function literal. We discussed this concept in
    [Chapter 4](part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84), *Giving Meaning
    to Programs with Functions*, where we answered the *what* and *how* of function
    literals. So now, let's answer the *why*, and by *why* we mean the problem it
    solves. We'll take the preceding example of it. Take a closer look and you'll
    see that we abstracted the problem statement. If we had declared specific functions
    for simple and color pages, they would have spoken for themselves, such as in
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `printColorPages` function, which takes a `Document`, `lastIndex`
    page number, `startIndex` page number, and then prints color pages. The same goes
    for `printSimplePages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are code smells here and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In both of these functions only the implementation part varies, that is, `colorPrint`
    and `simplePrint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of the implementations, input and output parameters do not vary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take both implementations out and pass them as parameters. It''s going
    to be a function literal of the same form as the function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By answering these kinds of questions we get to our end function. It looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope it''s now clear how we go through this kind of refactoring. The best
    thing about it is that it will all come easily to you once you write the code
    yourself. One more thing we would like to know about the representation is that
    when you specify these literals and assign them to a value, you should know how
    they differ. The following representation is going to help you do that. Let''s
    take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Function values and function literals
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see two forms. The one on the left is called
    a function value and the one on the right is a function literal. Function values
    are runtime objects. The question arises, *runtime objects of which type*? The
    answer is a `Function1` type, which is a trait in Scala and declared in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In brackets, [], we have specified the type parameters; we''ll learn about
    these in [Chapter 10](part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84),
    *Advanced Functional Programming.* For now, just understand that these two specify
    that our implementation of `Function1` is going to take an input parameter of
    the first type `T1` and the output will be of type `R`*.* Basically, our literal
    representation is just an anonymous instantiation of this trait and we can verify
    how the compiled version of it looks. The `javap` representation of the previous
    function literal looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding representation means that the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, on the right-hand side, we override the `apply` method for the `Function1`
    trait*.* Does it look more concise written in a literal way? Yes! That''s why
    Scala has this syntax. Also, it means that a function value of this type is going
    to support all methods defined in `Function1`. We know that the trait has an `apply`
    method that''s an abstract member from the trait. We also have a few concrete
    members such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following for a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that `isEven` is the function literal `g`*,* that is, of form
    `(R) => A`. The type `R` for our implementation is `Int` and X is `Boolean`. The
    return type of `andThen` is `g(apply(x))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same manner, we can also find use cases for our `compose` function*.*
    The difference between `andThen` and `compose` can be understood with the help
    of two example functions—`f` and `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: In case of `andThen(g):f(x) == g(apply(x))`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case of `compose(g): f(x) == apply(g(x))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do the remaining mathematics, but it's fun forming such a pipeline of
    operations using literals because they are readable and easy to implement. This
    example brings our discussion of function literals to an end but believe me, we'll
    be using these a lot in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Up till now, we've been using the terms method and function interchangeably
    but the reality is a bit different. These two are different. The question is *how*,
    so let's start by talking about the methods to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen Scala methods and used them many times so far. However,
    to differentiate between methods and functions, we''ll take a look at the Scala
    methods once again. What are methods in Scala? Throughout our discussion of methods,
    we''ll look at several definitions of what a method is. Let''s start with what
    a method may contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Method signature
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we start our method with a few modifiers such as annotations,
    or keywords such as `final` and so on. This is followed by a `def` keyword, method
    name, parameter list, and then a return type that is optional. Scala methods are
    intelligent enough to infer the return type. Usually, a return type for a method
    is what the last expression evaluates to. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a method named `filePrinter`, which does
    nothing but print the filenames in the current directory one by one. It''s worth
    noticing a few things. We have used a `def` keyword*,* an assignment operator,
    and braces. We''ve preferred to omit specifying the return type, that is, `Unit`
    in our case. Methods which do not return any specific type except `Unit` can also
    be written in procedure syntax. In procedure syntax, we omit the assignment operator
    and directly define the method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we wrote a method that prints all the filenames from
    the current directory. Now, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have four representations for our `filePrinter` method in the form of different
    versions, from `V0` to `V3`. Our intention is the same for all four methods. We
    want to print the filenames in the current directory. Can you guess which ones
    will work?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re done with guessing, let''s take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here's the output of our file printers. By taking a closer look, you'll see
    that for `filePrinter` versions `V0`, `V1`, and `V2`, the output is correct but
    for version `V3`, it's not. Plus, the sequence of evaluation tells us that from
    somewhere in our code, we're printing filenames. You might realize that it's because
    of the way we tried to define version v3 of our method. The `filePrinterV3` method
    defines only a simple `println`. The Scala compiler treats subsequent statements
    outside the scope of our method. Well, we can ensure these kind of mistakes don't
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this by explicitly specifying the return type of our methods. Specifying
    the return type makes the Scala compiler take care of such mistakes and then notifies
    you at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: A thing to note about methods in Scala is that they are **non-value** types.
    This means no instance or no object at runtime. This notion causes us to investigate
    what we mean by this and how it works. This statement also provides a major difference
    between functions and methods. Let's investigate the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Functions versus methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we mentioned that we usually use the terms
    **function** and **method** interchangeably. But the reality is different. In
    Scala, these two are different concepts altogether. We'll use several examples
    to help understand this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at all the differences, from syntactical differences to
    semantic differences. We''ll also look at when to use what: a function or a method.
    For now, let''s use a previous example. For the `colorPrinter` function, in both
    versions, we''ll define a method and give it the name, `colorPrintV3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The way we can call these is similar. Syntactically there''s no difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `colorPrint` and `colorPrintV2` are functions and `colorPrintV3` is a
    method. In the preceding use case, we passed all these as literals. This looks
    similar, and it also works in a similar way. It also provides output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We said that methods and functions in Scala are different, but the way we use
    them and the results are similar. This happens because the compiler helps to convert
    a method into a function dynamically when it sees the possibility of doing it.
    So this is our counter-statement to this conflicting situation. We better investigate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll check class files generated by the compiler. Our intention is to investigate
    these three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`colorPrint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorPrintV2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colorPrintV3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The files generated by the compiler is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we observe the preceding compiled class representation of the `colorPrint`
    series of functions, it becomes clear that the way Scala treats them internally
    is different. The takeaway points from this are:'
  prefs: []
  type: TYPE_NORMAL
- en: Scala function literals are compiled down to the form of a FunctionX trait (X
    here, is a placeholder for a number, meaning, the number of parameters this function
    is going to support). We've already seen that this FunctionX trait comes with
    more methods such as `apply`, `andThen`, and `compose`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala methods are compiled down to normal Java methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, methods suited to the context of an object, for example, the `apply`
    method from the FunctionX trait, only get called on anonymous instances of FunctionX,
    so the following makes sense for the `apply` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that Scala does some magic with the function syntax at compile
    time. Also, we know that our literals are *Ffunction objects* so we can perform
    operations like `toString`, as well as equality operations on them. Hence, the
    following is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the compiler won''t let you perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that `colorPrintV3` is a method and not a value type.
    Also if you try to call `toString` on `colorPrintV3`, the compiler will complain
    about it and won''t let you perform such operations on a method type. The Scala
    compiler automatically converts a method to its literal equivalent and provides
    a way to explicitly perform it. We use the following syntax for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the trailing underscore. This syntactic sugar is enough to tell
    the Scala compiler to convert the method to a function. Now, you may call `toString`,
    create a function pipeline, or use `andThen` or `compose` methods on `colorPrintV4`.
    We can even perform equality methods on it. So that's how methods and functions
    are different in Scala, but now the question arises when to choose what?
  prefs: []
  type: TYPE_NORMAL
- en: Methods or functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have an idea about the difference between a method and a function,
    you might be wondering where and when to use what. Should I prefer a function
    over a method or the opposite? Earlier, we defined a `colorPrinterV3` method and
    passed that to our higher-order `printPages` function (we''ll talk about higher-order
    functions in later sections)*.* Now that you know that the compiler has to put
    some extra effort into converting the method into its function equivalent, it
    becomes obvious that in use cases where we''re depending upon higher-order functions,
    it''s a good choice to have functions in scope so that we can communicate properly.
    Apart from that, it''s also obvious that defining a function instead of a method
    gives us more functionality options. We''ve seen examples of methods such as `andThen`
    and `compose`. These methods let us enhance the functionality. Performance-wise,
    there''s not much of a difference in the usage. There are a few scenarios where
    only methods are the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: We can provide default values for method parameters, but that's not possible
    for functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a parent-child class relationship, when we override a method from a superclass,
    we can still access the parent class version of that method using a `super` call.
    However, once you override a function, you can't make a super call and are stuck
    with the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So it's wise to choose which one to use depending on the requirements you have.
    Functions provide us with more chaining capabilities. We may choose to use whichever
    suits us the best.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s again take a look at the snippet we have, and see if we can
    make some more modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I'm using this `Printer` example because it's easy to understand and we've already
    seen bits and pieces of it. So, when taking a look at the calling of the `printPages`
    function, we may want to do some refactoring. First, we know the logic that checks
    if the printer is ON or OFF by checking `printerSwitch` value. Moreover, every
    time we call `printPages`, we have to pass the `!printerSwitch` parameter. We
    want to omit this extra burden of telling the printer to check if it's on or not.
    We want the printer to already know that, that's what we're going to do. But in
    a programming context, is it possible to refer to `printerSwitch` from the inner
    scope of the `printPages` function? Yes, it's possible if we choose to use a closure.
    Let's discuss closures and how we can define them in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: What are closures?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll solve the problem in the previous section using closures. But first,
    let''s explain the concept of a **closure***.* In programming terminology, a closure
    has more than one definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A closure is simply a function value that gets created at runtime and encompasses
    a reference to a free variable that's not in the local scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closure in practical terms is a function that you can pass around that retains
    the same scope and values as the ones it had at the time of creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What do we mean by these statements? Let''s check that using a very simple,
    but a fun example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, you're getting it, aren't you? Here, we created a function that expects
    a `showName` and plays it. That doesn't go so smoothly and we get to watch some
    advertisements. That's what is happening in the preceding code. It's obvious that
    the use case is not practical, but it's easy to understand the concept. We're
    trying to refer to a variable that's not in the local scope of our `playingShow`
    function*.* When we tried using this function for the first time, the runtime
    representation of `playingShow` was referring to the iPhone 7 advertisement. Then
    we time travel, and the second time we called `playingShow`, we watched an advertisement
    that was different from the previous one. The point to take away is the runtime
    representation of our `playingShow` is called a closure. Some terminology included
    with a closure are *open terms* and *closed terms.* Here, in our example, `advertisement`
    is called a free variable because it doesn't reside in the local scope of our
    *function*/*closure* whereas the `showName` parameter, which we explicitly referred
    to, is called a *bound* variable*.* When we try to form a function literal with
    only bound variables, it's called a closed term. And the other way around, when
    you include a free variable, it makes an open term.
  prefs: []
  type: TYPE_NORMAL
- en: 'A closed term example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An open term example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One more thing to note is that a closure only keeps the reference to the free
    variables. That's the reason we were able to detect the change in the value of
    `advertisement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you''ve some idea about closures*,* let''s get back to the refactoring
    of the `printPages` function. Our intended behavior was that the printer should
    already know how to switch before printing. We can omit the function literal specified
    in `printPages`. Then there are two possible solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What we've done in the second solution is we removed `isPrinterOn` from our
    `printPages` function's parameter list and put the implementation with `!printerSwitch`.
    This makes our `printPages` function a closure and somehow we were able to reduce
    code duplication in `colorPrint` and `colorPrintV2`. So this is another alternative
    we have to our solution.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you get the idea of what a closure is and how it can be used. We also
    learned that closures don't solve any problems that can't be solved without them.
    They are just an alternative to getting things done in a concise manner. We also
    saw a closure carry state with them; this is a concept defined in many languages
    and in languages where there's no state present such as **Haskell**, hence these
    are used to carry *immutable state.* However, these are an essential and fun alternative
    to solving a particular problem. In Scala, there are several such tool type constructs
    available, using which we can make our code smell good, a closure is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: We've talked a lot about functions, methods, and closures. During which we've
    come up with various higher-order functions. So now, we're kind of comfortable
    with the concept of higher-order functions. When we see one, it doesn't feel odd
    or doesn't make us feel uncomfortable. Great, then let's discuss them in detail.
    You already have some idea about the power of them in a functional programming
    context. We'll explore them more.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that we can only pass a first-class value object as an argument to
    a method or a function. For example, take this simple method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a method named `sum` and declares two parameters `a` and `b`. Now, to
    use this method, we will pass arguments. In the argument list, it's obvious we'll
    have to pass values of the integer type. It's clear that any type, if it's a value,
    can be declared as a function parameter and can be used as an argument while calling
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala, function literals are nothing more than function trait objects, hence
    it''s obvious that we can declare them as parameters and use them as arguments.
    This gives rise to functions which contain functions as parameters, and function
    calls which contain function literals as arguments. These types of functions are
    called **higher-order functions** (**HOF**). Using higher-order functions has
    its own advantages. We''ve already seen a couple of those. Wherever we define
    abstract syntax in libraries, frameworks, or code, higher-order functions are
    used at large. If you think about how these behaviors/functions can be used in
    higher orders, you''ll come up with a few of the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Function as an output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function as an input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding scenarios specify three conditions where we can use function
    literals as higher-order functions. Take a look at the following figure to get
    a clear picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A few forms of higher-order functions
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the table, we have used a function literal of form `int => int`,
    which means a function that takes an integer as an input and gives back another
    integer after performing some operation on it. The first form in the figure takes
    an integer as an input parameter and returns a function literal of form `int ->
    int`. In the second form, we are taking a function literal of form `int -> int`,
    and giving an integer as an output. In the final form, we are expecting an integer
    and a function literal of the same form `int -> int` as a parameter. Let''s see
    a few examples to see things clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined all three forms. The first gives a function
    as an output, named `multiplier10`, the form itself is explanatory. It takes an
    integer and returns a function literal that is a multiplier of 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is a higher-order method which takes a function literal as input
    and outputs an integer as a result. The `intOpPerformer` method, as the name suggests,
    performs an operation of type `Int => Int`, be it a multiplication operation or
    any other operation. Whichever we pass, it''s going to be used and the output
    will be an integer as mentioned in the signature. We can call the function by
    providing an input function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So this is another way we can utilize the higher-order nature of a function.
    There''s one more, the third version, where we pass this function literal as part
    of the parameter list and it applies the first parameter value to the second parameter
    function and gives an integer result. The `multiplicator` function is an example
    of such a construct. We have used the curried form of the function. We''ll learn
    about currying in subsequent sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These are the ways we can incorporate higher-order functions and all of them
    solve certain problems. By removing code duplication, we can abstract out the
    pattern and make a higher-order version of our function. That's how we use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our famous `ColorPrinter` example also uses higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `print` is a higher-order function that we are passing as a parameter.
    A close look will explain it better. The `colorPrint` argument itself is a function
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possible just because `colorPrint` is a value object. While we are
    on the subject, sometimes you may read: "Functional languages treat functions
    as first class values." What do we mean by *first class values*? It means that
    the way we declare an integer or string value and use them as parameters. In the
    same way, we can declare a function literal and use it as a parameter in other
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions make it a lot easier to compose functions or chains of
    functions to perform a complex task in an easy and readable manner. Needless to
    say, utility functions such as `map`, `flatmap`, `filter`, `fold`, and so on are
    all higher-order functions. In Scala or any other programming language, functions
    such as `map`, `filter`, or `flatmap` are a result of trying to solve a particular
    pattern of problem. Hence, it's obvious that we take a part of a certain pattern
    from our functions and replace it with a higher-order function. The idea for this
    action is to abstract out the implementation in the form of a function literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example, to get a better understanding, is a simple mathematical operation
    for two integers. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code are a few methods that take two input parameters and
    perform a particular operation. Using these is also pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: But as good programmers, it's our duty to check the implementation details,
    even if the solution is working. When you do that, you get to see that all four
    implementations have many things in common. All four methods have two parameters
    but the definition proves to be different as each method is performing a different
    operation. In a sense, we know we can abstract out the signature and implementation
    details in the form of function literals and form a higher-order function. So
    we take steps for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create function literal versions of all four implementations, which
    have a form of `(Int, Int) => Int` and we come up with something like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that we can pass these literals without worrying about internal
    dynamic conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we write the abstracted out method that takes one such function literal
    and two integer parameters to perform the operation on. The result looks something
    like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, `operation` is the higher-order method which takes a function literal
    and two parameters and calls the function passed with the other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using the higher-order method is as easy as calling any other function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You may ask whether this makes sense. We still wrote the same (with a couple
    of extra) lines of code. So let''s remove the literals we wrote, as those are
    just literals we named. We can directly use the functionality by providing what
    you intend to do dynamically to our `operation` function. Our code looks like
    the following after the final implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The real function required is just a one-liner, the `operation` higher-order
    function. The next few lines are the calls to the previous `operation` function.
    One thing to note, on the calling side of the `operation` function we didn't provide
    the `a` and `b` type of parameters. That's because Scala is powerful enough to
    understand that an `operation` functions first parameter expects the same type
    as we are providing.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this example helps you to understand the concept of higher-order functions.
    In practice, the more you use them, the more you get to see the power of them.
    A couple of forms exist, using which we solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen more than one representation and one use case of higher-order
    functions, let's take a look at another way of calling functions using currying.
    You may have heard about currying as a concept. Here, our motto is to understand
    what Currying is and what purpose it solves.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala allows you to pass multiple parameters in functions or methods. We may
    want to create intermediate versions of such functions. This gives us more than
    one version of a single function. In other words, we can break down every function
    with multiple parameters into single parameter functions. Why would we want to
    create single parameter functions? The answer to this is, we can leverage it for
    function composition. For example, we can launch a website with the help of a
    domain name, hosting, and web platform. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a function that takes a domain name, another function that takes
    a website platform, and another function that takes a hosting platform as a parameter,
    you can compose them together to have a full-fledged website. Functional composition
    is powerful because it gives you more options together with intermediate functions.
    A normal function would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This form of a method does not provide you with the same power that you have
    when you compose a function. As mentioned, in Scala it''s possible to convert
    our functions to a curried form or convert functions with multiple parameters
    into a function with single parameters. For that Haskell Curry has provided the
    concept of currying. Here''s an example to help us understand this. We''ll take
    the same example of making a website. The problem statement is clear. We want
    to compose intermediate functions where we can pass multiple, single parameter
    lists. The end function should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `WebsitePlatform`, `DomainName`, and `Host` are the types we choose to
    use. We can create these using Scala, providing the `type` keyword. A form of
    the preceding function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to have an intermediate function that does not have to deal
    with the website platform, and simply creates a WordPress.com platform account
    for the intended account. The function should return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for the other two intermediate versions. For example, you want
    to create a dummy website with the default WordPress.com ([https://wordpress.com/](https://wordpress.com/))
    platform and a dummy WordPress URL for your website. The version then looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The final version deals with all the defaults using bluehost.com as the default
    hosting provider and creating a website for you. An example application would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Did you take a look at the preceding code? We used composition, step-by-step,
    to make a default website creator that uses WordPress.com as a website platform,
    bluehost.com as hosting provider, and some dummy URI as URL. Let's try to understand
    how this is working. The first thing that we did was just add a syntactic enhancement
    for a better understanding. The three types we declared using the type keywords
    are just strings. These strings are, of course, for demonstration purposes. They
    can be of different types. Then we declared the curried version of a method that
    takes three different single parameter lists. The definition is not very important
    right now, we're just printing.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the interesting part. We created an intermediate version of our function,
    named `wordPress`, and the return type of this function is `DomainName => Host
    => Unit`. In the very next step, we created another intermediate function named
    `wordPressDummyDotCom` that is particular to WordPress.com and uses a dummy URL.
    In the same way, we again composed another function that gives another default
    website component. The advantage of this is that we can create multiple versions
    with different website platforms and thus things will be easier for the client
    of your program, as you're providing multiple versions of default functions for
    almost every set of parameters. For that, we have used nothing more than the curried
    form of our function. It is so common to convert or write curried versions of
    your function in Scala, that the language has a default way of doing it. In Scala,
    it's possible to convert a function with multiple parameters to its curried counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a function with multiple parameters to curried form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, we have a function called `curried`*,* using which we can convert
    our functions to a curried form. Let''s see a simple example for a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a simple two-parameter function literal named `add`. Then,
    we used a Scala-provided function named `curried` to convert the function to its
    curried form. We named the result `addCurried`. With that, we were able to call
    both functions and got the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a way to uncurry curried functions. We have this `uncurried`
    method, using which we can convert the curried function to uncurried form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is how we use currying in Scala. There are similar constructs that we can
    use in Scala to fulfill the same intentions, and we call them *partially applied
    functions*. These are different to currying. Let's discuss the topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Partially applied functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partially applied functions, as the name suggests, apply the functions partially.
    It means that for functions with multiple parameters in a parameter list, we don't
    provide a value for each of the parameters. If we don't want to provide parameters
    we just leave them blank. Now that we know this, let's look at a similar example
    to the one we looked at when learning currying. With this, you'll be able to differentiate
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, take a look at the multiple parameter functions, which we''ll convert
    to partially applied forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `makeWebsite`, as we have already seen, takes three parameters, `platform`,
    `domainName`, and `host`. Take a look at an application we can create with various
    intermediate or partially applied functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here we can see three partially applied functions. Take a look at the first
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The function name suggests what this does. We can expect this function to provide
    a partially applied function for `WebsitePlatform`, and that''s the reason the
    return type of the function is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this function, we simply provide the unapplied parameters and it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we also described other versions, let''s take a look at them.
    For one of them, we provided a default dummy URL for our website, the website
    platform, and hosting service that we can provide at the time of calling the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The version returns back the type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When we take a look at the implementation part, we see that the unapplied parameters
    are replaced with an underscore. We've also provided the types explicitly with
    the parameters. So, in a way, *partially applied functions* solve almost the same
    kind of problems that currying solved for us. Also, we know that *partial functions*
    have a similar concept. As we've already gone through *partial functions,* we
    must know that they are just functions that are defined for a particular set of
    input values. Hence, we should be able to differentiate between these three concepts.
  prefs: []
  type: TYPE_NORMAL
- en: With this discussion of *partially applied functions*, we have come to the end
    of our chapter. Let's summarize what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we enhanced our knowledge of functions in Scala. We started
    with the basic method and function definitions, investigated the difference between
    them, and looked at how Scala treats them. We also saw that Scala is intelligent
    enough to convert a method to a function whenever needed. Then we took the discussion
    further and talked about closures. We got to know what *closures* are and then
    we had a solid discussion regarding higher-order functions in Scala. That was
    essential as we were already using higher-order functions and we saw multiple
    forms of them. Afterwards, we looked at currying and talked about *partially applied
    functions.* We know that partially applied functions are different from *partial
    functions* and *currying.* So now we have a solid understanding of functions in
    Scala because we have investigated them thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to go further and learn about a few advanced functional constructs.
    The knowledge gained in this chapter will help us do that in the next chapter,
    where we'll learn about advanced functional constructs.
  prefs: []
  type: TYPE_NORMAL
