["```java\nvar webSocket = new WebSocket('ws://localhost:9000');\nwebSocket.onopen = function () {\n  webSocket.send(\"hello\");\n};\nwebSocket.onmessage = function (event) {\n  console.log(event.data);\n};\nwebSocket.onclose = function () {\n  alert(\"oops!! Disconnected\")\n}\n```", "```java\nlibraryDependencies ++= Seq(\n  \"com.typesafe.akka\" %% \"akka-actor\" % \"2.3.4\"\n)\n```", "```java\nclass Reverser extends Actor {\n\n  def receive = {\n    case s:String => println( s.reverse)\n    case _ => println(\"Sorry, didn't quite understand that. I can only process a String.\")\n  }\n}\n\nobject Reverser {\n  def props = Props(classOf[Reverser])\n}\n```", "```java\nval system = ActorSystem(\"demoSystem\")\n```", "```java\nval demoActor = system.actorOf(Reverser.props, name = \"demoActor\")\n```", "```java\ndemoActor ! \"Hello, How do u do?\"\ndemoActor ! \"Been Long since we spoke\"\ndemoActor ! 12345\n```", "```java\n> run\n[info] Compiling 1 Scala source to /AkkaActorDemo/target/scala-2.10/classes...\n[info] Running com.demo.Main\n?od u od woH ,olleH\nekops ew ecnis gnoL neeB\nSorry, didn't quite understand that I can only process a String.\n\n```", "```java\nclass ReverserWithLimit(min:Int,max:Int) extends Actor {\n\n  def receive = {\n    case s:String if (s.length> min & s.length<max)=> println( s.reverse)\n    case _ => println(s\"Sorry, didn't quite understand that. I can only process a String of length $min-$max.\")  }\n}\n\nobject ReverserWithLimit {\n  def props(min:Int,max:Int) = Props(classOf[Reverser],min,max)\n}\n```", "```java\n def websocketBroadcast = WebSocket.using[String] {\n    request =>\n      val (out, channel) = Concurrent.broadcast[String]\n      val in = Iteratee.foreach[String] {\n        word => channel.push(word.reverse)\n      }\n      (in, out)\n  }\n```", "```java\nGET        /ws                  controllers.Application.websocketBroadcast\n```", "```java\n def websocketUnicast = WebSocket.using[String] {\n    request =>\n      var channel: Concurrent.Channel[String] = null\n      val out = Concurrent.unicast[String] {\n        ch =>\n          channel = ch\n      }\n      val in = Iteratee.foreach[String] {\n        word => channel.push(word.reverse)\n      }\n      (in, out)\n  }\n```", "```java\n    def dbWebsocket = WebSocket.using[JsValue] {\n        request =>\n          WebSocketChannel.init\n      }\n    ```", "```java\nobject WebSocketChannel {\n  def props(channel: Concurrent.Channel[JsValue]): Props =\n    Props(classOf[WebSocketChannel], channel)\n\n  def init: (Iteratee[JsValue, _], Enumerator[JsValue]) = {\n\n    var actor: ActorRef = null\n    val out = Concurrent.unicast[JsValue] {\n      channel =>\n        actor = Akka.system.actorOf(WebSocketChannel.props(channel))\n    }\n\n    val in = Iteratee.foreach[JsValue] {\n      jsReq => actor ! jsReq\n    }\n    (in, out)\n  }\n}\n```", "```java\nclass WebSocketChannel(wsChannel: Concurrent.Channel[JsValue])\n  extends Actor with ActorLogging {\n\n  val backend = Akka.system.actorOf(Props(classOf[DBActor]))\n\n  def receive: Actor.Receive = {\n    case jsRequest: JsValue =>\n      backend ! convertJson(jsRequest)\n    case x: DBResponse =>\n      wsChannel.push(x.toJson)\n  }\n}\n```", "```java\nclass Reverser(outChannel: ActorRef) extends Actor {\n\n    def receive = {\n      case s: String => outChannel ! s.reverse\n    }\n  }\n\nobject Reverser {\n  def props(outChannel: ActorRef) = Props(classOf[Reverser], outChannel)\n}\n```", "```java\ndef websocket = WebSocket.acceptWithActor[String, String] {\n  request => out =>\n    Reverser.props(out)\n}\n```", "```java\nGET        /wsActor                  controllers.Application.websocket\n```", "```java\n def dbCommunicator = WebSocket.acceptWithActor[JsValue, JsValue] {\n    request => out =>\n      WebSocketChannel.props(out)\n  }\n```", "```java\nclass WebSocketChannel(out: ActorRef)\n  extends Actor with ActorLogging {\n\n  val backend = Akka.system.actorOf(DBActor.props)\n  def receive: Actor.Receive = {\n    case jsRequest: JsValue =>\n      backend ! convertJsonToMsg(jsRequest)\n    case x:DBResponse =>\n      out ! x.toJson\n  }\n}\n\nobject WebSocketChannel {\n  def props(out: ActorRef): Props =\n    Props(classOf[WebSocketChannel], out)\n}\n```", "```java\noverride def postStop() = {\n  backend ! PoisonPill\n}\n```", "```java\ncase class WebsocketRequest(reqType:String, message:String)\n```", "```java\ndef websocketFormatted = WebSocket.acceptWithActor[WebsocketRequest, JsValue]{\n  request => out =>\n  SomeActor.props(out)\n}\n```", "```java\nimplicit val requestFormat = Json.format[WebsocketRequest]\nimplicit val requestFrameFormatter = FrameFormatter.jsonFrame[WebsocketRequest]\n```", "```java\n    override def onRouteRequest(request: RequestHeader): Option[Handler] = {\n        if(request.path.startsWith(\"/ws\")){\n          Option(controllers.Default.error)\n        } else\n          super.onRouteRequest(request)\n      }\n    ```", "```java\n    def wsWithHeader = WebSocket.tryAccept[String] {\n        rh =>\n          Future.successful(rh.headers.get(\"token\") match {\n            case Some(x) =>\n              var channel: Concurrent.Channel[String] = null\n              val out = Concurrent.unicast[String] {\n                ch =>\n                  channel = ch\n              }\n              val in = Iteratee.foreach[String] {\n                word => channel.push(word.reverse)\n              }\n              Right(in, out)\n            case _ => Left(Forbidden)\n          })\n      }\n    ```", "```java\n    def wsheaders = WebSocket.tryAcceptWithActor[String, String] {\n        request =>\n          Future.successful(request.headers.get(\"token\") match {\n            case Some(x) => Right(out => Reverser.props(out))\n            case _ => Left(Forbidden)\n          })\n      }\n    ```"]