- en: Chapter 4. Projectiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Flying is learning how to throw yourself at the ground and miss."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Douglas Adams* |'
  prefs: []
  type: TYPE_TB
- en: Actors in creative Greenfoot applications, such as games and animations, often
    have movement that can best be described as *being launched*. For example, a soccer
    ball, bullet, laser, light ray, baseball, and firework are examples of this type
    of object. One common method of implementing this type of movement is to create
    a set of classes that model real-world physical properties (mass, velocity, acceleration,
    friction, and so on) and have game or simulation actors inherit from these classes.
    Some refer to this as creating a *physics engine* for your game or simulation.
    However, this course of action is complex and often overkill. As you learned in
    [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation*, there are often
    simple heuristics we can use to approximate realistic motion. This is the approach
    we will take here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the basics of projectiles, how to make
    an object bounce, and a little about particle effects. We will apply what you
    learn to a small platform game that we will build up over the course of this chapter.
    In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gravity and jumping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bouncing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bullets and turrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating realistic flying objects is not simple, but we will cover this topic
    in a methodical, step-by-step approach, and when we are done, you will be able
    to populate your creative scenarios with a wide variety of flying, jumping, and
    launched objects. It's not as simple as Douglas Adams makes it sound in his quote,
    but nothing worth learning ever is.
  prefs: []
  type: TYPE_NORMAL
- en: Cupcake Counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is beneficial to the learning process to discuss topics in the context of
    complete scenarios. Doing this forces us to handle issues that might be elided
    in smaller, one-off examples. In this chapter, we will build a simple platform
    game called **Cupcake Counter** (shown in *Figure 1*). We will first look at a
    majority of the code for the **World** and **Actor** classes in this game without
    showing the code implementing the topic of this chapter, that is, the different
    forms of projectile-based movement. We will then present and explain the missing
    code in subsequent sections. This is the same approach we took in the preceding
    chapter, in order to study collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cupcake Counter](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This is a screenshot of Cupcake Counter'
  prefs: []
  type: TYPE_NORMAL
- en: How to play
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of **Cupcake Counter** is to collect as many cupcakes as you can before
    being hit by either a ball or a fountain. The left and right arrow keys move your
    character left and right and the up arrow key makes your character jump. You can
    also use the space bar key to jump. After touching a cupcake, it will disappear
    and reappear randomly on another platform. Balls will be fired from the turret
    at the top of the screen and fountains will appear periodically. The game will
    increase in difficulty as your cupcake count goes up. The game requires good jumping
    and avoiding skills.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Cupcake Counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a scenario called `Cupcake Counter` and add each class to it as they
    are discussed. If you prefer, you can download the initial version of Cupcake
    Counter from: [http://www.packtpub.com/support](http://www.packtpub.com/support)'
  prefs: []
  type: TYPE_NORMAL
- en: The CupcakeWorld class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subclass of `World` sets up all the actors associated with the scenario,
    including a score. It is also responsible for generating periodic enemies, generating
    rewards, and increasing the difficulty of the game over time. The following is
    the code for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the methods in this class in order. First, we have the class constructor
    `CupcakeWorld()`. After calling the constructor of the superclass, it calls `setPaintOrder()`
    to set the actors that will appear in front of other actors when displayed on
    the screen. You were introduced to `setPaintOrder()` in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation*. The main reason why we use it here, is so
    that no actor will cover up the `Counter` class, which is used to display the
    score. Next, the constructor method calls `prepare()` to add and place the initial
    actors into the scenario. We will discuss the `prepare()` method later in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `act()` method, we will only call the function `checkLevel()`. As
    the player scores points in the game, the `level` variable of the game will also
    increase. The `checkLevel()` function will change the game a bit according to
    its `level` variable. When our game first starts, no enemies are generated and
    the player can easily get the cupcake (the reward). This gives the player a chance
    to get accustomed to jumping on platforms. As the cupcake count goes up, balls
    and fountains will be added. As the level continues to rise, `checkLevel()` reduces
    the delay between creating balls (`BCOUNT`) and fountains (`FCOUNT`). The `level`
    variable of the game is increased in the `addCupcakeCount()` method, which we
    will discuss in detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: The `generateFountains()` method adds a `Fountain` actor to the scenario. The
    rate at which we create fountains is controlled by the delay variable (refer to,
    [Chapter 2](part0017.xhtml "Chapter 2. Animation"), *Animation* to review) `fountainContainer`.
    After the delay, we create a fountain on a randomly chosen `Brick` (the platforms
    in our game). The `getObjects()` method returns all of the actors of a given class
    presently in the scenario. We then use `getRandomNumber()` to randomly choose
    a number between one and the number of `Brick` actors. Next, we use `addObject()`
    to place the new `Fountain` object on the randomly chosen `Brick` object.
  prefs: []
  type: TYPE_NORMAL
- en: Generating balls using the `generateBalls()` method is a little easier than
    generating fountains. All balls are created in the same location as the `turret`
    at the top of the screen and sent from there with a randomly chosen trajectory.
    The rate at which we generate new `Ball` actors is defined by the delay variable
    `ballCounter`. Once we create a `Ball` actor, we rotate the `turret` based on
    its *x* velocity. By doing this, we create the illusion that the turret is aiming
    and then firing `Ball Actor`. Last, we place the newly created `Ball` actor into
    the scenario using the `addObject()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `addCupcakeCount()` method is called by the actor representing the player
    (`Bob`) every time the player collides with `Cupcake`. In this method, we increase
    `score` and then call `generateNewCupcake()` to add a new `Cupcake` actor to the
    scenario. The `generateNewCupcake()` method is very similar to `generateFountains()`,
    except for the lack of a delay variable, and it randomly places `Cupcake` on one
    of the bricks instead of a `Fountain` actor. In [Chapter 1](part0014.xhtml "Chapter 1. Let's
    Dive Right in…"), *Let's Dive Right in…*, we demonstrated how to create a game
    score using the `Counter` class, a class you can import into your scenario. Please
    refer to that chapter for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In all of our previous scenarios, we used a `prepare()` method to add actors
    to the scenario. The major difference between this `prepare()` method and the
    previous ones, is that we use the `addObjectNudge()` method instead of `addObject()`
    to place our platforms. The `addObjectNudge()` method simply adds a little randomness
    to the placement of the platforms, so that every new game is a little different.
    The random variation in the platforms will cause the `Ball` actors to have different
    bounce patterns and require the player to jump and move a bit more carefully.
    In the call to `addObjectNudge()`, you will notice that we used the numbers `85`
    and `62`. These are simply numbers that spread the platforms out appropriately,
    and they were discovered through trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: I created a blue gradient background to use for the image of `CupcakeWorld`.
    Feel free to use this from the sample code you can download, create your own background
    image, or use one of the background images provided that come with Greenfoot.
  prefs: []
  type: TYPE_NORMAL
- en: Enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Cupcake Counter, all of the actors that can end the game if collided with
    are subclasses of the `Enemy` class. Using inheritance is a great way to share
    code and reduce redundancy for a group of similar actors. However, we often will
    create class hierarchies in Greenfoot solely for *polymorphism*. Polymorphism
    refers to the ability of a class in an object-orientated language to *take on
    many forms*. We are going to use it, so that our player actor only has to check
    for collision with an `Enemy` class and not every specific type of `Enemy`, such
    as `Ball` or `RedBall`. Also, by coding this way, we are making it very easy to
    add code for additional enemies, and if we find that our enemies have redundant
    code, we can easily move that code into our `Enemy` class. In other words, we
    are making our code extensible and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for our `Enemy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ball` class extends the `Enemy` class. Since `Enemy` is solely used for
    polymorphism, the `Ball` class contains all of the code necessary to implement
    bouncing and an initial trajectory. Here is the code for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `Ball` is missing the code to handle moving and bouncing.
    As we stated earlier, we will go over all the projectile-based code after providing
    the code we are using as the starting point for this game. In the `Ball` constructor,
    we randomly choose a speed in the *x* direction and save it in the `speedX` instance
    variable. We have included one accessory method to return the value of `speedX`
    (`getXVelocity()`). Last, we include `checkOffScreen()` to remove `Ball` once
    it goes off screen. If we do not do this, we would have a form of memory leak
    in our application because Greenfoot will continue to allocate resources and manage
    any actor until it is removed from the scenario. For the `Ball` class, I choose
    to use the `ball.png` image, which comes with the standard installation of Greenfoot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to create a simple particle effect. Creating
    an effect is more about the use of a particle as opposed to its implementation.
    In the following code, we create a generic particle class, `Particles`, that we
    will extend to create a `RedBall` particle. We have organized the code in this
    way to easily accommodate adding particles in the future. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our particles are implemented to move up and slightly turn each call of the
    `act()` method. A particle will move `lifeSpan` times and then remove itself.
    As you might have guessed, `lifeSpan` is another use of a delay variable. The
    `turnRate` property can be either positive (to turn slightly right) or negative
    (to turn slightly left).
  prefs: []
  type: TYPE_NORMAL
- en: 'We only have one subclass of `Particles`, `RedBall`. This class supplies the
    correct image for `RedBall`, supplies the required input for the `Particles` constructor,
    and then scales the image according to the parameters `scaleX` and `scaleY`. Here''s
    the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For `RedBall`, I used the Greenfoot-supplied image `red-draught.png`.
  prefs: []
  type: TYPE_NORMAL
- en: Fountains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this game, fountains add a unique challenge. After reaching level five (see
    the `World` class `CupcakeWorld`), `Fountain` objects will be generated and randomly
    placed in the game. *Figure 2* shows a fountain in action. A `Fountain` object
    continually spurts `RedBall` objects into the air like water from a fountain.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fountains](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: This is a close-up of a Fountain object in the game Cupcake Counter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code that implements the `Fountain` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The constructor for `Fountain` creates a new blue, semitransparent square and
    sets that to be its image. We start with a blue square to give the player of the
    game a warning that a fountain is about to erupt. Since fountains are randomly
    placed at any location, it would be unfair to just drop one on our player and
    instantly end the game. This is also why `RedBall` is a subclass of `Enemy` and
    `Fountain` is not. It is safe for the player to touch the blue square. The `startDelay`
    delay variable is used to pause for a short amount of time, then remove the blue
    square (using the function `wipeView()`), and then start the `RedBall` shower
    (using the `createRedBallShower()` function). We can see this in the `act()` method.
    The implementation for `createRedBallShower()` is given and explained in the *Particle
    effects* section to come ahead in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Turrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the game, there is a turret in the top-middle of the screen that shoots
    purple bouncy balls at the player. It is shown in *Figure 1*. Why do we use a
    bouncy-ball shooting turret? *Because this is our game and we can!* The implementation
    of the `Turret` class is very simple. Most of the functionality of rotating the
    turret and creating `Ball` to shoot is handled by `CupcakeWorld` in the `generateBalls()`
    method already discussed. The main purpose of this class is to just draw the initial
    image of the turret, which consists of a black circle for the base of the turret
    and a black rectangle to serve as the cannon. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We previously talked about the `GreenfootImage` class and how to use some of
    its methods to do custom drawing. One new function we introduced is `drawImage()`.
    This method allows you to draw one `GreenfootImage` into another. This is how
    you compose images, and we used it to create our turret from a rectangle image
    and a circle image.
  prefs: []
  type: TYPE_NORMAL
- en: Rewards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a `Reward` class for the same reason we created an `Enemy` class.
    We are setting ourselves up to easily add new rewards in the future. (later in
    the chapter, we will assign this as an exercise). Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cupcake` class is a subclass of the `Reward` class and represents the
    object on the screen the player is constantly trying to collect. However, cupcakes
    have no actions to perform or state to keep track of; therefore, its implementation
    is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When creating this class, I set its image to be `muffin.png`. This is an image
    that comes with Greenfoot. Even though the name of the image is a muffin, it still
    looks like a cupcake to me.
  prefs: []
  type: TYPE_NORMAL
- en: Jumpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Jumper` class is a class that will allow all subclasses of it to jump
    when pressing either the up arrow key or the spacebar. Most of the body of this
    class will be implemented in the *Gravity and jumping* section to come ahead in
    the chapter. At this point, we just provide a placeholder implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next class we are going to present is the `Bob` class. The `Bob` class
    extends the `Jumper` class and then adds functionality to let the player move
    it left and right. It also uses animation techniques discussed in [Chapter 2](part0017.xhtml
    "Chapter 2. Animation"), *Animation* to make it look as though it is actually
    walking. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Like `CupcakeWorld`, this class is substantial. We will discuss each method
    it contains sequentially. First, the constructor's main duty is to set up the
    images for the walking animation. This type of animation was discussed in [Chapter
    2](part0017.xhtml "Chapter 2. Animation"), *Animation* in the *Hurting the avatar*
    section and again in [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"),
    *Collision Detection* in the *Detecting a collision with multiple objects* section.
    The images came from [www.wikia.com](http://www.wikia.com) and were supplied,
    in the form of a sprite sheet, by the user Mecha Mario. A direct link to the sprite
    sheet is [http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG](http://smbz.wikia.com/wiki/File:Dawson_Sprite_Sheet.PNG).
    Note that I manually copied and pasted the images I used from this sprite sheet
    using my favorite image editor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Free Internet resources**'
  prefs: []
  type: TYPE_NORMAL
- en: Unless you are also an artist or a musician in addition to being a programmer,
    you are going to be hard pressed to create all of the assets you need for your
    Greenfoot scenario. If you look at the credits for AAA video games, you will see
    that the number of artists and musicians actually equal or even outnumber the
    programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Internet comes to the rescue. There are a number of websites that
    supply legally free assets you can use. For example, the website I used to get
    the images for the `Bob` class supplies free content under the Creative Commons
    Attribution-Share Alike License 3.0 (Unported) (CC-BY-SA) license. It is very
    important that you check the licensing used for any asset you download off the
    Internet and follow those user agreements carefully. In addition, make sure that
    you fully credit the source of your assets. For games, you should include a *Credits*
    screen to cite all the sources for the assets you used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some good sites for free, online assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.wikia.com](http://www.wikia.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[newgrounds.com](http://newgrounds.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://incompetech.com](http://incompetech.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[opengameart.org](http://opengameart.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[untamed.wild-refuge.net/rpgxp.php](http://untamed.wild-refuge.net/rpgxp.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `act()` method. It first calls the `act()` method of its superclass.
    It needs to do this so that we get the jumping functionality that is supplied
    by the `Jumper` class. Then, we call `checkDead()` and `eatReward()`. The `checkDead()`method
    ends the game if this instance of the `Bob` class touches an enemy, and `eatReward()`
    adds one to our score, by calling the `CupcakeWorld` method `addCupcakeCount()`,
    every time it touches an instance of the `Cupcake` class.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the class implements moving left and right. The main method for
    this is `handleKeyPresses()`. Like in `act()`, the first thing we do, is call
    `handleKeyPresses()` contained in the `Jumper` superclass. This runs the code
    in `Jumper` that handles the spacebar and up arrow key presses. The key to handling
    key presses is the Greenfoot method `isKeyDown()` (see the following information
    box). We use this method to check if the left arrow or right arrow keys are presently
    being pressed. If so, we check whether or not the actor can move left or right
    using the methods `canMoveLeft()` and `canMoveRight()`, respectively. If the actor
    can move, we then call either `moveLeft()` or `moveRight()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Handling key presses in Greenfoot**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preface of the book, we explained that we assumed that you have some
    experience with Greenfoot and have, minimally, completed the tutorials located
    on the page: [http://www.greenfoot.org/doc](http://www.greenfoot.org/doc)'
  prefs: []
  type: TYPE_NORMAL
- en: The second tutorial explains how to control actors with the keyboard. To refresh
    your memory, we are going to present some information on the keyboard control
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary method we use in implementing keyboard control is `isKeyDown()`.
    This method provides a simple way to check whether a certain key is being pressed.
    Here is an excerpt from Greenfoot''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss `canMoveLeft()`, `moveLeft()`, and `animateLeft()`. The
    `canMoveRight()`, `moveRight()`, and `animateRight()`methods mirror their functionality
    and will not be discussed. The sole purpose of `canMoveLeft()` is to prevent the
    actor from walking off the left-hand side of the screen. The `moveLeft()` method
    moves the actor using `setLocation()` and then animates the actor to look as though
    it is moving to the left-hand side. It uses a delay variable to make the walking
    speed look natural (not too fast). The `animateLeft()` method sequentially displays
    the walking-left images. This is the same animation strategy we saw in [Chapter
    2](part0017.xhtml "Chapter 2. Animation"), *Animation*.
  prefs: []
  type: TYPE_NORMAL
- en: Platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game contains several platforms that the player can jump or stand on. The
    platforms perform no actions and only serve as placeholders for images. We use
    inheritance to simplify collision detection. Here is the implementation of `Platform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the implementation of `BrickWall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the implementation of `Brick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Test it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now be able to compile and test Cupcake Counter. Make sure you handle
    any typos or other errors you introduced while inputting the code. For now, you
    can only move left and right. Check out `Bob` walking. *Pretty cool!* Everything
    else depends on some of the code we left out of the preceding implementations.
    We will fill out that missing code next. Let's launch some actors.
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider one of the locations we left out of the previous code. Try to supply
    the code yourself. How would you start? My suggestion would be to start with pencil
    and paper. Draw some figures and imagine the steps that you would need to perform
    to implement the functionality. Translate these steps to Java code and try them
    out. Doing this will help you better understand and process the upcoming solutions,
    even if your solution was incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Launching actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to take the preceding incomplete implementation and turn it into
    a game by adding jumping, bouncing, a particle effect, and bullets fired from
    a turret.
  prefs: []
  type: TYPE_NORMAL
- en: Gravity and jumping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Presently, our player character is stuck at the bottom of the screen. We are
    going to fill in the missing code in the `Jumper` class and the `Bob` class to
    enable our character to jump and finally have a way to reach the cupcake reward
    at the top of the screen. Jumping is applying a force to move an object upwards.
    We are also going to need a downwards force operating on the object, in order
    for it to fall back down. As in real life, we are going to call this force *gravity*.
    The changes to the `Jumper` class are so extensive that we are going to first
    look at the complete implementation and then discuss it afterwards. Here''s the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we have added two new instance variables (`fallSpeed` and `jumping`)
    and two static constants (`GRAVITY` and `JUMPSTRENGTH`). These new variables will
    be used throughout our code. In our `act()` method, we added the `standOrFall()`
    method. This method is responsible for applying gravity and detecting collisions
    (both for the head and feet of the actor). Before looking at that method further,
    let's look at the completed implementation of `handleKeyPresses()`. In this method,
    we detect whether the space bar or up arrow key was pressed and call `jump()`
    if it was. You will notice that the `if` statement also contains a check to see
    whether the `Boolean` variable `jumping` is `false`. We need this check to prevent
    double jumping (jumping again while in the middle of a jump). The `jump()` method
    changes `fallSpeed` to a negative value. This applies a force in the up direction
    on the actor. We set `jumping` to `true` (as we are now in a jumping state) and
    then call `fall()`. The `fall()` method applies gravity to an actor. In this method,
    we can see how a negative value of `fallSpeed` will propel the actor upwards.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `fallSpeed` has `GRAVITY` added to it until it becomes positive.
    This will create a parabola-like motion, as shown in *Figure 3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Gravity and jumping](img/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: This is the implementation of falling'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the implementation of `standOrFall()`. The first thing we need
    to check is whether or not we are presently standing on a `Platform` object. We
    use the method `inAir()` to do this check. This method uses `getOneObjectAtOffset()`
    (see [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*) to check whether the bottom of the actor is touching a `Platform`
    object and returns `false` if it is. In `standOrFall()`, we do three things if
    we have determined that we are in the air. We check to see whether the top or
    bottom of the actor is colliding with `Platform` and call the `fall()` method
    if it is. The methods `checkHead()` and `checkLanding()` are similar. They are
    both used in border-based collision detection, as discussed in [Chapter 3](part0024.xhtml
    "Chapter 3. Collision Detection"), *Collision Detection*, to detect at exactly
    which pixel location the collision occurred. They then change the value of `fallSpeed,`
    so that the actor stops at the point of collision. If we detect that we are not
    in the air in `standOrFall()`, then we are standing on a platform and can set
    `fallSpeed` to `0` (not falling) and `jumping` to `false` (not jumping).
  prefs: []
  type: TYPE_NORMAL
- en: Bouncing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bouncing actors look great and really add a nice dimension to any game. In
    the mind of the player, they propel your game from a flat arrangement of pixels
    to a rich world in which objects obey the natural laws of physics. In Cupcake
    Counter, the balls shot from the turret bounce. Bouncing is implemented in the
    `Ball` class. First, add the following instance variables to your existing `Ball`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add code to the `act()` method that will cause an instance
    of the class to fall or bounce if it hits an object. Change your `act()` method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fallOrBounce()` method is going to be complex, but we are going to use
    functional decomposition (break it up into smaller methods) to manage the complexity
    and make our code more readable. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have reduced the implementation of `fallOrBounce()` to checking whether
    we are about to hit our head or checking whether we are about to land on a platform.
    We choose between the two checks based on the value of `fallSpeed`. If `fallSpeed`
    is negative, then we are moving upwards and there is no need to check for landing
    at this point. Here is the implementation of `checkHead()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `checkHead()` method uses border-based collision detection (discussed in
    [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision Detection*)
    to detect exactly when the top of the object touches a platform. If `step` ends
    up being greater than `fallSpeed`, then no collision occurred and we can continue
    letting gravity affect our trajectory by calling `fall()`. If `step` is less than
    `fallSpeed`, then we hit our head on a platform and we need to handle bouncing
    off this platform by calling `handleBounce()`. Here is the implementation of `handleBounce()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This method handles a bounce by breaking it up into two main phases. The first
    phase handles the motion between the actor and the platform. The second phase
    handles travelling from the platform to the end location. The phases are shown
    in *Figure 4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bouncing](img/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: This shows the two main phases in handling a bounce. Phase 1 is the
    motion leading up to the impact and Phase 2 is the motion after impact'
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, we move the ball to the point of collision by setting `fallSpeed`
    to `step` and calling `fall(0)`. We will look at the implementation of `fall()`
    soon. For now, it is enough to know that `fall(0)` calls `setLocation()` to move
    the ball and updates `fallSpeed` by applying the affects of gravity. In the second
    phase of `handleBounce()`, we multiply by `0.7` in order to simulate the loss
    of energy that occurs in an impact. There is nothing magical or scientific about
    `0.7`. It just looked right when tested. We then move the remaining distance of
    our inertia (`step` – `oldFallSpeed`) by calling `fall(0)` again. The bounce has
    changed our falling direction, so the last thing we do is update `fallSpeed` to
    reflect this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we just used the `fall()` method, let us look at that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, `fall()` moves the actor using `setLocation()` according
    to its speed in the *x* direction and how fast it is falling. The instance variable
    `fallSpeed` is updated to account for the slowing (or accelerating) effects of
    gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only method left to complete the implementation of the `Ball` class is
    `checkLanding()`. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `checkLanding()` exactly mirrors the implementation of
    `checkHead()` except that it handles moving downwards instead of moving upwards.
  prefs: []
  type: TYPE_NORMAL
- en: Bouncing is a great effect and can be applied to a wide variety of actors. You
    could combine the implementation of bouncing with the implementation of jumping
    we discussed in the previous section and make a bouncing, jumping hero for your
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Particle effects work by creating a bunch of small actors to make an animation.
    Previously, you learned to do animations mainly by rapid image swapping. You could
    imagine creating a water fountain by creating 4-6 images of a fountain shooting
    upwards and switching between those images. Instead of doing that, we will create
    a fountain using a particle effect. Conveniently, you already have all the information
    you need to create particle effects. Particles are simply small actors that you
    assign a pattern of motion to. You then create a lot of them to provide the desired
    effect. We will do this to complete our implementation of the `Fountain` class.
    The only part of the implementation we left out was the code for the `createRedBallShower()`
    method. Here is that missing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The instance variable `lifespan` is a delay variable that we use to determine
    how long the fountain will exist. Once `lifespan` is less than zero, we remove
    this fountain from the scenario. Otherwise, we create `RedBall` anew with a random
    lifespan and rate of turn and speed. These parameters to the constructor of the
    `RedBall` class were discussed in the *Enemies* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating `RedBall` anew for every call of the `act()` method with slightly different
    attributes creates a really interesting fountain effect, as shown in *Figure 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Bullets and turrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already fully implemented bullets and turrets. The `Turret` class was
    complete and we finished the `Ball` class (our bullet) in the *Bouncing* section.
    What we will discuss here, are the basic steps to create a turret and a bullet
    and explain how what we have already done gives you the information you need to
    create a machine gun, cannon, tank, or other type of turret.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need a turret with an image. You can dynamically create the image
    just as we did in the `Turret` class, or you can set it using `setImage()`. Then,
    turrets only need to be rotated in the direction they are firing. That is what
    we did in the `generateBalls()` method in `CupcakeWorld`. Bullets are just actors
    that are rotated in a certain direction and then continually call `move()` to
    move in that direction. If you rotate the turret and bullet by the same angle,
    place the bullet at the same starting location as the turret, and let the bullet
    move forward, then it will appear as if the turret fired the bullet. Does this
    make sense? *Figure 5* summarizes this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bullets and turrets](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: These are the steps necessary to create a turret firing a bullet'
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, compile all of the code we just gave you and play Cupcake Counter for a
    while. You might start to notice why we started by having the platforms have some
    randomness to their placement. If we didn't, the player would quickly adapt to
    the falling patterns of the balls.
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment for this section, is to code another random variation in the
    game. You could further randomize the platforms, mess with the ball speed or size,
    or change the power of the player's jump.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a fairly functional game. We have a score, cool animations,
    collision detection, and levels in our game. After playing it, what would be the
    first thing you would improve? Let your friend play it. What did he/she think?
    Try to come up with a change that improves the game based on your experience playing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we designed our game so that it would be easy to add new rewards,
    enemies, and platforms. Add one of each to the game and add your own twist to
    them. For example, you could create a super cupcake that is worth five points
    but only lasts a short time. This will require the player to make some quick,
    meaningful decisions during the game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we did not create a full physics engine, we did go over some simple techniques
    to give actors interesting movement. Our discussion was focused on projectile-based
    movement and included bouncing, jumping, firing, and particle effects. Until now,
    we acquired a number of creative program techniques that enable us to create a
    wide variety of animations, simulations, and games. However, creating a fun interactive
    experience is not trivial. In the next chapter, we are going to learn about game
    design and a process for game development that will help us create amazing interactive
    experiences.
  prefs: []
  type: TYPE_NORMAL
