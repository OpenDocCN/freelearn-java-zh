<html><head></head><body><h1 id="e-raci">Chapter 4. Creating and Using Web APIs</h1>
<p id="e-ap3e">In this chapter, we will cover the following recipes:</p>
<ul id="e-tHbJ">
<li id="e-WGuH">Creating a <code>POST</code> API endpoint</li>
<li id="e-tPfO">Creating a <code>GET</code> API endpoint</li>
<li id="e-ltbx">Creating a <code>PUT</code> API endpoint</li>
<li id="e-GExF">Creating a <code>DELETE</code> API endpoint</li>
<li id="e-CquR">Securing API endpoints with HTTP basic authentication</li>
<li id="e-rJQG">Consuming external web APIs</li>
<li id="e-by5S">Using the Twitter API with OAuth</li>
</ul>
<h1 id="e-VhDs">Introduction</h1>
<p id="e-fOYz">In this chapter, we will look into creating REST APIs and interfacing with other external web-based APIs, in our case, the Twitter API.</p>
<p id="e-nYBS">With the increasing popularity of data exchanges between independent web services, REST APIs have become a popular approach not only to consume external data, but also to receive incoming data for further processing and persistence as well as exposing data to authorized clients. Based on the RESTful API spec, the HTTP method <code>POST</code> is used to insert new records and the HTTP method <code>GET</code> is used to retrieve data. The HTTP method <code>PUT</code> is used to update existing records and lastly, the HTTP method <code>DELETE</code> is used to remove records.</p>
<p id="e-D2fP">We will see how we can utilize different Play 2.0 libraries to build our own REST API endpoints and access other web-based APIs using the new Play WS library.</p>

<h1 id="e-gD7v">Creating a POST API endpoint</h1>
<p id="e-oC2L">In this recipe, we will explore how to use Play 2.0 to create a RESTful <code>POST</code> endpoint to add new records to our API.</p>
<h2 id="e-n4mW">How to do it…</h2>
<p id="e-oSxP">For Java, we need to perform the following steps:</p>
<ol id="e-CSp5">
<li id="e-UlnZ">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-y5zz">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Av8O">Create a new products controller in <code>foo_java/app/controllers/Products.java</code> with the following content:<pre id="e-DOWh">package controllers;
     import java.util.*;
    import play.data.Form;
    import play.mvc.*;
    import models.Product;
    import static play.libs.Json.toJson;
     public class Products extends Controller {
        public static Map&amp;lt;String, Product&amp;gt; products = new HashMap&amp;lt;String, Product&amp;gt;();
         @BodyParser.Of(BodyParser.Json.class)
        public static Result create() {
            try {
                Form&amp;lt;Product&amp;gt; form = Form.form(Product.class).bindFromRequest();
                 if (form.hasErrors()) {
                    return badRequest(form.errorsAsJson());
                } else {
                    Product product = form.get();
                    products.put(product.getSku(), product);
                    return created(toJson(product));
                }
             } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
    }</pre>
</li>
<li id="e-lfWN">Create a product model class in <code>foo_java/app/models/Product.java</code>:<pre id="e-WYe2">package models;
     import play.data.validation.Constraints;
     public class Product implements java.io.Serializable {
        @Constraints.Required
        private String sku;
         @Constraints.Required
        private String title;
         public String getSku() {
            return sku;
        }
        public void setSku(String sku) {
            this.sku = sku;
        }
        public String getTitle() {
            return title;
        }
        public void setTitle(String title) {
            this.title = title;
        }
    }</pre>
</li>
<li id="e-lzxm">Add a new route entry for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-wpNo">POST    /api/products       controllers.Products.create</pre>
</li>
<li id="e-nqP2">Request the new route and examine the response body to confirm:<pre id="e-Rs9u">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST http://localhost:9000/api/products --data '{"sku":"abc",   "title":"Macbook Pro Retina"}' --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 43&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 43 out of 43 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 42&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"sku":"abc","title":"Macbook Pro Retina"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-YSQB">For Scala, we need to perform the following steps:</p>
<ol id="e-TEIX">
<li id="e-Fk4l">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-IXer">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Mvra">Create a new products controller in <code>foo_scala/app/controllers/Products.scala</code> with the following content:<pre id="e-TEaW">package controllers
     import models.Product
    import play.api.libs.json.{JsError, Json}
    import play.api.libs.json.Json._
    import play.api.mvc._
     object Products extends Controller {
      implicit private val productWrites = Json.writes[Product]
      implicit private val productReads = Json.reads[Product]
      private val products: scala.collection.mutable.ListBuffer[Product] = scala.collection.mutable.ListBuffer[Product]()
       def create = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        val post = request.body.validate[Product]
        post.fold(
          errors =&amp;gt; BadRequest(Json.obj("message" -&amp;gt; JsError.toFlatJson(errors))),
          p =&amp;gt; {
            try {
              products += p
              Created(Json.toJson(p))
            } catch {
              case e: Exception =&amp;gt; InternalServerError(e.getMessage)
            }
          }
        )
      }
    }</pre>
</li>
<li id="e-LJ8o">Create a product model class in <code>foo_scala/app/models/Product.scala</code>:<pre id="e-Hm8n">package models
     case class Product(sku: String, title: String)</pre>
</li>
<li id="e-wtxp">Add a new route entry for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-uBHi">POST    /api/products       controllers.Products.create</pre>
</li>
<li id="e-wnOL">Request the new route and examine the response body to confirm:<pre id="e-Npsp">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST http://localhost:9000/api/products --data '{"sku":"abc",   "title":"Macbook Pro Retina"}' --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 43&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 43 out of 43 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 42&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"sku":"abc","title":"Macbook Pro Retina"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-ptNP">How it works…</h2>
<p id="e-CFew">In this recipe, we implemented a RESTful <code>POST</code> request using Play 2.0. The first step was to create our controller and model classes. For the model class, we declared two basic fields for a product. We annotated them as required fields. This allows Play to validate these two fields when a product is bound to a request body.</p>
<pre id="e-qfF8">// Java 
    @Constraints.Required
    private String sku;</pre>
<p id="e-G4dG">As for a Scala equivalent of enforcing required request parameters, we declare optional parameters using the <code>scala.Option</code> class. In this recipe though, to keep the Java and Scala recipes consistent, it will be unnecessary to use <code>scala.Option</code> and we will enforce required fields in our case class like so:</p>
<pre id="e-tSFg">case class Product(sku: String, title: String)</pre>
<p id="e-rief">We then created an action method that will handle the product <code>POST</code> request in the controller class. We ensure that there aren't any validation errors encountered by the <code>play.data.Form</code> object during data binding; however, if it does encounter an issue, it will return an HTTP Status 400 wrapped by the <code>badRequest()</code> helper:</p>
<pre id="e-GPqN">// Java 
    if (form.hasErrors()) {
        return badRequest(form.errorsAsJson());
    }
     // Scala 
    errors =&amp;gt; BadRequest(Json.obj("message" -&amp;gt; JsError.toFlatJson(errors))),</pre>
<p id="e-ZItu">If no errors are encountered, we proceed to persisting our new product and returning an HTTP Status 201 wrapped by the <code>created()</code> helper:</p>
<pre id="e-emBu">// Java 
    return created(toJson(product));
     // Scala 
    Created(Json.toJson(p))</pre>
<p id="e-xU75">We then declared our new <code>POST</code> route in the <code>conf/routes</code> file. Finally, we used the command-line tool, <code>curl</code>, to simulate the HTTP <code>POST</code> request to test our route. To verify that our endpoint does execute the <code>POST</code> form field validations, omit the title parameter from the previous <code>curl</code> command and you will see the appropriate error message:</p>
<pre id="e-YRgA">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST http://localhost:9000/api/products --data '{"sku":"abc"}' --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 44&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 44 out of 44 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 400 Bad Request&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 36&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"title":["This field is required"]}%&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-aO1b">Creating a GET API endpoint</h1>
<p id="e-DEJF">For this recipe, we will create the RESTful <code>GET</code> endpoint, which will return a collection of JSON objects.</p>
<h2 id="e-mvs3">How to do it…</h2>
<p id="e-nYOY">For Java, we need to perform the following steps:</p>
<ol id="e-DoHP">
<li id="e-NspM">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-Mxix">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-hHbj">Modify the products controller in <code>foo_java/app/controllers/Products.java</code> by adding the following action method:<pre id="e-iOUG">public static Result index() {
        return ok(toJson(products));
    }</pre>
</li>
<li id="e-hdrr">Add a new route entry for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-VFvA">GET     /api/products       controllers.Products.index</pre>
</li>
<li id="e-DH0w">Request the new route and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-v4Rn">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 50&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"abc":{"sku":"abc","title":"Macbook Pro Retina"},"def":{"sku":"def","title":"iPad Air"}}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-LQsU">For Scala, we need to perform the following steps:</p>
<ol id="e-asbg">
<li id="e-JVXw">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-euR5">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-bNGk">Modify the product controller in <code>foo_scala/app/controllers/Products.scala</code> by adding the following action method:<pre id="e-xP4r">def index = Action {
      Ok(toJson(products))
    }</pre>
</li>
<li id="e-FGjR">Add a new route entry for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-GozD">&lt;span class="strong"&gt;&lt;strong&gt;    GET     /api/products       controllers.Products.index&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-KRZG">Request our new route and examine the response headers to confirm our modifications to the HTTP response header:<pre id="e-rHbS">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 50&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"abc":{"sku":"abc","title":"Macbook Pro Retina"},"def":{"sku":"def","title":"iPad Air"}}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-gq4R">How it works…</h2>
<p id="e-fJ2f">In this recipe, we implemented an API endpoint that returns a listing of product records. We were able to implement this by declaring a new action method that retrieves records from our data store, converts objects to JSON, and returns a JSON collection:</p>
<pre id="e-TIGa">// Java 
    return ok(toJson(products));
     // Scala 
    Ok(toJson(products))</pre>
<p id="e-WbJA">We then declared a new route entry for the <code>GET</code> endpoint and used <code>curl</code> to verify the endpoints' functionality.</p>
<p id="e-cVza">The endpoint will return an empty JSON array in the case of an empty data store:</p>
<pre id="e-ohK9">&lt;span class="strong"&gt;&lt;strong&gt;    # Empty product list  &lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    []%&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-uHOH">Creating a PUT API endpoint</h1>
<p id="e-kUCB">In this recipe, we will implement a RESTful <code>PUT</code> API endpoint using Play 2.0 to update an existing record in our data store.</p>
<h2 id="e-eihz">How to do it…</h2>
<p id="e-fFVp">For Java, we need to perform the following steps:</p>
<ol id="e-tHtK">
<li id="e-LMhV">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-rqsi">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-lg3u">Modify <code>foo_java/app/controllers/Products.java</code> by adding the following action:<pre id="e-FCLL">@BodyParser.Of(BodyParser.Json.class)
    public static Result edit(String id) {
        try {
            Product product = products.get(id);
             if (product != null) {
                Form&amp;lt;Product&amp;gt; form = Form.form(Product.class).bindFromRequest();
                if (form.hasErrors()) {
                    return badRequest(form.errorsAsJson());
                } else {
                    Product productForm = form.get();
                    product.setTitle(productForm.getTitle());
                    products.put(product.getSku(), product);
                     return ok(toJson(product));
                }
            } else {
                return notFound();
            }
        } catch (Exception e) {
            return internalServerError(e.getMessage());
        }
    }</pre>
</li>
<li id="e-lSHN">Add a new route for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-Cjl0">PUT     /api/products/:id   controllers.Products.edit(id: String)</pre>
</li>
<li id="e-dqWc">Using <code>curl</code>, we will update an existing product in our data store:<pre id="e-lc1G">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X PUT http://localhost:9000/api/products/def --data '{"sku":"def", "title":"iPad 3 Air"}' --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; PUT /api/products/def HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 35&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 35 out of 35 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 34&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"sku":"def","title":"iPad 3 Air"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-GkNR">For Scala, we need to perform the following steps:</p>
<ol id="e-imVW">
<li id="e-OIPG">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-ySfy">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-zMSx">Modify <code>foo_scala/app/controllers/Products.scala</code> by adding the following action:<pre id="e-A0b3">def edit(id: String) = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
      val post = request.body.validate[Product]
      post.fold(
        errors =&amp;gt; BadRequest(Json.obj("message" -&amp;gt; JsError.toFlatJson(errors))),
        p =&amp;gt; {
          products.find(_.sku equals id) match {
            case Some(product) =&amp;gt; {
              try {
                products -= product
                products += p
                 Ok(Json.toJson(p))
              } catch {
                case e: Exception =&amp;gt; InternalServerError(e.getMessage)
              }
            }
            case None =&amp;gt; NotFound
          }
        }
      )
    }</pre>
</li>
<li id="e-ejh7">Add a new route for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-QvU3">PUT     /api/products/:id   controllers.Products.edit(id: String)</pre>
</li>
<li id="e-pqKX">Using <code>curl</code>, we will update an existing product in our data store:<pre id="e-eepN">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X PUT http://localhost:9000/api/products/def --data '{"sku":"def", "title":"iPad 3 Air"}' --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; PUT /api/products/def HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 35&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 35 out of 35 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 34&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"sku":"def","title":"iPad 3 Air"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-nYoq">How it works…</h2>
<p id="e-Ae9V">In this recipe, we created a new URL route and action that will update an existing record in our data store. We added a new action to the products controller class and declared a new route for it in <code>conf/routes</code>. In our <code>edit</code> action, we declared that the action is to expect a request body in JSON format:</p>
<pre id="e-i75g">// Java
    @BodyParser.Of(BodyParser.Json.class)
     // Scala
    def edit(id: String) = Action(BodyParsers.parse.json) { implicit request =&amp;gt;</pre>
<p id="e-WIzr">We check whether the ID value that is passed is valid by doing a lookup in our data store. We send an HTTP status 404 for invalid IDs:</p>
<pre id="e-rIac">// Java 
    return notFound();
     // Scala 
    case None =&amp;gt; NotFound</pre>
<p id="e-SCsE">We also check for any form validation errors and will return the appropriate status code in the event of errors:</p>
<pre id="e-cL9v">// Java 
    if (form.hasErrors()) {
      return badRequest(form.errorsAsJson());
    }
     // Scala 
    errors =&amp;gt; BadRequest(Json.obj("message" -&amp;gt; JsError.toFlatJson(errors))),</pre>
<p id="e-ihJH">Finally, we used <code>curl</code> to test the new product <code>PUT</code> action. We can further validate the <code>PUT</code> endpoint by testing how it handles invalid IDs and and invalid request bodies:</p>
<pre id="e-zNk0">&lt;span class="strong"&gt;&lt;strong&gt;# Passing an invalid Product ID:&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;$ curl -v -X PUT http://localhost:9000/api/products/XXXXXX&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; PUT /api/products/XXXXXX HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 404 Not Found&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;# PUT requests with form validation error&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;$ curl -v -X PUT http://localhost:9000/api/products/def --data '{}'  --header "Content-type: application/json"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;*   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; PUT /api/products/def HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt; Content-Length: 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* upload completely sent off: 2 out of 2 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; HTTP/1.1 400 Bad Request&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt; Content-Length: 69&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;* Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"title":["This field is required"],"sku":["This field is required"]}%&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-bPxd">Creating a DELETE API endpoint</h1>
<p id="e-WKVO">In this recipe, we will implement a RESTful <code>DELETE</code> API endpoint to remove a record from our data store.</p>
<h2 id="e-kzsH">How to do it…</h2>
<p id="e-DPAo">For Java, we need to perform the following steps:</p>
<ol id="e-ztSN">
<li id="e-JRtP">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-PwHf">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-vzW8">Modify <code>foo_java/app/controllers/Products.java</code> by adding the following action:<pre id="e-Fo5V">public static Result delete(String id) {
        try {
            Product product = products.get(id);
             if (product != null) {
                products.remove(product);
                 return noContent();
            } else {
                return notFound();
            }
        } catch (Exception e) {
            return internalServerError(e.getMessage());
        }
    }</pre>
</li>
<li id="e-ESjI">Add a new route for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-p9IQ">DELETE  /api/products/:id   controllers.Products.delete(id: String)</pre>
</li>
<li id="e-Oj60">Using <code>curl</code>, remove an existing record, as follows:<pre id="e-EcIH">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X DELETE http://localhost:9000/api/products/def&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; DELETE /api/products/def HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 204 No Content&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-MNX9">For Scala, we need to perform the following steps:</p>
<ol id="e-rpbJ">
<li id="e-FCr7">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-BFns">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-dPdj">Modify <code>foo_scala/app/controllers/Products.scala</code> by adding the following action:<pre id="e-uPi6">def delete(id: String) = BasicAuthAction {
    products.find(_.sku equals id) match {
      case Some(product) =&amp;gt; {
        try {
          products -= product
          NoContent
        } catch {
          case e: Exception =&amp;gt; InternalServerError(e.getMessage)
        }
      }
      case None =&amp;gt; NotFound
    }
  }</pre>
</li>
<li id="e-kXrE">Add a new route for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-gJbg">DELETE  /api/products/:id   controllers.Products.delete(id: String)</pre>
</li>
<li id="e-EOFh">Using <code>curl</code>, remove an existing record as shown here:<pre id="e-N9w3">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X DELETE http://localhost:9000/api/products/def&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; DELETE /api/products/def HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 204 No Content&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-SkWJ">How it works…</h2>
<p id="e-BTI3">In this recipe, we created a new URL route and action that is used to remove an existing product record. We declared the <code>delete</code> action to look up the record by the ID parameter passed in. We ensure that the the appropriate HTTP status code is returned in the event of an invalid ID, in this case, HTTP status code 404:</p>
<pre id="e-dvFW">// Java 
    return notFound();
     // Scala 
    case None =&amp;gt; NotFound</pre>
<p id="e-kI4w">We then ensure that the appropriate HTTP status code for successful record removal is returned, in this case, HTTP status code 204:</p>
<pre id="e-dJhK">// Java 
    return noContent();
     // Scala 
    NoContent</pre>
<p id="e-D749">We can also test the <code>DELETE</code> endpoint and verify that it handles invalid IDs correctly:</p>
<pre id="e-Ew0J">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X DELETE http://localhost:9000/api/products/XXXXXX&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; DELETE /api/products/asd HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 404 Not Found&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-flll">Securing API endpoints with HTTP basic authentication</h1>
<p id="e-Ijrd">In this recipe, we will explore how to secure API endpoints using the HTTP basic authentication scheme with Play 2.0. We will use the Apache Commons Codec library for Base64 encoding and decoding for this recipe. This dependency is implicitly imported by Play and we will not need to explicitly declare it to our library dependencies in <code>build.sbt</code>.</p>
<h2 id="e-rCcx">How to do it…</h2>
<p id="e-yN8X">For Java, we need to perform the following steps:</p>
<ol id="e-UAys">
<li id="e-rybz">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-E78h">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-cgFz">Create a new <code>play.mvc.Security.Authenticator</code> implementation class in <code>foo_java/app/controllers/BasicAuthenticator.java</code> with the following content:<pre id="e-txxG">package controllers;
     import org.apache.commons.codec.binary.Base64;
    import play.mvc.Http;
    import play.mvc.Result;
    import play.mvc.Security;
     public class BasicAuthenticator extends Security.Authenticator {
        private static final String AUTHORIZATION = "authorization";
        private static final String WWW_AUTHENTICATE = "WWW-Authenticate";
        private static final String REALM = "Basic realm=\"API Realm\"";
         @Override
        public String getUsername(Http.Context ctx) {
            try {
                String authHeader = ctx.request().getHeader(AUTHORIZATION);
                 if (authHeader != null) {
                    ctx.response().setHeader(WWW_AUTHENTICATE, REALM);
                    String auth = authHeader.substring(6);
                    byte[] decodedAuth = Base64.decodeBase64(auth);
                    String[] credentials = new String(decodedAuth, "UTF-8").split(":");
                     if (credentials != null &amp;amp;&amp;amp; credentials.length == 2) {
                        String username = credentials[0];
                        String password = credentials[1];
                        if (isAuthenticated(username, password)) {
                            return username;
                        } else {
                            return null;
                        }
                    }
                }
                return null;
             } catch (Exception e) {
                return null;
            }
        }
        private boolean isAuthenticated(String username, String password) {
            return username != null &amp;amp;&amp;amp; username.equals("ned") &amp;amp;&amp;amp;
                password != null &amp;amp;&amp;amp; password.equals("flanders");
        }
         @Override
        public Result onUnauthorized(Http.Context context) {
            return unauthorized();
        }
    }</pre>
</li>
<li id="e-uSRq">Modify <code>foo_java/app/controllers/Products.java</code> by adding the following annotation to the API actions:<pre id="e-wgav">&lt;span class="strong"&gt;&lt;strong&gt;    @Security.Authenticated(BasicAuthenticator.class)&lt;/strong&gt;&lt;/span&gt;
    public static Result create() 
 &lt;span class="strong"&gt;&lt;strong&gt;    @Security.Authenticated(BasicAuthenticator.class)&lt;/strong&gt;&lt;/span&gt;
    public static Result index() 
 &lt;span class="strong"&gt;&lt;strong&gt;    @Security.Authenticated(BasicAuthenticator.class)&lt;/strong&gt;&lt;/span&gt;
    public static Result edit(String id)
 &lt;span class="strong"&gt;&lt;strong&gt;    @Security.Authenticated(BasicAuthenticator.class)&lt;/strong&gt;&lt;/span&gt;
    public static Result delete(String id)</pre>
</li>
<li id="e-XZhZ">Using <code>curl</code>, send a request to the existing RESTful <code>GET</code> endpoint as we did earlier; you will now see an unauthorized response:<pre id="e-Rvf5">&lt;span class="strong"&gt;&lt;strong&gt;    $  curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying 127.0.0.1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (127.0.0.1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-k2XY">Using <code>curl</code> again, send another request to the existing RESTful <code>GET</code> endpoint, this time with the user credentials, <code>ned</code> (username) and <code>flanders</code> (password):<pre id="e-wknC">&lt;span class="strong"&gt;&lt;strong&gt;    $  curl -v -u "ned:flanders" http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying 127.0.0.1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (127.0.0.1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Server auth using Basic with user 'ned'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Basic bmVkOmZsYW5kZXJz&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; WWW-Authenticate: Basic realm="API Realm"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-S4ay">For Scala, we need to perform the following steps:</p>
<ol id="e-pVbP">
<li id="e-aNly">Run <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-QZya">activator "~run"</pre>
</li>
<li id="e-Kc07">Create a new <code>ActionBuilder</code> class in <code>foo_scala/app/controllers/BasicAuthAction.scala</code> with the following content:<pre id="e-VbAX">package controllers
     import controllers.Products._
    import org.apache.commons.codec.binary.Base64
    import play.api.mvc._
    import scala.concurrent.Future
     object BasicAuthAction extends ActionBuilder[Request] {
      def invokeBlock[A](request: Request[A], block: (Request[A]) =&amp;gt; Future[Result]) = {
        try {
          request.headers.get("authorization") match {
            case Some(headers) =&amp;gt; {
              val auth = headers.substring(6)
              val decodedAuth = Base64.decodeBase64(auth)
              val credentials = new String(decodedAuth, "UTF-8").split(":")
               if (credentials != null &amp;amp;&amp;amp; credentials.length == 2 &amp;amp;&amp;amp;
                  isAuthenticated(credentials(0), credentials(1))) {
                block(request)
              } else {
                unauthorized
              }
            }
            case None =&amp;gt; unauthorized
          }
        } catch {
          case e: Exception =&amp;gt; Future.successful(InternalServerError(e.getMessage))
        }
      }
       def unauthorized = Future.successful(Unauthorized.withHeaders("WWW-Authenticate" -&amp;gt; "Basic realm=\"API Realm\""))
       def isAuthenticated(username: String, password: String) = username != null &amp;amp;&amp;amp; username.equals("ned") &amp;amp;&amp;amp; password != null &amp;amp;&amp;amp; password.equals("flanders")
    }</pre>
</li>
<li id="e-YqQ7">Modify <code>foo_scala/app/controllers/Products.scala</code> by adding the newly created <code>ActionBuilder</code> class with the API actions instead:<pre id="e-ociF">def index = BasicAuthAction 
     def create = BasicAuthAction(BodyParsers.parse.json)
     def edit(id: String) = BasicAuthAction(BodyParsers.parse.json)
     def delete(id: String) = BasicAuthAction</pre>
</li>
<li id="e-ZTII">Using <code>curl</code>, send a request to the existing RESTful <code>GET</code> endpoint as we did earlier; you will now see an unauthorized response:<pre id="e-LakO">&lt;span class="strong"&gt;&lt;strong&gt;    $  curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying 127.0.0.1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (127.0.0.1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;  &lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-VyHi">Using <code>curl</code> again, send another request to the existing RESTful <code>GET</code> endpoint, this time with the user credentials, <code>ned</code> (username) and <code>flanders</code> (password):<pre id="e-Hrpo">&lt;span class="strong"&gt;&lt;strong&gt;    $  curl -v -u "ned:flanders" http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying 127.0.0.1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (127.0.0.1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Server auth using Basic with user 'ned'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Basic bmVkOmZsYW5kZXJz&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-WGXh">How it works…</h2>
<p id="e-sPn9">In this recipe, we secured the RESTful API endpoints using the HTTP basic authentication scheme with Play 2.0. We created the respective security implementation class for both Java and Scala. For each security implementation class, <code>BasicAuthenticator.java</code> and <code>BasicAuthAction.scala</code>, we retrieved the authorization header and decoded the value string to decrypt the user credentials that we passed in:</p>
<pre id="e-pTm4">// Java
    String authHeader = ctx.request().getHeader(AUTHORIZATION);
    if (authHeader != null) {
        ctx.response().setHeader(WWW_AUTHENTICATE, REALM);
        String auth = authHeader.substring(6);
        byte[] decodedAuth = Base64.decodeBase64(auth);
        String[] credentials = new String(decodedAuth, "UTF-8").split(":");
    }
     // Scala 
    request.headers.get("authorization") match {
        case Some(headers) =&amp;gt; {
          val auth = headers.substring(6)
          val decodedAuth = Base64.decodeBase64(auth)
          val credentials = new String(decodedAuth, "UTF-8").split(":")
        }
    }</pre>
<p id="e-FuJC">Once we got the username and password, we invoked the <code>isAuthenticated</code> function to check the validity of the user credentials:</p>
<pre id="e-moig">// Java
    if (credentials != null &amp;amp;&amp;amp; credentials.length == 2) {
     String username = credentials[0];
        String password = credentials[1];
        if (isAuthenticated(username, password)) {
            return username;
        } else {
            return null;
        }
    }
     // Scala
    if (credentials != null &amp;amp;&amp;amp; credentials.length == 2 &amp;amp;&amp;amp;
          isAuthenticated(credentials(0), credentials(1))) {
        block(request)
    } else {
        unauthorized
    }</pre>
<p id="e-w4Yg">We then utilized the security implementation classes by annotating the Java API actions and declaring it as the API action class:</p>
<pre id="e-qAwD">// Java
    @Security.Authenticated(BasicAuthenticator.class)
    public static Result index() {
        return ok(toJson(products));
    }
     // Scala 
    def index = BasicAuthAction {
        Ok(toJson(products))
    }</pre>
<p id="e-CSig">Using <code>curl</code>, we can also check whether our secure API actions handle unauthenticated requests:</p>
<pre id="e-b1mj">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/api/products&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /api/products HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; WWW-Authenticate: Basic realm="API Realm"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-z1Vy">Consuming external web APIs</h1>
<p id="e-IDZF">In this recipe, we will explore the Play WS API to consume external web services from a Play 2 web application. As web application requirements evolve, we become more dependent on external data services for data such as foreign exchange rates, real-time weather data, and so on. The Play WS library provides us with APIs to be able to interface with external web services.</p>
<h2 id="e-XKnW">How to do it…</h2>
<p id="e-i7nl">For Java, we need to perform the following steps:</p>
<ol id="e-QgBf">
<li id="e-grZW">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-Rd7k">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-KY4x">Declare <code>playWs</code> as a project dependency in <code>build.sbt</code>:<pre id="e-dm7s">libraryDependencies ++= Seq(
        javaWs
    )</pre>
</li>
<li id="e-lU6L">Create a new controller in <code>foo_java/app/controllers/WebClient.java</code> and add the following content:<pre id="e-DIgY">package controllers;
     import com.fasterxml.jackson.databind.JsonNode;
    import play.libs.F;
    import play.libs.F.Promise;
    import play.libs.ws.WS;
    import play.mvc.Controller;
    import play.mvc.Result;
     public class WebClient extends Controller {
        public static Promise&amp;lt;Result&amp;gt; getTodos() {
            Promise&amp;lt;play.libs.ws.WSResponse&amp;gt; todos = WS.url("http://jsonplaceholder.typicode.com/todos").get();
            return todos.map(
                new F.Function&amp;lt;play.libs.ws.WSResponse, Result&amp;gt;() {
                    public Result apply(play.libs.ws.WSResponse res) {
                        JsonNode json = res.asJson();
                        return ok("Todo Title: " + json.findValuesAsText("title"));
                    }
                }
            );
        }
    }</pre>
</li>
<li id="e-lO0T">Add a new route entry for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-hQ2g">GET     /client/get_todos   controllers.WebClient.getTodos</pre>
</li>
<li id="e-RpeD">Using <code>curl</code>, we will be able to test how our new action is able to consume an external web API:<pre id="e-qGym">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/client/get_todos&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /client/get_todos HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 8699&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Todo Title: [delectus aut autem, quis ut nam facilis et officia qui, fugiat veniam minus, et porro tempora, laboriosam mollitia et enim quasi adipisci quia provident illum, qui ullam ratione quibusdam voluptatem quia omnis, illo expedita&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-wCRX">For Scala, we need to perform the following steps:</p>
<ol id="e-FQ1u">
<li id="e-n0zM">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-WLt6">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-wfZZ">Declare <code>playWs</code> as a project dependency in <code>build.sbt</code>:<pre id="e-UAje">libraryDependencies ++= Seq(
        ws
    )</pre>
</li>
<li id="e-nOPa">Create a new controller in <code>foo_scala/app/controllers/WebClient.scala</code> and add the following content:<pre id="e-xS4g">package controllers
     import play.api.libs.concurrent.Execution.Implicits.defaultContext
    import play.api.Play.current
    import play.api.libs.ws.WS
    import play.api.mvc.{Action, Controller}
     object WebClient extends Controller {
      def getTodos = Action.async {
        WS.url("http://jsonplaceholder.typicode.com/todos").get().map { res =&amp;gt;
          Ok("Todo Title: " + (res.json \\ "title").map(_.as[String]))
        }
      }
    }</pre>
</li>
<li id="e-a1AJ">Add a new route entry for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-cYVF">GET     /client/get_todos   controllers.WebClient.getTodos</pre>
</li>
<li id="e-B1LD">Using <code>curl</code>, we will be able to test how our new action is able to consume an external web API:<pre id="e-YODM">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/client/get_todos&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /client/get_todos HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 8699&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Todo Title: [delectus aut autem, quis ut nam facilis et officia qui, fugiat veniam minus, et porro tempora, laboriosam mollitia et enim quasi adipisci quia provident illum, qui ullam ratione quibusdam voluptatem quia omnis, illo expedita&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-R4bw">How it works…</h2>
<p id="e-pKHb">In this recipe, we utilized the Play 2.0 plugin, WS, to consume an external web API. We created a new route and <code>AsynchronousAction</code> method. In the action, we passed the external API's URL into the WS api and specified that it will be a <code>GET</code> operation:</p>
<pre id="e-cdmH">// Java  
    Promise&amp;lt;play.libs.ws.WSResponse&amp;gt; todos = WS.url("http://jsonplaceholder.typicode.com/todos").get();
    // Scala 
WS.url("http://jsonplaceholder.typicode.com/todos").get()</pre>
<p id="e-VFa5">We then parsed the JSON response and piped it into the resulting response of the newly created route, <code>/client/get_todos</code>:</p>
<pre id="e-DtWd">// Java 
    return todos.map(
      new F.Function&amp;lt;play.libs.ws.WSResponse, Result&amp;gt;() {
        public Result apply(play.libs.ws.WSResponse res) {
          JsonNode json = res.asJson();
          return ok("Todo Title: " + json.findValuesAsText("title"));
        }
      }
    );
     // Scala 
    Ok("Todo Title: " + (res.json \\ "title").map(_.as[String]))</pre>

<h1 id="e-Esnt">Using the Twitter API and OAuth</h1>
<p id="e-DAYc">In this recipe, we will explore how we can use the built-in support of Play 2.0 for OAuth to retrieve tweets from the Twitter API.</p>
<h2 id="e-WXgX">How to do it…</h2>
<p id="e-JywI">For Java, we need to perform the following steps:</p>
<ol id="e-FppC">
<li id="e-QWla">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-Gg3H">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-jnym">Specify your Twitter API information in <code>foo_java/conf/application.conf</code>:<pre id="e-JrCI">tw.consumerKey="YOUR TWITTER DEV CONSUMER KEY HERE"
    tw.consumerSecret="YOUR TWITTER DEV CONSUMER SECRET HERE"
    tw.accessToken="YOUR TWITTER DEV ACCESS TOKEN HERE"
    tw.accessTokenSecret="YOUR TWITTER DEV ACCESS TOKEN SECRET HERE"</pre>
</li>
<li id="e-D1cP">Modify the <code>WebClient</code> controller in <code>foo_java/app/controllers/WebClient.java</code> with the following action:<pre id="e-hA3m">// Add additional imports at the top section of the class file 
    import play.Play;
    import play.libs.oauth.OAuth;
    import play.libs.oauth.OAuth.OAuthCalculator;
    import play.libs.ws.WSResponse;
    import java.util.HashMap;
    import java.util.Iterator;
    import java.util.Map;
     // Add the Action method
    public static Promise&amp;lt;Result&amp;gt; getTweets(String hashtag) {
        final String url = "https://api.twitter.com/1.1/search/tweets.json?q=%40" + hashtag;
        final OAuth.ConsumerKey consumerInfo = new OAuth.ConsumerKey(
            Play.application().configuration().getString("tw.consumerKey"),
            Play.application().configuration().getString("tw.consumerSecret")
        );
        final OAuth.RequestToken tokens = new OAuth.RequestToken(
            Play.application().configuration().getString("tw.accessToken"),
            Play.application().configuration().getString("tw.accessTokenSecret")
        );
         Promise&amp;lt;play.libs.ws.WSResponse&amp;gt; twRequest = WS.url(url).sign(new OAuthCalculator(consumerInfo, tokens)).get();
        return twRequest.map(
            new F.Function&amp;lt;WSResponse, Result&amp;gt;(){
                @Override
                public Result apply(WSResponse res) throws Throwable {
                    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
                    JsonNode root = res.asJson();
                     for (JsonNode json : root.get("statuses")) {
                        map.put(
         json.findValue("user").findValue("screen_name").asText(),
                            json.findValue("text").asText()
                        );
                    }
                     return ok(views.html.tweets.render(map));
                }
            }
        );
    }</pre>
</li>
<li id="e-yAxN">Add the new route for the <code>getTweets(hashtag: String)</code> action to <code>foo_java/conf/routes</code>:<pre id="e-j81D">GET /client/get_tweets/:hashtag controllers.WebClient.getTweets(hashtag)</pre>
</li>
<li id="e-q1et">Add a new view template in <code>foo_java/app/views/tweets.scala.html</code> with the following content:<pre id="e-qQzD">@(tweets: Map[String, String])
     &amp;lt;ul&amp;gt;
      @tweets.map { tw =&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;@@@tw._1&amp;lt;/strong&amp;gt; says &amp;lt;i&amp;gt;"@tw._2"&amp;lt;/i&amp;gt;&amp;lt;/li&amp;gt;
      }
    &amp;lt;/ul&amp;gt;</pre>
</li>
<li id="e-iBI2">Using a web browser, access the <code>/client/get_tweets/:hashtag</code> route to view tweets retrieved from the Twitter API:<img data-width="800" data-height="426" src="gqMspVre.jpg"/>
</li>
</ol>
<p id="e-g27I">For Scala, we need to perform the following steps:</p>
<ol id="e-yWWE">
<li id="e-ALpL">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-uzv5">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-j2ak">Specify your Twitter API information in <code>foo_scala/conf/application.conf</code>:<pre id="e-h7zj">tw.consumerKey="YOUR TWITTER DEV CONSUMER KEY HERE"
    tw.consumerSecret="YOUR TWITTER DEV CONSUMER SECRET HERE"
    tw.accessToken="YOUR TWITTER DEV ACCESS TOKEN HERE"
    tw.accessTokenSecret="YOUR TWITTER DEV ACCESS TOKEN SECRET HERE"</pre>
</li>
<li id="e-Nw4a">Modify the <code>WebClient</code> controller in <code>foo_scala/app/controllers/WebClient.scala</code> with the following action:<pre id="e-p3UX">def getTweets(hashtag: String) = Action.async {
      import play.api.Play
       val consumerInfo = ConsumerKey(
        Play.application.configuration.getString("tw.consumerKey").get,
        Play.application.configuration.getString("tw.consumerSecret").get
      )
      val tokens = RequestToken(
        Play.application.configuration.getString("tw.accessToken").get,
        Play.application.configuration.getString("tw.accessTokenSecret").get
      )
      val url = "https://api.twitter.com/1.1/search/tweets.json?q=%40" + hashtag
       WS.url(url).sign(OAuthCalculator(consumerInfo, tokens)).get().map { res =&amp;gt;
        val tweets = ListBuffer[(String, String)]()
        (res.json \ "statuses").as[List[JsObject]].map { tweet =&amp;gt;
          tweets += ((
            (tweet \ "user" \ "screen_name").as[String],
            (tweet \ "text").as[String]
          ))
        }
         Ok(views.html.tweets(tweets.toList))
      }
    }</pre>
</li>
<li id="e-or3p">Add the new routes for the <code>getTweets(hashtag: String)</code> action in <code>foo_scala/conf/routes</code>:<pre id="e-My2h">GET /client/get_tweets/:hashtag controllers.WebClient.getTweets(hashtag)</pre>
</li>
<li id="e-lTYK">Add a new view template in <code>foo_scala/app/views/tweets.scala.html</code> with the following content:<pre id="e-VC9C">@(tweets: List[(String, String)])
     &amp;lt;ul&amp;gt;
      @tweets.map { tw =&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;@@@tw._1&amp;lt;/strong&amp;gt; says &amp;lt;i&amp;gt;"@tw._2"&amp;lt;/i&amp;gt;&amp;lt;/li&amp;gt;
      }
    &amp;lt;/ul&amp;gt;</pre>
</li>
<li id="e-RZoB">Using a web browser, access the <code>/client/get_tweets/:hashtag</code> route to view tweets retrieved from the Twitter API, as shown in the following screenshot:<img data-width="800" data-height="526" src="FmkrgheD.jpg"/>
</li>
</ol>
<h2 id="e-DQbt">How it works...</h2>
<p id="e-GFVi">In this recipe, we created a new URL route and action to retrieve and display Tweets by the hashtag specified in the request route, <code>/client/get_tweets/:hashtag</code>. We implemented the action method by retrieving the required Twitter API consumer and access token keys from <code>conf/application.conf</code> (remember to register for a Twitter Dev account at <a href="http://dev.twitter.com">http://dev.twitter.com</a> and generate your consumer and access tokens for this recipe):</p>
<pre id="e-mLfi">// Java
    final OAuth.ConsumerKey consumerInfo = new OAuth.ConsumerKey(
        Play.application().configuration().getString("tw.consumerKey"),
        Play.application().configuration().getString("tw.consumerSecret")
    );
    final OAuth.RequestToken tokens = new OAuth.RequestToken(
        Play.application().configuration().getString("tw.accessToken"),
        Play.application().configuration()
    .getString("tw.accessTokenSecret")
    );
     // Scala 
    val consumerInfo = ConsumerKey(
      Play.application.configuration.getString("tw.consumerKey").get,
      Play.application.configuration.getString("tw.consumerSecret").get
    )
    val tokens = RequestToken(
      Play.application.configuration.getString("tw.accessToken").get,
      Play.application.configuration.getString("tw.accessTokenSecret").get
    )</pre>
<p id="e-uQZ4">We then passed these credentials to the Play class <code>OAuthCalculator</code> as we accessed the Twitter search API endpoint:</p>
<pre id="e-bCiL">// Java
    Promise&amp;lt;play.libs.ws.WSResponse&amp;gt; twRequest = 
WS.url(url).sign(new OAuthCalculator(consumerInfo, tokens)).get();
     // Scala 
    WS.url(url).sign(OAuthCalculator(consumerInfo, tokens)).get()</pre>
<p id="e-DgGc">Once the Twitter API response returns, we parse the response JSON and push it to a intermediate collection object, which we then passed on to our view template:</p>
<pre id="e-Wt6h">// Java 
    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
    JsonNode root = res.asJson();
     for (JsonNode json : root.get("statuses")) {
      map.put(
        json.findValue("user")
          .findValue("screen_name").asText(),
        json.findValue("text").asText()
      );
    }
     return ok(views.html.tweets.render(map));
     // Scala 
    val tweets = ListBuffer[(String, String)]()
    (res.json \ "statuses").as[List[JsObject]].map { tweet =&amp;gt;
      tweets += ((
        (tweet \ "user" \ "screen_name").as[String],
        (tweet \ "text").as[String]
      ))
    }
     Ok(views.html.tweets(tweets.toList))</pre>
</body></html>