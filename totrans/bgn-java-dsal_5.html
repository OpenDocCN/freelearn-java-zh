<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">String Matching Algorithms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">String matching algorithms are quite common in text-editing programs. These kind of programs frequently need to find all occurrences of a pattern in the text, where the text is usually the document being edited and the pattern is a word supplied by the user. Since text-editing programs aim to be responsive, having efficient algorithms to solve the string matching problem is fundamental.</p>
<p class="mce-root"><span class="calibre14">By the end of this chapter, you will be able to:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">List common string matching algorithms</span></li>
<li class="calibre13"><span class="calibre10">Solve the string matching problem</span></li>
<li class="calibre13"><span class="calibre10">Devise a naive algorithm to solve the string matching problem</span></li>
<li class="calibre13"><span class="calibre10">Implement the Boyer-Moore string search algorithm to carry out string search in literature</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Naive Search Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The string matching problem has two inputs, as follows:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">An array</span> <em class="calibre21"><span class="calibre10">T[1, 2, ...n]</span></em> <span class="calibre10">of length</span> <em class="calibre21"><span class="calibre10">n</span></em></li>
<li class="calibre13"><span class="calibre10">An <em class="calibre21">array</em></span> <em class="calibre21"><span class="calibre10">P[1, 2, ...m]</span></em> <span class="calibre10">of length</span> <em class="calibre21"><span class="calibre10">m (&lt;= n)</span></em></li>
</ul>
<p class="mce-root">The elements of <kbd class="calibre15">T</kbd> and <kbd class="calibre15">P</kbd> are characters from the same finite alphabet (usually called ∑).</p>
<p class="mce-root">For instance, we may be searching in binary strings, in which case our alphabet is <em class="calibre19">{0, 1}</em>, or we may be searching in strings of lowercase letters, in which case our alphabet is <em class="calibre19">{a, b… z}</em>.</p>
<p class="mce-root">The following diagram represents this terminology:</p>
<p class="cdpaligncenter"><img src="Images/7a430fdb-bbbf-4f5c-b989-72740e7d2fc0.png" width="1827" height="377" class="calibre77"/></p>
<div class="packt_figref"><span class="calibre10">Figure 5.1: Representation of text array</span> <span class="calibre10">T</span><span class="calibre10">, pattern array</span> <span class="calibre10">P</span><span class="calibre10">, and finite alphabet ∑</span></div>
<p class="mce-root">The character arrays <kbd class="calibre15">P</kbd> and <kbd class="calibre15">T</kbd> are usually called "strings of characters". We're interested in finding occurrences of pattern <kbd class="calibre15">P</kbd> in text <kbd class="calibre15">T</kbd>.</p>
<p class="mce-root">We say that pattern <kbd class="calibre15">P</kbd> occurs in text <kbd class="calibre15">T</kbd> if we can align the pattern <kbd class="calibre15">P</kbd> with text <kbd class="calibre15">T</kbd> so that all characters in <kbd class="calibre15">P</kbd> match the ones in <kbd class="calibre15">T</kbd>. When aligning, we need to shift pattern <kbd class="calibre15">P</kbd> zero or more times to the right.</p>
<p class="mce-root">Therefore, in the string matching problem, we're interested in valid shifts with which pattern <kbd class="calibre15">P</kbd> occurs in text <kbd class="calibre15">T</kbd>. We say that the pattern <kbd class="calibre15">P</kbd> occurs with a shift <em class="calibre19">s</em> in text <kbd class="calibre15">T</kbd> if the pattern <kbd class="calibre15">P</kbd> occurs beginning at position <kbd class="calibre15">s + 1</kbd> in text <kbd class="calibre15">T</kbd>. In other words, we need to shift <kbd class="calibre15">P</kbd> from the start of text <kbd class="calibre15">T s</kbd> times to the right, in order to find a match. In its essence, the string matching problem aims to find all valid shifts with which pattern <kbd class="calibre15">P</kbd> occurs in a given text <kbd class="calibre15">T</kbd>.</p>
<p class="mce-root">Two common examples, besides text-editing programs, are finding patterns in DNA sequences and finding web pages that are relevant to queries in internet search engines.</p>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre14">Now that we've formalized the string matching problem, let's look at the naive algorithm to solve it.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing Naive Search</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As we described the string matching problem, we said that we were interested in finding all valid shifts with which pattern <kbd class="calibre15">P</kbd> occurs in a given text <kbd class="calibre15">T</kbd>. If we translate that notion directly into an algorithm, we're able to arrive at the naive string matching algorithm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Developing the String Matching Algorithm in Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The aim is to write a code in Java to apply a naive string matching algorithm.</p>
<p class="mce-root">We need to build the naive string matching algorithm. For this algorithm, we need to return all valid starting positions (or shifts) in the text <kbd class="calibre15">T</kbd> in which the pattern <kbd class="calibre15">P</kbd> occurs.</p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement the</span> <kbd class="calibre15"><span class="calibre10">match()</span></kbd> <span class="calibre10">method of the</span> <kbd class="calibre15"><span class="calibre10">NaiveStringMatching</span></kbd> <span class="calibre10">class, which<br class="calibre2"/>
available on GitHub at the following path:</span><br class="calibre2"/>
<a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/naivestringmatching/NaiveStringMatching.java</a></li>
<li class="chapter"><span class="calibre10">Repeatedly shift pattern <kbd class="calibre15">P</kbd> along text <kbd class="calibre15">T</kbd>, matching all the characters in it with the characters aligned in <kbd class="calibre15">T</kbd>.</span></li>
<li class="chapter"><span class="calibre10">When a match occurs, keep track of the index in <kbd class="calibre15">T</kbd> where it did.</span></li>
</ol>
<div class="packt_infobox"><span class="calibre10">The implementation of the naive string matching algorithm is an almost direct translation of the problem statement. We want to go through all possible shifts for</span> <kbd class="calibre31"><span class="calibre10">P</span></kbd> <span class="calibre10">and check which ones are valid by comparing each element of</span> <kbd class="calibre31"><span class="calibre10">P</span></kbd> <span class="calibre10">with the corresponding shifted elements of</span> <kbd class="calibre31"><span class="calibre10">T</span></kbd><span class="calibre10">.</span></div>
<p class="mce-root"><span class="calibre14">A possible solution for this problem is in the following snippet:</span></p>
<pre class="calibre20"><span class="calibre10">for (int i = 0; i &lt; n - m + 1; i++) {<br class="calibre2"/>  boolean hasMatch = true;<br class="calibre2"/>  for (int j = 0; j &lt; m; j++) {<br class="calibre2"/>    if (P.charAt(j) != T.charAt(i + j)) {<br class="calibre2"/>      hasMatch = false;<br class="calibre2"/>      break;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  if (hasMatch)<br class="calibre2"/>  shifts.add(i);<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.1: Solution to the naive string matching problem. Source class name:</span> <span class="calibre10">solution.NaiveStringMatching</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/PmEFws" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/PmEFws</span></a> <span class="calibre10">to access this code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Rationalization of the Naive Search Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The naive search algorithm takes <em class="calibre19">O((n - m + 1)m)</em> time, which is a tight bound on the worst case. We can imagine a worst case of the naive search algorithm if we have a text string with the character a repeating for <em class="calibre19">n</em> times, that is, an (such as <em class="calibre19">a5 = "aaaaa"</em>), and the pattern am (for <em class="calibre19">m &lt;= n</em>). In this case, we have to execute the inner loop <em class="calibre19">m</em> times to validate the shift.</p>
<p class="mce-root">The naive search algorithm can be improved if we know that all characters in pattern <kbd class="calibre15">P</kbd> are different. In this case, whenever we fail validating a shift because <em class="calibre19">P[j]</em> doesn't match <em class="calibre19">T[i + j]</em>, we don't need to backtrack. Instead, we can start validating the next shift on <em class="calibre19">(i + j)</em>, therefore reducing the running time of the algorithm to <em class="calibre19">O(n)</em>.</p>
<p class="mce-root">For example, if <em class="calibre19">P = "abcd"</em> and <em class="calibre19">T = "abcaabcd"</em>, when <em class="calibre19">i = 0</em> and <em class="calibre19">j = 3</em>, we find a mismatch <em class="calibre19">('a' != 'd')</em>. Instead of repeating the comparisons for <em class="calibre19">i = 1</em>, we can start on <em class="calibre19">i = 3</em>, because we're sure there's no other a between <em class="calibre19">i = 0</em> and <em class="calibre19">i = 3</em> (remember that all characters of <kbd class="calibre15">P</kbd> are different). These kinds of observations on the pattern <kbd class="calibre15">P</kbd> are the basis of the Boyer-Moore algorithm.</p>
<p class="mce-root">In this first section, we introduced the string matching problem and solved it using a naive algorithm. In the following section, we'll introduce a much more efficient algorithm to solve this problem—the Boyer-Moore algorithm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting Started with the Boyer-Moore String Searching Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Boyer-Moore string searching algorithm was introduced by Robert S. Boyer and J. Strother Moore in 1977, and builds upon the naive search algorithm by intelligently skipping certain sections of the text.</p>
<p class="mce-root">One key feature of the algorithm is that it matches the pattern from right to left, instead of left to right, using to its advantage a couple of shift rules that improve its running time. To understand the effect of these rules, let's build the Boyer-Moore algorithm from our naive search algorithm.</p>
<p class="mce-root">We'll start by modifying the matching on the pattern so that it operates from right to left. The following code demonstrates this:</p>
<pre class="calibre20"><span class="calibre10">for (int j = m - 1; j &gt;= 0; j--) {<br class="calibre2"/>  if (P.charAt(j) != T.charAt(i + j)) {<br class="calibre2"/>    hasMatch = false;<br class="calibre2"/>    break;<br class="calibre2"/>  }<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.2: Modifying the inner loop from Snippet 5.1 for algorithm to operate from right to left</span> C</div>
<p class="mce-root"><span class="calibre14">Using the naive string matching algorithm as the base, let's look at some rules that allow us to intelligently skip certain shifts.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Bad Character Rule</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The idea of the bad character rule is to identify mismatches between a character in the pattern and a character in the text so that we can safely skip certain shifts. To identify the occurrence of a bad character, let's look at the example in the following table:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">2</td>
<td class="calibre25">3</td>
<td class="calibre25"><strong class="calibre3">4</strong></td>
<td class="calibre25"><strong class="calibre3">5</strong></td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
<td class="calibre25">8</td>
<td class="calibre25">9</td>
<td class="calibre25">10</td>
<td class="calibre25">11</td>
<td class="calibre25">12</td>
<td class="calibre25">13</td>
<td class="calibre25">14</td>
<td class="calibre25">15</td>
<td class="calibre25">16</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">T</strong></td>
<td class="calibre25">H</td>
<td class="calibre25">C</td>
<td class="calibre25">B</td>
<td class="calibre25"><em class="calibre21">B</em></td>
<td class="calibre25"><strong class="calibre3">A</strong></td>
<td class="calibre25"><strong class="calibre3">H</strong></td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">B</td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
</tr>
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">P</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25"><em class="calibre21">H</em></td>
<td class="calibre25"><strong class="calibre3">A</strong></td>
<td class="calibre25"><strong class="calibre3">H</strong></td>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 5.1: Identifying bad characters</span></div>
<p class="mce-root">In the example provided in <em class="calibre19">Table 5.1</em>, we successfully matched the suffix <em class="calibre19">AH</em>, but then arrived at a bad character, since <em class="calibre19">B != H</em>. Whenever this happens, we're sure that it will only be possible to find a valid shift starting from the next shift that solves this mismatch. This means that we can shift <kbd class="calibre15">P</kbd> until either of the following conditions are true:</p>
<ul class="calibre12">
<li class="calibre13">The mismatch is turned into a match</li>
<li class="calibre13">The pattern moves past the mismatched character</li>
</ul>
<p class="mce-root">We can turn a mismatch into a match whenever the pattern has characters to the left of the mismatched character that match the character in the text. Otherwise, we must move the pattern past the mismatched character. In the example provided in <em class="calibre19">Table 5.1</em>, we have another <em class="calibre19">B</em> at <em class="calibre19">P[1]</em>, so we can shift <em class="calibre19">P</em> until <em class="calibre19">P[1]</em> aligns with <em class="calibre19">T[3]</em> as follows:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">2</td>
<td class="calibre25">3</td>
<td class="calibre25">4</td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
<td class="calibre25">8</td>
<td class="calibre25">9</td>
<td class="calibre25">10</td>
<td class="calibre25">11</td>
<td class="calibre25">12</td>
<td class="calibre25">13</td>
<td class="calibre25">14</td>
<td class="calibre25">15</td>
<td class="calibre25">16</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">T</strong></td>
<td class="calibre25">H</td>
<td class="calibre25">C</td>
<td class="calibre25">B</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">B</td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
</tr>
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">P</strong></td>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">H</td>
<td class="calibre25">A</td>
<td class="calibre25"><em class="calibre21">H</em></td>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 5.1.1: Using the bad character rule to skip a shift</span></div>
<p class="mce-root"><span class="calibre14">We've safely skipped the check for</span> <em class="calibre19"><span class="calibre14">1</span></em> <span class="calibre14">shift. Now, we have a mismatch right in the first character. Let's try to apply the bad character rule. First, let's see if we can turn the mismatch into a match.</span></p>
<p class="mce-root"><span class="calibre14">Unfortunately, that is not possible because the character</span> <span class="calibre14"><em class="calibre19">C</em> </span><span class="calibre14">is absent from</span> <em class="calibre19"><span class="calibre14">P</span></em><span class="calibre14">. In this case, we shift the pattern past the mismatched character as follows:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre78"><strong class="calibre3">i</strong></td>
<td class="calibre79">0</td>
<td class="calibre78">1</td>
<td class="calibre78">2</td>
<td class="calibre80">3</td>
<td class="calibre80">4</td>
<td class="calibre79">5</td>
<td class="calibre80">6</td>
<td class="calibre80">7</td>
<td class="calibre80">8</td>
<td class="calibre80">9</td>
<td class="calibre81">10</td>
<td class="calibre82">11</td>
<td class="calibre83">12</td>
<td class="calibre83">13</td>
<td class="calibre84">14</td>
<td class="calibre83">15</td>
<td class="calibre83"><span class="calibre10">16</span></td>
</tr>
<tr class="calibre26">
<td class="calibre78"><strong class="calibre3">T</strong></td>
<td class="calibre79">H</td>
<td class="calibre78">C</td>
<td class="calibre78">B</td>
<td class="calibre80">B</td>
<td class="calibre80">A</td>
<td class="calibre79">H</td>
<td class="calibre80">C</td>
<td class="calibre80">C</td>
<td class="calibre80"><strong class="calibre3">A</strong></td>
<td class="calibre80"><strong class="calibre3">B</strong></td>
<td class="calibre81"><strong class="calibre3">A</strong></td>
<td class="calibre82"><strong class="calibre3">H</strong></td>
<td class="calibre83"><strong class="calibre3">A</strong></td>
<td class="calibre83"><strong class="calibre3">H</strong></td>
<td class="calibre84">B</td>
<td class="calibre83">C</td>
<td class="calibre83">C</td>
</tr>
<tr class="calibre27">
<td class="calibre78"><strong class="calibre3">P</strong></td>
<td class="calibre79"/>
<td class="calibre78"/>
<td class="calibre78"/>
<td class="calibre80"/>
<td class="calibre80"/>
<td class="calibre79"/>
<td class="calibre80"/>
<td class="calibre80"/>
<td class="calibre80"><strong class="calibre3">A</strong></td>
<td class="calibre80"><strong class="calibre3">B</strong></td>
<td class="calibre81"><strong class="calibre3">A</strong></td>
<td class="calibre82"><strong class="calibre3">H</strong></td>
<td class="calibre83"><strong class="calibre3">A</strong></td>
<td class="calibre83"><strong class="calibre3">H</strong></td>
<td class="calibre84"/>
<td class="calibre83"/>
<td class="calibre83"/>
</tr>
</tbody>
</table>
<div class="packt_figref">Table 5.1.2: Pattern moving past a mismatched character</div>
<p class="mce-root">We've successfully skipped checking five shifts and have arrived at a valid shift.</p>
<p class="mce-root">The bad character rule will help us optimize the naive string matching algorithm, but only if we can efficiently find the correct number of times to shift. Let's assume we have access to a two-dimensional array <em class="calibre19">[1...m][1...e]</em>, <em class="calibre19">e</em> being the size of our alphabet. For convenience, let's call this array left and assume that <em class="calibre19">left[i][j]</em> gives us the closest index <em class="calibre19">k</em> of character <em class="calibre19">j</em> in <em class="calibre19">P</em> so that <em class="calibre19">k &lt; i</em>, or is <em class="calibre19">-1</em> if character <em class="calibre19">j</em> isn't found to the left of <em class="calibre19">i</em> in <em class="calibre19">P</em>. If we're able to build such an array, we could improve our naive string search algorithm by considering possibly larger skips (given by the information in left). The following code snippet shows how we can use the left array to improve our naive string searching algorithm as follows:</p>
<pre class="calibre20"><span class="calibre10">int skip;<br class="calibre2"/>for (int i = 0; i &lt; n - m + 1; i += skip) {<br class="calibre2"/>  skip = 0;<br class="calibre2"/>  for (int j = m - 1; j &gt;= 0; j--) {<br class="calibre2"/>    if (P.charAt(j) != T.charAt(i + j)) {<br class="calibre2"/>      skip = Math.max(1, j - left[j][T.charAt(i + j)]);<br class="calibre2"/>     break;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  if (skip == 0) {<br class="calibre2"/>    shifts.add(i);<br class="calibre2"/>    skip = 1;<br class="calibre2"/>  }<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref">Snippet 5.3: Using the bad character rule to improve our skips</div>
<div class="packt_infobox"><br class="calibre2"/>
Go to <a href="https://goo.gl/cCYnfp" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://goo.gl/cCYnfp</a> to access this code.</div>
<p class="mce-root"><span class="calibre14">We're left to filling in the</span> <kbd class="calibre15"><span class="calibre10">left</span></kbd> <span class="calibre14">array, which will be performed in the next activity.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing the Bad Character Rule</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root"><span class="calibre14">We have to preprocess string</span> <em class="calibre19"><span class="calibre14">P</span></em> <span class="calibre14">to build the</span> <kbd class="calibre15"><span class="calibre10">left</span></kbd> <span class="calibre14">array that allows us to use the bad character rule efficiently. Recall that</span> <em class="calibre19"><span class="calibre14">left[i][j]</span></em> <span class="calibre14">should return either of the following:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">The largest index</span> <em class="calibre21"><span class="calibre10">k</span></em> <span class="calibre10">so that</span> <em class="calibre21"><span class="calibre10">k &lt;= i</span></em> <span class="calibre10">and</span> <em class="calibre21"><span class="calibre10">P[k] == j</span></em></li>
<li class="calibre13"><span class="calibre10"><em class="calibre21">-1</em>, if</span> <em class="calibre21"><span class="calibre10">j</span></em> <span class="calibre10">isn't found in</span> <em class="calibre21"><span class="calibre10">P</span></em></li>
</ul>
<p class="mce-root"><strong class="calibre6">Aim</strong></p>
<p class="mce-root">To build an array that allows us to use the bad character rule efficiently.</p>
<p class="mce-root"><strong class="calibre6">Steps for Completion</strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement the commented part of the</span> <kbd class="calibre15"><span class="calibre10">match()</span></kbd> <span class="calibre10">method of the class </span><kbd class="calibre15"><span class="calibre10">BadCharacterRule</span></kbd><span class="calibre10">, which is available on GitHub at the following path: <br class="calibre2"/></span><span class="calibre10"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/badcharacterrule/BadCharacterRule.java</a></span></li>
<li class="chapter"><span class="calibre10">Assume that the alphabet of strings</span> <em class="calibre21"><span class="calibre10">P</span></em> <span class="calibre10">and</span> <em class="calibre21"><span class="calibre10">T</span></em> <span class="calibre10">consists only of lowercase letters of the English alphabet.</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Good Suffix Rule</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The good suffix rule presents a complementary method to enhance our search for valid shifts. To identify when the good suffix rule is applicable, let's look at the example given in the following table:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">2</td>
<td class="calibre25">3</td>
<td class="calibre25">4</td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
<td class="calibre25">8</td>
<td class="calibre25">9</td>
<td class="calibre25">10</td>
<td class="calibre25">11</td>
<td class="calibre25">12</td>
<td class="calibre25">13</td>
<td class="calibre25">14</td>
<td class="calibre25">15</td>
<td class="calibre25">16</td>
<td class="calibre25">17</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">T</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">B</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
</tr>
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">P</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25">C</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 5.2: Illustration of the good suffix rule</span></div>
<p class="mce-root">When found in a situation where we have matched a suffix of <em class="calibre19">P</em> but have found a mismatch, using the good suffix rule, and considering <em class="calibre19">t</em> as the matched suffix, we can try to find the next shift that solves the mismatch by carrying out either of the following cases:</p>
<ul class="calibre12">
<li class="calibre13">Find another occurrence of <em class="calibre21">t</em> to the left in <em class="calibre21">P</em></li>
<li class="calibre13">Find a prefix of <em class="calibre21">P</em> which matches a suffix of <em class="calibre21">t</em></li>
<li class="calibre13">Move <em class="calibre21">P</em> past <em class="calibre21">t</em></li>
</ul>
<p class="mce-root">Considering case 1, we can try to shift <em class="calibre19">P</em> by three to align other occurrences of <em class="calibre19">t</em> in <em class="calibre19">P</em> (starting at <em class="calibre19">P[4]</em>). As we can see, the letter to the left of that occurrence of <em class="calibre19">t</em> (in <em class="calibre19">P[3]</em>) is <em class="calibre19">C</em>, which is exactly the same as the one that provoked the mismatch. Therefore, we should always try to find a <em class="calibre19">t</em> that is followed, on the left, by a character that is different from the one that provoked the mismatch. A variant of the good suffix rule which ignores the character on the left of <em class="calibre19">t</em> is called the weak good suffix rule.</p>
<div class="packt_infobox"><span class="calibre10"><br class="calibre2"/>
The good suffix rule takes into account that the character on the left of </span><em class="calibre21"><span class="calibre10">t</span></em> <span class="calibre10">is also called the strong good suffix rule.</span></div>
<p class="mce-root"><span class="calibre14">If we can't find another occurrence of</span> <em class="calibre19"><span class="calibre14">t</span></em> <span class="calibre14">in</span> <em class="calibre19"><span class="calibre14">P</span></em><span class="calibre14">, the best we can do with this rule is to find a prefix of</span> <em class="calibre19"><span class="calibre14">P</span></em> <span class="calibre14">that matches a suffix of</span> <em class="calibre19"><span class="calibre14">t</span></em><span class="calibre14">, entering c</span><span class="calibre14">ase 2</span><span class="calibre14">.</span> <em class="calibre19"><span class="calibre14">Table 5.3</span></em> <span class="calibre14">illustrates this case:</span></p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">2</td>
<td class="calibre25">3</td>
<td class="calibre25">4</td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
<td class="calibre25">8</td>
<td class="calibre25">9</td>
<td class="calibre25">10</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">T</strong></td>
<td class="calibre25">A</td>
<td class="calibre25"><em class="calibre21">A</em></td>
<td class="calibre25"><strong class="calibre3">B</strong></td>
<td class="calibre25"><strong class="calibre3">A</strong></td>
<td class="calibre25"><strong class="calibre3">B</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">C</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
</tr>
<tr class="calibre27">
<td class="calibre25"><strong class="calibre3">P</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25"><strong class="calibre3">B</strong></td>
<td class="calibre25"><strong class="calibre3">A</strong></td>
<td class="calibre25"><strong class="calibre3">B</strong></td>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
<td class="calibre25"/>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 5.3: Finding prefix of P matching the suffix of T</span></div>
<p class="mce-root">In this case, we found a mismatch at <em class="calibre19">P[1]</em>, but we can't find another occurrence of <em class="calibre19">BAB</em> to the left of it. We can, however, find a prefix of <em class="calibre19">AB</em> that matches a suffix of <em class="calibre19">t AB</em> and shift <em class="calibre19">P</em> so that these align.</p>
<p class="mce-root">Whenever we can neither find another occurrence nor a prefix of <em class="calibre19">t</em>, we're left with moving <em class="calibre19">P</em> past <em class="calibre19">t</em> in <em class="calibre19">T</em>.</p>
<p class="mce-root">The implementation of the good suffix rule also requires some preprocessing on <em class="calibre19">P</em>. To understand the preprocessing that is necessary, we need to introduce the concept of a border and proper prefix and suffix. A prefix of string <em class="calibre19">S</em> is a substring of <em class="calibre19">S</em> that occurs at the beginning of <em class="calibre19">S</em>. A proper prefix of string <em class="calibre19">S</em> is a prefix of <em class="calibre19">S</em> that is different than <em class="calibre19">S</em> (consider that <em class="calibre19">S</em> is always a prefix of <em class="calibre19">S</em>).</p>
<p class="mce-root">A suffix of string <em class="calibre19">S</em> is a substring of <em class="calibre19">S</em> that occurs at the end of <em class="calibre19">S</em>. A proper suffix of string <em class="calibre19">S</em> is a suffix of <em class="calibre19">S</em> that is different from <em class="calibre19">S</em> (consider that <em class="calibre19">S</em> is always a suffix of <em class="calibre19">S</em>). A border is a substring of a given string that is both a proper prefix and a proper suffix. For example, given the string <em class="calibre19">ccacc</em>, there are two borders: <em class="calibre19">c</em> and <em class="calibre19">cc. cca</em> is not a border.</p>
<p class="mce-root">The preprocessing step for the good suffix rule is divided into two steps: one for case 1 of the rule, and another for case 2.</p>
<p class="mce-root">In case 1, the matching suffix is a border of a suffix of a pattern. For example, if <em class="calibre19">P = AACCACCAC</em> and we have <em class="calibre19">t = AC</em> (a suffix of <em class="calibre19">P</em>), then we need to find a suffix of <em class="calibre19">P</em> that has <em class="calibre19">AC</em> as a prefix (constituting a border of the suffix). The string <em class="calibre19">ACCAC</em> is a suffix of <em class="calibre19">P</em> and has <em class="calibre19">AC</em> as a border.</p>
<p class="mce-root">Therefore, we need to find the borders of the suffixes of the pattern. But, even after finding them, we need to be able to map a given border to the shortest suffix that has this border so that we're able to shift accordingly. Moreover, to follow the strong good suffix rule, the border cannot be extended to the left by the same symbol that caused the mismatch.</p>
<p class="mce-root">The preprocessing algorithm for case 1 is displayed in the following snippet:</p>
<pre class="calibre20">int i = m, j = m + 1;<br class="calibre2"/>int[] f = new int[m + 1];<br class="calibre2"/>int[] s = new int[m + 1];<br class="calibre2"/>f[i] = j;<br class="calibre2"/>while (i &gt; 0) {<br class="calibre2"/>  while (j &lt;= m &amp;&amp; P.charAt(i - 1) != P.charAt(j - 1)) {<br class="calibre2"/>    if (s[j] == 0)<br class="calibre2"/>      s[j] = j - i;<br class="calibre2"/>      j = f[j];<br class="calibre2"/>  }<br class="calibre2"/>  i--; j--;<br class="calibre2"/>  f[i] = j;<br class="calibre2"/>}</pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.4: Preprocessing algorithm for Case 1 of the good suffix rule. Source class name: </span><span class="calibre10">GoodSuffixRule</span></div>
<div class="packt_infobox"><span class="calibre10">Go to</span> <a href="https://goo.gl/WzGuVG" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/WzGuVG</span></a> <span class="calibre10">to access this code.<br class="calibre2"/>
To better understand the preprocessing algorithm for</span> <span class="calibre10">case 1</span><span class="calibre10">, put some </span><span class="calibre10"><kbd class="calibre31">println</kbd></span> <span class="calibre10">statements on the relevant steps of the algorithm and run it using some sample input. You can use string</span> <kbd class="calibre31"><span class="calibre10">ABBABAB</span></kbd><span class="calibre10">, whose output is shown in</span> <em class="calibre21"><span class="calibre10">Table 5.4</span></em><span class="calibre10">.</span></div>
<p class="mce-root">In the previous snippet, we compute an array <em class="calibre19">f</em>, whose entries <em class="calibre19">f[i]</em> contain the starting position of the widest border of the suffix of the pattern that starts at position <em class="calibre19">i</em>. <em class="calibre19">f[m]</em> is equal to <em class="calibre19">m + 1</em>, as the empty string has no border. The idea behind the previously shown preprocessing algorithm is to compute each border by checking whether a shorter border that is already known can be extended to the left by the same symbol. The array <em class="calibre19">s</em> is used to store shift distances; we can save entries in array <em class="calibre19">s</em> whenever we can't extend a border to the left (when <em class="calibre19">P[i - 1] != P[j - 1]</em>), provided that <em class="calibre19">s[j]</em> is not already occupied.</p>
<p class="mce-root">To better understand what this algorithm produces, let's look at its output for string <em class="calibre19">ABBABAB</em>, which is shown in the following table:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">i</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">1</td>
<td class="calibre25">2</td>
<td class="calibre25">3</td>
<td class="calibre25">4</td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
</tr>
<tr class="calibre26">
<td class="calibre25"><strong class="calibre3">P</strong></td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25">A</td>
<td class="calibre25">B</td>
<td class="calibre25"/>
</tr>
<tr class="calibre24">
<td class="calibre25"><strong class="calibre3">f</strong></td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">4</td>
<td class="calibre25">5</td>
<td class="calibre25">6</td>
<td class="calibre25">7</td>
<td class="calibre25">7</td>
<td class="calibre25">8</td>
</tr>
<tr class="calibre38">
<td class="calibre25"><strong class="calibre3">s</strong></td>
<td class="calibre25">0</td>
<td class="calibre25">0</td>
<td class="calibre25">0</td>
<td class="calibre25">0</td>
<td class="calibre25">2</td>
<td class="calibre25">0</td>
<td class="calibre25">4</td>
<td class="calibre25">1</td>
</tr>
</tbody>
</table>
<div class="packt_figref"><span class="calibre10">Table 5.4: Output of the preprocessing algorithm for Case 1 of the good suffix rule with string ABBABAB</span></div>
<p class="mce-root">The widest border of suffix <em class="calibre19">BABAB</em>, which starts at <em class="calibre19">2</em>, is <em class="calibre19">BAB</em>, which starts at <em class="calibre19">4</em>, and therefore <em class="calibre19">f[2] = 4</em>. The widest border of suffix <em class="calibre19">AB</em>, which starts at <em class="calibre19">5</em>, is "", which starts at <em class="calibre19">7</em>. Therefore, <em class="calibre19">f[5] = 7</em>. The suffix <em class="calibre19">BABAB</em>, whose widest border is <em class="calibre19">BAB</em>, cannot be extended to the left (since <em class="calibre19">P[1] != P[3]</em>). Therefore, the shift distance of <em class="calibre19">BAB</em> is matched and then a mismatch occurs, which is <em class="calibre19">s[4] = 4 - 2 = 2</em>. The suffix <em class="calibre19">BABAB</em> has border <em class="calibre19">B</em> as well, which also cannot be extended to left, which ensures that <em class="calibre19">s[6] = 6 - 2 = 4</em>. The suffix <em class="calibre19">B</em> beginning at position <em class="calibre19">6</em> has border "", beginning at position <em class="calibre19">7</em>; therefore, <em class="calibre19">s[7] = 7 - 6 = 1</em>, which corresponds to the shift distance if nothing has matched.</p>
<p class="mce-root">In case 2, a suffix of the matching suffix of the pattern occurs at the beginning of the pattern, which constitutes a border of the pattern. Therefore, the pattern can be shifted as far as its widest border allows. What we need to do for the preprocessing step for case 2 is to find, for each suffix, the widest border of the pattern that is contained in that suffix. We can build upon the <em class="calibre19">f</em> array that was previously computed to do that. The following snippet illustrates this:</p>
<pre class="calibre20"><span class="calibre10">j = f[0];<br class="calibre2"/>for (i = 0; i &lt;= m; i++) {<br class="calibre2"/>  if (s[i] == 0)<br class="calibre2"/>  s[i] = j;<br class="calibre2"/>  if (i == j)<br class="calibre2"/>  j = f[j];<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.5: Preprocessing algorithm for Case 2 of the good suffix rule. Source class name:</span> <span class="calibre10">GoodSuffixRule</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/ckoTu6" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/ckoTu6</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">The widest border of the pattern is stored at <em class="calibre19">f[0]</em>. The idea of the preprocessing algorithm for case 2 is to use that value until the pattern becomes shorter than <em class="calibre19">f[0]</em>, in which case we go with the next wider border of the pattern <em class="calibre19">(f[j])</em>.</p>
<p class="mce-root">Integrating the good suffix case with the naive search algorithm allows us to improve on the skips performed, as shown in the following code:</p>
<pre class="calibre20"><span class="calibre10">for (i = 0; i &lt; n - m + 1; i += skip) {<br class="calibre2"/>  boolean hasMatch = true;<br class="calibre2"/>  skip = 0;<br class="calibre2"/>  for (j = m - 1; j &gt;= 0; j--) {<br class="calibre2"/>    if (P.charAt(j) != T.charAt (i + j)) {<br class="calibre2"/>      skip = s[j + 1];<br class="calibre2"/>      hasMatch = false;<br class="calibre2"/>      break;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  if (hasMatch) {<br class="calibre2"/>    shifts.add(i);<br class="calibre2"/>    skip = s[0];<br class="calibre2"/>  } <br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.6: The Boyer-Moore algorithm using only the good suffix rule. Source class name: </span><span class="calibre10">Goodsuffixrule</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/1uCgeh" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/1uCgeh</span></a> <span class="calibre10">to access this code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Application of the Boyer-Moore Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The Boyer-Moore algorithm is typically used with one or both the bad character and good suffix rule. When used with both rules, the shift that is to occur is the biggest one produced by the rules. The Boyer-Moore algorithm improves the naive search algorithm in the average case, but is still</span> <em class="calibre19"><span class="calibre14">O(nm)</span></em> <span class="calibre14">in the worst case (that case being the</span> <span class="calibre14">same described in the previous section, that is, a repeated group of characters both in the pattern and in the text).</span> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Boyer-Moore Algorithm </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The aim is to write a code in Java to implement the Boyer-Moore algorithm.</span></p>
<p class="mce-root"><span class="calibre14">We need to integrate the bad character rule with the good suffix rule to produce the complete Boyer-Moore algorithm. The idea here is to use the rule that gives us the better (or biggest) shift in each situation.</span></p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement the</span> <kbd class="calibre15"><span class="calibre10">match()</span></kbd> <span class="calibre10">method of the</span> <kbd class="calibre15"><span class="calibre10">BoyerMoore</span></kbd> <span class="calibre10">class, which is available<br class="calibre2"/>
on the following path:<br class="calibre2"/></span><span class="calibre10"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson5/activity/boyermoore/BoyerMoore.java</a></span></li>
<li class="chapter"><span class="calibre10">Combine the snippets and change the skip logic to choose the best of both rules.</span></li>
</ol>
<p class="mce-root"><span class="calibre14">The following snippet shows how the combined matching can be implemented as a solution:</span></p>
<pre class="calibre20"><span class="calibre10">for (i = 0; i &lt; n - m + 1; i += skip) {<br class="calibre2"/>  skip = 0;<br class="calibre2"/>  boolean hasMatch = true;<br class="calibre2"/>  for (j = m - 1; j &gt;= 0; j--) {<br class="calibre2"/>    if (P.charAt(j) != T.charAt(i + j)) {<br class="calibre2"/>      hasMatch = false;<br class="calibre2"/>      skip = Math.max(s[j + 1], j - left[j]<br class="calibre2"/>      [T.charAt(i + j)]);<br class="calibre2"/>      break;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  if (hasMatch) {<br class="calibre2"/>    shifts.add(i);<br class="calibre2"/>    skip = s[0];<br class="calibre2"/>  } <br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.7: Implementation of the boyer-moore algorithm. Source class:</span> <span class="calibre10">BoyerMoore</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/71mXd6" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/71mXd6</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In this section, we've introduced the Boyer-Moore algorithm as an improvement over the naive search algorithm. By preprocessing the pattern to skip unnecessary shifts, we can decrease the average runtime complexity of the string matching algorithm. In the following section, we will list some other string matching algorithms, listing their applicability, but without going into much detail about their implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introducing Other String Matching Algorithms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Even though the Boyer-Moore string search algorithm is the standard benchmark for practical string search literature, there are other string matching algorithms that are also suitable for different purposes. In this small section, we present the following three, which are the most famous ones:</p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Rabin-Karp</span></li>
<li class="calibre13"><span class="calibre10">Knuth-Morris-Pratt</span></li>
<li class="calibre13"><span class="calibre10">Aho-Corasick</span></li>
</ul>
<p class="mce-root"><span class="calibre14">However, only give out the implementation of Rabin-Karp.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Rabin-Karp</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In 1987, Richard M. Karp and Michael O. Rabin proposed a string matching algorithm that performs well in practice and generalizes string matching against a set of patterns. The Rabin-Karp algorithm takes <em class="calibre19">O(m)</em> time in its preprocessing stage and its worst-case running time is <em class="calibre19">O((n - m + 1)m)</em>, similar to Boyer-Moore's.</p>
<p class="mce-root">To better introduce the Rabin-Karp algorithm, let's assume that our alphabet ∑ is composed only of decimal digits <em class="calibre19">(∑ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9})</em>, so that we can view a string of <em class="calibre19">k</em> characters as a decimal number with length <em class="calibre19">k</em>. Therefore, string 12345 corresponds to number 12345. Given a pattern <em class="calibre19">P[0...m]</em> and a substring from text <em class="calibre19">T[i...i + m]</em>, if we convert both those strings to their correspondent decimal number, so that we have numbers <em class="calibre19">p</em> and <em class="calibre19">t<sub class="calibre40">i</sub></em>, then <em class="calibre19">p = t<sub class="calibre40">i</sub></em> only if <em class="calibre19">P[0...m] = T[i...i + m]</em>, and therefore <em class="calibre19">i</em> is only a valid shift if <em class="calibre19">p = t<sub class="calibre40">i</sub></em>.</p>
<p class="mce-root">If we could compute p in <em class="calibre19">O(m)</em> time and all the t<sub class="calibre40">i</sub> values in <em class="calibre19">O(n - m + 1)</em> time, then we could determine all valid shifts in <em class="calibre19">O(n)</em> time by comparing p with each of the <em class="calibre19">t<sub class="calibre40">i</sub></em> values. The problem with this is when <em class="calibre19">p</em> and <em class="calibre19">t<sub class="calibre40">i</sub></em> are too large to work with. If the numbers are too large, then we can work with them modulo <em class="calibre19">q</em>, for a suitable modulus <em class="calibre19">q</em>.</p>
<p class="mce-root">Let's leave the choice of a suitable modulus <em class="calibre19">q</em> for later. How we can generalize this to work with other alphabets? For example, what if we want to use characters that are not decimal digits?</p>
<p class="mce-root">Consider that, in the case of our original alphabet, to convert a string 12345 into a number, we would perform the operation <em class="calibre19">10<sup class="calibre32">4</sup>*1+10<sup class="calibre32">3</sup>*2+10<sup class="calibre32">2</sup>*3+10¹*4+10<sup class="calibre32">0</sup>*5</em>. If we have a D-ary alphabet <em class="calibre19">{0, 1… d - 1}</em>, then we could use the same strategy, but replace 10 by <em class="calibre19">d</em>. One other consideration to have is that, when we have computed <em class="calibre19">t<sub class="calibre40">i</sub></em> and we want to compute <em class="calibre19">t<sub class="calibre40">i+1</sub></em>, then we can simply remove the leftmost digit, shift everything to the left, and add the newest digit, that is, <em class="calibre19">t<sub class="calibre40">i+1</sub> = ((t<sub class="calibre40">i</sub> - T[i]*d<sub class="calibre40">m-1</sub>)*d + T[i + 1]) % q</em>.</p>
<p class="mce-root"><span class="calibre14">One final consideration to have is that working with modulo</span> <em class="calibre19"><span class="calibre14">q</span></em> <span class="calibre14">is not perfect.</span> <em class="calibre19"><span class="calibre14">t</span><sub class="calibre40"><span class="calibre14">i</span></sub> <span class="calibre14">= p (mod q)</span></em> <span class="calibre14">does not imply that</span> <em class="calibre19"><span class="calibre14">t</span><sub class="calibre40"><span class="calibre14">i</span></sub> <span class="calibre14">= p</span></em><span class="calibre14">. But if</span> <em class="calibre19"><span class="calibre14">t</span><sub class="calibre40"><span class="calibre14">i</span></sub> <span class="calibre14">!= p</span></em> <span class="calibre14"><em class="calibre19">(mod q)</em>, then</span> <em class="calibre19"><span class="calibre14">t</span><sub class="calibre40"><span class="calibre14">i</span></sub> <span class="calibre14">!= p</span></em><span class="calibre14">. We can therefore use this as a fast heuristic test to rule out invalid shifts.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Applying the Rabin-Karp Algorithm</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The aim here is to develop a code in Java for implementing the Rabin-Karp algorithm for matching a string from a set of alphabetical characters that have decimal digits.</span></p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Convert the text and pattern strings into digits.</span></li>
<li class="chapter"><span class="calibre10">Use if and for loops to calculate the number of matching characters.</span></li>
<li class="chapter"><span class="calibre10">Put everything together to implement the Rabin-Karp algorithm. The following</span> <em class="calibre21"><span class="calibre10">Snippet 5.9</span></em> <span class="calibre10">shows the pre-compute part of the algorithm:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">long q = BigInteger.probablePrime(31, new  Random()).longValue();<br class="calibre2"/>// Precompute d^(m-1) % q for use when removing leading digit<br class="calibre2"/>long dm = 1;<br class="calibre2"/>for (int i = 1; i &lt;= m - 1; i++)<br class="calibre2"/>  dm = (d * dm) % q;<br class="calibre2"/>// Precompute p and t0<br class="calibre2"/>long ph = 0;<br class="calibre2"/>long th = 0;<br class="calibre2"/>for (int i = 0; i &lt; m; i++) {<br class="calibre2"/>  ph = (d * ph + P.charAt(i)) % q;<br class="calibre2"/>  th = (d * th + T.charAt(i)) % q;<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 5.9: Implementation of the Rabin-Karp algorithm. Source class name: </span><span class="calibre10">RabinKarp</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/w7yzPA" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/w7yzPA</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In the previous implementation, we chose <em class="calibre19">q</em> as a large prime number (using the <kbd class="calibre15">BigInteger</kbd> API). We did that so that we have a good hash function and avoided the most of false positives from the <em class="calibre19">p = t<sub class="calibre40">i</sub></em> comparison. This is a similar technique to the one we saw in the remainder method for hash tables in <a href="05da549e-383b-475e-86f2-043f47a226a1.xhtml" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">Chapter 3</a>, <em class="calibre19">Hash Tables and Binary Search Trees</em>.</p>
<div class="packt_infobox"><span class="calibre10">Despite being outside the scope of this book, the Rabin-Karp algorithm generalizes well to having a set of patterns to be found in the same text. For that purpose, it is frequently used in plagiarism detection.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Knuth–Morris–Pratt</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre6">Knuth-Morris-Pratt</strong> (<strong class="calibre6">KMP</strong>) algorithm is a single-pattern string searching algorithm conceived by Donald Knuth and Vaughan Pratt in 1970, and independently by James H. Morris, being jointly published by the three in 1977. When compared to the Boyer-Moore algorithm, KMP employs the observation that, when a mismatch occurs, the pattern embodies sufficient information to determine where the next match could begin.</p>
<p class="mce-root">It is similar to Boyer-Moore in the sense that it efficiently skips unnecessary comparisons. The KMP algorithm has a running time of <em class="calibre19">O(n)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Aho–Corasick</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Aho-Corasick algorithm is a string searching algorithm invented by Alfred V. Aho and Margaret J. Corasick. Similar to the extended version of the Rabin-Karp algorithm, it is capable of matching elements of a dictionary (set of words) within an input text. The idea behind it is to build a finite state machine that enables matching all strings of the dictionary simultaneously. The algorithm is linear in the length of the strings, plus the length of the searched text, plus the number of output matches. If <em class="calibre19">n</em> is the length of the searched text, <em class="calibre19">m</em> is the sum of the length of all words in the dictionary, and <em class="calibre19">z</em> is the total number of occurrences of words in the text.</p>
<p class="mce-root">Therefore, the time complexity of the Aho-Corasick algorithm is <em class="calibre19">O(n + m + z)</em>. In this small section, we've looked at three other famous string matching algorithms. Without going into much detail about them, we've seen their applicability on different problems other than the one the Boyer-Moore algorithm solves. In particular, we've noted that there are algorithms specialized for the finding of a set of patterns in a text.</p>
<div class="packt_infobox">In 1979, Zvi Galil introduced an important optimization, called the Galil rule, that speeds up the comparisons done at each shift by skipping sections that are known to match. Using the Galil rule, the Boyer-Moore algorithm achieves linear time complexity in the worst case.<span class="calibre10"><br class="calibre2"/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">In this chapter, we have introduced the string matching problem. We've started from the naive search algorithm and improved it by using the rules introduced by Boyer and Moore. We've seen how these rules improve the average runtime complexity of our algorithm. We've also explored some other string matching algorithms without going into too much detail about them. In the next chapter, we will be exploring graphs and their applications</span></p>


            </article>

            
        </section>
    </div>



  </body></html>