<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Physics with Bullet"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Physics with Bullet</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a pushable door</li><li class="listitem" style="list-style-type: disc">Building a rocket engine</li><li class="listitem" style="list-style-type: disc">Ballistic projectiles and arrows</li><li class="listitem" style="list-style-type: disc">Handling multiple gravity sources</li><li class="listitem" style="list-style-type: disc">Self-balancing using RotationalLimitMotors</li><li class="listitem" style="list-style-type: disc">The principles of a bridge-building game</li><li class="listitem" style="list-style-type: disc">Networked physics</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Introduction</h1></div></div></div><p>Using physics in games has become very common and accessible, thanks to open source physics engines, such as Bullet. jMonkeyEngine supports both the Java-based jBullet and native Bullet in a seamless manner.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>jBullet is<a id="id549" class="indexterm"/> a Java-based library with JNI bindings to the original Bullet based on C++. jMonkeyEngine is supplied with both of these, and they can be used interchangeably by replacing the libraries in the classpath. No coding change is required. Use <code class="literal">jme3-libraries-physics</code> for the implementation of jBullet and <code class="literal">jme3-libraries-physics-native</code> for Bullet. In general, Bullet is considered to be faster and is full featured.</p></div></div><p>Physics can be used for almost anything in games, from tin cans that can be kicked around to character animation systems. In this chapter, we'll try to reflect the diversity of these implementations.</p><p>All the recipes in this chapter will require you to have a <code class="literal">BulletAppState</code> class in the application. To avoid repetition, the process of doing this is described in the <span class="emphasis"><em>Adding Bullet physics to the application</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>.</p></div></div>
<div class="section" title="Creating a pushable door"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Creating a pushable door</h1></div></div></div><p>Doors <a id="id550" class="indexterm"/>are useful in games. Visually, it is more appealing to not have holes in the walls but doors for the players to pass through. Doors can be used to obscure the view and hide what's behind them for a surprise later. In extension, they can also be used to dynamically hide geometries and increase the performance. There is also a gameplay aspect where doors are used to open new areas to the player and give a sense of progression.</p><p>In this recipe, we will create a door that can be opened by pushing it, using a <code class="literal">HingeJoint</code> class.</p><p>This door consists<a id="id551" class="indexterm"/> of the following three elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Door object</strong></span>: This<a id="id552" class="indexterm"/> is a visible object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Attachment</strong></span>: This is<a id="id553" class="indexterm"/> the fixed end of the joint around which the hinge swings</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hinge</strong></span>: This <a id="id554" class="indexterm"/>defines how the door should move</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec195"/>Getting ready</h2></div></div></div><p>Simply <a id="id555" class="indexterm"/>following the steps in this recipe won't give us anything testable. Since the camera has no physics, the door will just sit there and we will have no way to push it. If you have made any of the recipes that use the <code class="literal">BetterCharacterControl</code> class, many of them in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, we will already have a suitable test bed for the door. If not, jMonkeyEngine's <code class="literal">TestBetterCharacter</code> example can also be used.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec196"/>How to do it...</h2></div></div></div><p>This recipe consists of two sections. The first will deal with the actual creation of the door and the functionality to open it. This will be made in the following six steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new <code class="literal">RigidBodyControl</code> object called <code class="literal">attachment</code> with a small <code class="literal">BoxCollisionShape</code>. The <code class="literal">CollisionShape</code> should normally be placed inside the wall where the player can't run into it. It should have a mass of 0, to prevent it from being affected by gravity.</li><li class="listitem">We move it some distance away and add it to the <code class="literal">physicsSpace</code> instance, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">attachment.setPhysicsLocation(new Vector3f(-5f, 1.52f, 0f));
bulletAppState.getPhysicsSpace().add(attachment);</pre></div></li><li class="listitem">Now, create a <code class="literal">Geometry</code> class called <code class="literal">doorGeometry</code> with a <code class="literal">Box</code> shape with dimensions that are suitable for a door, as follows:<div class="informalexample"><pre class="programlisting">Geometry doorGeometry = new Geometry("Door", new Box(0.6f, 1.5f, 0.1f));</pre></div></li><li class="listitem">Similarly, create a <code class="literal">RigidBodyControl</code> instance with the same dimensions, that is, <code class="literal">1</code> in <code class="literal">mass</code>; add it as a control to the <code class="literal">doorGeometry</code> class first and then add it to <code class="literal">physicsSpace</code> of <code class="literal">bulletAppState</code>. The following code snippet shows you how to do this:<div class="informalexample"><pre class="programlisting">RigidBodyControl doorPhysicsBody = new RigidBodyControl(new BoxCollisionShape(new Vector3f(.6f, 1.5f, .1f)), 1);
bulletAppState.getPhysicsSpace().add(doorPhysicsBody);
doorGeometry.addControl(doorPhysicsBody);</pre></div></li><li class="listitem">Now, we're<a id="id556" class="indexterm"/> going to connect the two with <code class="literal">HingeJoint</code>. Create a new <code class="literal">HingeJoint</code> instance called <code class="literal">joint</code>, as follows:<div class="informalexample"><pre class="programlisting">new HingeJoint(attachment, doorPhysicsBody, new Vector3f(0f, 0f, 0f), new Vector3f(-1f, 0f, 0f), Vector3f.UNIT_Y, Vector3f.UNIT_Y);</pre></div></li><li class="listitem">Then, we set the limit for the rotation of the door and add it to <code class="literal">physicsSpace</code> as follows:<div class="informalexample"><pre class="programlisting">joint.setLimit(-FastMath.HALF_PI - 0.1f, FastMath.HALF_PI + 0.1f);
bulletAppState.getPhysicsSpace().add(joint);</pre></div></li></ol></div><p>Now, we have a door that can be opened by walking into it. It is primitive but effective. Normally, you want doors in games to close after a while. However, here, once it is opened, it remains opened. In order to implement an automatic closing mechanism, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">DoorCloseControl</code> extending <code class="literal">AbstractControl</code>.</li><li class="listitem">Add a <code class="literal">HingeJoint</code> field called <code class="literal">joint</code> along with a setter for it and a float variable called <code class="literal">timeOpen</code>.</li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we get <code class="literal">hingeAngle</code> from <code class="literal">HingeJoint</code> and store it in a float variable called <code class="literal">angle</code>, as follows:<div class="informalexample"><pre class="programlisting">float angle = joint.getHingeAngle();</pre></div></li><li class="listitem">If the angle deviates a bit more from zero, we should increase <code class="literal">timeOpen</code> using <code class="literal">tpf</code>. Otherwise, <code class="literal">timeOpen</code> should be reset to <code class="literal">0</code>, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">if(angle &gt; 0.1f || angle &lt; -0.1f) timeOpen += tpf;
else timeOpen = 0f;</pre></div></li><li class="listitem">If <code class="literal">timeOpen</code> is more than <code class="literal">5</code>, we begin by checking whether the door is still open. If it is, we<a id="id557" class="indexterm"/> define a speed to be the inverse of the angle and enable the door's motor to make it move in the opposite direction of its angle, as follows:<div class="informalexample"><pre class="programlisting">if(timeOpen &gt; 5) {
  float speed = angle &gt; 0 ? -0.9f : 0.9f;
  joint.enableMotor(true, speed, 0.1f);
  spatial.getControl(RigidBodyControl.class).activate();
}</pre></div></li><li class="listitem">If <code class="literal">timeOpen</code> is less than <code class="literal">5</code>, we should set the speed of the motor to <code class="literal">0</code>:<div class="informalexample"><pre class="programlisting">joint.enableMotor(true, 0, 1);</pre></div></li><li class="listitem">Now, we can create a new <code class="literal">DoorCloseControl</code> instance in the main class, attach it to the <code class="literal">doorGeometry</code> class, and give it the same joint we used previously in the recipe, as follows:<div class="informalexample"><pre class="programlisting">DoorCloseControl doorControl = new DoorCloseControl();
doorControl.setHingeJoint(joint);
doorGeometry.addControl(doorControl);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec197"/>How it works...</h2></div></div></div><p>The attachment <code class="literal">RigidBodyControl</code> has no mass and will thus not be affected by external forces such as gravity. This means it will stick to its place in the world. The door, however, has mass and would fall to the ground if the attachment didn't keep it up with it.</p><p>The <code class="literal">HingeJoint</code> class connects the two and defines how they should move in relation to each other. Using <code class="literal">Vector3f.UNIT_Y</code> means the rotation will be around the <span class="emphasis"><em>y</em></span> axis. We set the limit of the joint to be a little more than half PI in each direction. This means it will open almost 100 degrees to either side, allowing the player to step through.</p><p>When we<a id="id558" class="indexterm"/> try this out, there may be some flickering as the camera passes through the door. To get around this, there are some tweaks that can be applied. We can change the collision shape of the player. Making the collision shape bigger will result in the player hitting the wall before the camera gets close enough to clip through. This has to be done considering other constraints in the physics world.</p><p>You can consider changing the near clip distance of the camera. Decreasing it will allow things to get closer to the camera before they are clipped through. This might have implications on the camera's projection.</p><p>One thing that will not work is making the door thicker, since the triangles on the side closest to the player are the ones that are clipped through. Making the door thicker will move them even closer to the player.</p><p>In <code class="literal">DoorCloseControl</code>, we consider the door to be open if <code class="literal">hingeAngle</code> deviates a bit more from 0. We don't use 0 because we can't control the exact rotation of the joint. Instead we use a rotational force to move it. This is what we do with <code class="literal">joint.enableMotor</code>. Once the door is open for more than five seconds, we tell it to move in the opposite direction. When it's close to 0, we set the desired movement speed to 0. Simply turning off the motor, in this case, will cause the door to keep moving until it is stopped by an external force.</p><p>Once we<a id="id559" class="indexterm"/> enable the motor, we also need to call <code class="literal">activate()</code> on <code class="literal">RigidBodyControl</code> or it will not move.</p></div></div>
<div class="section" title="Building a rocket engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Building a rocket engine</h1></div></div></div><p>A rocket <a id="id560" class="indexterm"/>engine is crucial for most space-based games and many 2D games as well. In this recipe, we'll cover the minimum that is required to create a thruster that can be used in many different contexts. The following figure shows a thruster with <code class="literal">ParticleEmitter</code>:</p><div class="mediaobject"><img src="graphics/6478OS_08_04.jpg" alt="Building a rocket engine"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec198"/>Getting ready</h2></div></div></div><p>For this recipe, we need to make sure that we see the debug shapes of physics. To do this, we need to call the <code class="literal">bulletAppState.setDebugEnabled(true);</code> statement.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec199"/>How to do it...</h2></div></div></div><p>We will <a id="id561" class="indexterm"/>begin by setting up some things that are not strictly needed for the rocket engine but will aid the testing. Perform the following steps to build a rocket engine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all we add a floor mesh. For this, we create a new <code class="literal">Node</code> class called <code class="literal">ground</code>.</li><li class="listitem">To do this, we add <code class="literal">RigidBodyControl</code> with <code class="literal">PlaneCollisionShape</code>. The plane should face upwards like floors normally do, as follows:<div class="informalexample"><pre class="programlisting">RigidBodyControl floorControl = new RigidBodyControl(new PlaneCollisionShape(new Plane(new Vector3f(0, 1, 0), 0)), 0);
ground.addControl(floorControl);
floorControl.setPhysicsLocation(new Vector3f(0f, -10, 0f));</pre></div></li><li class="listitem">We then attach them both to <code class="literal">rootNode</code> of the application and <code class="literal">physicsSpace</code> of <code class="literal">bulletAppState</code>.</li><li class="listitem">Finally, we need to add a key to control the booster. For this, we implement an <code class="literal">AnalogListener</code> interface in our application.</li><li class="listitem">Then, add the application to <code class="literal">inputManager</code> along with a mapping object called boost that is bound to the Space bar:<div class="informalexample"><pre class="programlisting">inputManager.addListener(this, "boost");
inputManager.addMapping("boost", new KeyTrigger(KeyInput.KEY_SPACE));</pre></div></li><li class="listitem">Most of this recipe will be implemented in a class that extends <code class="literal">SimpleApplication</code>.</li><li class="listitem">We begin by defining a <code class="literal">Node</code> class called <code class="literal">spaceShip</code> that will be our spaceship's representation.</li><li class="listitem">We then create a <code class="literal">RigidBodyControl</code> instance with <code class="literal">BoxCollisionShape</code> and<a id="id562" class="indexterm"/> add it to the <code class="literal">spaceShip</code> node as follows:<div class="informalexample"><pre class="programlisting">RigidBodyControl control = new RigidBodyControl(new BoxCollisionShape(new Vector3f(1, 1, 1)), 1);
spaceShip.addControl(control);</pre></div></li><li class="listitem">Now, we create another <code class="literal">Node</code>, which will be our thruster. Give it the name <code class="literal">Thruster</code> to be able to identify it more easily later, as follows:<div class="informalexample"><pre class="programlisting">Node thruster = new Node("Thruster");</pre></div></li><li class="listitem">We set <code class="literal">localTranslation</code> of this so that it will end up at the bottom of the spaceship, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">thruster.setLocalTranslation(0, -1, 0);</pre></div></li><li class="listitem">Then, we attach it to the <code class="literal">spaceShip</code> node.</li><li class="listitem">Now, we have to attach the <code class="literal">spaceShip</code> node to both the <code class="literal">rootNode</code> and <code class="literal">physicsSpace</code> of <code class="literal">bulletAppState</code>.</li><li class="listitem">To control the thruster and make it more reusable, we will create a class called <code class="literal">ThrusterControl</code>, extending <code class="literal">AbstractControl</code>.</li><li class="listitem">It'll have one field, a <code class="literal">Spatial</code> field called <code class="literal">thruster</code>, that will store the <code class="literal">thruster</code> node.</li><li class="listitem">We will override the <code class="literal">setSpatial</code> method and set it by calling <code class="literal">getChild("Thruster")</code> on the supplied spatial.</li><li class="listitem">Lastly, we define a new method called <code class="literal">fireBooster()</code>.</li><li class="listitem">Inside this, we subtract the thruster's location from the spaceship's location and store it in a new <code class="literal">Vector3f</code> field called <code class="literal">direction</code> as follows:<div class="informalexample"><pre class="programlisting">Vector3f direction = spatial.getWorldTranslation().subtract(thruster.getWorldTranslation());</pre></div></li><li class="listitem">Then, we find the <code class="literal">RigidBodyControl</code> class in the spatial and call <code class="literal">applyImpulse</code> with the direction vector. We use the inverted direction as the relative position that the impulse should originate from. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">spatial.getControl(RigidBodyControl.class).applyImpulse(direction, direction.negate());</pre></div></li><li class="listitem">In the <a id="id563" class="indexterm"/>application class, we have to make it call the <code class="literal">fireBooster</code> method. We do this in the <code class="literal">onAnalog</code> method that was added when we implemented the <code class="literal">AnalogListener</code> interface:<div class="informalexample"><pre class="programlisting">if(name.equals("boost") &amp;&amp; value &gt; 0){
  spaceShip.getControl(ThrusterControl.class).fireBooster();
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec200"/>How it works...</h2></div></div></div><p>The graphics in this recipe are very minimalistic and mostly rely on the debug mode of <code class="literal">BulletAppState</code> to draw them. The physics shapes don't normally have a visual representation since they're not part of the scene graph. Using the debug mode can be very useful during early prototypes.</p><p>The <code class="literal">RigidBodyControl</code> instance of the spaceship makes sure it's affected by gravity and other forces.</p><p>The sole purpose of a thruster is to be able to easily retrieve the position that is relative to the spaceship from where the boosting force needs to be applied. This is why we place it at the bottom of the spaceship. The benefit of using the <code class="literal">Control</code> pattern to control a <code class="literal">Thruster</code> is that we can apply it to other geometries easily (and even use it in <code class="literal">SceneComposer</code>).</p><p>The <code class="literal">fireBooster</code> method of <code class="literal">ThrusterControl</code> takes the position of <code class="literal">spaceShip</code> and subtracts<a id="id564" class="indexterm"/> the position of the thruster node to get the direction <a id="id565" class="indexterm"/>of the force to apply. The relative position of the force is the direct opposite of this direction.</p></div></div>
<div class="section" title="Ballistic projectiles and arrows"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Ballistic projectiles and arrows</h1></div></div></div><p>Applying <a id="id566" class="indexterm"/>physics to arrows can greatly improve the appearance <a id="id567" class="indexterm"/>and gameplay of a medieval or fantasy game. Setting up arrows that are affected by gravity is fairly simple; this recipe, however, will also set the arrows up in a way that they always face the direction they're traveling in, making them more realistic. The following figure shows one of the arrows in flight:</p><div class="mediaobject"><img src="graphics/6478OS_08_01.jpg" alt="Ballistic projectiles and arrows"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec201"/>Getting ready</h2></div></div></div><p>For this recipe, we need to make sure that we see the debug shapes of physics. To do this, we need to call the <code class="literal">bulletAppState.setDebugEnabled(true);</code> statement.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec202"/>How to do it...</h2></div></div></div><p>In this recipe, we'll create three classes. Let's begin by looking at the <code class="literal">Arrow</code> class, which contains <a id="id568" class="indexterm"/>most of the new functionalities. This will be done in the <a id="id569" class="indexterm"/>following eight steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">Arrow</code>, extending <code class="literal">Node</code>.</li><li class="listitem">Its constructor takes two <code class="literal">Vector3f</code> variables as parameters. One of these is for the starting location of the arrow and one for the initial velocity, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">public Arrow(Vector3f location, Vector3f velocity)</pre></div></li><li class="listitem">Inside the constructor, we define a <code class="literal">Geometry</code> instance for the body of the arrow with a <code class="literal">box</code> mesh as follows:<div class="informalexample"><pre class="programlisting">Box arrowBody = new Box(0.3f, 4f, 0.3f);
Geometry geometry = new Geometry("bullet", arrowBody);</pre></div></li><li class="listitem">Then, we set <code class="literal">localTranslation</code> of <code class="literal">Geometry</code> so that one of its ends touches the center point of the node as follows:<div class="informalexample"><pre class="programlisting">geometry.setLocalTranslation(0f, -4f, 0f);</pre></div></li><li class="listitem">We set <code class="literal">localTranslation</code> of this <code class="literal">Arrow</code> as the supplied location.</li><li class="listitem">Next, we create <code class="literal">CollisionShape</code>. This will represent the head of the arrow and can be <code class="literal">SphereCollisionShape</code>, as follows:<div class="informalexample"><pre class="programlisting">SphereCollisionShape arrowHeadCollision = new SphereCollisionShape(0.5f);</pre></div></li><li class="listitem">Now, we define <code class="literal">RigidBodyControl</code> based on <code class="literal">CollisionShape</code>, as follows:<div class="informalexample"><pre class="programlisting">RigidBodyControl rigidBody = new RigidBodyControl(arrowHeadCollision, 1f);</pre></div></li><li class="listitem">We set <code class="literal">LinearVelocity</code> of <code class="literal">RigidBodyControl</code> to be the supplied velocity and add it as a Control to Arrow, as follows:<div class="informalexample"><pre class="programlisting">rigidBody.setLinearVelocity(velocity);
addControl(rigidBody);</pre></div></li></ol></div><p>This would be <a id="id570" class="indexterm"/>enough for the arrow to follow the laws of physics; however, it will always face the forward direction. By adding another control, we can make it <a id="id571" class="indexterm"/>face the direction of the velocity. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create another class called <code class="literal">ArrowFacingControl</code>, extending <code class="literal">AbstractControl</code>.</li><li class="listitem">We add a <code class="literal">Vector3f</code> field called <code class="literal">direction</code>.</li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we get <code class="literal">linearVelocity</code> from <code class="literal">RigidBodyControl</code> of the spatial and normalize it. We then store it in <code class="literal">direction</code> as follows:<div class="informalexample"><pre class="programlisting">direction = spatial.getControl(RigidBodyControl.class).getLinearVelocity().normalize();</pre></div></li><li class="listitem">Then, call the spatial and tell it to rotate to the supplied <code class="literal">direction</code> vector as follows:<div class="informalexample"><pre class="programlisting">spatial.rotateUpTo(direction);</pre></div></li><li class="listitem">In the constructor of the <code class="literal">Arrow</code> class, we add an instance of this control, as follows:<div class="informalexample"><pre class="programlisting">addControl(new ArrowFacingControl());</pre></div></li></ol></div><p>The last section handles the firing of the arrow from <code class="literal">SimpleApplication</code>. This can be done with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need to implement <code class="literal">ActionListener</code> in the application.</li><li class="listitem">Add the <code class="literal">ActionListener</code> class to <code class="literal">inputManager</code> as a listener, together with a key for firing arrows, as follows:<div class="informalexample"><pre class="programlisting">inputManager.addListener(this, "fire");
inputManager.addMapping("fire", new KeyTrigger(KeyInput.KEY_SPACE));</pre></div></li><li class="listitem">In the <code class="literal">onAction</code> method, call a new method called <code class="literal">fireArrow</code> when the <code class="literal">fire</code> button is released. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">if (action.equals("fire") &amp;&amp; !isPressed) fireArrow();</pre></div></li><li class="listitem">The <code class="literal">fireArrow</code> method should begin by instancing a new <code class="literal">Arrow</code> instance and <a id="id572" class="indexterm"/>applying a (preloaded) material to it, as<a id="id573" class="indexterm"/> follows:<div class="informalexample"><pre class="programlisting">Arrow arrow = new Arrow(new Vector3f(0f, 6f, -10f), new Vector3f(0.5f, 0.5f, 0.0f).mult(50));
arrow.setMaterial(matBullet);</pre></div></li><li class="listitem">We attach it to <code class="literal">rootNode</code> as well as to <code class="literal">physicsSpace</code>, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">rootNode.attachChild(arrow);
getPhysicsSpace().add(arrow);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec203"/>How it works...</h2></div></div></div><p>The <code class="literal">Arrow</code> object has two major components. One is <code class="literal">Geometry</code>, which is a simple elongated box. The other is <code class="literal">CollisionShape</code> for the head of the arrow, which is the only thing that will look for collisions. The geometry is conveniently moved so that its tip will be at the (0,0,0) position of the <code class="literal">Arrow</code> node. It is convenient since it means we don't have to do any conversions in <code class="literal">ArrowFacingControl</code> but can use <code class="literal">rotateUpTo</code> with the actual velocity (direction) of the arrow.</p></div></div>
<div class="section" title="Handling multiple gravity sources"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec84"/>Handling multiple gravity sources</h1></div></div></div><p>Some games require handling gravity from multiple variable sources. In this recipe, we'll handle <a id="id574" class="indexterm"/>this and create a simple miniature solar system to demonstrate it using <code class="literal">ThrusterControl</code> from the <span class="emphasis"><em>Building a rocket engine</em></span> recipe. To (greatly) simplify the relation between the planets, they won't affect each other with their gravity, but only the ship. It will also be made in a 2D-asteroids-like fashion, although the gravity would still apply for a 3D game.</p><p>We'll add some basic controls to rotate the ship to the left and right, and you can use the thruster to make the ship move forward.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec204"/>How to do it...</h2></div></div></div><p>Apart from <code class="literal">ThrusterControl</code>, we'll create two more small classes and an application class that joins everything together. Let's start with a class that represents the player's ship. This will consist of the following six steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">SpaceShip</code>, which has a <code class="literal">Node</code> field called <code class="literal">shipNode</code> in it.</li><li class="listitem">In the constructor, we set up the physics for it by creating a new <code class="literal">RigidBodyControl</code> instance with <code class="literal">BoxCollisionShape</code>. To create it in a way that it is affected by gravity, we also give it a mass of <code class="literal">1</code> that will be supplied in the constructor as follows:<div class="informalexample"><pre class="programlisting">RigidBodyControl control = new RigidBodyControl(new BoxCollisionShape(new Vector3f(1, 1, 1)), 1);
shipNode.addControl(control);</pre></div></li><li class="listitem">Now, we create a <code class="literal">Node</code> instance called <code class="literal">thruster</code>. We also set the name of <code class="literal">Node</code> to <code class="literal">Thruster</code> for the control to find it automatically, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">Node thruster = new Node("Thruster");</pre></div></li><li class="listitem">We set <code class="literal">localTranslation</code> to be at one of the sides of the spaceship and attach it to <code class="literal">shipNode</code>, as follows:<div class="informalexample"><pre class="programlisting">thruster.setLocalTranslation(-1, 0, 0);
shipNode.attachChild(thruster);</pre></div></li><li class="listitem">Then, we rotate the ship's spatial so that it's facing sideways:<div class="informalexample"><pre class="programlisting">shipNode.rotate(0, FastMath.PI, 0);</pre></div></li><li class="listitem">Finally, we add a new <code class="literal">ThrusterControl</code> instance to the spaceship's spatial.</li></ol></div><p>That's it for <a id="id575" class="indexterm"/>the <code class="literal">SpaceShip</code> class. Now, we create a class for our planets, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start off by defining a class called <code class="literal">StellarBody</code>, which extends <code class="literal">AbstractControl</code>. The <code class="literal">StellarBody</code> class has four float fields: <code class="literal">size</code>, <code class="literal">speed</code>, <code class="literal">orbit</code>, and <code class="literal">cycle</code>.</li><li class="listitem">The constructor takes three of these (<code class="literal">size</code>, <code class="literal">speed</code>, and <code class="literal">orbit</code>) as the input, as shown in the following code:<div class="informalexample"><pre class="programlisting">public StellarBody(float orbit, float speed, float size)</pre></div></li><li class="listitem">We override the <code class="literal">setSpatial</code> method and add <code class="literal">RigidBodyControl</code> to the supplied spatial with <code class="literal">SphereCollisionShape</code>, using <code class="literal">size</code> as the radius and <code class="literal">0</code> for mass:<div class="informalexample"><pre class="programlisting">RigidBodyControl rigidBody = new RigidBodyControl(new SphereCollisionShape(size), 0f);
rigidBody.setGravity(Vector3f.ZERO);
spatial.addControl(rigidBody);</pre></div></li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we make it move along its orbit by increasing the speed of the cycle by multiplying it by <code class="literal">tpf</code>, as follows:<div class="informalexample"><pre class="programlisting">cycle += (speed * tpf)  % FastMath.TWO_PI;</pre></div></li><li class="listitem">Then, we set the actual position of the planet along the orbit using the <code class="literal">sin</code> and <code class="literal">cos</code> methods of the <code class="literal">FastMath</code> class:<div class="informalexample"><pre class="programlisting">float x = FastMath.sin(cycle);
float z = FastMath.cos(cycle);</pre></div></li><li class="listitem">We<a id="id576" class="indexterm"/> multiply the result by the orbit and set <code class="literal">localTranslation</code> of the spatial to the new location as follows:<div class="informalexample"><pre class="programlisting">spatial.setLocalTranslation(x * orbit, 0, z * orbit);</pre></div></li><li class="listitem">Then, we also need to set <code class="literal">physicsLocation</code> of <code class="literal">RigidBodyControl</code> to the same location.</li><li class="listitem">We need a new method, <code class="literal">getGravity</code>, that will take the position of the ship as an input <code class="literal">Vector3f</code>.</li><li class="listitem">The method begins by subtracting the input position by <code class="literal">worldTranslation</code>, to get the position of the ship relative to the <code class="literal">StellarBody</code> class, as follows:<div class="informalexample"><pre class="programlisting">Vector3f relativePosition = spatial.getWorldTranslation().subtract(position);</pre></div></li><li class="listitem">The result is normalized and then modified by a formula to get a suitable gravity. This value is returned to the calling method, as follows:<div class="informalexample"><pre class="programlisting">relativePosition.normalizeLocal();
return relativePosition.multLocal(size * 1000 / relativePosition.lengthSquared());</pre></div></li></ol></div><p>To test all of this, we need to add a few things to <code class="literal">SimpleApplication</code>. To do this, perform the following set of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we implement <code class="literal">AnalogListener</code>.</li><li class="listitem">We add an <code class="literal">ArrayList&lt;StellarBody&gt;</code> list called <code class="literal">gravitationalBodies</code>.</li><li class="listitem">In the <code class="literal">simpleInitApp</code> method, we should begin by initializing <code class="literal">bulletAppState</code> and set up some controls for the spaceship. We add actions to rotate the spaceship to the left and right as well as fire the ship's thruster, as follows:<div class="informalexample"><pre class="programlisting">String[] mappings = new String[]{"rotateLeft", "rotateRight", "boost"};
inputManager.addListener(this, mappings);
inputManager.addMapping("boost", new KeyTrigger(KeyInput.KEY_SPACE));
inputManager.addMapping("rotateLeft", new KeyTrigger(KeyInput.KEY_LEFT));
inputManager.addMapping("rotateRight", new KeyTrigger(KeyInput.KEY_RIGHT));</pre></div></li><li class="listitem">Since it's a<a id="id577" class="indexterm"/> 2D representation, we move the camera some distance up and make it look as if it is at the center of the world. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">cam.setLocation(new Vector3f(0, 300f, 0));
cam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);</pre></div></li><li class="listitem">We create an instance called <code class="literal">ship</code> of <code class="literal">SpaceShip</code> and attach its geometry to <code class="literal">rootNode</code> and <code class="literal">physicsSpace</code> of <code class="literal">bulletAppState</code>.</li><li class="listitem">Now we can create a number of <code class="literal">StellarBody</code> instances using the following steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For each instance, we should create a <code class="literal">Geometry</code> class with a <code class="literal">Sphere</code> shape that will have the same radius as the size we will supply to the <code class="literal">StellarBody</code> control.</li><li class="listitem">The <code class="literal">Geometry</code> class should both be attached to <code class="literal">rootNode</code> and <code class="literal">physicsSpace</code> of <code class="literal">bulletAppState</code>.</li><li class="listitem">We add <code class="literal">StellarBody</code> as a control to the <code class="literal">Geometry</code> class and the <code class="literal">gravitationalBodies</code> list.</li></ol></div></li><li class="listitem">Inside the <code class="literal">update</code> method, we have to take into account the gravity of the <code class="literal">StellarBody</code> instances. </li><li class="listitem">First, we define a new <code class="literal">Vector3f</code> instance called <code class="literal">combinedGravity</code>.</li><li class="listitem">Then, we loop through our <code class="literal">gravitationalBodies</code> list and apply the following line of code to apply the gravity to <code class="literal">combinedGravity</code>:<div class="informalexample"><pre class="programlisting">combinedGravity.addLocal(body.getGravity(ship.getSpatial().getWorldTranslation()));</pre></div></li><li class="listitem">Finally, we call the <code class="literal">ship.setGravity(combinedGravity);</code> statement.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec205"/>How it works...</h2></div></div></div><p>Due to the <a id="id578" class="indexterm"/>extreme difficulty in creating a stable solar system with more than three bodies, <code class="literal">StellarBody</code> controls the need to have a static orbit around the center of the system. Using <code class="literal">0</code> as mass ensures that they aren't affected by gravity. The orbit field represents the orbit's distance from the center of the system, and it will rotate around the center using speed as a factor. The cycle field stores information on how far along its orbit it has come, and will reset once it reaches two PI (a full circle).</p><p>The <code class="literal">getGravity</code> method returns the gravity relative to the position that is supplied, which in this <a id="id579" class="indexterm"/>case is the location of the ship. It first determines the direction and then applies the gravity based on the distance between the two.</p><p>By using the <code class="literal">gravitationalBodies</code> list, we have a dynamic way to simply add up all the gravitational forces in the system to a single <code class="literal">Vector3f</code> object, which we then apply to the spaceship in the <code class="literal">update</code> method of the application.</p></div></div>
<div class="section" title="Self-balancing using RotationalLimitMotors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec85"/>Self-balancing using RotationalLimitMotors</h1></div></div></div><p>Many games today use a blend of animations and physics to create realistic movement. For<a id="id580" class="indexterm"/> animated characters, this revolves<a id="id581" class="indexterm"/> around balance. It could take the shape of a runner who leans inwards through a curve to counter the centrifugal force. Creating a system like this is not easy and requires a lot of tweaking. In this recipe, we'll look into some of the fundamentals of this, and we'll create a new <code class="literal">Control</code> class that will try to balance itself using the rotational motors of <code class="literal">SixDofJoint</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<span class="strong"><strong>Six Degrees of Freedom</strong></span> (<span class="strong"><strong>SixDof</strong></span>) relates<a id="id582" class="indexterm"/> to the six ways the joint can rotate: +x, -x, +y, -y, +z, and -z. One way it differs from a <code class="literal">point2point</code> joint is that in addition, it also has motors for each axis, which makes it possible for it to also apply force.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec206"/>How to do it...</h2></div></div></div><p>To simulate balancing, we will begin by creating the upper body of a stickman-shape figure with a torso and two rigid arms. To do this, perform the following set of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we should set up an application with <code class="literal">BulletAppState</code>.</li><li class="listitem">In the <code class="literal">simpleInitApp</code> method, we create a small square <code class="literal">Box Geometry</code> to be the waist of the character. It can be <code class="literal">0.25f</code> in all the axes.</li><li class="listitem">We add <code class="literal">RigidBodyControl</code> to it with <code class="literal">0</code> in mass since it shouldn't move.</li><li class="listitem">Then, we create an oblong box to be the torso and place it above the waist. It should have <code class="literal">RigidBodyControl</code> with <code class="literal">1</code> in mass and <code class="literal">BoxCollisionShape</code> should be of the same size as the geometry:<div class="informalexample"><pre class="programlisting">torso = new Geometry("Torso", new Box(0.25f, 2f, 0.25f);
RigidBodyControl torsoRigidBody = new RigidBodyControl(new BoxCollisionShape(...), 1f);
...
torsoRigidBody.setPhysicsLocation(new Vector3f(0, 4.25f, 0));</pre></div></li><li class="listitem">Next, we create <code class="literal">SixDofJoint</code> between the waist and torso and afterwards add it to <code class="literal">physicsSpace</code> as follows:<div class="informalexample"><pre class="programlisting">SixDofJoint waistJoint =  new SixDofJoint(waistRigidBody, torsoRigidBody, new Vector3f(0, 0.25f, 0), new Vector3f(0, -2.25f, 0f), true);</pre></div></li><li class="listitem">We <a id="id583" class="indexterm"/>should limit the joint so<a id="id584" class="indexterm"/> that it can't rotate on any axes other than the <span class="emphasis"><em>x</em></span> axis, and it shouldn't be able to rotate too much. We can use the following <code class="literal">setAngularLowerLimit</code> and <code class="literal">setAngularUpperLimit</code> methods for this:<div class="informalexample"><pre class="programlisting">waistJoint.setAngularLowerLimit(new Vector3f(-FastMath.QUARTER_PI * 0.3f, 0, 0));
waistJoint.setAngularUpperLimit(new Vector3f(FastMath.QUARTER_PI * 0.3f, 0, 0));</pre></div></li><li class="listitem">Next, we create one of the arms.</li><li class="listitem">We create one of the arms by placing it at the same location as that of the torso and giving it a size of <code class="literal">Vector3f(0.25f, 0.25f, 2f)</code>, making it stretch out sideways, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">leftArm = new Geometry("Left Arm", new Box(0.25f, 0.25f, 2f);
RigidBodyControl leftArmRigidBody = new RigidBodyControl(new BoxCollisionShape(...), 1f);
...
leftArmRigidBody.setPhysicsLocation(new Vector3f(0, 4.25f, 0));</pre></div></li><li class="listitem">We create another <code class="literal">SixDofJoint</code> for it using the pivot points of <code class="literal">Vector3f(0, 2.5f, 0.25f)</code> and <code class="literal">Vector3f(0, 0, -2.5f)</code>, offsetting it some distance to the side of the torso's spatial.</li><li class="listitem">Then, we set the angular limits of the joint to <code class="literal">Vector3f(0, 0, 0)</code> and <code class="literal">Vector3f(FastMath.QUARTER_PI, 0, 0)</code>.</li><li class="listitem">We repeat the previous three steps to create the opposite arm, but we'll reverse the offset values to make the arm protrude in the opposite direction of the torso.</li></ol></div><p>We now <a id="id585" class="indexterm"/>have the basics done for our recipe. Running<a id="id586" class="indexterm"/> it should show the character slumping to one side with the arms stretched out to the sides. Now, we can begin with balancing by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">BalanceControl</code>, extending <code class="literal">AbstractControl</code>.</li><li class="listitem">It should have a <code class="literal">SixDofJoint</code> field called <code class="literal">joint</code> and a <code class="literal">RotationalLimitMotor</code> field called <code class="literal">motorX</code>.</li><li class="listitem">Create a <code class="literal">setJoint</code> method.</li><li class="listitem">Inside this method, after setting the joint, we also populate <code class="literal">motorX</code> with one of the <code class="literal">RotationalLimitMotor</code> instances, as follows:<div class="informalexample"><pre class="programlisting">motorX = joint.getRotationalLimitMotor(0);</pre></div></li><li class="listitem">Inside the <code class="literal">controlUpdate</code> method, we get <code class="literal">bodyA</code> from the joint and store it in <code class="literal">PhysicsRigidBody</code>. This is the torso:<div class="informalexample"><pre class="programlisting">PhysicsRigidBody bodyA = joint.getBodyA();</pre></div></li><li class="listitem">We get the current rotation of <code class="literal">bodyA</code> to see how much it pivots. We then convert the rotation to angles and store them as follows:<div class="informalexample"><pre class="programlisting">float[] anglesA = new float[3];
bodyA.getPhysicsRotation().toAngles(anglesA);</pre></div></li><li class="listitem">We then store <code class="literal">angles[0]</code> in a float variable called <code class="literal">x</code>.</li><li class="listitem">If <code class="literal">x</code> is more than 0.01f or less than -0.01, we should start <code class="literal">motorX</code> and rotate it to compensate for the pivot, as follows:<div class="informalexample"><pre class="programlisting">motorX.setEnableMotor(true);
motorX.setTargetVelocity(x*1.1f);
motorX.setMaxMotorForce(13.5f);</pre></div></li><li class="listitem">Otherwise, we turn off the motor as follows:<div class="informalexample"><pre class="programlisting">motorX.setTargetVelocity(0);
motorX.setMaxMotorForce(0);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec207"/>How it works...</h2></div></div></div><p>Running the<a id="id587" class="indexterm"/> result, we should see the<a id="id588" class="indexterm"/> stickman desperately trying to stay upright while flailing his arms up and down. The reason is that getting the forces right when balancing can be very difficult. With values that are too high, the stickman will constantly overshoot the target and instead rotate in the other direction. With values that are too low, it won't have the strength to get upright. With some further tweaking to <code class="literal">targetVelocity</code> and <code class="literal">maxMotorForce</code>, we might be able make him stable.</p><p>We started by creating the basic shape of a figure that would try to keep the balance. The waist was made to not be affected by the physics, so it could be a solid point. We then added a torso and two arms, resulting in a center of mass somewhere in the upper part of the torso. By placing each of the body parts at some distance from each other with the joints, we give them more freedom of movement.</p><p>The <code class="literal">BalanceControl</code> class we created has one simple strategy. It looks for the torso (bodyA)'s rotation along the <span class="emphasis"><em>x</em></span> axis, and tries to keep it as close to 0 as possible. If it notices that it's anything but near 0, it will try to move the arms, shifting the center of the mass to the opposite direction.</p><p>Despite the low number of components, getting it all to balance out is really difficult! Having more components, such as a whole human skeleton, requires a much more advanced<a id="id589" class="indexterm"/> strategy, with body parts <a id="id590" class="indexterm"/>moving in a synchronized fashion, rather than they trying to do so individually.</p></div></div>
<div class="section" title="The principles of a bridge-building game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec86"/>The principles of a bridge-building game</h1></div></div></div><p>Variants of bridge-building games have been around for a long time. The classical <span class="emphasis"><em>Bridge Builder</em></span> is a <a id="id591" class="indexterm"/>2D physics game where the player is required connect beams to create a bridge strong enough for a train (or some other moving object) to pass.</p><p>This recipe will describe most of the core functionalities needed to create such a game, including making the objects stay 2D and not wander off on the <span class="emphasis"><em>z</em></span> axis.</p><p>We'll have <a id="id592" class="indexterm"/>some basic controls for the game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Left-click will select a previously built node in the bridge</li><li class="listitem" style="list-style-type: disc">Right-click will add a new node or connect two previously built ones</li><li class="listitem" style="list-style-type: disc">The Space bar will turn on the physics</li></ul></div><p>The following figure shows a bridge:</p><div class="mediaobject"><img src="graphics/6478OS_08_02.jpg" alt="The principles of a bridge-building game"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec208"/>Getting ready</h2></div></div></div><p>Before <a id="id593" class="indexterm"/>we begin with more physics-related functions, we should set up the basic application.</p><p>First of all, we create a new class that extends <code class="literal">SimpleApplication</code>.</p><p>Later on, we're going to use the following two lists:</p><div class="informalexample"><pre class="programlisting">private List&lt;Geometry&gt; segments;
private List&lt;Point2PointJoint&gt; joints;</pre></div><p>We also need some strings as input mappings: <code class="literal">LEFT_CLICK</code>, <code class="literal">RIGHT_CLICK</code>, and <code class="literal">TOGGLE_PHYSICS</code>.</p><p>We add a <code class="literal">RigidBodyControl</code> field called <code class="literal">selectedSegment</code> that will contain the last selected segment in the game.</p><p>Since we're strictly making a 2D game, we should change the camera to be orthographic. This can be<a id="id594" class="indexterm"/> done by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Disable <code class="literal">flyCam</code>.</li><li class="listitem">Find out the aspect ratio by dividing the <code class="literal">cam</code> width by its height and storing it.</li><li class="listitem">Set <code class="literal">cam.parallelProjection</code> to <code class="literal">true</code>.</li><li class="listitem">Then, change <code class="literal">frustrum</code> of the camera to suit and orthographic view as follows:<div class="informalexample"><pre class="programlisting">cam.setFrustum(1, 1000, -100 * aspect, 100 * aspect, 100, -100);</pre></div></li><li class="listitem">We move it some way along the <span class="emphasis"><em>z</em></span> axis and rotate it back towards the center, as follows:<div class="informalexample"><pre class="programlisting">cam.setLocation(new Vector3f(0, 0, 20));
cam.setRotation(new Quaternion().fromAngles(new float[]{0,-FastMath.PI,0}));</pre></div></li></ol></div><p>Now, we can initialize <code class="literal">bulletAppState</code> as we usually do. Turn on the debug mode, and most importantly, set <code class="literal">speed</code> to <code class="literal">0</code>. We don't want any physics on while we build the bridge.</p><p>The world needs a gap to be bridged. So, for this, we'll use <code class="literal">RigidBodyControl</code> to represent two cliffs, one on either side, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create one <code class="literal">RigidBodyControl</code> instance for each side and give it <code class="literal">BoxCollisionShape</code> with a size of <code class="literal">Vector3f(75f, 50f, 5f)</code> and <code class="literal">0</code> mass.</li><li class="listitem">Place one of them at <code class="literal">Vector3f(-100f, -50f, 0)</code> and the other one at <code class="literal">Vector3f(100f, -50f, 0)</code>.</li><li class="listitem">Then, add them to <code class="literal">physicsSpace</code>.</li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec209"/>How to do it...</h2></div></div></div><p>We're going to start by creating two methods that will help us add new bridge segments to the game:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We define a method called <code class="literal">createSegment</code> that takes a <code class="literal">Vector3f</code> parameter called <code class="literal">location</code> as the input.</li><li class="listitem">The first thing we do is set the <code class="literal">z</code> value of <code class="literal">location</code> to <code class="literal">0</code>. This is because we're making a 2D game.</li><li class="listitem">Then, we <a id="id595" class="indexterm"/>create a new <code class="literal">RigidBodyControl</code> instance called <code class="literal">newSegment</code>. We add <code class="literal">SphereCollisionShape</code> to it and then add <code class="literal">newSegment</code> to <code class="literal">physicsSpace</code>. It's important that it has some mass. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">RigidBodyControl newSegment = new RigidBodyControl(new SphereCollisionShape(1f), 5);
bulletAppState.getPhysicsSpace().add(newSegment);</pre></div></li><li class="listitem">Now, we create a <code class="literal">Geometry</code> instance based on a <code class="literal">Sphere</code> shape with the same radius as <code class="literal">RigidBodyControl</code>. We will use this as a target for mouse clicks.</li><li class="listitem">The <code class="literal">Geometry</code> object needs <code class="literal">modelBound</code> for which we'll use <code class="literal">BoundingSphere</code>. The radius may be bigger than <code class="literal">RigidBodyControl</code>.</li><li class="listitem">The <code class="literal">RigidBodyControl</code> object is added to <code class="literal">Geometry</code> as a control and we use the <code class="literal">setPhysicsLocation</code> method to move it to the to the supplied location, as follows:<div class="informalexample"><pre class="programlisting">geometry.addControl(newSegment);
newSegment.setPhysicsLocation(location);</pre></div></li><li class="listitem">The <code class="literal">Geometry</code> object is then added to the segments list we defined earlier and then it is attached to <code class="literal">rootNode</code>.</li><li class="listitem">If <code class="literal">selectedSegment</code> is not null, we will call a method we will define next:<div class="informalexample"><pre class="programlisting">createJoint(selectedJoint, newSegment);</pre></div></li><li class="listitem">Lastly, in the <code class="literal">createJoint</code> method, we set <code class="literal">selectedSegment</code> to be <code class="literal">newSegment</code>.</li><li class="listitem">Now, we can define the <code class="literal">createJoint</code> method. It takes two <code class="literal">RigidBodyControl</code> parameters as the input, as shown in the following code:<div class="informalexample"><pre class="programlisting">createJoint(RigidBodyControl body1, RigidBodyControl body2)</pre></div></li><li class="listitem">First, we <a id="id596" class="indexterm"/>find out the location that should be the pivot point of <code class="literal">body2</code>. This is the same as <code class="literal">physicsLocation</code> of <code class="literal">body2</code> subtracted from <code class="literal">physicsLocation</code> of <code class="literal">body1</code>, as follows:<div class="informalexample"><pre class="programlisting">Vector3f pivotPointB = body1.getPhysicsLocation().subtract(body2.getPhysicsLocation());</pre></div></li><li class="listitem">Then, we define <code class="literal">Point2PointJoint</code> by joining the two segments. The vectors supplied mean that <code class="literal">body2</code> will pivot in a way that is relative to <code class="literal">body1</code>; we do this using the following code:<div class="informalexample"><pre class="programlisting">Point2PointJoint joint = new Point2PointJoint(body1, body2, Vector3f.ZERO, pivotPointB);</pre></div></li><li class="listitem">We then add the newly created joint to the <code class="literal">joints</code> list and to <code class="literal">physicsSpace</code>.</li></ol></div><p>We're now getting to the controls of the application and need another method to help us. The method will check whether a mouse click has hit any segment and return it. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We define a new method called <code class="literal">checkSelection</code>, which returns <code class="literal">RigidBodyControl</code>.</li><li class="listitem">Inside this method, we create a new <code class="literal">Ray</code> instance, which will have the current mouse cursor's location as the origin; the following code tells you how to do this:<div class="informalexample"><pre class="programlisting">Ray ray = new Ray();
ray.setOrigin(cam.getWorldCoordinates(inputManager.getCursorPosition(), 0f));</pre></div></li><li class="listitem">Since the view is orthographic, we let the direction be <code class="literal">Vector3f(0, 0, -1f)</code>.</li><li class="listitem">Now, we define a new <code class="literal">CollisionResults</code> instance to store any segments that <code class="literal">Ray</code> collides with.</li><li class="listitem">The next thing we do is parse through the segment's list and check whether the ray hits any of them.</li><li class="listitem">If it does, we're done, and then return <code class="literal">RigidBodyControl</code> of segment to the calling method.</li></ol></div><p>We defined<a id="id597" class="indexterm"/> a couple of input mappings earlier. Now, we can all implement the functionality for them in the <code class="literal">onAction</code> method by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the left mouse button is clicked, we should call <code class="literal">checkSelection</code>. If the returned value is not null, we should set <code class="literal">selectedSegment</code> to that value, as follows:<div class="informalexample"><pre class="programlisting">if (name.equals(LEFT_CLICK) &amp;&amp; !isPressed) {
  RigidBodyControl newSelection = checkSelection();
  if (newSelection != null) {
    selectedSegment = newSelection;
  }
}</pre></div></li><li class="listitem">If the right mouse button is clicked, we should also call <code class="literal">checkSelection</code>. If the returned value is not null and it's not <code class="literal">selectedSegment</code>, we call <code class="literal">createJoint</code> with <code class="literal">selectedSegment</code> and the value of <code class="literal">checkSelection</code> to create a link between <code class="literal">selectedSegment</code> and the segment returned from the method, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">else if (name.equals(RIGHT_CLICK) &amp;&amp; !isPressed) {
  RigidBodyControl hitSegment = checkSelection();
  if (hitSegment != null &amp;&amp; hitSegment != selectedSegment) {
    createJoint(selectedSegment, hitSegment);
  }</pre></div></li><li class="listitem">Otherwise, if we didn't hit anything, we call <code class="literal">createSegment</code> with the position of the mouse cursor to create a new segment at that location as follows:<div class="informalexample"><pre class="programlisting">createSegment(cam.getWorldCoordinates(inputManager.getCursorPosition(), 10f));</pre></div></li><li class="listitem">If the <a id="id598" class="indexterm"/>Space bar has been pressed, all we need to do is set the speed of <code class="literal">bulletAppState</code> to <code class="literal">1</code> to start the physics.</li></ol></div><p>We're almost done with our simulation now, but we need to do a few more things. This last section will handle the <code class="literal">update</code> method and what happens when the physics is running and the bridge is being tested:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In<a id="id599" class="indexterm"/> the <code class="literal">update</code> method, we parse through all the items in the segment list and set the <code class="literal">z</code> value of <code class="literal">linearVelocity</code> to <code class="literal">0</code>, as follows:<div class="informalexample"><pre class="programlisting">Vector3f velocity = segment.getControl(RigidBodyControl.class).getLinearVelocity();
velocity.setZ(0);
segment.getControl(RigidBodyControl.class).setLinearVelocity(velocity);</pre></div></li><li class="listitem">After this, we parse through all the items in the joint's list. For each, we should check whether the joint's <code class="literal">appliedImpulse</code> value is higher than a value, let's say <code class="literal">10</code>. If it is, the joint should be removed from the list as well as from <code class="literal">physicsSpace</code>, as follows:<div class="informalexample"><pre class="programlisting">Point2PointJoint p = joints.get(i);
  if (p.getAppliedImpulse() &gt; maxImpulse) {
    bulletAppState.getPhysicsSpace().remove(p);
    joints.remove(p);

  }</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec210"/>How it works...</h2></div></div></div><p>The <code class="literal">createSegment</code> method<a id="id600" class="indexterm"/> creates a new bridge segment that is sphere shaped, both in <code class="literal">physicsSpace</code> and the visible world. This is the part that has a mass and can be selected by clicking on it, since <code class="literal">Ray</code> only collides with spatials.</p><p>The <code class="literal">createJoint</code> method<a id="id601" class="indexterm"/> creates the visible connection between the newly created segment, and the currently selected one. It does this using <code class="literal">Point2PointJoin</code>t. This is different from, for example, <code class="literal">HingeJoint</code>, since it's not fixed in space, when several <code class="literal">Point2Pointjoints</code> are connected and you have something that resembles a bridge.</p><p>The mouse selection is covered more in depth in other chapters, but it works by shooting <code class="literal">Ray</code> from the mouse's position on the screen, inwards into the game world. Once <code class="literal">Ray</code> hits <code class="literal">Geometry</code> (which has <code class="literal">BoundingSphere</code> that is slightly larger than the visible mesh for increased selectability), the corresponding <code class="literal">RigidBodyControl</code> will be selected.</p><p>There's no challenge in a bridge-building game if the segments don't have a maximum force they <a id="id602" class="indexterm"/>can handle before they break. This is what we take care of in the <code class="literal">update</code> method where we check <code class="literal">appliedImpulse</code> on each segment. If it goes above a certain threshold, it can be considered to be overloaded and removed, often with disastrous results. We also set <code class="literal">linearVelocity</code> along the <span class="emphasis"><em>z</em></span> axis on each segment to <code class="literal">0</code> since it's a 2D game and we don't want anything to move to the depth layer.</p><p>We start the game with the physics simulation off by setting the speed of <code class="literal">bulletAppState</code> to <code class="literal">0</code>. Without doing so, building the game will get tricky pretty fast as everything will fall down. Pressing the Space bar will start the physics, and let the player know whether their engineering skills are up to par.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec211"/>There's more…</h2></div></div></div><p>There are a couple of things missing from the recipe to make it a full-blown bridge builder. First of all, there is usually a limit to the length the segments can have. There might also be a grid structure along which they have to be placed.</p><p>It's also quite easy since the bridge currently only has to support its own weight. In a full game, the difficulty is usually increased by adding a heavier object that needs to pass the bridge to complete the level.</p><p>Add some monetary constraints to this or a varied terrain and you have a challenging game.</p></div></div>
<div class="section" title="Networked physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Networked physics</h1></div></div></div><p>This recipe will go into something of a final frontier in game development. The topic is extremely application-dependent, and it is difficult to get right. Hopefully, after going through this recipe, you will have a basic framework in place that can be adapted to specific projects.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec212"/>Getting ready</h2></div></div></div><p>This recipe is <a id="id603" class="indexterm"/>for those who have a fundamental understanding of both <a class="link" href="ch07.html" title="Chapter 7. Networking with SpiderMonkey">Chapter 7</a>, <span class="emphasis"><em>Networking with SpiderMonkey</em></span>, and <a class="link" href="ch08.html" title="Chapter 8. Physics with Bullet">Chapter 8</a>, <span class="emphasis"><em>Physics with Bullet</em></span>. This recipe will describe how to implement networked physics in the networked fps that was discussed previously in the book. Since this is built on top of the existing framework, an <code class="literal">AppState</code> pattern has been chosen to isolate as much of the physics code as possible. There will be some overlapping, though.</p><p>Physics can be expensive as it is and has its own problems and requirements. Sending translations and rotations for objects over the network with every tick will seriously affect the bandwidth load. The ground rule is this: send only what you must.</p><p>Divide physics objects into those that you're interested in sharing and those that you don't. In most games, this means separating those that affect the gameplay and those that don't.</p><p>For example, a meter-sized crate that can be climbed upon will definitely affect the gameplay. It has to be networked.</p><p>A bucket that can be kicked or small debris from an explosion do not affect the gameplay and should only have local physics. It doesn't matter if they show up in different places for different players.</p><p>The second part of the rule is this: send only when you must. There's no point in sending an update for an object that is not moving.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec213"/>How to do it...</h2></div></div></div><p>Based on<a id="id604" class="indexterm"/> the first rule, we'll start by defining a new <code class="literal">Control</code> class for our networked physics objects:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">PhysicsObjectControl</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">It should have two fields: a Boolean field called <code class="literal">serverControlled</code> and an integer field called <code class="literal">id</code>.</li></ol></div><p>We now <a id="id605" class="indexterm"/>define a network message to handle updates to objects with physics:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's call it <code class="literal">PhysicsObjectMessage</code> and have it extend <code class="literal">AbstractMessage</code>.</li><li class="listitem">There are three mandatory fields for it; they are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first is an integer field called <code class="literal">objectId</code></li><li class="listitem" style="list-style-type: disc">It also needs a <code class="literal">Vector3f</code> field called <code class="literal">translation</code></li><li class="listitem" style="list-style-type: disc">Finally, we add a <code class="literal">Quaternion</code> field called <code class="literal">rotation</code></li></ul></div></li><li class="listitem">Don't forget to add the <code class="literal">@Serializable</code> annotation, and add it to the list of messages in the <code class="literal">GameUtil</code> class!</li><li class="listitem">The last common implementation we do is for the <code class="literal">Game</code> class where we add a list of <code class="literal">Spatials</code> called <code class="literal">physicsObjects</code>; the following code tells us how to do this:<div class="informalexample"><pre class="programlisting">private Map&lt;Integer, Spatial&gt; physicsObjects = new HashMap&lt;Integer, Spatial&gt;();</pre></div></li></ol></div><p>Now, we can dig<a id="id606" class="indexterm"/> into the server-side implementation by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We contain most of the code in a new <code class="literal">AppState</code> class called <code class="literal">ServerPhysicsAppState</code>. This <code class="literal">AppState</code> class will contain the reference to the <code class="literal">BulletAppState</code> class, and it will handle the initialization.</li><li class="listitem">Inside its <code class="literal">initialize</code> method, it should add the loaded level to <code class="literal">physicsSpace</code> as follows:<div class="informalexample"><pre class="programlisting">bulletAppState.getPhysicsSpace().add(server.getLevelNode().getChild("terrain-TestScene").getControl(PhysicsControl.class));</pre></div></li><li class="listitem">A<a id="id607" class="indexterm"/> strategy is needed to collect all the objects that should be affected by server physics and assign them to <code class="literal">PhysicsObjectControl</code> (unless this has been done in <span class="strong"><strong>SceneComposer</strong></span> already). Objects that should have server physics should also have <code class="literal">serverControlled</code> set to <code class="literal">true</code> and a unique ID, which is known by both the client and the server. The resulting spatials should be stored in the <code class="literal">physicsObject</code> class map, as follows:<div class="informalexample"><pre class="programlisting">bigBox.addControl(new PhysicsObjectControl(uniqueId));
bigBox.getControl(PhysicsObjectControl.class).setServerControllled(true);
physicsObjects.put(uniqueId, bigBox);</pre></div></li><li class="listitem">In the <code class="literal">update</code> method of <code class="literal">ServerPhysicsAppState</code>, we parse through the values of the <code class="literal">physicsObject</code> map. If any of the item in <code class="literal">physicsObjects</code> has <code class="literal">PhysicsObjectControl</code> that <code class="literal">isServerControlled()</code> and their <code class="literal">isActive()</code> is <code class="literal">true</code>, a new <code class="literal">PhysicsObjectMessage</code> should be created as follows:<div class="informalexample"><pre class="programlisting">PhysicsObjectMessage message = new PhysicsObjectMessage();</pre></div></li><li class="listitem">It should have the ID of <code class="literal">PhysicsObjectControl</code> as <code class="literal">objectId</code> and <code class="literal">physicsLocation</code> and <code class="literal">physicsRotation</code> of <code class="literal">RigidBodyControl</code>; refer to the following code:<div class="informalexample"><pre class="programlisting">message.setObjectId(physicsObject.getControl(PhysicsObjectControl.class).getId());
message.setTranslation(physicsObject.getControl(RigidBodyControl.class).getPhysicsLocation());
message.setRotation(physicsObject.getControl(RigidBodyControl.class).getPhysicsRotation());</pre></div></li><li class="listitem">The message is then broadcasted to the clients.</li></ol></div><p>We'll revisit <a id="id608" class="indexterm"/>the server code in a bit, but first let's look at what is needed for the client to receive messages.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, the client has to have <code class="literal">BulletAppState</code> set up.</li><li class="listitem">Next, it needs to have knowledge of the objects to be handled by the server physics. If the objects are gathered from the scene, a strategy is needed to make sure the IDs are the same, or they're read in the same order.</li><li class="listitem">They should then be stored in the <code class="literal">Game</code> class as on the server.</li><li class="listitem">The second thing is a change to <code class="literal">ClientMessageHandler</code>. If the message is an instance of <code class="literal">PhysicsObjectMessage</code>, it should get the <code class="literal">physicsObject</code> <code class="literal">Map</code> from the <code class="literal">Game</code> class as follows:<div class="informalexample"><pre class="programlisting">Map&lt;Integer, Spatial&gt; physicsObjects = game.getPhysicsObjects();</pre></div></li><li class="listitem">A spatial should then be selected based on the <code class="literal">objectId</code> in the message as follows:<div class="informalexample"><pre class="programlisting">int objectId = physicsMessage.getObjectId();
Spatial s = physicsObjects.get(objectId);</pre></div></li><li class="listitem">The rotation and translation should be applied as <code class="literal">physicsLocation</code> and <code class="literal">physicsRotation</code> respectively on the spatial's <code class="literal">RigidBodyControl</code>:<div class="informalexample"><pre class="programlisting">PhysicsObjectControl physicsControl = s.getControl(PhysicsObjectControl.class);
if(physicsControl.getId() == objectId){
  s.getControl(RigidBodyControl.class).setPhysicsLocation(physicsMessage.getTranslation()); s.getControl(RigidBodyControl.class).setPhysicsRotation(physicsMessage.getRotation());
}</pre></div></li><li class="listitem">Now, the <a id="id609" class="indexterm"/>pipeline for transmitting physics updates from the server to the clients should work. If we run it, not much is happening. This is because the players in the implementation in <a class="link" href="ch07.html" title="Chapter 7. Networking with SpiderMonkey">Chapter 7</a>, <span class="emphasis"><em>Networking with SpiderMonkey</em></span>, weren't using physics. They were simply coded to stick to the surface of the terrain. We can change the player's representation to handle this.</li><li class="listitem">In <code class="literal">ServerPlayerControl</code>, we add a <code class="literal">BetterCharacterControl</code> field called <code class="literal">physicsCharacter</code> and a Boolean field called <code class="literal">usePhysics</code>.</li><li class="listitem">Next, we override the <code class="literal">setSpatial</code> method, and perform a check to see whether the spatial supplied has <code class="literal">BetterCharacterControl</code>. If it does, <code class="literal">usePhysics</code> should be set to <code class="literal">true</code> and the local <code class="literal">physicsCharacter</code> field should be set to <code class="literal">spatial</code> as follows:<div class="informalexample"><pre class="programlisting">if(spatial.getControl(BetterCharacterControl.class) != null){
  usePhysics = true;
  physicsCharacter = spatial.getControl(BetterCharacterControl.class);
}</pre></div></li><li class="listitem">Finally, in the <code class="literal">controlUpdate</code> method, we check whether <code class="literal">usePhysics</code> is <code class="literal">true</code>. If it is, rather than updating the spatial like we normally do in the method, we should instead set <code class="literal">walkDirection</code> of <code class="literal">physicsCharacter</code> to the local one and set <code class="literal">viewDirection</code> to the forward vector of its rotation as follows:<div class="informalexample"><pre class="programlisting">if(usePhysics){
physicsCharacter.setWalkDirection(walkDirection.multLocal(50));
physicsCharacter.setViewDirection(tempRotation.getRotationColumn(2));
}</pre></div></li><li class="listitem">In our<a id="id610" class="indexterm"/> server's main class, inside the <code class="literal">addPlayer</code> method, we should now add <code class="literal">BetterCharacterControl</code> to the player's spatial before we add <code class="literal">ServerPlayerControl</code>, as shown in the following code snippet:<div class="informalexample"><pre class="programlisting">Node playerNode = new Node("Player");
<span class="strong"><strong>playerNode.addControl(new BetterCharacterControl(0.5f, 1.5f, 1f));</strong></span>
playerNode.addControl(player);
rootNode.attachChild(playerNode);
stateManager.getState(ServerPhysicsAppState.class).addPlayer(player.getPhysicsCharacter());</pre></div></li><li class="listitem">There also needs to be some logic to add and remove <code class="literal">BetterCharacterControl</code> from <code class="literal">physicsSpace</code> as it joins and leaves the game.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec214"/>How it works...</h2></div></div></div><p>The first thing we did in the recipe was to lay some ground work by defining a new control called <code class="literal">PhysicsObjectControl</code> to be applied to the objects that should be handled by bullet physics. This control can either be added at runtime; alternatively, if <span class="strong"><strong>Scene Composer</strong></span> is used to lay out levels and scenes, it can be added to the objects beforehand. It's recommended that you define which ones should be handled by the server by setting <code class="literal">serverControlled</code> on the relevant objects before they're being added to the scenes. The ID should then be set in a deterministic way on both the client and the server when they parse the scene for the objects.</p><p>The architecture to handle the physics might very well look different in another implementation, but here, the <code class="literal">AppState</code> pattern was used so that it could be easily added as an extension to the existing framework from <a class="link" href="ch07.html" title="Chapter 7. Networking with SpiderMonkey">Chapter 7</a>, <span class="emphasis"><em>Networking with SpiderMonkey</em></span>. In this chapter, we didn't use any physics for the players but simply checked the height of the terrain to find out where the ground was. Hence, we added an optional <code class="literal">BetterCharacterControl</code> instance to the player—again, a change that would still make it compatible with the previous implementation. However, this was only added on the server side. For client-side physics, a similar change would have to be made there.</p><p>The server <a id="id611" class="indexterm"/>will check every update and see whether any of the objects with <code class="literal">serverControlled</code> enabled is active and will send any updates to the clients. Actually, you could leave out the physics all together on the client and simply update the spatial's rotation and translation, if you wanted. This would lower the requirements on the client's hardware, but this will only work if all of the physics are handled by the server of course.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec215"/>There's more…</h2></div></div></div><p>There is an opportunity here to introduce a third state on <code class="literal">PhysicsObjectControl</code>; a state in which the object is affected but not controlled by the server. This could be used for objects that are important in their initial state; however, once they've been moved, it's no longer important that all the clients have the same information, for example, a door that at some points get blown off its hinges. In this case, a new message type can be introduced that will apply an impulse or force to an object from the server side. Once the object has been activated, the client can take care of the calculations, lowering the network load.</p></div></div></body></html>