- en: Airline Ticket System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last projects—Twitter Consumers, Twitter Gathering, and Twitter Dispatcher—were
    excellent. We learned several exciting features, and they were implemented using
    the new features present in Spring 5.0\. All of them are implemented in Reactive
    Streams and use Kotlin as the programming language. They are the hottest features
    in Spring 5.0; it was an impressive progression.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are notably missing parts on these projects; we have microservice
    needs in mind. There are no infrastructure services such as service discovery,
    distributed configurations, API Gateway, distributed tracing, and monitoring.
    These kinds of services are mandatory in distributed systems such as microservice
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons for that. Firstly, we can think of the configuration
    management. Let''s imagine the following scenario – in the development cycle,
    we have three environments: DEV, TST, and PROD. This is a pretty simple standard
    found in companies. Also, we have an application decoupled in 4 microservices,
    then with the minimum infrastructure, we have 12 instances of services; remember,
    this is a good scenario because in a real situation, we will probably have several
    instances of microservice applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier scenario, we will maintain at least three configuration files
    per microservice, remember there are three environments for which we need to keep
    the configurations. Then, we will have 12 *versions* of settings. It is a hard
    task to maintain the configurations, to keep the files synchronized and updated.
    These files probably contain sensitive information, such as database passwords
    and message brokers' configurations, and it is not recommended that you put these
    files on the host machines.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the distributed configuration can solve our problems easily. We
    will learn about configuration servers in this chapter, and other infrastructure
    services as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize what we will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a Config Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a service discovery with Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring applications with Spring Cloud Zipkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing the applications with the Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Airline Ticket System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In these last few chapters, we will work on the Airline Ticket System. The solution
    is quite complex and involves a lot of HTTP integrations and message-based solutions.
    We will explore what we have learned from the book journey.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Spring Messaging, Spring WebFlux, and Spring Data components to
    create the solution. The application will split up into several microservices
    to guarantee the scalability, elasticity, and fault tolerance for the system.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will have some infrastructure services to help us deliver an efficient
    system. Some new patterns will be introduced, such as circuit breakers and OAuth.
    In the infrastructure layer, we will use the Netflix OSS components integrated
    with the Spring Framework ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of our application is to sell airline tickets, but to achieve
    this task, we need to build an entire ecosystem. We will build a microservice
    which will manage the seats and planes' characteristics. There will also be a
    microservice to manage available company flights; the basic idea is to manage
    flight dates and routes. Of course, we will have a microservice to manage passengers,
    fares, bookings, and payments. Finally, we will have an `e-commerce` API with
    which end users will buy airline tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Airline functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create some microservices to compose the solution and then we will decompose
    the solution into small pieces, that is, microservices. For that, we will use
    the Bounded Context pattern which is an essential part of the **Domain-Driven
    Design** (**DDD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram to have an idea about what we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/753b73dc-b3dc-42f9-9a97-d71218b84d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: It is a summary of what we will do in these few chapters; we have defined the
    basic functionalities for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take a look at components; let's go to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Solution diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the whole solution, which we will implement
    in the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fa12d95-91e4-4a04-a321-d9520ed6e208.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there are different kinds of components. Some components will
    be exposed through the **Gateway** for end users, in our case, our customers.
    There is a category which the company users will use to register flights, for
    instance, where these microservices will be exposed on **Gateway** as well.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure category will not be exposed over the internet, except the
    **Gateway** service. These services help the solution infrastructure and should
    be not exposed because there is sensitive data in there.
  prefs: []
  type: TYPE_NORMAL
- en: There a lot of things to do; let's get on with the show.
  prefs: []
  type: TYPE_NORMAL
- en: DDD enables us to deal easily with microservices. Some DDD patterns fit well
    for the microservices architectural style. There are many interesting books in
    the Packt catalog.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we adopt the microservices architectural style, there are some challenges
    to solve. One of the first problems to solve is how to manage the microservices
    configurations in the cluster, and how to make them easy and distributed, as well?
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config provides a Spring way, based on annotations and Spring beans.
    It is an easy way to solve this problem in a production-ready module. There are
    three main components in this module, the Configuration Repository, that is, version
    control system, the Config Server, which will provide the configurations, and
    finally, the Configuration Client, which will consume the configuration from the
    Config Server.
  prefs: []
  type: TYPE_NORMAL
- en: This module supplies the configuration files over an HTTP interface. It is the
    main feature provided by this project and it acts as a central repository for
    configuration in our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We want to remove the `application.yaml` file from our classpath; we do not
    need this file in classpath anymore, and so we will use the Config Server to serve
    this file for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our microservices will not have the configuration file, that is, `application.yaml`. 
    During the application bootstrap, the application will look at the Config Server
    to get the correct configuration, and after that, the application will finish
    the bootstrap to get them up and into running status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains the **Config Server** and Config Client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a9eadf3-88e3-4a7c-af0b-f445593eb38f.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the basic idea here is to try to distribute the configuration
    through the **Config Server**. There are some advantages to using this approach.
    The first one keeps the configuration in the central repository. It makes the
    configuration easy to maintain. The second one is that the configurations are
    served with a standard protocol, such as HTTP. Most of the developers know the
    protocol and make the interaction easy to understand. Finally, and most importantly,
    when the properties change, it can reflect immediately in other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Time to implement it. Let's go there.
  prefs: []
  type: TYPE_NORMAL
- en: The Config Server is usually maintained on private networks, if we are deploying
    in cloud environments, although the Spring Cloud Config supports encrypt and decrypt
    based on symmetric or asymmetric keys. Keep in the mind that the microservices
    configurations should not be published on public networks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Config Server project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our project with Spring Initializr. Go to Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    and follow the image instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d2e86ae-ec42-42fe-98c6-7b783b332925.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Generate Project and then we can open the project on the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Spring Cloud Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Git repository as a property source, and then we need to create
    a repository to keep these files. However, before that, let''s navigate to the `pom.xml` file
    and see some interesting stuff. We can find the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is a Config Server dependency. It enables us to use the Config Server in
    our application. Remember, we need to put this into the `pom.xml` file to achieve
    the required Config Server.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub as a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Cloud Config Server enables us to use different datastore technologies
    to work as a properties repository. There are some options such as Git repository,
    filesystem, or SVN and others, provided by the community.
  prefs: []
  type: TYPE_NORMAL
- en: We will choose the Git repository, and use GitHub as a host.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Git repository that has the source code of the book. The repository
    is located at: [https://GitHub.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files](https://Github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud Config Server also supports private repositories. For that
    purpose, we need to supply the private/public keys.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a piece of cake to enable and run the Config Server and provide our configuration
    HTTP protocol. To achieve it, we need to put the following annotation in our Spring
    Boot starter class. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Awesome. `@EnableConfigServer` does the magic for us. It will stand up the Config
    Server and make the application ready to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Git repository as a properties source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our Config Server needs to be configured. For that purpose, we will use the
    `application.yaml` file. This file should be simple and with minimal configurations
    as well. The configuration file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have configured the application port, which is a common task. We named our
    Config Server, and the most important part is the `server.git.uri` configuration
    property which instructs the Spring Framework to get the configurations files.
  prefs: []
  type: TYPE_NORMAL
- en: Another configuration is `search-paths`; it allows us to search the configuration
    in `git` repository folders, instead of a root address in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Awesome job; our configuration server is ready to use. Then let's run it. We
    can use the JAR file, or through IDE as well, it is up to you to choose the desired
    way.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Java command line or IDE to run it. I prefer to use IDE because
    it enables us to debug and make some code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d7333e2-00cb-45fe-9240-725b872db110.png)'
  prefs: []
  type: TYPE_IMG
- en: Tomcat started successfully; our Config Server is up and running. We can find
    some different endpoints in our Config Server. These endpoints are exposed to
    serve the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud Config Server supports profiles as well, providing different
    configurations for different environments is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern supported by the Config Server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is really important to keep this in mind. Also, it makes it mandatory to
    declare the `application.name` property in our microservices, to identify the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the endpoints provided by the Spring Cloud Config Server on the
    application bootstrap. Take a look at the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fab23f7-200e-46ed-916d-431284f56b91.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember the Config Server supports environments; because of this, there is
    a kind of regex on endpoints. Look at the `"/{name}-{profiles}.yml"` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are able to test our Config Server over the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `yaml` file to create the test; the file should be called
    `dummy.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Push it to GitHub – if you are using the GitHub book, this step is unnecessary.
    Then, we can call the Config Server API using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The command looks for the `dummy` configuration in the profile `default`; the
    URL is self-explanatory. The following output should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37d49791-5ca9-4f9e-a4ba-42fe9928c9bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Our Config Server is fully operational. Now, we will configure our service discovery
    using Netflix Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service discovery is one of the key points of the microservices architecture.
    The basis of the microservices architecture is to decouple the monolithic application
    into smaller pieces of software which have well-defined boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: This impacts our system design in the monolithic application. In general, the
    application logic stays in a single place with regards to the code. It means the
    procedure or methods calls are invoked in the same context when the application
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: When we adopt the microservices architectural style, these invocations are typically
    external, in other words, they will invoke the service through HTTP calls, for
    example, in another application context or web server.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the services need to call other services through HTTP, for instance, but
    how do the services call the others if the instances of these services change
    with a considerable frequency? Remember, we are creating distributed and scalable
    systems, where the instances of services can be increased according to the system
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: The services need to know where the other services are running to be able to
    call them. Let's imagine that we are considering putting the services IPs in the
    configuration; it will be hard to manage and impossible to track the machine changes
    during that time.
  prefs: []
  type: TYPE_NORMAL
- en: The service discovery pattern addresses this challenge. In general, the solution
    involves a Service Registry, which knows the locations of all the running services.
    The client then needs to have a kind of Service Registry Client to be able to
    query this Service Registry to obtain the valid address for the desired service;
    the Service Registry will then return a healthy address, and finally, the client
    can invoke the desired service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c59a3075-c289-48e0-93db-f68ce5d32989.png)'
  prefs: []
  type: TYPE_IMG
- en: The full documentation of this pattern can be found at [http://microservices.io/patterns/client-side-discovery.html](http://microservices.io/patterns/client-side-discovery.html)
    and [https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/).
    There are so many implementations for that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud service discovery supports some service discovery implementations,
    such as Hashicorp Consul provided by the Spring Cloud Consul, and Apache Zookeeper
    provided by the Spring Cloud Zookeeper.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the Netflix OSS stack where we will use the Eureka server, which
    was provided by the Spring Netflix OSS. It enables us to use the Eureka server
    as a managed Spring bean.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Eureka Client provides a client aware of the Service Registry, and
    it can be done with a couple of annotations and some configurations – we will
    do that soon.
  prefs: []
  type: TYPE_NORMAL
- en: We will start to create and configure the Eureka server in the following sections.
    Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation for the Spring Cloud Consul can be found at: [https://cloud.spring.io/spring-cloud-consul](https://cloud.spring.io/spring-cloud-consul),
    and the Spring Cloud Zookeeper can be found at: [https://cloud.spring.io/spring-cloud-zookeeper.](https://cloud.spring.io/spring-cloud-zookeeper)
  prefs: []
  type: TYPE_NORMAL
- en: Creating Spring Cloud Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable service discovery in our infrastructure, we need to create an instance
    of a service which will act as a service discovery. The Spring Cloud Eureka server
    enables us to achieve this task. Let''s create our project. Go to Spring Initializr
    and fill in the information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f428b3d-b577-4360-987f-f4a4106206dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the required dependencies. The Eureka server is the dependency
    which allows us to spin up a service discovery server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's open the project on IDE and start to configure it. We will do this in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Eureka server main class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start the configuration, we will create the `main` class. This class
    will start the Spring Boot application. The Eureka server is embedded in the application.
    It is a pretty standard Spring Boot application with a single annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` application class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableEurekaServer` annotation will start the embedded Eureka server in
    our application and make it ready to use. It will enable the service registry
    in our application as well.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring Cloud Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Eureka server needs to be configured using the Spring Cloud Server configured
    in the previous sections. Then, we need to keep the `application.yaml` off our
    project, to use the Config Server properly. Instead of the `application.yaml,`
    we need to put the `bootstrap.yaml` and put the Config Server address on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `discovery.yaml` on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `bootstrap.yaml` file in the classpath project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the `discovery.yaml` file. The file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting things to explore. We are using the localhost as
    `hostname` because we are running on the developer machine. There are a couple
    of configurations about the URLs health check and status page – pay attention
    to the configurations that are related to the server. They are placed below the
    `eureka.instance` YAML node. The configurations are `health-check-url-path` and
    `status-page-url-path`. We can use the default values as well, but the new Spring
    Boot Actuator changes the URL for those two features, so we need to configure
    them properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `eureka.client` YAML node is about the client configuration; in our case,
    we set `registerWithEureka` to false. We do not want the Eureka server to act
    as a client as well. The same is true for the `fetchRegistry` configuration, it
    is a client configuration and it will cache the Eureka registry's information.
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` node is about logging configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome – our `gateway.yaml` is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `bootstrap.yaml` file in the Eureka server project classpath.
    The file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Easy peasy – we have configured `spring.cloud.config`. It instructs Spring of
    the Config Server address. Also, we have configured the `label`, which is the
    branch when we are using the **version control system** (**VCS**) as a repository.
  prefs: []
  type: TYPE_NORMAL
- en: Well done. The configuration is ready. Time to run it. Let's do it in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Spring Cloud Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eureka server is ready to use. We will start the Spring Boot application
    and put our Eureka server online. We can use the Java command line or IDE to run
    it. I prefer to use IDE because it enables us to debug and make some code changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Config Server needs to be running because the discovery will find the configuration
    file to bootstrap the server properly.
  prefs: []
  type: TYPE_NORMAL
- en: Run it!
  prefs: []
  type: TYPE_NORMAL
- en: 'We should see the following lines in the application bootstrap logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/989fa49b-7e17-477a-9e57-8afa3d9434d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome. Look at the following line of the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It means our Eureka server is ready to use. To check the solution, we can go
    to the Eureka server home page. Go to `http://localhost:8761/` and the following
    page will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7be8d8e4-c0c9-46b9-8686-8dac3141d1fe.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, there is no instance of service available yet. We can find some
    relevant information such as the server Uptime, the current Data center, and the Current
    time. There is some information in the General Info section, information regarding
    the server where the Eureka server is running.
  prefs: []
  type: TYPE_NORMAL
- en: Good job. Our service discovery service is running. We will use this infrastructure
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Zipkin server and Sleuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our solution involves some microservices; it makes our solution easy to deploy
    and easy to write code. Each solution has a particular repository and codebase.
  prefs: []
  type: TYPE_NORMAL
- en: In the monolith solution, the whole problem is solved in the same artifact to
    be deployed. Usually, in Java, these artifacts are `.jar`, `.war`, or `.ear,` if
    the application was written in the Java EE 5/6 specifications.
  prefs: []
  type: TYPE_NORMAL
- en: The logging strategies for these kinds of applications is quite easy to work
    with (hence problems can be solved easily) because everything happens in the same
    context; the requests are received from the same application server or web server,
    which have the business components. Now, if we go to the logs, we will probably
    find the log entries we want. It makes the trace application easier to find errors
    and debug.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservices solution, the application behaviors are split in the distributed
    systems; it increases the trace tasks substantially because the request probably
    arrives in the API Gateway and comes into microservices. They log the information
    in different sources. In this scenario, we need a kind of log aggregator and a
    way to identify the whole transaction between services.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, the Spring Cloud Sleuth and Spring Cloud Zipkin can help us
    and make the trace features more comfortable for developers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at and understand how it works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure for the Zipkin server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to work, we need to configure a service which the Zipkin server
    needs. By default, the Zipkin server uses in-memory databases, but it is not recommended
    for production; usually, developers use this feature to demonstrate Zipkin features.
  prefs: []
  type: TYPE_NORMAL
- en: We will use MySQL as a data store. The Zipkin server also supports different
    sources, such as Cassandra and Elasticsearch.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Sleuth supports synchronous and asynchronous operations. The synchronous
    operations are over the HTTP protocol and asynchronous can be done by RabbitMQ
    or Apache Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: To use the HTTP, that is, REST API, we should use `@EnableZipkinServer,` it
    will delegate the persistence for REST tier through the `SpanStore` interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will choose the asynchronous solution, since it fits well for our project,
    and we do not want the trace collector to cause some performance issues. The asynchronous
    solution uses the Spring Cloud Stream binder to store the `Spans`. We choose the
    RabbitMQ message broker to do that. It can be achieved using the `@EnableZipkinStreamServer`
    annotations which configure Spring Sleuth to use streams for store `Spans`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `docker-compose-min.yaml` to bootstrap our RabbitMQ and MySQL
    containers. The file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `docker-compose-min.yaml` file can be found at [GitHub](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-min.yaml),
    there is a MongoDB and Redis – they will be used in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special here. We have declared two containers—RabbitMQ and
    MySQL— and exposed the ports on the host machine. Also, we have created the `airline`
    network; we will use this network to attach our infrastructure microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create our Zipkin server, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Spring Cloud Zipkin server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create our Zipkin panel structure in Spring Initializr, and then we
    need to follow the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a1de65e-052f-4dd6-be13-97f188a67b43.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome – take a look at the Selected Dependencies section, all of them are
    required. Pay attention to the Spring Boot version. We choose `1.5.9`, because
    there is no support for Zipkin server in Spring Boot 2\. It is not a problem because
    we do not need specific features from Spring Boot 2.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Generate Project button and wait for the download to finish. Afterwards,
    open the project in IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable service discovery and store `Spans` on a database, we need
    to put the following dependencies in our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first dependency is for the service discovery client and the others are
    to JDBC connections to MySQL. It makes our project dependencies fully configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `main` class to start our Zipkin server. The class is pretty
    standard but with some new annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableEurekaClient` annotation enables the application to connect to the
    Eureka server. The new annotation, `@EnableZipkinStreamServer`, instructs the
    framework to connect with the configured broker to receive the `Spans`. Remember,
    it can be done using the Spring Cloud Stream Binder.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring boostrap.yaml and application.yaml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the section, we created our `main` class. Before we run it, we should create
    our two configuration files. The `bootstrap.yaml` inside the `src/main/resources`
    directory and the `application.yaml` on our GitHub repository. They will be downloaded
    via Config Server and provided by the Zipkin server project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `bootstrap.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special, we have configured our Config Server address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to our `application.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting things here. In the `spring.rabbitmq` node, we have
    configured our RabbitMQ broker connection. It will be used to receive `Spans`.
    In the `spring.datasource`, we have configured the MySQL connection. The Zipkin
    server will use it to store data. Also, we have configured how to execute the
    DDL script to create the `zipkin` database.
  prefs: []
  type: TYPE_NORMAL
- en: The `spring.sleuth` node was configured to not produce any `Span` because it
    is a server, not a client application, and we will not perform a trace on the
    Zipkin server.
  prefs: []
  type: TYPE_NORMAL
- en: The `zipkin` node had been used to configure the Zipkin server storage type,
    MySQL, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run it!!!
  prefs: []
  type: TYPE_NORMAL
- en: Running the Zipkin server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have configured the Zipkin server properly, so now we will be able to run
    it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the main class `ZipkinServerApplication`. We can use the IDE or
    Java command line, after running the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50e1605b-4111-45f1-b8aa-93de1ab85ee4.png)'
  prefs: []
  type: TYPE_IMG
- en: Good job – the Zipkin server is running now. We can take a look at the index
    page to see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Zipkin page; the page should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1778b765-0f54-4c69-98f8-056a77cb4052.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can check the RabbitMQ panel to find the queue created by the Zipkin
    server. Go to the RabbitMQ Queues (`http://localhost:15672/#/queues`) section,
    the page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df399b7-3aba-4bfc-ba86-d1c685e08c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the queues, the project has created the `sleuth.sleuth` queue, well
    done.
  prefs: []
  type: TYPE_NORMAL
- en: The Zipkin server is ready. For now, we will not have any `Span`, because there
    is no application sending data to Zipkin. We will do that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API Gateway pattern helps us to expose our microservices through a single
    known entrypoint. Usually, it acts as an entrypoint to external access and redirects
    the call to internal microservices.
  prefs: []
  type: TYPE_NORMAL
- en: There are many benefits when we adopt the API Gateway in our application. The
    first one can be recognized easily, it makes the API consumption easy for the
    clients, which means the clients do not need to know the different microservices
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Other benefits are a consequence of the first one. When we have a unique entrypoint,
    we can address some cross-application concerns such as filtering, authentication,
    throttling, and rate limit, as well.
  prefs: []
  type: TYPE_NORMAL
- en: It is an essential part when we adopt the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud Gateway enables us to have these features in a Spring-managed
    bean, in a Spring way using Dependency Injection and other features provided by
    the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The project was built on the Spring Framework 5, which uses the Project Reactor
    as a basis. There are some interesting features provided, such as Hystrix Circuit
    Breaker integration and with the Spring Cloud Discovery client, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the diagram to understand the benefits of the API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/065a670f-fcd5-4050-b27b-f01aaaf076fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The full documentation of the API Gateway Pattern can be found at: [http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Spring Cloud Gateway project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Spring Initializr to create our Spring Cloud Gateway project;
    we will need to add some dependencies manually. Let''s go to the Spring Initializr
    page and create our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2b1db6d-1650-42cc-a0c1-c3dd8626220e.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a brand new dependency Gateway, it enables us to work with Spring Cloud
    Gateway. Then click on Generate Project and wait for the download to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we need to add a missing dependency. The missing dependency is
    required by the Gateway to interact with the Eureka server; the name of the dependency
    is `spring-cloud-starter-netflix-eureka-client`. Then, let''s add the dependency
    on our `pom.xml`, we will need to add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Excellent, our project is configured correctly to work with the Eureka server.
    In the following section, we will configure the project to work with the Config
    Server as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Spring Cloud Gateway main class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no secret to this part. The Spring Cloud Gateway works in the same
    way as the common Spring Boot applications. There is a `main` class which will
    start the embedded server and starts the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main` class should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it is a pretty standard Spring Boot application, configured with
    `@EnableEurekaClient` to work with the Eureka server as a service discovery implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring Cloud Gateway project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary project structure is ready. We will create the project configurations
    in this section. To achieve this, we need to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `gateway.yaml` file to GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `bootstrap.yaml` in the Gateway project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the Spring Cloud Config Server, so it is necessary to create the
    new file in GitHub because the Config Server will try to find the file on the
    repository. In our case, we are using GitHub as a repository.
  prefs: []
  type: TYPE_NORMAL
- en: The second task is necessary because the `bootstrap.yaml` file is processed
    before the application is fully ready to run. Then, during this phase, the application
    needs to look up the configuration file and to achieve this, the application needs
    to know the `repository`, in our case, the Config Server. Remember the address
    of the Config Server always needs to be placed on the `bootstrap.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `gateway.yaml` file – the file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `eureka.client` node in the YAML file is responsible for configuring the
    Eureka Client configurations. We need to configure our Eureka server address instance.
    It should be pointed to the correct address.
  prefs: []
  type: TYPE_NORMAL
- en: There are more options for the Eureka Configuration Client properties. The full
    documentation can be found in [https://github.com/Netflix/eureka/wiki/Configuring-Eureka](https://github.com/Netflix/eureka/wiki/Configuring-Eureka);
    the Netflix team maintains Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to create our `bootstrap.yaml` file on the Gateway project. This
    file will instruct the Spring Framework to look up the configuration file on the
    Config Server and then download the required file to finish the application bootstrap.
    Our file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Pretty simple. The `application.name` is required to instruct the framework
    to look up the correct file. Usually, there are many configuration files for different
    applications and environments as well.
  prefs: []
  type: TYPE_NORMAL
- en: On the `cloud.config` node, we need to put in the Spring Cloud Config Server
    address, which we configured in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project final structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da5891f8-5e3f-4cce-bc08-ecf657d48c3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Look at the screenshot. There is no `application.yaml` in the classpath. This
    gives us several advantages; there is no configuration file in classpath projects,
    which helps us a great deal in managing the microservices configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will run it and explain the whole application bootstrap
    process. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project is well-configured, so now it is time to run it. We can use the
    Java command line or IDE. There is no difference either way.
  prefs: []
  type: TYPE_NORMAL
- en: The Config Server and Eureka server need to stay up; it is mandatory that the
    Gateway project works correctly. Then, we can run the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project and look at the logs. We can see some interesting stuff, such
    as the project connecting to the Config Server and download the configuration
    and after this, it connects to the Eureka server and self-registers. The following
    diagram explains the application bootstrap flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba4406fe-ea05-49d0-b4e8-f229ce72a25b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at what the different flows are and understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: The Gateway application requests the configuration file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Config Server serves the config file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Gateway application registers to the Eureka server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Awesome, our Gateway application is connected to our infrastructure services.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Gateway is running. Now, we can check the Eureka server page to confirm
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `http://localhost:8761/`, and check the Instances currently registered
    with Eureka section. We should see the Gateway application, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82aeb332-a6e7-4c16-b009-4145d35785d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Excellent. It worked well. The Gateway application is successfully registered,
    and it can be looked up via the service discovery. Our Gateway will connect to
    the Eureka server to get the service available and distribute the requested calls
    to the correct services.
  prefs: []
  type: TYPE_NORMAL
- en: Well done. Now, we can create our routes in the Gateway. We will do this in
    the next chapter when we create our airline microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first route with Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Gateway is running. Before we start the real routes for our Airline application,
    let's try to use some fake routes to test the Spring Cloud Gateway behaviors.
    We will use the [https://httpbin.org/](https://httpbin.org/) site, which helps
    us to test some routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class with the `@Configuration` annotation to provide the routes
    for the Spring Container. Let''s create a package called `springfive.airline.gateway.infra.route`,
    then create the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are some different types to configure routes; the first one we extracted
    is the function to a private attribute called `addCustomHeader,` which will be
    used in the `custom-request-header` route. We will use **curl** to test some routes
    created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one we will test is the `custom-request-header,` the route was configured
    to route to: [http://httpbin.org:80](http://httpbin.org:80) and the path will
    be `/headers`. This service will return the Request Headers sent to the server.
    Take a look at `addCustomHeader`, we have configured it to add a custom header
    to the Request. It will be Book as the key and Spring 5.0 By Example, as the value.
    Let''s call the gateway URL, using curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a229878-be00-48f8-b602-2408154f73f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's analyze the output. The first thing to look at is we have called the localhost
    address. The `Host` key in the Request shows `httpbin.org`, it means the Spring
    Cloud Gateway has changed the address. Awesome, but we expected it. The second
    one is where we have added the `Book` key, and bingo, there it is in the Request
    Headers. The Gateway worked as expected, and with a few lines of code, we did
    some interesting stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do one more test. We will test the `combine-and-change`, this route
    is configured to answer the `/anything` with the Request `Header access-key: AAA`,
    so the command line should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `-v` argument makes the call in verbose mode, it is useful
    for debugging purposes and the `-H` indicates the Request Headers. Let''s look
    at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d56c40a7-0a13-4f87-ac89-69bf9f651202.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome. If you look at the `access-key` value, the Gateway changed to a requested
    value `BBB`. Good job guys. There are some endpoints to test, feel free to test
    as you want.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the httpbin documentation at: [https://httpbin.org/](https://httpbin.org/).
    There are some interesting other methods to test HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the infrastructure on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our infrastructure is ready and it enables us to develop the application. We
    can create a Docker compose file to spin up the infrastructure services; during
    the development life cycle, components such as Eureka, Config Server, Trace Server,
    and API Gateway do not suffer changes because they interact as an infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, it enables us to create component images and use them in the `docker-compose.yaml`
    file. Let''s list our components:'
  prefs: []
  type: TYPE_NORMAL
- en: Config Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zipkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know how to create Docker images using the Fabric8 Maven plugin, we have
    done this several times in the previous chapters – let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure one as an example, keep in mind we need do the same configuration
    for all projects, Eureka, Gateway, Config Server, and Gateway. The following snippet
    configures the `docker-maven-plugin` to generate a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a pretty simple configuration. A simple Maven plugin with a couple of
    configurations. Then, after the plugin configuration, we are able to generate
    the Docker image. The command to generate Docker images is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It will generate a Docker image for us.
  prefs: []
  type: TYPE_NORMAL
- en: The projects configured can be found on GitHub; there are so many configurations
    to do as in the previous chapters. We need to configure the `docker-maven-plugin`
    and generate the Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Fully configured projects can be found in the chapter seven folder. The GitHub
    repository is: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07.](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07)
  prefs: []
  type: TYPE_NORMAL
- en: 'After the images have been created, we are able to create a Docker compose
    file defining the whole thing. The `docker-compose-infra-full.yaml` file should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting things to pay attention to here. It is very important
    that all container instances are attached to the same Docker network called `airline`.
    Pay attention to the ports exposed by the containers, it is important to enable
    service discovery features in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can execute the instruction to spin up the whole infrastructure; it
    can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09f31f0c-c06b-4f64-a449-958fd0af2308.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can execute the following instruction to check the container''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It will list the running containers, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdedb2b7-8516-4db5-8d80-9677cb87ca6c.png)'
  prefs: []
  type: TYPE_IMG
- en: All applications are up and running. Well done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the containers, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It will remove the containers from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent job, our infrastructure is fully operational in Docker containers.
    It is a base for starting to create our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built the essential infrastructures services adopting
    the microservices architectural style.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how Spring Framework eliminates the infrastructure code from
    our microservices and enables us to create these services, using a couple of annotations.
  prefs: []
  type: TYPE_NORMAL
- en: We understand how it works under the hood; it is extremely important to debug
    and troubleshoot when the application gets some errors in the production stage.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to create scalable, fault tolerant, and responsive systems.
    We have built the foundations of our system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to build our Airline Ticket System, understand
    how to connect the new microservices with the whole infrastructure, and enable
    service discovery and other amazing features.
  prefs: []
  type: TYPE_NORMAL
- en: See you there.
  prefs: []
  type: TYPE_NORMAL
