["```java\npublic interface Graph<V, E> {\n    int addVertex();\n    void removeVertex(int id);\n    void addEdge(int source, int target);\n    void removeEdge(int source, int target);\n    boolean isAdjacent(int source, int target);\n    LinkedList getNeighbors(int source);\n    void setVertexValue(int vertex, V value);\n    V getVertexValue(int vertex);\n    void setEdgeValue(int source, int target, E value);\n    E getEdgeValue(int source, int target);\n    boolean isUndirected();\n    BinarySearchTree<Integer> getAllVertices();\n    int maxVertexID();\n}\n```", "```java\npublic class AdjacencyMatrixGraphWithSparseVertex<V,E> implements Graph<V, E> {\n\n    private static class NullEdgeValue{};\n```", "```java\n    private NullEdgeValue nullEdge = new NullEdgeValue();\n    private NullEdgeValue nullVertex = new NullEdgeValue();\n\n    Object [][] adjacencyMatrix = new Object[0][];\n    Object[] vertexValues = new Object[0];\n```", "```java\n    boolean undirected;\n\n    public AdjacencyMatrixGraphWithSparseVertex(boolean undirected){\n        this.undirected = undirected;\n    }\n```", "```java\n    @Override\n    public int addVertex() {\n        int numVertices = adjacencyMatrix.length;\n        Object [][] newAdjacencyMatrix = new Object[numVertices+1][];\n        for(int i=0;i<numVertices;i++){\n            newAdjacencyMatrix[i] = new Object[numVertices+1];\n            System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, numVertices);\n        }\n        newAdjacencyMatrix[numVertices] = new Object[numVertices+1];\n        adjacencyMatrix = newAdjacencyMatrix;\n        Object [] vertexValuesNew = new Object[vertexValues.length+1];\n        System.arraycopy(vertexValues,0, vertexValuesNew, 0, vertexValues.length);\n        vertexValuesNew[vertexValues.length] = nullVertex;\n        vertexValues = vertexValuesNew;\n        return numVertices;\n    }\n```", "```java\n    @Override\n    public void removeVertex(int id) {\n        vertexValues[id] = null;\n        for(int i=0;i<adjacencyMatrix.length;i++){\n            adjacencyMatrix[id][i] = null;\n            adjacencyMatrix[i][id] = null;\n        }\n    }\n```", "```java\n    @Override\n    public void addEdge(int source, int target) {\n        if(adjacencyMatrix[source][target] == null){\n            adjacencyMatrix[source][target] = nullEdge;\n            if(undirected){\n                adjacencyMatrix[target][source] = nullEdge;\n            }\n        }else{\n            throw new IllegalArgumentException(\"Edge already exists\");\n        }\n    }\n```", "```java\n    @Override\n    public void removeEdge(int source, int target) {\n        adjacencyMatrix[source][target] = null;\n        if(undirected){\n            adjacencyMatrix[target][source] = null;\n        }\n    }\n```", "```java\n    @Override\n    public boolean isAdjacent(int source, int target) {\n        return adjacencyMatrix[source][target] != null;\n    }\n```", "```java\n    @Override\n    public LinkedList getNeighbors(int source) {\n        LinkedList<Integer> neighborList = new LinkedList<>();\n        for(int i=0;i<adjacencyMatrix.length;i++){\n            if(adjacencyMatrix[source][i]!=null){\n                neighborList.appendLast(i);\n            }\n        }\n        return neighborList;\n    }\n```", "```java\n    @Override\n    public void setVertexValue(int vertex, V value) {\n        vertexValues[vertex] = value;\n    }\n\n    @Override\n    public V getVertexValue(int vertex) {\n        if(vertexValues[vertex]!=nullVertex)\n            return (V)vertexValues[vertex];\n        else\n            throw new IllegalArgumentException(\"Vertex \"+vertex\n                 +\" does not exist\");\n    }\n```", "```java\n    @Override\n    public void setEdgeValue(int source, int target, E value) {\n        adjacencyMatrix[source][target] = value;\n        if(undirected){\n            adjacencyMatrix[target][source] = value;\n        }\n    }\n\n    @Override\n    public E getEdgeValue(int source, int target) {\n        if(adjacencyMatrix[source][target] != nullEdge) {\n            return (E) adjacencyMatrix[source][target];\n        }else {\n            return null;\n        }\n    }\n\n@Override\n    public boolean isUndirected() {\n        return undirected;\n    }\n\n    @Override\n    public BinarySearchTree<Integer> getAllVertices() {\n        BinarySearchTree<Integer> allVertices = new RedBlackTree<>();\n        for(int i=0;i<vertexValues.length;i++){\n            if(vertexValues[i]!=null){\n                allVertices.insertValue(i);\n            }\n        }\n        return allVertices;\n    }\n\n    @Override\n    public int maxVertexID() {\n        return vertexValues.length-1;\n    }\n}\n```", "```java\npublic class GraphVertex<V> implements Comparable<GraphVertex<V>>{\n    int id;\n    V value;\n\n    public GraphVertex(int id, V value) {\n        this.id = id;\n        this.value = value;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    public void setValue(V value) {\n        this.value = value;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        GraphVertex<?> that = (GraphVertex<?>) o;\n        return id == that.id;\n    }\n\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    @Override\n    public int compareTo(GraphVertex<V> o) {\n        return id - o.id;\n    }\n}\n```", "```java\npublic class AdjacencyMatrixGraphWithDenseVertex<V,E> implements Graph<V, E> {\n```", "```java\n    class Vertex extends GraphVertex<V>{\n        int internalIndex;\n\n        public Vertex(int id, V value, int internalIndex) {\n            super(id, value);\n            this.internalIndex = internalIndex;\n        }\n\n        public int getInternalIndex() {\n            return internalIndex;\n        }\n\n        public void setInternalIndex(int internalIndex) {\n            this.internalIndex = internalIndex;\n        }\n    }\n```", "```java\n    private int nextId;\n```", "```java\n    private static class NullValue {};\n    private NullValue nullEdge = new NullValue();\n\n    Object [][] adjacencyMatrix = new Object[0][];\n```", "```java\n    RedBlackTree<GraphVertex<V>> vertices = new RedBlackTree<>();\n    boolean undirected;\n\n    public AdjacencyMatrixGraphWithDenseVertex(boolean undirected){\n        this.undirected = undirected;\n    }\n```", "```java\n    @Override\n    public int addVertex() {\n        int id = nextId++;\n        int numVertices = adjacencyMatrix.length;\n        Object [][] newAdjacencyMatrix = new Object[numVertices+1][];\n        for(int i=0;i<numVertices;i++){\n            newAdjacencyMatrix[i] = new Object[numVertices+1];\n            System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, numVertices);\n        }\n        newAdjacencyMatrix[numVertices] = new Object[numVertices+1];\n\n        vertices.insertValue(new Vertex(id, null, adjacencyMatrix.length));\n        adjacencyMatrix = newAdjacencyMatrix;\n        return numVertices;\n    }\n```", "```java\n    @Override\n    public void removeVertex(int id) {\n        BinaryTree.Node<GraphVertex<V>> node = vertices.searchValue(new GraphVertex<V>(id, null));\n        if(node!=null){\n            int internalId = ((Vertex)(node.getValue())).getInternalIndex();\n            int numVertices = adjacencyMatrix.length;\n            Object [][] newAdjacencyMatrix = new Object[numVertices-1][];\n```", "```java\n            for(int i=0;i<internalId;i++){\n                newAdjacencyMatrix[i] = new Object[numVertices-1];\n                System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i], 0, internalId);\n                System.arraycopy(adjacencyMatrix[i],internalId+1, newAdjacencyMatrix[i], internalId, numVertices-internalId-1);\n            }\n```", "```java\n            for(int i=internalId+1;i<numVertices;i++){\n                newAdjacencyMatrix[i-1] = new Object[numVertices-1];\n                System.arraycopy(adjacencyMatrix[i],0, newAdjacencyMatrix[i-1], 0, internalId);\n                System.arraycopy(adjacencyMatrix[i],internalId+1, newAdjacencyMatrix[i-1], internalId, numVertices-internalId-1);\n            }\n            adjacencyMatrix = newAdjacencyMatrix;\n```", "```java\n            vertices.traverseDepthFirstNonRecursive((gv)->{\n                if(((Vertex)gv).getInternalIndex()>internalId)\n                    ((Vertex)gv).setInternalIndex(((Vertex)gv).getInternalIndex()-1);\n            }, BinaryTree.DepthFirstTraversalType.PREORDER);\n            vertices.deleteValue(new GraphVertex<>(id, null));\n        }else{\n            throw new IllegalArgumentException(\"Vertex with id \"+id\n            +\" does not exist\");\n        }\n    }\n```", "```java\n    @Override\n    public void addEdge(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode = vertices.searchValue(\n                new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode = vertices.searchValue(\n                new GraphVertex<V>(target, null));\n        if(sNode!=null && tNode!=null) {\n            int s = ((Vertex)(sNode.getValue())).getInternalIndex();\n            int t = ((Vertex)(tNode.getValue())).getInternalIndex();\n            if(adjacencyMatrix[s][t] == null){\n                adjacencyMatrix[s][t] = nullEdge;\n                if(undirected){\n                    adjacencyMatrix[t][s] = nullEdge;\n                }\n            }else{\n                throw new IllegalArgumentException(\"Edge already exists\");\n            }\n        }else{\n            throw new IllegalArgumentException(\"Non-existent ID\");\n        }\n\n    }\n```", "```java\n    @Override\n    public void removeEdge(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode = vertices.searchValue(\n                new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode = vertices.searchValue(\n                new GraphVertex<V>(target, null));\n        if(sNode!=null && tNode!=null) {\n            int s = ((Vertex)(sNode.getValue())).getInternalIndex();\n            int t = ((Vertex)(tNode.getValue())).getInternalIndex();\n            adjacencyMatrix[s][t] = null;\n        }else{\n            throw new IllegalArgumentException(\"Non-existent ID\");\n        }\n\n    }\n```", "```java\n    @Override\n    public boolean isAdjacent(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode = vertices.searchValue(\n                new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode = vertices.searchValue(\n                new GraphVertex<V>(target, null));\n        if(sNode!=null && tNode!=null) {\n            int s = ((Vertex)(sNode.getValue())).getInternalIndex();\n            int t = ((Vertex)(tNode.getValue())).getInternalIndex();\n            return adjacencyMatrix[s][t] != null;\n        }else{\n            throw new IllegalArgumentException(\"Non-existent ID\");\n        }\n\n    }\n```", "```java\n    @Override\n    public LinkedList<Integer> getNeighbors(int source) {\n        BinaryTree.Node<GraphVertex<V>> node = vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        if(node!=null){\n            LinkedList<Integer> neighborsList = new LinkedList<>();\n            int sourceInternalIndex = ((Vertex) node.getValue()).getInternalIndex();\n            vertices.traverseDepthFirstNonRecursive((gv)->{\n                int targetInternalIndex = ((Vertex) gv).getInternalIndex();\n                if(adjacencyMatrix[sourceInternalIndex][targetInternalIndex]!=null)\n                    neighborsList.appendLast(gv.getId());\n            }, BinaryTree.DepthFirstTraversalType.INORDER);\n            return neighborsList;\n        }else{\n            throw new IllegalArgumentException(\"Vertex with id \"+source+\" does not exist\");\n        }\n\n    }\n```", "```java\n    @Override\n    public void setVertexValue(int vertex, V value) {\n        BinaryTree.Node<GraphVertex<V>> node =\n                vertices.searchValue(\n                        new GraphVertex<V>(vertex, null));\n        if(node!=null){\n            node.getValue().setValue(value);\n        }else{\n            throw new IllegalArgumentException(\"Vertex with id \"+vertex+\" does not exist\");\n        }\n    }\n\n    @Override\n    public V getVertexValue(int vertex) {\n        BinaryTree.Node<GraphVertex<V>> node =\n                vertices.searchValue(\n                        new GraphVertex<V>(vertex, null));\n        if(node!=null){\n            return node.getValue().getValue();\n        }else{\n            throw new IllegalArgumentException(\"Vertex with id \"+vertex+\" does not exist\");\n        }\n    }\n\n    @Override\n    public void setEdgeValue(int source, int target, E value) {\n        BinaryTree.Node<GraphVertex<V>> sNode = vertices.searchValue(\n                new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode = vertices.searchValue(\n                new GraphVertex<V>(target, null));\n        if(sNode!=null && tNode!=null) {\n            int s = ((Vertex)(sNode.getValue())).getInternalIndex();\n            int t = ((Vertex)(tNode.getValue())).getInternalIndex();\n            adjacencyMatrix[s][t] = value;\n            if (undirected) {\n                adjacencyMatrix[t][s] = value;\n            }\n        }else{\n            throw new IllegalArgumentException(\"Non-existent ID\");\n        }\n    }\n\n    @Override\n    public E getEdgeValue(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode = vertices.searchValue(\n                new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode = vertices.searchValue(\n                new GraphVertex<V>(target, null));\n        if(sNode!=null && tNode!=null) {\n            int s = ((Vertex)(sNode.getValue())).getInternalIndex();\n            int t = ((Vertex)(tNode.getValue())).getInternalIndex();\n            return (E) adjacencyMatrix[s][t];\n        }else{\n            throw new IllegalArgumentException(\"Non-existent ID\");\n        }\n    }\n\n@Override\n    public boolean isUndirected() {\n        return undirected;\n    }\n\n    @Override\n    public BinarySearchTree<Integer> getAllVertices() {\n        BinarySearchTree<Integer> allVertices = new RedBlackTree<>();\n        vertices.traverseDepthFirstNonRecursive(\n          (v) -> allVertices.insertValue(v.getId()),\n           BinaryTree.DepthFirstTraversalType.PREORDER);\n        return allVertices;\n    }\n    @Override\n    public int maxVertexID() {\n        return nextId-1;\n    }\n}\n```", "```java\npublic class AdjacencyListGraphWithSparseVertex<V,E> implements Graph<V,E> {\n    boolean undirected;\n\n    public AdjacencyListGraphWithSparseVertex(boolean undirected) {\n        this.undirected = undirected;\n    }\n```", "```java\nclass Edge implements Comparable<Edge>{\n        E value;\n        int target;\n```", "```java\n        DoublyLinkedList.DoublyLinkedNode<Integer> targetNode;\n\n        public Edge(int target) {\n            this.target = target;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Edge edge = (Edge) o;\n\n            return target == edge.target;\n\n        }\n\n        @Override\n        public int hashCode() {\n            return target;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return target - o.target;\n        }\n    }\n```", "```java\n    class Vertex extends GraphVertex<V>{\n        RedBlackTree<Edge>\n                edges = new RedBlackTree<>();\n        DoublyLinkedList<Integer> neighbors = new DoublyLinkedList<>();\n        public Vertex(int id, V value) {\n            super(id, value);\n        }\n    }\n```", "```java\n    Object[] vertices = new Object[0];\n```", "```java\n    @Override\n    public int addVertex() {\n        Object[] newVertices = new Object[vertices.length+1];\n        System.arraycopy(vertices, 0, newVertices, 0, vertices.length);\n        newVertices[vertices.length] = new Vertex(vertices.length, null);\n        vertices=newVertices;\n        return newVertices.length-1;\n    }\n```", "```java\n    @Override\n    public void removeVertex(int id) {\n        Vertex sVertex = (Vertex) vertices[id];\n        if(sVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ id +\" does not exist\");\n        }\n        LinkedList<Integer> neighbors = getNeighbors(id);\n        Edge dummyEdgeForId = new Edge(id);\n```", "```java\n        for(int t:neighbors){\n            Edge e = ((Vertex)vertices[t]).edges.deleteValue(dummyEdgeForId).getValue();\n            ((Vertex)vertices[t]).neighbors.removeNode(e.targetNode);\n        }\n        vertices[id] = null;\n    }\n```", "```java\n    @Override\n    public void addEdge(int source, int target) {\n        Vertex sVertex = (Vertex) vertices[source];\n        Edge sEdge = sVertex.edges.insertValue(new Edge(target)).getValue();\n        sEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode<Integer>)\n        sVertex.neighbors.appendLast(sEdge.target);\n        if(undirected){\n            Vertex tVertex = (Vertex) vertices[target];\n            Edge tEdge = tVertex.edges.insertValue(new Edge(source)).getValue();\n            tEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode<Integer>)\n            tVertex.neighbors.appendLast(tEdge.target);\n        }\n    }\n```", "```java\n    @Override\n    public void removeEdge(int source, int target) {\n        Vertex sVertex = (Vertex) vertices[source];\n        Edge deletedEdge = sVertex.edges.deleteValue(new Edge(target)).getValue();\n        sVertex.neighbors.removeNode(deletedEdge.targetNode);\n        if(undirected){\n            Vertex tVertex = (Vertex) vertices[target];\n            deletedEdge = tVertex.edges.deleteValue(new Edge(source)).getValue();\n            tVertex.neighbors.removeNode(deletedEdge.targetNode);\n        }\n    }\n```", "```java\n    @Override\n    public boolean isAdjacent(int source, int target) {\n        Vertex sVertex = (Vertex) vertices[source];\n        return sVertex.edges.searchValue(new Edge(target))!=null;\n    }\n```", "```java\n    @Override\n    public LinkedList<Integer> getNeighbors(int source) {s\n        Vertex sVertex = (Vertex) vertices[source];\n        return sVertex.neighbors;\n    }\n```", "```java\n    @Override\n    public void setVertexValue(int vertex, V value) {\n        Vertex sVertex = (Vertex) vertices[vertex];\n        if(sVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ vertex \n            + \"does not exist\");\n        }else{\n            sVertex.setValue(value);\n        }\n    }\n\n    @Override\n    public V getVertexValue(int vertex) {\n        Vertex sVertex = (Vertex) vertices[vertex];\n        if(sVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ vertex \n              + \"does not exist\");\n        }else{\n            return sVertex.getValue();\n        }\n    }\n\n    @Override\n    public void setEdgeValue(int source, int target, E value) {\n        Vertex sVertex = (Vertex) vertices[source];\n        Vertex tVertex = (Vertex) vertices[target];\n        if(sVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ source \n              + \"does not exist\");\n        }else if(tVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ target \n               + \"does not exist\");\n        }else{\n            BinaryTree.Node<Edge> node = sVertex.edges.searchValue(new Edge(target));\n            if(node==null){\n                throw new IllegalArgumentException(\"Edge between \"+ source + \"and\" + target + \"does not exist\");\n\n            }else{\n                node.getValue().value = value;\n            }\n        }\n    }\n\n    @Override\n    public E getEdgeValue(int source, int target) {\n        Vertex sVertex = (Vertex) vertices[source];\n        Vertex tVertex = (Vertex) vertices[target];\n        if(sVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ source \n                 + \"does not exist\");\n        }else if(tVertex==null){\n            throw new IllegalArgumentException(\"Vertex \"+ target \n                  + \"does not exist\");\n        }else{\n            BinaryTree.Node<Edge> node =\n                    sVertex.edges.searchValue(new Edge(target));\n            if(node==null){\n                throw new IllegalArgumentException(\"Edge between \"+ source + \"and\" + target + \"does not exist\");\n            }else{\n                return node.getValue().value;\n            }\n        }\n    }\n\n    @Override\n    public boolean isUndirected() {\n        return undirected;\n    }\n\n    @Override\n    public BinarySearchTree<Integer> getAllVertices() {\n        BinarySearchTree<Integer> allVertices = new RedBlackTree<>();\n        for(int i=0;i<vertices.length;i++){\n            if(vertices[i]!=null){\n                allVertices.insertValue(i);\n            }\n        }\n        return allVertices;\n    }\n\n    @Override\n    public int maxVertexID() {\n        return vertices.length-1;\n    }\n}\n```", "```java\npublic class AdjacencyListGraphWithDenseVertex<V,E> implements Graph<V,E> {\n```", "```java\n    int nextId;\n    boolean undirected;\n```", "```java\n    class Edge implements Comparable<Edge>{\n        E value;\n        int target;\n\n        DoublyLinkedList.DoublyLinkedNode<Integer> targetNode;\n        public Edge(int target) {\n            this.target = target;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) \n                 return false;\n            Edge edge = (Edge) o;\n            return target == edge.target;\n        }\n\n        @Override\n        public int hashCode() {\n            return target;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return target - o.target;\n        }\n    }\n    class Vertex extends GraphVertex<V>{\n        RedBlackTree<Edge> edges = new RedBlackTree<Edge>();\n\n        DoublyLinkedList<Integer> neighbors \n                           = new DoublyLinkedList<>();\n        public Vertex(int id, V value) {\n            super(id, value);\n        }\n    }\n\n    public AdjacencyListGraphWithDenseVertex(boolean undirected) {\n        this.undirected = undirected;\n    }\n```", "```java\n    RedBlackTree<GraphVertex<V>> vertices = new RedBlackTree<>();\n```", "```java\n    @Override\n    public int addVertex() {\n        vertices.insertValue(new Vertex(nextId++, null));\n        return nextId;\n    }\n```", "```java\n    @Override\n    public void removeVertex(int id) {\n        vertices.deleteValue(new GraphVertex<V>(id, null));\n        vertices.traverseDepthFirstNonRecursive((gv)->{\n                BinaryTree.Node<Edge> edgeNode = ((Vertex) gv).edges.deleteValue(new Edge(id));\n                if(edgeNode!=null){\n                    Edge edge = edgeNode.getValue();\n                    ((Vertex) gv)\n                        .neighbors.removeNode(edge.targetNode);\n                }\n        },\n                BinaryTree.DepthFirstTraversalType.INORDER);\n    }\n```", "```java\n    @Override\n    public void addEdge(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n          vertices.searchValue(new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(target, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"+source+\" does not exist\");\n        }else if(tNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"+target+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            Vertex tVertex = (Vertex) tNode.getValue();\n            Edge tEdge = new Edge(target);\n            sVertex.edges.insertValue(tEdge);\n            tEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode<Integer>) sVertex.neighbors\n              .appendLast(tVertex.getId());\n            if(undirected) {\n                Edge sEdge = new Edge(source);\n                tVertex.edges.insertValue(sEdge);\n                sEdge.targetNode = (DoublyLinkedList.DoublyLinkedNode<Integer>) tVertex.neighbors\n                  .appendLast(sVertex.getId());\n            }\n        }\n    }\n```", "```java\n    @Override\n    public void removeEdge(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(target, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"+source+\" does not exist\");\n        }else if(tNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"+target+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            Edge deletedEdge = sVertex.edges.deleteValue(new Edge(target)).getValue();\n            sVertex.neighbors.removeNode(deletedEdge.targetNode);\n            if(undirected) {\n                Vertex tVertex = (Vertex) tNode.getValue();\n                deletedEdge = tVertex.edges.deleteValue(new Edge(source)).getValue();\n              tVertex.neighbors.removeNode(deletedEdge.targetNode);\n            }\n        }\n    }\n```", "```java\n    @Override\n    public boolean isAdjacent(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(target, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"\n                                   +source+\" does not exist\");\n        }else if(tNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"\n                                   +target+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            return sVertex.edges.searchValue(\n                                 new Edge(target)) != null;\n\n        }\n    }\n```", "```java\n    @Override\n    public LinkedList<Integer> getNeighbors(int source) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\n                    \"Vertex ID \"+source+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            return  sVertex.neighbors;\n        }\n    }\n```", "```java\n    @Override\n    public void setVertexValue(int vertex, V value) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(vertex, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"\n                               +vertex+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            sVertex.setValue(value);\n        }\n    }\n\n    @Override\n    public V getVertexValue(int vertex) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(vertex, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID \"\n                               +vertex+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            return sVertex.getValue();\n        }\n    }\n\n    @Override\n    public void setEdgeValue(int source, int target, E value) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(target, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID\n                           \"+source+\" does not exist\");\n        }else if(tNode == null){\n            throw new IllegalArgumentException(\"Vertex ID\n                           \"+target+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            BinaryTree.Node<Edge> edgeNode =\n                    sVertex.edges.searchValue(new Edge(target));\n            if(edgeNode!=null) {\n                edgeNode.getValue().value = value;\n                if (undirected) {\n                    Vertex tVertex = (Vertex) tNode.getValue();\n                    edgeNode = tVertex.edges\n                            .searchValue(new Edge(source));\n                    edgeNode.getValue().value = value;\n                }\n            }else{\n                throw new IllegalArgumentException(\n                          \"No edge exists between the vertices \"\n                          + source + \" and \" + target);\n            }\n        }\n    }\n\n    @Override\n    public E getEdgeValue(int source, int target) {\n        BinaryTree.Node<GraphVertex<V>> sNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(source, null));\n        BinaryTree.Node<GraphVertex<V>> tNode =\n                vertices.searchValue(\n                        new GraphVertex<V>(target, null));\n        if(sNode == null){\n            throw new IllegalArgumentException(\"Vertex ID\n                               \"+source+\" does not exist\");\n        }else if(tNode == null){\n            throw new IllegalArgumentException(\"Vertex ID\n                               \"+target+\" does not exist\");\n        }else{\n            Vertex sVertex = (Vertex) sNode.getValue();\n            BinaryTree.Node<Edge> edgeNode =\n                    sVertex.edges.searchValue(new Edge(target));\n            if(edgeNode!=null) {\n                return edgeNode.getValue().value;\n\n            }else{\n                throw new IllegalArgumentException(\n                           \"No edge exists between the vertices \"\n                           + source + \" and \" + target);\n            }\n        }\n    }\n\n    @Override\n    public boolean isUndirected() {\n        return undirected;\n    }\n\n    @Override\n    public BinarySearchTree<Integer> getAllVertices() {\n        BinarySearchTree<Integer> allVertices \n                                = new RedBlackTree<>();\n        vertices.traverseDepthFirstNonRecursive(\n                  (v) -> allVertices.insertValue(v.getId()),\n                BinaryTree.DepthFirstTraversalType.PREORDER);\n        return allVertices;\n    }\n\n    @Override\n    public int maxVertexID() {\n        return nextId -1;\n    }\n}\n```", "```java\npublic interface OrderedStore<E> {\n    void insert(E value);\n    E pickFirst();\n    E checkFirst();\n}\n```", "```java\npublic interface Stack<E> extends OrderedStore<E>{\n    void push(E value);\n    E pop();\n    E peek();\n    @Override\n    default E checkFirst(){\n        return peek();\n    }\n\n    @Override\n    default void insert(E value){\n        push(value);\n    }\n\n    @Override\n    default E pickFirst(){\n        return pop();\n    }\n}\n\npublic interface Queue<E> extends OrderedStore<E>{\n    void enqueue(E value);\n    E dequeue();\n    E peek();\n\n    @Override\n    default E checkFirst(){\n        return peek();\n    }\n\n    @Override\n    default void insert(E value){\n        enqueue(value);\n    }\n\n    @Override\n    default E pickFirst(){\n        return dequeue();\n    }\n}\n```", "```java\npublic interface TwoArgumentStatement<E,F> {\n    void doSomething(E e, F f);\n}\n```", "```java\nenum TraversalType{\n    DFT, BFT\n}\n```", "```java\ndefault void visitAllConnectedVertices(int startingNode, TwoArgumentStatement<Integer,  V> visitor, TraversalType type) {\n        OrderedStore<Integer> toBeProcessed = null;\n        boolean doneProcessing[] = new boolean[maxVertexID()+1];\n        switch (type){\n            case BFT: \n                toBeProcessed = new QueueImplLinkedList<Integer>(); \n                break;\n            case DFT: \n                toBeProcessed = new StackImplLinkedList<Integer>(); \n                break;\n        }\n\n        toBeProcessed.insert(startingNode);\n\n        while(toBeProcessed.checkFirst()!=null){\n\n            int currentVertex = toBeProcessed.pickFirst();\n            if(doneProcessing[currentVertex]){\n                continue;\n            }\n\n            doneProcessing[currentVertex] = true;\n            visitor.doSomething(currentVertex,\n                           getVertexValue(currentVertex));  \n```", "```java\n            for(int neighbor:getNeighbors(currentVertex)){\n                if(doneProcessing[neighbor]==false){\n                    toBeProcessed.insert(neighbor);\n                }\n            }\n        }\n    }\n```", "```java\nclass Edge implements Comparable<Edge>{\n        int source;\n        int target;\n\n        public Edge(int source, int target) {\n            this.source = source;\n            this.target = target;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n\n            Edge edge = (Edge) o;\n\n            if (source != edge.source) return false;\n            return target == edge.target;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = source;\n            result = 31 * result + target;\n            return result;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            if(source!=o.source){\n                return source - o.source;\n            }else {\n                return target - o.target;\n            }\n        }\n    }\n```", "```java\ndefault void visitAllConnectedEdges(int startingNode, ThreeArgumentStatement<Integer, Integer, E> visitor,\n                                        TraversalType type){\n\n        OrderedStore<Edge> toBeProcessed = null;\n        boolean doneProcessing[] = new boolean[maxVertexID()+1];\n        switch (type){\n            case BFT: toBeProcessed = new QueueImplLinkedList<Edge>(); break;\n            case DFT: toBeProcessed = new StackImplLinkedList<Edge>(); break;\n        }\n        toBeProcessed.insert(new Edge(-1, startingNode));\n        while (toBeProcessed.checkFirst()!=null){\n            Edge edge = toBeProcessed.pickFirst();\n            LinkedList<Integer> neighbors = getNeighbors(edge.target);\n            if(edge.source>=0) {\n                visitor.doSomething(edge.source, edge.target,\n                  getEdgeValue(edge.source, edge.target));\n            }\n            if(doneProcessing[edge.target]){\n                continue;\n            }\n\n            for(int target: neighbors){\n                if(isUndirected() && doneProcessing[target]){\n                    continue;\n                }\n                Edge nextEdge = new Edge(edge.target, target);\n                if(nextEdge.target!=edge.source)\n                    toBeProcessed.insert(nextEdge);\n            }\n\n            doneProcessing[edge.target] = true;\n        }\n    }\n```", "```java\ndefault void checkDirectedCycleFromVertex(\n            com.example.functional.LinkedList<Integer> path, BinarySearchTree<Integer> allVertices){\n```", "```java\n        int top = path.head();\n        allVertices.deleteValue(top);\n        LinkedList<Integer> neighbors = getNeighbors(top);\n```", "```java\n        for(int n:neighbors){\n            com.example.functional.LinkedList<Integer> pathPart = path;\n            while (!pathPart.isEmpty()){\n                int head = pathPart.head();\n                if(head == n){\n                    throw new CycleDetectedException(\"Cycle detected\");\n                }\n                pathPart = pathPart.tail();\n            }\n            checkDirectedCycleFromVertex(path.add(n), allVertices);\n        }\n    }\n```", "```java\ndefault boolean detectCycle(){\n```", "```java\n        BinarySearchTree<Integer> allVertices = getAllVertices();\n        try {\n            if (isUndirected()) {\n                while (allVertices.getRoot() != null) {\n                    int start = allVertices.getRoot().getValue();\n                    RedBlackTree<Integer> metAlready \n                                     = new RedBlackTree<>();\n                    metAlready.insertValue(start);\n                    allVertices.deleteValue(start);\n                    visitAllConnectedEdges(start, (s, t, v) -> {\n                            if(metAlready.searchValue(t) == null) {\n                                metAlready.insertValue(t);\n                                allVertices.deleteValue(t);\n                            }else if(metAlready.searchValue(s)== null){\n                                metAlready.insertValue(s);\n                                allVertices.deleteValue(s);\n                            }else{\n                                throw new CycleDetectedException(\n                                  \"found \"+t);\n                            }\n                        }, TraversalType.DFT);\n                }\n            } else {\n                while (allVertices.getRoot() != null) {\n                    checkDirectedCycleFromVertex(\n                      com.example.functional.LinkedList\n                      .<Integer>emptyList().add(allVertices.getRoot().getValue()), allVertices);\n                }\n            }\n        }catch (CycleDetectedException ex){\n            return true;\n        }\n        return false;\n    }\n```", "```java\npublic class UnionFind<E extends Comparable<E>> {\n```", "```java\n    private class Node implements Comparable<Node>{\n        Node parent;\n        E object;\n        int rank;\n\n        public Node(E  object) {\n            this.object = object;\n            rank = 0;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return object.compareTo(o.object);\n        }\n    }\n```", "```java\n    BinarySearchTree<Node> allNodes = new RedBlackTree<>();\n```", "```java\n    int partitionCount;\n```", "```java\n    public void add(E object){\n        Node n = new Node(object);\n        allNodes.insertValue(n);\n        partitionCount++;\n    }\n```", "```java\n    Node findRoot(Node n){\n        if(n.parent==null){\n            return n;\n        }else{\n            return findRoot(n.parent);\n        }\n    }\n```", "```java\n    public void union(E o1, E o2){\n        BinaryTree.Node<Node> node1 = allNodes.searchValue(new Node(o1));\n        BinaryTree.Node<Node> node2 = allNodes.searchValue(new Node(o2));\n        if(node1==null || node2==null){\n            throw new IllegalArgumentException(\"Objects not found\");\n        }\n        Node n1 = node1.getValue();\n        Node n2 = node2.getValue();\n        Node p1 = findRoot(n1);\n        Node p2 = findRoot(n2);\n        if(p1==p2){\n            return;\n        }\n        int r1 = n1.rank;\n        int r2 = n2.rank;\n        if(r1>r2){\n            p2.parent = p1;\n        }else if(r2>r1){\n            p1.parent = p2;\n        }else{\n            p2.parent = p1;\n            p1.rank++;\n        }\n        partitionCount--;\n    }\n```", "```java\n    public E find(E object){\n        BinaryTree.Node<Node> node1 = allNodes.searchValue(new Node(object));\n        if(node1==null){\n            throw new IllegalArgumentException(\"Objects not found\");\n        }\n        Node n = node1.getValue();\n        return findRoot(n).object;\n    }\n}\n```", "```java\nclass CostEdge extends Edge{\n        Integer cost;\n\n        public CostEdge(int source, int target, int cost) {\n            super(source, target);\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return cost - ((CostEdge)o).cost;\n        }\n    }\n```", "```java\ndefault LinkedList<Edge> minimumSpanningTree(OneArgumentExpression<E,Integer> costFinder){\n        if(!isUndirected()){\n            throw new IllegalStateException(\n              \"Spanning tree only applicable to undirected trees\");\n        }\n        LinkedList<Edge> subGraph = new LinkedList<>();\n\n        PriorityQueue<CostEdge> edgeQueue = new LinkedHeap<>((x, y)->x.compareTo(y));\n\n        UnionFind<Integer> unionFind = new UnionFind<>();\n\n        this.visitAllConnectedEdges(getAllVertices().getRoot().getValue(), (s,t,v)-> edgeQueue.enqueue(\n            new CostEdge(s,t,costFinder.compute(v))), TraversalType.DFT);\n\n        this.getAllVertices().traverseDepthFirstNonRecursive(\n          (x)->unionFind.add(x),\n                BinaryTree.DepthFirstTraversalType.PREORDER);\n\n        while((unionFind.getPartitionCount()>1 \n                               && edgeQueue.checkMinimum()!=null){\n            Edge e = edgeQueue.dequeueMinimum();\n            int sGroup = unionFind.find(e.source);\n            int tGroup = unionFind.find(e.target);\n            if(sGroup!=tGroup){\n                subGraph.appendLast(e);\n                unionFind.union(e.source, e.target);\n            }\n        }\n        return subGraph;\n    }\n```"]