<html><head></head><body>
		<div id="_idContainer121">
			<h1 id="_idParaDest-358"><em class="italic"><a id="_idTextAnchor357"/>Chapter 19</em>: Logging and Testing</h1>
			<p>In this chapter, we will cover logging and testing from the jOOQ perspective. Relying on the fact that these are common-sense notions, I won't explain what logging and testing are, nor will I highlight their obvious importance. That being said, let's jump directly into the agenda of this chapter:</p>
			<ul>
				<li>jOOQ logging</li>
				<li>jOOQ testing</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor358"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19</a>.</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>jOOQ logging</h1>
			<p>By default, you'll see the jOOQ logs at the <strong class="source-inline">DEBUG</strong> level during code generation and during queries/routine <a id="_idIndexMarker1819"/>execution. For instance, during a regular <strong class="source-inline">SELECT</strong> execution, jOOQ logs the query SQL string (with and without the bind values), the first 5 records from the fetched result set as a nice formatted table, and the size of the result is set as shown in the following figure:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/Figure_19.1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.1 – A default jOOQ log for a SELECT execution</p>
			<p>This figure reveals a few important aspects of jOOQ logging. First of all, the jOOQ logger is named <strong class="source-inline">org.jooq.tools.LoggerListener</strong> and represents an implementation of the <strong class="source-inline">ExecuteListener</strong> SPI presented in <a href="B16833_18.xhtml#_idTextAnchor338"><em class="italic">Chapter 18</em></a>, <em class="italic">jOOQ SPI (Providers and Listeners)</em>. Under the hood, <strong class="source-inline">LoggerListener</strong> uses an internal abstraction (<strong class="source-inline">org.jooq.tools.JooqLogger</strong>) that attempts to interact with any of the famous loggers, sl4j, log4j, or the Java Logging API (<strong class="source-inline">java.util.logging</strong>). So, if your application uses any of these loggers, jOOQ hooks into it and uses it.</p>
			<p>As you can see in <a id="_idIndexMarker1820"/>this figure, jOOQ logs the query SQL string when the <strong class="source-inline">renderEnd()</strong> callback is invoked, and the fetched result set when the <strong class="source-inline">resultEnd()</strong> callback is invoked. Nevertheless, the jOOQ methods that rely on lazy (sequential) access to the underlying JDBC <strong class="source-inline">ResultSet</strong> (so, methods that uses <strong class="source-inline">Iterator</strong>  of the <strong class="source-inline">Cursor</strong>– for instance, <strong class="source-inline">ResultQuery.fetchStream()</strong> and <strong class="source-inline">ResultQuery.collect()</strong>) don't pass through <strong class="source-inline">resultStart()</strong> and <strong class="source-inline">resultEnd()</strong>. In such cases, only the first five records from <strong class="source-inline">ResultSet</strong> are buffered by jOOQ and are available for logging in <strong class="source-inline">fetchEnd()</strong> via <strong class="source-inline">ExecuteContext.data("org.jooq.tools.LoggerListener.BUFFER")</strong>. The rest of the records are either lost or skipped.</p>
			<p>If we execute a routine or the query is a DML, then other callbacks are involved as well. Are you curious to find out more?! Then you'll enjoy studying the <strong class="source-inline">LoggerListener</strong> source code by yourself.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>jOOQ logging in Spring Boot – default zero-configuration logging</h2>
			<p>In Spring Boot 2.x, without <a id="_idIndexMarker1821"/>providing any explicit logging <a id="_idIndexMarker1822"/>configurations, we see logs printed in the console at the <strong class="source-inline">INFO</strong> level. This is happening because the Spring Boot default logging functionality uses the popular Logback logging framework.</p>
			<p>Mainly, the Spring Boot logger is determined by the <strong class="source-inline">spring-boot-starter-logging</strong> artifact that (based on the provided configuration or auto-configuration) activates any of the supported logging providers (<strong class="source-inline">java.util.logging</strong>, log4j2, and Logback). This artifact can be imported explicitly or transitively (for instance, as a dependency of <strong class="source-inline">spring-boot-starter-web</strong>).</p>
			<p>In this context, having <a id="_idIndexMarker1823"/>a Spring Boot application with no explicit logging configurations <a id="_idIndexMarker1824"/>will not log jOOQ messages. However, we can take advantage of jOOQ logging if we simply enable the <strong class="source-inline">DEBUG</strong> level (or <strong class="source-inline">TRACE</strong> for more verbose logging). For instance, we can do it in the <strong class="source-inline">application.properties</strong> as follows:</p>
			<pre class="source-code">// set DEBUG level globally</pre>
			<pre class="source-code">logging.level.root=DEBUG </pre>
			<pre class="source-code">// or, set DEBUG level only for jOOQ</pre>
			<pre class="source-code">logging.level.org.jooq.tools.LoggerListener=DEBUG</pre>
			<p>You can practice this example in <em class="italic">SimpleLogging</em> for MySQL.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>jOOQ logging with Logback/log4j2</h2>
			<p>If you already have <a id="_idIndexMarker1825"/>Logback configured (for instance, via <strong class="source-inline">logback-spring.xml</strong>), then you'll <a id="_idIndexMarker1826"/>need to add the <a id="_idIndexMarker1827"/>jOOQ logger, as follows:</p>
			<pre class="source-code">…</pre>
			<pre class="source-code">&lt;!-- SQL execution logging is logged to the </pre>
			<pre class="source-code">     LoggerListener logger at DEBUG level --&gt;</pre>
			<pre class="source-code">&lt;logger name="org.jooq.tools.LoggerListener" </pre>
			<pre class="source-code">        level="debug" additivity="false"&gt;</pre>
			<pre class="source-code">  &lt;appender-ref ref="ConsoleAppender"/&gt;</pre>
			<pre class="source-code">&lt;/logger&gt;</pre>
			<pre class="source-code">&lt;!-- Other jOOQ related debug log output --&gt;</pre>
			<pre class="source-code">&lt;logger name="org.jooq" level="debug" additivity="false"&gt;</pre>
			<pre class="source-code">  &lt;appender-ref ref="ConsoleAppender"/&gt;</pre>
			<pre class="source-code">&lt;/logger&gt;</pre>
			<pre class="source-code">…</pre>
			<p>You can practice this <a id="_idIndexMarker1828"/>example in <em class="italic">Logback</em> for MySQL. If you prefer log4j2, then <a id="_idIndexMarker1829"/>consider the <em class="italic">Log4j2</em> application for MySQL. The <a id="_idIndexMarker1830"/>jOOQ logger is configured in <strong class="source-inline">log4j2.xml</strong>.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor362"/>Turn off jOOQ logging</h2>
			<p>Turning on/off jOOQ logging <a id="_idIndexMarker1831"/>can be done via the <strong class="source-inline">set</strong>/<strong class="source-inline">withExecuteLogging()</strong> setting. For instance, the following query will not be logged:</p>
			<pre class="source-code">ctx.configuration().derive(</pre>
			<pre class="source-code">       new Settings().withExecuteLogging(Boolean.FALSE))</pre>
			<pre class="source-code">   .dsl()</pre>
			<pre class="source-code">   .select(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR)</pre>
			<pre class="source-code">   .from(PRODUCT).fetch();</pre>
			<p>You can practice this example in <em class="italic">TurnOffLogging</em> for MySQL. Note that this setting doesn't affect the jOOQ Code Generator logging. That logging is configured with <strong class="source-inline">&lt;logging&gt;LEVEL&lt;/logging&gt;</strong> (Maven), <strong class="source-inline">logging = 'LEVEL'</strong> (Gradle), or <strong class="source-inline">.withLogging(Logging.LEVEL)</strong> (programmatically). <strong class="source-inline">LEVEL</strong> can be any of <strong class="source-inline">TRACE</strong>, <strong class="source-inline">DEBUG</strong>, <strong class="source-inline">INFO</strong>, <strong class="source-inline">WARN</strong>, <strong class="source-inline">ERROR</strong>, and <strong class="source-inline">FATAL</strong>. Here is the Maven approach for setting the <strong class="source-inline">WARN</strong> level – log everything that is bigger or equal to the <strong class="source-inline">WARN</strong> level:</p>
			<pre class="source-code">&lt;configuration xmlns="..."&gt;</pre>
			<pre class="source-code">  &lt;logging&gt;WARN&lt;/logging&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>You can practice this example in <em class="italic">GenCodeLogging</em> for MySQL.</p>
			<p>In the second part <a id="_idIndexMarker1832"/>of this section, let's tackle a suite of examples that should help you to get familiar with different techniques of customizing jOOQ logging. Based on these examples, you should be capable of solving your scenarios. Since these are just examples, they won't cover all possible cases, which is worth remembering in your real scenarios.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>Customizing result set logging</h2>
			<p>By default, jOOQ truncates <a id="_idIndexMarker1833"/>the logged result set to five records. However, we can easily log the entire result set via <strong class="source-inline">format(int size)</strong>, as shown here:</p>
			<pre class="source-code">private static final Logger log = </pre>
			<pre class="source-code">        LoggerFactory.getLogger(...);</pre>
			<pre class="source-code">var result = ctx.select(...)...</pre>
			<pre class="source-code">                   .fetch();</pre>
			<pre class="source-code">log.debug("Result set:\n" + result.format</pre>
			<pre class="source-code">    (result.size()));      </pre>
			<p>How about logging the whole result set for every query (excluding queries that rely on lazy, sequential access to an underlying JDBC <strong class="source-inline">ResultSet</strong>)? Moreover, let's assume that we plan to log the row number, as shown in the following figure:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_19.2.jpg" alt="Figure 19.2 – Customizing result set logging&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.2 – Customizing result set logging</p>
			<p>One approach <a id="_idIndexMarker1834"/>for accomplishing this consists of writing a custom logger as <strong class="source-inline">ExecuteListener</strong> and overriding the <strong class="source-inline">resultEnd()</strong> method:</p>
			<pre class="source-code">public class MyLoggerListener extends DefaultExecuteListener {</pre>
			<pre class="source-code"> private static final JooqLogger log = </pre>
			<pre class="source-code">    JooqLogger.getLogger(LoggerListener.class);</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void resultEnd(ExecuteContext ctx) {</pre>
			<pre class="source-code">  Result&lt;?&gt; result = ctx.result();</pre>
			<pre class="source-code">  if (result != null) {</pre>
			<pre class="source-code">    logMultiline("Total Fetched result", </pre>
			<pre class="source-code">                  result.format(), Level.FINE, result.size());</pre>
			<pre class="source-code">    log.debug("Total fetched row(s)", result.size());</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> // inspired from jOOQ source code </pre>
			<pre class="source-code"> private void logMultiline(String comment,  </pre>
			<pre class="source-code">           String message, Level level, int size) {</pre>
			<pre class="source-code">   // check the bundled code</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>You can <a id="_idIndexMarker1835"/>practice this example in <em class="italic">LogAllRS</em> for MySQL. </p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor364"/>Customizing binding parameters logging</h2>
			<p>If we switch the logging level to <strong class="source-inline">TRACE</strong> (<strong class="source-inline">logging.level.root=TRACE</strong>), then we get more <a id="_idIndexMarker1836"/>verbose jOOQ logging. For instance, the bind parameters are logged as a separate list, as shown in this example:</p>
			<pre class="source-code">Binding variable 1 : 5000 (integer /* java.lang.Integer */)</pre>
			<pre class="source-code">Binding variable 2 : 223113 (bigint /* java.lang.Long */)</pre>
			<pre class="source-code">...</pre>
			<p>Challenge yourself to customize this list to look different and to be logged at <strong class="source-inline">DEBUG</strong> level. You can find some inspiration in <em class="italic">LogBind</em> for MySQL, which logs bindings like this:</p>
			<pre class="source-code">... : [1] as integer /* java.lang.Integer */ - [5000]</pre>
			<pre class="source-code">... : [vintageCars] as bigint /* java.lang.Long */ - [223113]</pre>
			<pre class="source-code">...</pre>
			<p>How about log bindings as a nice formatted table? I'm looking forward to seeing your code.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor365"/>Customizing logging invocation order</h2>
			<p>Let's assume that <a id="_idIndexMarker1837"/>we plan to enrich jOOQ logging to log a chart, as shown here:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_19.3.jpg" alt="Figure 19.3 – Logging a chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.3 – Logging a chart</p>
			<p>This chart is logged only for <strong class="source-inline">SELECT</strong> statements that contain <strong class="source-inline">PRODUCT.PRODUCT_ID</strong> (represented on the X axis of the chart – category) and <strong class="source-inline">PRODUCT.BUY_PRICE</strong> (represented on the Y axis of the chart – value). Moreover, we don't take into account the queries that <a id="_idIndexMarker1838"/>rely on lazy sequential access to the underlying JDBC <strong class="source-inline">ResultSet</strong>, such as <strong class="source-inline">ctx.selectFrom(PRODUCT).collect(Collectors.toList());</strong>. In such cases, jOOQ buffers for logging only the first five records, so, in most of the cases, the chart will be irrelevant.</p>
			<p>The first step consists of writing a custom <strong class="source-inline">ExecuteListener</strong> (our own logger) and overriding the <strong class="source-inline">resultEnd()</strong> method – called after fetching a set of records from <strong class="source-inline">ResultSet</strong>. In this method, we search for <strong class="source-inline">PRODUCT.PRODUCT_ID</strong> and <strong class="source-inline">PRODUCT.BUY_PRICE</strong>, and if we find them, then we use the jOOQ <strong class="source-inline">ChartFormat</strong> API, as shown here:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void resultEnd(ExecuteContext ecx) {</pre>
			<pre class="source-code"> if (ecx.query() != null &amp;&amp; ecx.query() instanceof Select) {</pre>
			<pre class="source-code">  Result&lt;?&gt; result = ecx.result();</pre>
			<pre class="source-code">  if (result != null &amp;&amp; !result.isEmpty()) {</pre>
			<pre class="source-code">   final int x = result.indexOf(PRODUCT.PRODUCT_ID);</pre>
			<pre class="source-code">   final int y = result.indexOf(PRODUCT.BUY_PRICE);</pre>
			<pre class="source-code">   if (x != -1 &amp;&amp; y != -1) {</pre>
			<pre class="source-code">    ChartFormat cf = new ChartFormat()</pre>
			<pre class="source-code">     .category(x)</pre>
			<pre class="source-code">     .values(y)</pre>
			<pre class="source-code">     .shades('x');</pre>
			<pre class="source-code">    String[] chart = result.formatChart(cf).split("\n");</pre>
			<pre class="source-code">    log.debug("Start Chart", "");</pre>
			<pre class="source-code">    for (int i = 0; i &lt; chart.length; i++) {</pre>
			<pre class="source-code">     log.debug("", chart[i]);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    log.debug("End Chart", "");</pre>
			<pre class="source-code">   } else {</pre>
			<pre class="source-code">     log.debug("Chart", "The chart cannot be </pre>
			<pre class="source-code">                         constructed (missing data)");</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>There is one more thing that we need. At this moment, our <strong class="source-inline">resultEnd()</strong> is invoked after the jOOQ's <strong class="source-inline">LoggerListener.resultEnd()</strong> is invoked, which means that our chart is logged after the result set. However, if you look at the previous figure, you can see that our chart is logged before the result set. This can be accomplished by reversing the order of invocation for the <strong class="source-inline">fooEnd()</strong> methods:</p>
			<pre class="source-code">configuration.settings()</pre>
			<pre class="source-code"> .withExecuteListenerEndInvocationOrder(</pre>
			<pre class="source-code">    InvocationOrder.REVERSE);</pre>
			<p>So, by default, as long as the jOOQ logger is enabled, our loggers (the overridden <strong class="source-inline">fooStart()</strong> and <strong class="source-inline">fooEnd()</strong> methods) are invoked after their counterparts from the default logger (<strong class="source-inline">LoggingLogger</strong>). But, we can reverse the default order via two settings: <strong class="source-inline">withExecuteListenerStartInvocationOrder()</strong> for <strong class="source-inline">fooStart()</strong> methods and <strong class="source-inline">withExecuteListenerEndInvocationOrder()</strong> for <strong class="source-inline">fooEnd()</strong> methods. In our <a id="_idIndexMarker1839"/>case, after reversion, our <strong class="source-inline">resultEnd()</strong> is called before <strong class="source-inline">LoggingLogger.resultEnd()</strong>, and this is how we slipped our chart in the proper place. You can practice this example in <em class="italic">ReverseLog</em> for MySQL.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor366"/>Wrapping jOOQ logging into custom text</h2>
			<p>Let's assume that <a id="_idIndexMarker1840"/>we plan to wrap each query/routine default logging into some custom text, as shown in the following figure:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_19.4.jpg" alt="Figure 19.4 – Wrapping jOOQ logging into custom text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.4 – Wrapping jOOQ logging into custom text</p>
			<p>Before checking <a id="_idIndexMarker1841"/>a potential solution in <em class="italic">WrapLog</em> for MySQL, consider challenging yourself to solve it.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor367"/>Filtering jOOQ logging</h2>
			<p>Sometimes, we want to be very selective with what's being logged. For instance, let's assume that only <a id="_idIndexMarker1842"/>the SQL strings for the <strong class="source-inline">INSERT</strong> and <strong class="source-inline">DELETE</strong> statements should be logged. So, after we turn off the jOOQ default logger, we set up our logger, which should be capable of isolating the <strong class="source-inline">INSERT</strong> and <strong class="source-inline">DELETE</strong> statements from the rest of the queries. A simple approach consists of applying a simple check, such as (<strong class="source-inline">query instanceof Insert || query instanceof Delete</strong>), where <strong class="source-inline">query</strong> is given by <strong class="source-inline">ExecuteContext.query()</strong>. However, this will not work in the case of plain SQL or batches containing the <strong class="source-inline">INSERT</strong> and <strong class="source-inline">DELETE</strong> statements. Specifically for such cases, we can apply a regular expression, such as "<strong class="source-inline">^(?i:(INSERT|DELETE).*)$</strong>", to the SQL string(s) returned via <strong class="source-inline">ExecuteContext</strong> passed in <strong class="source-inline">renderEnd()</strong>. While you can find these words materialized in code lines in <em class="italic">FilterLog</em> for MySQL, let's focus on another scenario.</p>
			<p>Let's assume that we plan to log only regular <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong> statements that contain a suite of given tables (plain SQL, batches, and routines are not logged at all). For instance, we can conveniently pass the desired tables via <strong class="source-inline">data()</strong> as follows:</p>
			<pre class="source-code">ctx.data().put(EMPLOYEE.getQualifiedName(), "");</pre>
			<pre class="source-code">ctx.data().put(SALE.getQualifiedName(), "");</pre>
			<p>So, if a query refers to the <strong class="source-inline">EMPLOYEE</strong> and <strong class="source-inline">SALE</strong> tables, then, and only then, should it be logged. This time, relying on regular expressions can be a little bit sophisticated and risky. It would be more proper to rely on a <strong class="source-inline">VisitListener</strong> that allows us to inspect the AST and extract the referred tables of the current query with a robust approach. Every <strong class="source-inline">QueryPart</strong> passes through <strong class="source-inline">VisitListener</strong>, so we can inspect its type and collect it accordingly:</p>
			<pre class="source-code">private static class TablesExtractor </pre>
			<pre class="source-code">      extends DefaultVisitListener {</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void visitEnd(VisitContext vcx) {</pre>
			<pre class="source-code">  if (vcx.renderContext() != null) {</pre>
			<pre class="source-code">    if (vcx.queryPart() instanceof Table) {</pre>
			<pre class="source-code">     Table&lt;?&gt; t = (Table&lt;?&gt;) vcx.queryPart();</pre>
			<pre class="source-code">     vcx.configuration().data()</pre>
			<pre class="source-code">            .putIfAbsent(t.getQualifiedName(), "");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>When <strong class="source-inline">VisitListener</strong> finishes its execution, we have already traversed all <strong class="source-inline">QueryPart</strong>, and we've collected all the tables involved in the current query, so we can compare these tables with the given tables and decide whether or not to log the current query. Note that our <strong class="source-inline">VisitListener</strong> has been declared as <strong class="source-inline">private static class</strong> because we use it internally in our <strong class="source-inline">ExecuteListener</strong> (our logger), which orchestrates <a id="_idIndexMarker1843"/>the logging process. More precisely, at the proper moment, we append this <strong class="source-inline">VisitListener</strong> to a configuration derived from the configuration of <strong class="source-inline">ExecuteContext</strong>, passed to our <strong class="source-inline">ExecuteListener</strong>. So, this <strong class="source-inline">VisitListener</strong> is not appended to the configuration of <strong class="source-inline">DSLContext</strong> that is used to execute the query. </p>
			<p>The relevant part of our logger (<strong class="source-inline">ExecuteListener</strong>) is listed here:</p>
			<pre class="source-code">public class MyLoggerListener extends DefaultExecuteListener {</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void renderEnd(ExecuteContext ecx) {</pre>
			<pre class="source-code">  if (ecx.query() != null &amp;&amp;</pre>
			<pre class="source-code">      !ecx.configuration().data().isEmpty()) {</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code"><strong class="bold">   Configuration configuration = ecx.configuration()</strong></pre>
			<pre class="source-code"><strong class="bold">             .deriveAppending(new TablesExtractor());</strong></pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">   if (configuration.data().keySet().containsAll(tables)) {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>Check out the highlighted code. The <strong class="source-inline">deriveAppending()</strong> method creates a derived <strong class="source-inline">Configuration</strong> from <a id="_idIndexMarker1844"/>this one (by "this one", we understand <strong class="source-inline">Configuration</strong> of the current <strong class="source-inline">ExecuteContext</strong>, which was automatically derived from the <strong class="source-inline">Configuration</strong> of <strong class="source-inline">DSLContext</strong>), with appended visit listeners. Practically, this <strong class="source-inline">VisitListener</strong> is inserted into <strong class="source-inline">Configuration</strong> through <strong class="source-inline">VisitListenerProvider</strong>, which is responsible for creating a new listener instance for every rendering life cycle.</p>
			<p>However, what's the point of this? In short, it is all about performance and scopes (<strong class="source-inline">org.jooq.Scope</strong>). <strong class="source-inline">VisitListener</strong> is intensively called; therefore, it can have some impact on rendering performance. So, in order to minimize its usage, we ensure that it is used only in the proper conditions from our logger. In addition, <strong class="source-inline">VisitListener</strong> should store the list of tables that are being rendered in some place accessible to our logger. Since we choose to rely on the <strong class="source-inline">data()</strong> map, we have to ensure that the logger and <strong class="source-inline">VisitListener</strong> have access to it. By appending <strong class="source-inline">VisitListener</strong> to the logger via <strong class="source-inline">deriveAppending()</strong>, we append its <strong class="source-inline">Scope</strong> as well, so the <strong class="source-inline">data()</strong> map is accessible from both. This way, we can share custom data between the logger and <strong class="source-inline">VisitContext</strong> for the entire lifetime of the scope.</p>
			<p>You can <a id="_idIndexMarker1845"/>practice this example in <em class="italic">FilterVisitLog</em> for MySQL. Well, that's all about logging. Next, let's talk about testing.</p>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor368"/>jOOQ testing</h1>
			<p>Accomplishing jOOQ testing can be done in several ways, but we can immediately highlight that the less <a id="_idIndexMarker1846"/>appealing option relies on mocking the jOOQ API, while the best option relies on writing integration tests against the production database (or at least against an in-memory database). Let's start with the option that fits well only in simple cases, mocking the jOOQ API.</p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor369"/>Mocking the jOOQ API</h2>
			<p>While mocking the JDBC API can <a id="_idIndexMarker1847"/>be really difficult, jOOQ solves <a id="_idIndexMarker1848"/>this chore and exposes a simple mock API via <strong class="source-inline">org.jooq.tools.jdbc</strong>. The climax of this API is represented by the <strong class="source-inline">MockConnection</strong> (for mocking a database connection) and <strong class="source-inline">MockDataProvider</strong> (for mocking query executions). Assuming that jUnit 5 is used, we can mock a connection like this:</p>
			<pre class="source-code">public class ClassicmodelsTest {</pre>
			<pre class="source-code"> public static DSLContext ctx;</pre>
			<pre class="source-code"> @BeforeAll</pre>
			<pre class="source-code"> public static void setup() {</pre>
			<pre class="source-code">  // Initialise your data provider</pre>
			<pre class="source-code">  MockDataProvider provider = new ClassicmodelsMockProvider();</pre>
			<pre class="source-code">  MockConnection connection = new MockConnection(provider);</pre>
			<pre class="source-code">  // Pass the mock connection to a jOOQ DSLContext</pre>
			<pre class="source-code">  ClassicmodelsTest.ctx = DSL.using(</pre>
			<pre class="source-code">                    connection, SQLDialect.MYSQL);</pre>
			<pre class="source-code">  // Optionally, you may want to disable jOOQ logging</pre>
			<pre class="source-code">  ClassicmodelsTest.ctx.configuration().settings()</pre>
			<pre class="source-code">          .withExecuteLogging(Boolean.FALSE);</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> // add tests here</pre>
			<pre class="source-code">}</pre>
			<p>Before writing tests, we have to prepare <strong class="source-inline">ClassicmodelsMockProvider</strong> as an implementation <a id="_idIndexMarker1849"/>of <strong class="source-inline">MockDataProvider</strong> that overrides <a id="_idIndexMarker1850"/>the <strong class="source-inline">execute()</strong> method. This method returns an array of <strong class="source-inline">MockResult</strong> (each <strong class="source-inline">MockResult</strong> represents a mock result). A possible implementation may look as follows:</p>
			<pre class="source-code">public class ClassicmodelsMockProvider </pre>
			<pre class="source-code">                  implements MockDataProvider {</pre>
			<pre class="source-code"> private static final String ACCEPTED_SQL =  </pre>
			<pre class="source-code">    "(SELECT|UPDATE|INSERT|DELETE).*";</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public MockResult[] execute(MockExecuteContext mex) </pre>
			<pre class="source-code">   throws SQLException {</pre>
			<pre class="source-code">  // The DSLContext can be used to create </pre>
			<pre class="source-code">  // org.jooq.Result and org.jooq.Record objects</pre>
			<pre class="source-code">  DSLContext ctx = DSL.using(SQLDialect.MYSQL);</pre>
			<pre class="source-code">  // So, here we can have maximum 3 results</pre>
			<pre class="source-code">  MockResult[] mock = new MockResult[3];</pre>
			<pre class="source-code">  // The execute context contains SQL string(s), </pre>
			<pre class="source-code">  // bind values, and other meta-data</pre>
			<pre class="source-code">  String sql = mex.sql();</pre>
			<pre class="source-code">  // Exceptions are propagated through the JDBC and jOOQ APIs</pre>
			<pre class="source-code">  if (!sql.toUpperCase().matches(ACCEPTED_SQL)) {</pre>
			<pre class="source-code">   throw new SQLException("Statement not supported: " + sql);</pre>
			<pre class="source-code">  } </pre>
			<pre class="source-code">  // From this point forward, you decide, whether any given </pre>
			<pre class="source-code">  // statement returns results, and how many</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Now, we are <a id="_idIndexMarker1851"/>ready to go! First, we can write a test. Here <a id="_idIndexMarker1852"/>is an example:</p>
			<pre class="source-code">@Test</pre>
			<pre class="source-code">public void sampleTest() {</pre>
			<pre class="source-code"> Result&lt;Record2&lt;Long, String&gt;&gt; result = </pre>
			<pre class="source-code">   ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">      .from(PRODUCT)</pre>
			<pre class="source-code">      .where(PRODUCT.PRODUCT_ID.eq(1L))</pre>
			<pre class="source-code">      .fetch();</pre>
			<pre class="source-code"> assertThat(result, hasSize(equalTo(1)));</pre>
			<pre class="source-code"> assertThat(result.getValue(0, PRODUCT.PRODUCT_ID), </pre>
			<pre class="source-code">   is(equalTo(1L)));</pre>
			<pre class="source-code"> assertThat(result.getValue(0, PRODUCT.PRODUCT_NAME), </pre>
			<pre class="source-code">   is(equalTo("2002 Suzuki XREO")));</pre>
			<pre class="source-code">}</pre>
			<p>The code <a id="_idIndexMarker1853"/>that mocks this <a id="_idIndexMarker1854"/>behavior is added in <strong class="source-inline">ClassicmodelsMockProvider</strong>:</p>
			<pre class="source-code">private static final String SELECT_ONE_RESULT_ONE_RECORD =  </pre>
			<pre class="source-code"> "select ... where `classicmodels`.`product`.`product_id`=?";</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">} else if (sql.equals(SELECT_ONE_RESULT_ONE_RECORD)) {</pre>
			<pre class="source-code">  Result&lt;Record2&lt;Long, String&gt;&gt; result</pre>
			<pre class="source-code">    = ctx.newResult(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME);</pre>
			<pre class="source-code">  result.add(</pre>
			<pre class="source-code">    ctx.newRecord(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">       .values(1L, "2002 Suzuki XREO"));</pre>
			<pre class="source-code">   mock[0] = new MockResult(-1, result);</pre>
			<pre class="source-code">}</pre>
			<p>The first argument of the <strong class="source-inline">MockResult</strong> constructor represents the number of affected rows, and -<strong class="source-inline">1</strong> represents that the row count not being applicable. In the bundled code (<em class="italic">Mock</em> for MySQL), you can see more examples, including testing batching, fetching many results, and <a id="_idIndexMarker1855"/>deciding the result based on the bindings. However, do <a id="_idIndexMarker1856"/>not forget that jOOQ testing is equivalent to testing the database interaction, so mocking is proper only for simple cases. Do not use it for transactions, locking, or testing your entire database!</p>
			<p>If you don't believe me, then follow Lukas Eder's statement: <em class="italic">"The fact that mocking only fits well in a few cases can't be stressed enough. People will still attempt to use this SPI, because it looks so easy to do, not thinking about the fact that they're about to implement a full-fledged DBMS in the poorest of ways. I've had numerous users to whom I've explained this 3-4x: 'You're about to implement a full-fledged DBMS" and they keep asking me: "Why doesn't jOOQ 'just' execute this query when I mock it?" – "Well jOOQ *isn't* a DBMS, but it allows you to pretend you can write one, using the mocking SPI."</em> <em class="italic">And they keep asking again and again. Hard to imagine what's tricky about this, but as much as it helps with SEO (people want to solve this problem, then discover jOOQ), I regret leading some developers down this path... It's excellent though to test some converter and mapping integrations within jOOQ."</em></p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor370"/>Writing integration tests</h2>
			<p>A quick approach <a id="_idIndexMarker1857"/>for writing integration tests for jOOQ relies <a id="_idIndexMarker1858"/>on simply creating <strong class="source-inline">DSLContext</strong> for the production database. Here is an example:</p>
			<pre class="source-code">public class ClassicmodelsIT {</pre>
			<pre class="source-code"> private static DSLContext ctx;</pre>
			<pre class="source-code"> @BeforeAll</pre>
			<pre class="source-code"> public static void setup() {</pre>
			<pre class="source-code">  ctx = DSL.using("jdbc:mysql://localhost:3306/</pre>
			<pre class="source-code">    classicmodels" + "?allowMultiQueries=true", "root", "root");</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> @Test</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>However, this approach (exemplified in <em class="italic">SimpleTest</em> for MySQL) fits well for simple scenarios that don't <a id="_idIndexMarker1859"/>require dealing with transaction <a id="_idIndexMarker1860"/>management (begin, commit, and rollback). For instance, if you just need to test your <strong class="source-inline">SELECT</strong> statements, then most probably this approach is all you need.</p>
			<h3>Using SpringBoot @JooqTest</h3>
			<p>On the other <a id="_idIndexMarker1861"/>hand, it's a common <a id="_idIndexMarker1862"/>scenario to run each integration test in a separate transaction that rolls back in the end, and to achieve this while testing jOOQ in Spring Boot, you can use the <strong class="source-inline">@JooqTest</strong> annotation, as shown here:</p>
			<pre class="source-code"><strong class="bold">@JooqTest</strong></pre>
			<pre class="source-code">@ActiveProfiles("test") // profile is optional</pre>
			<pre class="source-code">public class ClassicmodelsIT {</pre>
			<pre class="source-code"> @Autowired</pre>
			<pre class="source-code"> private DSLContext ctx;</pre>
			<pre class="source-code"> // optional, if you need more control of Spring transactions</pre>
			<pre class="source-code"> @Autowired</pre>
			<pre class="source-code"> private TransactionTemplate template;</pre>
			<pre class="source-code"> @Test</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>This time, Spring Boot automatically creates <strong class="source-inline">DSLContext</strong> for the current profile (of course, using explicit profiles is optional, but I added it here, since it is a common practice in Spring Boot applications) and automatically wraps each test in a separate Spring transaction that is rolled back at the end. In this context, if you prefer to use jOOQ transactions <a id="_idIndexMarker1863"/>for certain <a id="_idIndexMarker1864"/>tests, then don't forget to disable Spring transaction by annotating those test methods with <strong class="source-inline">@Transactional(propagation=Propagation.NEVER)</strong>. The same is true for the usage of <strong class="source-inline">TransactionTemplate</strong>. You can practice this example in <em class="italic">JooqTest</em> for MySQL, which contains several tests, including jOOQ optimistic locking via <strong class="source-inline">TransactionTemplate</strong> and via jOOQ transactions.</p>
			<p>By using Spring Boot profiles, you can easily configure a separate database for tests that is (or not) identical to the production database. In <em class="italic">JooqTestDb</em>, you have the MySQL <strong class="source-inline">classicmodels</strong> database for production and the MySQL <strong class="source-inline">classicmodels_test</strong> database for testing (both of them have the same schema and data and are managed by Flyway).</p>
			<p>Moreover, if you prefer an in-memory database that is destroyed at the end of testing, then in <em class="italic">JooqTestInMem</em> for MySQL, you have the on-disk MySQL <strong class="source-inline">classicmodels</strong> database for production and the in-memory H2 <strong class="source-inline">classicmodels_mem_test</strong> database for testing (both of them have the same schema and data and are managed by Flyway). In these two applications, after you inject the <strong class="source-inline">DSLContext</strong> prepared by Spring Boot, you <a id="_idIndexMarker1865"/>have to point <a id="_idIndexMarker1866"/>jOOQ to the test schema – for instance, for the in-memory database, as shown here:</p>
			<pre class="source-code">@JooqTest</pre>
			<pre class="source-code">@ActiveProfiles("test")</pre>
			<pre class="source-code">@TestInstance(Lifecycle.PER_CLASS)</pre>
			<pre class="source-code">public class ClassicmodelsIT {</pre>
			<pre class="source-code"> @Autowired</pre>
			<pre class="source-code"> private DSLContext ctx;</pre>
			<pre class="source-code"> // optional, if you need more control of Spring transactions</pre>
			<pre class="source-code"> @Autowired</pre>
			<pre class="source-code"> private TransactionTemplate template;</pre>
			<pre class="source-code"> @BeforeAll</pre>
			<pre class="source-code"> public void setup() {</pre>
			<pre class="source-code">  ctx.settings()</pre>
			<pre class="source-code">  // .withExecuteLogging(Boolean.FALSE) // optional</pre>
			<pre class="source-code">     .withRenderNameCase(RenderNameCase.UPPER)</pre>
			<pre class="source-code">     .withRenderMapping(new RenderMapping()</pre>
			<pre class="source-code">     .withSchemata(</pre>
			<pre class="source-code">       new MappedSchema().withInput("classicmodels")</pre>
			<pre class="source-code">                         .withOutput("PUBLIC")));</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> @Test</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>You should be <a id="_idIndexMarker1867"/>familiar with this <a id="_idIndexMarker1868"/>technique from <a href="B16833_17.xhtml#_idTextAnchor330"><em class="italic">Chapter 17</em></a>, <em class="italic">Multitenancy in jOOQ</em>.</p>
			<h3>Using Testcontainers</h3>
			<p>Testcontainers (<a href="https://www.testcontainers.org/">https://www.testcontainers.org/</a>) is a Java <a id="_idIndexMarker1869"/>library that <a id="_idIndexMarker1870"/>allows us to perform JUnit tests in <a id="_idIndexMarker1871"/>lightweight Docker containers, created and destroyed automatically for the most common databases. So, in order to use Testcontainers, you have to install Docker.</p>
			<p>Once you've installed Docker and provided the expected dependencies in your Spring Boot application, you can start a container and run some tests. Here, I've done it for MySQL:</p>
			<pre class="source-code">@JooqTest</pre>
			<pre class="source-code">@Testcontainers</pre>
			<pre class="source-code">@ActiveProfiles("test")</pre>
			<pre class="source-code">public class ClassicmodelsIT {</pre>
			<pre class="source-code"> private static DSLContext ctx;</pre>
			<pre class="source-code"> // optional, if you need more control of Spring transactions</pre>
			<pre class="source-code"> @Autowired</pre>
			<pre class="source-code"> private TransactionTemplate template;</pre>
			<pre class="source-code"> @Container</pre>
			<pre class="source-code"> private static final MySQLContainer sqlContainer = </pre>
			<pre class="source-code">   new MySQLContainer&lt;&gt;("mysql:8.0")</pre>
			<pre class="source-code">     .withDatabaseName("classicmodels")</pre>
			<pre class="source-code">     .withStartupTimeoutSeconds(1800) </pre>
			<pre class="source-code">     .withCommand("--authentication-</pre>
			<pre class="source-code">                     policy=mysql_native_password");</pre>
			<pre class="source-code"> @BeforeAll</pre>
			<pre class="source-code"> public static void setup() throws SQLException {</pre>
			<pre class="source-code">  // load into the database the schema and data   </pre>
			<pre class="source-code">  Flyway flyway = Flyway.configure()</pre>
			<pre class="source-code">    .dataSource(sqlContainer.getJdbcUrl(), </pre>
			<pre class="source-code">      sqlContainer.getUsername(), sqlContainer.getPassword())</pre>
			<pre class="source-code">    .baselineOnMigrate(true)     </pre>
			<pre class="source-code">    .load();        </pre>
			<pre class="source-code">  flyway.migrate();</pre>
			<pre class="source-code">  // obtain a connection to MySQL</pre>
			<pre class="source-code">  Connection conn = sqlContainer.createConnection("");</pre>
			<pre class="source-code">  // intialize jOOQ DSLContext</pre>
			<pre class="source-code">  ctx = DSL.using(conn, SQLDialect.MYSQL);</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> // this is optional since is done automatically anyway</pre>
			<pre class="source-code"> @AfterAll</pre>
			<pre class="source-code"> public static void tearDown() {</pre>
			<pre class="source-code">  if (sqlContainer != null) {</pre>
			<pre class="source-code">   if (sqlContainer.isRunning()) {</pre>
			<pre class="source-code">     sqlContainer.stop();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> @Test</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>Note that we've populated the test database via Flyway, but this is not mandatory. You can use any <a id="_idIndexMarker1872"/>other dedicated utility, such as <a id="_idIndexMarker1873"/>Commons DbUtils. For instance, you can do it via <strong class="source-inline">org.testcontainers.ext.ScriptUtils</strong>, like this:</p>
			<pre class="source-code">...</pre>
			<pre class="source-code">var containerDelegate = </pre>
			<pre class="source-code">  new JdbcDatabaseDelegate(sqlContainer, "");</pre>
			<pre class="source-code">ScriptUtils.runInitScript(containerDelegate, </pre>
			<pre class="source-code">  "integration/migration/V1.1__CreateTest.sql");</pre>
			<pre class="source-code">ScriptUtils.runInitScript(containerDelegate, </pre>
			<pre class="source-code">  "integration/migration/afterMigrate.sql");</pre>
			<pre class="source-code">...</pre>
			<p>That's it! Now, you can spin out a throwaway container for testing database interaction. Most probably, this <a id="_idIndexMarker1874"/>is the most preferable approach <a id="_idIndexMarker1875"/>for testing jOOQ applications in production. You can practice this example in <em class="italic">Testcontainers</em> for MySQL.</p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor371"/>Testing R2DBC</h2>
			<p>Finally, if <a id="_idIndexMarker1876"/>you are using <a id="_idIndexMarker1877"/>jOOQ R2DBC, then writing tests is quite straightforward. </p>
			<p>In the bundled code, you can find three examples for MySQL, as follows:</p>
			<ul>
				<li>The <em class="italic">TestR2DBC</em> example: <strong class="source-inline">ConnectionFactory</strong> is created via <strong class="source-inline">ConnectionFactories.get()</strong> and <strong class="source-inline">DSLContext</strong> via <strong class="source-inline">ctx = DSL.using(connectionFactory)</strong>. The tests are executed against a production database.</li>
				<li>The <em class="italic">TestR2DBCDb</em> example: <strong class="source-inline">ConnectionFactory</strong> is automatically created by Spring Boot and <strong class="source-inline">DSLContext</strong> is created as <strong class="source-inline">@Bean</strong>. The tests are executed against a MySQL test database (<strong class="source-inline">classicmodels_test</strong>), similar to the production one (<strong class="source-inline">classicmodels</strong>).</li>
				<li>The <em class="italic">TestR2DBCInMem</em> example: <strong class="source-inline">ConnectionFactory</strong> is automatically created by Spring Boot and <strong class="source-inline">DSLContext</strong> is created as <strong class="source-inline">@Bean</strong>. The tests are executed against an H2 in-memory test database (<strong class="source-inline">classicmodels_mem_test</strong>).</li>
			</ul>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor372"/>Summary</h1>
			<p>As you just saw, jOOQ has solid support for logging and testing, proving yet again that it is a mature technology ready to meet the most demanding expectations of a production environment. With a high rate of productivity and a small learning curve, jOOQ is the first choice that I use and recommend for projects. I strongly encourage you to do the same!</p>
		</div>
	</body></html>