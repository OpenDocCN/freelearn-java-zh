- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Moving into Spring Boot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入 Spring Boot
- en: In the previous chapter, you learned how to set up your development environment
    for developing your REST APIs using Java and your Angular application. We also
    installed SDKMAN! to manage multiple versions of Java, a REST client to test APIs
    without the use of third-party tools, Angular DevTools to debug your Angular application,
    and Git for code versioning and collaboration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用 Java 和你的 Angular 应用程序设置你的开发环境来开发你的 REST API。我们还安装了 SDKMAN! 来管理多个版本的
    Java，一个 REST 客户端来测试 API 而不使用第三方工具，Angular DevTools 来调试你的 Angular 应用程序，以及 Git 用于代码版本控制和协作。
- en: This chapter will now teach you the concepts of Spring Boot. We will deep-dive
    into Spring Boot’s fundamentals and the essential things we need to learn to develop
    our backend application. We will also learn how to create a Spring Boot project
    using Spring Initializr.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你 Spring Boot 的概念。我们将深入探讨 Spring Boot 的基础和我们需要学习的开发后端应用程序的基本知识。我们还将学习如何使用
    Spring Initializr 创建 Spring Boot 项目。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Spring Boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Boot
- en: Using Spring Initializr
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Initializr
- en: Dependency injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Beans and annotations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean 和注解
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is what you need to complete this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章你需要以下内容：
- en: '**For building the backend**: JetBrains’ IntelliJ IDEA and the Java 17 SDK'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于构建后端**：JetBrains 的 IntelliJ IDEA 和 Java 17 SDK'
- en: '**For generating the Java project**: Spring Initializr'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于生成 Java 项目**：Spring Initializr'
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There will be no directories of repositories for chapters 1 to 4 because most
    topics here are only theory and feature some sample code. The actual application
    project will begin in *w*, *Building APIs* *with Spring*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里的大部分主题都是理论，并包含一些示例代码，因此第 1 到 4 章将不会有存储库目录。实际的应用程序项目将从 *w*，*使用 Spring 构建
    API* 开始。
- en: Understanding Spring Boot
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Spring Boot
- en: We have already discussed an overview of Spring in [*Chapter 1*](B18159_01.xhtml#_idTextAnchor015),
    *Spring Boot and Angular – The Big Picture*. In this section, we will have a deeper
    understanding of the essential concepts of Spring Boot in building your backend
    application, but first, let’s recap what Spring Boot is and its significant advantages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第一章*](B18159_01.xhtml#_idTextAnchor015) 中讨论了 Spring 的概述，*Spring Boot
    和 Angular – 大图景*。在本节中，我们将更深入地了解 Spring Boot 的基本概念，以便构建你的后端应用程序，但首先，让我们回顾一下 Spring
    Boot 是什么以及它的显著优势。
- en: '**Spring Boot** is an open source micro-framework from Pivotal. It is an enterprise-level
    framework for developers to create standalone applications on **Java Virtual Machines**
    (**JVMs**). Its primary focus is to shorten your code length to make it easier
    for you to run your application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Boot** 是来自 Pivotal 的开源微框架。它是一个面向企业级开发者的框架，用于在 **Java 虚拟机**（**JVMs**）上创建独立应用程序。它的主要重点是缩短你的代码长度，以便你更容易运行应用程序。'
- en: The framework extends the Spring Framework, which allows a more opinionated
    way to configure your applications. In addition, it comes with built-in autoconfiguration
    capabilities that configure both Spring Framework and third-party packages based
    on your settings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架扩展了 Spring 框架，允许以更有见地的方来配置你的应用程序。此外，它还内置了自动配置功能，可以根据你的设置配置 Spring 框架和第三方包。
- en: 'Here are the significant advantages of Spring Boot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Spring Boot 的显著优势：
- en: '**Auto-configuration**: When configuring your Spring Boot application, it downloads
    all the dependencies needed to run your application.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动配置**：当配置你的 Spring Boot 应用程序时，它会下载运行应用程序所需的所有依赖项。'
- en: '**Opinionated approach**: Spring Boot uses a narrow approach to installing
    dependencies based on your application''s needs. Manual configuration is removed
    as it adds the packages you need for your application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有见地的方法**：Spring Boot 使用一种基于应用程序需求的有见地的方法来安装依赖项。手动配置被移除，因为它添加了应用程序所需的包。'
- en: '**Spring starters**: We can choose a list of starter dependencies to define
    your application’s expected needs during the initialization process. One example
    is Spring Web, which allows us to initialize a Spring-based web application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring starters**：我们可以在初始化过程中选择一系列的启动依赖项来定义应用程序预期的需求。一个例子是 Spring Web，它允许我们初始化一个基于
    Spring 的 Web 应用程序。'
- en: Now, we know what Spring Boot is and its advantages. Let’s now discuss the architecture
    of Sprint Boot.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 Spring Boot 及其优势。接下来，让我们讨论 Spring Boot 的架构。
- en: Spring Boot architecture
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot 架构
- en: 'Spring Boot consists of different layers and classes to process the data and
    logic in your backend. The four layers and their use are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 由不同的层和类组成，用于处理后端中的数据和逻辑。以下是其四个层及其用途：
- en: '**Presentation/display layer**: The presentation layer is responsible for interpreting
    JSON parameters as objects. This layer is the upper layer that is also responsible
    for handling authentication and HTTP requests. After accomplishing JSON translation
    and authentication, we will now move to the business layer.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表示/显示层**：表示层负责将 JSON 参数解释为对象。这一层是上层，也负责处理身份验证和 HTTP 请求。在完成 JSON 转换和身份验证后，我们现在将转向业务层。'
- en: '**Business layer**: The business layer, as the name suggests, handles all the
    business logic in the application. It is composed of service classes that perform
    authorization and additional validation.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**业务层**：正如其名所示，业务层处理应用程序中的所有业务逻辑。它由执行授权和额外验证的服务类组成。'
- en: '**Persistence layer**: The persistence layer is mainly responsible for storage
    logic that converts objects from and to database rows to insert data.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持久层**：持久层主要负责将对象从数据库行转换为存储逻辑，以插入数据。'
- en: '**Database layer**: The database layer performs **Create, Read, Update, and
    Delete** (**CRUD**) operations. The layer can consist of multiple databases.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据库层**：数据库层执行 **创建、读取、更新和删除**（**CRUD**）操作。该层可以由多个数据库组成。'
- en: The Spring Boot architecture depends on the Spring Framework. The framework
    uses all of its features, such as Spring `DAOimpl` classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 架构依赖于 Spring 框架。该框架使用其所有功能，例如 Spring `DAOimpl` 类。
- en: Now, let’s discuss the Spring Boot Flow architecture, where we will see how
    data is processed inside an application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 Spring Boot 流程架构，我们将看到数据如何在应用程序内部处理。
- en: Spring Boot flow architecture
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot 流程架构
- en: The Spring Boot flow architecture will explain how the HTTP requests are processed
    and how layers communicate. The flow is composed of controllers, service layers,
    databases, and models. To have a better understanding, let’s look at the following
    diagram.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 流程架构将解释 HTTP 请求的处理方式和层之间的通信方式。流程由控制器、服务层、数据库和模型组成。为了更好地理解，让我们看一下以下图表。
- en: '![Figure 3.1 – Spring Boot flow architecture](img/B18159_03_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Spring Boot 流程架构](img/B18159_03_01.jpg)'
- en: Figure 3.1 – Spring Boot flow architecture
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Spring Boot 流程架构
- en: In the Spring Boot flow architecture, the first thing that occurs is the client
    sends a request (an HTTPS request) to the controller. The controller maps the
    request and decides what to do with it. Next, it calls the service layer, where
    all business logic is performed, and gets additional dependencies required for
    operations from repository classes. The service layer is also responsible for
    performing logic on the data represented as a model and will be used by JPA to
    be inserted into the database.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 流程架构中，首先发生的是客户端向控制器发送一个请求（一个 HTTPS 请求）。控制器映射请求并决定如何处理它。接下来，它调用服务层，在那里执行所有业务逻辑，并从存储库类中获取操作所需的额外依赖项。服务层还负责对表示为模型的数据执行逻辑，并将由
    JPA 用于插入数据库。
- en: We have learned the flow of the Spring Boot architecture. Now, we will discuss
    **Representational State Transfer** (**REST**) and its concepts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了 Spring Boot 架构的流程。现在，我们将讨论 **表示状态转换**（**REST**）及其概念。
- en: Understanding REST
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 REST
- en: Before we start building our backend application, we must first know the concept
    of REST, as this is the primary architectural approach that we will apply for
    our backend to be consumable with client applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建我们的后端应用程序之前，我们必须首先了解 REST 的概念，因为这是我们为后端应用客户端应用程序可消费而将应用的主要架构方法。
- en: REST is a web service the primary goal of which is to make web services more
    effective. It allows direct access to applications through a **Uniform Resource
    Identifier** (**URI**) and can provide the resource in the XML or JSON format,
    making it more flexible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种旨在使网络服务更有效的网络服务。它允许通过 **统一资源标识符**（**URI**）直接访问应用程序，并提供 XML 或 JSON 格式的资源，使其更加灵活。
- en: 'The URI is where communication happens between two applications. Think of it
    as a bridge where the backend and frontend communicate. The client (frontend)
    requests a resource and returns a response represented by the XML or JSON format.
    Requesting a resource is used with the following HTTP methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: URI是两个应用程序之间通信的地方。将其视为后端和前端通信的桥梁。客户端（前端）请求一个资源，并以XML或JSON格式返回一个响应。请求资源使用以下HTTP方法：
- en: '`GET`: This is used to get and read a resource.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这用于获取和读取资源。'
- en: '`POST`: This creates a new resource.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这会创建一个新的资源。'
- en: '`PUT`: This updates an existing resource.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这会更新现有资源。'
- en: '`DELETE`: This deletes a resource.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这会删除一个资源。'
- en: 'Let’s have a simple real-world example (a blog application) where we use HTTP
    methods to access a resource with the provided endpoints:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的现实世界示例（一个博客应用程序）来举例，其中我们使用HTTP方法通过提供的端点访问资源：
- en: '`GET /user/{id}/blogs`: This gets the list of blogs of a specific user.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /user/{id}/blogs`：这会获取特定用户的博客列表。'
- en: '`POST /user/{id}/blog`: This creates a blog for a specific user.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /user/{id}/blog`：这为特定用户创建一个博客。'
- en: '`PATCH /user/{id}/blog/{blog_id}`: This updates an existing blog for a specific
    user.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH /user/{id}/blog/{blog_id}`：这会更新特定用户的一个现有博客。'
- en: '`DELETE /user/{id}/blog/{blog_id}`: This deletes an existing blog for a specific
    user.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /user/{id}/blog/{blog_id}`：这会删除特定用户的一个现有博客。'
- en: 'In the preceding example, we request a resource using HTTP methods and endpoints.
    The endpoint returns an object in the form of XML or JSON in the response body.
    REST also supports the standard status code that will define whether our request
    is successful or not. The list of commonly used status codes is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用HTTP方法和端点请求资源。端点在响应体中以XML或JSON的形式返回一个对象。REST还支持标准状态码，这将定义我们的请求是否成功。以下是一些常用状态码的列表：
- en: '`200`: Success status for the request'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`：请求成功的状态'
- en: '`201`: Indicates that an object was successfully created'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201`：表示一个对象已成功创建'
- en: '`400`: Indicates a bad request – usually happens when the request body is invalid'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`：表示一个错误的请求——通常发生在请求体无效时'
- en: '`401`: Unauthorized access to the resource'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401`：未经授权访问资源'
- en: '`404`: Indicates that the resource is not found'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404`：表示资源未找到'
- en: '`500`: Indicates an internal server error'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：表示内部服务器错误'
- en: The status codes are a helpful indication of what the client application will
    do after the HTTP call, providing an overview of how we can use REST in client
    and server communication.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是客户端应用程序在HTTP调用后将要执行的有用指示，概述了我们可以如何使用REST在客户端和服务器通信中。
- en: '![Figure 3.2 – Communication between client and server applications](img/B18159_03_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 客户端和服务器应用程序之间的通信](img/B18159_03_02.jpg)'
- en: Figure 3.2 – Communication between client and server applications
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 客户端和服务器应用程序之间的通信
- en: We learned about the concept and architecture of Spring Boot in this section.
    We also now know the ideas of REST and how it works to provide backend solutions.
    In the next section, we will generate our new Spring Boot project using Spring
    Initializr.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Spring Boot的概念和架构。我们还现在知道了REST的理念以及它是如何提供后端解决方案的。在下一节中，我们将使用Spring
    Initializr生成我们的新Spring Boot项目。
- en: Using Spring Initializr
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr
- en: This section will explain what **Spring Initializr** is and how to configure
    and start our project. Spring Initializr is a web application that can generate
    a Spring Boot project on the fly. Spring Initializr will configure the build file
    with the required dependencies to run our project, focusing only on the code in
    the application. Spring Initializr makes it easier to set up our project, with
    the help of the **Spring Boot CLI** on the side, helping us configure our application.
    Spring Initializr generates a more traditional Java structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释**Spring Initializr**是什么以及如何配置和启动我们的项目。Spring Initializr是一个可以即时生成Spring
    Boot项目的Web应用程序。Spring Initializr将配置构建文件，包含运行我们的项目所需的依赖项，仅关注应用程序中的代码。Spring Initializr通过侧边的**Spring
    Boot CLI**帮助我们配置应用程序，使得设置项目更加容易。Spring Initializr生成一个更传统的Java结构。
- en: 'There are several ways to use Spring Initializr:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使用Spring Initializr：
- en: Via a web-based interface
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基于Web的界面
- en: Via Intellij IDEA
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过IntelliJ IDEA
- en: We will discuss these different ways to generate our Spring Boot application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论生成我们的Spring Boot应用程序的不同方法。
- en: Web-based interface
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于Web的界面
- en: 'The first way to use Spring Initializr is using a web-based interface. The
    application can be accessed through [https://start.spring.io](https://start.spring.io).
    You will see the following form once you open the link:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Initializr 的第一种方式是通过基于 Web 的界面。应用程序可以通过 [https://start.spring.io](https://start.spring.io)
    访问。一旦打开链接，您将看到以下表单：
- en: '![Figure 3.3 – Spring Initializr](img/B18159_03_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Spring Initializr](img/B18159_03_03.jpg)'
- en: Figure 3.3 – Spring Initializr
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Spring Initializr
- en: The form will ask you for some basic information about your project. The first
    question is, *what is your choice between Maven and Gradle to build your project?*
    The app will also need information such as what language you will use, the artifact
    name, project name, and package name to be used, and what JDK version will be
    used when building the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将要求您提供一些关于您项目的基本信息。第一个问题是，*您在 Maven 和 Gradle 之间如何选择来构建您的项目？* 应用程序还需要有关您将使用哪种语言、工件名称、项目名称和要使用的包名称以及构建应用程序时将使用的
    JDK 版本的信息。
- en: Now, on the right side of the interface, you will see the **Add Dependencies**
    button. The **Add Dependencies** feature is one of the most important features
    of Spring Initializr, as this will allow us to choose the dependencies depending
    on the needs of our project. For example, we need to have a relational database
    with JPA access; we should add the Spring Data JPA.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在界面的右侧，您将看到 **添加依赖项** 按钮。**添加依赖项** 功能是 Spring Initializr 最重要的功能之一，因为它将允许我们根据项目的需求选择依赖项。例如，如果我们需要一个具有
    JPA 访问的数据库，我们应该添加 Spring Data JPA。
- en: Therefore, we added **Lombok**, **Spring Web**, **Spring Data JPA**, **PostgreSQL
    Driver**, and **Spring Data Reactive Redis** in the following example. We will
    also discuss each dependency as we go through building our example application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在以下示例中添加了 **Lombok**、**Spring Web**、**Spring Data JPA**、**PostgreSQL 驱动程序**
    和 **Spring Data Reactive Redis**。我们将在构建示例应用程序的过程中讨论每个依赖项。
- en: '![Figure 3.4 – Generating Spring Boot with the dependencies](img/B18159_03_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 使用依赖项生成 Spring Boot](img/B18159_03_04.jpg)'
- en: Figure 3.4 – Generating Spring Boot with the dependencies
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 使用依赖项生成 Spring Boot
- en: We can see in the preceding example that we have already added the dependencies
    we need in our project. The last would be generating our application by clicking
    the **Generate** button; this will download a zip file that will contain our application.
    Before generating our project, we can click the **Explore** button to check our
    project structure and verify the configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到我们已经在我们的项目中添加了所需的依赖项。最后一步是通过点击 **生成** 按钮来生成我们的应用程序；这将下载一个包含我们的应用程序的
    zip 文件。在生成项目之前，我们可以点击 **探索** 按钮来检查我们的项目结构和验证配置。
- en: After successfully downloading the generated Spring Boot application, we will
    extract the file, and we can now open the Spring Boot project with the IDE of
    our choice. Finally, we are ready to write our code, but first, let’s check out
    the project structure generated by Spring Initializr.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 成功下载生成的 Spring Boot 应用程序后，我们将解压文件，现在我们可以使用我们选择的 IDE 打开 Spring Boot 项目。最后，我们准备好编写代码了，但首先，让我们看看
    Spring Initializr 生成的项目结构。
- en: '![Figure 3.5 – A generated Spring Boot application](img/B18159_03_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 生成的 Spring Boot 应用程序](img/B18159_03_05.jpg)'
- en: Figure 3.5 – A generated Spring Boot application
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 生成的 Spring Boot 应用程序
- en: 'We can see from the generated project that there is not much application code
    included. However, the project consists of the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的项目中我们可以看到，其中包含的应用程序代码并不多。然而，项目包括以下内容：
- en: '`DemoApplication.java`: A class with the `main()` function for the application
    bootstrap'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DemoApplication.java`：一个包含应用程序启动 `main()` 函数的类'
- en: '`DemoApplicationTests.java`: An empty JUnit test class for unit testing'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DemoApplicationTests.java`：一个空的 JUnit 测试类，用于单元测试'
- en: '`Pom.xml`: A Maven build specification that contains the dependencies needed
    for the application'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pom.xml`：一个包含应用程序所需依赖项的 Maven 构建规范'
- en: '`Application.properties`: A properties file that is used to add configuration
    properties'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application.properties`：一个用于添加配置属性的属性文件'
- en: We can see on the generated project that empty directories are included, such
    as the `static` folder; this is significant, as this is used for placing static
    content such as CSS and JavaScript files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在生成的项目中看到包括空目录，例如 `static` 文件夹；这很重要，因为这个文件夹用于放置 CSS 和 JavaScript 等静态内容文件。
- en: We have successfully generated our Spring Boot project using the web interface.
    Now, we will use Spring Initializr directly in IntelliJ IDEA.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用网络界面生成了我们的 Spring Boot 项目。现在，我们将直接在 IntelliJ IDEA 中使用 Spring Initializr。
- en: Via IntelliJ IDEA
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 IntelliJ IDEA
- en: 'Another way of generating our Spring Boot project is by using Spring Initializr
    directly in IntelliJ IDEA; note that this is only available in the Ultimate edition
    of IntelliJ. If you are using the Community edition, you can install Spring Assistant
    at the following link: [https://plugins.jetbrains.com/plugin/10229-spring-assistant](https://plugins.jetbrains.com/plugin/10229-spring-assistant).
    This will add a Spring Assistant option to generate your Spring Boot projects.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种生成我们的 Spring Boot 项目的办法是直接在 IntelliJ IDEA 中使用 Spring Initializr；请注意，这仅在 IntelliJ
    的 Ultimate 版本中可用。如果你使用的是 Community 版本，你可以在以下链接中安装 Spring Assistant：[https://plugins.jetbrains.com/plugin/10229-spring-assistant](https://plugins.jetbrains.com/plugin/10229-spring-assistant)。这将添加一个
    Spring Assistant 选项来生成你的 Spring Boot 项目。
- en: 'Execute the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Select **New Project** upon opening IntelliJ IDEA to start generating the project,
    which will open a new modal.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开 IntelliJ IDEA 并开始生成项目时选择 **新建项目**，这将打开一个新模态窗口。
- en: Select **Spring Initializr**, which will open a form with the same web interface
    as Spring Initializr.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Spring Initializr**，这将打开一个与 Spring Initializr 相同的网络界面表单。
- en: 'It will ask for details such as the project name, the language that will be
    used, the artifact name, and the SDK version that will be used to build the project:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将要求提供诸如项目名称、将要使用的语言、工件名称以及用于构建项目的 SDK 版本等详细信息：
- en: "![Figure 3.6 – The form for \uFEFFusing Spring Initializr with IntelliJ IDEA](img/B18159_03_06.jpg)"
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 使用 IntelliJ IDEA 与 Spring Initializr 的表单](img/B18159_03_06.jpg)'
- en: Figure 3.6 – The form for using Spring Initializr with IntelliJ IDEA
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 使用 IntelliJ IDEA 与 Spring Initializr 的表单
- en: We can see in the preceding figure that we have populated all the required details
    for our project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到，我们已经为我们的项目填写了所有必要的详细信息。
- en: Clicking the **Next** button will redirect us to the **Dependencies** selection.
    We will choose the dependencies we need for the Spring Boot development, which
    are the same as what we entered in the Sprint Initializr interface.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮将带我们转到 **依赖项** 选择页面。我们将选择用于 Spring Boot 开发的依赖项，这些依赖项与我们在 Sprint
    Initializr 界面中输入的相同。
- en: After successfully checking the dependencies, click **Finish**, and our Spring
    Boot application is configured. Finally, we are ready to write our code.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功检查依赖项后，点击 **完成**，我们的 Spring Boot 应用程序配置完成。最后，我们准备好编写代码。
- en: We have successfully generated our Spring Boot application through the Spring
    Initializr web interface and built-in IntelliJ IDEA. In the next section, we will
    learn one of the most important and commonly used concepts in Spring Boot – dependency
    injection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过 Spring Initializr 网络界面和内置的 IntelliJ IDEA 成功生成了 Spring Boot 应用程序。在下一节中，我们将学习
    Spring Boot 中最重要且最常用的概念之一——依赖注入。
- en: Dependency injection
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: We have successfully generated our own Spring Boot project, and now, we will
    start learning the concepts of Spring, and one of the most important concepts
    we need to understand is **dependency injection**. As we develop our backend using
    Spring Boot, we will mainly use dependency injection throughout our development,
    as this makes our Java program modular and enables easier switching of implementations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功生成了自己的 Spring Boot 项目，现在，我们将开始学习 Spring 的概念，其中最重要的概念之一是我们需要理解的 **依赖注入**。随着我们使用
    Spring Boot 开发后端，我们将在整个开发过程中主要使用依赖注入，因为这使我们的 Java 程序模块化，并使实现之间的切换更加容易。
- en: Dependency injection is an essential feature of **object-oriented programming
    languages**, but first, let’s discuss the concept of inversion of control, which
    is what dependency injection is trying to achieve.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是面向对象编程语言的一个基本特性，但首先，让我们讨论一下控制反转的概念，这正是依赖注入试图实现的目标。
- en: Inversion of control
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制反转
- en: '**Inversion of Control** (**IoC**) is the design pattern used for object-oriented
    programming languages. IoC is the concept of inverting the flow of your program,
    and it is used for decoupling the components in your application, making your
    piece of code reusable and modular. Hence, the IoC design pattern will provide
    us with a way to inject a custom class into other classes of our application.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）是面向对象编程语言中使用的模式。IoC 是反转程序流程的概念，它用于解耦应用程序中的组件，使代码可重用且模块化。因此，IoC
    设计模式将为我们提供一种将自定义类注入到应用程序中其他类的方法。'
- en: 'The injected class will be instantiated in different parts of our application.
    Instead of letting our class decide its implementations or making its code fixes,
    we allow the injection of dependencies to change the class’s flow, performance,
    and code depending on the case. Thus, IoC mainly offers flexibility and modularity,
    but it also provides several other advantages in designing your applications:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Having control of an object’s life cycle, we can define some objects as a singleton,
    and some objects can have their instance.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the application more maintainable as your code reduces because of reusable
    components.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components is more manageable, as we can isolate components and mock
    their dependencies, not covering other code that will not be included in unit
    testing.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned about the IoC pattern and how it is advantageous for developing
    our application. Now, we will use dependency injection, which allows us to achieve
    this pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The basics of dependency injection
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed how IoC works, and it is achieved by allowing an implementation
    to be decided by giving dependencies to the object. So, this idea is mainly **dependency
    injection**. We allow objects or classes to accept other dependencies that can
    provide implementations of different classes without writing them again, making
    our code flexible and reusable. Dependency injection can be achieved in different
    ways, and here are the following implementations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based dependency injection
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Constructor-based dependency injection** can be achieved by creating an object
    class with a constructor, with arguments of a specific type representing the dependency
    we can set.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, the `Student` class has a constructor, `public Student()
    {}`, which accepts a parameter of type `Grades`. The constructor allows us to
    inject a `Grades` object in `Student`, allowing all implementations of the `Grades`
    object to be accessible in the `Student` object. Now, we have accessed the `getGrades()`
    method in our `Student`. To use the `Student` object, we will execute the following
    example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see in the preceding example that we have instantiated a new student
    in our main class by getting the bean of our `Beans.xml` file. The `Beans.xml`
    file is our main configuration file for our construction-based injection, which
    is where we will define our beans together with their dependencies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the following example of what `Beans.xml` looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we have defined the `Student` and `Grades` object
    as beans. The only difference is that the `Student` object has a `constructor-arg`
    that references grades; this indicates that we are injecting the `Grades` object
    into our `Student` object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We have already achieved constructor-based dependency by using the `Beans.xml`
    configuration. We can also use annotations directly in our code to configure our
    beans and their dependencies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example of how to configure beans and dependencies
    with annotations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用注解配置bean和依赖关系的以下示例：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see in the preceding example that instead of using XML, we have used
    annotations to identify our beans and configuration. For example, the `@Configuration`
    annotation indicates that the `AppConfig` class is the source of the bean definitions,
    and the `@Bean` annotation defines the bean in our application. We will discuss
    annotations and beans intensely as we go throughout this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到我们没有使用XML，而是使用了注解来识别我们的bean和配置。例如，`@Configuration`注解表示`AppConfig`类是bean定义的来源，而`@Bean`注解定义了我们的应用程序中的bean。随着我们继续本章，我们将深入讨论注解和bean。
- en: We have successfully learned how to implement constructor-based dependency injection
    by using `Bean.xml` and annotations. Now, let’s move on to the implementation
    of setter-based dependency injection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何通过使用`Bean.xml`和注解来实现基于构造函数的依赖注入。现在，让我们继续到基于setter的依赖注入的实现。
- en: Setter-based dependency injection
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: The injection of dependencies can be achieved when the container calls the setter
    methods of our class. So, instead of creating a constructor for the class, we
    will create a function that will set the object’s dependency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器调用我们的类的setter方法时，可以实现依赖项的注入。因此，我们不会为类创建构造函数，而是创建一个设置对象依赖项的功能。
- en: 'Let’s look at a basic code example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本的代码示例：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we can see that we have created a setter method named
    `setGrades()`, which accepts a `Grades` object, and its primary function is to
    set a value for the `grades` dependency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到我们创建了一个名为`setGrades()`的setter方法，它接受一个`Grades`对象，其主要功能是为`grades`依赖项设置一个值。
- en: Instead of using the constructor with arguments, we use setters to inject our
    dependencies into our object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用带参数的构造函数，而是使用setter来将我们的依赖项注入到我们的对象中。
- en: 'To use the `Student` object, let’s see the following example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Student`对象，让我们看看以下示例：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see in the preceding example that it’s the same as how we used setter-based
    objects and constructor-based objects. The difference here is how we configure
    our beans in `Bean.xml`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到它与使用setter-based对象和constructor-based对象的方式相同。这里的区别在于我们在`Bean.xml`中如何配置我们的bean。
- en: 'Let’s see the `Beans.xml` example for setter-based dependency injection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看setter-based依赖注入的`Beans.xml`示例：
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We configured the beans in our `Beans.xml`, `Student`, and the `Grades` object
    in the preceding example. The only difference here is when we declare dependencies.
    We use the `property` tag instead of `constructor-arg` to define our dependencies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`Beans.xml`、`Student`和`Grades`对象中配置了bean。这里唯一的区别在于我们声明依赖项的方式。我们使用`property`标签而不是`constructor-arg`来定义我们的依赖项。
- en: We have successfully created our object with setter-based dependency injection,
    and now, we will discuss field-based dependency injection.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地使用setter-based依赖注入创建了我们的对象，现在，我们将讨论基于字段的依赖注入。
- en: Field-based dependency injection
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于字段的依赖注入
- en: As the name suggests, `@Autowired` annotation for injection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`@Autowired`注解用于注入。
- en: 'Let’s see the following example of injecting dependencies into a field:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下将依赖项注入字段的示例：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example code, we can see that we didn’t create a constructor
    or a setter method to inject our dependency. Instead, we only used the `@Autowired`
    annotation to inject the `Grades` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们没有创建构造函数或setter方法来注入我们的依赖项。相反，我们只使用了`@Autowired`注解来注入`Grades`对象。
- en: The field-based injection may be clean at first glance, having only annotations
    in our code and fewer methods, but many things happen behind our `@Autowired`
    dependency. For example, it uses reflection to inject dependencies that are costlier
    than a constructor and setter-based injection; it also violates the **single responsibility
    principle**. We can add more dependencies directly in the fields without warning.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，基于字段的注入可能很简洁，我们的代码中只有注解，方法更少，但我们的`@Autowired`依赖项背后发生了许多事情。例如，它使用反射来注入比构造函数和基于setter的注入成本更高的依赖项；它还违反了**单一职责原则**。我们可以在字段中直接添加更多依赖项而无需警告。
- en: We have learned the basics of dependency injection and the different ways to
    implement it in our Java application. Now, we will discuss the concept and importance
    of annotations and beans in Spring.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了依赖注入的基础知识以及在我们Java应用程序中实现它的不同方式。现在，我们将讨论Spring中注解和bean的概念及其重要性。
- en: Annotation and beans
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解与 bean
- en: '**Annotation and beans** are essential parts of developing your Spring applications.
    They are considered the building blocks of Spring and make our code less boilerplate
    and maintainable.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注解与 bean** 是开发 Spring 应用程序的基本组成部分。它们被认为是 Spring 的构建块，使我们的代码更简洁、易于维护。'
- en: '**Spring annotations** are used to define the different types of beans. They
    are simply a form of metadata that marks our code to provide information. Conversely,
    **beans** are objects that are instantiated and created and can be injected with
    other beans. We will discuss more as we go through this section.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring 注解**用于定义不同类型的 bean。它们只是标记我们代码的一种元数据形式，提供信息。相反，**bean** 是实例化和创建的对象，可以被其他
    bean 注入。我们将在这个部分继续讨论。'
- en: Types of annotations
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解类型
- en: Annotations in Spring are categorized into different types depending on their
    functionality. The following are annotations grouped into their respective categories.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 中的注解根据其功能被分为不同的类型。以下是根据其各自类别分组的注解。
- en: Core annotations
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心注解
- en: '`org.springframework.beans.factory.annotation` and `org.springframework.context.annotation`
    packages. The following is a list of core annotations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.beans.factory.annotation` 和 `org.springframework.context.annotation`
    包。以下是一个核心注解列表：'
- en: '`@Required`: This is applied in the setter methods of a bean and implies that
    the bean must be injected with the dependency at configuration. Otherwise, it
    will throw `BeanInitializationException`. Let’s look at the following example
    of how to use the `@``Required` annotation:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Required`：这个注解应用于 bean 的设置方法，意味着在配置时必须注入依赖。否则，将抛出 `BeanInitializationException`。让我们看看如何使用
    `@Required` 注解的以下示例：'
- en: '[PRE8]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we can see that the `setBrand()` method was annotated
    with `@Required`; this indicates that the brand must be populated on initialization.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到 `setBrand()` 方法被注解为 `@Required`；这表示在初始化时必须填充品牌。
- en: '`@Autowired`: We have encountered the `@Autowired` annotation several times
    in DI, and this is mainly used to inject dependencies without the use of constructors
    and setter methods. Let’s look at the following example of how to use the `@``Autowired`
    annotation:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired`：我们在依赖注入（DI）中多次遇到了 `@Autowired` 注解，这主要用于在不使用构造函数和设置方法的情况下注入依赖。让我们看看如何使用
    `@Autowired` 注解的以下示例：'
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see in the preceding example that `@Autowired` is applied directly in
    the field. This is because the annotations use reflection to inject dependencies,
    with more processes involved than constructors and setter methods.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到 `@Autowired` 直接应用于字段。这是因为注解使用反射来注入依赖，涉及的过程比构造函数和设置方法更多。
- en: '`@ComponentScan`: The annotation is a class-level annotation to indicate the
    packages we want to be scanned for beans. `@ComponentScan` can accept arguments
    about what specific packages are to be scanned, and not providing any will allow
    the current packages and all sub-packages. Let’s look at the following example
    of how to use `@ComponentScan`:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`：这个注解是一个类级别的注解，用来指示我们想要扫描的包。`@ComponentScan` 可以接受关于要扫描的特定包的参数，如果不提供任何参数，将允许当前包及其所有子包。让我们看看如何使用
    `@ComponentScan` 的以下示例：'
- en: '[PRE26]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see in the preceding example that the `@ComponentScan` app is applied
    to the Spring `App` class, and it is usually implemented together with the `@Configuration`
    annotation. Let’s say that `SpringApp` is found under the `com.example.spring.app`
    package; this will scan the package and its sub-packages if there are existing
    beans.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到 `@ComponentScan` 注解被应用于 Spring 的 `App` 类，通常与 `@Configuration`
    注解一起实现。假设 `SpringApp` 位于 `com.example.spring.app` 包下；这将扫描该包及其子包，如果存在现有的 bean。
- en: '`@ComponentScan`: The annotation is also a class-level annotation to indicate
    that a class is the source of bean definitions that the Spring container will
    process at runtime. Let’s look at the following example of how to use the `@``ComponentScan`
    annotation:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`：这个注解也是一个类级别的注解，用来指示一个类是 Spring 容器在运行时将处理的 bean 定义源。让我们看看如何使用
    `@ComponentScan` 注解的以下示例：'
- en: '[PRE43]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can see in the preceding example that the `@Configuration` annotation is
    applied to the `SpringApp` class, which indicates that `SpringApp` will be the
    source of beans.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到 `@Configuration` 注解被应用于 `SpringApp` 类，这表示 `SpringApp` 将是 bean
    的来源。
- en: '`@Bean`: The annotation is a method-level annotation, and it is used to tell
    a method to produce a bean. Let’s look at the following example of how to use
    the `@``Bean` annotation:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding example, the `@Bean` annotation is applied to the `beanExample`
    method. Once `JavaConfig` encounters the method, it will be executed and register
    the return value as a bean in `BeanFactory`, and the name will be the same as
    the method name when none is specified.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Bean` annotation can also be configured in Spring XML, and the equivalent
    configuration is the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Stereotype annotations
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stereotype annotations** are mainly used to create Spring beans on the fly
    in an application context. The following is a list of stereotype annotations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component`: This is the primary stereotype annotation. As with the `@Bean`
    annotation, the `@Component` annotation is used to define a bean or a Spring component.
    The difference between the two is that `@Component` is applied at the class level
    while `@Bean` is applied at the method level.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other difference is that the `@Component` class cannot also be used to
    create a bean if the class is outside the Spring container, whereas we can create
    a bean using `@Bean` even if the class is found outside the Spring container.
    Let’s look at the following example of how to use the `@``Component` annotation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can see in the preceding example that `@Component` is applied to the `Car`
    class. This means that this will create a `car` bean at runtime. We also need
    to remember that `@Component` cannot be used with the `@``Configuration` annotation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`@Service`: This annotation, used for the service layer, indicates that a class
    is used to execute business logic, perform calculations, and call external APIs.
    `@Service` is a kind of `@``Component` annotation.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Repository`: This annotation is used for classes that directly access a database.
    This is an indication of a class that executes the role of a data access object.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Controller`: The annotations used for Spring controller classes. It is also
    a type of `@Component` annotation, used for Spring MVC and the methods annotated
    with `@RequestMapping`, which is used for REST.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot annotations
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These annotations are created explicitly for Spring Boot, and this is mostly
    the combination of several annotations. The following is a list of Spring Boot
    annotations:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: This annotation is used to auto-configure the bean
    present in the classpath and then to configure it to run the methods. The annotation
    is now rarely used, as `@SpringBootApplication` has already been released in Spring
    1.2.0.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SpringBootApplication`: The annotation is the combination of `@EnableAutoConfiguration`,
    `@ComponentsScan`, and `@Configuration`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST annotations
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are specialized annotations used to create endpoints, specify the HTTP
    requests, and serialize return objects. The following list shows the different
    REST annotations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This is used to create endpoints and map web requests. The
    annotations can be used in a class or a method.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping`: This maps the HTTP `GET` requests and is used for fetching data,
    and it is the equivalent of `@RequestMapping(method =` `RequestMethod.GET)`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This maps the HTTP `POST` requests and is used for creating
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.POST)`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This maps the HTTP `PUT` requests and is used for updating
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.PUT)`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This maps the HTTP `PUT` requests and is used for deleting
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.DELETE)`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This maps the HTTP `PATCH` requests and is used for partial
    updates on data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.PATCH)`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`: This is used to bind HTTP requests with an object in a method
    parameter. The Spring framework binds the HTTP request body of the parameter with
    the `@``RequestBody` annotation.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseBody`: This attaches the method''s return value to the response body.
    The annotation indicates that the return object should be serialized into a JSON
    or XML format.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`: This is used to get the values from the URI. It is allowed
    to define multiple `@PathVariable` instances in a method.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestParam`: This is used to get the query parameters from the URL.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestHeader`: This is used to extract the details about the incoming HTTP
    request headers. We use this annotation in the parameters of a method.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RestController`: This is a combination of the `@Controller` and `@ResponseBody`
    annotations. The importance of this annotation is that it prevents annotating
    each method with `@``ResponseBody`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned about the different types of annotations and their uses in Spring.
    Now, we will discuss and understand more in the next section the actual definition
    and importance of beans in Spring applications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Understanding beans
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already encountered beans several times in the previous section. We
    have learned how to create and initialize beans using `@Bean` and `@Component`
    annotations, but the main question is, *what is the primary use of a bean in*
    *Spring applications?*
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: A **bean** is the central concept of the Spring Framework we need to understand.
    It is essential to learn its purpose and functionality to use the Spring Framework
    effectively.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: To define a bean in Spring, it is an object that forms the backbone of your
    application managed by the Spring IoC container. These are the objects that we
    mainly use for data and to inject dependencies to create multiple implementations.
    For better understanding, let’s have some examples of beans.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a domain class named `Car`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can see in the example that the car needs a `Brand` dependency. The `Brand`
    class has the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The typical approach is to create a new instance of the `Brand` class and pass
    it as a parameter upon creating a new `Car` class. This approach will work fine,
    but this can cause issues when we have many classes. So, a better process is that
    instead of constructing dependencies by themselves, the objects can retrieve their
    dependencies from an IoC container in the form of beans.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we only need to do is configure the beans and dependencies using annotations
    or XML to identify the dependencies required for a specific object. Let’s convert
    the previous example into a bean:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will annotate the `Car` class with the `@Component` annotation to identify
    the class as `Bean`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The next thing we need to do is create a configuration class. In the preceding
    example, we have annotated the class with `@Configuration` and `@ComponentScan`
    to identify that this is our configuration class; this will produce a `Bean` of
    type `Brand`, having configured the `Brand` class as a `Bean`. We will only need
    to pull the beans in the application context, and the dependencies are already
    injected:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding example code, we can see that we have extracted the `Car` bean
    in the application context. Therefore, we can automatically use the getter methods
    of the `Brand` dependency; this means that the IoC container manages the beans
    and their dependencies.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned. You have learned the fundamentals of Spring
    Boot, its architecture, and the basics of REST. You have also learned how to use
    Spring Initializr to create your own Spring Boot project.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection allows objects or classes to accept other dependencies
    that can implement different classes without writing them again. Annotations define
    the different types of beans; they are simply a form of metadata that marks our
    code to provide information.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: And finally, beans are objects that form the backbone of an application managed
    by the Spring IoC container.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning how to set up a database and use Spring
    Data JPA.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
