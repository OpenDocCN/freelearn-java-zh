- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving into Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to set up your development environment
    for developing your REST APIs using Java and your Angular application. We also
    installed SDKMAN! to manage multiple versions of Java, a REST client to test APIs
    without the use of third-party tools, Angular DevTools to debug your Angular application,
    and Git for code versioning and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will now teach you the concepts of Spring Boot. We will deep-dive
    into Spring Boot’s fundamentals and the essential things we need to learn to develop
    our backend application. We will also learn how to create a Spring Boot project
    using Spring Initializr.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Initializr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beans and annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is what you need to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For building the backend**: JetBrains’ IntelliJ IDEA and the Java 17 SDK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For generating the Java project**: Spring Initializr'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There will be no directories of repositories for chapters 1 to 4 because most
    topics here are only theory and feature some sample code. The actual application
    project will begin in *w*, *Building APIs* *with Spring*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed an overview of Spring in [*Chapter 1*](B18159_01.xhtml#_idTextAnchor015),
    *Spring Boot and Angular – The Big Picture*. In this section, we will have a deeper
    understanding of the essential concepts of Spring Boot in building your backend
    application, but first, let’s recap what Spring Boot is and its significant advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Boot** is an open source micro-framework from Pivotal. It is an enterprise-level
    framework for developers to create standalone applications on **Java Virtual Machines**
    (**JVMs**). Its primary focus is to shorten your code length to make it easier
    for you to run your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The framework extends the Spring Framework, which allows a more opinionated
    way to configure your applications. In addition, it comes with built-in autoconfiguration
    capabilities that configure both Spring Framework and third-party packages based
    on your settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the significant advantages of Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto-configuration**: When configuring your Spring Boot application, it downloads
    all the dependencies needed to run your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opinionated approach**: Spring Boot uses a narrow approach to installing
    dependencies based on your application''s needs. Manual configuration is removed
    as it adds the packages you need for your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring starters**: We can choose a list of starter dependencies to define
    your application’s expected needs during the initialization process. One example
    is Spring Web, which allows us to initialize a Spring-based web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we know what Spring Boot is and its advantages. Let’s now discuss the architecture
    of Sprint Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot consists of different layers and classes to process the data and
    logic in your backend. The four layers and their use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation/display layer**: The presentation layer is responsible for interpreting
    JSON parameters as objects. This layer is the upper layer that is also responsible
    for handling authentication and HTTP requests. After accomplishing JSON translation
    and authentication, we will now move to the business layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Business layer**: The business layer, as the name suggests, handles all the
    business logic in the application. It is composed of service classes that perform
    authorization and additional validation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Persistence layer**: The persistence layer is mainly responsible for storage
    logic that converts objects from and to database rows to insert data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Database layer**: The database layer performs **Create, Read, Update, and
    Delete** (**CRUD**) operations. The layer can consist of multiple databases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Spring Boot architecture depends on the Spring Framework. The framework
    uses all of its features, such as Spring `DAOimpl` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the Spring Boot Flow architecture, where we will see how
    data is processed inside an application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot flow architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Spring Boot flow architecture will explain how the HTTP requests are processed
    and how layers communicate. The flow is composed of controllers, service layers,
    databases, and models. To have a better understanding, let’s look at the following
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Spring Boot flow architecture](img/B18159_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Spring Boot flow architecture
  prefs: []
  type: TYPE_NORMAL
- en: In the Spring Boot flow architecture, the first thing that occurs is the client
    sends a request (an HTTPS request) to the controller. The controller maps the
    request and decides what to do with it. Next, it calls the service layer, where
    all business logic is performed, and gets additional dependencies required for
    operations from repository classes. The service layer is also responsible for
    performing logic on the data represented as a model and will be used by JPA to
    be inserted into the database.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the flow of the Spring Boot architecture. Now, we will discuss
    **Representational State Transfer** (**REST**) and its concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start building our backend application, we must first know the concept
    of REST, as this is the primary architectural approach that we will apply for
    our backend to be consumable with client applications.
  prefs: []
  type: TYPE_NORMAL
- en: REST is a web service the primary goal of which is to make web services more
    effective. It allows direct access to applications through a **Uniform Resource
    Identifier** (**URI**) and can provide the resource in the XML or JSON format,
    making it more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URI is where communication happens between two applications. Think of it
    as a bridge where the backend and frontend communicate. The client (frontend)
    requests a resource and returns a response represented by the XML or JSON format.
    Requesting a resource is used with the following HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This is used to get and read a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This creates a new resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This updates an existing resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This deletes a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have a simple real-world example (a blog application) where we use HTTP
    methods to access a resource with the provided endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /user/{id}/blogs`: This gets the list of blogs of a specific user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /user/{id}/blog`: This creates a blog for a specific user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH /user/{id}/blog/{blog_id}`: This updates an existing blog for a specific
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /user/{id}/blog/{blog_id}`: This deletes an existing blog for a specific
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding example, we request a resource using HTTP methods and endpoints.
    The endpoint returns an object in the form of XML or JSON in the response body.
    REST also supports the standard status code that will define whether our request
    is successful or not. The list of commonly used status codes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200`: Success status for the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201`: Indicates that an object was successfully created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400`: Indicates a bad request – usually happens when the request body is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401`: Unauthorized access to the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404`: Indicates that the resource is not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: Indicates an internal server error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status codes are a helpful indication of what the client application will
    do after the HTTP call, providing an overview of how we can use REST in client
    and server communication.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Communication between client and server applications](img/B18159_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Communication between client and server applications
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the concept and architecture of Spring Boot in this section.
    We also now know the ideas of REST and how it works to provide backend solutions.
    In the next section, we will generate our new Spring Boot project using Spring
    Initializr.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will explain what **Spring Initializr** is and how to configure
    and start our project. Spring Initializr is a web application that can generate
    a Spring Boot project on the fly. Spring Initializr will configure the build file
    with the required dependencies to run our project, focusing only on the code in
    the application. Spring Initializr makes it easier to set up our project, with
    the help of the **Spring Boot CLI** on the side, helping us configure our application.
    Spring Initializr generates a more traditional Java structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to use Spring Initializr:'
  prefs: []
  type: TYPE_NORMAL
- en: Via a web-based interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via Intellij IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss these different ways to generate our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Web-based interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way to use Spring Initializr is using a web-based interface. The
    application can be accessed through [https://start.spring.io](https://start.spring.io).
    You will see the following form once you open the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Spring Initializr](img/B18159_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Spring Initializr
  prefs: []
  type: TYPE_NORMAL
- en: The form will ask you for some basic information about your project. The first
    question is, *what is your choice between Maven and Gradle to build your project?*
    The app will also need information such as what language you will use, the artifact
    name, project name, and package name to be used, and what JDK version will be
    used when building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the right side of the interface, you will see the **Add Dependencies**
    button. The **Add Dependencies** feature is one of the most important features
    of Spring Initializr, as this will allow us to choose the dependencies depending
    on the needs of our project. For example, we need to have a relational database
    with JPA access; we should add the Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we added **Lombok**, **Spring Web**, **Spring Data JPA**, **PostgreSQL
    Driver**, and **Spring Data Reactive Redis** in the following example. We will
    also discuss each dependency as we go through building our example application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Generating Spring Boot with the dependencies](img/B18159_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Generating Spring Boot with the dependencies
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding example that we have already added the dependencies
    we need in our project. The last would be generating our application by clicking
    the **Generate** button; this will download a zip file that will contain our application.
    Before generating our project, we can click the **Explore** button to check our
    project structure and verify the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully downloading the generated Spring Boot application, we will
    extract the file, and we can now open the Spring Boot project with the IDE of
    our choice. Finally, we are ready to write our code, but first, let’s check out
    the project structure generated by Spring Initializr.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A generated Spring Boot application](img/B18159_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A generated Spring Boot application
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see from the generated project that there is not much application code
    included. However, the project consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DemoApplication.java`: A class with the `main()` function for the application
    bootstrap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DemoApplicationTests.java`: An empty JUnit test class for unit testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pom.xml`: A Maven build specification that contains the dependencies needed
    for the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.properties`: A properties file that is used to add configuration
    properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see on the generated project that empty directories are included, such
    as the `static` folder; this is significant, as this is used for placing static
    content such as CSS and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully generated our Spring Boot project using the web interface.
    Now, we will use Spring Initializr directly in IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: Via IntelliJ IDEA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of generating our Spring Boot project is by using Spring Initializr
    directly in IntelliJ IDEA; note that this is only available in the Ultimate edition
    of IntelliJ. If you are using the Community edition, you can install Spring Assistant
    at the following link: [https://plugins.jetbrains.com/plugin/10229-spring-assistant](https://plugins.jetbrains.com/plugin/10229-spring-assistant).
    This will add a Spring Assistant option to generate your Spring Boot projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **New Project** upon opening IntelliJ IDEA to start generating the project,
    which will open a new modal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Spring Initializr**, which will open a form with the same web interface
    as Spring Initializr.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will ask for details such as the project name, the language that will be
    used, the artifact name, and the SDK version that will be used to build the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.6 – The form for \uFEFFusing Spring Initializr with IntelliJ IDEA](img/B18159_03_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The form for using Spring Initializr with IntelliJ IDEA
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding figure that we have populated all the required details
    for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Next** button will redirect us to the **Dependencies** selection.
    We will choose the dependencies we need for the Spring Boot development, which
    are the same as what we entered in the Sprint Initializr interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successfully checking the dependencies, click **Finish**, and our Spring
    Boot application is configured. Finally, we are ready to write our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have successfully generated our Spring Boot application through the Spring
    Initializr web interface and built-in IntelliJ IDEA. In the next section, we will
    learn one of the most important and commonly used concepts in Spring Boot – dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully generated our own Spring Boot project, and now, we will
    start learning the concepts of Spring, and one of the most important concepts
    we need to understand is **dependency injection**. As we develop our backend using
    Spring Boot, we will mainly use dependency injection throughout our development,
    as this makes our Java program modular and enables easier switching of implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is an essential feature of **object-oriented programming
    languages**, but first, let’s discuss the concept of inversion of control, which
    is what dependency injection is trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Inversion of Control** (**IoC**) is the design pattern used for object-oriented
    programming languages. IoC is the concept of inverting the flow of your program,
    and it is used for decoupling the components in your application, making your
    piece of code reusable and modular. Hence, the IoC design pattern will provide
    us with a way to inject a custom class into other classes of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The injected class will be instantiated in different parts of our application.
    Instead of letting our class decide its implementations or making its code fixes,
    we allow the injection of dependencies to change the class’s flow, performance,
    and code depending on the case. Thus, IoC mainly offers flexibility and modularity,
    but it also provides several other advantages in designing your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Having control of an object’s life cycle, we can define some objects as a singleton,
    and some objects can have their instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the application more maintainable as your code reduces because of reusable
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components is more manageable, as we can isolate components and mock
    their dependencies, not covering other code that will not be included in unit
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned about the IoC pattern and how it is advantageous for developing
    our application. Now, we will use dependency injection, which allows us to achieve
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already discussed how IoC works, and it is achieved by allowing an implementation
    to be decided by giving dependencies to the object. So, this idea is mainly **dependency
    injection**. We allow objects or classes to accept other dependencies that can
    provide implementations of different classes without writing them again, making
    our code flexible and reusable. Dependency injection can be achieved in different
    ways, and here are the following implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Constructor-based dependency injection** can be achieved by creating an object
    class with a constructor, with arguments of a specific type representing the dependency
    we can set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `Student` class has a constructor, `public Student()
    {}`, which accepts a parameter of type `Grades`. The constructor allows us to
    inject a `Grades` object in `Student`, allowing all implementations of the `Grades`
    object to be accessible in the `Student` object. Now, we have accessed the `getGrades()`
    method in our `Student`. To use the `Student` object, we will execute the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that we have instantiated a new student
    in our main class by getting the bean of our `Beans.xml` file. The `Beans.xml`
    file is our main configuration file for our construction-based injection, which
    is where we will define our beans together with their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the following example of what `Beans.xml` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have defined the `Student` and `Grades` object
    as beans. The only difference is that the `Student` object has a `constructor-arg`
    that references grades; this indicates that we are injecting the `Grades` object
    into our `Student` object.
  prefs: []
  type: TYPE_NORMAL
- en: We have already achieved constructor-based dependency by using the `Beans.xml`
    configuration. We can also use annotations directly in our code to configure our
    beans and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example of how to configure beans and dependencies
    with annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that instead of using XML, we have used
    annotations to identify our beans and configuration. For example, the `@Configuration`
    annotation indicates that the `AppConfig` class is the source of the bean definitions,
    and the `@Bean` annotation defines the bean in our application. We will discuss
    annotations and beans intensely as we go throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully learned how to implement constructor-based dependency injection
    by using `Bean.xml` and annotations. Now, let’s move on to the implementation
    of setter-based dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Setter-based dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The injection of dependencies can be achieved when the container calls the setter
    methods of our class. So, instead of creating a constructor for the class, we
    will create a function that will set the object’s dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a basic code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that we have created a setter method named
    `setGrades()`, which accepts a `Grades` object, and its primary function is to
    set a value for the `grades` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the constructor with arguments, we use setters to inject our
    dependencies into our object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Student` object, let’s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that it’s the same as how we used setter-based
    objects and constructor-based objects. The difference here is how we configure
    our beans in `Bean.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the `Beans.xml` example for setter-based dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We configured the beans in our `Beans.xml`, `Student`, and the `Grades` object
    in the preceding example. The only difference here is when we declare dependencies.
    We use the `property` tag instead of `constructor-arg` to define our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created our object with setter-based dependency injection,
    and now, we will discuss field-based dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Field-based dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, `@Autowired` annotation for injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the following example of injecting dependencies into a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example code, we can see that we didn’t create a constructor
    or a setter method to inject our dependency. Instead, we only used the `@Autowired`
    annotation to inject the `Grades` object.
  prefs: []
  type: TYPE_NORMAL
- en: The field-based injection may be clean at first glance, having only annotations
    in our code and fewer methods, but many things happen behind our `@Autowired`
    dependency. For example, it uses reflection to inject dependencies that are costlier
    than a constructor and setter-based injection; it also violates the **single responsibility
    principle**. We can add more dependencies directly in the fields without warning.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the basics of dependency injection and the different ways to
    implement it in our Java application. Now, we will discuss the concept and importance
    of annotations and beans in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation and beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Annotation and beans** are essential parts of developing your Spring applications.
    They are considered the building blocks of Spring and make our code less boilerplate
    and maintainable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring annotations** are used to define the different types of beans. They
    are simply a form of metadata that marks our code to provide information. Conversely,
    **beans** are objects that are instantiated and created and can be injected with
    other beans. We will discuss more as we go through this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Types of annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotations in Spring are categorized into different types depending on their
    functionality. The following are annotations grouped into their respective categories.
  prefs: []
  type: TYPE_NORMAL
- en: Core annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`org.springframework.beans.factory.annotation` and `org.springframework.context.annotation`
    packages. The following is a list of core annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Required`: This is applied in the setter methods of a bean and implies that
    the bean must be injected with the dependency at configuration. Otherwise, it
    will throw `BeanInitializationException`. Let’s look at the following example
    of how to use the `@``Required` annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we can see that the `setBrand()` method was annotated
    with `@Required`; this indicates that the brand must be populated on initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Autowired`: We have encountered the `@Autowired` annotation several times
    in DI, and this is mainly used to inject dependencies without the use of constructors
    and setter methods. Let’s look at the following example of how to use the `@``Autowired`
    annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding example that `@Autowired` is applied directly in
    the field. This is because the annotations use reflection to inject dependencies,
    with more processes involved than constructors and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ComponentScan`: The annotation is a class-level annotation to indicate the
    packages we want to be scanned for beans. `@ComponentScan` can accept arguments
    about what specific packages are to be scanned, and not providing any will allow
    the current packages and all sub-packages. Let’s look at the following example
    of how to use `@ComponentScan`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding example that the `@ComponentScan` app is applied
    to the Spring `App` class, and it is usually implemented together with the `@Configuration`
    annotation. Let’s say that `SpringApp` is found under the `com.example.spring.app`
    package; this will scan the package and its sub-packages if there are existing
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ComponentScan`: The annotation is also a class-level annotation to indicate
    that a class is the source of bean definitions that the Spring container will
    process at runtime. Let’s look at the following example of how to use the `@``ComponentScan`
    annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding example that the `@Configuration` annotation is
    applied to the `SpringApp` class, which indicates that `SpringApp` will be the
    source of beans.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Bean`: The annotation is a method-level annotation, and it is used to tell
    a method to produce a bean. Let’s look at the following example of how to use
    the `@``Bean` annotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the `@Bean` annotation is applied to the `beanExample`
    method. Once `JavaConfig` encounters the method, it will be executed and register
    the return value as a bean in `BeanFactory`, and the name will be the same as
    the method name when none is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Bean` annotation can also be configured in Spring XML, and the equivalent
    configuration is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Stereotype annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stereotype annotations** are mainly used to create Spring beans on the fly
    in an application context. The following is a list of stereotype annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Component`: This is the primary stereotype annotation. As with the `@Bean`
    annotation, the `@Component` annotation is used to define a bean or a Spring component.
    The difference between the two is that `@Component` is applied at the class level
    while `@Bean` is applied at the method level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other difference is that the `@Component` class cannot also be used to
    create a bean if the class is outside the Spring container, whereas we can create
    a bean using `@Bean` even if the class is found outside the Spring container.
    Let’s look at the following example of how to use the `@``Component` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that `@Component` is applied to the `Car`
    class. This means that this will create a `car` bean at runtime. We also need
    to remember that `@Component` cannot be used with the `@``Configuration` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Service`: This annotation, used for the service layer, indicates that a class
    is used to execute business logic, perform calculations, and call external APIs.
    `@Service` is a kind of `@``Component` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Repository`: This annotation is used for classes that directly access a database.
    This is an indication of a class that executes the role of a data access object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Controller`: The annotations used for Spring controller classes. It is also
    a type of `@Component` annotation, used for Spring MVC and the methods annotated
    with `@RequestMapping`, which is used for REST.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These annotations are created explicitly for Spring Boot, and this is mostly
    the combination of several annotations. The following is a list of Spring Boot
    annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: This annotation is used to auto-configure the bean
    present in the classpath and then to configure it to run the methods. The annotation
    is now rarely used, as `@SpringBootApplication` has already been released in Spring
    1.2.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SpringBootApplication`: The annotation is the combination of `@EnableAutoConfiguration`,
    `@ComponentsScan`, and `@Configuration`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are specialized annotations used to create endpoints, specify the HTTP
    requests, and serialize return objects. The following list shows the different
    REST annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This is used to create endpoints and map web requests. The
    annotations can be used in a class or a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping`: This maps the HTTP `GET` requests and is used for fetching data,
    and it is the equivalent of `@RequestMapping(method =` `RequestMethod.GET)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This maps the HTTP `POST` requests and is used for creating
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.POST)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This maps the HTTP `PUT` requests and is used for updating
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.PUT)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This maps the HTTP `PUT` requests and is used for deleting
    data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.DELETE)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This maps the HTTP `PATCH` requests and is used for partial
    updates on data, and it is the equivalent of `@RequestMapping(method =` `RequestMethod.PATCH)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`: This is used to bind HTTP requests with an object in a method
    parameter. The Spring framework binds the HTTP request body of the parameter with
    the `@``RequestBody` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ResponseBody`: This attaches the method''s return value to the response body.
    The annotation indicates that the return object should be serialized into a JSON
    or XML format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`: This is used to get the values from the URI. It is allowed
    to define multiple `@PathVariable` instances in a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestParam`: This is used to get the query parameters from the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestHeader`: This is used to extract the details about the incoming HTTP
    request headers. We use this annotation in the parameters of a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RestController`: This is a combination of the `@Controller` and `@ResponseBody`
    annotations. The importance of this annotation is that it prevents annotating
    each method with `@``ResponseBody`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned about the different types of annotations and their uses in Spring.
    Now, we will discuss and understand more in the next section the actual definition
    and importance of beans in Spring applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already encountered beans several times in the previous section. We
    have learned how to create and initialize beans using `@Bean` and `@Component`
    annotations, but the main question is, *what is the primary use of a bean in*
    *Spring applications?*
  prefs: []
  type: TYPE_NORMAL
- en: A **bean** is the central concept of the Spring Framework we need to understand.
    It is essential to learn its purpose and functionality to use the Spring Framework
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: To define a bean in Spring, it is an object that forms the backbone of your
    application managed by the Spring IoC container. These are the objects that we
    mainly use for data and to inject dependencies to create multiple implementations.
    For better understanding, let’s have some examples of beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a domain class named `Car`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the example that the car needs a `Brand` dependency. The `Brand`
    class has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The typical approach is to create a new instance of the `Brand` class and pass
    it as a parameter upon creating a new `Car` class. This approach will work fine,
    but this can cause issues when we have many classes. So, a better process is that
    instead of constructing dependencies by themselves, the objects can retrieve their
    dependencies from an IoC container in the form of beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we only need to do is configure the beans and dependencies using annotations
    or XML to identify the dependencies required for a specific object. Let’s convert
    the previous example into a bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will annotate the `Car` class with the `@Component` annotation to identify
    the class as `Bean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is create a configuration class. In the preceding
    example, we have annotated the class with `@Configuration` and `@ComponentScan`
    to identify that this is our configuration class; this will produce a `Bean` of
    type `Brand`, having configured the `Brand` class as a `Bean`. We will only need
    to pull the beans in the application context, and the dependencies are already
    injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example code, we can see that we have extracted the `Car` bean
    in the application context. Therefore, we can automatically use the getter methods
    of the `Brand` dependency; this means that the IoC container manages the beans
    and their dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned. You have learned the fundamentals of Spring
    Boot, its architecture, and the basics of REST. You have also learned how to use
    Spring Initializr to create your own Spring Boot project.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection allows objects or classes to accept other dependencies
    that can implement different classes without writing them again. Annotations define
    the different types of beans; they are simply a form of metadata that marks our
    code to provide information.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, beans are objects that form the backbone of an application managed
    by the Spring IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning how to set up a database and use Spring
    Data JPA.
  prefs: []
  type: TYPE_NORMAL
