["```java\nscala> class SomeClass\ndefined class SomeClass\nscala> object SomeObject\ndefined object SomeObject\nscala> :type SomeObject\nSomeObject.type\nscala> :type new SomeClass\nSomeClass\nscala> trait SomeTrait {\n     | def usage(a: SomeClass, b: SomeObject.type): SomeTrait\n     | }\ndefined trait SomeTrait\n```", "```java\nscala> def singleIn[T <: Singleton](t: T): T = t\nsingleIn: [T <: Singleton](t: T)T\n\nscala> final val t = singleIn(42)\nt: 42 = 42\n```", "```java\nscala> def bool2String(b: true) = \"ja\"\nbool2String: (b: true)String\nscala> bool2String(true)\nres7: String = ja\nscala> bool2String(false)\n ^\n error: type mismatch;\n found : Boolean(false)\n required: true\n```", "```java\nscala> val a1: true = true\na1: true = true\n\nscala> bool2String(a1)\nres10: String = ja\n\nscala> final val a2 = true\na2: Boolean(true) = true\n\nscala> bool2String(a2)\nres11: String = ja\n\nscala> // but\n\nscala> val a3 = true\na3: Boolean = true\n\nscala> bool2String(a3)\n                   ^\n       error: type mismatch;\n        found : a3.type (with underlying type Boolean)\n        required: true\n```", "```java\nscala> object scope {\n | def bool2String(b: true) = \"ja\"\n | def bool2String(b: false) = \"nein\"\n | }\n def bool2String(b: false) = \"nein\"\n ^\nOn line 3: error: double definition:\n def bool2String(b: true): String at line 2 and\n def bool2String(b: false): String at line 3\n have same type after erasure: (b: Boolean)String\n```", "```java\nscala> def singleOut[T](t: T): t.type = t\nsingleOut: [T](t: T)t.type\n\nscala> final val t = singleOut(42)\nt: 42 = 42\n```", "```java\ndef valueOf[T](implicit vt: ValueOf[T]): T = vt.value\n```", "```java\nscala> final val a = valueOf[42]\na: 42 = 42\n```", "```java\nscala> def int2str(i: Int) = i match {\n     | case t: 42 => \"forty-two\"\n     | case ii => ii.toString\n     | }\nint2str: (i: Int)String\n\nscala> int2str(42)\nres24: String = forhty-two\n\nscala> int2str(43)\nres25: String = 43\n```", "```java\nscala> trait A { override def toString = \"A\" }\ndefined trait A\n\nscala> trait B { override def toString = super.toString + \"B\" }\ndefined trait B\n\nscala> trait C { override def toString = super.toString + \"C\" }\ndefined trait C\n\nscala> class E extends A with B with C {\n     | override def toString: String = super.toString + \"D\"\n     | }\ndefined class E\n\nscala> new E().toString\nres28: String = ABCD\n```", "```java\ntrait A { def a: String }\ntrait B { def b: String }\ntrait C { this: A => // override `this`\n  def c = this.a\n}\ntrait D { self: A with B => // any alias is allowed; mixed traits\n  def d = this.a + this.b\n}\n```", "```java\ncase class C(); class D(); case class E()\n\ndef iOrB(i: Int, s: Boolean)(b: Boolean): AnyVal = if (b) i else s\ndef iOrS(i: Int, s: String)(b: Boolean): Any = if (b) i else s\n\ndef sOrC(c: C, s: String)(b: Boolean): java.io.Serializable = if (b) c else s\ndef cOrD(c: C, d: D)(b: Boolean): AnyRef = if (b) c else d\ndef cOrE(c: C, e: E)(b: Boolean): Product with Serializable = if (b) c else e\n```", "```java\ntrait Foo { def foo: Int }\ncase class F() extends Foo {def foo: Int = 0}\ncase class G() extends Foo {def foo: Int = 0}\n\ndef fOrG(f: F, g: G)(b: Boolean): \n  Product with Serializable with Foo = if (b) f else g\n```", "```java\ncase class Lock() {\n  final case class Key()\n  def open(key: Key): Lock = this\n  def close(key: Key): Lock = this\n  def openWithMaster(key: Lock#Key): Lock = this\n  def makeKey: Key = new Key\n  def makeMasterKey: Lock#Key = new Key\n}\n```", "```java\nval blue: Lock = Lock()\nval red: Lock = Lock()\nval blueKey: blue.Key = blue.makeKey\nval anotherBlueKey: blue.Key = blue.makeKey\nval redKey: red.Key = red.makeKey\n\nblue.open(blueKey)\nblue.open(anotherBlueKey)\nblue.open(redKey) // compile error\nred.open(blueKey) // compile error\n\n```", "```java\nval masterKey: Lock#Key = red.makeMasterKey\n\nblue.openWithMaster(masterKey)\nred.openWithMaster(masterKey)\n```", "```java\ncase class Wrapper[A](content: A) {\n  def unwrap: A = content\n}\ndef createWrapper[A](a: A):Wrapper[A] = Wrapper(a)\ntype ConcreteWrapper[A] = Wrapper[A]\n\nval wInt: Wrapper[Int] = createWrapper[Int](10)\nval wLong: ConcreteWrapper[Long] = createWrapper(10L)\nval int: Int = wInt.unwrap\nval long: Long = wLong.unwrap\n```", "```java\ncase class Abc[A](a: A, b: A, c: A)\nval intA: Abc[Int] = Abc(10, 20, 30)\nval longA: Abc[Long] = Abc(10L, 20L, 30L)\nval whatA: Abc[AnyVal] = Abc(10, 20, true)\nval whatB: Abc[io.Serializable] = Abc(\"10\", \"20\", Wrapper(10))\nval whatC: Abc[Any] = Abc(10, \"20\", Wrapper(10))\n```", "```java\ntrait Constraints[A <: AnyVal, B >: Null <: AnyRef] {\n  def a: A\n  def b: B\n}\n\n// compile error - type parameter bounds\n// case class AB(a: String, b: Int) extends Constraints[String, Int]\n\ncase class AB(a: Int, b: String) extends Constraints[Int, String]\n```", "```java\ntrait HolderA {\n  type A\n  def a: A\n}\nclass A extends HolderA {\n  override type A = Int\n  override def a = 10\n}\n```", "```java\ntrait HolderBC {\n  type B\n  type C <: B\n  def b: B\n  def c: C\n}\n```", "```java\nclass BC extends HolderBC {\n  override def b = \"String\"\n  override def c = true\n}\n\n```", "```java\ntrait HolderDEF {\n  type D >: Null <: AnyRef\n  type E <: AnyVal\n  type F = this.type\n  def d: D\n  def e: E\n  def f: F\n}\n\nclass DEF extends HolderDEF {\n  override type D = String\n  override type E = Boolean\n\n  // incompatible type String\n  // override type E = String\n  // override def e = true\n\n  override def d = \"\"\n  override def e = true\n\n  // incompatible type DEF\n  // override def f: DEF = this\n\n  override def f: this.type = this\n}\n```", "```java\nabstract class HolderGH[G,H] {\n  type I <: G\n  type J >: H\n  def apply(j: J): I\n}\nclass GH extends HolderGH[String, Null] {\n  override type I = Nothing\n  override type J = String\n  override def apply(j: J): I = throw new Exception\n}\n```", "```java\ntrait Rule[In] {\n  type Out\n  def method(in: In): Out\n}\n```", "```java\nabstract class Wrapper[A] {\n  val a: A\n  // A in flatten shadows A in the Wrapper\n  // def flatten[B, A <: Wrapper[B]]: Wrapper[B] = a\n  def flatten(implicit ev: A <:< Wrapper[B]): Wrapper[B] = a\n}\n```", "```java\ntype Or[A, B]\ntype And[A, B]\ntype +=[A, B] = Or[A, B]\ntype =:[A, B] = And[A, B]\n\ntype CC = Or[And[A, B], C]\ntype DA = A =: B =: C\ntype DB = A And B And C\n\n// type E = A += B =: C // wrong associativity\ntype F = (A += B) =: C\n```", "```java\ntype |[A, B] = Or[A, B]\ntype  [A, B] = And[A, B]\ntype G = A   B | C\n\n```", "```java\nsealed trait Glass[Contents]\ncase class Full[Contents](contents: Contents) extends Glass[Contents]\ncase object Empty extends Glass[Nothing]\n```", "```java\ncase class Water(purity: Int)\ndef drink(glass: Glass[Water]): Unit = ???\n\n```", "```java\ndrink(Full(Water(100)))\ndrink(Empty) // compile error, wrong type of contents\n```", "```java\ndef drinkAndRefill(glass: Glass[Water]): Unit = ???\ndrinkAndRefill(Empty) // same compile error\n```", "```java\ndef drinkAndRefill[B <: Water](glass: Glass[B]): Unit = ???\n```", "```java\nsealed trait Glass[+Contents]\n```", "```java\ndrink(Empty) // compiles fine\n```", "```java\nclass Drinker[T] { def drink(contents: T): Unit = ??? }\n\nsealed trait Glass[Contents] {\n  def contents: Contents\n  def knockBack(drinker: Drinker[Contents]): Unit = drinker.drink(contents)\n}\ncase class Full[C](contents: C) extends Glass[C]\n```", "```java\nclass Water(purity: Int)\nclass PureWater(purity: Int) extends Water(purity) {\n  def shine: Unit = ???\n}\n\nval glass = Full(new PureWater(100))\nglass.knockBack(new Drinker[PureWater])\n```", "```java\nglass.knockBack(new Drinker[Water]) // compile error\n```", "```java\nclass Drinker[-T] { def drink(contents: T): Unit = ??? }\nglass.knockBack(new Drinker[Water]) // compiles\n```", "```java\ndef drink[T <: Water](g: Glass[T]): Unit = { g.contents; () }\n```", "```java\ndef drink[_ <: Water](g: Glass[_]): Unit = { g.contents; () }\n```", "```java\nimport scala.language.existentials\nval glass = Full[T forSome { type T <: Water }](new Water(100))\n```", "```java\nsealed trait Contents\ncase class Water(purity: Int) extends Contents\ncase class Whiskey(label: String) extends Contents\nsealed trait Container[C <: Contents] { def contents: C }\ncase class Glass[C<: Contents](contents: C) extends Container[C]\ncase class Jar[C <: Contents](contents: C) extends Container[C]\n\n```", "```java\ndef fillGlass[C <: Contents](c: C): Glass[C] = Glass(c)\ndef fillJar[C <: Contents](c: C): Jar[C] = Jar(c)\n```", "```java\nsealed trait Filler[CC[_]] {\n  def fill[C](c: C): CC[C]\n}\nobject GlassFiller extends Filler[Glass] {\n  override def fill[C](c: C): Glass[C] = Glass(c)\n}\nobject JarFiller extends Filler[Jar] {\n  override def fill[C](c: C): Jar[C] = Jar(c)\n}\n```", "```java\ndef fill[C, G[_]](c: C)(F: Filler[G]): G[C] = F.fill(c)\n```", "```java\nval fullGlass: Glass[Int] = fill(100)(GlassFiller)\nval fullJar: Jar[Int] = fill(200)(JarFiller)\n```", "```java\nsealed trait Contents\ncase class Water(purity: Int) extends Contents\ncase class Whiskey(label: String) extends Contents\n\nsealed trait Container[C] { def contents: C }\ncase class Glass[C](contents: C) extends Container[C]\ncase class Jar[C](contents: C) extends Container[C]\n\nsealed trait Filler[C <: Contents, CC <: Container[C]] {\n  def fill(c: C): CC\n}\n```", "```java\ntype WaterFiller[CC <: Container[Water]] = Filler[Water, CC]\n\ndef fillWithWater[CC <: Container[Water]](container: CC)(filler: WaterFiller[CC]) = ???\n\n```", "```java\ndef fillWithWater[CC <: Container[Water], F: ({ type T[C] = Filler[Water, C] })#T[CC]](container: CC)(filler: F) = ???\n```", "```java\ndef fillWithWater[CC <: Container[Water]](container: CC)(filler: ({ type T[C] = Filler[Water, C] })#T) = ???\n```", "```java\nsealed trait Lock\nclass PadLock extends Lock\nclass CombinationLock extends Lock\n```", "```java\nsealed trait LockState\nsealed trait Open extends LockState\nsealed trait Closed extends LockState\nsealed trait Broken extends LockState\n```", "```java\ncase class Lock[State <: LockState]()\n```", "```java\ndef break: Lock[Broken] = Lock()\ndef open[_ >: State <: Closed](): Lock[Open] = Lock()\ndef close[_ >: State <: Open](): Lock[Closed] = Lock()\n\n```", "```java\nscala> val openLock = Lock[Open]\nopenLock: Lock[Open] = Lock()\nscala> val closedLock = openLock.close()\nclosedLock: Lock[Closed] = Lock()\nscala> val broken = closedLock.break\nbroken: Lock[Broken] = Lock()\nscala> closedLock.close()\n ^\n error: inferred type arguments [Closed] do not conform to method close's type parameter bounds [_ >: Closed <: Open]\nscala> openLock.open()\n ^\n error: inferred type arguments [Open] do not conform to method open's type parameter bounds [_ >: Open <: Closed]\nscala> broken.open()\n ^\n error: inferred type arguments [Broken] do not conform to method open's type parameter bounds [_ >: Broken <: Closed]\n```", "```java\ndef open(implicit ev: State =:= Closed): Lock[Open] = Lock()\ndef close(implicit ev: State =:= Open): Lock[Closed] = Lock()\n```", "```java\nscala> val openLock = Lock[Open]\nopenLock: Lock[Open] = Lock()\n\nscala> val closedLock = openLock.close\nclosedLock: Lock[Closed] = Lock()\n\nscala> val lock = closedLock.open\nlock: Lock[Open] = Lock()\n\nscala> val broken = closedLock.break\nbroken: Lock[Broken] = Lock()\n\nscala> closedLock.close\n                  ^\n       error: Cannot prove that Closed =:= Open.\n\nscala> openLock.open\n                ^\n       error: Cannot prove that Open =:= Closed.\n\nscala> broken.open\n              ^\n       error: Cannot prove that Broken =:= Closed.\n```", "```java\nsealed trait Lock\nclass PadLock extends Lock\nclass CombinationLock extends Lock\n```", "```java\nsealed trait Secret[E]\nsealed trait Lock[E] { def open(key: Secret[E]): E = ??? }\ncase class PadLock() extends Lock[PadLock]\ncase class CombinationLock() extends Lock[CombinationLock]\n```", "```java\ncase class IntLock() extends Lock[Int]\nlazy val unlocked: Int = IntLock().open(new Secret[Int] {})\n```", "```java\nsealed trait Lock[E <: Lock]\n```", "```java\nsealed trait Lock[E <: Lock[E]] {\n  def open(key: Secret[E]): E = ???\n}\n```", "```java\nscala> case class IntLock() extends Lock[Int]\n                                      ^\n       error: illegal inheritance;\n        self-type IntLock does not conform to Lock[Int]'s selftype Int\nscala> case class PadLock() extends Lock[PadLock]\ndefined class PadLock\n```", "```java\nscala> case class CombinationLock() extends Lock[PadLock]\ndefined class CombinationLock\n```", "```java\nsealed trait Lock[E <: Lock[E]] { self: E  =>\n  def open(key: Secret[E]): E = self\n}\n\nscala> case class CombinationLock() extends Lock[PadLock]\n                                              ^\n       error: illegal inheritance;\n        self-type CombinationLock does not conform to Lock[PadLock]'s selftype PadLock\nscala> case class CombinationLock() extends Lock[CombinationLock]\ndefined class CombinationLock\nscala> PadLock().open(new Secret[PadLock]{})\nres2: PadLock = PadLock()\nscala> CombinationLock().open(new Secret[CombinationLock]{})\nres3: CombinationLock = CombinationLock()\n```"]