<html><head></head><body>
		<div id="_idContainer055">
			<h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor054"/>Chapter 3</em>: GraalVM Architecture</h1>
			<p><a id="_idTextAnchor055"/>In <a href="B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Evolution of Java Virtual Machine</em>, we took a detailed look at the JVM architecture. In <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">JIT, HotSpot, and GraalJIT</em>, we went into more detail on how JVM JIT compilers work. We also looked at how JVM has evolved into an optimum HotSpot VM, with C1 and C2 JIT compilers.</p>
			<p>While the C2 compiler is very sophisticated, it has become a very complex piece of code. GraalVM provides a Graal compiler, which builds on top of all the best practices from the C2 compiler, but it is built entirely from the ground up in Java. Hence, Graal JIT is more object-oriented, and has modern and manageable code, with the support of all of the modern integrated development environments, tools, and utilities to monitor, tune, and manage the code. GraalVM is much more than just the Graal JIT compiler. GraalVM brings in a larger ecosystem of tools, runtimes, and APIs to support multiple languages (Polyglot) to run on VMs, leveraging the most mature and hardened JIT compilation provided by Graal.</p>
			<p>In this chapter, we will focus on the GraalVM architecture and its various components to achieve the most advanced, fastest, polyglot runtime for the cloud. We will also explore the cloud-native architectural patterns, and how GraalVM is the best platform for the cloud.</p>
			<p>Before we get into the details of the GraalVM architecture, we will begin by learning the requirements of a modern technical architecture. Later in the chapter, as we go through each of the GraalVM architectural components, we will address these requirements. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Reviewing modern architectural requirements</li>
				<li>Learning what the GraalVM architecture is</li>
				<li>Reviewing the GraalVM editions </li>
				<li>Understanding the GraalVM architecture</li>
				<li>An overview of the GraalVM microservices architecture</li>
				<li>An overview of various microservices frameworks that can build code for GraalVM</li>
				<li>Understanding how GraalVM addresses various non-functional aspects</li>
			</ul>
			<p>By the end of this chapter, you will have a very clear understanding of the GraalVM architecture and how various components come together to provide a comprehensive VM runtime for polyglot applications.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor056"/>Reviewing modern architectural requirements</h1>
			<p>Before we dig deeper into the GraalVM architecture, let's first understand the shortcomings of JVM and why we need a new architecture and approach. The older versions of JVM were optimized for traditional architectures, which were built for long-running applications that run in a data center, providing high throughput and stability (for example, monolith web application servers and large client-side applications). Some microservices are long-running, and Graal JIT will also provide the optimum solution. As we move to cloud-native, the whole architecture paradigm has shifted to componentized, modularized, distributed, and asynchronous architecture tuned to run efficiently with high scalability and availability requirements.</p>
			<p>Let's <a id="_idIndexMarker169"/>break this down into more specific requirements for the modern cloud-native architectures.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor057"/>Smaller footprint</h2>
			<p>The applications are <a id="_idIndexMarker170"/>composed of granular modular components (microservices) for high scalability. Hence, it is important to build the applications with a smaller footprint, so that they don't consume too much RAM and CPU. As we move to cloud-native deployments, it's even more important, as we have <em class="italic">p</em><em class="italic">ay-per-use</em> on the cloud. The smaller the footprint, the <a id="_idIndexMarker171"/>more we can run with fewer resources on the cloud. This has a direct impact on <strong class="bold">Total Cost of Ownership</strong> (<strong class="bold">TCO</strong>), one of the key business KPIs.</p>
			<p>A smaller footprint also helps us to make changes and deploy them rapidly and continuously. This is very important in the agile world, where the systems are built to embrace change. As businesses change rapidly, applications are also required to embrace changes rapidly to support business decisions. In traditional monolith architectures, even a small change requires an overall build, test, and deployment. In modern architectures, we need flexibility to roll out changes in the functionality in a modular way, without bringing the production systems down.</p>
			<p>We have new engineering <a id="_idIndexMarker172"/>practices such as A/B testing, where we perform the testing of these functional modules (microservices) in parallel with the older version, to decide whether the new version is good enough to roll out. We perform canary deployments (rolling updates), where the application components are updated, without stopping the production systems. We will cover these architectural requirements in more detail in the <em class="italic">DevOps – continuous integration and delivery</em> section later in this chapter.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Quicker bootstrap</h2>
			<p>Scalability is <a id="_idIndexMarker173"/>one of the most <a id="_idIndexMarker174"/>important requirements. Modern applications are built to scale up and down rapidly based on the load. The load has increased exponentially and modern-day applications are required to handle any load gracefully. With a smaller footprint, it's also expected that these application components (microservices) boot up quickly to start handling the load. As we move toward more serverless architectures, the application components are expected to handle bootup and shutdown on request. This requires a very rapid bootup strategy.</p>
			<p>A quicker bootstrap and smaller footprint also pose the challenge of building application components with embeddable VM. The container-based approach requires these application components to be immutable.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/>Polyglot and interoperability</h2>
			<p>Polyglot is the <a id="_idIndexMarker175"/>reality: each language <a id="_idIndexMarker176"/>has its own strengths and will continue to have, so we need to embrace this fact. If you look at the <a id="_idIndexMarker177"/>core logic of the interpreter/compiler, they are all the same. They all try to achieve similar levels of optimization and generate the fastest running <a id="_idIndexMarker178"/>machine code with the smallest footprint. What we need is an optimum platform that can run these <a id="_idIndexMarker179"/>various applications, written in different languages, and also allow interoperability between them.</p>
			<p>With these architecture requirement lists in mind, let's now understand how GraalVM works and how it addresses these requirements.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor060"/>Learning what the GraalVM architecture is</h1>
			<p>GraalVM provides a Graal JIT compiler, an implementation of JVMCI (which we covered in the previous chapter), which is completely built on Java and uses C2 compiler optimization techniques as the baseline and builds on top of it. Graal JIT is much more sophisticated than a C2 compiler. GraalVM is a drop-in replacement for JDK, which means that all the applications that are currently running on JDK should run on GraalVM without any application code changes.</p>
			<p>While GraalVM is <a id="_idIndexMarker180"/>built on Java, it not only supports Java, but also enables Polyglot development with JavaScript, Python, R, Ruby, C, and C++. It provides an extensible framework called <strong class="bold">Truffle</strong> that <a id="_idIndexMarker181"/>allows any language to be built and run on the platform.</p>
			<p>GraalVM also provides AOT compilation to build native images with static linking. GraalVM comes with the <a id="_idIndexMarker182"/>following list of runtimes, libraries, and tools/utilities (this is for the GraalVM 20.3.0 version. The latest list of components can be found at <a href="https://www.graalvm.org/docs/introduction/">https://www.graalvm.org/docs/introduction/</a>.)</p>
			<p>First, let's have a look at the <a id="_idIndexMarker183"/>core components in the following table:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B16878_Table_3.1.jpg" alt=""/>
				</div>
			</div>
			<p>Next, let's go through the <a id="_idIndexMarker184"/>list of additional tools and utilities in the following table:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B16878_Table_3.2.jpg" alt=""/>
				</div>
			</div>
			<p>Now that we are aware of the components in GraalVM, we will go through the various editions of GraalVM that are available, and the differences between these editions.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor061"/>Reviewing the GraalVM editions (Community and Enterprise)</h1>
			<p>GraalVM is available as Community and Enterprise Editions:</p>
			<ul>
				<li><strong class="bold">Community Edition</strong>: GraalVM <strong class="bold">Community Edition</strong> (<strong class="bold">CE</strong>) is an open source edition built as an <a id="_idIndexMarker185"/>OpenJDK distribution. Most of the <a id="_idIndexMarker186"/>components of GraalVM are GPL 2, with a classpath exception licensed. For more details on licensing, please refer to <a href="https://github.com/oracle/graal#license">https://github.com/oracle/graal#license</a>. GraalVM CE is based on OpenJDK 1.8.272 and OpenJDK 11.0.9. GraalVM CE is community supported. It can be deployed in production. However, it does not come with the required support services from Oracle. Oracle also provides a Docker image, which is readily downloadable, for testing and evaluation (refer to <a href="https://www.graalvm.org/docs/getting-started/container-images/">https://www.graalvm.org/docs/getting-started/container-images/</a> for further details).</li>
				<li><strong class="bold">Enterprise Edition</strong>: GraalVM <strong class="bold">Enterprise Edition</strong> (<strong class="bold">EE</strong>) is a licensed version under the GraalVM OTN license agreement. This is <a id="_idIndexMarker187"/>free for evaluation and building non-production applications. GraalVM EE provides additional performance (~20% faster than CE and dynamic <a id="_idIndexMarker188"/>languages such as JavaScript, Python, R, and Ruby are ~2x faster), a smaller footprint (~2x smaller than CE), security (native code memory protection), and scalability for running production enterprise applications. EE comes with additional debugging tools, such as Ideal Graph Visualizer, which helps in not only debugging performance issues, but also in fine-tuning the applications for best performance on GraalVM. GraalVM EE comes with support services. For Oracle cloud customers, GraalVM EE support is available as part of the <a id="_idIndexMarker189"/>subscription. GraalVM EE also has a managed mode, which does better <a id="_idIndexMarker190"/>heap management, avoiding page faults and crashes. GraalVM EE is available for clients who already have a Java SE subscription.</li>
			</ul>
			<p>Now that we know the various available editions of GraalVM, and what runtimes, tools, and frameworks come with it, let's get into the details of the GraalVM architecture.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor062"/>Understanding the GraalVM architecture</h1>
			<p>In this section, we will look at the <a id="_idIndexMarker191"/>various architectural components of GraalVM. We will look at how various runtimes, tools, and frameworks come together to provide the most advanced VM and runtime. The following diagram shows the high-level architecture of GraalVM:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B16878_Figure_3.1.jpg" alt="Figure 3.1 – Graal VM architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Graal VM architecture</p>
			<p>Let's go through each of these components in detail.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor063"/>JVM (HotSpot)</h2>
			<p>JVM HotSpot is the <a id="_idIndexMarker192"/>regular Java HotSpot VM. The C2 compiler, which is part of the <a id="_idIndexMarker193"/>HotSpot VM, is replaced with the Graal JIT compiler implementation. The Graal JIT compiler is an implementation of <strong class="bold">Java Virtual Machine Compiler Interface</strong> (<strong class="bold">JVMCI</strong>) and plugs into the Java VM. We covered the architecture of JVM HotSpot in the previous chapters. Please refer to them for a more in-depth understanding of how JVM HotSpot works and the various architectural components of JVM.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor064"/>Java Virtual Machine Compiler Interface (JVMCI)</h2>
			<p>JVMCI was introduced in Java 9. This <a id="_idIndexMarker194"/>allowed compilers to be written as plugins that JVM can call for dynamic compilation. It provides an API and a <a id="_idIndexMarker195"/>protocol to build compilers with custom implementations and optimizations.</p>
			<p>The word <em class="italic">compiler</em> in this context means a just-in-time compiler. We went into a lot of detail on JIT compilers in the previous chapters. GraalVM uses JVMCI to get access to the JVM objects, interact with JVM, and install the machine code into the code cache.</p>
			<p>Graal JIT implementation comes in two modes:</p>
			<ul>
				<li><strong class="source-inline">libgraal</strong>: <strong class="source-inline">libgraal</strong> is an AOT compiled <a id="_idIndexMarker196"/>binary that is <a id="_idIndexMarker197"/>loaded by HotSpot VM as a native binary. This is the default mode and the recommended way to run GraalVM with HotSpot VM. In this mode, <strong class="source-inline">libgraal</strong> uses its own memory space and does not use the HotSpot heap. This mode of Graal JIT has quick bootup and improved performance.</li>
				<li><strong class="source-inline">jargraal</strong>: In this mode, Graal JIT is <a id="_idIndexMarker198"/>loaded like any <a id="_idIndexMarker199"/>other Java class, and hence it goes through a warm-up phase and runs with an interpreter until the hot methods are identified and optimized. This mode can be invoked by passing the <strong class="source-inline">--XX:-UseJVMCINativeLibrary</strong> flag from the command line.</li>
			</ul>
			<p>In OpenJDK 9+, 10+, and 11+, we use the <strong class="source-inline">-XX:+UnlockExperimentalVMOptions</strong>, <strong class="source-inline">-XX:+UseJVMCICompiler</strong>, and <strong class="source-inline">XX:+EnableJVMCI</strong> flags to run the Graal compiler, instead of the C2 compiler. GraalVM, by default, uses the Graal JIT compiler. It is always advisable to use GraalVM distributions, as these <a id="_idIndexMarker200"/>have the latest changes. OpenJDK gets the changes merged at a slower rate.</p>
			<p>In the next chapter, we <a id="_idIndexMarker201"/>will be going into detail on how Graal JIT is better than the C2 JIT, using a sample code. We will be using the debugging tools and utilities that come with Graal to demonstrate the optimizations that Graal JIT performs at runtime.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor065"/>Graal compiler and tooling</h2>
			<p>The Graal compiler is <a id="_idIndexMarker202"/>built on JVMCI and provides a <a id="_idIndexMarker203"/>better JIT compiler (C2 as we covered in both the previous chapters) implementation, with <a id="_idIndexMarker204"/>further optimizations. The Graal compiler also <a id="_idIndexMarker205"/>provides an AOT (Graal AOT) compilation option to build native images that can run standalone with embedded VMs.</p>
			<h3>Graal JIT compiler</h3>
			<p>We looked at the <a id="_idIndexMarker206"/>JVM architecture in <a href="B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Evolution of Java Virtual Machine</em>. For reference, here is the high-level architecture overview of JVM:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B16878_Figure_3.2.jpg" alt="Figure 3.2 – JVM architecture with a C2 compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – JVM architecture with a C2 compiler</p>
			<p>As you can see, the C1 and C2 compilers implement the JIT compilation as part of the JVM execution <a id="_idIndexMarker207"/>engine. We went into a lot of detail on how C1 and C2 optimize/deoptimize the code based on the compilation threshold.</p>
			<p>GraalVM replaces the JIT compiler in JVM and incorporates further optimization. The following diagram shows the high-level architecture of GraalVM:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B16878_Figure_3.3.jpg" alt="Figure 3.3 – VM architecture with Graal compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – VM architecture with Graal compiler</p>
			<p>One of the differences <a id="_idIndexMarker208"/>between the JVM JIT compiler and Graal JIT is that Graal JIT is built to optimize the intermediate code representation (<strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) and using Graal graphs, or Graal intermediate representation). Java represents the code as an AST, an intermediate representation, while compiling.</p>
			<p>Any language expressions and instructions can be converted and represented as ASTs; this helps in abstracting the language-specific syntax and semantics from the logic of optimizing the code. This approach makes GraalVM capable of optimizing and running code written in any language, as long as the code can be converted into an AST. We will be doing a deep dive into Graal graphs and ASTs in <a href="B16878_04_Final_SK_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Graal Just-In-Time Compiler</em>.</p>
			<p>The four key <a id="_idIndexMarker209"/>components of the Graal JIT compiler are as follows:</p>
			<ul>
				<li><strong class="bold">Profiler</strong>: As the name suggests, it profiles the running code and generates the information that is used by the code optimizer to take decisions or make assumptions regarding optimization.</li>
				<li><strong class="bold">Intermediate Code Generator</strong>: This generates the intermediate code representation, which is the input for the code optimizer.</li>
				<li><strong class="bold">Code Optimizer</strong>: This uses the data that is collected by profiles and optimizes the intermediate code.</li>
				<li><strong class="bold">Target Code Generator</strong>: The optimized code is then converted to the target machine code.</li>
			</ul>
			<p>The following diagram shows how Graal JIT works at a very high level:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B16878_Figure_3.4.jpg" alt="Figure 3.4 – Graal JIT compilation – a high-level flowchart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Graal JIT compilation – a high-level flowchart</p>
			<p>Let's <a id="_idIndexMarker210"/>understand this flowchart better:</p>
			<ul>
				<li>The JVM language (Java, Kotlin, Groovy, and so on) code runs on Graal JIT natively, and Graal JIT optimizes the code.</li>
				<li>The non-JVM languages (such as JavaScript and Ruby) implement a language parser and interpreter using the Truffle API. The language interpreters convert the code into AST representation. Graal runs the JIT compilation on the intermediate representation. This helps in leveraging all the advanced optimization techniques implemented by Graal to non-JVM languages.</li>
				<li>The <a id="_idIndexMarker211"/>native LLVM-based languages (such as C/C++, Swift, and Objective C) follow a slightly different route to convert to the intermediate representation. Graal Sulong is used to create the intermediate representation that is used by Graal. We will be talking about Truffle and Sulong later in this chapter.</li>
			</ul>
			<h4>Graal JIT optimization strategies</h4>
			<p>Graal JIT optimization strategies are built from the ground up, based on the best practices from the C2 JIT compiler optimization strategies. Graal JIT builds on top of the C2 optimization strategies and provides more advanced optimization strategies. Here are some of the <a id="_idIndexMarker212"/>optimization strategies that the Graal JIT compiler performs:</p>
			<ul>
				<li>Partial escape analysis</li>
				<li>Improved inlining (<a href="http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf">http://aleksandar-prokopec.com/resources/docs/prio-inliner-final.pdf</a>)</li>
				<li>Guard optimization (<a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf">http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf</a>)</li>
				<li>Chaining lambdas</li>
				<li>Inter-procedural optimization</li>
			</ul>
			<p>We will be covering these optimization strategies in detail, with the help of sample code and examples, in the next chapter.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/>Truffle</h2>
			<p>The Truffle framework is an <a id="_idIndexMarker213"/>open source library for building the <a id="_idIndexMarker214"/>interpreters and the tools/utilities (such as integrated development environments, debuggers, and profilers). The Truffle API is used to build language interpreters that can run on GraalVM, leveraging the optimizations provided by GraalVM.</p>
			<p>The Graal and Truffle frameworks consist of the following APIs that enable Polyglot:</p>
			<ul>
				<li><strong class="bold">Language Implementation Framework</strong>: This <a id="_idIndexMarker215"/>framework is <a id="_idIndexMarker216"/>used by the language implementers. It also comes with a reference <a id="_idIndexMarker217"/>implementation of a language called <strong class="bold">SimpleLanguage</strong>. We will be going through this in detail in <a href="B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 9</em></a>, <em class="italic">Graal Polyglot – LLVM, Ruby, and WASM</em>.</li>
				<li><strong class="bold">Polyglot API</strong>: This set of APIs aids <a id="_idIndexMarker218"/>interaction between <a id="_idIndexMarker219"/>code written in different languages (guest languages) with Java (the host language). For example, a Java (host) program can embed R (guest) language code to perform some machine learning/AI logic. The Polyglot API provides the framework that will help the language programmers to manage the objects between the guest and the host.</li>
				<li><strong class="bold">Instrumentation</strong>: The Truffle Instrumentation API <a id="_idIndexMarker220"/>provides the <a id="_idIndexMarker221"/>framework for utilities/tool builders to build integrated development/debugging environments, tools, and utilities. The tools and utilities that are built using the Truffle Instrumentation API can work with any language that is implemented with Truffle. This provides a consistent developer experience across various languages and leverages the sophisticated debugging/diagnostic capabilities of JVM.</li>
			</ul>
			<p><em class="italic">Figure 3.5</em> shows the high-level architecture of <a id="_idIndexMarker222"/>how Truffle acts as an intermediate layer between GraalVM and other language interpreters. The individual language interpreters are implemented using the Truffle API. Truffle also provides an interoperability API, for calling methods and passing data between methods across various language implementations:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B16878_Figure_3.5.jpg" alt="Figure 3.5 – Truffle architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Truffle architecture</p>
			<p>As represented in the previous diagram, Java applications run directly on the GraalVM, with Graal Compiler <a id="_idIndexMarker223"/>replacing the C2 JIT compiler. Other language programs run on top of the Truffle Language Implementation framework. The respective language interpreters use the <a id="_idIndexMarker224"/>Truffle to implement the interpreters. Truffle combines the code along with the interpreter to produce the machine code, using partial evaluation.</p>
			<p>AST is the intermediate representation. AST provides the optimum way to represent the syntactic structure of the language, where typically, the parent node is the operator, and the children node represents the operands or operators (based on cardinality). The following diagram shows a rough representation of AST:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B16878_Figure_3.6.jpg" alt="Figure 3.6 – AST for simple expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – AST for simple expression</p>
			<p>In this diagram, <strong class="bold">a</strong>, <strong class="bold">b</strong>, and <strong class="bold">c</strong> can be any variables (for loosely typed languages). The interpreter starts assuming "generics" based on the profiling of various executions. It then starts assuming the specifics and will then optimize the code using partial evaluation.</p>
			<p>Truffle (language interpreters written with Truffle) runs as an interpreter and Graal JIT kicks in to start identifying optimizations in the code.</p>
			<p>The optimizations <a id="_idIndexMarker225"/>are based on speculation, and eventually, if the <a id="_idIndexMarker226"/>speculation is proven to be incorrect at runtime, the JIT will re-optimize and recompile (as shown in the previous diagram). Re-optimization and recompiling is an expensive task.</p>
			<p>Partial evaluation creates an intermediate representation of the language, from the code and the data, and as it learns, and identifies new data types, it deoptimizes to the AST interpreter, applies optimizations, and does the node rewriting and recompiles. After a certain point, it will have the optimum representation. The following diagram explains how Truffle and Graal optimize intermediate representation:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B16878_Figure_3.7.jpg" alt="Figure 3.7 – AST optimization by Graal JIT&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – AST optimization by Graal JIT</p>
			<p>Let's <a id="_idIndexMarker227"/>understand <a id="_idIndexMarker228"/>this diagram better:</p>
			<ul>
				<li>The expression is reduced to an AST. In the AST nodes, the leaf nodes are operands. In this example, we have taken a very simple expression to understand how partial evaluation works. In a language such as JavaScript, which is not a strongly typed language, a, b, and c can be any data type (sometimes referred to as generics). Evaluating a generic in an expression is a costly operation.</li>
				<li>Based on the profiling, Graal JIT speculates and assumes a specific data type (in this example, as an integer), optimizes the code to evaluate the expression for integers, and compiles the code.</li>
				<li>In this example, it is using an inlining optimization strategy. The Graal JIT compiler has various other optimization strategies that are applied based on the use case.</li>
				<li>When, during runtime, the compiler identifies a control flow where one of the operands is not really an integer, it deoptimizes and rewrites the AST with the new data type and optimizes the code.</li>
				<li>Following a few iterations of running this optimization/deoptimization, the compiler will eventually generate the most optimum code.</li>
			</ul>
			<p>The key difference <a id="_idIndexMarker229"/>here is that Graal is working on the AST and generating <a id="_idIndexMarker230"/>optimized code, and it does not matter what language is used to write the source code as long as the code is represented as AST.</p>
			<p>The following diagram shows a high-level flow of how different languages run on GraalVM, with Truffle acting as an intermediate layer, to execute any programming language code on GraalVM:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B16878_Figure_3.8.jpg" alt="Figure 3.8 – Truffle and Graal compilation flowchart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Truffle and Graal compilation flowchart</p>
			<p>This diagram illustrates a simpler representation of how Truffle acts as a layer between non-JVM languages and GraalVM. The code can also be built directly as a native image with Substrate VM.</p>
			<p>Truffle API is used <a id="_idIndexMarker231"/>along with a custom annotations processor to generate interpreter source code, which is then compiled. Java code does not need the intermediate <a id="_idIndexMarker232"/>representation. It can be compiled directly to run on GraalVM. We will discuss Truffle interpreters and how to write a custom interpreter in <a href="B16878_09_Final_SK_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 9</em></a>, <em class="italic">Graal Polyglot – LLVM, Ruby, and WASM</em>. We will cover the Truffle Polyglot API in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>.</p>
			<p>Truffle also provides a <a id="_idIndexMarker233"/>framework called the <strong class="bold">Truffle Instrument API</strong> for building tools. Instruments provide fine-grained VM-level runtime events, which can be used to build profiling, tracing analyzing, and debugging tools. The best part is that the language interpreters built with Truffle can use the ecosystem of Truffle instruments (for example, VisualVM, Chrome Debugger, and GraalVM Visual Studio Code Extension).</p>
			<p>Truffle <a id="_idIndexMarker234"/>provides the <strong class="bold">Polyglot Interoperability Protocol</strong>. This protocol defines the message that each language needs to implement and supports the passing of data between the Polyglot applications.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/>Sulong – LLVM</h2>
			<p>LLVM is an open source <a id="_idIndexMarker235"/>project that is a collection of <a id="_idIndexMarker236"/>modular, reusable compilers and toolchains. There are a lot of language (C, C++, Fortran, Rust, Swift, and so on) compilers that are built on LLVM, where LLVM provides the intermediate representation (also known as LLVM-IR).</p>
			<p>The Sulong pipeline looks different from what we looked at in other language compilers that are running on Truffle. The following diagram shows how C/C++ code gets compiled:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B16878_Figure_3.9.jpg" alt="Figure 3.9 – LLVM compilation flowchart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – LLVM compilation flowchart</p>
			<p>This diagram shows <a id="_idIndexMarker237"/>how an application code written in C is compiled and run on GraalVM. The application code in native languages such as C/C++ is <a id="_idIndexMarker238"/>compiled in Clang, into an intermediate representation. This LLVM intermediate representation runs on the LLVM intermediate representation interpreter, which is built on the Truffle API. Graal JIT will further optimize the code at runtime.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor068"/>SubstrateVM (Graal AOT and native image)</h2>
			<p>Applications on <a id="_idIndexMarker239"/>Graal can be deployed on GraalVM or SubstrateVM. SubstrateVM is <a id="_idIndexMarker240"/>embeddable VM code that gets packaged during AOT compilation in native images. </p>
			<p>Graal AOT compilation is a very <a id="_idIndexMarker241"/>powerful way to create native binaries for a particular targeted OS/architecture. For cloud-native workloads and serverless, this is a very powerful option for achieving a smaller footprint, faster startups, and, more importantly, embeddable runtimes (providing immutability).</p>
			<p>Rapid componentized modular deployment (containers) also poses management and versioning challenges. This is <a id="_idIndexMarker242"/>typically called <strong class="bold">Configuration Drift</strong>, which is one of the major issues that we face in managing a large number of containers in high-availability environments. Typically, container infrastructure is built by a team and, over time, it is managed by different teams. There are always situations where we are forced to change the configuration of the VMs/containers/OS in a particular environment that we may never trace. This causes a gap between production and the DR/HA environment.</p>
			<p>Immutable infrastructure (images) helps us do better version control of the infrastructure. It also <a id="_idIndexMarker243"/>gives us more confidence in testing, as the underlying infrastructure on which our application containers are running is <a id="_idIndexMarker244"/>immutable, and we are certain about the test results. To build immutable components, we require an embeddable VM (with a small footprint). SubstrateVM provides that embeddable VM.</p>
			<p>In AOT compilation, the code is compiled directly to the machine code and executed. There is no runtime profiling or optimization/deoptimization. The Graal AOT compiler (also referred to as the "native image" compiler) performs static analysis and static initializations on the code and produces a VM-embedded executable code. The optimization performed by AOT is based on the reachability of the code. The following diagram shows the compilation process:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B16878_Figure_3.10.jpg" alt="Figure 3.10 – Graal AOT compilation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Graal AOT compilation</p>
			<p>This diagram shows how the Graal AOT compiles native images and embeds SubstrateVM as part of the native image. One of the disadvantages of AOT compilation is that the VM cannot optimize the code based on runtime profiling, as in JIT. To address this issue, we use a profile guided optimization strategy to capture the runtime metrics of the application and use that profiled data to optimize the native image by recompiling.</p>
			<h3>Profile Guided Optimization (PGO)</h3>
			<p>GraalVM uses <strong class="bold">Profile Guided Optimization</strong> (<strong class="bold">PGO</strong>) to <a id="_idIndexMarker245"/>optimize native images based on the <a id="_idIndexMarker246"/>runtime profiling data. This is one of the features that is available in Enterprise Edition only. The following diagram shows how a PGO pipeline works:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B16878_Figure_3.11.jpg" alt="Figure 3.11 – Graal AOT compilation with PGO&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Graal AOT compilation with PGO</p>
			<p>Let's understand this <a id="_idIndexMarker247"/>workflow better:</p>
			<ul>
				<li>When the code is compiled with <strong class="source-inline">native-image</strong>, we use the <strong class="source-inline">--pgo-instrumented</strong> flag. This will tell the compiler to inject instrumentation code into the compiled code.</li>
				<li>When we start running this instrumented native image, the profiler starts collecting the runtime data and then starts creating the profile files (<strong class="source-inline">.ipof</strong>).</li>
				<li>Once we have run the native image with various workloads (all possible workloads – to capture as much instrumentation as possible), we can then recompile the native image with the <strong class="source-inline">--pgo</strong> flag (<strong class="source-inline">native-image --pgo=profile.iprof</strong>), providing <a id="_idIndexMarker248"/>the profile files as input. The Graal native image compiler creates the optimum native image.</li>
			</ul>
			<p>We will be building a native <a id="_idIndexMarker249"/>image with profile-guided optimization in the next chapter with the help of real examples and also understand how memory management works in native images.</p>
			<p>GraalVM is a great runtime for the modern microservices architecture. In the next section, we will go through the various features of GraalVM that help to build a microservices application.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor069"/>An overview of GraalVM microservices architecture</h1>
			<p>GraalVM is ideal for <a id="_idIndexMarker250"/>microservices architecture. One of the most important requirements for certain microservices architecture is a smaller footprint and faster startup. GraalVM is an ideal runtime for running Polyglot workloads in the cloud. Cloud-native frameworks are already available on the market that can build applications to run optimally on GraalVM, such as Quarkus, Micronut, Helidon, and Spring. These frameworks are found to perform almost 50x times faster when running as native images. We will go into detail about how GraalVM is the right runtime and platform for microservices in <a href="B16878_10_Final_SK_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Microservices Architecture with GraalVM.</em></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor070"/>Understanding how GraalVM addresses various non-functional aspects</h1>
			<p>In this section, we will go <a id="_idIndexMarker251"/>through the typical non-functional requirements of a microservices cloud-native architecture, and how GraalVM addresses these requirements.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor071"/>Performance and scalability</h2>
			<p>Performance and scalability are <a id="_idIndexMarker252"/>among the more important non-functional requirements of a microservices cloud-native architecture. The microservices are automatically scaled out and down by orchestrators such as Kubernetes. This requires the microservices to be built on a runtime that starts up quickly and runs fast, consuming minimal cloud resources. GraalVM AOT compilation helps to build native images that perform on a par with native languages such as C/C++.</p>
			<p>To understand how AOT compiled code (native image) is faster than JIT compiled code, let's look at the steps that JIT and AOT follow at runtime:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B16878_Figure_3.12.jpg" alt="Figure 3.12 – Graal JIT versus the AOT flowchart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Graal JIT versus the AOT flowchart</p>
			<p>This diagram shows the high-level steps for JIT and AOT. JIT optimizes the code over a period of time by profiling the code at runtime. There are performance overheads, as there is additional profiling, optimizing, and deoptimizing that is done by the JVM at runtime.</p>
			<p>It is observed, based on the Apache Bench benchmark, that while GraalVM JIT throughput and performance is lower than AOT at the beginning, as the number of requests increases, Graal JIT optimizes and performs better than Graal AOT after around 14,000 requests per second.</p>
			<p>It is also observed that Graal AOT performs 50 times faster than Graal JIT and has a 5x smaller memory footprint than Graal JIT.</p>
			<p>Graal AOT with PGO throughput is <a id="_idIndexMarker253"/>consistent and sometimes better than Graal JIT. However, for long-running tasks, Graal JIT might have better throughput. So, for the best throughput and consistent performance, Graal AOT with PGO is the best.</p>
			<p>Please refer to the benchmark study published at <a href="https://www.infoq.com/presentations/graalvm-performance/">https://www.infoq.com/presentations/graalvm-performance/</a> and <a href="https://www.graalvm.org/why-graalvm/">https://www.graalvm.org/why-graalvm/</a>.</p>
			<p>There are further benchmark studies that are published with academic collaborators at <a href="https://renaissance.dev">https://renaissance.dev</a>.</p>
			<p>Here's what we can conclude:</p>
			<ul>
				<li>GraalVM Native Image (AOT) is best for faster startups and applications that require a smaller footprint, such as serverless applications and container microservices.</li>
				<li>GraalVM JIT is best for peak throughputs. Throughput is a very important aspect for long-running processes, where scalability is critical. This could be high-volume web application servers such as e-commerce servers and stock market applications.</li>
				<li>A combination of garbage collection configuration and JIT will help in achieving reduced latency. Latency is very important as regards the responsiveness of applications. When we are running high throughput, it's possible that on occasion, garbage collection slows down the response.</li>
			</ul>
			<p>There is not a hard and fast rule for using it. It depends on various combinations that we need to decide <a id="_idIndexMarker254"/>between JIT and AOT, and various other configurations that are possible. We will explore various compiler and native image configurations in the next chapter.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Security</h2>
			<p>GraalVM security is <a id="_idIndexMarker255"/>built on JVM security, which is based on the sandbox model. Let's have a very quick <a id="_idIndexMarker256"/>review of how the sandbox model works:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B16878_Figure_3.13.jpg" alt="Figure 3.13 – JVM security model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – JVM security model</p>
			<p>In Java 2 security architecture, all the class files are verified by bytecode verifier (please refer to both the previous chapters for more details on class loaders). The bytecode verifier checks whether the class files are valid and look for any overflows, underflows, data type conversions, method calls, references to classes, and so on.</p>
			<p>Once the bytecode is <a id="_idIndexMarker257"/>verified, the dependent classes are loaded by the class loader. Please refer to <a href="B16878_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Evolution of Java Virtual Machine</em>, to understand how the class loader subsystem works. Class loaders work with Security Manager and access control to enforce security rules that are defined in the policy files. Java code that is downloaded over the network is checked for a signature (represented as <strong class="source-inline">java.security.CodeSource</strong>, including the public key).</p>
			<p>Security Manager (<strong class="source-inline">java.lang.SecurityManager</strong>) is the most important component for handling authorizations. Security Manager has various checks in place to ensure that the authorization is done. The access controller (<strong class="source-inline">java.security.AccessContoller</strong>) class is another critical class that helps control access to system resources.</p>
			<p>Keystore is a password-protected store that holds all the private keys and certificates. Each entry in the store can also be password-protected.</p>
			<p>Java Security is extendable, with <a id="_idIndexMarker258"/>custom security implementations called <strong class="bold">Security Providers</strong>.</p>
			<p>GraalVM builds on the Java security model and abstracts it to address enforcing security at intermediate representation level. GraalVM does not recommend running untrusted code on Security Manager.</p>
			<p>The GraalVM security model uses the Truffle language implementation framework API for JVM host applications to create an execution context, which is passed to the guest application (application code written in different languages). The following diagram shows the high-level architecture of how GraalVM allows the guest and host applications to interoperate and determine how access is controlled:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16878_Figure_3.14.jpg" alt="Figure 3.14 – Graal security model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Graal security model</p>
			<p>The execution context (<strong class="source-inline">org.graalvm.polyglot.Context</strong>) defines the access control for the guest applications. Based on the access control that is defined in the execution context, the guest applications get access to the system's resources. GraalVM provides a Polyglot API to <a id="_idIndexMarker259"/>create these access controls, with an execution context, to set the access privileges to access various functions, such as File I/O, Threading, and Native Access. Based on what privileges are set by the host, the guest will have that access. A watchdog thread is used to timebound the context. The watchdog will close the context, in the given time, to free up the resources, and restrict access based on time.</p>
			<p>The following code demonstrates how the execution context can be set:</p>
			<p class="source-code">Context context = Context.newBuilder().allowIO(true).build();</p>
			<p class="source-code">Context context = Context.newBuilder()                  .fileSystem(FileSystem fs).build();</p>
			<p class="source-code">Context context = Context.newBuilder()                  .allowCreateThread(true).build()</p>
			<p class="source-code">Context context = Context.newBuilder()                  .allowNativeAccess(true).build()</p>
			<p>GraalVM also offers an API to exchange objects between host and guest applications:</p>
			<ul>
				<li><strong class="bold">Guest to Host Data Exchange</strong>: The <a id="_idIndexMarker260"/>guest application can call the host methods and may pass the data. However, this is controlled <a id="_idIndexMarker261"/>based on method access modifiers and the host access policy (ALL, NONE or EXPLICIT – <strong class="source-inline">@HostAccess.Export</strong> Annotation, for example).</li>
				<li><strong class="bold">Host to Guest Data Exchange</strong>: The <a id="_idIndexMarker262"/>objects passed <a id="_idIndexMarker263"/>from the host to the guest need to be handled by guest languages. The data is passed through the context, for example:<p class="source-code">Value a = Context.create().eval("js", "21 + 21");</p></li>
			</ul>
			<p>Value <strong class="source-inline">a</strong> can be returned by the <a id="_idIndexMarker264"/>host application to the JavaScript guest application with a value of <strong class="source-inline">42</strong> (after evaluation).</p>
			<p>We will be covering this in detail in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, with the help of a real example.</p>
			<p>GraalVM EE also provides a managed execution mode for LLVM intermediate representation code to handle any memory violations and faults. Please refer to <a href="https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html">https://docs.oracle.com/en/graalvm/enterprise/19/guide/security/security-guide.html</a> for more details.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor073"/>DevOps – continuous integration and delivery</h2>
			<p>DevOps automation is <a id="_idIndexMarker265"/>one of the <a id="_idIndexMarker266"/>core requirements of any modern, cloud-native architecture. GraalVM integrates very well into the DevOps pipeline. The following diagram illustrates a typical GitOps pipeline with representative software (GraalVM integrates into any stack of the DevOps software stack):</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B16878_Figure_3.15.jpg" alt="Figure 3.15 – GitOps with GraalVM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – GitOps with GraalVM</p>
			<p>Let's understand this diagram better.</p>
			<p>The <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) pipeline <a id="_idIndexMarker267"/>gets triggered by a <a id="_idIndexMarker268"/>typical pull request from the Git repository with changes in the application code and infrastructure code. CI tools such as GitHub actions, Argo CD, or CicleCI can be used to orchestrate a CI pipeline. A typical CI pipeline consists of the following:</p>
			<ul>
				<li><strong class="bold">Build</strong>: In the build phase, the release tagged code is <a id="_idIndexMarker269"/>pulled from the appropriate branch from the Git repository. The code is verified (any static code analysis) and built. For cloud-native, typically, the code is built as native images, using the Graal AOT compiler.</li>
				<li><strong class="bold">Test</strong>: The code is tested <a id="_idIndexMarker270"/>with unit testing scripts and further verified for any security vulnerabilities.</li>
				<li><strong class="bold">Package</strong>: Once the code <a id="_idIndexMarker271"/>passes all the tests, the code is typically packaged into the cloud-native target runtime (using a Docker image or VM or any other binary format). The target could be a serverless container or Docker container or a VM.</li>
				<li><strong class="bold">Store</strong>: The final binaries are <a id="_idIndexMarker272"/>stored on binary stores or repositories, such as Docker Hub or Red Hat Quay (if it's a Docker image).</li>
			</ul>
			<p>The Continuous Deployment pipeline can either be triggered based on a release plan or can be manually triggered (depending on the release plan and strategy). Continuous Deployment typically has the following phases:</p>
			<ul>
				<li><strong class="bold">Deployment for Validation</strong>: The final <a id="_idIndexMarker273"/>binary ID deployed to an environment where the binary can now be tested end to end. Various strategies can be followed:<p>a. <strong class="bold">Traditionally</strong>: We have <a id="_idIndexMarker274"/>an Integration Test Environment and a User Acceptance Test Environment (or Pre-Production Environment) for various <a id="_idIndexMarker275"/>levels of validation and testing.</p><p>b. <strong class="bold">Blue/Green Deployment</strong>: There are two parallel environments (called Blue and Green). One of them will be in production, let's assume Blue. The Green environment can be used to <a id="_idIndexMarker276"/>test and validate our code. Once we are sure that the new release is working fine, we use the router to switch to the Green environment and use the Blue environment for testing future releases. This provides a high availability way to deploy applications.</p><p>c. <strong class="bold">Canary Deployments and Rolling Updates</strong>: Canary deployment is more a recent approach of using the same environment for both production and validation. This is a great <a id="_idIndexMarker277"/>feature to test our code and compare the new release with the current release (A/B testing). Canary deployments provide an API management layer, which can be used to redirect the traffic to specific endpoints, based on various parameters (such as testing users or a user from a specific department can access the new version, while end users are still using the old version). The <a id="_idIndexMarker278"/>application can be deployed on a specific number of servers/nodes (by % or number). As we get more confident with the new release, we can perform rolling updates by increasing the number of nodes, where the new release should run, and open up to a wider circle of users. This also gives the flexibility to perform a phased rollout of new releases (by region or user demography or any parameter).</p></li>
				<li><strong class="bold">Testing</strong>: There are various levels of <a id="_idIndexMarker279"/>testing that are performed, both functional and non-functional. Most of this is performed with automation, and that is also choreographed by the Continuous Delivery pipeline.</li>
				<li><strong class="bold">Production Deployment</strong>: Once it's all tested, the <a id="_idIndexMarker280"/>final application is deployed to the production environment. Once again, this deployment may use one of the Traditional or Blue/Green or Canary strategies.</li>
			</ul>
			<p>GraalVM provides a very <a id="_idIndexMarker281"/>flexible way to deploy the application as a standalone, container, cloud, VM, and Oracle database. There are <a id="_idIndexMarker282"/>very sophisticated microservices frameworks, such as Quarkus, Micronaut, and Fn project, that provide native support for GraalVM and integrate very well with modern GitOps tools.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor074"/>Summary</h1>
			<p>In this chapter, we explored the GraalVM architecture. Graal JIT is the new implementation of the JIT compiler, which replaces the C2 compiler, and brings in a lot more optimizations. Graal JIT is implemented completely in Java. Truffle provides the interpreter implementation framework and Polyglot framework to get other non-JVM languages into GraalVM.</p>
			<p>This chapter provided a good understanding of the various runtimes, frameworks, tools, Graal updater, and utilities that are shipped with GraalVM. We also looked at the two available editions of GraalVM and what the key differences are between these two editions. We went through all the various components of the GraalVM architecture. We also explored some of the non-functional aspects of the architecture, including security model, performance, and DevOps. This is very important if you want to understand how GraalVM can be used to build cloud-native microservices and high-performing applications across various languages.</p>
			<p>In the next chapter, we will dig deeper into how Graal JIT works, how we can use the various tools that come with Graal to understand the internal workings of Graal JIT, and how we can use these tools to debug and fine-tune our code.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor075"/>Questions</h1>
			<ol>
				<li>What are the various editions of GraalVM? </li>
				<li>What is JVMCI?</li>
				<li>What is Graal JIT?</li>
				<li>What is Graal AOT? How does PGO help AOT compilation?</li>
				<li>What is Truffle? How does it help to run multiple language codes on GraalVM?</li>
				<li>What is SubstrateVM?</li>
				<li>What is Guest Access Context?</li>
				<li>Why is GraalVM the ideal runtime for cloud-native microservices?</li>
			</ol>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/>Further reading</h1>
			<ul>
				<li>Lightweight Cloud-Native Java Applications (<a href="https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673">https://medium.com/graalvm/lightweight-cloud-native-java-applications-35d56bc45673</a>)</li>
				<li>Java on Truffle — Going Fully Metacircular (<a href="https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840">https://medium.com/graalvm/java-on-truffle-going-fully-metacircular-215531e3f840</a>)</li>
				<li>GraalVM (<a href="https://www.graalvm.org/">https://www.graalvm.org/</a>)</li>
				<li>GraalVM Enterprise Edition (<a href="https://docs.oracle.com/en/graalvm/enterprise/20/index.html">https://docs.oracle.com/en/graalvm/enterprise/20/index.html</a>)</li>
				<li>GraalVM Git (<a href="https://github.com/oracle/graal">https://github.com/oracle/graal</a>)</li>
			</ul>
		</div>
	</body></html>