<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web Application Security</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you will learn about the importance of security in web apps. We will investigate the responsibility of a programmer when adding security measures. Lastly, we will extend the functionality of the blogmania app.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Recognize the value of security in web applications</li>
<li>Identify a programmer's role in web app security</li>
<li>Assess in which areas Spring offers security solutions</li>
<li>Extend the blogmania app with access control</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing Your Web Application</h1>
                </header>
            
            <article>
                
<p>Security is of the utmost importance in software development. This does not just apply to online banking or your personal health data – it even applies for very simple applications. Why is that so?</p>
<p>Imagine that your web application has been a great success so far. Many people are using it, some may store their data in it. Then, disaster strikes: through a flaw in your software, an attacker is able to hijack the machine that your app is running on and abuse the machine for some evil purpose. Or, it turns out that people can read the diary entries of all users. It could become expensive for you; it could destroy customers' trust in your software!</p>
<p>Additionally, other security-related issues, such as the exposure of customer data from Ashley Madison dating website, credit card data theft in the millions, or even computer viruses, may come up as relevant sections worth talking about.</p>
<p>Designing and operating secure software has to be a major aim from the very beginning. There are many aspects of security that are difficult to add later. Let's take a look at some of the possible threats.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Threats to Software Security</h1>
                </header>
            
            <article>
                
<p>There are many threats to software security. The full section could easily fill a book of its own. In this chapter, we can only hope to gain a broad overview. The threats that we will look at can be coarsely categorized as follows:</p>
<ul>
<li>Interpret untrusted data</li>
<li>Allow access from foreign clients</li>
<li>Allow access to resources not owned</li>
<li>Insufficient logging and monitoring</li>
</ul>
<div class="packt_infobox"><br/>
A great source for information on security for web applications is <strong>OWASP</strong> (<strong>Open Web Application Security Project</strong>). Pay particular attention to their list of <em>Top 10 Most Critical Web Application Security Risks</em>: <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interpreting Untrusted Data</h1>
                </header>
            
            <article>
                
<p>Whenever an application receives data from another application, there is the question of whether to trust that data or not. Sometimes, in a closed system, trusting others is the correct way to handle data, but in the majority of circumstances, some<br/>
caution is in order.</p>
<p>This is intentionally a wide category. OWASP lists multiple problems that can be subsumed in it. The general advice here is to check data carefully. There is no single way that any library could help with that. To make you aware of some of the possible issues, let's look at a non-exhaustive list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Injection</h1>
                </header>
            
            <article>
                
<p><strong>Injection</strong> means to allow a user to inject some of their code into your code. This is very rarely a good idea, and it is usually not on purpose. Two very prominent representatives of this are <strong>XSS</strong> (<strong>Cross-Site Scripting using JavaScript</strong>) and SQL injection. Usually, some text from a client is accepted for instance, in a simple text field in a form on a web page and is subsequently used without further processing. Now, imagine that the text entered into the form was as follows:</p>
<pre>&lt;script&gt;alert('Hello World')&lt;/script&gt;</pre>
<p>If this text was then simply embedded into your web page, the text would not be displayed, but instead, this JavaScript would be executed! To avoid this, you can either be very conservative in what you accept, or you can escape the text in every output. The former is simpler, but may be a problem for the user; if you do not allow the less-than sign (&lt;), then the user cannot use it, even for legitimate text. The latter requires you to escape the text everywhere; for instance, by using <kbd>&lt;th:text&gt;</kbd> in Thymeleaf, as we learned in <em><a href="ae829ce0-b16f-454e-84c9-37eb73bc9de5.xhtml">Chapter 5</a>: Displaying Information Using Web Pages</em>.</p>
<p>SQL injection is another problematic attack, particularly for old code that used to create SQL by string concatenation. The remedy is quite simple: use placeholders for your queries. We will see more of this in <em><a href="7ca1da3d-1799-4c1a-b9cd-4456d2810267.xhtml">Chapter 9</a>: Persisting Data Using a Database</em>, when we discuss databases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Insecure Deserialization</h1>
                </header>
            
            <article>
                
<p><strong>Insecure deserialization</strong> has recently become a real problem. The scenario is that some data is meant to be passed between services (that are non-human clients). There are many formats to put this on the wire. In the previous chapter, you have learned about JSON as one such format, but two others which are widespread are XML and Java binary serialization.</p>
<p>Now, XML is a very versatile format. However, with great power comes great responsibility. The <strong>entity</strong> feature is most troublesome in untrusted contexts, and the recommendation is to use libraries that do not expand entities at the loss of functionality, or somehow sanitize the XML before parsing it.</p>
<p>Java serialization is susceptible to bugs in the deserialization routines when the incoming data is manipulated. Many popular libraries contain fixes for this attack. All we can do is to make sure to always use up-to-date software.</p>
<div class="packt_infobox"><br/>
Java serialization and deserialization is used widely in JMS and RMI. They work using a built-in mechanism; you have probably seen the serializable interface before. This is a fine method to convert an object in memory into a binary representation, transfer it over the wire, and convert the binary representation back to an object on the other side. However, if the sender creates a manipulated stream of bytes, the deserialization routine on the other side may be tricked into doing something unexpected.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Allowing Access from Foreign Clients</h1>
                </header>
            
            <article>
                
<p>To allow access means to grant access to every client in a web application. It is a consequence of the way HTTP works, and is generally required for operation. One consequence is that the JavaScript that runs from a foreign site may be able to access the resources on our server. This usually is not what we want.</p>
<p>One possible attack is called <strong>CSRF</strong>, or <strong>Cross-Site Request Forgery</strong>. In its simplest form, imagine a malicious site posing as your banking site, even imitating the layout. After you have entered your credentials, the malicious site can save them for later mayhem, and, in the meantime log you into your real banking site. You will not even notice! Spring Security offers help to avoid CSRF attacks, and we will see how to do this later.</p>
<p>Browsers implement the <strong>Same-Origin-Policy</strong> (<strong>SOP</strong>) to avoid many of these problems. It is, however, a quite rigid policy that may prohibit the legitimate sharing of resources between servers that you control yourself. <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) is a way to circumvent the SOP for your purposes. We will work with Spring Security's support to configure CORS later on.</p>
<div class="packt_infobox"><br/>
As so often with things relating to HTTP and the web, the Mozilla Developer Network is an excellent resource to get more information about SOP, CORS, and CRSF: <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Allowing Access to Resources Not Owned</h1>
                </header>
            
            <article>
                
<p>A user may have access to things that he not have access to. For instance, a normal user should only see his own private information, not that of others, and he should not be able to access the administration interface. The key to accessing control is by using either <strong>authentication</strong> and <strong>authorization</strong>. These are supported very well by Spring security and are actually the bulk of this chapter. Take a look at the following table:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/8a3d1be3-572a-4745-8638-cf2ba1ec0726.png" width="750" height="146"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Insufficient Logging and Monitoring</h1>
                </header>
            
            <article>
                
<p>This is not a threat in itself, but rather it's the failure to detect problems at runtime. Setting up firewalls; is more of a task for the operations department than for the software developer. Proper logging and monitoring can detect the beginning of an attack and allow for quick countermeasures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authentication and Authorization</h1>
                </header>
            
            <article>
                
<p>The terms authentication and authorization are frequently mixed up, but it is very helpful to know their exact meanings – and their differences.</p>
<p>The ultimate goal here is to find out whether the person sitting in front of the monitor is allowed to perform a certain task. First, we have to confirm the identity of the person, and after that, we can check whether this person has the necessary permissions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>Authentication is the process of confirming a client's identity. There are a number of possible ways for a user to authenticate.</p>
<p>Spring Security will manage the classic login variants for us, and we will turn to that in the next section. It also has support for a number of different distributed logins, for example, <kbd>OAuth</kbd> and <kbd>OAuth2</kbd>, but that is out of the scope of this book.</p>
<p>Username-password authentication needs to address the following challenges:</p>
<ul>
<li>We need a user database of some sort. This can be an in-memory, hardcoded list, or it can come from an external database system.</li>
<li>Besides the username, we need to store the password, but in a safe way. The general consensus is to not save the password at all, but a non-reversible hash instead. In the unfortunate event of a leakage in our database, it would then not be possible for the attacker to obtain the passwords; this is important because users tend to use the same (or a similar) passwords in different places.</li>
</ul>
<p>In a web application, we must also think about how the authentication is sent from the browser to the server. One very important aspect is that the original password must travel over the wire (at least once), so we have to ensure that we are using a secure channel (communicating via HTTPS).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>After we have ascertained the identity of the user, we must check what he is allowed to do. This is called authorization, meaning that the user is authorized to do something.</p>
<p>In a web application, it is important to handle two different aspects. Imagine a web application that has a private area for each user and an administration interface. It is quite obvious that we must prevent access to the administration interface for non-privileged users. This can be done by restricting the accessible paths in an application and <strong>granting access</strong> to only relevant paths. You will see how to do that with Spring Security's <kbd>WebSecurityConfigurerAdapter</kbd>.</p>
<p>Some URLs, however, are accessible to all users, but need to display different content. You would not want other people to see your private data! Some resources may react differently, depending on the user: an article may be limited to 1,000 characters for normal users, but to 4,000 characters for premium users.</p>
<p>To handle this, you need to assign access rights to users, in other words, <strong>grant permission</strong>. One such model is to assign roles to users (such as <kbd>USER</kbd> or <kbd>ADMIN</kbd>) and restrict access to resources to certain roles. If you need very fine-grained control, you can also use the more powerful (but, alas, more difficult to handle) <strong>Access Control Lists</strong> (<strong>ACLs</strong>). Only in the most complicated scenarios would you need to check this by hand, though. Spring Security offers you some simple annotations to limit access to methods within Spring Beans.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Examining Baby-step Security (1)</h1>
                </header>
            
            <article>
                
<p>The aim is to analyze the difference between an unsecured and a secured web app. Let's say you want to see an app in an unsecured and a secured version, side by side, to compare them.</p>
<p>Before beginning, you will need to load and start the Security-Intro app found at <a href="https://bit.ly/2REovBW">https://bit.ly/2REovBW</a>. Start the app. Fire up the homepage in the browser and make a REST call to <kbd>/api/messages.json</kbd> in Postman, to see that both are easily accessible. (You can find the Postman configuration in the chapter's folder, as well, if you need it). The steps for completion are as follows:</p>
<ol>
<li>Locate the POM and add the following dependency to its <kbd>&lt;dependencies&gt;</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="2">
<li>Let IntelliJ re-import the POM and restart the application.</li>
<li>Navigate to the web version and make the REST call again.</li>
</ol>
<p>You will make the following two observations:</p>
<ul>
<li>The web version now shows a login page.</li>
</ul>
<p style="padding-left: 60px">  Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/593aa361-40e3-4eaf-93fe-a5591e76f0e3.png" style="width:29.25em;height:15.58em;" width="420" height="224"/></div>
<ul>
<li>The REST call resulted in <strong>401 Unauthorized</strong>.</li>
</ul>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2ylvMzt">https://bit.ly/2ylvMzt</a> to access the complete code for the <kbd>SecurityIntroApplicationTests.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Security</h1>
                </header>
            
            <article>
                
<p>After a short overview of the different aspects of security, let's turn to Spring again, and the way that it addresses some of the issues mentioned previously. Note that many security problems actually stem from the erroneous behavior of the application and cannot be solved by just using a library.</p>
<p>The last two will only be covered quite briefly, as there is not much to say about them. The bulk of this section will, therefore, be about authentication and authorization.</p>
<p>Even if we meticulously took care to differentiate the two words, the concepts could not be demonstrated in isolation, as the effects of the one only become apparent through the other. Let's start by adding Spring Security to the project and look at the effects.</p>
<div class="packt_infobox"><br/>
Spring Security is a sub-project of the Spring platform, just like Spring Web MVC, which was introduced in <a href="6c057031-8824-460d-bad6-abd27cbb3b21.xhtml"/><em><a href="6c057031-8824-460d-bad6-abd27cbb3b21.xhtml">Chapter 4</a></em>: <em>The MVC Pattern</em>. It has a release cycle of its own. When using Spring Boot, you do not have to care about that, as the Spring Boot dependency management will resolve to a tried and tested version. Only in rare cases should you have the need to manually include the required dependencies and specify their version numbers.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Magic of Auto-Configured Spring Security</h1>
                </header>
            
            <article>
                
<p>Adding Spring Security to a Spring Boot project is very simple. It comes with a default configuration that is very secure and is most definitely unsuitable for any real purpose. All you have to do is add the respective starter POM:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>The starter POM has transitive dependencies on all necessary artifacts. Now, upon starting, a Spring Boot application will print out a line like the following:</p>
<pre>Using generated security password: f76defbe-62d2-4711-9189-<br/>aa8926ad03eb</pre>
<p>Access to any resource, whether with a web browser or a REST client, will be secured.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tight Spring Security Defaults</h1>
                </header>
            
            <article>
                
<p>A lot is happening behind the scenes here. The following list is not quite exhaustive, but it contains all of the information that you normally need to know:</p>
<ul>
<li>Installed a security filter chain</li>
<li>Handling all requests</li>
<li>Some fallback user repositories and a login page</li>
</ul>
<p class="mce-root"/>
<p>The magic is part of Spring Boot here, which will create all the necessary Beans for using Spring Security. This is the auto-configuration feature that you already know about, which can create Beans as soon as the necessary classes are found on the classpath and, launch post-construct setup routines to wire it all in.</p>
<p>First, it installs a servlet filter (as introduced in <em><a href="6c057031-8824-460d-bad6-abd27cbb3b21.xhtml">Chapter 4</a>: The MVC Pattern</em>). This filter intercepts each request and adds the necessary security. This is a Spring Bean with the type <kbd>DelegatingFilterProxyRegistrationBean</kbd> and the name <kbd>springSecurityFilterChain</kbd>. As the names already suggest, these are not simple filters, but are chains of filters, with each adding a bit of functionality. These chains are constructed automatically.</p>
<p>The filter is configured to secure all requests by default, and all with the same level of security. There is one notable exception: the login page that you are confronted with when you try to access the web part of the application.</p>
<p>The repository of users for the application is kept in-memory, and there is, in fact, only one user in the system. Its name is <strong>user</strong>, and its password is chosen at random upon the start of the application; it is in the form of a UUID. This is secure, but it is a bit unwieldy in practice. This default was chosen so that adding the dependency would actually make a difference and force users to choose their own configurations, instead of leaving the system as insecure as before.</p>
<p>The results of these measures are quite different for the REST and the web versions, so we will look at them one by one. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing REST with Basic Auth</h1>
                </header>
            
            <article>
                
<p>After introducing Spring Security to the project, accessing a REST resource started to result in <strong>401 Unauthorized</strong>. This is what the security filter will produce when no means of authentication is provided. In case you are wondering, yes, you are <strong>not authorized</strong> to access this resource, but it is primarily because you could not <strong>authenticate</strong> yourself to the system.</p>
<p>Along with the response, the server also sent a header, <kbd>WWW-Authenticate: Basic realm="Realm"</kbd>, to tell the client what to do about the situation. The answer tells us that we should use a procedure called <strong>Basic Auth</strong> and use the <strong>Realm</strong> realm for it.</p>
<div class="packt_infobox"><br/>
The Basic Auth scheme is the simplest form of authentication. It does not require cookies or storage on the server. The client sends the credential with every request in the authorization header. The password is not hashed or encrypted, but only Base64 encoded; therefore, a secure connection is advisable.</div>
<p>A realm can be used to access different areas of a server with different credentials. It is rarely used; most servers have only one realm.</p>
<p>For <strong>REST clients</strong>, this is a simple yet effective way to authenticate. Postman allows you to set the credentials easily, as do command-line tools, such as <strong>cURL</strong>. Neither client nor server needs to store any tokens, so the process is completely stateless.</p>
<p>For <strong>web browsers</strong>, this scheme works, but not comfortably. Browsers will present the user with a dialog box to input the credentials, but this belongs to the browser, and does not share the look and feel of the web page. Also, there is no way to log out again.</p>
<div class="packt_infobox"><br/>
Basic Auth requires validation of the password for every request. Modern password hashing is intentionally slow, to improve security. It is therefore recommended to exchange the password for some shorttime credentials, such as the session, even for REST calls.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing Web Browsing in the Session</h1>
                </header>
            
            <article>
                
<p>After introducing Spring Security to the project, accessing a secured web page started to issue a <strong>302 Found</strong> with a location header, and the browser redirected us to the given page. The very basic login form that we see there is a built-in fallback from Spring Security. Entering credentials there will POST them to another built-in endpoint that will then check the credentials and add them to the session. To identify this session in subsequent requests, a cookie, called JSESSIONID, is set.</p>
<div class="packt_infobox"><br/>
Sessions are supported by all servlet containers, such as Tomcat, and are a place to store some ephemeral data for a returning user. In today's environments, sessions are used mostly to identify the user, and nothing more. Storing real data may bring problems to scalability if there is no central session store.</div>
<p>This scheme is more versatile: a web page can use a login form of its own or embed the login form into a landing page. Also, the user can log out. However, it requires some storage of the session and its identifier in both the server and client, and is thus not 100% stateless.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Examining Baby-step Security (2)</h1>
                </header>
            
            <article>
                
<p>The aim is to utilize the secured web app. Let's say you have a secured app and want to log in. Before beginning, start (or restart) the application from the previous sub-section and navigate to <kbd>http://localhost:8080/</kbd>.</p>
<ol>
<li>Copy the password, which is in a UUID format.</li>
</ol>
<div class="packt_infobox"><br/>
In the log view in IntelliJ, there is a line (that stands out because there are empty lines around) that starts with <span class="packt_screen">Using generated security password</span>.</div>
<ol start="2">
<li>In the browser, enter <kbd>user</kbd> as the username and the copied <kbd>password</kbd> as the password.</li>
</ol>
<div class="packt_infobox"><br/>
You are now logged in and can view the homepage. (If you forgot to reload the form in between, the first login may fail. Just do it again, in this case.)</div>
<ol start="3">
<li>In Postman, in the <strong>Authorization</strong> pane, choose <span class="packt_screen">Basic Auth</span> from the drop-down menu, or load the authenticated version from the Postman collection.</li>
<li>Then, enter the credentials as before.
<ul>
<li>When you click on <span class="packt_screen">Preview Request</span>, you can show the header in the <strong>Headers</strong> pane.</li>
<li>When you send the request, the data is again returned as shown in the following screenshot:</li>
</ul>
</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/92c60b12-4af0-436c-84d1-22272ee8bc16.png" style="width:35.67em;height:21.42em;" width="939" height="564"/></div>
<p>You can see that the data is returned because the authorization header was set correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Explicit Configuration</h1>
                </header>
            
            <article>
                
<p>That was quite a lot at once. To customize the behavior, let's first reproduce the default configuration of Spring Security by hand. It will then be obvious what to change if we have different needs. To do that, we will need the following:</p>
<ul>
<li>A configuration class to handle security aspects</li>
<li>Code containing the HTTP security</li>
<li>A login form and a mapping function to display it</li>
<li>A user repository with a dummy user</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Security Configuration Entry Point</h1>
                </header>
            
            <article>
                
<p>The recommended way to configure Spring Security in Spring Boot is to extend the <kbd>WebSecurityConfigurerAdapter</kbd> class, which offers plugin points to access various aspects. Let's take a look:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class SecurityConfiguration<br/>            extends WebSecurityConfigurerAdapter {<br/><br/>}</pre>
<p>As you can see that we also mark this class as a Spring Boot <kbd>@Configuration</kbd> class and enable the security scheme by using <kbd>@EnableWebSecurity</kbd>.</p>
<div class="packt_infobox"><br/>
You may wonder why <kbd>@EnableWebSecurity</kbd> is necessary at all, if enabled security is the default. You are right – it isn't. Still, it is customary to make it explicit.<br/>
If, for some reason, you want to disable all of Spring Boot's automatic security configuration, even though you have Spring Security included in your project, you have to disable it explicitly in your main application class, using <kbd>@SpringBootApplication(exclude = SecurityAutoConfiguration.class)</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding Hardcoded Users</h1>
                </header>
            
            <article>
                
<p>To manage the authentication source, we use the <kbd>AuthenticationManagerBuilder</kbd>, which we get as an argument to the <kbd>configure()</kbd> method. We will start with <strong>in-memory</strong> authentication, that is, the user list does not come from external sources, but is pre-loaded. Take a look at the following code example:</p>
<pre>public class SecurityConfiguration … {<br/>  @Override<br/>  public void configure(AuthenticationManagerBuilder auth)<br/>                        throws Exception {<br/>    auth.inMemoryAuthentication()<br/>        .withUser(User.withDefaultPasswordEncoder()<br/>                      .username("user")<br/>                      .password("password")<br/>                      .roles("USER"));<br/>  }<br/>}</pre>
<p>The injection builder auth gives us functions that harmonize with autocompletion in the IDE. The <kbd>inMemoryAuthentication()</kbd> creates the <strong>in-memory</strong> store, and <kbd>withUser()</kbd> adds a user to the system, using the same name as before, but with a slightly easier password for playing around.</p>
<div class="packt_infobox"><br/>
The password is given explicitly. Therefore, it is present in the code in plain text. This is not a secure configuration and is only used to get us started in the absence of a database.</div>
<p>The password is now set to something more memorable than the ever-changing UUID. This user has the USER role; this is used to authorize resources, as we will see shortly.</p>
<div class="packt_infobox"><br/>
When you start the application now, it will still print out a generated password. This is <strong>not</strong> the user and password that are used now. It just means that <kbd>UserDetailsServiceAutoConfiguration</kbd> still creates a <kbd>UserDetailsService</kbd> Bean, which is, however, unused. We will replace that Bean with our own implementation later on.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Locking Paths with Basic Auth</h1>
                </header>
            
            <article>
                
<p>To lock and allow access to HTTP resources (web pages or API endpoints), we use an <kbd>HttpSecurity</kbd> object, which we get as an argument to another <kbd>configure()</kbd> method (it is overloaded with some other, less frequently used configuration objects). First, we want to lock all URLs to users that have the <kbd>USER</kbd> role, just like our predefined user:</p>
<pre>public class SecurityConfiguration … {<br/>  @Override<br/>  protected void configure(HttpSecurity http)<br/>                           throws Exception {<br/>    http.authorizeRequests()<br/>        .antMatchers("/**").hasRole("USER")<br/>        .and()<br/>        .httpBasic().realmName("blogmania");<br/>  }<br/>}</pre>
<p>With <kbd>authorizeRequests()</kbd>, we introduce the path matchers section. The <kbd>antMatchers()</kbd> is a function that takes any number of paths in Ant-style, and finally, <kbd>hasRole()</kbd> specifies the condition of the user. In this case, the paths have a certain role.</p>
<div class="packt_infobox"><br/>
Apache Ant (<a href="https://ant.apache.org/">https://ant.apache.org/</a>) was a widely popular Java build system, a predecessor to both Maven and Gradle. It introduced a style of specifying paths, sub-paths, and files that is different from the usage of the asterisk in the shell. It is easy, yet very versatile; the pattern "/**" here means "starting from the root, match everything."<br/>
The roles in Spring Security are simple Java strings. This may cause trouble if you misspell them, so, for real-life applications, you should create an enumeration and use its string value.<br/>
We have now locked everything, but do not have a means to actually authenticate. This is added with the simple <kbd>httpBasic()</kbd> invocation.<br/>
Our app is now secured and accessible using Basic Auth.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding a Login</h1>
                </header>
            
            <article>
                
<p>The basic auth that secures the app now works fine, but the user experience is poor. The user expects a <strong>login form</strong> that is part of the application, and probably a means to log out again. We will now add the following details:</p>
<ul>
<li>Login form</li>
<li>Default: GET /login</li>
<li>Can have as many as needed</li>
<li>Username &amp; password</li>
<li>A mysterious <kbd>_csrf</kbd> field</li>
<li>Send to login controller</li>
<li>Default: <kbd>POST /login</kbd></li>
</ul>
<p>The minimum login form that Spring requires is as follows:</p>
<pre>&lt;form action="/login" method="POST"&gt;<br/>   &lt;input name="username" value="" type="text"&gt;<br/>   &lt;input name="password" type="password"&gt;<br/>   &lt;input name="submit" value="Login" type="submit"&gt;<br/>   &lt;input name="_csrf" value="246a60ad-3059-4e4b-9409<br/>49eddd66efdb" type="hidden"&gt;<br/>&lt;/form&gt;</pre>
<p>Apart from the mysterious <kbd>_csrf</kbd> field, which will be explained in the next section, this is a very basic form with just two parameters (username and password), which will be <kbd>POSTed</kbd> to the <kbd>/login</kbd> URL.</p>
<p>We can have as many of these forms as we like, (to embed them into other pages, for example), as long as they POST their input to the right receiver. Many applications, however, feature an additional separate login page. This will be the page that the users are redirected to if they try to view a page that they cannot access.</p>
<p>This might be because their session is expired, or they may have entered an incorrect password on the first try. The page will then be called with an added <kbd>?error</kbd> parameter. In a Thymeleaf template, we can evaluate that. Consider the following Thymeleaf HTML:</p>
<pre>&lt;form th:action="@{/login}" method="post"&gt;<br/>   &lt;label for="username"&gt;Username&lt;/label&gt;<br/>   &lt;input type="text" id="username" name="username"&gt;<br/>   &lt;label for="password"&gt;Password&lt;/label&gt;<br/>    &lt;input type="password" id="password" name="password"&gt;<br/>    &lt;button type="submit"&gt;Log in&lt;/button&gt;<br/>    &lt;div th:if="${loginError}" class="alert alert-primary"<br/>role="alert"&gt;<br/>       &lt;p class="error"&gt;Wrong user or password&lt;/p&gt;<br/>   &lt;/div&gt;<br/>&lt;/form&gt;</pre>
<p>The first <kbd>&lt;div&gt;</kbd> containing the error message will only be shown when <kbd>loginError</kbd> is set. The full file (including more markup to improve the representation) can be found in the <kbd>login.html</kbd> file, alongside all of the other code for this chapter, in <a href="https://bit.ly/2DGVgvE">https://bit.ly/2DGVgvE</a>.</p>
<p>The login page that we just created is not yet mapped, so we need to add this method in some controller class as follows:</p>
<pre>@GetMapping("/login")<br/>public String login(Model model,<br/>                    @RequestParam Optional&lt;String&gt; error) {<br/>   if (error.isPresent()) {<br/>       log.info("Incorrect login, warning the user");<br/>       model.addAttribute("loginError", "true");<br/>   }<br/>   return "login";<br/>}</pre>
<p>As you can see, this method would be trivial if we did not add a little error handling. By default, Spring will call the login page with <kbd>/login?error</kbd> if an error occurred, so we evaluate this optional parameter and put an attribute into the model; this attribute is used to display the error message in the form. You can find the source code for this in the class <kbd>HomePageController</kbd>, in the source code distribution.</p>
<p>What remains is to tell Spring Security to actually use our login page. For this, we need to add form-based authentication to the HTTP security. Another thing to consider is that access to the login form itself must be granted to everyone, or it will not be possible to log in at all. The complete configuration method will then look like as follows:</p>
<pre>public class SecurityConfiguration … {<br/>  @Override<br/>  protected void configure(HttpSecurity http)<br/>                           throws Exception {<br/>    http.authorizeRequests()<br/>        .antMatchers("/css/**", "/webjars/**", "/login").<br/>permitAll()<br/>        .antMatchers("/**").hasRole("USER")<br/>        .and()<br/>        .formLogin().loginPage("/login")<br/>        .and()<br/>        .httpBasic().realmName("securityintro");<br/>  }<br/>}</pre>
<div class="packt_tip"><br/>
Failure to allow unauthenticated access to the login page itself and all of the resources it needs, be it CSS, JavaScript, or images, will result in a non-functional application. There will be an infinite number of redirects, which the browser will hopefully interrupt at some point.</div>
<p>The first new line permits access for all clients, for a number of new Ant patterns. In addition to the login page itself, we also grant access to the static resources needed for a nicer display.</p>
<p>The other new line configures a form login, in addition to the existing basic auth login, and specifies the login page with the path we used. (It is actually the default, but it is better to be explicit here.)</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding a Logout</h1>
                </header>
            
            <article>
                
<p>Users need to log out of the application, either for security reasons or to log in as another user. This can be easily accomplished, for instance, with the following snippet from the security introduction app (<kbd>index.html</kbd>):</p>
<pre>&lt;form th:action="@{/logout}" method="post"&gt;<br/>   &lt;button type="submit"&gt;Log out&lt;/button&gt;<br/>&lt;/form&gt;</pre>
<p>The gist of this code is that we need to issue a POST request to the <kbd>/logout</kbd> URL, which is the configurable default for this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring Web Security</h1>
                </header>
            
            <article>
                
<p><span>Consider that you have a web app that has web security configured. You want to change which </span><span>pages you can access freely, and which you can only access with authentication. You </span><span>should try to avoid the traps. </span>The aim here is to explore the effects of using the <kbd>HttpSecurity</kbd> object. </p>
<p>Before beginning, load and start the Blogmania app from the folder <a href="https://bit.ly/2PmyyPF">https://bit.ly/2PmyyPF</a>. Note that you cannot access it without logging in, as you are redirected to the login page immediately. After logging in, you can enter the start page. You can log out again.</p>
<ol>
<li>In the <kbd>SecurityConfiguration</kbd> class, find the <kbd>configure(HttpSecurity http)</kbd> method.</li>
<li>First, try to tighten the security by removing the call that (suspiciously)has an entry that looks as if it will allow anyone in! The body should now look as follows:</li>
</ol>
<pre style="padding-left: 60px">http.authorizeRequests()<br/>    .antMatchers("/**").hasRole("USER")<br/>    .and()<br/>    .formLogin().loginPage("/login")<br/>    .and()<br/>    .httpBasic().realmName("blogmania");</pre>
<ol start="3">
<li>Start the application and reload.</li>
</ol>
<div class="packt_infobox"><br/>
That didn't work at all. If you have the browser's developer tools open, you will see that it was redirecting until it decided to break the cycle. What happened? Oh, we disallowed access to the login page itself!</div>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/0c1c072f-e6d4-4bc0-ab49-4dc927158daf.png" style="width:45.75em;height:23.17em;" width="1178" height="594"/></div>
<ol start="4">
<li>Try the opposite. Re-add the line (use <kbd>undo</kbd>), and instead, remove the requirement for a specific role.</li>
<li>By pressing <em>Ctrl + spacebar</em>, IntelliJ will show you the full list of possibilities. Simply choose to permit all, and the result will be as follows:</li>
</ol>
<pre style="padding-left: 60px">http.authorizeRequests()<br/>    .antMatchers("/css/**", "/webjars/**", "/login").<br/>permitAll()<br/>    .antMatchers("/**").permitAll()<br/>    .and()<br/>    .formLogin().loginPage("/login")<br/>    .and()<br/>    .httpBasic().realmName("blogmania");</pre>
<ol start="6">
<li>Start the application and reload.</li>
</ol>
<p class="mce-root">Note that now, you can view all pages without being logged in. You can still navigate to <kbd>/login</kbd> and perform the login. However, there will be no visible difference. (There is only a difference behind the scenes.)</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Method-Level Security</h1>
                </header>
            
            <article>
                
<p>In our previous configuration, we used web security; that is, we applied the security configuration to URLs. Since Spring Security's pluggable architecture is not limited to web applications, there must be another way to control access: <strong>method-level security</strong>.</p>
<p>Even though method-level security can be configured in XML, it is better known under the name of annotation-based security. This is, of course, because its widespread use came with Spring's <kbd>@Secured</kbd> annotation. These days, there are three different sets of annotations, and first we'll look at the annotation that is easiest to use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Roles Allowed</h1>
                </header>
            
            <article>
                
<p>The first annotation comes from JSR-250 (<a href="https://jcp.org/en/jsr/detail?id=250">https://jcp.org/en/jsr/detail?id=250</a>) and is called <kbd>@RolesAllowed</kbd>. It is very easy to use as follows:</p>
<pre>@RolesAllowed("USER")<br/>public void performForRole() {<br/>   log.info("Only called when authorized as USER");<br/>}</pre>
<p>The annotation takes the name of a role (or a list, thereof) and limits calls to <kbd>performSecure</kbd> to authenticated users that also have the USER role. If the method is called and the constraint for the USER role is not satisfied, a runtime exception, <kbd>AccessDeniedException</kbd>, will be thrown instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enable @RolesAllowed</h1>
                </header>
            
            <article>
                
<p>Method-level security is not enabled in Spring Security by default. You have to modify it in a configuration class, preferably your security configuration as follows:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>@EnableGlobalMethodSecurity(jsr250Enabled = true)<br/>public class SecurityConfiguration<br/>        extends WebSecurityConfigurerAdapter {<br/>    …<br/>}</pre>
<p>This annotation is the simplest, but it is also the most limited form of access control with annotations. If your needs surpass the capabilities of <kbd>@RolesAllowed</kbd>, Spring Security offers some more security features.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing Controllers</h1>
                </header>
            
            <article>
                
<p>You can secure all public methods in Spring Beans with annotations. So, assuming that we control access to mapping methods in Spring MVC controllers, how is that different from using the <kbd>HttpSecurity</kbd> configuration?</p>
<p>In fact, it isn't. It is mainly a matter of style. Take a look at the following table:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/0e30aaab-1845-4d9c-a00e-26ad7589e18f.png" style="width:37.42em;height:16.50em;" width="751" height="330"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Original @Secured Method</h1>
                </header>
            
            <article>
                
<p>Spring Security's original annotation for method-level security is called <kbd>@Secured</kbd>. It has to be enabled with <kbd>@EnableGlobalMethodSecurity (securedEnabled = true)</kbd>, to be used. The argument to the annotation is passed to an <kbd>AccessDecisionManager</kbd> to make the final decision. You can allow access to all authenticated authorities, or just to those who have the authority, via a given role as follows:</p>
<pre>@Secured("IS_AUTHENTICATED_ANONYMOUSLY")<br/>public void performSecureWithAny() {<br/>   log.info("Only called when anonymous");<br/>}<br/>@Secured("ROLE_USER")<br/>public void performSecureWithRole() {<br/>   log.info("Only called when authorized as USER");<br/>}</pre>
<p>You may encounter this annotation, but you should avoid it in new code, as it is less simple to use than <kbd>@RolesAllowed</kbd>, and less powerful than <kbd>@PreAuthorize</kbd> and others, which we will see in the next section.</p>
<div class="packt_infobox"><br/>
You may find discussions about the differences between roles and authorities in Spring security in some materials. You may find the rule that all role names should start with the prefix <kbd>ROLE_</kbd> (which can be configured).</div>
<p>Mostly, you will not have to worry about this these days, until you have the need for fine-grained access control in your application. If Spring Security finds role names without the prefix, it will add them in all contexts on the fly – completely in the background. If a user has the role USER, then all of the following roles will allow access:</p>
<pre>@RolesAllowed("USER")<br/>@RolesAllowed("ROLE_USER")<br/>@Secured("ROLE_USER")<br/>@PreAuthorize("hasRole('USER')")<br/>@PreAuthorize("hasRole('ROLE_USER')")<br/>@PreAuthorize("hasAuthority('ROLE_USER')")</pre>
<p>The two exceptions here are <kbd>@Secured("USER")</kbd> because that annotation uses a very special syntax and <kbd>@PreAuthorize("hasAuthority('USER')")</kbd> because the authorities that Spring automatically creates from roles all have the prefix.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Expression-Based Security</h1>
                </header>
            
            <article>
                
<p>The most powerful approach to method level security is in the pre- and post-annotations that allow <kbd>SpEL</kbd>-based access. To enable this set of annotations, the <kbd>prePostEnabled</kbd> option must be set as follows:</p>
<pre>@EnableGlobalMethodSecurity(prePostEnabled = true)<br/>public class SecurityConfiguration … {<br/>    …<br/>}</pre>
<p>This will enable four annotations at once as follows:</p>
<pre>@PreAuthorize<br/>@PostAuthorize<br/>@PreFilter<br/>@PostFilter</pre>
<p>These really are aptly named. Each of them takes a <kbd>SpEL</kbd> expression. This can be arbitrarily complex. Therein lies a certain danger—you must ensure that you actually unit test the effect of the annotations, just as you would with normal Java code. Experience shows that this is often forgotten since testing the annotations is a bit more complicated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Simple Expressions</h1>
                </header>
            
            <article>
                
<p>The first annotation is <kbd>@PreAuthorize</kbd>, and it has very simple semantics: if the <kbd>SpEL</kbd> expression evaluates to true, access to the method is granted, and it is denied otherwise. It can be taken as a more powerful version of <kbd>@RolesAllowed</kbd>, as in the following example:</p>
<pre>@PreAuthorize<br/>@PostAuthorize<br/>@PreFilter<br/>@PostFilter<br/>@PreAuthorize("hasRole('USER')")<br/>public void readMyArticles() {<br/>   log.info("Only called when authorized as USER");<br/>}</pre>
<p>Uptil this point, it is only more verbose; let's look at a slightly better example:</p>
<pre>@PreAuthorize("hasAnyRole('USER', 'GUEST')")<br/>public void readPublicArticles() {<br/>   log.info("Only called when authorized as USER or GUEST");<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Powerful Expressions</h1>
                </header>
            
            <article>
                
<p>The real power begins to show when the expressions access the arguments of the method they secure. For instance, imagine that we have fetched a record from the database, and then, further down the processing chain, we want to delete it in a service as follows:</p>
<pre>@PreAuthorize("#blogPost.author.name == authentication.name")<br/>public void deletePost(BlogPost blogPost) {<br/>   log.info("Only called when actually the author of the post");<br/>}</pre>
<p>This is a new, and very powerful, tool that Spring Security has given us.</p>
<div class="packt_tip"><br/>
Make sure that when you do permission checks based on data that is provided by the user, your code cannot be tricked. In this example, it is crucial that the author's name is read from the database before it is compared to the name of the user.</div>
<p>Far less common is the case where you want to authorize after the fact, possibly depending on the return values. Using the built-in <kbd>returnObject</kbd> expression, we can access the return value in the <kbd>SpEL</kbd> expression in a <kbd>@PostAuthorize</kbd> annotation.</p>
<div class="packt_infobox"><br/>
Expression-based access control can also be used with <kbd>HttpSecurity</kbd>, instead of this annotation. You really should use the<br/>
autocompletion of your favorite IDE to explore all the different ways to specify restrictions, but as a starter, this chained method is called <kbd>access()</kbd>.<br/>
We can only scratch the surface here. Please refer to the documentation on expression-based security is in <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access">https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Beyond Access – Filtering</h1>
                </header>
            
            <article>
                
<p>The <kbd>@PreFilter</kbd> and <kbd>@PostFilter</kbd> annotations enable Spring to filter the input arguments and the return value, respectively. Filtering is performed with the help of <kbd>SpEL</kbd>. Consider the following example:</p>
<pre>@PreFilter("filterObject.content.length() &lt; 240 or<br/>hasRole('ADMIN')")<br/>@PostFilter("filterObject.author.name == authentication.name")<br/>public List&lt;BlogPost&gt; saveAndReturnAll(List&lt;BlogPost&gt; posts) {<br/>   …<br/>}</pre>
<p>This method is supposed to take a list of blog posts, save them, and then return all of the blog posts, both new and old. However, the annotation has put two limits on this.</p>
<ul>
<li>Only blog posts that are shorter than 240 characters are allowed, except when you have admin privileges.</li>
<li>Only your own blog posts are returned, except for admins, who get all posts.</li>
</ul>
<p>Filtering only works over collections. The collections must be mutable. During an evaluation, the expression <kbd>filterObject</kbd> refers to the list element under scrutiny. This feature goes beyond access control, and we should carefully consider whether this part of the business logic is not in better hands within the Java code.</p>
<p class="mce-root"/>
<p>To sum this up, take a look at the following table:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e8ef128c-c4d8-4fdc-bd0e-a5c872d6e38d.png" style="width:41.50em;height:11.17em;" width="651" height="174"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing Security Aspects</h1>
                </header>
            
            <article>
                
<p>Remember the <kbd>performForRole()</kbd> method from the previous chapter? How can we make sure that the annotation will limit the access the way we want it to?</p>
<p>To test Spring Security, we need one more dependency in our POM as follows:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;<br/>   &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>As usual, the version is already pinned by Spring Boot. Now, the test is quite simple (assuming that the service that contains the method to test is called <kbd>SecuredService</kbd>):</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest<br/>public class SecuredServiceTest {<br/>   @Autowired<br/>   private SecuredService securedService;<br/><br/>   @Test<br/>   @WithMockUser<br/>   public void accessWithUserRole() {<br/>       securedService.performForRole();<br/>   }<br/>   @Test<br/>   @WithAnonymousUser<br/>   public void accessWithoutAnyRole() {<br/>       try {<br/>           securedService.performForRole();<br/>           fail();<br/>       } catch (AccessDeniedException e) {<br/>           // succeed<br/>       }<br/>   }<br/>}</pre>
<p>The only new things in the whole test are the Spring Security test annotations <kbd>@WithMockUser</kbd> and <kbd>@WithAnonymousUser</kbd>. The latter can test for unauthorized access; the former gives us a configurable user who has, by default, the name <kbd>user</kbd>, and the <kbd>USER</kbd> role.</p>
<p>For many setups, this is enough. For more involved access schemes, there are also advanced test annotations, such as <kbd>@WithUserDetails</kbd>, and even <kbd>@WithSecurityContext</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Security Context</h1>
                </header>
            
            <article>
                
<p>Sometimes, you need information about the currently logged in user, beyond just allowing or denying access. This information is stored in the security context (the class is really a <kbd>SecurityContext</kbd>). The question, now, is how to obtain this context.</p>
<p>The security context is maintained by Spring Security in a thread-local variable, by default. To access it, we call a static method on a holder object as follows:</p>
<pre>Object principal = SecurityContextHolder.getContext()<br/>            .getAuthentication().getPrincipal();<br/>String username = principal instanceof UserDetails<br/>       ? ((UserDetails) principal).getUsername()<br/>       : principal.toString();</pre>
<p>These lines try to find the name of the currently logged in user. The code may require some explanation.</p>
<ul>
<li><kbd>SecurityContextHolder.getContext()</kbd> will return the currently active security context.</li>
<li>This context really contains only one thing: the current authentication, which we retrieve with <kbd>getAuthentication()</kbd>.</li>
<li>This authentication object contains some details, such as the credentials and the granted authorities, and also the principal, which is a representation of the user.</li>
</ul>
<p>The next lines are very defensive—the principal has Object type only, as Spring Security is very flexible here. Most of the time, however, the principal is an implementation of <kbd>UserDetails</kbd>, and we can extract the username from it.</p>
<p>You can find an application of the security context in the example application in the <kbd>homePage()</kbd> method of <kbd>HomePageController</kbd>. We will take a closer look at <kbd>UserDetails</kbd> and granted authorities in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A Real User Repository</h1>
                </header>
            
            <article>
                
<p>The in-memory authentication that we have used up to this point is actually quite a workable implementation. The key point is how to initially load the users because hardcoding them as we did is insecure.</p>
<p>However, in many cases, we will want to use another implementation. All we have to do is provide an implementation of Spring Security's <kbd>UserDetailsService</kbd> interface. It is quite simple on the surface, but a bit involved to actually implant into the application. Let's take a look at an implementation that accepts all users whose names are in lowercase:</p>
<pre>@Slf4j<br/>@RequiredArgsConstructor<br/>public class LowercaseUserDetailsService<br/>        implements UserDetailsService {<br/>  private final PasswordEncoder passwordEncoder;<br/><br/>  @Override<br/>  public UserDetails loadUserByUsername(String username) {<br/>    if (username == null || username.trim().isEmpty() ||<br/>            !username.toLowerCase().equals(username)) {<br/>      log.info("Reject {}, accept only lowercase", username);<br/>      throw new UsernameNotFoundException("Accept only<br/>lowercase");<br/>    }<br/>      String password = passwordEncoder.encode("password");<br/>      log.info("Accepting {} / {}", username, password);<br/>      return new User(username, password,<br/>              singleton(new SimpleGrantedAuthority("ROLE_USER")));<br/>    }<br/>}</pre>
<p>The main thing to note is that we need to implement only one method: <kbd>loadByUsername()</kbd>. It is important to note that this routine does not actually perform the authentication, but is a DAO that looks up a user and returns the corresponding details, including the encoded password. The actual checking is done elsewhere. As noted in the corresponding JavaDoc, this method must not return null, and is expected to throw a <kbd>UsernameNotFoundException</kbd> when the user does not exist at all.</p>
<p>Spring makes no assumptions about the whereabouts of the users. In our play example, we generate users on the fly, to show that there are no restrictions at all. In the real world, we would rather query our database to populate the <kbd>UserDetails</kbd> object.</p>
<div class="packt_infobox"><br/>
The <kbd>UserDetails</kbd> object that is returned here is what we saw earlier, as the principal in the security context. If we only have one source of <kbd>UserDetails</kbd> objects, which is quite normal, then we can cast the principal to it blindly.</div>
<p>However, when we are moving through code unauthenticated, the principal is not one of our <kbd>UserDetails</kbd>. It is a string with the value <kbd>anonymousUser</kbd>. Let's skip the password line for the time being as follows:</p>
<pre>return new User(username, password,<br/>       singleton(new SimpleGrantedAuthority("ROLE_USER")));</pre>
<p>The <kbd>loadByUsername()</kbd> method is supposed to return <kbd>UserDetails</kbd>, which is an interface, and that interface needs to supply the Spring Security system with a list of <kbd>GrantedAuthority</kbd>, another interface. This is very flexible, but to help us, there are two standard implementations of these two interfaces that are adequate for many purposes: <kbd>User</kbd> and <kbd>SimpleGrantedAuthority</kbd>. We make use of these two implementations to construct a new user with the username that was given earlier and a single role for each <kbd>USER</kbd>.</p>
<div class="packt_infobox"><br/>
Yes, this is the place where you need to differentiate between roles and authorities. Authorities are a more general concept, and roles are a simple sub-case of those. An authority that is called <kbd>ROLE_USER</kbd> will be interpreted as the USER role.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Password Encoders</h1>
                </header>
            
            <article>
                
<p>Passwords must not be stored in plain text. Instead, you need to store them in your database in a non-reversible format, usually called a <strong>hash</strong>. In a normal <kbd>UserDetailsService</kbd>, we would not need to worry about this, and would just pass the hashed password from the database on to Spring Security, to check against the password that the user gave.</p>
<p>In our example, however, we need to hash the plain-text password <kbd>password</kbd> with the same hash function that Spring Security will use to check against as follows:</p>
<p><kbd>String password = passwordEncoder.encode("password");</kbd></p>
<p>We use the global password encoder that was autowired into our service to encode the password. In a more sophisticated application, a line like this would appear in a different place—right after the user entered a new password, and right before we put that into the database.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Wiring it Together</h1>
                </header>
            
            <article>
                
<p>Back in our <kbd>SecurityConfiguration</kbd> class, we will now replace the authentication manager builder configuration method with these three code snippets as follows:</p>
<pre>@Override<br/>public void configure(AuthenticationManagerBuilder auth)<br/>        throws Exception {<br/>   auth.userDetailsService(userDetailsService())<br/>       .passwordEncoder(passwordEncoder());<br/>}<br/><br/>@Bean<br/>@Override<br/>public UserDetailsService userDetailsService() {<br/>   return new LowercaseUserDetailsService(passwordEncoder());<br/>}<br/><br/>@Bean<br/>public PasswordEncoder passwordEncoder() {<br/>   return PasswordEncoderFactories.<br/>createDelegatingPasswordEncoder();<br/>}</pre>
<p>The code is now almost self-explanatory. We exchanged the in-memory authentication with our own implementation. One thing to note is that we should use a <kbd>@Bean</kbd> method to create the service, instead of annotating it with <kbd>@Service</kbd>; this is so we can override the already existing method in <kbd>WebSecurityConfigurerAdapter</kbd>.</p>
<p>We can choose from a wide range of password encoders, but the most flexible is the delegating password encoder that comes as a default. It will always use a very strong, standard algorithm to encode the password (by default, it is <kbd>BCrypt</kbd> these days), but it can check many other, older algorithms. This will be of tremendous help when you want to migrate to a new algorithm.</p>
<div class="packt_infobox"><br/>
The encoded password will have the algorithm embedded, and will look like <kbd>{bcrypt}$2a$10$2.eeR1LFYuJjicT.SyTEpEgX7mgJvH902rS</kbd>, to allow Spring Security to delegate to the appropriate password encoder. An ancient entry in your database might be <kbd>{MD5}{3A1yJJ/pQ5zMYv77050bccaccda0e573339a</kbd> and requires that the user change the password in order to migrate to <kbd>BCrypt</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real Repositories</h1>
                </header>
            
            <article>
                
<p>In real applications, where do the users come from? Very often, there is already a user database, and one easy way to follow is to have our users implement the <kbd>UserDetails</kbd> interface. In the security introduction application, this is the <kbd>Author</kbd> class.</p>
<p>Spring Security comes with two implementations of <kbd>UserDetailsService</kbd>, out of the box. These two even implement <kbd>UserDetailsManager</kbd>, to allow for creating new and changing existing users. You have already seen one of these two: <kbd>InMemoryUserDetailsManager</kbd> stores all possible users in the memory. For a limited number of users, this is efficient. To fill in the users, we may read them from a file upon startup.</p>
<p>The other implementation is <kbd>JdbcUserDetailsManager</kbd> and it comes with database access via JDBC. Database access will be handled in the next chapter, but to use this class, the only prerequisite is to create the required tables in the database. The users provided by this implementation are of the class <kbd>User</kbd>, mentioned earlier. That class contains neither the full name nor the email address, which may make it less suitable for many applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-Site Request Forgery (CSRF)</h1>
                </header>
            
            <article>
                
<p>To round off this chapter, let's briefly discuss about two important four-letter acronyms, CSRF and CORS.</p>
<p><strong>Cross-site request forgery</strong> is when a site A creates a request to a site B but lets the user think something else is happening. The stateless nature of HTTP means that site B cannot determine where the call originated from. The browser will add all of the necessary cookies to the request, so if the user is currently logged in site B, perhaps in another tab, then site A can manipulate data.</p>
<p>The key to preventing this kind of attack is to require a synchronizer token to be sent alongside all requests that manipulate data; that is, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>. This token is sent to the browser in each form, usually as a hidden field, and must be present in the request. The attacking site will not normally have access to that token.</p>
<p>CSRF protection can be disabled if you only accept calls from trusted sources. This decision should not be taken lightly.</p>
<p>What do we have to do to use this feature? Almost nothing, if we rely on forms and Spring Security's support for Thymeleaf (and also for JSPs and other templating engines). Each form that we create in a Thymeleaf template will have an additional hidden field, called <kbd>_csrf</kbd>, that will be checked upon accepting the call. If you go back to the explanation of the login form, you will see this field. A form is extended by Thymeleaf when the <kbd>th:action</kbd> attribute is used on the <kbd>&lt;form&gt;</kbd> tag.</p>
<p>If you use REST calls, you cannot pass another parameter in your JSON, and you will not have a form that gives the client to the CSRF token to begin with. In this case, we need another configuration, as follows:</p>
<pre class="mce-root">@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>  http<br/>    .csrf()<br/>      .csrfTokenRepository(<br/>              CookieCsrfTokenRepository.withHttpOnlyFalse());<br/>}</pre>
<p>Now, Spring Security will send along an <strong>XSRF-TOKEN</strong> cookie, and we can use this to send an <strong>X-XSRF-TOKEN</strong> header with the request. We will not look into this slightly advanced technique in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cross-Origin Resource Sharing (CORS)</h1>
                </header>
            
            <article>
                
<p><strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) is a way to work with today's browsers' <strong>SOP</strong> (<strong>Same-Origin Policy</strong>). Spring offers two different ways to achieve the same goal. We will not go into too much detail, but we will look at two example configurations straight from the Spring documentation.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first comes from Spring MVC support as follows:</p>
<pre>@Bean<br/>public WebMvcConfigurer corsConfigurer() {<br/>  return new WebMvcConfigurer() {<br/>    @Override<br/>    public void addCorsMappings(CorsRegistry registry) {<br/>      registry.addMapping("/greeting-javaconfig")<br/>      .allowedOrigins("http://localhost:9000");<br/>    }<br/>  };<br/>}</pre>
<p>This will relax the SOP to allow access to <kbd>/greeting-javaconfig</kbd> from <kbd>localhost:port 9000</kbd>. There is also annotation-based configuration support for this. This is the way to configure CORS when you do not have Spring Security.</p>
<p>If, however, you have Spring Security, then security and CORS must work hand in hand, and it is necessary to extend the security configuration, as follows:</p>
<pre>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>    http.cors() …<br/>}</pre>
<p>Now, if Spring MVC is on the <kbd>classpath</kbd> and no <kbd>CorsConfigurationSource</kbd> is provided, Spring Security will use the CORS configuration provided to Spring MVC, as defined previously. Instead, you can decide to configure CORS using the code as follows:</p>
<pre>@Bean<br/>CorsConfigurationSource corsConfigurationSource() {<br/>  CorsConfiguration configuration = new CorsConfiguration();<br/>  configuration.setAllowedOrigins(<br/>          Arrays.asList("http://localhost:9000"));<br/>  configuration.setAllowedMethods(<br/>          Arrays.asList("GET","POST"));<br/>  UrlBasedCorsConfigurationSource source =<br/>          new UrlBasedCorsConfigurationSource();<br/>  source.registerCorsConfiguration("/**", configuration);<br/>  return source;<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Exploring Security Annotations</h1>
                </header>
            
            <article>
                
<p><strong>Prerequisites</strong></p>
<p>Load and start the security introduction application from the source archive. It is a short message service that sports some features that may be a little far-fetched, but which make it easier to demonstrate some of the features of Spring Security without the overhead of a real application. You can view<span> </span><kbd>all</kbd><span> </span>pages even as an anonymous user.</p>
<p><strong>Aim</strong></p>
<p>To explore the effects of security<span> </span>annotations<span> </span>on the methods.</p>
<p><strong>Scenario</strong></p>
<p>You have a web app that has web security configured. However, you do not want to rely only on URLs but directly secure the code with annotations.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Navigate to the HomePageController to find the <kbd>homePage()</kbd> method and add an annotation to limit access to users who have the role <kbd>USER</kbd>.</li>
<li>Restart the application and open the page in the browser.</li>
</ol>
<div class="packt_infobox"><br/>
Note that we are immediately redirected to the login page. Log in with any of the predefined users; for instance, <kbd>peter/quinn</kbd> or <kbd>cate/sakai</kbd>.</div>
<ol start="3">
<li>Note that the index page changed to reflect your user:<br/>
Take a look at the following screenshots showing the name and role assigned:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/4bfb69ac-cb90-47ec-ac1a-77c9bdcab48e.png" style="width:14.67em;height:9.17em;" width="213" height="133"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><img src="Images/9c664049-c38a-42dd-83d4-738ca706ae88.png" style="width:30.75em;height:17.83em;" width="635" height="369"/></div>
<ol start="4">
<li>Try to log out.</li>
<li>Find the <kbd>ShortMessageService</kbd> and its <kbd>findAll()</kbd> method. Add an annotation that limits the display to the articles.</li>
<li>Restart the application and open the page in the browser.</li>
</ol>
<p><strong>Outcome</strong></p>
<p>After logging in, you will only see your own articles. Remove the <kbd>@RolesAllowed</kbd> annotation from <em>step 1</em> again, and restart. You will then be able to view your own articles.</p>
<div class="packt_infobox"><br/>
You can now see the full annotation in action: when logged out (in Spring Security, this is called an anonymous authentication), you can see all of the articles, but when logged in, you can only see your own. (Admittedly, it's not the most straightforward behavior.)<br/>
Did you notice how annotating the mapping function had the same effect as our previous configurations on the <kbd>HttpSecurity</kbd> object? You can even try to lock down the path there, instead of using the annotation. (It is already in the code, commented out.) Go to <a href="https://bit.ly/2x8Fyoa">https://bit.ly/2x8Fyoa</a> to access the complete code for the <kbd>HomePageController.java</kbd> file.<br/>
<span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of this book on page 261.<br/>
<br/></span></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we took a look at many aspects of security, particularly those that you, as a software developer, should have on your agenda. The Spring Security project offers a tight integration in both the Spring MVC part, which allows you to lock down URLs and Spring Beans, which limits access to certain methods. You learned how to wire the different pieces together; how to configure authentication (for instance in a form) load users into the system (including their access permissions and their passwords); and how to give them access to parts of the system.</p>
<p class="mce-root">Our blogmania app now limits writing new articles to only known users. However, the blog posts are still in the memory only. We need a way to persist them, and so we will turn our attention towards databases in the next (and final) chapter in this book.</p>


            </article>

            
        </section>
    </div>



  </body></html>