<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging the JEE Application</h1>
                
            
            <article>
                
<p class="calibre3">In the previous chapter, we learned how to write and run unit tests for Java applications using Eclipse and JUnit. In this chapter, we are going to learn how to use Eclipse to debug JEE applications. Debugging is an unavoidable part of application development. Unless the application is very simple, the chances are that it is not going to work as expected on the very first attempt and you will spend some time trying to find out the reasons why. In very complex applications, application developers may end up spending more time debugging than writing application code. Problems may not necessarily exist in your code, but may exist in the external system that your application depends on. Debugging a complex piece of software requires skill, which can be developed with experience. However, it also needs good support from the application runtime and IDE.</p>
<p class="calibre3">There are different ways to debug an application. You may just put <kbd class="calibre13">System.out.println()</kbd> statements in your code and print values of the variables, or just a message stating that execution of the application has reached a certain point. If the application is small or simple, this may work, but this may not be a good idea when debugging large and complex applications. You also need to remember to remove such debug statements before moving the code to staging or production. If you have written unit tests and if some of the unit tests fail, then that may give you some idea about the problems in your code. However, in many cases, you may want to monitor the execution of code at line level or function level and check the values of the variables at that line or in that function. This requires support from the language runtime and a good IDE that helps you visualize and control the debugging process. Fortunately, Java has an excellent debugger, and Eclipse JEE provides great support for debugging Java code.</p>
<p class="calibre3">In this chapter, we are going to learn how to debug JEE applications using Eclipse JEE. We will use the same <em class="calibre21">Course Management</em> application that we built in <a href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, for debugging. The debugging technique described in this chapter can be applied to remotely debug any Java application, and is not necessarily restricted to the JEE applications.</p>
<p class="calibre3">In this chapter, we are going to cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Setting up Eclipse to debug JEE applications remotely</li>
<li class="calibre11">Understanding how to perform different different debugging actions, such as setting breakpoints, inspecting variables and expressions, and stepping through the code</li>
<li class="calibre11">Connecting the debugger from Eclipse to an externally running JEE application server</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging a remote Java application</h1>
                
            
            <article>
                
<p class="calibre3">You may have debugged standalone Java applications from Eclipse. You set breakpoints in the code, run the application in the <span class="calibre12">Debug</span> mode from Eclipse, and then debug the application by stepping through the code. Debugging remote Java applications is a bit different, particularly when it comes to how you launch the debugger. In the case of local application, the debugger launches the application. In the case of remote application, it is already launched and you need to connect the debugger to it. In general, if you want to allow remote debugging for the application, you need to run the application using the following parameters:</p>
<pre class="calibre25"><strong class="calibre1">-Xdebug -Xrunjdwp:transport=dt_socket,address=9001,server=y,suspend=n</strong>
  </pre>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">Xdebug</kbd> enables debugging</li>
<li class="calibre11"><kbd class="calibre13">Xrunjdwp</kbd> runs the debugger implementation of the <strong class="calibre1">Java Debug Wire Protocol</strong> (<strong class="calibre1">JDWP</strong>)</li>
</ul>
<p class="calibre3">Instead of <kbd class="calibre13">-Xdebug -Xrunjdwp</kbd>, you can also use <kbd class="calibre13">-agentlib:jdwp</kbd> for JDK 1.5 and above, for example:</p>
<pre class="calibre25"> <strong class="calibre1">-agentlib:jdwp=transport= dt_socket,address=9001,server=y,suspend=n</strong></pre>
<p class="calibre3">Let's understand the parameters used here in detail:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">transport=dt_socket</kbd>: This starts a socket server at <kbd class="calibre13">address=9001</kbd> (this can be any free port) to receive debugger commands and send responses.</li>
<li class="calibre11"><kbd class="calibre13">server=y</kbd>: This tells the JVM if the application is a server or a client, in the context of debugger communication. Use the <kbd class="calibre13">y</kbd> value for remote applications.</li>
<li class="calibre11"><kbd class="calibre13">suspend=n</kbd>: This tells the JVM to not wait for the debugger client to attach to it. If the value is <kbd class="calibre13">y</kbd>, then the JVM will wait before executing the main class until a debugger client attaches to it. Setting the <kbd class="calibre13">y</kbd> value for this option may be useful in cases where you want to debug, for example, the initialization code of servlets that are loaded upon startup of the web container. In such cases, if you do not choose to suspend the application till the debugger connects to it, the code that you want to debug may get executed before the debugger client attaches to it.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging a web application using Tomcat in Eclipse EE</h1>
                
            
            <article>
                
<p class="calibre3">We have already learned how to configure Tomcat in Eclipse EE and deploy web applications in it from Eclipse (refer to the <em class="calibre21">Configuring Tomcat in Eclipse</em> and <em class="calibre21">Running JSP in Tomcat</em> sections in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>). We will use the <em class="calibre21">Course Management</em> application that we created in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em> (JDBC version), for debugging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting Tomcat in Debug mode</h1>
                
            
            <article>
                
<p class="calibre3">If you want to debug a remote Java process, you need to start the process using debug parameters. However, if you have configured Tomcat in Eclipse EE, you don't need to do this manually. Eclipse takes care of launching Tomcat in <span class="calibre12">Debug</span> mode. To start Tomcat in <span class="calibre12">Debug</span> mode, select the server in the <span class="calibre12">Servers</span> view and click the <span class="calibre12">Debug</span> button. Alternatively, right-click on the server and select <span class="calibre12">Debug</span> from the menu. Make sure that the project you want to debug is already added to Tomcat; in this case, the project is <kbd class="calibre13">CourseManagementJDBC</kbd>:</p>
<div class="mce-root1"><img src="../images/00137.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 6.1: Starting Tomcat in Debug mode</div>
<p class="calibre3">Once Tomcat is started in <span class="calibre12">Debug</span> mode, its status changes to <span class="calibre12">Debugging</span>:</p>
<div class="mce-root1"><img src="../images/00138.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 6.2: Tomcat running in Debug mode</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting breakpoints</h1>
                
            
            <article>
                
<p class="calibre3">Now, let's set breakpoints in the code before we launch the <kbd class="calibre13">CourseManagement</kbd> application. Open <kbd class="calibre13">CourseDAO</kbd> from the <kbd class="calibre13">CourseManagementJDBC</kbd> project and double-click in the left margin of the first line in the <kbd class="calibre13">getCourses</kbd> method:</p>
<div class="mce-root1"><img src="../images/00139.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 6.3: Setting a breakpoint</div>
<p class="calibre3">Another way to set a breakpoint at a line is to right-click in the left margin and select <span class="calibre12">Toggle Breakpoint</span>:</p>
<div class="mce-root1"><img src="../images/00140.jpeg" class="calibre148"/></div>
<div class="packt_figure1">Figure 6.4: Toggling breakpoints using the menu</div>
<p class="calibre3">You can also set breakpoints at the method level. Just place the caret inside any method, and select the <span class="calibre12">Run</span> | <span class="calibre12">Toggle Method Breakpoint</span> menu. This is equivalent to setting the breakpoint at the first line of the method. This is preferred over setting a breakpoint at the first line of the method when you always want to stop at the beginning of the method. The debugger will always stop at the first statement in the method, even if you later insert code at the beginning of the method.</p>
<p class="calibre3">Another useful breakpoint option is to set it when any exception occurs during program execution. Often, you may not want to set a breakpoint at a specific location, but may want to investigate why an exception is happening. If you do not have access to the stack trace of the exception, you can just set a breakpoint for the exception and run the program again. Next time, the execution will stop at the code location where the exception occurred. This makes it easy to debug exceptions. To set a breakpoint for an exception, select <span class="calibre12">Run</span> | <span class="calibre12">Add Java Exception Breakpoint...</span> and select the <kbd class="calibre13">Exception</kbd> class from the list:</p>
<div class="mce-root1"><img src="../images/00141.jpeg" class="calibre149"/></div>
<div class="packt_figure1">Figure 6.5: Setting a breakpoint at an exception</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running the application in Debug mode</h1>
                
            
            <article>
                
<p class="calibre3">Now, let's run the <kbd class="calibre13">listCourse.jsp</kbd> page in <span class="calibre12">Debug</span> mode:</p>
<ol class="calibre14">
<li value="1" class="calibre11">In <span>Project Navigator</span>, go to <kbd class="calibre13">src/main/webapp/listCourse.jsp</kbd> and right-click on the file. Select <span>Debug As</span> | <span>Debug on Server</span>. Eclipse may prompt you to use the existing debug server:</li>
</ol>
<div class="mce-root1"><img src="../images/00142.jpeg" class="calibre150"/></div>
<div class="packt_figure1">Figure 6.6: Choosing an existing debug server</div>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Click <span>Finish</span>. Eclipse will ask you if you want to switch to the <span>Debug</span> perspective (refer to <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre2">Introducing JEE and Eclipse</em>, for a discussion on Eclipse perspectives):</li>
</ol>
<div class="mce-root1"><img src="../images/00143.jpeg" class="calibre151"/></div>
<div class="packt_figure1">Figure 6.7: Auto-switching to the Debug perspective</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Select the <span>Remember my decision</span> option and click the <span>Yes</span> button. Eclipse will switch to the <span>Debug</span> perspective. Eclipse will try to open the page in the internal Eclipse browser, but it won't display the page immediately. Recall that <kbd class="calibre13">listCourse.jsp</kbd> calls <kbd class="calibre13">Course.getCourses()</kbd>, which in turn calls <kbd class="calibre13">CourseDAO.getCourses()</kbd>. We have set a breakpoint in the <kbd class="calibre13">CourseDAO.getCourses()</kbd> method, so the execution of the page stops there:</li>
</ol>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00144.jpeg" class="calibre152"/></div>
<div class="packt_figure1">Figure 6.8: The debugger paused at a breakpoint</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Performing step operations and inspecting variables</h1>
                
            
            <article>
                
<p class="calibre3">You can now perform different step operations (step over, step in, and step out) using the toolbar icons at the top, or using keyboard shortcuts. Open the drop-down on the <span class="calibre12">Run</span> menu to learn about the menu and toolbar shortcuts for debugging. Typically, you would inspect variables or perform step operations to verify whether the execution flow is correct and then continue the execution by clicking the <span class="calibre12">Resume</span> button or by using the menu/keyboard shortcut.</p>
<p class="calibre3">In the <span class="calibre12">Debug</span> tab (refer to <em class="calibre21">Figure 6.8</em>), you can see all the threads and inspect the stack frames of each thread when the debugger is suspended. Stack frames of a thread show you the path of a program execution in that thread until the point that the debugger was suspended after hitting a breakpoint or due to step operations. In a multithreaded application, such as a Tomcat web container, more than one thread might have been suspended at a time and each might have different stack frames. When debugging a multithreaded application, make sure that you have selected the required thread in the <span class="calibre12">Debug</span> tab before selecting options to step over/in/out or resume.</p>
<p class="calibre3">Often, you step into a method and realize that the values are not what you expect and you want to rerun statements in the current method to investigate them. In such cases, you can drop to any previous stack frame and start over.</p>
<p class="calibre3">For example, let's say that in the preceding example we step into the <kbd class="calibre13">DatabaseConnectionFactory.getConnectionFactory().getConnection</kbd> method. When we step in, the debugger first steps into the <kbd class="calibre13">getConnectionFactory</kbd> method, and in the next step-in operation, it steps into the <kbd class="calibre13">getConnection</kbd> method. Suppose, when we are in the <kbd class="calibre13">getConnection</kbd> method that we want to go back and check what happened in the <kbd class="calibre13">getConnectionFactory</kbd> method for something that we might have missed earlier (although in this simple example, not much happens in the <kbd class="calibre13">getConnectionFactory</kbd> method; it should just serve as an example). We can go back to the <kbd class="calibre13">getCourses</kbd> method and start over the execution of <kbd class="calibre13">getConnectionFactory</kbd> and <kbd class="calibre13">getConnection</kbd>. In the <span class="calibre12">Debug</span> tab, right-click on the <kbd class="calibre13">CourseDAO.getCourses()</kbd> stack frame and select <span class="calibre12">Drop to Frame</span>, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00145.jpeg" class="calibre153"/></div>
<div class="packt_figure1">Figure 6.9 Drop to Frame</div>
<p class="calibre3">The debugger discards all the stack frames above the selected frame, and the execution drops back to the selected frame; in this case, in the <kbd class="calibre13">getCourses</kbd> method of the <kbd class="calibre13">CourseDAO</kbd> class. You can then step over again into the <kbd class="calibre13">getConnection</kbd> method. Note that only stack variables and their values are discarded when you drop to frame. Any changes made to reference objects that are not on the stack are not rolled back.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inspecting variable values</h1>
                
            
            <article>
                
<p class="calibre3">Now let's step over a few statements till we are in the <kbd class="calibre13">while</kbd> loop to create course objects from the data returned by the result set. In the top-right window, you will find the <span class="calibre12">Variables</span> view, which displays variables applicable at that point of execution:</p>
<div class="mce-root1"><img src="../images/00146.jpeg" class="calibre154"/></div>
<div class="packt_figure1">Figure 6.10: The debugger paused at breakpoint</div>
<p class="calibre3">You can inspect variables in the previous method calls too by changing the selection in the <span class="calibre12">Debug</span> tab: click on any previous method call (stack frame) and the <span class="calibre12">Variables</span> view will display variables that are valid for the selected method. You can change the value of any variable, including values of the member variables of the objects. For example, in <em class="calibre21">Figure 6.8, </em>we can change the value of the course name from <kbd class="calibre13">"Machine Learning"</kbd> to <kbd class="calibre13">"Machine Learning - Part1"</kbd>. To change the variable value, right-click on the variable in the <span class="calibre12">Variables</span> view and select <span class="calibre12">Change Value</span>:</p>
<div class="mce-root1"><img src="../images/00147.jpeg" class="calibre155"/></div>
<div class="packt_figure1">Figure 6.11: Changing the variable's value during debugging</div>
<p class="calibre3">You don't have to go to the <span class="calibre12">Variables</span> view to check a variable's value every time. There is a quick way: just hover the cursor over the variable in the editor and Eclipse will pop up a window showing the variable's value:</p>
<div class="mce-root1"><img src="../images/00148.jpeg" class="calibre156"/></div>
<div class="packt_figure1">Figure 6.12: Inspecting the variable</div>
<p class="calibre3">You can also right-click on a variable and select the <span class="calibre12">Inspect</span> option to see the variable's values. However, you cannot change the value when you select the <span class="calibre12">Inspect</span> option.</p>
<p class="calibre3">If you want to see the value of a variable frequently (for example, a variable in a loop), you can add the variable to the watchlist. It is a more convenient option than trying to search for the variable in the <span class="calibre12">Variables</span> view. Right-click on a variable and select the <span class="calibre12">Watch</span> option from the menu. The <span class="calibre12">Watch</span> option adds the variable to the <span class="calibre12">Expressions</span> view (its default location is next to the <span class="calibre12">Breakpoints</span> view at the top right) and displays its value:</p>
<div class="mce-root1"><img src="../images/00149.jpeg" class="calibre157"/></div>
<div class="packt_figure1">Figure 6.13: Inspecting a variable</div>
<p class="calibre3">The use of the <span class="calibre12">Expressions</span> view is not limited to watching variable values. You can watch any valid Java expression, such as arithmetic expressions, or even method calls. Click on the plus icon in the <span class="calibre12">Expressions</span> view and add an expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging an application in an externally configured Tomcat</h1>
                
            
            <article>
                
<p class="calibre3">Thus far, we have debugged our application using Tomcat configured within Eclipse. When we launched Tomcat in <span class="calibre12">Debug</span> mode, Eclipse took care of adding the JVM parameters for debugging to the Tomcat launch script. In this section, we will see how to launch an external (to Eclipse) Tomcat instance and connect to it from Eclipse. Although we are going to debug a remote instance of Tomcat, information in this section can be used for connecting to any remotely running Java program that is launched in <span class="calibre12">Debug</span> mode. We have already seen the debug parameters to pass when launching a remote application in <span class="calibre12">Debug</span> mode.</p>
<p class="calibre3">Launching Tomcat externally in <span class="calibre12">Debug</span> mode is not too difficult. Tomcat startup scripts already have an option to start the server in <span class="calibre12">Debug</span> mode; you just need to pass the appropriate parameters. From the Command Prompt, select the <kbd class="calibre13">&lt;TOMCAT_HOME&gt;/bin</kbd> folder and type the following command in Windows:</p>
<pre class="calibre25"><strong class="calibre1">&gt;catalina.bat jpda start</strong> </pre>
<p class="calibre3">Launching Tomcat in <span class="calibre12">Debug</span> mode in Mac OSX and Linux:</p>
<pre class="calibre25"><strong class="calibre1">$./catalina.sh jpda start</strong>  </pre>
<p class="calibre3">Passing the <kbd class="calibre13">jpda</kbd> argument sets the default values to all the required debug parameters. The default debug port is 8000. If you want to change it, either modify <kbd class="calibre13">catalin.bat/catalin.sh</kbd> or set the environment variable <kbd class="calibre13">JPDA_ADDRESS</kbd> as follows:</p>
<p class="calibre3">Setting <kbd class="calibre13">JPDA_ADDRESS</kbd> environment variable in Windows:</p>
<pre class="calibre25"><strong class="calibre1">&gt;set JPDA_ADDRESS=9001</strong>  </pre>
<p class="calibre3">Setting <kbd class="calibre13">JPDA_ADDRESS</kbd> environment variable in OSX and Linux:</p>
<pre class="calibre25"><strong class="calibre1">$export JPDA_ADDRESS=9001</strong>  </pre>
<p class="calibre3">Similarly, you can set <kbd class="calibre13">JPDA_SUSPEND</kbd> to <kbd class="calibre13">y</kbd> or <kbd class="calibre13">n</kbd> to control whether the debugger should wait for the client to connect before executing the <kbd class="calibre13">main</kbd> class.</p>
<p class="calibre3">To connect the debugger from Eclipse to a remote instance, select the <span class="calibre12">Run</span> | <span class="calibre12">Debug Configurations...</span> menu. Right-click on the <span class="calibre12">Remote Java Application</span> node in the list view on the left and select <span class="calibre12">New</span>:</p>
<div class="mce-root1"><img src="../images/00150.jpeg" class="calibre158"/></div>
<div class="packt_figure1">Figure 6.14: Inspecting a variable</div>
<p class="calibre3">Set the appropriate <span class="calibre12">Project</span> and <span class="calibre12">Port</span> (the same as what you selected to start Tomcat in <span class="calibre12">Debug</span> mode, that is, the default: <kbd class="calibre13">8000</kbd>) and click <span class="calibre12">Debug</span>. If the debugger connection is successful, Eclipse will switch to the debug perspective. From here on out, the process of debugging is the same as that explained earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the debugger to know the status of program execution</h1>
                
            
            <article>
                
<p class="calibre3">We have seen how to use the debugger to verify the execution flow of a program (using the step operations) and to inspect variables. You can also use the debugger to know what the status of the running program is. For example, a web request is taking too long and you want to know where exactly the execution is stuck. You can use the debugger to find this. It is similar to taking the thread dump of a running program, but is much easier than the methods used to get the thread dump. Let's assume that our <kbd class="calibre13">CourseDAO.getCourses</kbd> method is taking a long time to execute. Let's simulate this by using a couple of <kbd class="calibre13">Thread.sleep</kbd> calls, as shown in the following code snippet:</p>
<pre class="calibre25">public List&lt;Course&gt; getCourses () throws SQLException { 
  //get connection from connection pool 
  Connection con = <br class="title-page-name"/> DatabaseConnectionFactory.getConnectionFactory().getConnection(); 
 
  try { 
    Thread.sleep(5000); 
  } catch (InterruptedException e) {} 
 
 
  List&lt;Course&gt; courses = new ArrayList&lt;Course&gt;(); 
  Statement stmt = null; 
  ResultSet rs = null; 
  try { 
    stmt = con.createStatement(); 
 
    StringBuilder sb = new StringBuilder("select course.id as <br class="title-page-name"/>     courseId, course.name as courseName,")      .append("course.credits as credits, Teacher.id as teacherId, <br class="title-page-name"/>       Teacher.first_name as firstName, ")      .append("Teacher.last_name as lastName, Teacher.designation <br class="title-page-name"/>       designation ") 
      .append("from Course left outer join Teacher on ") 
      .append("course.Teacher_id = Teacher.id ") 
      .append("order by course.name"); 
 
    rs = stmt.executeQuery(sb.toString()); 
 
    while (rs.next()) { 
      Course course = new Course(); 
      course.setId(rs.getInt("courseId")); 
      course.setName(rs.getString("courseName")); 
      course.setCredits(rs.getInt("credits")); 
      courses.add(course); 
 
      int teacherId = rs.getInt("teacherId"); 
      if (rs.wasNull()) //no teacher set for this course. 
        continue; 
      Teacher teacher = new Teacher(); 
      teacher.setId(teacherId); 
      teacher.setFirstName(rs.getString("firstName")); 
      teacher.setLastName(rs.getString("lastName")); 
      teacher.setDesignation(rs.getString("designation")); 
      course.setTeacher(teacher); 
    } 
 
    try { 
      Thread.sleep(5000); 
    } catch (InterruptedException e) {} 
 
 
    return courses; 
  } finally { 
    try {if (rs != null) rs.close();} catch (SQLException e) {} 
    try {if (stmt != null) stmt.close();} catch (SQLException e) <br class="title-page-name"/> {} 
    try {con.close();} catch (SQLException e) {} 
  } 
} </pre>
<p class="calibre3">Start Tomcat in <span class="calibre12">Debug</span> mode, and run <kbd class="calibre13">listCourses.jsp</kbd> in <span class="calibre12">Debug</span> mode. Because we have inserted <kbd class="calibre13">Thread.sleep</kbd> statements, the request will take time. Go to the <span class="calibre12">Debug</span> view, which is where threads and stack frames are displayed. Click on the first node under the Tomcat debug configuration node and select the <span class="calibre12">Suspend</span> option, as shown in the following screenshot: </p>
<div class="mce-root1"><img src="../images/00151.jpeg" class="calibre159"/></div>
<div class="packt_figure1">Figure 6.15: Suspending program execution</div>
<p class="calibre3">The debugger pauses execution of all threads in the program. You can then see the status of each thread by expanding the thread nodes. You will find one of the threads executing the <kbd class="calibre13">CourseDAO.getCourse</kbd> method and the statement that it was executing before being suspended:</p>
<div class="mce-root1"><img src="../images/00152.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 6.16: The status of suspended threads</div>
<p class="calibre3">From the preceding screenshot, you can see that the execution of the thread is suspended in the <kbd class="calibre13">CourseDAO.getCourses</kbd> method of the <kbd class="calibre13">Thread.sleep</kbd> statement. You can even inspect variables at each stack frame when the program is suspended. By suspending the program and inspecting the state of threads and stack frames, you may be able to find bottlenecks in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">Good support for debugging from language runtime and IDE can considerably reduce the time spent in debugging. Java runtime and Eclipse provide excellent support for debugging local and remote applications. To debug a remote application, launch it with debug parameters for JVM and connect the Eclipse debugger to it. You can then debug the remote application just as you would debug the local one, that is, set breakpoints, perform step operations, and inspect variables. You can also change variable values in the application when its execution is suspended.</p>
<p class="calibre3">In the next chapter, we will see how to develop JEE applications using EJBs and use the GlassFish server. Although this chapter explained the debugging of JEE applications deployed in Tomcat, you can use the same techniques in the GlassFish server.</p>


            </article>

            
        </section>
    </body></html>