<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.2.1">Wrapping Business Rules inside Domain Hexagon</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about the Domain as the first hexagon in hexagonal architecture. </span><span class="koboSpan" id="kobo.3.2">By being the innermost hexagon, the Domain does not depend on any code from the Application and Framework hexagons. </span><span class="koboSpan" id="kobo.3.3">Also, we make all the other hexagons depend on the Domain to conduct their operations. </span><span class="koboSpan" id="kobo.3.4">This kind of arrangement confers the Domain hexagon a degree of responsibility and relevance far higher than other hexagons. </span><span class="koboSpan" id="kobo.3.5">We employ such an arrangement because it is in the Domain where we group all the business rules and data that most represent the problem we try </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Among the techniques to model a problem domain, </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">DDD</span></strong><span class="koboSpan" id="kobo.9.1">) is widely adopted</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.10.1"> in projects that emphasize software code as a medium to convey knowledge about a business. </span><span class="koboSpan" id="kobo.10.2">An ever-present concern to separate what constitutes the core problem domain and what is secondary to it makes DDD a suitable approach to support the hexagonal architecture goal of separating technology code from </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">business code.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">The principles and techniques we will see in this chapter will serve as the basis to build the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">Modeling a problem domain </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">with entities</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Enhancing descriptiveness with </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">value objects</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Assuring consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">with aggregates</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Working with </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">domain services</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Using policy and specification patterns to deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">business rules</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Defining business rules as </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Plain Old Java </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.28.1">Objects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.30.1">POJOs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">By the end of this chapter, you will have learned the building blocks of DDD and will be able to apply the presented concepts in the development of </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">hexagonal applications.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Java Standard Edition</span></strong><span class="koboSpan" id="kobo.37.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.38.1">SE</span></strong><span class="koboSpan" id="kobo.39.1">) development kit and </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.41.1"> installed on your computer. </span><span class="koboSpan" id="kobo.41.2">They are all available for the Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02"><span class="No-Break"><span class="koboSpan" id="kobo.45.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.47.1">Modeling a problem domain with entities</span></h1>
<p><span class="koboSpan" id="kobo.48.1">In DDD, before </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.49.1">any code is written, there must be lots of discussions between developers and domain experts—the people who have a deep understanding of their business, which may include other developers as well. </span><span class="koboSpan" id="kobo.49.2">Those discussions provide valuable information, acquired through a process called knowledge crunching, which is based on brainstorming between those developers and domain experts. </span><span class="koboSpan" id="kobo.49.3">That knowledge is then incorporated into</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.50.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">ubiquitous language</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">This language works as the </span><em class="italic"><span class="koboSpan" id="kobo.53.1">lingua franca</span></em><span class="koboSpan" id="kobo.54.1"> among everyone involved in the project and is present in documentation, day-to-day conversations, and – of course – </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">in code.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">When we deal with entities, we must always pay attention to how much we can learn about a business by just reading code. </span><span class="koboSpan" id="kobo.56.2">Even though just reading code may not be enough. </span><span class="koboSpan" id="kobo.56.3">That’s when techniques such as knowledge-crunching, where we speak with domain experts to learn more about a business, are instrumental in helping us continuously evolve the ubiquitous language and translate the business knowledge into working code. </span><span class="koboSpan" id="kobo.56.4">That’s the basis for rich entities that really capture relevant behaviors and are more than mere </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">data objects.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">For an entity to be considered an entity, it must have an identity; so, we’ll see how to assign identity in a way that is aligned with the hexagonal architecture goal to separate concerns between business and </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">technology code.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.60.1">The purity of domain entities</span></h2>
<p><span class="koboSpan" id="kobo.61.1">When we model a </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.62.1">problem domain, the main focus is to capture, as precisely as possible, a real-life scenario in code. </span><span class="koboSpan" id="kobo.62.2">That scenario is often composed of several processes working together to support an organization’s goals to meet customer expectations. </span><span class="koboSpan" id="kobo.62.3">This ability to fulfill customer needs will ultimately determine the organization’s capacity to generate profit. </span><span class="koboSpan" id="kobo.62.4">So, the problem-domain modeling effort is crucial to determine the overall success of any organization that relies on its software to make money. </span><span class="koboSpan" id="kobo.62.5">A failure to understand and translate business requirements into code will obviously result in not satisfied </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">customer expectations.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Central to that </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.65.1">problem-domain modeling effort is the creation of entities. </span><span class="koboSpan" id="kobo.65.2">Due to the proximity entities have to business requirements, we should strive to shield these entities from technical requirements. </span><span class="koboSpan" id="kobo.65.3">We do this to prevent the blurring of business-related code with technology-related code. </span><span class="koboSpan" id="kobo.65.4">By technology, I mean those things that exist and make sense only in the context </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">of software.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Those same technology concerns would not make sense if we were only considering the business requirements without the software. </span><span class="koboSpan" id="kobo.67.2">We also have to recognize that a problem domain may not always refer to pure business requirements. </span><span class="koboSpan" id="kobo.67.3">A problem domain may be purely technological, such as creating a new development framework. </span><span class="koboSpan" id="kobo.67.4">I don’t think hexagonal architecture is the best approach in those scenarios because its emphasis is on projects trying to solve conventional </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">business problems.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Domain entities should be pure in the sense that they deal only with business concerns. </span><span class="koboSpan" id="kobo.69.2">For technology-specific things, we have the option to utilize ports, use cases, and adapters, as we’ll see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">following chapters.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.71.1">Relevant entities</span></h2>
<p><span class="koboSpan" id="kobo.72.1">A relevant entity is </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.73.1">characterized by the presence of two elements – business rules and business data. </span><span class="koboSpan" id="kobo.73.2">It is not unusual to see entity classes modeled almost like database entity objects that express only the data part and forget the business rules represented through the behaviors provided by the entity class methods. </span><span class="koboSpan" id="kobo.73.3">These business rules may end up in parts of code other than the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">This kind of leak, where the business rules end up outside the Domain hexagon, can be harmful because it may make it difficult to understand what the domain entity does. </span><span class="koboSpan" id="kobo.75.2">That happens when business rules are defined outside the Domain hexagon and depend, for example, on code that handles database entities, which are not part of the domain model but are a technical detail supporting the domain model. </span><span class="koboSpan" id="kobo.75.3">That phenomenon is prevalent in what is called an </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">anemic domain model</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">The</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.78.1"> entity objects coming from anemic domain models generally have data but lack behavior. </span><span class="koboSpan" id="kobo.78.2">By not coupling data with behavior, the anemic domain model goes against the </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.79.1">very essence of </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Object-Oriented Programming</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">OOP</span></strong><span class="koboSpan" id="kobo.83.1">). </span><span class="koboSpan" id="kobo.83.2">When behavior is not present in domain objects, we have to go somewhere else to fully grasp what the entity is supposed to do, thus generating a mental overload that can quickly become an onerous burden as a code </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">base grows.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Conversely, we should not overload entity classes with logic that is not intrinsic to the entity we try to model. </span><span class="koboSpan" id="kobo.85.2">That’s not a trivial thing to do because, at first, we may think an operation is a part of the entity, only to discover later on that </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">it’s not.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">For things considered not intrinsic to entity behavior, we have the option to use a domain service. </span><span class="koboSpan" id="kobo.87.2">With services, we can accommodate those operations that don’t fit smoothly into an </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">entity class.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">In the previous</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.90.1"> chapter, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.92.1"> method to filter and list routers in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Router</span></strong><span class="koboSpan" id="kobo.94.1"> class, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
public static List</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.97.1">&lt;Router&gt; retrieveRouter(List&lt;Router&gt;
  routers, Predicate&lt;Router&gt; predicate){
     return routers.stream()
        .filter(predicate)
        .collect(Collectors.&lt;Router&gt;toList());
}</span></pre> <p><em class="italic"><span class="koboSpan" id="kobo.98.1">Could we consider this list router’s behavior an intrinsic characteristic of routers in the real world?</span></em><span class="koboSpan" id="kobo.99.1"> If our problem domain says the opposite, then we should remove this behavior from the entity class. </span><em class="italic"><span class="koboSpan" id="kobo.100.1">And what about the constraints that we use to check the router type before we add a router to the list?</span></em><span class="koboSpan" id="kobo.101.1"> If we consider this verification a router-intrinsic behavior, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.103.1">Embed this constraint directly in the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">entity class</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">Create a specification to assert </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">the constraint</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.107.1">Specifications are a subject we will cover later in this chapter, but for now, you can see specifications as predicate mechanisms to ensure we work with the correct objects. </span><span class="koboSpan" id="kobo.107.2">The following code snippet provides an example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Router</span></strong><span class="koboSpan" id="kobo.109.1"> entity class with the router type-check constraints embedded directly </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">in it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.111.1">
public class Router {
/** Code omitted **/
     public static Predicate&lt;Router&gt; filterRouterByType
       (RouterType routerType){
          return routerType.equals(RouterType.CORE)
                ? </span><span class="koboSpan" id="kobo.111.2">Router.isCore() :
                Router.isEdge();
     }
     private static Predicate&lt;Router&gt; isCore(){
          return p -&gt; p.getRouterType() == RouterType.CORE;
     }
     private static Predicate&lt;Router&gt; isEdge(){
          return p -&gt; p.getRouterType() == RouterType.EDGE;
     }
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.112.1">To</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.113.1"> accommodate the domain service method, we need first to create a domain service class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">RouterSearch</span></strong><span class="koboSpan" id="kobo.115.1"> and move to it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.117.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Router</span></strong><span class="koboSpan" id="kobo.119.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
public class RouterSearch {
    public static List&lt;Router&gt; retrieveRouter(List&lt;Router&gt;
      routers, Predicate&lt;Router&gt; predicate){
          return routers.stream()
                .filter(predicate)
                .collect(Collectors.&lt;Router&gt;toList());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.122.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">isCore</span></strong><span class="koboSpan" id="kobo.124.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">isEdge</span></strong><span class="koboSpan" id="kobo.126.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">filterRouterByType</span></strong><span class="koboSpan" id="kobo.128.1"> constraint methods continue to exist in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Router</span></strong><span class="koboSpan" id="kobo.130.1"> entity class. </span><span class="koboSpan" id="kobo.130.2">We only moved the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.132.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">Router</span></strong><span class="koboSpan" id="kobo.134.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">RouterSearch</span></strong><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">That </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.138.1"> method can now be consumed as a service by other objects in the domain and in other hexagons. </span><span class="koboSpan" id="kobo.138.2">Later in this chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.139.1">Working with domain services</span></em><span class="koboSpan" id="kobo.140.1"> section, we will take a closer look at </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">domain services.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">A question</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.143.1"> that may arise is how complex the domain model methods should be, especially those that are part of the domain entities. </span><span class="koboSpan" id="kobo.143.2">My take is that the complexity will be determined by our knowledge of the problem domain and our ability to translate it into a domain entity that captures, through proper method definitions, only the necessary behaviors required to change the entity state according to the conditions presented by the problem domain. </span><span class="koboSpan" id="kobo.143.3">A weak problem domain knowledge may yield unnecessary complexity. </span><span class="koboSpan" id="kobo.143.4">So, as our knowledge of the problem domain increases, it also increases our capacity to provide the right level of complexity to the methods we define for the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">domain entities.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">One fundamental characteristic of entities is that they have an identity that uniquely identifies them. </span><span class="koboSpan" id="kobo.145.2">Having an identity mechanism is paramount to ensuring that our entities are unique across a system. </span><span class="koboSpan" id="kobo.145.3">One way to provide such identity is through the use of UUIDs, a subject we will explore in </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the section.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.147.1">Using UUIDs to define identity</span></h2>
<p><span class="koboSpan" id="kobo.148.1">You</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.149.1"> may be familiar with </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">identifier</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">ID</span></strong><span class="koboSpan" id="kobo.153.1">)-generation techniques that rely on database sequence mechanisms to generate and avoid duplication of IDs. </span><span class="koboSpan" id="kobo.153.2">Although it’s convenient to delegate this responsibility to a database, by doing so, we couple a crucial aspect of our software to an </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">external system.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Let’s suppose we’re aiming to develop a hexagonal application that lets us evolve business code with as few technology dependencies as possible. </span><span class="koboSpan" id="kobo.155.2">In this case, we need to find a way to turn this identity generation into an </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">independent process.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">A common approach to establishing an identity that does not rely on a central authority is with a </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">universally unique identifier</span></strong><span class="koboSpan" id="kobo.159.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">UUID</span></strong><span class="koboSpan" id="kobo.161.1">). </span><span class="koboSpan" id="kobo.161.2">This</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.162.1"> is a 128-bit number widely used to assure universal uniqueness in computer systems. </span><span class="koboSpan" id="kobo.162.2">There are four different methods</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.163.1"> to generate UUIDs – time-based, </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Distributed Computer Environment</span></strong><span class="koboSpan" id="kobo.165.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.166.1">DCE</span></strong><span class="koboSpan" id="kobo.167.1">) security, name-based, and randomly generated. </span><span class="koboSpan" id="kobo.167.2">The following code snippet shows how you can create name-based and randomly </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">generated UUIDs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
     // Name-based UUID
     var bytes = new byte[20];
     new Random().nextBytes(bytes);
     var nameBasedUUID = UUID.nameUUIDFromBytes(bytes);
     // Randomly generated UUID
     var randomUUID = UUID.randomUUID();</span></pre> <p><span class="koboSpan" id="kobo.170.1">Beware of </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.171.1">UUIDs, you can have performance issues if your data source is a relational database. </span><span class="koboSpan" id="kobo.171.2">Because UUIDs are strings, they consume more memory than the integers created by autogenerated IDs provided by relational databases. </span><span class="koboSpan" id="kobo.171.3">The use of UUIDs can cause a considerable impact on the size and index management of databases. </span><span class="koboSpan" id="kobo.171.4">There is no free lunch. </span><span class="koboSpan" id="kobo.171.5">Computer resources are the price to be paid for such an agnostic ID-generation solution. </span><span class="koboSpan" id="kobo.171.6">It’s up to you to decide whether the benefits of this approach outweigh </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the disadvantages.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Once defined, the entity ID should not change, so it becomes an immutable attribute. </span><span class="koboSpan" id="kobo.173.2">This immutable characteristic makes the entity ID attribute a suitable candidate to be modeled as a value object. </span><span class="koboSpan" id="kobo.173.3">Based on the topology and network inventory example that we dealt with in the previous chapter, the following code snippet shows us a simple approach to creating a value object class to represent the ID of our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
public class RouterId {
     private final UUID id;
     private RouterId(UUID id){
          this.id = id;
     }
     public static RouterId withId(String id){
          return new RouterId(UUID.fromString(id));
     }
     public static RouterId withoutId(){
          return new RouterId(UUID.randomUUID());
     }
}</span></pre> <p><span class="koboSpan" id="kobo.177.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">withId</span></strong><span class="koboSpan" id="kobo.179.1"> factory </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.180.1">method allows the reconstitution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Router</span></strong><span class="koboSpan" id="kobo.182.1"> entities when we have the ID. </span><span class="koboSpan" id="kobo.182.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">withoutId</span></strong><span class="koboSpan" id="kobo.184.1"> factory method enables the generation of new IDs if we deal with a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> entity.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">withId</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">withoutId</span></strong><span class="koboSpan" id="kobo.191.1"> methods are both applications of a pattern called the static factory method that allows us to encapsulate object creation. </span><span class="koboSpan" id="kobo.191.2">These methods are part of the domain model because they enable identity provisioning, through IDs, on either new or existing </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">router entities.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Entities are first-class citizens in a hexagonal architecture. </span><span class="koboSpan" id="kobo.193.2">They are the foundational elements from which other software components will derive. </span><span class="koboSpan" id="kobo.193.3">However, they alone aren’t enough to create rich domain models because not everything in a domain possesses an identity. </span><span class="koboSpan" id="kobo.193.4">We need something to express objects that don’t need to be uniquely identified. </span><span class="koboSpan" id="kobo.193.5">We fill this need with value objects, a type of object intended to help us increase the descriptiveness of a </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">problem domain.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.195.1">Enhancing descriptiveness with value objects</span></h1>
<p><span class="koboSpan" id="kobo.196.1">In the book</span><a id="_idIndexMarker075"/> <em class="italic"><span class="koboSpan" id="kobo.197.1">Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.198.1">, the author Vernon Vaughn points out that we should use value objects to measure, quantify, or</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.199.1"> describe things from our problem domain. </span><span class="koboSpan" id="kobo.199.2">For example, you can describe an ID attribute with a value object instead of a long or integer value. </span><span class="koboSpan" id="kobo.199.3">You can wrap a double or big decimal attribute into a specific value object to express quantification </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">more clearly.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We’re not fully satisfied with just using the built-in language types to model a problem domain. </span><span class="koboSpan" id="kobo.201.2">To make a system more explicit about its nature and purposes, we wrap those built-in language data types – and even our own created types – in well-defined </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">value objects.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">This effort to convey meaning is based on the following two fundamental characteristics of </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">value objects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.205.1">They </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">are immutable</span></span></li>
<li><span class="koboSpan" id="kobo.207.1">They don’t have </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">an identity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.209.1">Suppose you have painted a picture. </span><span class="koboSpan" id="kobo.209.2">Imagine how strange would it be if, for some reason, after you’ve finished your work, parts of your picture mysteriously change colors. </span><span class="koboSpan" id="kobo.209.3">In this analogy, colors are like value objects that we use to create a picture, and each color can be a different value object. </span><span class="koboSpan" id="kobo.209.4">So, to ensure that our paint will persist, the colors, once used, must not change and must be immutable once </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.210.1">used. </span><span class="koboSpan" id="kobo.210.2">I base my argument for value objects on the idea that some characteristics must never change because they are the raw material we use to describe a </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">problem domain.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Raw material </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.213.1">alone neither expresses much meaning nor has much value. </span><span class="koboSpan" id="kobo.213.2">The real value comes when we combine and work with that raw stuff to form relevant and discernable things. </span><span class="koboSpan" id="kobo.213.3">Because value objects alone are like raw material, we don’t bother to replace them or throw them away. </span><em class="italic"><span class="koboSpan" id="kobo.214.1">And if they are not so important, why should we assign them an identity and take the same care we have </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.215.1">with entities?</span></em></span></p>
<p><span class="koboSpan" id="kobo.216.1">The bottom line is that value objects should be discardable and easily replaceable objects that we use to compose an entity or other type </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">of object.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.218.1">Using value objects to compose entities</span></h2>
<p><span class="koboSpan" id="kobo.219.1">When</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.220.1"> modeling an entity class, for example, we have two</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.221.1"> options – to use or not use value objects on entity attributes. </span><span class="koboSpan" id="kobo.221.2">Here is an example of the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">second approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
public class Event implements Comparable&lt;Event&gt; {
     private EventId id;
     private OffsetDateTime timestamp;
     private String protocol;
     private String activity;
     ...
</span><span class="koboSpan" id="kobo.223.2">}</span></pre> <p><span class="koboSpan" id="kobo.224.1">Consider the following log excerpt as data entries we want to parse in</span><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.225.1">to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
00:44:06.906367 100430035020260940012015 IPV6 </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">casanova.58183 &gt; menuvivofibra.br.domain</span></strong><span class="koboSpan" id="kobo.230.1">: 64865+ PTR? </span><span class="koboSpan" id="kobo.230.2">1.0.0.224.in-addr.arpa. </span><span class="koboSpan" id="kobo.230.3">(40)
00:44:06.912775 100430035020260940012016 IPV4 menuvivofibra.br.domain &gt; casanova.58183: 64865 1/0/0 PTR all-systems.mcast.net. </span><span class="koboSpan" id="kobo.230.4">(75)</span></pre> <p><span class="koboSpan" id="kobo.231.1">After being properly parsed, we would have </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Event</span></strong><span class="koboSpan" id="kobo.233.1"> objects with network traffic activity string </span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.234.1">fields, as </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">shown here:</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.236.1">casanova.58183 &gt; </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.237.1">menuvivofibra.br.domain</span></strong></span></p>
<p><span class="koboSpan" id="kobo.238.1">Before the</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.239.1"> greater-than sign, we have the source host </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.240.1">and, after, the destination host. </span><span class="koboSpan" id="kobo.240.2">For the sake of this example, let’s see it as an activity representing the source and destination of a packet. </span><span class="koboSpan" id="kobo.240.3">By being a string, it leaves a burden for clients that want to retrieve the source or destination host from it, as </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">illustrated here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
var srcHost = event.getActivity().split("&gt;")[0]
  //casanova.58183</span></pre> <p><span class="koboSpan" id="kobo.243.1">Let’s try it with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Activity</span></strong><span class="koboSpan" id="kobo.245.1"> va</span><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.246.1">lue object, </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
public class Activity {
     private final String description;
     private final String srcHost;
     private final Strin</span><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.249.1">g dstHost;
     public Activity (String description, String srcHost,
       String dstHost){
          this.description = description;
          this.srcHost = description.split("&gt;")[0];
          this.dstHost = description.split("&gt;")[1];
     }
     public String getSrcHost(){
          return this.srcHost;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.250.1">Then, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Event</span></strong><span class="koboSpan" id="kobo.252.1"> en</span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.253.1">tity class, </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
public class Event implements Comparable&lt;Event&gt; {
     private EventId id;
     private OffsetDateTime timestamp;
     private String protocol;
     </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">private Activity activity;</span></strong><span class="koboSpan" id="kobo.257.1">
     ...
</span><span class="koboSpan" id="kobo.257.2">}</span></pre> <p><span class="koboSpan" id="kobo.258.1">The client </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.259.1">code becomes clearer and more expressive, as </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.260.1">we can see in the following snippet. </span><span class="koboSpan" id="kobo.260.2">Also, clients don’t need to handle the data themselves to retrieve the source and </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">destination hosts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
var srcHost = event.getActivity().retrieveSrcHost()
//casanova.58183</span></pre> <p><span class="koboSpan" id="kobo.263.1">With value objects, we have more flexibility and control over our data, letting us express the domain model in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">cohesive way.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.265.1">Assuring consistency with aggregates</span></h1>
<p><span class="koboSpan" id="kobo.266.1">So far, we’ve </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.267.1">seen how valuable entities are to represent things in a problem domain. </span><span class="koboSpan" id="kobo.267.2">Also, we saw how value objects are essential to enhance the descriptiveness of the model we use. </span><em class="italic"><span class="koboSpan" id="kobo.268.1">However, how do we proceed when we have a group of related entities and value objects that express a whole concept when put together?</span></em><span class="koboSpan" id="kobo.269.1"> For such a scenario, we should employ the use of </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">aggregates</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">The idea is that objects inside an aggregate operate in a consistent and isolated manner. </span><span class="koboSpan" id="kobo.271.3">To achieve such consistency, we must ensure that any change on any aggregate object is conditioned to the variants imposed by such </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">an aggregate.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">An aggregate is like an orchestrator that orchestrates data and behavior on the objects it controls. </span><span class="koboSpan" id="kobo.273.2">For this approach to work, we need to define an entry point to interact with the aggregate realm. </span><span class="koboSpan" id="kobo.273.3">This entry point is also known as the aggregate root, which keeps references to the entities and value objects that are part of the aggregate. </span><span class="koboSpan" id="kobo.273.4">With the boundary provided by aggregates, we’re in a better position to assure consistency in the operations conducted by the objects within that boundary. </span><span class="koboSpan" id="kobo.273.5">By formally establishing conceptual boundaries to ensure consistency in the activities based on our problem domain, it will be easier for us to incorporate techniques such as optimistic or pessimistic locking, and technologies such </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.274.1">as the </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">Java Transaction API</span></strong><span class="koboSpan" id="kobo.276.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">Java JTA</span></strong><span class="koboSpan" id="kobo.278.1">) to support</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.279.1"> consistent transactional operations. </span><span class="koboSpan" id="kobo.279.2">With well-structured aggregates, we have better conditions to apply whatever approach we think is good to enable transactions on </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">From a performance and scalability perspective, we should always strive to keep our aggregates as small as possible. </span><span class="koboSpan" id="kobo.281.2">The reason is simple – large aggregate objects consume more memory. </span><span class="koboSpan" id="kobo.281.3">Too many aggregate objects being instantiated at the same time can compromise the overall </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">JVM</span></strong><span class="koboSpan" id="kobo.285.1">) performance. </span><span class="koboSpan" id="kobo.285.2">This</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.286.1"> rule applies to anything in the OOP world, but we emphasize aggregates because of their ability to </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">integrate objects.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">A small aggregate generally contains just one entity that acts as the aggregate root and other value objects. </span><span class="koboSpan" id="kobo.288.2">The way to make two different aggregates interact with each other is through their aggregate root, which happens to be an entity root with its unique ID. </span><span class="koboSpan" id="kobo.288.3">The aggregate root is used for persistence purposes as well. </span><span class="koboSpan" id="kobo.288.4">So, you’ll perform changes on aggregate child objects through the aggregate root, and when your changes are done, you’ll use the same aggregate root to commit those changes to your </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">persistence system.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Conversely, if you don’t see the non-functional requirements of performance and scalability as something critical, I think, with proper care, that aggregates can grow to have more than </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">one entity.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.292.1">Modeling an aggregate</span></h2>
<p><span class="koboSpan" id="kobo.293.1">To illustrate</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.294.1"> how we can model an aggregate, let’s return to our network and topology inventory scenario. </span><span class="koboSpan" id="kobo.294.2">One of the business needs is to catalog the equipment and networks connected to a specific </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">Edge Router</span></strong><span class="koboSpan" id="kobo.296.1">. </span><span class="koboSpan" id="kobo.296.2">Below this </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Edge Router</span></strong><span class="koboSpan" id="kobo.298.1">, we have a </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">Level 3 Switch</span></strong><span class="koboSpan" id="kobo.300.1">, responsible for </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.301.1">creating </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Virtual Local-Area Networks</span></strong><span class="koboSpan" id="kobo.303.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">VLANs</span></strong><span class="koboSpan" id="kobo.305.1">) for different networks. </span><span class="koboSpan" id="kobo.305.2">The structure would be something like the one </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.307.1"><img alt="Figure 2.1 – Network components" src="image/B19777_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">Figure 2.1 – Network components</span></p>
<p><span class="koboSpan" id="kobo.309.1">The catalog of</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.310.1"> equipment, networks, and relationships is used by the infrastructure department to help them plan and implement changes in the overall network. </span><span class="koboSpan" id="kobo.310.2">A router or switch alone doesn’t tell us too much about the network. </span><span class="koboSpan" id="kobo.310.3">The real value comes when we aggregate all the network components and </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">their interconnections.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">This kind of information will allow the infrastructure department to have more visibility and make well-based decisions. </span><span class="koboSpan" id="kobo.312.2">The epicenter of our aggregate is the edge router entity, which happens to be our aggregate root. </span><span class="koboSpan" id="kobo.312.3">The switch is also an entity. </span><span class="koboSpan" id="kobo.312.4">We model its VLAN networks as value objects. </span><span class="koboSpan" id="kobo.312.5">The context here is clear – a network composed of HR, marketing, and engineering VLAN networks connected to a switch that, in turn, is connected to the edge router. </span><span class="koboSpan" id="kobo.312.6">The internet or other networks can be considered in a different context. </span><span class="koboSpan" id="kobo.312.7">Here</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.313.1"> is a </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">Unified Modeling Language</span></strong><span class="koboSpan" id="kobo.315.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.316.1">UML</span></strong><span class="koboSpan" id="kobo.317.1">)-like representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">aggregate root:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.319.1"><img alt="Figure 2.2 – The aggregate grouping together all network components" src="image/B19777_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">Figure 2.2 – The aggregate grouping together all network components</span></p>
<p><span class="koboSpan" id="kobo.321.1">Starting from</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.322.1"> the bottom level, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Network</span></strong><span class="koboSpan" id="kobo.324.1"> as a value object, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
public record Network(IP address, String name, int cidr) {
    public Network {
        if (cidr &lt; 1 || cidr &gt; 32) {
            throw new IllegalArgumentException("Invalid
              CIDR
            value");
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.327.1">Note that the </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Internet Protocol</span></strong><span class="koboSpan" id="kobo.329.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.330.1">IP</span></strong><span class="koboSpan" id="kobo.331.1">) address </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.332.1">attribute is a value object as well, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
public class IP {
     private final String address;
     private final Protocol protocol;
     public IP(String address) {
          if(address == null)
          throw new IllegalArgumentException("Null IP
            address");
          if(address.length()&lt;=15) {
               this.protocol = Protocol.IPV4;
          } else {
               this.protocol = Protocol.IPV6;
          }
          this.address = address;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.335.1">You may have </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.336.1">noted some validation rules in the constructors of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">IP</span></strong><span class="koboSpan" id="kobo.338.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Network</span></strong><span class="koboSpan" id="kobo.340.1"> value objects’ classes. </span><span class="koboSpan" id="kobo.340.2">Those validations work as guards to prevent the wrong construction of value objects. </span><span class="koboSpan" id="kobo.340.3">Putting those guards in instance creation is one way to free clients from the burden of validating value objects. </span><span class="koboSpan" id="kobo.340.4">That’s exactly what happens on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Network</span></strong><span class="koboSpan" id="kobo.342.1"> class, where we just validate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">cidr</span></strong><span class="koboSpan" id="kobo.344.1"> attribute because </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">IP</span></strong><span class="koboSpan" id="kobo.346.1"> will come </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">already validated.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">There’s also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">Protocol</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.350.1">enum</span></strong><span class="koboSpan" id="kobo.351.1"> value object that we will use to compose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">IP</span></strong><span class="koboSpan" id="kobo.353.1"> value object, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.355.1">
public enum Protocol {
     IPV4,
     IPV6
}</span></pre> <p><span class="koboSpan" id="kobo.356.1">After modeling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">IP</span></strong><span class="koboSpan" id="kobo.358.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Network</span></strong><span class="koboSpan" id="kobo.360.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Protocol</span></strong><span class="koboSpan" id="kobo.362.1"> value objects, we have now the necessary objects</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.363.1"> to model the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Switch</span></strong><span class="koboSpan" id="kobo.365.1"> entity class, </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
public class Switch {
     private final SwitchType type;
     private final SwitchId switchId;
     private final List&lt;Network&gt; networkList;
     private final IP address;
    public Switch (SwitchType switchType, SwitchId
      switchId, List&lt;Network&gt; networks, IP address) {
        this.switchType = switchType;
        this.switchId = switchId;
        this.networks = networks;
        this.address = address;
    }
   public Switch addNetwork(Network network, Router rout
     er)
   {
      List&lt;Network&gt; newNetworks =
      new ArrayList&lt;&gt;(router.retrieveNetworks());
    newNetworks.add(network);
    return new Switch(
        this.switchType,
        this.switchId,
        newNetworks,
        this.address);
   }
    public List&lt;Network&gt; getNetworks() {
        return networks;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.368.1">Because</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.369.1"> networks are directly connected to a switch, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">addNetwork</span></strong><span class="koboSpan" id="kobo.371.1"> method to support the capability to add more networks to a switch. </span><span class="koboSpan" id="kobo.371.2">This method first retrieves the existing networks from the router, adding them to a list. </span><span class="koboSpan" id="kobo.371.3">Then, it adds the new network to the list of existing networks. </span><span class="koboSpan" id="kobo.371.4">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">addNetwork</span></strong><span class="koboSpan" id="kobo.373.1"> does not change the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Switch</span></strong><span class="koboSpan" id="kobo.375.1"> object but, rather, creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Switch</span></strong><span class="koboSpan" id="kobo.377.1"> instance containing the network </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">we added.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">On top of all the value objects we have created so far, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">Switch</span></strong><span class="koboSpan" id="kobo.381.1"> entity, we need to formalize a boundary with an aggregate root. </span><span class="koboSpan" id="kobo.381.2">That’s the role of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Router</span></strong><span class="koboSpan" id="kobo.383.1"> entity class, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
public class Router {
    private final RouterType routerType;
    private final RouterId routerid;
    private Switch networkSwitch;
    public Router(RouterType, RouterId routerid) {
        this.routerType = routerType;
        this.routerid = routerid;
    }
    public static Predicate&lt;Router&gt;
      filterRouterByType(RouterType routerType) {
        return routerType.equals(RouterType.CORE)
                ? </span><span class="koboSpan" id="kobo.385.2">Router.isCore() :
                Router.isEdge();
    }
    public static Predicate&lt;Router&gt; isCore() {
        return p -&gt; p.getRouterType() == RouterType.CORE;
   }
    public static Predicate&lt;Router&gt; isEdge() {
        return p -&gt; p.getRouterType() == RouterType.EDGE;
   }
    public void addNetworkToSwitch(Network network) {
        this.networkSwitch =
          networkSwitch.addNetwork(network, this);
    }
    public Network createNetwork(IP address, String name,
      int cidr) {
        return new Network(address, name, cidr);
    }
    public List&lt;Network&gt; retrieveNetworks() {
        return networkSwitch.getNetworks();
    }
    public RouterType getRouterType() {
        return routerType;
    }
    @Override
    public String toString() {
        return "Router{" +
                "type=" + routerType +
                ", id=" + routerid +
          '}';
    }
}</span></pre> <p><span class="koboSpan" id="kobo.386.1">Along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">RouterType</span></strong><span class="koboSpan" id="kobo.388.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">RouterId</span></strong><span class="koboSpan" id="kobo.390.1"> value objects, there is also an entity for the switch. </span><span class="koboSpan" id="kobo.390.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">networkSwitch</span></strong><span class="koboSpan" id="kobo.392.1"> entity represents the switch connected directly to this router. </span><span class="koboSpan" id="kobo.392.2">Then, we add two methods, one to create a new network and another to connect an existing network to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">the switch.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">By putting </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.395.1">these methods on the aggregate root, we delegate to it the responsibility to handle all the objects under its context, thus enhancing consistency when we deal with such an aggregation of objects. </span><span class="koboSpan" id="kobo.395.2">Also, this is an effort to prevent the anemic domain model approach, whereby entities are just data objects without any kind </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">of behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Next, we will see how to use domain services to call those operations contained in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the aggregate.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.399.1">Working with domain services</span></h1>
<p><span class="koboSpan" id="kobo.400.1">When </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.401.1">modeling a problem domain, we’ll certainly face situations where the task at hand does not fit adequately into any of the object categories that we’ve seen so far in the domain hexagon – entities, value objects, and aggregates. </span><span class="koboSpan" id="kobo.401.2">Earlier in this chapter, we encountered a situation where we removed from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Router</span></strong><span class="koboSpan" id="kobo.403.1"> entity a method responsible for retrieving a list of routers. </span><span class="koboSpan" id="kobo.403.2">That method seemed to be in the wrong place because, in our topology and network inventory scenario, a router usually doesn’t list other routers. </span><span class="koboSpan" id="kobo.403.3">To deal with this cumbersome situation, we’ve refactored the router list method in a separate object. </span><span class="koboSpan" id="kobo.403.4">Eric Evans calls such objects </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.404.1">domain services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">I believe it’s important to distinguish domain services from</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.407.1"> any other type of service. </span><span class="koboSpan" id="kobo.407.2">For example, in </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.409.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.410.1">MVC</span></strong><span class="koboSpan" id="kobo.411.1">) architectures, services are often seen as bridges that connect the different facets of an application, handling data and orchestrating calls within and outside the system. </span><span class="koboSpan" id="kobo.411.2">Their usage is often associated with software development frameworks such as Spring that even have a service annotation. </span><span class="koboSpan" id="kobo.411.3">However, independent of the context, I believe the main difference between distinguished service types lies not in the meaning but in </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the scope.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.413.1">What makes something a service?</span></em><span class="koboSpan" id="kobo.414.1"> It’s the ability to perform some worthwhile effort. </span><span class="koboSpan" id="kobo.414.2">This characteristic is inherent to any service, both in the real world and with computers. </span><span class="koboSpan" id="kobo.414.3">However, in the latter case, we should care about</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.415.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">Separation of Concerns</span></strong><span class="koboSpan" id="kobo.417.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.418.1">SoC</span></strong><span class="koboSpan" id="kobo.419.1">), modularization, decoupling, and other relevant stuff for good architecture. </span><span class="koboSpan" id="kobo.419.2">It’s based on those concerns that we put domain services inside the domain hexagon. </span><span class="koboSpan" id="kobo.419.3">They perform worthwhile tasks – as with any other services – but within the constrained scope of our problem domain. </span><span class="koboSpan" id="kobo.419.4">This means domain services should not call services or other objects that operate in application or framework hexagons. </span><span class="koboSpan" id="kobo.419.5">Instead, objects from those hexagons are clients who call </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">domain services.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">In the previous section, we created the following two methods in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Router</span></strong><span class="koboSpan" id="kobo.423.1"> entity class, which is also the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">aggregate root:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
public void addNetworkToSwitch(Network network) {
    this.networkSwitch = networkSwitch.addNetwork(network,
      this);
}
public Network createNetwork(IP address, String name, long
  cidr) {
    return new Network(address, name, cidr);
}</span></pre> <p><span class="koboSpan" id="kobo.426.1">In the following code snippet, we have a </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.427.1">service class operating over those two </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Router</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.429.1">entity methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
public class NetworkOperation {
     final private int MINIMUM_ALLOWED_CIDR = 8;
     public void createNewNetwork(Router router, IP
       address, String name, int cidr) {
     if(cidr &lt; MINIMUM_ALLOWED_CIDR)
     throw new IllegalArgumentException("CIDR is
       below      "+MINIMUM_ALLOWED_CIDR);
     if(isNetworkAvailable(router, address))
     throw new IllegalArgumentException("Address already
       exist");
     Network =
       router.createNetwork(address,name,cidr);
     router.addNetworkToSwitch(network);
     }
     private boolean isNetworkAvailable(Router router, IP
       address){
          var availability = true;
          for (Network network : router.retrieveNetworks()) {
               if(network.getAddress().equals(address) &amp;&amp;
                 network.getCidr() == cidr)
                    availability = false;
                    break;
          }
          return availability;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.431.1">We have a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">createNewNetwork</span></strong><span class="koboSpan" id="kobo.433.1"> that is responsible for creating a new network object and adding it to the switch linked to our router. </span><span class="koboSpan" id="kobo.433.2">We should meet two constraints to be able to create a network. </span><span class="koboSpan" id="kobo.433.3">The first, simple one checks whether the minimum </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">Classless Inter-Domain Routing</span></strong><span class="koboSpan" id="kobo.435.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.436.1">CIDR</span></strong><span class="koboSpan" id="kobo.437.1">) has </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.438.1">not been violated. </span><span class="koboSpan" id="kobo.438.2">The second constraint is somewhat more elaborate. </span><span class="koboSpan" id="kobo.438.3">It verifies whether the network address is already used on the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">whole network.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">With this </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.441.1">approach, we’re delegating to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">NetworkOperation</span></strong><span class="koboSpan" id="kobo.443.1"> domain service class the responsibility to deal with tasks that don’t fit neatly into entities or value objects. </span><span class="koboSpan" id="kobo.443.2">It's also a good way to prevent entity and value object classes from growing too large, with far more features than necessary according to a </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">problem domain.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">Until now, we’ve dealt with invariants directly on entities, value objects, or service classes. </span><span class="koboSpan" id="kobo.445.2">Next, we’ll see an approach to accommodate those invariants in a more orderly and </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">organized way.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.447.1">Using policy and specification to deal with business rules</span></h1>
<p><span class="koboSpan" id="kobo.448.1">One of the</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.449.1"> most </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.450.1">valuable things a system possesses is its codified business rules. </span><span class="koboSpan" id="kobo.450.2">Those rules represent a vital effort to understand a real-world problem and translate that understanding into working software. </span><span class="koboSpan" id="kobo.450.3">That’s not a trivial task, for sure. </span><span class="koboSpan" id="kobo.450.4">In DDD, we learn how crucial it is to work closely with domain experts to model our problem domain correctly. </span><span class="koboSpan" id="kobo.450.5">If domain experts are not available, we should seek developers with knowledge of a business. </span><span class="koboSpan" id="kobo.450.6">If none of them is available, we have no choice but to embark on a knowledge-seeking journey through books and any other resources that can help us grasp our problem domain’s </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">inner workings.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Once the business </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.453.1">knowledge is acquired and we have enough relevant information about the problem domain’s steps and processes, we can then start the adventure to transform that knowledge into code. </span><span class="koboSpan" id="kobo.453.2">At first glance, this process to understand business needs and transform them into software seems simple. </span><span class="koboSpan" id="kobo.453.3">Instead, it’s been the fruit of very good debates that have given rise to various methodologies and even an important manifesto called</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.454.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.455.1">Agile Manifesto</span></strong><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">It’s not my goal here to discuss the best approach to understanding business needs. </span><span class="koboSpan" id="kobo.456.3">Instead, the idea here is to present some of the techniques we can use to transform that business knowledge into </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">working software.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">We always have the </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.459.1">option to do things our way, sometimes ignoring the knowledge resulting from the experience of others who came before us. </span><span class="koboSpan" id="kobo.459.2">When dealing with business rules, this is by no means different. </span><span class="koboSpan" id="kobo.459.3">In the previous examples, we did this very thing, scattering business rules around code without a second thought. </span><span class="koboSpan" id="kobo.459.4">We now have an opportunity to fix that approach and tap into the knowledge of others who came </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">before us.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Policy and specification patterns are two patterns that can help us better organize our code’s </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">business rules.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">policy</span></strong><span class="koboSpan" id="kobo.465.1">, also</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.466.1"> known as a </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.467.1">strategy, is a pattern that encapsulates part of the problem domain in a block of code. </span><span class="koboSpan" id="kobo.467.2">For those familiar with the Strategy pattern (</span><em class="italic"><span class="koboSpan" id="kobo.468.1">Gang of Four</span></em><span class="koboSpan" id="kobo.469.1">), the term </span><em class="italic"><span class="koboSpan" id="kobo.470.1">algorithm</span></em><span class="koboSpan" id="kobo.471.1"> can be used to describe that encapsulated block of code. </span><span class="koboSpan" id="kobo.471.2">The main characteristic of a policy is that it performs some action or processing in the data provided. </span><span class="koboSpan" id="kobo.471.3">Policies are intentionally kept separate from entities and value objects to avoid coupling. </span><span class="koboSpan" id="kobo.471.4">This decoupling provides the well-known benefit of evolving one part without direct impact or side effects on </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">Conversely, </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">specifications</span></strong><span class="koboSpan" id="kobo.475.1"> are</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.476.1"> like conditions or predicates used to ensure the properties of an object. </span><span class="koboSpan" id="kobo.476.2">However, what </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.477.1">characterizes a specification is its care to encapsulate those predicates in a more expressive way than mere logical operators. </span><span class="koboSpan" id="kobo.477.2">Once encapsulated, those specifications can be reused and even combined to express the problem </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">domain better.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">When used together, policies and specifications are sound techniques to improve the robustness and consistency of our business rules across code. </span><span class="koboSpan" id="kobo.479.2">A specification ensures that only suitable objects are handled by our policies. </span><span class="koboSpan" id="kobo.479.3">We have a catalog of different and easily changeable algorithms at our disposal </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">with policies.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">To better illustrate how specifications and policies work, we will now explore how to </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">implement them.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.483.1">Creating specifications</span></h2>
<p><span class="koboSpan" id="kobo.484.1">Let’s first </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.485.1">see how we can refactor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">NetworkOperation</span></strong><span class="koboSpan" id="kobo.487.1"> service class to use specifications. </span><span class="koboSpan" id="kobo.487.2">We’ll start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Specification</span></strong><span class="koboSpan" id="kobo.489.1"> interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
public interface Specification&lt;T&gt; {
          boolean isSatisfiedBy(T t);
     Specification&lt;T&gt; and(Specification&lt;T&gt; specification);
}</span></pre> <p><span class="koboSpan" id="kobo.492.1">It’s through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">isSatisfiedBy</span></strong><span class="koboSpan" id="kobo.494.1"> implementation that we will define our predicates. </span><span class="koboSpan" id="kobo.494.2">Followed by this interface, we need to create an abstract class that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">and</span></strong><span class="koboSpan" id="kobo.496.1"> method to allow us to combine specifications, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
public abstract class AbstractSpecification&lt;T&gt; implements
  Specification&lt;T&gt; {
     public abstract boolean isSatisfiedBy(T t);
     public Specification&lt;T&gt; and(final Specification&lt;T&gt;
       specification) {
          return new AndSpecification&lt;T&gt;(this,
            specification);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.499.1">Here, there is only a method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">AND</span></strong><span class="koboSpan" id="kobo.501.1"> operator because we are not dealing with other operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">OR</span></strong><span class="koboSpan" id="kobo.503.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">NOT</span></strong><span class="koboSpan" id="kobo.505.1">, although it’s common to implement methods for those operators. </span><span class="koboSpan" id="kobo.505.2">To conclude the creation of our base types, we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">AndSpecification</span></strong><span class="koboSpan" id="kobo.507.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
public class AndSpecification&lt;T&gt; extends AbstractSpecifica
  tion&lt;T&gt; {
     private final Specification&lt;T&gt; spec1;
     private final Specification&lt;T&gt; spec2;
     public AndSpecification(final Specification&lt;T&gt; spec1,
       final Specification&lt;T&gt; spec2) {
          this.spec1 = spec1;
          this.spec2 = spec2;
     }
     public boolean isSatisfiedBy(final T t) {
          return spec1.isSatisfiedBy(t) &amp;&amp;
            spec2.isSatisfiedBy(t);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.510.1">We are now </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.511.1">ready to create our own specifications. </span><span class="koboSpan" id="kobo.511.2">The first one is about the business rule that limits the minimum CIDR allowed for the creation of new networks. </span><span class="koboSpan" id="kobo.511.3">The code is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
if(cidr &lt; MINIMUM_ALLOWED_CIDR)
     throw new IllegalArgumentException("CIDR is
       below "+MINIMUM_ALLOWED_CIDR);</span></pre> <p><span class="koboSpan" id="kobo.514.1">The corresponding specification will look </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
public class CIDRSpecification extends AbstractSpecifica
  tion&lt;Integer&gt; {
     final static public int MINIMUM_ALLOWED_CIDR = 8;
     @Override
     public boolean isSatisfiedBy(Integer cidr) {
          return cidr &gt; MINIMUM_ALLOWED_CIDR;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.517.1">Next, we’ll </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.518.1">deal with the business rules that check whether the network address is not already used, </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
if(isNetworkAvailable(router, address))
  throw new IllegalArgumentException("Address already ex
    ist");
private boolean isNetworkAvailable(Router router, IP ad
  dress) {
     var availability = true;
     for (Network network : router.retrieveNetworks()) {
          if(network.getAddress().equals(address) &amp;&amp;
            network.getCidr() == cidr)
                    availability = false;
                    break;
          }
          return availability;
     }</span></pre> <p><span class="koboSpan" id="kobo.521.1">The refactoring of the previous code basically consists of moving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">isNetworkAvailable</span></strong><span class="koboSpan" id="kobo.523.1"> method from the entity to the specification class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
public class NetworkAvailabilitySpecification extends Ab
  stractSpecification&lt;Router&gt; {
     private final IP address;
     private final String name;
     private final int cidr;
     public NetworkAvailabilitySpecification(IP address,
       String name, int cidr) {
          this.address = address;
          this.name = name;
          this.cidr = cidr;
     }
     @Override
     public boolean isSatisfiedBy(Router router) {
          return router!=null &amp;&amp;
            isNetworkAvailable(router);
     }
     private boolean isNetworkAvailable(Router router) {
          return router.retrieveNetworks().stream()
             .noneMatch(
             network -&gt; network.address().equals(address)
               &amp;&amp;
             network.name().equals(name) &amp;&amp;
             network.cidr() == cidr);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.526.1">To illustrate how to combine two specifications with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">and</span></strong><span class="koboSpan" id="kobo.528.1"> method, we will create two more specifications. </span><span class="koboSpan" id="kobo.528.2">The </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.529.1">first one is to establish the maximum allowed networks and is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
public class NetworkAmountSpecification extends Ab
  stractSpecification&lt;Router&gt; {
     final static public int MAXIMUM_ALLOWED_NETWORKS = 6;
     @Override
     public boolean isSatisfiedBy(Router router) {
          return router.retrieveNetworks().size()
            &lt;=MAXIMUM_ALLOWED_NETWORKS;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.532.1">And the second specification is to ensure that we deal only with edge or core routers. </span><span class="koboSpan" id="kobo.532.2">This is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
public class RouterTypeSpecification extends AbstractSpeci
  fication&lt;Router&gt; {
     @Override
     public boolean isSatisfiedBy(Router router) {
          return
          router.getRouterType().equals(RouterType.EDGE) ||
            router.getRouterType().equals(RouterType.CORE);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.535.1">Now that we have defined our specifications, we can use a feature introduced first as a preview in Java 15 and then as definitive in Java 17, allowing us to constrain which classes are permitted to implement </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.536.1">an interface or a class. </span><span class="koboSpan" id="kobo.536.2">We call it a </span><em class="italic"><span class="koboSpan" id="kobo.537.1">sealed class/interface</span></em><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">As the name implies, this feature seals the class/interface, so it cannot be implemented unless the implementing class/interface name is explicitly declared on the sealed class or interface. </span><span class="koboSpan" id="kobo.538.3">Let’s check how this feature can work with the specification we </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">just created.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">We want to restrict who can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Specification</span></strong><span class="koboSpan" id="kobo.542.1"> interface and the   </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">AbstractSpecification</span></strong><span class="koboSpan" id="kobo.544.1"> abstract class. </span><span class="koboSpan" id="kobo.544.2">In the following code snippet, we can see how we can apply it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Specification</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
public sealed interface Specification&lt;T&gt; permits Ab
  stractSpecification {
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.548.1">Note that we restrict which class can implement the interface by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">permits</span></strong><span class="koboSpan" id="kobo.550.1"> clause. </span><span class="koboSpan" id="kobo.550.2">Let’s seal the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">AbstractSpecification</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.552.1">abstract class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
public abstract sealed class AbstractSpecification&lt;T&gt; im
  plements Specification&lt;T&gt; permits
        AndSpecification,
        CIDRSpecification,
        NetworkAmountSpecification,
        NetworkAvailabilitySpecification,
        RouterTypeSpecification
{
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.554.1">The permit clause now includes all the other classes implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">AbstractSpecification</span></strong><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">We still need to ensure the implementing classes are </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">final</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">Therefore, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">final</span></strong><span class="koboSpan" id="kobo.560.1"> clause on every one of those classes, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
public final class NetworkAmountSpecification extends Ab
  stractSpecification&lt;Router&gt; {
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.563.1">Once we </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.564.1">have finished adjusting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">final</span></strong><span class="koboSpan" id="kobo.566.1"> keyword on the implementing specification classes, we have a well-defined set of sealed classes/interfaces, describing which specification classes can be used to define a system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">business rules.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">We’re now ready to refactor our domain service, responsible for creating new networks to use those specifications, </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
public class NetworkOperation {
     public void createNewNetwork(Router router, IP
       address, String name, int cidr) {
          var availabilitySpec = new
            NetworkAvailabilitySpecification(address, name,
              cidr);
          var cidrSpec = new CIDRSpecification();
          var routerTypeSpec = new
            RouterTypeSpecification();
          var amountSpec = new
            NetworkAmountSpecification();
          if(cidrSpec.isSatisfiedBy(cidr))
               throw new IllegalArgumentException("CIDR is
                 below
                 "+CIDRSpecification.MINIMUM_ALLOWED_CIDR);
          if(availabilitySpec.isSatisfiedBy(router))
               throw new IllegalArgumentException("Address
                 already exist");
          if(amountSpec.and(routerTypeSpec).isSatisfiedBy
            (router)) {
               Network network =
                 router.createNetwork(address, name, cidr);
               router.addNetworkToSwitch(network);
          }
     }
}</span></pre> <p><span class="koboSpan" id="kobo.571.1">Now that we </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.572.1">have explored how to implement specifications, let’s see how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">create policies.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.574.1">Creating policies</span></h2>
<p><span class="koboSpan" id="kobo.575.1">To understand </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.576.1">how policies work, we will create a service class to help us retrieve a list of network events based on a specific algorithm to parse raw event data. </span><span class="koboSpan" id="kobo.576.2">This parse algorithm can or cannot be considered part of the problem domain; usually, it’s not, but for the sake of this example, let’s assume </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">it is.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">We will create two policies – the first is to parse string log entries into </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Event</span></strong><span class="koboSpan" id="kobo.580.1"> objects using a pure </span><strong class="bold"><span class="koboSpan" id="kobo.581.1">regular expression</span></strong><span class="koboSpan" id="kobo.582.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.583.1">regex</span></strong><span class="koboSpan" id="kobo.584.1">)-based algorithm, where </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.585.1">we explicitly inform the regex pattern, while the second one will accomplish the same thing but with a split-based algorithm that uses just a space delimiter. </span><span class="koboSpan" id="kobo.585.2">The choice between both policies can be based on performance and the ability to customize the parsing mechanisms, among </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">other factors.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">First, we will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">EventParser</span></strong><span class="koboSpan" id="kobo.589.1"> interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
public interface EventParser {
     DateTimeFormatter formatter =
       DateTimeFormatter.ofPattern("yyyy-MM-dd
         HH:mm:ss.SSS").withZone(ZoneId.of("UTC"));
     Event parseEvent(String event);
}</span></pre> <p><span class="koboSpan" id="kobo.592.1">We’ll use </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.593.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">formatter</span></strong><span class="koboSpan" id="kobo.595.1"> attribute in both event-parser </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">implementation classes.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">Let’s start implementing the regex parser policy, </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
public class RegexEventParser implements EventParser {
     @Override
     public Event parseEvent(String event) {
          final String regex = "(\\\"[^\\\"]+\\\")|\\S+";
          final Pattern pattern = Pattern.compile(regex,
            Pattern.MULTILINE);
          final Matcher matcher = pattern.matcher(event);
          var fields = new ArrayList&lt;&gt;();
          while (matcher.find()) {
               fields.add(matcher.group(0));
          }
          var timestamp =
            LocalDateTime.parse(matcher.group(0),
              formatter).atOffset(ZoneOffset.UTC);
          var id = EventId.of(matcher.group(1));
          var protocol =
            Protocol.valueOf(matcher.group(2));
          var activity = new Activity(matcher.group(3),
            matcher.group(5));
          return new Event(timestamp, id, protocol,
            activity);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.600.1">The split</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.601.1"> parser policy seems simpler, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">see here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.603.1">
public class SplitEventParser implements EventParser{
          @Override
     public Event parseEvent(String event) {
          var fields = Arrays.asList(event.split(" "));
          var timestamp =
            LocalDateTime.parse(fields.get(0),
              formatter).atOffset(ZoneOffset.UTC);
          var id = EventId.of(fields.get(1));
          var protocol = Protocol.valueOf(fields.get(2));
          var activity = new Activity(fields.get(3),
            fields.get(5));
          return new Event(timestamp,id, protocol,
            activity);
     }
}</span></pre> <p><span class="koboSpan" id="kobo.604.1">As we did </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.605.1">previously with specifications, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">EventParser</span></strong><span class="koboSpan" id="kobo.607.1"> interface can be turned into a </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">sealed interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
public sealed interface EventParser permits RegexEvent
  Parser, SplitEventParser {
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.610.1">Don’t forget to include the final keyword on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">RegexEventParser</span></strong><span class="koboSpan" id="kobo.612.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">SplitEventParser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">Now, returning to the parser policy implementation, note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">Event</span></strong><span class="koboSpan" id="kobo.617.1"> constructor is called with the parsed attributes. </span><span class="koboSpan" id="kobo.617.2">We need to update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Event</span></strong><span class="koboSpan" id="kobo.619.1"> entity class to enable it to work with our policies. </span><span class="koboSpan" id="kobo.619.2">We can do so with the </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
public class Event implements Comparable&lt;Event&gt; {
     private final OffsetDateTime timestamp;
     private final EventId id;
     private final Protocol protocol;
     private final Activity activity;
     public Event(OffsetDateTime timestamp, EventId id,
       Protocol protocol, Activity activity) {
          this.timestamp = timestamp;
          this.id = id;
          this.protocol = protocol;
          this.activity = activity;
     }
     public static Event parsedEvent(String
       unparsedEvent, ParsePolicyType policy) {
          switch (policy){
            case REGEX -&gt; new
            RegexEventParser().parseEvent(unparsedEvent);
            case SPLIT -&gt; new
            SplitEventParser().parseEvent(unparsedEvent);
          }
     }
...
</span><span class="koboSpan" id="kobo.621.2">}</span></pre> <p><span class="koboSpan" id="kobo.622.1">The switch that </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.623.1">allows us to </span><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.624.1">choose between policies relies on the </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">fol</span><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.626.1">lowing enum:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
public enum ParsePolicyType {
    REGEX,
    SPLIT
}</span></pre> <p><span class="koboSpan" id="kobo.628.1">We’re now ready to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">EventSearch</span></strong><span class="koboSpan" id="kobo.630.1"> service class with a method to retrieve network events. </span><span class="koboSpan" id="kobo.630.2">This domain service will allow us to choose which kind of parse algorithm to use when retrieving events. </span><span class="koboSpan" id="kobo.630.3">Here’s the code we’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">for this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
public class EventSearch {
     public List&lt;Event&gt; retrieveEvents(List&lt;String&gt;
       unparsedEvents, ParsePolicyType policyType){
          var parsedEvents = new ArrayList&lt;Event&gt;();
          unparsedEvents.forEach(event →{
               parsedEvents.add(Event.parsedEvent(event,
          policyType));
          });
          return parsedEvents;
     }
}</span></pre> <p><span class="koboSpan" id="kobo.633.1">Now that we are</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.634.1"> acquainted with policy and specification patterns, let’s see the benefits of modeling our business rules </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">on POJOs.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.636.1">Defining business rules as POJOs</span></h1>
<p><span class="koboSpan" id="kobo.637.1">Back in the </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.638.1">day, when </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.639.1">enterprise </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.640.1">development was strongly influenced by Java 2 Platform, </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">Enterprise Edition</span></strong><span class="koboSpan" id="kobo.642.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.643.1">J2EE</span></strong><span class="koboSpan" id="kobo.644.1">) (known today as </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Jakarta EE</span></strong><span class="koboSpan" id="kobo.646.1">), there was a technology</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.647.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.648.1">Enterprise JavaBeans</span></strong><span class="koboSpan" id="kobo.649.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.650.1">EJBs</span></strong><span class="koboSpan" id="kobo.651.1">), responsible for lifting from </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.652.1">developers all the heavyweight jobs required to manage software development plumbing activities, relating to transaction management, security, and object life cycles. </span><span class="koboSpan" id="kobo.652.2">The EJB promise was that developers could focus their energy on developing business features, while the J2EE container would take care of all the infrastructure details. </span><span class="koboSpan" id="kobo.652.3">EJBs fulfilled this promise, but not without a price. </span><span class="koboSpan" id="kobo.652.4">It was time-consuming and boring to create and maintain EJBs in their first versions. </span><span class="koboSpan" id="kobo.652.5">There were lots of things to do, involving various </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Extensible Markup Language</span></strong><span class="koboSpan" id="kobo.654.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.655.1">XML</span></strong><span class="koboSpan" id="kobo.656.1">) configurations</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.657.1"> and deployment descriptors, and to make things worse, there was little space to reuse these EJB objects because they had so much boilerplate. </span><span class="koboSpan" id="kobo.657.2">They weren’t like POJOs – simple </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">and reusable.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">This issue with </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.660.1">the first EJB versions – version 2 especially – helped to motivate the creation of improved solutions that could leverage the simplicity of POJOs. </span><span class="koboSpan" id="kobo.660.2">Among those solutions, we can mention EJB 3 and the technologies derived from frameworks such as Spring and Quarkus. </span><span class="koboSpan" id="kobo.660.3">What all those technologies have in common, though, is the incentive and flexibility to work </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">with POJOs.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">POJOs are</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.663.1"> appealing because they are nothing more than regular Java objects. </span><span class="koboSpan" id="kobo.663.2">It is simple to understand a POJO because we deal only with Java standard </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">Application Programming Interfaces</span></strong><span class="koboSpan" id="kobo.665.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.666.1">APIs</span></strong><span class="koboSpan" id="kobo.667.1">) instead of custom libraries and frameworks. </span><span class="koboSpan" id="kobo.667.2">That’s what </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.668.1">makes POJOs a category of developer-friendly objects that are easier to understand and reuse across different parts of an application. </span><span class="koboSpan" id="kobo.668.2">If we aim for change-tolerant applications, then the use of POJOs is always recommended to diminish coupling with specific technologies, allowing an application to switch between different technologies or frameworks without </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">much friction.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">This flexibility offered by POJOs allows them to participate, simultaneously if needed, in different system departments. </span><span class="koboSpan" id="kobo.670.2">For example, nothing prevents someone from using the same POJO in transactional, persistence, and user-presentation contexts. </span><span class="koboSpan" id="kobo.670.3">We can also use POJOs to represent business rules – the entity, policy, and specification objects presented in this chapter are good examples of how we can embody business rules </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">within POJOs.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">By using POJOs to model business rules, we leverage all the benefits related to reusability and simplicity that a POJO can provide. </span><span class="koboSpan" id="kobo.672.2">They also go hand in hand with the important goal of keeping domain objects shielded from any technological details, which will ultimately contribute to the essential SoC efforts to support more supple and </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">sober designs.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.674.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.675.1">The DDD topics we covered in this chapter are paramount in our effort to develop hexagonal applications, as it’s through the use of DDD techniques that we’ll be able to shape a decoupled, consistent, and business-oriented domain hexagon that will be the foundation for the application and </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">framework hexagons.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">It’s always essential to understand the basics. </span><span class="koboSpan" id="kobo.677.2">By looking closer into the main DDD concepts, we found the basic techniques to aid us in developing the domain hexagon. </span><span class="koboSpan" id="kobo.677.3">We covered how to make pure and relevant entities and how to assign an identity to them. </span><span class="koboSpan" id="kobo.677.4">With value objects, we understood how important they are in conveying meaning and enhancing the descriptiveness of a problem domain. </span><span class="koboSpan" id="kobo.677.5">Aggregates showed us how to group related entities and value objects to describe whole operations in our problem domain. </span><span class="koboSpan" id="kobo.677.6">Also, we saw how aggregates are instrumental in assuring consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">with transactions.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Following aggregates, we learned that domain services let us express behaviors that don’t fit well into entities or value objects, and to better organize business rules, we learned about policy and specification patterns. </span><span class="koboSpan" id="kobo.679.2">Finally, we assessed the benefits of the reusability and simplicity that POJOs provide when defining business rules. </span><span class="koboSpan" id="kobo.679.3">With the ideas and techniques explored in this chapter, we can now build a domain hexagon that captures and properly arranges into code the business rules that will influence the behavior of an </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">entire application.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">We’re now ready to move one step higher in the ladder by entering the realm of the application hexagon, where we’ll see how to combine and orchestrate business rules to create software functionality through use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">and ports.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.683.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.684.1">What is the main attribute of entities not found in </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">value objects?</span></span></li>
<li><span class="koboSpan" id="kobo.686.1">Can value objects </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">be mutable?</span></span></li>
<li><span class="koboSpan" id="kobo.688.1">Every aggregate must have an entry-point object to allow communication with other objects controlled by the aggregate. </span><span class="koboSpan" id="kobo.688.2">What is the name of this </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">entry-point object?</span></span></li>
<li><span class="koboSpan" id="kobo.690.1">Are domain services allowed to call objects on </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">other hexagons?</span></span></li>
<li><span class="koboSpan" id="kobo.692.1">What is the difference between a policy and </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">a specification?</span></span></li>
<li><span class="koboSpan" id="kobo.694.1">What is the benefit of defining business rules as </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">a POJO?</span></span></li>
</ol>
<h1 id="_idParaDest-54"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.696.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.697.1">Implementing Domain-Driven Design</span></em><span class="koboSpan" id="kobo.698.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">Vernon, 2016)</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.700.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.701.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">Evans, 2003)</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.703.1">Extreme Programming Explained: Embrace Change</span></em><span class="koboSpan" id="kobo.704.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">Beck, 1999)</span></span></li>
</ul>
<h1 id="_idParaDest-55"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.706.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.707.1">Contrary to value objects, entities have </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">an identity.</span></span></li>
<li><span class="koboSpan" id="kobo.709.1">No. </span><span class="koboSpan" id="kobo.709.2">The most important property of a value object is </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">its immutability.</span></span></li>
<li><span class="koboSpan" id="kobo.711.1">The entry-point object for any aggregate is called an </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">aggregate root.</span></span></li>
<li><span class="koboSpan" id="kobo.713.1">No, but objects from other domains and other hexagons can call </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">domain services.</span></span></li>
<li><span class="koboSpan" id="kobo.715.1">A policy is a pattern that encapsulates part of the problem domain knowledge in a block of code or an algorithm. </span><span class="koboSpan" id="kobo.715.2">A specification is a pattern that works with predicates to assert the validity of the properties </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">of objects.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Because a POJO doesn’t depend on external technology details, such as a feature provided by an external library or a framework. </span><span class="koboSpan" id="kobo.717.2">Instead, a POJO relies only on a standard Java API, which makes POJOs simple and easy-to-reuse objects. </span><span class="koboSpan" id="kobo.717.3">POJOs are helpful for creating business rules objects that aren’t blurred by </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">technology details.</span></span></li>
</ol>
</div>
</body></html>