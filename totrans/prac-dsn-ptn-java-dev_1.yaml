- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting into Software Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every software architect or developer often faces the challenges of structuring
    code – how to develop a code structure that remains sustainable, just as an artist
    draws their painting. This chapter will take us on a journey into writing program
    code. You will explore the challenges behind the structure of code and its organization.
    Together, we will approach the topic from an early stage described by the pillars
    of object-oriented programming, known as APIE. We will also review the principles
    of SOLID to gain clarity in understanding design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Code – from symbols to program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining OOP and APIE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the SOLID design principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The significance of design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing what challenges design patterns solve
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have reviewed the basic programming concepts,
    which will form the basis of the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Code – from symbols to program
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Human speech is fruitful, rich, colorful, and way beyond what the words themselves
    may express. Nouns, verbs, and adjectives for precisely expressing a moment or
    action can be used. In contrast, machines do not understand the complex constructions
    or expressions that humans are able to create.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Machine language is limited, well-defined, extremely specific, and simplified.
    Its goal is to provide the precise expression of intent for which it is designed.
    This contrasts with human language whose purpose is just communication and not
    necessarily with specifics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'A machine’s intent can be expressed as a defined instruction or a set of them.
    This means that machines understand the instructions. These instructions must
    be available to the machine in some form at the time of execution. Each machine
    normally has a set of instructions. Based on this kind of instruction set, machines
    can perform the required instructions, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is\
    \ taken from memory and the result is stored\uFEFF)](img/B18884_01_01.jpg)"
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is taken
    from memory and the result is stored)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Let us explore one individual instruction. The instruction can be understood
    as a command given to the processor. The processor is the heart of the machine,
    or the center of the ordering and executing of processes. The machine may contain
    one or more of them. It depends on its design, but in any case, there is always
    one that takes the lead. For further simplification, we will only consider one
    – that is, consider a system that only has one **central processing unit** (**CPU**)
    dedicated to executing a program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: A CPU is a device that executes instructions containing a computer program.
    The CPU must contain such an instruction set, as shown in the previous diagram,
    to process the requested action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Because instructions can take completely different forms depending on the CPU,
    there is no defined standard. This promotes different CPU platforms, which is
    not necessarily a bad thing and contributes to evolution. However, the fact remains
    that the instructions are not easy for people to read.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We have stated that machines can perform instruction collection, ideally as
    a continuous flow. The flow of instructions can be simplified as a queue in memory,
    where one instruction goes in and the other leaves. The CPU plays the role of
    an interpreter who works with this memory cyclically (as we saw in *Figure 1**.1*).
    Okay, so the CPU interprets, but as the instructions are added to the memory,
    where do they come from, and how can such a stream be created?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let us gather some thoughts. Machine instructions, in most cases, originate
    from a compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a compiler? The compiler can be viewed as a CPU or a platform-specific
    program that translates text into target actions. The text we use to call the
    program and the result could be named machine code. The following diagram illustrates
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – A simplified platform-specific flow from the source code through
    the compiler program to its resultant action](img/B18884_01_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – A simplified platform-specific flow from the source code through
    the compiler program to its resultant action
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Machine code is a low-level language that the machine understands and consists
    of language instructions that are processed sequentially (see *Figure 1**.1*);
    the program was compiled, executed, and run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Java, there is no machine code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – A simplified flow for the Java program through the compiler
    to its platform execution](img/B18884_01_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – A simplified flow for the Java program through the compiler to
    its platform execution
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The source code is compiled by the Java compiler into bytecode. The bytecode
    is running a **Java virtual machine** (**JVM**) (see *Figure 1**.3*). In this
    situation, the JVM plays the role of the interface between the bytecode and the
    actual instructions that are executed on the CPU. The JVM emulates a bytecode
    instruction. It does this using the **just-in-time** (**JIT**) compiler that is
    part of the JVM. The JIT compiler translates bytecode instructions into native
    processor instructions. The JVM is a platform-specific interpreter, analogous
    to directly compiled code (see *Figure 1**.2*). The JVM also provides additional
    features such as memory management and garbage collection, which is what makes
    the Java platform so powerful. All these features allow developers to write code
    once, compile it into bytecode, and run a supported platform – known as **write
    once, run** **anywhere** (**WORA**).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the previous exploration, Java is a high-level language that
    is translated to a low level. Java provides a strong abstraction from the details
    of computer functionality. It allows programmers to create simpler programs for
    complex challenges.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一次探索的背景下，Java是一种高级语言，它被翻译成低级语言。Java提供了从计算机功能细节中的强大抽象。它允许程序员为复杂挑战创建更简单的程序。
- en: At this point, we begin our journey of jointly exploring standardized solutions.
    Later in the book, we will review how to create code that is maintainable and
    extensible with fewer memory requirements. Together, we will discuss different
    types of design patterns that can help us to make our daily work understandable,
    transparent, and more fun.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们开始共同探索标准化解决方案的旅程。在本书的后面部分，我们将回顾如何创建具有较少内存需求的可维护和可扩展的代码。我们将一起讨论不同类型的设计模式，这些模式可以帮助我们使日常工作变得可理解、透明，并且更有趣。
- en: Examining OOP and APIE
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查面向对象编程（OOP）和APIE
- en: In the previous section, we learned how a program written in one of the high-level
    languages is converted into machine instructions that are processed by the CPU.
    The high-level language provides a framework for expressing the desired ideas
    by following the details of the language implementation. Such languages commonly
    provide many neat constructions or statements that do not limit the imagination.
    In **object-oriented programming** (**OOP**) language, the representation of the
    core carrier is presented by the concept of the object. This book focuses on the
    Java language. Java is a fully object-oriented language with additional features.
    What does object-oriented language mean exactly? In computer science, this means
    that the program focuses on the concept of classes, where instances of these classes
    represent an object. Next, we will repeat the importance of the OOP paradigm and
    deal with some basic concepts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将用高级语言编写的程序转换成由CPU处理的机器指令。高级语言通过遵循语言实现的细节来提供一个表达所需想法的框架。这些语言通常提供许多整洁的结构或语句，这些结构或语句不会限制想象力。在**面向对象编程**（**OOP**）语言中，核心载体的表示是通过对象的概念来呈现的。本书专注于Java语言。Java是一种具有额外功能的完全面向对象的语言。面向对象语言究竟意味着什么？在计算机科学中，这意味着程序关注类的概念，其中这些类的实例代表一个对象。接下来，我们将重复OOP范式的重点，并处理一些基本概念。
- en: These terms can be expressed by the abbreviation of **abstraction, polymorphism,
    inheritance, and encapsulation** (**APIE**). The letters APIE indicate the four
    basic pillars of OOP languages. Let’s examine each word in a separate section
    in reverse order – so, EIPA. The motivation is to bring more clarity to our understanding
    of the concept of OOP.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语可以用**抽象、多态、继承和封装**（**APIE**）的缩写来表示。APIE字母表示OOP语言的四个基本支柱。让我们按相反的顺序分别检查每个词
    - 因此，EIPA。动机是为了使我们对OOP概念的理解更加清晰。
- en: Only exposing what’s required – encapsulation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只暴露所需的内容 - 封装
- en: 'The first in reverse order is encapsulation – let’s start with it. OOP languages,
    including Java, work with the concept of classes. Imagine that a class is a vehicle.
    The class provides all the fields that can be statically typed or object-specific
    – that is, initiated after an object is instantiated in the allocated memory.
    The concept is similar with respect to class or object methods. The method may
    belong to a class or its instance – in the considered example, to a vehicle. Any
    method can work over an object or class field and change the internal state of
    the vehicle or the field values (see *Example 1.1*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相反的顺序，首先是封装 - 让我们从它开始。面向对象的语言，包括Java，与类这一概念一起工作。想象一下，一个类就像一辆车。类提供了所有可以静态类型或对象特定的字段
    - 也就是说，在对象在分配的内存中实例化之后启动。在类或对象方法的概念上，这一概念是相似的。方法可能属于一个类或其实例 - 在考虑的例子中，属于一辆车。任何方法都可以在对象或类字段上工作，并改变车辆的内部状态或字段值（见
    *示例 1.1*）：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 1.1 – The Vehicle class hides an internal state (moving)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.1 - 车辆类隐藏内部状态（移动）
- en: We can apply encapsulation to the example of a vehicle. We imagine a real vehicle
    – only one. In such an imaginary vehicle, all internal elements and internal functions
    remain hidden from the driver. It only exposes the functionality it serves, such
    as the steering wheel, which the driver can control. This is the general principle
    of encapsulation. The state of an instance can be changed or updated through exposed
    methods or fields; everything else is hidden from the outside world. It is quite
    a good practice to use methods to modify the inner array or arrays of an instance.
    But we will repeat that later in this book. So far, it’s just a good hint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将封装应用于车辆的例子。我们想象一辆真实的车辆——只有一辆。在这样的想象车辆中，所有内部元素和内部函数都隐藏在驾驶员视线之外。它只暴露其提供的功能，例如方向盘，驾驶员可以控制。这就是封装的一般原则。实例的状态可以通过公开的方法或字段进行更改或更新；其他一切对外界都是隐藏的。使用方法修改实例的内部数组或数组集合是一种相当好的做法。但我们在本书的后面会重复这一点。到目前为止，这只是一个好的提示。
- en: Inevitable evolution – inheritance
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可避免的发展——继承
- en: In the previous section, an instance of an imaginary vehicle class was created.
    We encapsulated all the functions that should not be exposed to the driver. This
    means that the driver may not know how the engine works, only how to use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个想象中的车辆类实例。我们封装了所有不应向驾驶员公开的功能。这意味着驾驶员可能不知道发动机是如何工作的，只知道如何使用它。
- en: This section is devoted to the property of inheritance, which we will demonstrate
    in the following example. Assume that the vehicle’s engine is broken. How can
    we replace it? The goal is to replace the current one with a functional one. An
    engine that works this way may not necessarily be the same, especially if the
    vehicle model already has old parts that are not available on the market.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专门讨论继承属性，我们将在以下示例中展示。假设车辆的发动机损坏了。我们该如何更换它？目标是用一台功能正常的发动机来替换现有的发动机。以这种方式工作的发动机可能并不一定相同，尤其是如果车辆型号已经有一些市场上无法获得的旧部件。
- en: What we do is derived from all the attributes and functions needed to create
    a new engine. Concerning the class, the new replacement module will be a child
    in the class hierarchy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是从创建新发动机所需的所有属性和函数中派生出来的。关于类，新的替换模块将在类层次结构中成为子类。
- en: Although the engine will not be a perfect replica and does not have the same
    unique object identifier, it will match all the parent properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然发动机可能不是完美的复制品，并且没有相同的唯一对象标识符，但它将匹配所有父属性。
- en: With that, we have described the second pillar of inheritance in OOP – the ability
    to create a new class above the existing subclass. However, software designers
    should be wary of the fourth pillar, encapsulation, and any violations caused
    by a subclass depending on the implementation details of its superclass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经描述了面向对象编程中继承的第二大支柱——在现有子类之上创建新类的功能。然而，软件设计师应该警惕第四大支柱——封装，以及子类依赖于其超类实现细节所引起的任何违规行为。
- en: Behavior on demand – polymorphism
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求行为——多态性
- en: The third concept is polymorphism. With a little imagination, this can be understood
    as “many forms.” So, what does that mean here?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个概念是多态性。稍加想象，这可以理解为“多种形式”。那么，这在这里意味着什么呢？
- en: Given the vehicle described previously, it could be defined as the ability to
    perform a particular action in many ways. This would mean, in the context of a
    vehicle, that the movement of the other method, `move`, could happen differently
    based on the inputs or the state of the instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面描述的车辆，它可以定义为以多种方式执行特定动作的能力。这意味着，在车辆的情况下，其他方法`move`的运动可能会根据输入或实例的状态而有所不同。
- en: Java allows for two types of polymorphism, both of which differ in their runtime
    behavior. We will discuss both in detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许两种类型的多态性，它们在运行时行为上有所不同。我们将详细讨论这两种类型。
- en: Method overloading
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'This type is known as static polymorphism. This means that the correct method
    is resolved during program compilation – so, at compile time. Java provides two
    types of method overloads:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型被称为静态多态性。这意味着正确的方法是在程序编译期间解决的——所以，在编译时。Java提供了两种类型的方法重载：
- en: 'Changing the input argument type:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变输入参数类型：
- en: '![Figure 1.4 – Overloading the method of the Vehicle class by changing the
    input types](img/B18884_01_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 通过更改输入类型重载Vehicle类的方法](img/B18884_01_04.jpg)'
- en: Figure 1.4 – Overloading the method of the Vehicle class by changing the input
    types
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 通过更改输入类型重载Vehicle类的方法
- en: 'Changing the number of method arguments:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Overloading the method of the Vehicle class by changing the
    number of arguments](img/B18884_01_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Overloading the method of the Vehicle class by changing the number
    of arguments
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the second type of polymorphism.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is sometimes called dynamic polymorphism. This means that the method performed
    is known at runtime. The overridden method is called through reference to the
    object instance of belongingness. Let us examine a simple example to illustrate
    this. Consider the `Vehicle` class a parent class (see *Figure 1**.6* and *Example
    1.2*) with a method called `move`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – The relation between the overridden move methods for the parent
    and child classes](img/B18884_01_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – The relation between the overridden move methods for the parent
    and child classes
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We intend to create a child class, `Car`, with a similar method named `move`.
    The child provides slightly different functions because the `Car` instance moves
    faster than the parent instance, `Vehicle`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 1.2 – The Vehicle variable holds the reference to the Car instance and
    the appropriate move method is executed at runtime (see Figure 1.6)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We will touch on this topic in more detail in [*Chapter 3*](B18884_03.xhtml#_idTextAnchor093),
    *Working with Creational* *Design Patterns*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Standard features – abstraction
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last letter to cover (but the first letter in the abbreviation APIE) leads
    us to the hitherto unspecified pillar of abstraction. The key to this concept
    is the constant removal of specifics or individual details to achieve the generalization
    of the purpose of the object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: To get the best experience with this concept, let us get into the context with
    the vehicle example. We do not intend to describe a specific car model that belongs
    to a group of vehicles. Our goal is to define a common functionality that all
    types of vehicles under consideration can include in the context of our efforts.
    With such knowledge, we create a suitable abstraction, an abstract class that
    can be inherited later when constructing a particular model class (see *Example
    1.3*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to focus our efforts on generalizing and abstracting
    vehicle characteristics. This can have a positive impact on code reduction and
    reusability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The abstraction in Java can be achieved in two ways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes with abstract methods (see *Example 1.3* and *Figure 1**.7*):'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and
    SportCar classes](img/B18884_01_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and SportCar
    classes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 1.3 – The extraction of the common functionality without providing a
    particular implementation by using an abstract class concept
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Using interfaces (see *Example 1.4* and *Figure 1**.8*) with a generic abstract
    method:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.8 – The abstraction concept achieved by using interfaces](img/B18884_01_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – The abstraction concept achieved by using interfaces
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 1.4 – A similar functionality extraction by using Java interfaces
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Both concepts of abstraction can be combined (see *Figure 1**.9*):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – A combination of both abstraction concepts](img/B18884_01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – A combination of both abstraction concepts
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes and interfaces have their place in the design of code structure.
    Their use depends on demand, but both have a very positive impact on code maintainability
    and help in the use of design patterns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Gluing parts to APIE
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The motivation for each of the pillars mentioned in the previous sections is
    to introduce structure into the code through a given set of concepts. The pillars
    are defined and complementary. Let’s just examine one unit, the `Vehicle` class,
    and its instance. Instance logic and data are encapsulated and exposed through
    methods to the outside world. Vehicle characteristics can be inherited so that
    a new vehicle design, such as a new model, can be specified. Exposed methods can
    provide model-based behavior and incoming arguments with internal instance state
    changes. When crystalizing thoughts about a new vehicle, we can always generalize
    its behavior and extract it using an abstract class or interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the generalization process over the `Vehicle` class development.
    When preparing to define a new vehicle model, we can always generalize its characteristics
    and extract it using an abstract class or interface. Let’s look at the following
    diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – APIE viewed as a continual improvement process](img/B18884_01_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – APIE viewed as a continual improvement process
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Although these four pillars seem trivial, it is incredibly difficult to follow
    them, as we will continue to show in the following sections and chapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: So far in this section, we learned about the four basic pillars of OOP and examined
    how these principles affect code design. Next, we will learn more about sustainable
    code design concepts. Let us roll on to the following section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the SOLID design principles
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, the idea of structured work was introduced. The development
    pillars of APIE were elaborated on in detail using examples. You have gained a
    foundational understanding of the concept of class instances in terms of object-oriented
    principles and how we can create different types of specific objects:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Vehicle N, where N is a positive integer number, represents
    an instance of the Vehicle class](img/B18884_01_11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Vehicle N, where N is a positive integer number, represents an
    instance of the Vehicle class
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Classes can be instantiated so that an instance becomes an object. The object
    must fit into free memory. We say that the object allocates memory space. When
    Java is considered, allocated memory is virtual space inside the physical system’s
    memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以被实例化，使得一个实例成为一个对象。对象必须适应空闲内存。我们说对象分配内存空间。当考虑 Java 时，分配的内存是物理系统内存内的虚拟空间。
- en: Just a small note – we previously discussed the existence of the JVM, an interpreter
    of compiled bytecode for the required platform (see *Figure 1**.3*). We mentioned
    other JVM features, one of which is memory management. In other words, the JVM
    assumes responsibility for allocating virtual memory space. This virtual memory
    space can be used to allocate an instance of a class. This virtual memory and
    its fragmentation are taken care of by the JVM and an unused object cleans up
    the selected garbage collection algorithm, but this is beyond the scope of this
    book and would be the subject of further study (see *Reference 1*).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下 - 我们之前讨论了 JVM 的存在，它是为所需平台编译的字节码的解释器（参见 *图 1.3*）。我们提到了其他 JVM 功能，其中之一是内存管理。换句话说，JVM
    负责分配虚拟内存空间。这个虚拟内存空间可以用来分配一个类的实例。这个虚拟内存及其碎片由 JVM 负责处理，未使用的对象通过选定的垃圾收集算法进行清理，但这超出了本书的范围，将是进一步研究的主题（参见
    *参考文献 1*）。
- en: Every programmer, although it may not be obvious at first glance, plays the
    role of a software designer. The programmer creates the code by writing it. The
    code carries an idea that is semantically transformed into action depending on
    the text entered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员，尽管一开始可能并不明显，都扮演着软件设计师的角色。程序员通过编写代码来创建代码。代码承载着一种思想，这种思想根据输入的文本被语义地转化为行动。
- en: Over time, software development has gone through many phases and many articles
    have been written and published on software maintenance and reusability. One of
    the milestones in software development may be considered the year 2000 when Robert
    C. Martin published his paper on *Design Principles and Design Patterns* (see
    *Reference 2*). The paper reviews and examines techniques in the design and implementation
    of software development. These techniques were later simplified in 2004 into the
    mnemonic acronym SOLID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，软件开发已经经历了许多阶段，许多关于软件维护和可重用性的文章已经被撰写并发表。软件开发的一个里程碑可能被认为是 2000 年，当时罗伯特·C·马丁发表了关于
    *设计原则和设计模式* 的论文（参见 *参考文献 2*）。这篇论文回顾和检查了软件开发设计和实现的技术。这些技术后来在 2004 年被简化为记忆法缩写 SOLID。
- en: The goal of the SOLID principles is to help software designers make software
    and its structure more sustainable, reusable, and extensible. In the following
    sections, we will examine each of the individual terms hidden after the initial
    letter in the abbreviation SOLID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则的目标是帮助软件设计师使软件及其结构更加可持续、可重用和可扩展。在接下来的章节中，我们将检查 SOLID 缩写中隐藏的每个单独的术语。
- en: The single-responsibility principle (SRP) – the engine is just an engine
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP） - 发动机只是一个发动机
- en: 'The first principle is a well-defined class goal. We can say that each class
    should have only one reason to exist. As in, it has the intention and responsibility
    for only one part of the functionality. The class should encapsulate this part
    of the program. Let’s put this in the context of an example. Imagine the previous
    example of a vehicle and its abstraction. We are now extending this class with
    the `Engine` and `VehicleComputer` classes, as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一原则是一个定义良好的类目标。我们可以这样说，每个类应该只有一个存在的理由。也就是说，它只对功能的一部分有意图和责任。这个类应该封装这个程序的部分。让我们用一个例子来说明这一点。想象一下之前的车辆及其抽象的例子。我们现在通过
    `Engine` 和 `VehicleComputer` 类扩展这个类，如下所示：
- en: '![Figure 1.12 – The Vehicle class instance using Engine and VehicleComputer
    realization but an engine functionality does not interfere with the lights](img/B18884_01_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 使用 Engine 和 VehicleComputer 实现的 Vehicle 类实例，但发动机功能不会干扰灯光](img/B18884_01_12.jpg)'
- en: Figure 1.12 – The `Vehicle` class instance using `Engine` and `VehicleComputer`
    realization but an engine functionality does not interfere with the lights
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 使用 `Engine` 和 `VehicleComputer` 实现的 `Vehicle` 类实例，但发动机功能不会干扰灯光
- en: The engine can start and stop, but the instance of the `Engine` class cannot
    control vehicle lights, for example. The light control is the responsibility of
    the vehicle computer class instance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发动机可以启动和停止，但 `Engine` 类的实例不能控制车辆灯光，例如。灯光控制是车辆计算机类实例的责任。
- en: The open-closed principle (OCP)
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则（OCP）
- en: This principle states that the class or entity under consideration should be
    open to extension but closed to modifications. It goes hand in hand with the concepts
    already mentioned. Let’s put this in the context of an example where we consider
    the `Car` and `Truck` classes. Both classes inherit the `Vehicle` interface. Both
    believe that vehicle entities have a `move` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'By not thinking about proper abstraction and without respecting the OCP, code
    can easily bear unexpected difficulties when classes are not easy to reuse or
    cannot be handled (see *Example 1.5*):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 1.5 – Although both are considered entities, Truck and Car inherit a
    Vehicle interface, the move method is compliant, and this causes an issue in extension
    or execution
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The correction of the example at hand is very trivial in this case (see *Example
    1.6*):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 1.6 – The Vehicle interface provides a move abstraction method
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, as code evolves, non-compliance leads to unexpected challenges.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle (LSP) – substitutability of classes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous sections dealt with inheritance and abstraction as two of the
    key pillars of OOP. It will come as no surprise to those of you who have read
    carefully that, given the class hierarchy of parent-child relationships, a child
    may be replaced or represented by its parent and vice versa (see *Example 1.7*).
    Let us look at the example of `CarWash`, where you can wash any vehicle:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 1.7 – A CarWash example where any Vehicle type can be substituted by
    appropriate instances of classes in the class hierarchy
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This means that classes of a similar type can act analogously and replace the
    original class. This statement was first mentioned during a keynote address by
    Barbara Liskov in 1988 (see *Reference 3*). The conference focused on data abstraction
    and hierarchy. The statement was based on the idea of substitutability of class
    instances and interface segregation. Let’s look at interface segregation next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle (ISP)
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This principle states that no instance of a class should be forced to depend
    on methods that are not used or in their abstractions. It also provides instructions
    on how to structure interfaces or abstract classes. In other words, it controls
    how to divide the intended methods into smaller, more specific entities. The client
    could use these entities transparently. To point out a malicious implementation,
    consider `Car` and `Bike` as children of the `Vehicle` interface, which shares
    all the abstract methods (see *Example 1.8*):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 1.8 – Various implementations of inherited method abstraction
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of you with a keen eye will already notice that such a software design
    direction negatively involves software flexibility through unnecessary actions
    that need to be considered (such as exceptions). The remedy is based on compliance
    with the ISP in a very transparent way. Consider two additional interfaces, `HasEngine`
    and `HasPedals`, with their respective functions (see *Example 1.9*). This step
    forces the `printIsMoving` method to overload. The entire code becomes transparent
    to the client and does not require any special treatment to ensure code stability,
    with exceptions as an example (as seen in *Example 1.8*):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 1.9 – The functionality split into smaller units (interfaces) based
    on the purpose
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Two interfaces, `HasEngine` and `HasPedals`, are introduced, which enforce method
    code overload and transparency.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle (DIP)
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every programmer, or rather software designer, will face the challenge of hierarchical
    class composition throughout their careers. The following DIP is a remarkably
    simple guide on how to approach it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle suggests that a low-level class should not know about high-level
    classes. In the opposite direction, this means that the high-level classes, the
    classes that are above, should have no information about the basic classes at
    lower levels (see *Example 1.10*, with the `SportCar` class):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 1.10 – The garage implementation depends on vehicle abstraction, not
    concrete classes in a hierarchy
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: It also means that the implementation of a particular functionality should not
    depend on specific classes, but rather on their abstractions (see *Example 1.10*,
    with the `Garage` class).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Significance of design patterns
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections introduced two complementary approaches to software design
    – APIE and SOLID concepts. It has begun to crystallize that having code in a transparent
    form can be beneficial for a variety of reasons, because every programmer often,
    if not always, faces the challenge of designing a piece of code that extends or
    modifies existing ones.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: One wise man once said, “*The way to Hell is the path of continual technical
    debt ignorance...*.” Anything that slows down or prevents the development of applications
    can be considered a technical debt. Translated into a programming language, this
    would mean that even a small part matters, if not now, then later. It also follows
    that code readability and purpose are crucial to application logic, as it is possible
    to verify various hypotheses (for example, application operation).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The inability to perform business-oriented application testing can be considered
    the first sign of incorrect development trends. It may appear to require the use
    of different mock-up techniques during verification. This approach can easily
    turn into providing false-positive results. This can usually be caused by the
    clutter of the code structure, which forces programmers to use mocks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Although the SOLID and APIE concepts suggest several principles, they still
    do not guarantee that the project code base will not start to rot. Adherence to
    these principles makes it difficult, but there is still room because not all concepts
    provide the required framework for dealing with rot.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: There may be long stories of how software can rot over time, but one fact that
    remains is that there is a cure for avoiding it or letting it go. The cure is
    covered by an idea called **design patterns**. The idea of a design pattern not
    only covers the readability of the code base and its purpose but also advances
    the ability to verify required business hypotheses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: What are the ideas behind defining it to get more clarity? The design pattern
    idea can be described as a set of reusable coding approaches that solve the most
    common problems encountered during application development. These approaches are
    in line with the previously mentioned APIE or SOLID concepts and have an incredibly
    positive impact on bringing transparency, readability, and testability to the
    development path. Simply put, the idea of design patterns provides a framework
    for accessing common challenges in software design.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing what challenges design patterns solve
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a deep breath and think about the motivation for writing the program. The
    program is written in a programming language, in our case, Java, and is a human-readable
    form to address a specific challenge. Let’s look at it from a different perspective.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We can state that writing a program is considered a goal. The goal has its reason
    defined by known needs or requirements in most cases. Expectations and limitations
    are defined. When the goal is known, each action is chosen with the aim of achieving
    it. The goal is evaluated, organized, and placed in the context of the destination,
    where the destination means a work program addressing the required challenge.
    Imagine all the difficulties mentioned in the previous sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Day after day, a new solution is posed, instead of a transparent solution. Every
    day, another local success keeps the project afloat, despite everything looking
    good on the surface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, most teams follow the SCRUM framework. Imagine a situation where
    the team follows the SCRUM framework (see *Reference 4*) and application development
    begins to deviate from the goal. Daily standup meetings run smoothly from time
    to time: it is mentioned that a fundamental error has been found. A few days later,
    the bug is successfully fixed with great applause. Interestingly, the frequency
    of such notifications is growing – more corrections, more applause. But does this
    really mean that the project is moving towards its goal? Does this mean that the
    application works? Let’s look at the answer.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There is a darker side – the backlog is growing with features and technical
    debt. Technical debt is not necessarily a terrible thing. Technical debt can stimulate
    the project and can be especially useful in the concept validation phase. The
    problem with technical debt occurs when it is not recognized, ignored, and poorly
    evaluated – even worse when technical debt starts being labeled as new features.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Although the product backlog should be one entity, it begins to consist of two
    different and unfortunately incompatible parts – the business and the sprint backlog
    (mostly technical debt). Of course, the team is working on a sprint backlog that
    comes from planning meetings, but with increasing technical debt, there is less
    and less room for the relevant business functions of the product. The trends observed
    in this way can result in extremely tricky situations during each new sprint planning
    session, where the development resources should be allocated. Let’s stop for a
    moment and recall this situation where the team cannot move the product forward
    due to technical debt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The values of the SCRUM methodology can be simplified to courage, concentration,
    determination, respect, and openness. These values are not specific to the SCRUM
    framework. Because the team’s motivation is to deliver the product, they all sound
    very logical and fair.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We will now refresh our memory of the state the team has achieved. A state where
    it cannot move the project forward and struggles with the definition and proper
    consolidation of technical departments. This means that the team is doing its
    job, but may deviate from achieving its ultimate goal. Every discussion is extremely
    difficult because it is difficult to solve and describe the problem correctly
    for many different reasons. It may seem that developers may lose their language
    of communication and begin to misunderstand each other. We can see that the entropy
    of the software has increased because the coherence is not maintained. The project
    is beginning to rot and convergence to the inevitable wasted development time
    increases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take another deep breath and think together about how to prevent such
    a situation. It must be possible to identify these tendencies. Usually, each team
    has some commonality: the team is not always homogeneous in terms of knowledge,
    but this should not prevent us from identifying the degradation of the learning
    curve.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The project learning curve can help us identify a rotting project. Instead of
    gradual improvements towards the goal, the team experiences local successes full
    of technical repairs and solutions. Such successes do not even correspond to the
    values of SCRUM and gradual improvement seems unlikely. The solution may not be
    considered an improvement because it is specific to a particular movement and
    may violate the specifications of the technology used. During the solution period,
    the team may not acquire any useful knowledge applicable to the future. This can
    soon be considered a missing business opportunity due to the inability to supply
    business elements or only parts of them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the degradation of the learning curve, other symptoms can be
    identified. This can be described as an inability to test a business function.
    Project code is proving sticky, dependencies are out of control, which can also
    harm code readability, testability, and, of course, programmer discipline. The
    daily goal of the software designer can be reduced to closing a ticket.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To avoid getting to this state, this book will provide some guidelines for solving
    the most common problems in the following chapters by introducing and questioning
    different types of design patterns. The design patterns are in line with the aforementioned
    basic pillars of OOP and APIE and promote the principles of SOLID.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: What’s more, design patterns can highlight any misunderstood directions and
    enforce the **don’t repeat yourself** (**DRY**) principle. As a result, there
    is much less duplication, code testability, and more fun on the project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we embark on the journey of researching design patterns, let us quickly
    summarize. This chapter has expanded or improved our understanding of various
    areas. Each of these areas affects program code from different perspectives:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Code transparency and readability
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to solve complex challenges
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following SOLID and OOP principles
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code testability (it’s possible to verify the purpose of the code)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to extend and modify
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting continual refactoring
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is self-explanatory
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program code is written – well done. The next chapter will take us through
    a survey of the implementation platform – in our case, the Java platform. We will
    learn in more detail how and what it means to run a program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What interprets the Java code to the platform and how?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the acronym APIE represent?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of polymorphism does the Java language allow?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What principle helps software designers to produce maintainable code?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the OCP mean?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should be considered about design patterns?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Garbage Collection Handbook: The Art of Automatic Memory Management*,
    Anthony Hosking, J. Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791,
    ISBN-10: 9781420082791, 1996.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns*, Robert C. Martin, Object Mentor, 2000.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Keynote address - data abstraction and hierarchy*, Barbara Liskov, [https://dl.acm.org/doi/10.1145/62139.62141](https://dl.acm.org/doi/10.1145/62139.62141),
    1988.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SCRUM framework, [https://www.scrum.org/](https://www.scrum.org/), 2022\.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
