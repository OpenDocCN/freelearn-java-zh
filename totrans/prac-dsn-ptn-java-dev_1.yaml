- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting into Software Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入软件设计模式
- en: Every software architect or developer often faces the challenges of structuring
    code – how to develop a code structure that remains sustainable, just as an artist
    draws their painting. This chapter will take us on a journey into writing program
    code. You will explore the challenges behind the structure of code and its organization.
    Together, we will approach the topic from an early stage described by the pillars
    of object-oriented programming, known as APIE. We will also review the principles
    of SOLID to gain clarity in understanding design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件架构师或开发者通常都会面临结构化代码的挑战——如何开发一个可持续的代码结构，就像艺术家绘制他们的画作一样。本章将带我们进入编写程序代码的旅程。您将探索代码结构和组织背后的挑战。我们将从面向对象编程的支柱——APIE的早期阶段开始探讨这个主题。我们还将回顾SOLID原则，以获得对设计模式的理解清晰。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Code – from symbols to program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码——从符号到程序
- en: Examining OOP and APIE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查面向对象编程和APIE
- en: Understanding the SOLID design principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SOLID设计原则
- en: The significance of design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的重要性
- en: Reviewing what challenges design patterns solve
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾设计模式解决的问题
- en: By the end of this chapter, you will have reviewed the basic programming concepts,
    which will form the basis of the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将回顾基本的编程概念，这些概念将构成本书其余部分的基础。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01)。
- en: Code – from symbols to program
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码——从符号到程序
- en: Human speech is fruitful, rich, colorful, and way beyond what the words themselves
    may express. Nouns, verbs, and adjectives for precisely expressing a moment or
    action can be used. In contrast, machines do not understand the complex constructions
    or expressions that humans are able to create.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言是富有成效的、丰富的、多彩的，远远超出了单词本身可能表达的内容。可以用名词、动词和形容词来精确地表达一个时刻或动作。相比之下，机器不能理解人类能够创造出的复杂结构或表达。
- en: Machine language is limited, well-defined, extremely specific, and simplified.
    Its goal is to provide the precise expression of intent for which it is designed.
    This contrasts with human language whose purpose is just communication and not
    necessarily with specifics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 机器语言是有限的、定义明确的、极其具体的，并且是简化的。它的目标是提供精确的表达意图，这正是它被设计的目的。这与人类语言的目的形成对比，人类语言的目的仅仅是沟通，而不一定是具体的内容。
- en: 'A machine’s intent can be expressed as a defined instruction or a set of them.
    This means that machines understand the instructions. These instructions must
    be available to the machine in some form at the time of execution. Each machine
    normally has a set of instructions. Based on this kind of instruction set, machines
    can perform the required instructions, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 机器的意图可以通过定义明确的指令或一系列指令来表达。这意味着机器理解这些指令。这些指令必须在执行时以某种形式提供给机器。每种机器通常都有一组指令。基于这种指令集，机器可以执行所需的指令，如下所示：
- en: "![Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is\
    \ taken from memory and the result is stored\uFEFF)](img/B18884_01_01.jpg)"
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – CPU内部的简化指令周期（指令来自内存，结果存储在其中）](img/B18884_01_01.jpg)'
- en: Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is taken
    from memory and the result is stored)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – CPU内部的简化指令周期（指令来自内存，结果存储）
- en: Let us explore one individual instruction. The instruction can be understood
    as a command given to the processor. The processor is the heart of the machine,
    or the center of the ordering and executing of processes. The machine may contain
    one or more of them. It depends on its design, but in any case, there is always
    one that takes the lead. For further simplification, we will only consider one
    – that is, consider a system that only has one **central processing unit** (**CPU**)
    dedicated to executing a program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一条单独的指令。指令可以被理解为给处理器的命令。处理器是机器的心脏，或者说是过程排序和执行的中心。机器可能包含一个或多个处理器。这取决于其设计，但无论如何，总有一个起主导作用。为了进一步简化，我们只考虑一个——也就是说，考虑一个只有**中央处理单元**（**CPU**）的系统，该系统专门用于执行程序。
- en: A CPU is a device that executes instructions containing a computer program.
    The CPU must contain such an instruction set, as shown in the previous diagram,
    to process the requested action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CPU是一种执行包含计算机程序指令的设备。CPU必须包含如前图所示的指令集，以处理请求的操作。
- en: Because instructions can take completely different forms depending on the CPU,
    there is no defined standard. This promotes different CPU platforms, which is
    not necessarily a bad thing and contributes to evolution. However, the fact remains
    that the instructions are not easy for people to read.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令的形式可能完全不同，取决于CPU，因此没有定义的标准。这促进了不同的CPU平台，这并不一定是坏事，并有助于进化。然而，事实仍然是，指令对人们来说不易阅读。
- en: We have stated that machines can perform instruction collection, ideally as
    a continuous flow. The flow of instructions can be simplified as a queue in memory,
    where one instruction goes in and the other leaves. The CPU plays the role of
    an interpreter who works with this memory cyclically (as we saw in *Figure 1**.1*).
    Okay, so the CPU interprets, but as the instructions are added to the memory,
    where do they come from, and how can such a stream be created?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，机器可以执行指令集合，理想情况下是一个连续的流程。指令的流程可以简化为内存中的队列，其中一条指令进入，另一条离开。CPU扮演着与这种内存循环工作的解释者的角色（正如我们在*图1.1*中看到的）。好的，所以CPU进行了解释，但随着指令被添加到内存中，它们从何而来，如何创建这样的流？
- en: Let us gather some thoughts. Machine instructions, in most cases, originate
    from a compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们收集一些想法。在大多数情况下，机器指令来自编译器。
- en: 'What is a compiler? The compiler can be viewed as a CPU or a platform-specific
    program that translates text into target actions. The text we use to call the
    program and the result could be named machine code. The following diagram illustrates
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是编译器？编译器可以看作是一个CPU或特定平台的程序，它将文本转换为目标操作。我们用来调用程序和结果的文本可以命名为机器码。以下图示说明了这一点：
- en: '![Figure 1.2 – A simplified platform-specific flow from the source code through
    the compiler program to its resultant action](img/B18884_01_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 从源代码通过编译器程序到其结果的简化平台特定流程](img/B18884_01_02.jpg)'
- en: Figure 1.2 – A simplified platform-specific flow from the source code through
    the compiler program to its resultant action
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 从源代码通过编译器程序到其结果的简化平台特定流程
- en: Machine code is a low-level language that the machine understands and consists
    of language instructions that are processed sequentially (see *Figure 1**.1*);
    the program was compiled, executed, and run.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 机器码是机器理解的一种低级语言，由按顺序处理的指令组成（见*图1.1*）；程序被编译、执行和运行。
- en: 'In the case of Java, there is no machine code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的情况下，没有机器码：
- en: '![Figure 1.3 – A simplified flow for the Java program through the compiler
    to its platform execution](img/B18884_01_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – Java程序通过编译器到其平台执行的简化流程](img/B18884_01_03.jpg)'
- en: Figure 1.3 – A simplified flow for the Java program through the compiler to
    its platform execution
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – Java程序通过编译器到其平台执行的简化流程
- en: The source code is compiled by the Java compiler into bytecode. The bytecode
    is running a **Java virtual machine** (**JVM**) (see *Figure 1**.3*). In this
    situation, the JVM plays the role of the interface between the bytecode and the
    actual instructions that are executed on the CPU. The JVM emulates a bytecode
    instruction. It does this using the **just-in-time** (**JIT**) compiler that is
    part of the JVM. The JIT compiler translates bytecode instructions into native
    processor instructions. The JVM is a platform-specific interpreter, analogous
    to directly compiled code (see *Figure 1**.2*). The JVM also provides additional
    features such as memory management and garbage collection, which is what makes
    the Java platform so powerful. All these features allow developers to write code
    once, compile it into bytecode, and run a supported platform – known as **write
    once, run** **anywhere** (**WORA**).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码由Java编译器编译成字节码。字节码运行在**Java虚拟机**（**JVM**）中（见*图1.3*）。在这种情况下，JVM充当字节码和CPU上实际执行指令之间的接口。JVM模拟字节码指令。它通过JVM的一部分**即时编译器**（**JIT**）来完成这项工作。JIT编译器将字节码指令转换为本地处理器指令。JVM是一个特定平台的解释器，类似于直接编译的代码（见*图1.2*）。JVM还提供了额外的功能，如内存管理和垃圾回收，这使得Java平台如此强大。所有这些功能都允许开发者一次编写代码，编译成字节码，并在支持的平台上运行——这被称为**一次编写，到处运行**（**WORA**）。
- en: In the context of the previous exploration, Java is a high-level language that
    is translated to a low level. Java provides a strong abstraction from the details
    of computer functionality. It allows programmers to create simpler programs for
    complex challenges.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一次探索的背景下，Java是一种高级语言，它被翻译成低级语言。Java提供了从计算机功能细节中的强大抽象。它允许程序员为复杂挑战创建更简单的程序。
- en: At this point, we begin our journey of jointly exploring standardized solutions.
    Later in the book, we will review how to create code that is maintainable and
    extensible with fewer memory requirements. Together, we will discuss different
    types of design patterns that can help us to make our daily work understandable,
    transparent, and more fun.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们开始共同探索标准化解决方案的旅程。在本书的后面部分，我们将回顾如何创建具有较少内存需求的可维护和可扩展的代码。我们将一起讨论不同类型的设计模式，这些模式可以帮助我们使日常工作变得可理解、透明，并且更有趣。
- en: Examining OOP and APIE
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查面向对象编程（OOP）和APIE
- en: In the previous section, we learned how a program written in one of the high-level
    languages is converted into machine instructions that are processed by the CPU.
    The high-level language provides a framework for expressing the desired ideas
    by following the details of the language implementation. Such languages commonly
    provide many neat constructions or statements that do not limit the imagination.
    In **object-oriented programming** (**OOP**) language, the representation of the
    core carrier is presented by the concept of the object. This book focuses on the
    Java language. Java is a fully object-oriented language with additional features.
    What does object-oriented language mean exactly? In computer science, this means
    that the program focuses on the concept of classes, where instances of these classes
    represent an object. Next, we will repeat the importance of the OOP paradigm and
    deal with some basic concepts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将用高级语言编写的程序转换成由CPU处理的机器指令。高级语言通过遵循语言实现的细节来提供一个表达所需想法的框架。这些语言通常提供许多整洁的结构或语句，这些结构或语句不会限制想象力。在**面向对象编程**（**OOP**）语言中，核心载体的表示是通过对象的概念来呈现的。本书专注于Java语言。Java是一种具有额外功能的完全面向对象的语言。面向对象语言究竟意味着什么？在计算机科学中，这意味着程序关注类的概念，其中这些类的实例代表一个对象。接下来，我们将重复OOP范式的重点，并处理一些基本概念。
- en: These terms can be expressed by the abbreviation of **abstraction, polymorphism,
    inheritance, and encapsulation** (**APIE**). The letters APIE indicate the four
    basic pillars of OOP languages. Let’s examine each word in a separate section
    in reverse order – so, EIPA. The motivation is to bring more clarity to our understanding
    of the concept of OOP.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语可以用**抽象、多态、继承和封装**（**APIE**）的缩写来表示。APIE字母表示OOP语言的四个基本支柱。让我们按相反的顺序分别检查每个词
    - 因此，EIPA。动机是为了使我们对OOP概念的理解更加清晰。
- en: Only exposing what’s required – encapsulation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只暴露所需的内容 - 封装
- en: 'The first in reverse order is encapsulation – let’s start with it. OOP languages,
    including Java, work with the concept of classes. Imagine that a class is a vehicle.
    The class provides all the fields that can be statically typed or object-specific
    – that is, initiated after an object is instantiated in the allocated memory.
    The concept is similar with respect to class or object methods. The method may
    belong to a class or its instance – in the considered example, to a vehicle. Any
    method can work over an object or class field and change the internal state of
    the vehicle or the field values (see *Example 1.1*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相反的顺序，首先是封装 - 让我们从它开始。面向对象的语言，包括Java，与类这一概念一起工作。想象一下，一个类就像一辆车。类提供了所有可以静态类型或对象特定的字段
    - 也就是说，在对象在分配的内存中实例化之后启动。在类或对象方法的概念上，这一概念是相似的。方法可能属于一个类或其实例 - 在考虑的例子中，属于一辆车。任何方法都可以在对象或类字段上工作，并改变车辆的内部状态或字段值（见
    *示例 1.1*）：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 1.1 – The Vehicle class hides an internal state (moving)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.1 - 车辆类隐藏内部状态（移动）
- en: We can apply encapsulation to the example of a vehicle. We imagine a real vehicle
    – only one. In such an imaginary vehicle, all internal elements and internal functions
    remain hidden from the driver. It only exposes the functionality it serves, such
    as the steering wheel, which the driver can control. This is the general principle
    of encapsulation. The state of an instance can be changed or updated through exposed
    methods or fields; everything else is hidden from the outside world. It is quite
    a good practice to use methods to modify the inner array or arrays of an instance.
    But we will repeat that later in this book. So far, it’s just a good hint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将封装应用于车辆的例子。我们想象一辆真实的车辆——只有一辆。在这样的想象车辆中，所有内部元素和内部函数都隐藏在驾驶员视线之外。它只暴露其提供的功能，例如方向盘，驾驶员可以控制。这就是封装的一般原则。实例的状态可以通过公开的方法或字段进行更改或更新；其他一切对外界都是隐藏的。使用方法修改实例的内部数组或数组集合是一种相当好的做法。但我们在本书的后面会重复这一点。到目前为止，这只是一个好的提示。
- en: Inevitable evolution – inheritance
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可避免的发展——继承
- en: In the previous section, an instance of an imaginary vehicle class was created.
    We encapsulated all the functions that should not be exposed to the driver. This
    means that the driver may not know how the engine works, only how to use it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个想象中的车辆类实例。我们封装了所有不应向驾驶员公开的功能。这意味着驾驶员可能不知道发动机是如何工作的，只知道如何使用它。
- en: This section is devoted to the property of inheritance, which we will demonstrate
    in the following example. Assume that the vehicle’s engine is broken. How can
    we replace it? The goal is to replace the current one with a functional one. An
    engine that works this way may not necessarily be the same, especially if the
    vehicle model already has old parts that are not available on the market.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专门讨论继承属性，我们将在以下示例中展示。假设车辆的发动机损坏了。我们该如何更换它？目标是用一台功能正常的发动机来替换现有的发动机。以这种方式工作的发动机可能并不一定相同，尤其是如果车辆型号已经有一些市场上无法获得的旧部件。
- en: What we do is derived from all the attributes and functions needed to create
    a new engine. Concerning the class, the new replacement module will be a child
    in the class hierarchy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是从创建新发动机所需的所有属性和函数中派生出来的。关于类，新的替换模块将在类层次结构中成为子类。
- en: Although the engine will not be a perfect replica and does not have the same
    unique object identifier, it will match all the parent properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然发动机可能不是完美的复制品，并且没有相同的唯一对象标识符，但它将匹配所有父属性。
- en: With that, we have described the second pillar of inheritance in OOP – the ability
    to create a new class above the existing subclass. However, software designers
    should be wary of the fourth pillar, encapsulation, and any violations caused
    by a subclass depending on the implementation details of its superclass.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经描述了面向对象编程中继承的第二大支柱——在现有子类之上创建新类的功能。然而，软件设计师应该警惕第四大支柱——封装，以及子类依赖于其超类实现细节所引起的任何违规行为。
- en: Behavior on demand – polymorphism
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求行为——多态性
- en: The third concept is polymorphism. With a little imagination, this can be understood
    as “many forms.” So, what does that mean here?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个概念是多态性。稍加想象，这可以理解为“多种形式”。那么，这在这里意味着什么呢？
- en: Given the vehicle described previously, it could be defined as the ability to
    perform a particular action in many ways. This would mean, in the context of a
    vehicle, that the movement of the other method, `move`, could happen differently
    based on the inputs or the state of the instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面描述的车辆，它可以定义为以多种方式执行特定动作的能力。这意味着，在车辆的情况下，其他方法`move`的运动可能会根据输入或实例的状态而有所不同。
- en: Java allows for two types of polymorphism, both of which differ in their runtime
    behavior. We will discuss both in detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许两种类型的多态性，它们在运行时行为上有所不同。我们将详细讨论这两种类型。
- en: Method overloading
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'This type is known as static polymorphism. This means that the correct method
    is resolved during program compilation – so, at compile time. Java provides two
    types of method overloads:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型被称为静态多态性。这意味着正确的方法是在程序编译期间解决的——所以，在编译时。Java提供了两种类型的方法重载：
- en: 'Changing the input argument type:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变输入参数类型：
- en: '![Figure 1.4 – Overloading the method of the Vehicle class by changing the
    input types](img/B18884_01_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 通过更改输入类型重载Vehicle类的方法](img/B18884_01_04.jpg)'
- en: Figure 1.4 – Overloading the method of the Vehicle class by changing the input
    types
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 通过更改输入类型重载Vehicle类的方法
- en: 'Changing the number of method arguments:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变方法参数的数量：
- en: '![Figure 1.5 – Overloading the method of the Vehicle class by changing the
    number of arguments](img/B18884_01_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 通过改变参数数量来重载Vehicle类的方法](img/B18884_01_05.jpg)'
- en: Figure 1.5 – Overloading the method of the Vehicle class by changing the number
    of arguments
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 通过改变参数数量来重载Vehicle类的方法
- en: Now, let’s look at the second type of polymorphism.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看多态的第二种类型。
- en: Method overriding
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重写
- en: 'This is sometimes called dynamic polymorphism. This means that the method performed
    is known at runtime. The overridden method is called through reference to the
    object instance of belongingness. Let us examine a simple example to illustrate
    this. Consider the `Vehicle` class a parent class (see *Figure 1**.6* and *Example
    1.2*) with a method called `move`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被称为动态多态。这意味着执行的方法在运行时已知。重写的方法通过引用属于该对象实例的引用来调用。让我们通过一个简单的例子来说明这一点。考虑一个父类`Vehicle`（参见*图
    1**.6*和*示例 1.2*）中名为`move`的方法：
- en: '![Figure 1.6 – The relation between the overridden move methods for the parent
    and child classes](img/B18884_01_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 父类和子类重写move方法之间的关系](img/B18884_01_06.jpg)'
- en: Figure 1.6 – The relation between the overridden move methods for the parent
    and child classes
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 父类和子类重写move方法之间的关系
- en: 'We intend to create a child class, `Car`, with a similar method named `move`.
    The child provides slightly different functions because the `Car` instance moves
    faster than the parent instance, `Vehicle`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算创建一个子类`Car`，具有类似名称的`move`方法。子类提供略微不同的功能，因为`Car`实例比父实例`Vehicle`移动得更快：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 1.2 – The Vehicle variable holds the reference to the Car instance and
    the appropriate move method is executed at runtime (see Figure 1.6)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.2 – Vehicle变量持有Car实例的引用，并在运行时执行适当的move方法（参见图 1.6）
- en: We will touch on this topic in more detail in [*Chapter 3*](B18884_03.xhtml#_idTextAnchor093),
    *Working with Creational* *Design Patterns*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 3 章*](B18884_03.xhtml#_idTextAnchor093)中更详细地讨论这个主题，*使用创建型设计模式*。
- en: Standard features – abstraction
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准特性 – 抽象
- en: The last letter to cover (but the first letter in the abbreviation APIE) leads
    us to the hitherto unspecified pillar of abstraction. The key to this concept
    is the constant removal of specifics or individual details to achieve the generalization
    of the purpose of the object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要覆盖的字母（但在缩写APIE中的第一个字母）引导我们到达迄今为止未指定的抽象支柱。这个概念的关键是不断去除具体或个别细节，以达到对象目的的泛化。
- en: To get the best experience with this concept, let us get into the context with
    the vehicle example. We do not intend to describe a specific car model that belongs
    to a group of vehicles. Our goal is to define a common functionality that all
    types of vehicles under consideration can include in the context of our efforts.
    With such knowledge, we create a suitable abstraction, an abstract class that
    can be inherited later when constructing a particular model class (see *Example
    1.3*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这个概念的最佳体验，让我们以车辆为例来探讨这个背景。我们并不打算描述属于一组车辆的具体汽车型号。我们的目标是定义一个所有考虑的车辆类型都可以在我们的努力中包含的通用功能。有了这样的知识，我们创建一个合适的抽象，一个可以在构建特定模型类时继承的抽象类（参见*示例
    1.3*）。
- en: This approach allows us to focus our efforts on generalizing and abstracting
    vehicle characteristics. This can have a positive impact on code reduction and
    reusability.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使我们能够将精力集中在泛化和抽象车辆特性上。这可以对我们减少代码和提高可重用性产生积极影响。
- en: 'The abstraction in Java can be achieved in two ways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可以通过两种方式实现抽象：
- en: 'Abstract classes with abstract methods (see *Example 1.3* and *Figure 1**.7*):'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有抽象方法的抽象类（参见*示例 1.3*和*图 1**.7*）：
- en: '![Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and
    SportCar classes](img/B18884_01_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 带有CommonCar实现和SportCar类的AbstractVehicle类](img/B18884_01_07.jpg)'
- en: Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and SportCar
    classes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 带有CommonCar实现和SportCar类的AbstractVehicle类
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 1.3 – The extraction of the common functionality without providing a
    particular implementation by using an abstract class concept
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1.3 – 使用抽象类概念提取通用功能，而不提供特定的实现
- en: 'Using interfaces (see *Example 1.4* and *Figure 1**.8*) with a generic abstract
    method:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口（参见*示例 1.4*和*图 1**.8*）和通用抽象方法：
- en: '![Figure 1.8 – The abstraction concept achieved by using interfaces](img/B18884_01_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 使用接口实现的抽象概念](img/B18884_01_08.jpg)'
- en: Figure 1.8 – The abstraction concept achieved by using interfaces
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 使用接口实现的抽象概念
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 1.4 – A similar functionality extraction by using Java interfaces
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.4 – 使用Java接口进行类似的功能提取
- en: 'Both concepts of abstraction can be combined (see *Figure 1**.9*):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种抽象概念可以结合使用（见图*1.9*）：
- en: '![Figure 1.9 – A combination of both abstraction concepts](img/B18884_01_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 两种抽象概念的组合](img/B18884_01_09.jpg)'
- en: Figure 1.9 – A combination of both abstraction concepts
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 两种抽象概念的组合
- en: Abstract classes and interfaces have their place in the design of code structure.
    Their use depends on demand, but both have a very positive impact on code maintainability
    and help in the use of design patterns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类和接口在代码结构的设计中都有其位置。它们的使用取决于需求，但两者都对代码的可维护性产生了非常积极的影响，并有助于设计模式的使用。
- en: Gluing parts to APIE
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将部分粘接到APIE
- en: The motivation for each of the pillars mentioned in the previous sections is
    to introduce structure into the code through a given set of concepts. The pillars
    are defined and complementary. Let’s just examine one unit, the `Vehicle` class,
    and its instance. Instance logic and data are encapsulated and exposed through
    methods to the outside world. Vehicle characteristics can be inherited so that
    a new vehicle design, such as a new model, can be specified. Exposed methods can
    provide model-based behavior and incoming arguments with internal instance state
    changes. When crystalizing thoughts about a new vehicle, we can always generalize
    its behavior and extract it using an abstract class or interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节提到的每个支柱的动机是通过一组给定的概念将结构引入代码。这些支柱是定义明确的且相互补充的。让我们仅考察一个单元，即`Vehicle`类及其实例。实例逻辑和数据通过方法封装并暴露给外部世界。车辆特性可以继承，以便可以指定新的车辆设计，例如新车型。公开的方法可以提供基于模型的行为和传入参数的内部实例状态变化。当我们对新的车辆进行概念化时，我们总能概括其行为并使用抽象类或接口提取它。
- en: 'Let us examine the generalization process over the `Vehicle` class development.
    When preparing to define a new vehicle model, we can always generalize its characteristics
    and extract it using an abstract class or interface. Let’s look at the following
    diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察`Vehicle`类开发中的泛化过程。当准备定义新的车辆模型时，我们总能概括其特性并使用抽象类或接口提取它。让我们看一下以下图表：
- en: '![Figure 1.10 – APIE viewed as a continual improvement process](img/B18884_01_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 将APIE视为一个持续改进的过程](img/B18884_01_10.jpg)'
- en: Figure 1.10 – APIE viewed as a continual improvement process
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 将APIE视为一个持续改进的过程
- en: Although these four pillars seem trivial, it is incredibly difficult to follow
    them, as we will continue to show in the following sections and chapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这四个支柱看似微不足道，但遵循它们是极其困难的，正如我们将在以下章节中继续展示的那样。
- en: So far in this section, we learned about the four basic pillars of OOP and examined
    how these principles affect code design. Next, we will learn more about sustainable
    code design concepts. Let us roll on to the following section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们学习了OOP的四个基本支柱，并考察了这些原则如何影响代码设计。接下来，我们将学习更多关于可持续代码设计概念的知识。让我们继续到下一节。
- en: Understanding the SOLID design principles
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SOLID设计原则
- en: 'In the previous sections, the idea of structured work was introduced. The development
    pillars of APIE were elaborated on in detail using examples. You have gained a
    foundational understanding of the concept of class instances in terms of object-oriented
    principles and how we can create different types of specific objects:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们介绍了结构化工作的概念。通过示例详细阐述了APIE的开发支柱。您已经对面向对象原则中的类实例概念有了基础的理解，以及我们如何创建不同类型的特定对象：
- en: '![Figure 1.11 – Vehicle N, where N is a positive integer number, represents
    an instance of the Vehicle class](img/B18884_01_11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – 车辆N，其中N是一个正整数，代表车辆类的一个实例](img/B18884_01_11.jpg)'
- en: Figure 1.11 – Vehicle N, where N is a positive integer number, represents an
    instance of the Vehicle class
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 车辆N，其中N是一个正整数，代表车辆类的一个实例
- en: Classes can be instantiated so that an instance becomes an object. The object
    must fit into free memory. We say that the object allocates memory space. When
    Java is considered, allocated memory is virtual space inside the physical system’s
    memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以被实例化，使得一个实例成为一个对象。对象必须适应空闲内存。我们说对象分配内存空间。当考虑 Java 时，分配的内存是物理系统内存内的虚拟空间。
- en: Just a small note – we previously discussed the existence of the JVM, an interpreter
    of compiled bytecode for the required platform (see *Figure 1**.3*). We mentioned
    other JVM features, one of which is memory management. In other words, the JVM
    assumes responsibility for allocating virtual memory space. This virtual memory
    space can be used to allocate an instance of a class. This virtual memory and
    its fragmentation are taken care of by the JVM and an unused object cleans up
    the selected garbage collection algorithm, but this is beyond the scope of this
    book and would be the subject of further study (see *Reference 1*).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下 - 我们之前讨论了 JVM 的存在，它是为所需平台编译的字节码的解释器（参见 *图 1.3*）。我们提到了其他 JVM 功能，其中之一是内存管理。换句话说，JVM
    负责分配虚拟内存空间。这个虚拟内存空间可以用来分配一个类的实例。这个虚拟内存及其碎片由 JVM 负责处理，未使用的对象通过选定的垃圾收集算法进行清理，但这超出了本书的范围，将是进一步研究的主题（参见
    *参考文献 1*）。
- en: Every programmer, although it may not be obvious at first glance, plays the
    role of a software designer. The programmer creates the code by writing it. The
    code carries an idea that is semantically transformed into action depending on
    the text entered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员，尽管一开始可能并不明显，都扮演着软件设计师的角色。程序员通过编写代码来创建代码。代码承载着一种思想，这种思想根据输入的文本被语义地转化为行动。
- en: Over time, software development has gone through many phases and many articles
    have been written and published on software maintenance and reusability. One of
    the milestones in software development may be considered the year 2000 when Robert
    C. Martin published his paper on *Design Principles and Design Patterns* (see
    *Reference 2*). The paper reviews and examines techniques in the design and implementation
    of software development. These techniques were later simplified in 2004 into the
    mnemonic acronym SOLID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，软件开发已经经历了许多阶段，许多关于软件维护和可重用性的文章已经被撰写并发表。软件开发的一个里程碑可能被认为是 2000 年，当时罗伯特·C·马丁发表了关于
    *设计原则和设计模式* 的论文（参见 *参考文献 2*）。这篇论文回顾和检查了软件开发设计和实现的技术。这些技术后来在 2004 年被简化为记忆法缩写 SOLID。
- en: The goal of the SOLID principles is to help software designers make software
    and its structure more sustainable, reusable, and extensible. In the following
    sections, we will examine each of the individual terms hidden after the initial
    letter in the abbreviation SOLID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 原则的目标是帮助软件设计师使软件及其结构更加可持续、可重用和可扩展。在接下来的章节中，我们将检查 SOLID 缩写中隐藏的每个单独的术语。
- en: The single-responsibility principle (SRP) – the engine is just an engine
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP） - 发动机只是一个发动机
- en: 'The first principle is a well-defined class goal. We can say that each class
    should have only one reason to exist. As in, it has the intention and responsibility
    for only one part of the functionality. The class should encapsulate this part
    of the program. Let’s put this in the context of an example. Imagine the previous
    example of a vehicle and its abstraction. We are now extending this class with
    the `Engine` and `VehicleComputer` classes, as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一原则是一个定义良好的类目标。我们可以这样说，每个类应该只有一个存在的理由。也就是说，它只对功能的一部分有意图和责任。这个类应该封装这个程序的部分。让我们用一个例子来说明这一点。想象一下之前的车辆及其抽象的例子。我们现在通过
    `Engine` 和 `VehicleComputer` 类扩展这个类，如下所示：
- en: '![Figure 1.12 – The Vehicle class instance using Engine and VehicleComputer
    realization but an engine functionality does not interfere with the lights](img/B18884_01_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 使用 Engine 和 VehicleComputer 实现的 Vehicle 类实例，但发动机功能不会干扰灯光](img/B18884_01_12.jpg)'
- en: Figure 1.12 – The `Vehicle` class instance using `Engine` and `VehicleComputer`
    realization but an engine functionality does not interfere with the lights
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 使用 `Engine` 和 `VehicleComputer` 实现的 `Vehicle` 类实例，但发动机功能不会干扰灯光
- en: The engine can start and stop, but the instance of the `Engine` class cannot
    control vehicle lights, for example. The light control is the responsibility of
    the vehicle computer class instance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 发动机可以启动和停止，但 `Engine` 类的实例不能控制车辆灯光，例如。灯光控制是车辆计算机类实例的责任。
- en: The open-closed principle (OCP)
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则（OCP）
- en: This principle states that the class or entity under consideration should be
    open to extension but closed to modifications. It goes hand in hand with the concepts
    already mentioned. Let’s put this in the context of an example where we consider
    the `Car` and `Truck` classes. Both classes inherit the `Vehicle` interface. Both
    believe that vehicle entities have a `move` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，正在考虑的类或实体应该是开放的，可以扩展，但对修改应该是封闭的。它与已经提到的概念相辅相成。让我们以一个例子来阐述这一点，在这个例子中，我们考虑`Car`和`Truck`类。这两个类都继承了`Vehicle`接口。它们都认为车辆实体有一个`move`方法。
- en: 'By not thinking about proper abstraction and without respecting the OCP, code
    can easily bear unexpected difficulties when classes are not easy to reuse or
    cannot be handled (see *Example 1.5*):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不考虑适当的抽象，不尊重OCP（开闭原则），代码在类不易重用或难以处理时可能会遇到意外的困难（参见*示例1.5*）：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 1.5 – Although both are considered entities, Truck and Car inherit a
    Vehicle interface, the move method is compliant, and this causes an issue in extension
    or execution
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.5 – 虽然`Truck`和`Car`都被视为实体，但它们继承了`Vehicle`接口，`move`方法符合规范，这导致在扩展或执行时出现问题
- en: 'The correction of the example at hand is very trivial in this case (see *Example
    1.6*):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对当前示例的修正非常简单（参见*示例1.6*）：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 1.6 – The Vehicle interface provides a move abstraction method
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.6 – `Vehicle`接口提供了一个移动抽象方法
- en: Obviously, as code evolves, non-compliance leads to unexpected challenges.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，随着代码的演变，不遵守原则会导致意外的挑战。
- en: The Liskov Substitution Principle (LSP) – substitutability of classes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则（LSP） – 类的可替换性
- en: 'The previous sections dealt with inheritance and abstraction as two of the
    key pillars of OOP. It will come as no surprise to those of you who have read
    carefully that, given the class hierarchy of parent-child relationships, a child
    may be replaced or represented by its parent and vice versa (see *Example 1.7*).
    Let us look at the example of `CarWash`, where you can wash any vehicle:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节讨论了继承和抽象作为OOP（面向对象编程）的两个关键支柱。对于那些仔细阅读的人，给定父-子关系的类层次结构，一个子类可以被其父类替换或表示，反之亦然，这不会令人惊讶（参见*示例1.7*）。让我们看看`CarWash`的例子，你可以清洗任何车辆：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 1.7 – A CarWash example where any Vehicle type can be substituted by
    appropriate instances of classes in the class hierarchy
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.7 – 一个`CarWash`示例，其中任何车辆类型都可以由类层次结构中的适当类实例替换
- en: This means that classes of a similar type can act analogously and replace the
    original class. This statement was first mentioned during a keynote address by
    Barbara Liskov in 1988 (see *Reference 3*). The conference focused on data abstraction
    and hierarchy. The statement was based on the idea of substitutability of class
    instances and interface segregation. Let’s look at interface segregation next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着相似类型的类可以类似地行动，并替换原始类。这个说法最早是在1988年由Barbara Liskov在主题演讲中提出的（参见*参考文献3*）。该会议专注于数据抽象和层次结构。这个说法基于类实例和接口分离的可替换性。让我们看看接口分离。
- en: The interface segregation principle (ISP)
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口分离原则（ISP）
- en: 'This principle states that no instance of a class should be forced to depend
    on methods that are not used or in their abstractions. It also provides instructions
    on how to structure interfaces or abstract classes. In other words, it controls
    how to divide the intended methods into smaller, more specific entities. The client
    could use these entities transparently. To point out a malicious implementation,
    consider `Car` and `Bike` as children of the `Vehicle` interface, which shares
    all the abstract methods (see *Example 1.8*):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，一个类的任何实例都不应该被迫依赖于未使用或在其抽象中的方法。它还提供了如何构建接口或抽象类的指导。换句话说，它控制了如何将预期的方法划分为更小、更具体的实体。客户端可以透明地使用这些实体。为了指出一个恶意实现，考虑`Car`和`Bike`作为`Vehicle`接口的子类，它们共享所有抽象方法（参见*示例1.8*）：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 1.8 – Various implementations of inherited method abstraction
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.8 – 继承方法抽象的多种实现
- en: 'Some of you with a keen eye will already notice that such a software design
    direction negatively involves software flexibility through unnecessary actions
    that need to be considered (such as exceptions). The remedy is based on compliance
    with the ISP in a very transparent way. Consider two additional interfaces, `HasEngine`
    and `HasPedals`, with their respective functions (see *Example 1.9*). This step
    forces the `printIsMoving` method to overload. The entire code becomes transparent
    to the client and does not require any special treatment to ensure code stability,
    with exceptions as an example (as seen in *Example 1.8*):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些具有敏锐眼光的人可能已经注意到，这种软件开发方向通过不必要的操作（例如异常）对软件灵活性产生负面影响。补救措施基于对ISP的严格遵守，以一种非常透明的方式进行。考虑两个额外的接口，`HasEngine`和`HasPedals`，以及它们各自的功能（参见*示例1.9*）。这一步迫使`printIsMoving`方法进行重载。整个代码对客户端来说是透明的，并且不需要任何特殊处理来确保代码稳定性，以异常为例（如*示例1.8*所示）：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 1.9 – The functionality split into smaller units (interfaces) based
    on the purpose
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.9 – 根据目的将功能拆分为更小的单元（接口）
- en: Two interfaces, `HasEngine` and `HasPedals`, are introduced, which enforce method
    code overload and transparency.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了两个接口，`HasEngine`和`HasPedals`，它们强制方法代码重载和透明性。
- en: The dependency inversion principle (DIP)
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）
- en: Every programmer, or rather software designer, will face the challenge of hierarchical
    class composition throughout their careers. The following DIP is a remarkably
    simple guide on how to approach it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员，或者更确切地说，软件设计师，在其职业生涯中都会面临层次结构类组合的挑战。以下DIP是一个关于如何接近它的非常简单的指南。
- en: 'The principle suggests that a low-level class should not know about high-level
    classes. In the opposite direction, this means that the high-level classes, the
    classes that are above, should have no information about the basic classes at
    lower levels (see *Example 1.10*, with the `SportCar` class):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 原则建议低级类不应该了解高级类。相反，这意味着高级类，即位于上面的类，不应该了解较低层次的基本类（参见*示例1.10*，`SportCar`类）：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 1.10 – The garage implementation depends on vehicle abstraction, not
    concrete classes in a hierarchy
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1.10 – 车库实现依赖于车辆抽象，而不是层次结构中的具体类
- en: It also means that the implementation of a particular functionality should not
    depend on specific classes, but rather on their abstractions (see *Example 1.10*,
    with the `Garage` class).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着特定功能的实现不应该依赖于特定类，而应该依赖于它们的抽象（参见*示例1.10*，`Garage`类）。
- en: Significance of design patterns
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式的重要性
- en: The previous sections introduced two complementary approaches to software design
    – APIE and SOLID concepts. It has begun to crystallize that having code in a transparent
    form can be beneficial for a variety of reasons, because every programmer often,
    if not always, faces the challenge of designing a piece of code that extends or
    modifies existing ones.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节介绍了两种互补的软件开发方法——APIE和SOLID概念。开始显现的是，代码以透明形式存在可以因多种原因而有益，因为每个程序员通常，如果不是总是，都会面临设计一段扩展或修改现有代码的挑战。
- en: One wise man once said, “*The way to Hell is the path of continual technical
    debt ignorance...*.” Anything that slows down or prevents the development of applications
    can be considered a technical debt. Translated into a programming language, this
    would mean that even a small part matters, if not now, then later. It also follows
    that code readability and purpose are crucial to application logic, as it is possible
    to verify various hypotheses (for example, application operation).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一位智者曾经说过，“*通往地狱的道路是持续的技术债务无知之路...*。”任何减缓或阻止应用程序开发的事情都可以被认为是技术债务。用编程语言来翻译，这意味着即使是一小部分，如果现在不重要，那么将来也会重要。这也意味着代码的可读性和目的对于应用程序逻辑至关重要，因为可以验证各种假设（例如，应用程序操作）。
- en: The inability to perform business-oriented application testing can be considered
    the first sign of incorrect development trends. It may appear to require the use
    of different mock-up techniques during verification. This approach can easily
    turn into providing false-positive results. This can usually be caused by the
    clutter of the code structure, which forces programmers to use mocks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无法执行面向业务的应用程序测试可以被认为是错误开发趋势的第一个迹象。这可能会在验证期间需要使用不同的模拟技术。这种方法很容易变成提供假阳性结果。这通常可以归因于代码结构的杂乱，迫使程序员使用模拟。
- en: Although the SOLID and APIE concepts suggest several principles, they still
    do not guarantee that the project code base will not start to rot. Adherence to
    these principles makes it difficult, but there is still room because not all concepts
    provide the required framework for dealing with rot.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOLID和APIE概念提出了几个原则，但它们仍然不能保证项目代码库不会开始腐烂。遵守这些原则使这变得困难，但仍然有空间，因为并非所有概念都提供了处理腐烂所需框架。
- en: There may be long stories of how software can rot over time, but one fact that
    remains is that there is a cure for avoiding it or letting it go. The cure is
    covered by an idea called **design patterns**. The idea of a design pattern not
    only covers the readability of the code base and its purpose but also advances
    the ability to verify required business hypotheses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 软件随着时间的推移可能会腐烂的长篇故事可能有很多，但一个不变的事实是，有一种方法可以避免它或让它腐烂。这种治疗方法被一种称为**设计模式**的想法所涵盖。设计模式的概念不仅涵盖了代码库的可读性和其目的，还提高了验证所需业务假设的能力。
- en: What are the ideas behind defining it to get more clarity? The design pattern
    idea can be described as a set of reusable coding approaches that solve the most
    common problems encountered during application development. These approaches are
    in line with the previously mentioned APIE or SOLID concepts and have an incredibly
    positive impact on bringing transparency, readability, and testability to the
    development path. Simply put, the idea of design patterns provides a framework
    for accessing common challenges in software design.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定义它的背后是什么想法可以让我们更清晰？设计模式的概念可以被描述为一套可重用的编码方法，这些方法解决了在应用开发过程中遇到的最常见问题。这些方法与之前提到的APIE或SOLID概念一致，并且对带来透明度、可读性和可测试性对开发路径产生了极大的积极影响。简单来说，设计模式的概念为访问软件设计中的常见挑战提供了一个框架。
- en: Reviewing what challenges design patterns solve
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查设计模式解决哪些挑战
- en: Take a deep breath and think about the motivation for writing the program. The
    program is written in a programming language, in our case, Java, and is a human-readable
    form to address a specific challenge. Let’s look at it from a different perspective.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 深吸一口气，思考编写程序的动力。程序是用编程语言编写的，在我们的例子中是Java，它是一种人类可读的形式，用于解决特定的挑战。让我们从不同的角度来审视它。
- en: We can state that writing a program is considered a goal. The goal has its reason
    defined by known needs or requirements in most cases. Expectations and limitations
    are defined. When the goal is known, each action is chosen with the aim of achieving
    it. The goal is evaluated, organized, and placed in the context of the destination,
    where the destination means a work program addressing the required challenge.
    Imagine all the difficulties mentioned in the previous sections.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明编写程序被视为一个目标。在大多数情况下，目标有其原因，由已知的需要或需求定义。期望和限制被定义。当目标已知时，每个行动都是选择以实现它的目标。目标被评估、组织，并放置在目标的环境中，其中目标意味着一个解决所需挑战的工作程序。想象一下前几节中提到的所有困难。
- en: Day after day, a new solution is posed, instead of a transparent solution. Every
    day, another local success keeps the project afloat, despite everything looking
    good on the surface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 日复一日，提出的是新的解决方案，而不是一个透明的解决方案。每一天，另一个局部成功使项目得以维持，尽管表面上看起来一切都很顺利。
- en: 'Currently, most teams follow the SCRUM framework. Imagine a situation where
    the team follows the SCRUM framework (see *Reference 4*) and application development
    begins to deviate from the goal. Daily standup meetings run smoothly from time
    to time: it is mentioned that a fundamental error has been found. A few days later,
    the bug is successfully fixed with great applause. Interestingly, the frequency
    of such notifications is growing – more corrections, more applause. But does this
    really mean that the project is moving towards its goal? Does this mean that the
    application works? Let’s look at the answer.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数团队遵循SCRUM框架。想象一下，当团队遵循SCRUM框架（见*参考4*）并且应用开发开始偏离目标时的情况。日常站立会议有时运行得顺利：提到发现了一个基本错误。几天后，这个错误被成功修复，并得到了热烈的掌声。有趣的是，这种通知的频率正在增长——更多的修正，更多的掌声。但这真的意味着项目正在朝着目标前进吗？这真的意味着应用程序运行正常吗？让我们看看答案。
- en: There is a darker side – the backlog is growing with features and technical
    debt. Technical debt is not necessarily a terrible thing. Technical debt can stimulate
    the project and can be especially useful in the concept validation phase. The
    problem with technical debt occurs when it is not recognized, ignored, and poorly
    evaluated – even worse when technical debt starts being labeled as new features.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更黑暗的一面——待办事项随着功能和技术债务的增长。技术债务并不一定是一件糟糕的事情。技术债务可以刺激项目，在概念验证阶段尤其有用。技术债务的问题在于它没有被认识到、被忽视，并且评估不佳——甚至更糟糕的是，当技术债务开始被标记为新功能时。
- en: Although the product backlog should be one entity, it begins to consist of two
    different and unfortunately incompatible parts – the business and the sprint backlog
    (mostly technical debt). Of course, the team is working on a sprint backlog that
    comes from planning meetings, but with increasing technical debt, there is less
    and less room for the relevant business functions of the product. The trends observed
    in this way can result in extremely tricky situations during each new sprint planning
    session, where the development resources should be allocated. Let’s stop for a
    moment and recall this situation where the team cannot move the product forward
    due to technical debt.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管产品待办事项应该是一个整体，但它开始由两个不同且不幸不兼容的部分组成——业务和冲刺待办事项（主要是技术债务）。当然，团队正在处理来自规划会议的冲刺待办事项，但随着技术债务的增加，留给产品相关业务功能的空间越来越少。通过这种方式观察到的趋势可能导致在每次新的冲刺规划会议期间出现极其棘手的情况，那时应该分配开发资源。让我们暂时停下来，回顾一下团队由于技术债务而无法推动产品前进的情况。
- en: The values of the SCRUM methodology can be simplified to courage, concentration,
    determination, respect, and openness. These values are not specific to the SCRUM
    framework. Because the team’s motivation is to deliver the product, they all sound
    very logical and fair.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SCRUM 方法的价值观可以简化为勇气、专注、决心、尊重和开放。这些价值观并不特定于 SCRUM 框架。因为团队的动机是交付产品，它们听起来都非常合理和公平。
- en: We will now refresh our memory of the state the team has achieved. A state where
    it cannot move the project forward and struggles with the definition and proper
    consolidation of technical departments. This means that the team is doing its
    job, but may deviate from achieving its ultimate goal. Every discussion is extremely
    difficult because it is difficult to solve and describe the problem correctly
    for many different reasons. It may seem that developers may lose their language
    of communication and begin to misunderstand each other. We can see that the entropy
    of the software has increased because the coherence is not maintained. The project
    is beginning to rot and convergence to the inevitable wasted development time
    increases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们刷新一下对团队所达到状态的记忆。这是一个团队无法推动项目前进，并且在定义和适当整合技术部门方面挣扎的状态。这意味着团队正在做它的工作，但可能偏离了实现其最终目标。每一次讨论都极其困难，因为正确解决和描述问题的难度很大，原因有很多。可能看起来开发者可能会失去他们的沟通语言，并开始互相误解。我们可以看到，软件的熵增加了，因为一致性没有得到保持。项目开始腐烂，不可避免地浪费的开发时间增加。
- en: 'Let us take another deep breath and think together about how to prevent such
    a situation. It must be possible to identify these tendencies. Usually, each team
    has some commonality: the team is not always homogeneous in terms of knowledge,
    but this should not prevent us from identifying the degradation of the learning
    curve.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再深呼吸一下，一起思考如何防止这种情况。必须有可能识别这些趋势。通常，每个团队都有一些共性：团队在知识方面并不总是同质化的，但这不应该阻止我们识别学习曲线的退化。
- en: The project learning curve can help us identify a rotting project. Instead of
    gradual improvements towards the goal, the team experiences local successes full
    of technical repairs and solutions. Such successes do not even correspond to the
    values of SCRUM and gradual improvement seems unlikely. The solution may not be
    considered an improvement because it is specific to a particular movement and
    may violate the specifications of the technology used. During the solution period,
    the team may not acquire any useful knowledge applicable to the future. This can
    soon be considered a missing business opportunity due to the inability to supply
    business elements or only parts of them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 项目学习曲线可以帮助我们识别一个烂项目。而不是逐步向目标改进，团队经历了充满技术修复和解决方案的局部成功。这些成功甚至不符合敏捷开发（SCRUM）的价值观，逐步改进似乎不太可能。解决方案可能不会被看作是改进，因为它针对特定的运动，可能违反了所使用技术的规范。在解决方案期间，团队可能不会获得任何适用于未来的有用知识。这很快就可以被视为由于无法提供业务元素或仅提供部分元素而错失的商业机会。
- en: In addition to the degradation of the learning curve, other symptoms can be
    identified. This can be described as an inability to test a business function.
    Project code is proving sticky, dependencies are out of control, which can also
    harm code readability, testability, and, of course, programmer discipline. The
    daily goal of the software designer can be reduced to closing a ticket.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习曲线的退化，还可以识别出其他症状。这可以描述为无法测试业务功能。项目代码变得难以处理，依赖关系失控，这也会损害代码的可读性、可测试性和，当然，程序员的纪律。软件设计师的日常目标可以简化为关闭工单。
- en: To avoid getting to this state, this book will provide some guidelines for solving
    the most common problems in the following chapters by introducing and questioning
    different types of design patterns. The design patterns are in line with the aforementioned
    basic pillars of OOP and APIE and promote the principles of SOLID.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免达到这种状态，本书将在以下章节中通过介绍和质疑不同类型的设计模式，为解决最常见的常见问题提供一些指导。这些设计模式与前面提到的面向对象（OOP）和APIE的基本支柱一致，并促进SOLID原则。
- en: What’s more, design patterns can highlight any misunderstood directions and
    enforce the **don’t repeat yourself** (**DRY**) principle. As a result, there
    is much less duplication, code testability, and more fun on the project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，设计模式可以突出任何误解的方向，并强制执行**不要重复自己**（DRY）原则。因此，项目中的代码重复较少，可测试性更高，更有趣。
- en: That brings us to the end of this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Before we embark on the journey of researching design patterns, let us quickly
    summarize. This chapter has expanded or improved our understanding of various
    areas. Each of these areas affects program code from different perspectives:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始研究设计模式之旅之前，让我们快速总结一下。本章扩展或改进了我们对于各个领域的理解。这些领域从不同的角度影响程序代码：
- en: Code transparency and readability
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码透明度和可读性
- en: The ability to solve complex challenges
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决复杂挑战的能力
- en: Following SOLID and OOP principles
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循SOLID和面向对象（OOP）原则
- en: Code testability (it’s possible to verify the purpose of the code)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可测试性（可以验证代码的目的）
- en: Easy to extend and modify
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展和修改
- en: Supporting continual refactoring
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持持续重构
- en: Code is self-explanatory
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是自我解释的
- en: The program code is written – well done. The next chapter will take us through
    a survey of the implementation platform – in our case, the Java platform. We will
    learn in more detail how and what it means to run a program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序代码已经编写完成——做得好。下一章将带我们了解实现平台的概述——在我们的案例中，是Java平台。我们将更详细地了解如何运行程序以及这意味着什么。
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What interprets the Java code to the platform and how?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java代码是如何被解释到平台上的，又是如何解释的？
- en: What does the acronym APIE represent?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: APIE这个缩写代表什么？
- en: What types of polymorphism does the Java language allow?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java语言允许哪些类型的多态？
- en: What principle helps software designers to produce maintainable code?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个原则帮助软件设计师产生可维护的代码？
- en: What does the OCP mean?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OCP代表什么？
- en: What should be considered about design patterns?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计模式方面应该考虑什么？
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Garbage Collection Handbook: The Art of Automatic Memory Management*,
    Anthony Hosking, J. Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791,
    ISBN-10: 9781420082791, 1996.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《垃圾回收手册：自动内存管理的艺术》，作者：Anthony Hosking，J. Eliot B. Moss，Richard Jones，CRC Press，ISBN-13：978-1420082791，ISBN-10：9781420082791，1996年。
- en: '*Design Principles and Design Patterns*, Robert C. Martin, Object Mentor, 2000.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计原则与设计模式》，作者：Robert C. Martin，Object Mentor，2000年。
- en: '*Keynote address - data abstraction and hierarchy*, Barbara Liskov, [https://dl.acm.org/doi/10.1145/62139.62141](https://dl.acm.org/doi/10.1145/62139.62141),
    1988.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主旨演讲 - 数据抽象和层次结构*，芭芭拉·利斯科夫，[https://dl.acm.org/doi/10.1145/62139.62141](https://dl.acm.org/doi/10.1145/62139.62141)，1988年。'
- en: The SCRUM framework, [https://www.scrum.org/](https://www.scrum.org/), 2022\.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCRUM 框架，[https://www.scrum.org/](https://www.scrum.org/)，2022年。
