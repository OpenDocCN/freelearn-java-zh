<html><head></head><body><div class="part" title="Part&#xA0;1.&#xA0;Module 1"><div class="titlepage"><div><div><h1 class="title"><a id="part01"/>Part 1. Module 1</h1></div></div></div><div class="partintro" title="Module 1"><div/><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Clojure for Java Developers</strong></span>
</p><p>
<span class="emphasis"><em>
Transition smoothly from Java to the most widely used functional JVM-based language – Clojure
</em></span>
</p></blockquote></div></div></div>
<div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Clojure</h1></div></div></div><p>Welcome to the world of Clojure! If you are here, you probably know a little about Lisp or Clojure, but you don't really have an idea of how things work in this world.</p><p>We will get to know Clojure by comparing each feature to what you already know from Java. You will see that there are lists, maps and sets just like in Java, but they are immutable. To work with these kinds of collections, you need a different approach; a different paradigm.</p><p>This is what we will try to accomplish in this book, to give you a different way to approach problems. We hope you end up using Clojure in your every day life, but if you don't, we hope you use a new approach toward problem solving.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting to know Clojure</li><li class="listitem" style="list-style-type: disc">Installing Leiningen</li><li class="listitem" style="list-style-type: disc">Using a <span class="strong"><strong>Read Eval Print Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>)</li><li class="listitem" style="list-style-type: disc">Installing and using Cursive Clojure</li><li class="listitem" style="list-style-type: disc">Clojure's simple syntax</li><li class="listitem" style="list-style-type: disc">Clojure's data types and their relationship to the JVM's data types</li><li class="listitem" style="list-style-type: disc">Special syntax for functions</li></ul></div><div class="section" title="Getting to know Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Getting to know Clojure</h1></div></div></div><p>Before getting started<a class="indexterm" id="id0"/> with Clojure, you should know some of its features and what it shares with Java.</p><p>Clojure is a programming language that inherits a lot of characteristics from Lisp. You might think of Lisp as that weird programming language with all the parentheses. You need to keep in mind that Clojure chooses to embrace functional programming. This makes it very different from current mainstream programming languages. You will get to know about immutable data structures and how to write programs without changing variable values.</p><p>You will also <a class="indexterm" id="id1"/>find that Clojure is a dynamic programming language, which makes it a little easier and faster to write programs than using statically typed languages. There is also the concept of using a REPL, a tool that allows you to connect to a program running environment and change code dynamically. It is a very powerful tool.</p><p>At last, you will find out that you can convert Clojure to anything you like. You can create or use a statically typed system and bend the language to become what you like. A good example of this is the <code class="literal">core.typed</code> library, which allows you to specify the type information without adding support to the compiler.</p></div></div>
<div class="section" title="Installing Leiningen"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Installing Leiningen</h1></div></div></div><p>We are <a class="indexterm" id="id2"/>used to having certain tools to help us build our code, such as Ant, Maven, and Gradle.</p><p>In the Clojure ecosystem, the de facto standard for dependency and build management is Leiningen (affectionately named after the short story "Leiningen versus the Ants", which I <a class="indexterm" id="id3"/>recommend reading at <a class="ulink" href="http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants">http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants</a>); Leiningen strives to be a familiar to Java developers, it gets the best ideas from Maven, like: convention over configuration. It also gets ideas from Ant like custom scripting and plugins.</p><p>Installing it is very simple, let's check how to do it on Mac OS X (installing on Linux should be the same) using bash as your default shell.</p><p>You should also have Java 7 or 8 already installed and configured in your path.</p><p>You can check the detailed instructions on the <a class="indexterm" id="id4"/>Leiningen project page <a class="ulink" href="http://leiningen.org/">http://leiningen.org/</a>. If you want to get a Leiningen installation up and running, this is what you would have to do:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>curl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein</strong></span>
<span class="strong"><strong># The next step just set up the lein script in your path, you can do it any way you wish</strong></span>
<span class="strong"><strong>mv lein ~/bin</strong></span>
<span class="strong"><strong>echo "export PATH=$PATH:~/bin/"&gt;&gt; ~/.bashrc</strong></span>
<span class="strong"><strong>source ~/.bashrc</strong></span>
<span class="strong"><strong># Everything should be running now, let's test it</strong></span>
<span class="strong"><strong>lein help</strong></span>
</pre></div><p>The first time you run the <code class="literal">lein</code> command, it downloads everything needed from the internet. This makes it very easy to distribute your code, you can even include the <code class="literal">lein</code> script with your own projects and make it easier for other developers to get up and running, the only real requirement is the JDK.</p></div>
<div class="section" title="Using a REPL"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using a REPL</h1></div></div></div><p>One of the main advantages of Clojure (and Lisp) is interactive development, the REPL is the base of what can be achieved with interactive programming, it allows you to connect to a running VM running Clojure and execute or modify code on the fly.</p><p>There<a class="indexterm" id="id5"/> is a <a class="indexterm" id="id6"/>story about how NASA was able to debug and correct a bug on a $100 million piece of hardware that was 100 million miles away (<a class="ulink" href="http://www.flownet.com/gat/jpl-lisp.html">http://www.flownet.com/gat/jpl-lisp.html</a>).</p><p>We have that same power with Clojure and Leiningen and invoking it is very simple, you just need a single command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein repl</strong></span>
</pre></div><p>This is what you'll get after running the preceding command:</p><div class="mediaobject"><img alt="Using a REPL" src="graphics/B04289_01_01.jpg"/></div><p>Let's go into a bit more detail, as we can see we are running with the following programs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Java 8</li><li class="listitem" style="list-style-type: disc">Clojure 1.6.0</li></ul></div><p>We can also get some nice suggestions on how to see documentation, <code class="literal">source</code>, <code class="literal">Javadoc</code>, and previous errors.</p><div class="section" title="The nREPL protocol"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>The nREPL protocol</h2></div></div></div><p>One <a class="indexterm" id="id7"/>particular thing that is important to note is the nREPL protocol; Someday it might grant us the power to go into a machine running 100 million miles away.</p><p>When you fire up your REPL, the first thing you see is:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nREPL server started on port 55995 on host 127.0.0.1 - nrepl://127.0.0.1:55995</strong></span>
<span class="strong"><strong>REPL-y 0.3.5, nREPL 0.2.6</strong></span>
</pre></div><p>What it is saying is that there's a Clojure process running an nREPL server on port <code class="literal">55995</code>. We have connected to it using a very simple client that allows us to interact with the Clojure process.</p><p>The really interesting bit is that you can connect to a remote host just as easily; let's try attaching an REPL to the same process by simply typing the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein repl :connect localhost:55995</strong></span>
</pre></div><p>Most IDEs have a good integration with Clojure and most of them use this exact mechanism, as clients that work a little more intelligently.</p></div><div class="section" title="Hello world"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Hello world</h2></div></div></div><p>Now<a class="indexterm" id="id8"/> that we are inside the REPL, (any of the two) let's try writing our first expression, go on and type:</p><div class="informalexample"><pre class="programlisting">"Hello world"</pre></div><p>You should get back a value from the REPL saying <code class="literal">Hello world</code>, this is not really a program, and it is the <code class="literal">Hello world</code> value printed back by the print phase of the REPL.</p><p>Let's now try to write our first Lisp form:</p><div class="informalexample"><pre class="programlisting">(println "Hello world")</pre></div><p>This first expression looks different from what we are used to, it is called an S-expression and it is the standard Lisp way.</p><p>There are a couple of things to remember with S-expressions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are lists (hence, the name, Lisp)</li><li class="listitem" style="list-style-type: disc">The first element of the list is the action that we want to execute, the rest are the parameters of that action (one two three).</li></ul></div><p>So we are asking <a class="indexterm" id="id9"/>for the string <code class="literal">Hello world</code> to be printed, but if we look a bit closer at the output, as shown in the following screenshot, there is a <code class="literal">nil</code> that we weren't expecting:</p><div class="mediaobject"><img alt="Hello world" src="graphics/B04289_01_02.jpg"/></div><p>The reason for this is that the <code class="literal">println</code> function returns the value <code class="literal">nil</code> (Clojure's equivalent for null) after printing <code class="literal">Hello world</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>In Clojure, everything has a value and the REPL will always print it back for you.</p></div></div></div><div class="section" title="REPL utilities and conventions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>REPL utilities and conventions</h2></div></div></div><p>As we <a class="indexterm" id="id10"/>saw, the Leiningen nREPL client prints help text; but how does that work? Let's explore some of the other utilities that we have.</p><p>Try each of them to get a feeling of what it does with the help of the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Sample</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">doc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Prints out a function's <code class="literal">docstring</code>
</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">doc println</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">source</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Prints a function's source code, it must be written in Clojure</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">source println</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">javadoc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Open the <code class="literal">javadoc</code> for a class in the browser</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">javadoc java.lang.Integer</code>)</p>
</td></tr></tbody></table></div><p>Let's check how these functions work:</p><div class="informalexample"><pre class="programlisting">user=&gt; (javadoc java.util.List)
;; Should open the javadoc for java.util.List

user=&gt; (doc doc)
-------------------------
clojure.repl/doc
([name])
Macro
  Prints documentation for a var or special form given its name
nil

user=&gt; (source doc)
(defmacro doc
"Prints documentation for a var or special form given its name"
  {:added "1.0"}
  [name]
  (if-let [special-name ('{&amp; fn catch try finally try} name)]
    (#'print-doc (#'special-doc special-name))
    (cond
      (special-doc-map name) `(#'print-doc (#'special-doc '~name))
      (find-ns name) `(#'print-doc (#'namespace-doc (find-ns '~name)))
      (resolve name) `(#'print-doc (meta (var ~name))))))
nil</pre></div><p>What you are <a class="indexterm" id="id11"/>seeing here is metadata pertaining to the <code class="literal">doc</code> function; Clojure has the ability to store metadata about every function or <code class="literal">var</code> you use. Most of the Clojure core functions include a doc string and the source of the function and this is something that will become very handy in your day to day work.</p><p>Besides these functions, we also get easy access to the latest three values and the latest exceptions that happened in the REPL, let's check this out:</p><div class="informalexample"><pre class="programlisting">user=&gt; 2
2
user=&gt; 3
3
user=&gt; 4
4
user=&gt; (* *1 *2 *3) ;; We are multiplying over here the last three values
24 ;;We get 24!
user=&gt; (/ 1 0) ;; Let's try dividing by zero
ArithmeticException Divide by zero clojure.lang.Numbers.divide (Numbers.java:156)
user=&gt; *e
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&gt;

user=&gt; (.getMessage *e)
"Divide by zero"</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>
<code class="literal">*e</code> gives you access to the actual plain old Java exception object, so you can analyze and introspect it at runtime.</p></div></div><p>You can imagine the possibilities of being able to execute and introspect code with this, but what about the tools that we are already used to? How can we use this with an IDE?</p><p>Let's check now how to create a new Clojure project, we'll use Leiningen from the command line to understand what is happening. </p></div></div>
<div class="section" title="Creating a new project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Creating a new project</h1></div></div></div><p>Leiningen can help us create a new project using templates, there is a wide variety of templates available and you can build and distribute your own in Maven.</p><p>Some of the most common types of templates are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a <code class="literal">jar</code> library (the default template)</li><li class="listitem" style="list-style-type: disc">Creating a command-line app</li><li class="listitem" style="list-style-type: disc">Creating a Clojure web app</li></ul></div><p>Let's create a new <a class="indexterm" id="id12"/>Clojure command-line app and run it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein new app getting-started</strong></span>
<span class="strong"><strong>cd getting-started</strong></span>
<span class="strong"><strong>lein run</strong></span>
<span class="strong"><strong># Hello, world!</strong></span>
</pre></div><div class="section" title="Project structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Project structure</h2></div></div></div><p>Leiningen<a class="indexterm" id="id13"/> is similar to other Java development tools; it uses a similar convention and allows for heavy customizations in the <code class="literal">project.clj</code> file.</p><p>If you are familiar with Maven or Gradle, you can think of it as <code class="literal">pom.xml</code> or <code class="literal">build.gradle</code> respectively.</p><p>The following screenshot is the project structure:</p><div class="mediaobject"><img alt="Project structure" src="graphics/B04289_01_03.jpg"/></div><p>As you can<a class="indexterm" id="id14"/> see in the preceding screenshot, there are four main folders:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">resources</code>: It <a class="indexterm" id="id15"/>holds everything that should be in the class path, such as files, images, configuration files, properties files, and other resources needed at runtime.</li><li class="listitem" style="list-style-type: disc"><code class="literal">src</code>: Your<a class="indexterm" id="id16"/> Clojure source files; they are ordered in a very similar fashion to the <code class="literal">classpath</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dev-resources</code>: Everything<a class="indexterm" id="id17"/> that should be in the <code class="literal">classpath</code> in development (when you are running Leiningen). You can override your "production" files here and add files that are needed for tests to run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test</code>: Your <a class="indexterm" id="id18"/>tests; this code doesn't get packaged but it is run every time you execute the Leiningen test.</li></ul></div></div><div class="section" title="Creating a standalone app"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Creating a standalone app</h2></div></div></div><p>Once <a class="indexterm" id="id19"/>your<a class="indexterm" id="id20"/> project is created, you can build and run a Java standalone command-line app quite easily, let's try it now:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein uberjar</strong></span>
<span class="strong"><strong>java -jar target/uberjar/getting-started-0.1.0-SNAPSHOT-standalone.jar</strong></span>
<span class="strong"><strong># Hello, World!</strong></span>
</pre></div><p>As you can see, it is quite easy to create a standalone app and it is very similar to using Maven or Gradle.</p></div></div>
<div class="section" title="Using Cursive Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Using Cursive Clojure</h1></div></div></div><p>Java already<a class="indexterm" id="id21"/> has some great tools to help us be more productive and write higher quality code and we don't need to forget about those tools. There are several plugins<a class="indexterm" id="id22"/> for Clojure depending on what your IDE is. Have a look at them from the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>IDE</p>
</th><th style="text-align: left" valign="bottom">
<p>Plugins</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>IntelliJ</p>
</td><td style="text-align: left" valign="top">
<p>Cursive Clojure, La Clojure</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>NetBeans</p>
</td><td style="text-align: left" valign="top">
<p>NetBeans Clojure (works with NetBeans 7.4)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Eclipse</p>
</td><td style="text-align: left" valign="top">
<p>CounterClockwise</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Emacs</p>
</td><td style="text-align: left" valign="top">
<p>Cider</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>VIM</p>
</td><td style="text-align: left" valign="top">
<p>vim-fireplace, vim-leiningen</p>
</td></tr></tbody></table></div><p>A lot of people writing real Clojure code use Emacs and I actually like using vim as my main development tool, but don't worry, our main IDE will be IntelliJ + Cursive Clojure throughout the book.</p><div class="section" title="Installing Cursive Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Installing Cursive Clojure</h2></div></div></div><p>You can<a class="indexterm" id="id23"/> check the full documentation for Cursive at their website (<a class="ulink" href="https://cursiveclojure.com/">https://cursiveclojure.com/</a>), it is still under development but it is quite stable and a great aid when writing Clojure code.</p><p>We are going to use the latest IntelliJ Community Edition release, which at the time of this writing is version 14.</p><p>You can download <a class="indexterm" id="id24"/>IntelliJ from here <a class="ulink" href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>.</p><p>Installing <a class="indexterm" id="id25"/>Cursive Clojure is very simple, you need to add a repository for IntelliJ. You'll find the instructions to your specific IntelliJ version here: <a class="ulink" href="https://cursiveclojure.com/userguide/">https://cursiveclojure.com/userguide/</a>.</p><p>After you have installed Cursive Clojure, we are ready to go.</p><p>Now, we are ready to import our getting started project into Cursive Clojure.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Cursive Clojure doesn't currently have support to create Leiningen projects from within the IDE; however, support is great in order to import them.</p></div></div><p>Here is how you will do it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on <span class="strong"><strong>File</strong></span>.</li><li class="listitem">Import project.</li><li class="listitem">Look for your project.</li><li class="listitem">Open the folder or the <code class="literal">project.clj</code> file.</li><li class="listitem">Follow the <span class="strong"><strong>Next</strong></span> steps in the IDE.</li></ol></div><p>Now, we are ready to go, you can use the Cursive Clojure as your main development tool. There are a few more things to do with your IDE but I recommend you to look for them; they are important and will come in handy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To know how to execute the project</li><li class="listitem" style="list-style-type: disc">To know how to execute the tests</li><li class="listitem" style="list-style-type: disc">To open an REPL connected to some project.</li><li class="listitem" style="list-style-type: disc">The key binding to execute some given piece of code (run form before cursor in REPL)</li><li class="listitem" style="list-style-type: disc">The key binding to execute a given file (load file in REPL)</li></ul></div><p>One important part of Clojure programming is that it can modify and reevaluate code in runtime. Check the manual of your current version of Clojure and check for the structural editing section (<a class="ulink" href="https://cursiveclojure.com/userguide/paredit.html">https://cursiveclojure.com/userguide/paredit.html</a>). It is one of the most useful functionalities of Clojure IDEs and a direct consequence of the Clojure syntax.</p><p>I recommend you to check other functionalities from the manual. I really recommend checking the Cursive Clojure manual, it includes animations of how each functionality works.</p><p>You will use the <a class="indexterm" id="id26"/>last two key bindings quite a lot, so it is important to set them up correctly. There is more information about keybindings at <a class="ulink" href="https://cursiveclojure.com/userguide/keybindings.html">https://cursiveclojure.com/userguide/keybindings.html</a>.</p></div></div>
<div class="section" title="Getting started with Clojure code and data"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Getting started with Clojure code and data</h1></div></div></div><p>Let's take a<a class="indexterm" id="id27"/> deep dive into Clojure's syntax now, it is pretty different from other languages but it is actually much simpler. Lisps have a very regular syntax, with few special rules. As we said earlier, Clojure code is made of S-expressions and S-expressions are just lists. Let's <a class="indexterm" id="id28"/>look at some examples of lists to become familiar with lists in Lisp.</p><div class="informalexample"><pre class="programlisting">(1 2 3 4)
(println "Hello world")
(one two three)
("one" two three)</pre></div><p>All of the above are lists, but not all of them are valid code. Remember, only lists where the first element is a function can be considered valid expressions. So, here only the following could be valid expressions:</p><div class="informalexample"><pre class="programlisting">(println "Hello world")
(one two three)</pre></div><p>If <code class="literal">println</code> and <code class="literal">one</code> are defined as functions.</p><p>Let's see a piece of Clojure code, to finally explain how everything works.</p><div class="informalexample"><pre class="programlisting">(defn some-function [times parameter]
"Prints a string certain number of times"
  (dotimes [x times]
    (println parameter)))</pre></div><div class="section" title="Lists in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Lists in Clojure</h2></div></div></div><p>Clojure is<a class="indexterm" id="id29"/> based <a class="indexterm" id="id30"/>around "forms" or lists. In Clojure, same as every Lisp, the way to denote a list is with parentheses, so here are some examples of lists in the last code:</p><div class="informalexample"><pre class="programlisting">(println parameter)
(dotimes [x times] (println parameter))
(defn some-function [times parameter] (dotimes [x times] (println parameter)))</pre></div><p>Lists are one data type in Clojure and they are also the way to express code; you will learn later about all the benefits of expressing code as data. The first one is that it is really simple, anything you can do must be expressed as a list! Let's look at some other examples of executable code:</p><div class="informalexample"><pre class="programlisting">(* 1 2 3)
(+ 5 9 7)
(/ 4 5)
(- 2 3 4)
(map inc [1 2 3 4 5 6])</pre></div><p>I encourage you<a class="indexterm" id="id31"/> to write everything into the REPL, so you get a good notion of what's happening.</p></div><div class="section" title="Operations in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Operations in Clojure</h2></div></div></div><p>In <a class="indexterm" id="id32"/>Clojure, <code class="literal">MOST</code> <a class="indexterm" id="id33"/>of the executable forms have this structure:</p><div class="informalexample"><pre class="programlisting">(<span class="strong"><strong>op </strong></span>parameter-1parameter-2 ….)</pre></div><p>
<code class="literal">op</code> is the operation to be executed followed by all the parameters it needs, let's analyze each of our previous forms in this new light:</p><div class="informalexample"><pre class="programlisting">(+ 1 2 3)</pre></div><p>We are asking to execute the <code class="literal">+</code> (addition) operation with the parameters <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>. The expected result is <code class="literal">6</code>.</p><p>Let's analyze something a bit more complicated:</p><div class="informalexample"><pre class="programlisting">(<span class="strong"><strong>map</strong></span> inc [1 2 3 4 5 6])</pre></div><p>In this, we are asking to execute the <code class="literal">clojure.core/map</code> function with two parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">inc</code> is a function name, it takes a number and increments it</li><li class="listitem" style="list-style-type: disc"><code class="literal">[1 2 3 4 5 6]</code> is a collection of numbers</li></ul></div><p>Map applies the <code class="literal">inc</code> function to each member of the passed collection and returns a new collection, what we expect is a collection containing <code class="literal">[2 3 4 5 6 7]</code>.</p></div><div class="section" title="Functions in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Functions in Clojure</h2></div></div></div><p>Now <a class="indexterm" id="id34"/>let's check <a class="indexterm" id="id35"/>how a function definition is essentially the same as the previous two forms:</p><div class="informalexample"><pre class="programlisting">(defn some-function [times parameter]
"Prints a string certain number of times"
  (dotimes [x times]
    (println parameter)))</pre></div><p>The <code class="literal">defn</code> is the operation that we are asking for. It has several parameters, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">some-function</code> is the name of the function that we are defining</li><li class="listitem" style="list-style-type: disc"><code class="literal">[times parameter]</code> is a collection of parameters</li><li class="listitem" style="list-style-type: disc"><code class="literal">"Prints a string certain number of times"</code> is the docstring, it is actually an optional parameter</li><li class="listitem" style="list-style-type: disc"><code class="literal">(dotimes [x times] (println parameter))</code> is the body of the function that gets executed when you call <code class="literal">some-function</code></li></ul></div><p>The <code class="literal">defn</code> calls <a class="indexterm" id="id36"/>a function<a class="indexterm" id="id37"/> into existence. After this piece of code is executed, <code class="literal">some-function</code> exists in the current namespace and you can use it with the defined parameters.</p><p>The <code class="literal">defn</code> is actually written in Clojure and supports a few nice things. Let's now define a <code class="literal">multi-arity</code> function:</p><div class="informalexample"><pre class="programlisting">(defn hello
  ([] (hello "Clojure"))
  ([name] (str "Hello " name)))</pre></div><p>Over here we are defining a function with two bodies, one of them has no arguments and the other one has one argument. It is actually pretty simple to understand what's happening.</p><p>Try changing the source in your project's <code class="literal">core.clj</code> file similar to the following example:</p><div class="informalexample"><pre class="programlisting">(ns getting-started.core
  (:gen-class))

(defn hello
  ([] (hello "Clojure"))
  ([name] (str "Hello " name)))

(defn -main
"I don't do a whole lot ... yet."
  [&amp; args]
  (println "Hello, World!")
  (println (hello))
  (println (hello "Edu")))</pre></div><p>Now run it, you'll get three different Hello outputs.</p><p>As you can see, Clojure has a very regular syntax and even if it's a little strange for newcomers, it is actually quite simple.</p><p>Here, we have used a few data types that we haven't properly introduced; in the next section we'll take a look at them.</p></div></div>
<div class="section" title="Clojure's data types"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Clojure's data types</h1></div></div></div><p>Now is <a class="indexterm" id="id38"/>when <a class="indexterm" id="id39"/>everything you know about Java pays off; even the list forms that you saw earlier implement the <code class="literal">java.util.List</code> interface. Clojure was designed to be embeddable and to have a great integration with the host platform, so it's only natural that you can use everything you already know about Java types and objects.</p><p>There are two data types in Clojure: scalars and collections.</p><div class="section" title="Scalars"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Scalars</h2></div></div></div><p>In every language <a class="indexterm" id="id40"/>you need primitive types; you use them in everyday life as they represent numbers, strings, and Booleans. These primitive types are called scalars in the Clojure world.</p><p>Clojure has a couple of very interesting types like ratios and keywords. In the following table, you get to know the different types of scalars, how they compare to Java and a simple example of how to use each of them.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Clojure data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Java data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Sample</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>"This is a string"</p>
<p>"This is a multiline string"</p>
</td><td style="text-align: left" valign="top">
<p>A string of characters; in Clojure you can use multiline strings without a problem</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>true</p>
<p>false</p>
</td><td style="text-align: left" valign="top">
<p>Literal Boolean values</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Character</p>
</td><td style="text-align: left" valign="top">
<p>Character</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">\c</code>
</p>
<p>
<code class="literal">\u0045 ;; Unicode char 45 E</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Character values, they are <code class="literal">java.lang.Character</code> instances, you can define Unicode characters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Keywords</p>
</td><td style="text-align: left" valign="top">
<p>Doesn't exist in java</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:key</code>
</p>
<p>
<code class="literal">:sample</code>
</p>
<p>
<code class="literal">:some-keyword</code>
</p>
</td><td style="text-align: left" valign="top">
<p>They evaluate themselves and they are often used as keys. They are also functions that look for themselves in a map.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Number</p>
</td><td style="text-align: left" valign="top">
<p>Numbers are automatically handled as <code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code> or lower precision depending on what's necessary</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">42N ;;Big Integer</code>
</p>
<p>
<code class="literal">42 ;;long</code>
</p>
<p>
<code class="literal">0.1M ;;BigDecimal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>It is important to remember the trade-offs of Java numbers, if precision is important, you should always use big decimals and <code class="literal">bigintegers</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Ratio</p>
</td><td style="text-align: left" valign="top">
<p>Doesn't exist</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">22/7</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Clojure provides great numerical precision; if necessary it can retain the ration and execute exact operation. The tradeoff when using ratios is speed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Symbol</p>
</td><td style="text-align: left" valign="top">
<p>Doesn't exist</p>
</td><td style="text-align: left" valign="top">
<p>some-name</p>
</td><td style="text-align: left" valign="top">
<p>Symbols are identifiers in Clojure, very similar to a variable name in Java.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>nil</p>
</td><td style="text-align: left" valign="top">
<p>null</p>
</td><td style="text-align: left" valign="top">
<p>nil</p>
</td><td style="text-align: left" valign="top">
<p>The null value</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Regular expressions</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.util.regex.Pattern</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">#"\d"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Regular expressions, in Clojure you get free syntax to define regular expressions, but in the end it is a plain old Java reggae Pattern</p>
</td></tr></tbody></table></div></div><div class="section" title="Collection data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Collection data types</h2></div></div></div><p>In Clojure <a class="indexterm" id="id41"/>there are two types of collections: sequential and associative collections. Sequential are things you can iterate, such as lists. Associative collections are maps, sets, and things you can access by a certain index. Clojure's collections are fully compatible with Java and it can even implement the <code class="literal">java.util</code> interfaces, such as <code class="literal">java.util.List</code> and <code class="literal">java.util.Map</code>.</p><p>One of the main characteristics of collections in Clojure is that they are immutable; it has a lot of benefits that we'll see later.</p><p>Let's have a look at the characteristics of each collection data type available in Clojure and compare them with Java with the help of a sample (in Clojure) and its description.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Clojure data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Java data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Sample</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">List</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">List</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(1 2 3 4 5)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A simple list, notice the quote character before the list, if you don't specify it Clojure will try to evaluate the form as an instruction</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Vector</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Array</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">[1 2 3 4 5]</code>
</p>
</td><td style="text-align: left" valign="top">
<p>It is the main workhorse in Clojure, it is similar to an array because you can access elements in a random order</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Set</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">HashSet</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">#{1 2 3 4}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A normal Java hash set</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Map</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">HashMap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">{:key 5 :key-2 "red"}</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A Clojure map</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>As you can see, Clojure has a mature development environment that is always evolving. You can set up command-line tools and your IDE in a very similar fashion to the way you will do in a normal Java development.</p><p>We also learned a little about Clojure's regular syntax, its data types and how they relate to Java's own data types.</p><p>Overall, you should now be comfortable with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lisp syntax</li><li class="listitem" style="list-style-type: disc">Creating a Leiningen project from scratch</li><li class="listitem" style="list-style-type: disc">Running and packaging your code</li><li class="listitem" style="list-style-type: disc">Importing a Leiningen project into IntelliJ</li><li class="listitem" style="list-style-type: disc">Using the REPL</li><li class="listitem" style="list-style-type: disc">Knowing the relationship between Clojure types and Java types</li></ul></div><p>In the next chapter, we will get an idea of how to organize our code and how that organization takes advantage of Java packages.</p></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;Namespaces, Packages, and Tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Namespaces, Packages, and Tests</h1></div></div></div><p>We now have a working installation of Clojure and IntelliJ.</p><p>As a Java developer, you are used to working with classes as the minimal unit of organization. Clojure has a very different sense and gives you different tools to organize your code.</p><p>For starters, you should keep in mind that code and data are separate; you don't have a minimal unit with attributes and functions that work over those attributes. Your functions can work on any data structure that you wish, as long as you follow the rules of how the function works.</p><p>In this chapter, we will start writing some simple functions to illustrate how separation of functions and data works and we will have a look at the tools Clojure gives us to make the separation.</p><p>In this chapter, we will cover the following topic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How namespaces work compared to the classpath and Java packages</li><li class="listitem" style="list-style-type: disc">Unit tests</li><li class="listitem" style="list-style-type: disc">More Clojure examples and syntax</li></ul></div><div class="section" title="Namespaces in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Namespaces in Clojure</h1></div></div></div><p>Clojure <a class="indexterm" id="id42"/>namespaces might be familiar to you, as a Java developer, and for a very good reason, they have a very deep relationship with Java's packages and the classpath.</p><p>First of all, let's review what we already know from Java.</p><div class="section" title="Packages in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Packages in Clojure</h2></div></div></div><p>The Java<a class="indexterm" id="id43"/> code is organized in packages, a package in Java is a namespace that allows you to group a set of similar classes and interfaces.</p><p>You can think of a package as something very similar to a folder in your computer.</p><p>The following are some common packages that you use a lot when programming in Java:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">java.lang</code>: Everything<a class="indexterm" id="id44"/> that's native to Java, including basic types (integer, long, byte, boolean, character, string, number, short, float, void, and class), the basic threading primitives (runnable, thread), the basic primitives for exceptions (throwable, error, exception), the basic exceptions and errors (<code class="literal">NoSuchMethodError</code>, <code class="literal">OutOfMemoryError</code>, <code class="literal">StackOverflowError</code>, and so on) and runtime access classes like runtime and system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">java.io</code>: This<a class="indexterm" id="id45"/> package includes the primitives for input and output, such as console, file, readers, input streams, and writers.</li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util</code>: This<a class="indexterm" id="id46"/> is one of the most heavily used packages besides <code class="literal">java.lang</code>. This includes the classic data structures (map, set, list) along with the most common implementations of such data structures. This package also includes utilities like properties tools, scanner for reading from various input resources, <code class="literal">ServiceLoader</code> to load custom services from the <code class="literal">classloader</code>, UUID generator, timers, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.logging</code>: The <a class="indexterm" id="id47"/>logging utilities, you normally use them to give you different levels of alert, from a debug to serious conditions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">java.text</code>: These <a class="indexterm" id="id48"/>are utilities to manage text, dates, and numbers in a language independent way.</li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.servlet</code>: This<a class="indexterm" id="id49"/> includes the primitives to create web apps and deployment in standard web containers.</li></ul></div><p>Each one of these packages groups several related functionalities, the <code class="literal">java.lang</code> package is particularly important, since it has every Java core type, such as string, long, and integer. Everything inside the <code class="literal">java.lang</code> package is available automatically everywhere.</p><p>The <code class="literal">java.lang</code> package provides a bit more than just code organization, it also provides access security. If you remember about Java, there are three security access levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">private</li><li class="listitem" style="list-style-type: disc">public</li><li class="listitem" style="list-style-type: disc">protected</li></ul></div><p>In the case of packages, we are concerned with the protected level of access. The classes in the same package allow every other class in the same package to access its protected attributes and methods.</p><p>There are also ways to analyze a package in runtime but they are involved and allow for very little to be done.</p><p>Packages are implemented at the top of Java's classpath and the classloader.</p></div></div></div>
<div class="section" title="The classpath and the classloader"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The classpath and the classloader</h1></div></div></div><p>Java was <a class="indexterm" id="id50"/>designed to be modular and for that it needs some way to load your code easily. The answer to this was the classloader, the classloader allows you to read resources from every entry of the classpath; you can look at resources in the classpath as a hierarchical structure similar to the file system.</p><p>The classloader <a class="indexterm" id="id51"/>is just a list of entries; each entry can be a directory in the filesystem or a JAR file. At this point, you should also know that JAR files are just zip files.</p><p>The classloader will treat each entry as a directory (JAR files are just zipped directories) and it will look for files in each directory.</p><p>There are a lot of concepts here to remember, let's try to summarize them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JAR files are ZIP files; they might contain several classes, properties, files, and so on.</li><li class="listitem" style="list-style-type: disc">The classpath is a list of entries; each entry is a JAR file or a system directory.</li><li class="listitem" style="list-style-type: disc">The classloader looks for resources in each entry of the classpath, so you can think of classpath resources as a combination of all the directories in the classpath (repeated resources are not overwritten)</li></ul></div><p>If you are not already familiar with how classloaders look for resources in classpath entries, this is the general process; let's imagine that you want to load a class: <code class="literal">test.Test</code>, what happens next?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You tell the JVM that you want to load <code class="literal">test.Test</code>.</li><li class="listitem">The JVM knows to look for the <code class="literal">test</code>/<code class="literal">Test.class</code> file.</li><li class="listitem">It starts looking for it in each entry of the classpath.</li><li class="listitem">If the resource is a ZIP file, it "unzips" the directory.</li><li class="listitem">It looks for the resource in the directory which represents the entry.</li></ol></div><p>If you were to see the default classpath resources, you will probably see something, such as:</p><div class="informalexample"><pre class="programlisting">java:
    lang:
        String.class
        ….
    io:
        IOException.class
        …
    util:
        List.class</pre></div><p>It is important<a class="indexterm" id="id52"/> to note that each entry in the classpath doesn't just store class files, it can actually store any type of resource, It is a commonplace to store configuration files, such as <code class="literal">.properties</code> or <code class="literal">.xml</code>.</p><p>Nothing forbids <a class="indexterm" id="id53"/>you from storing anything else in the classpath resources, such as images, mp3 or even code! You can read and access anything from the classpath's resource like you can from the filesystem at runtime. The one thing that you can't do is modify the classpath's resource contents (at least not without some esoteric magic).</p><div class="section" title="Back to Clojure namespaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Back to Clojure namespaces</h2></div></div></div><p>Now that<a class="indexterm" id="id54"/> we have had our little review of how packages and the classpaths work in Java, it's time to go back to Clojure. You should understand that Clojure attempts to make the hosting platform transparent; this means a couple of very important things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Anything that you can do with the classpath from Java, you can also do with Clojure (you can read configuration files, images, etc).</li><li class="listitem" style="list-style-type: disc">Namespaces use the classpath just as Java does with packages, which makes them easy to understand. Nevertheless, don't underestimate them, Clojure namespace declarations can be more involved.</li></ul></div><p>Let's get practical and play a little with namespaces.</p><div class="section" title="Playing with namespaces"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Playing with namespaces</h3></div></div></div><p>Lets <a class="indexterm" id="id55"/>create a new Playground, in order to create it use the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein new app ns-playground</strong></span>
</pre></div><p>You can open this project with IntelliJ, as we did in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Clojure">Chapter 1</a>, <span class="emphasis"><em>Getting Started with Clojure</em></span>.</p><p>Let's look in detail at what was created for us:</p><div class="mediaobject"><img alt="Playing with namespaces" src="graphics/4289_02_03.jpg"/></div><p>This project structure looks similar to Java projects, we have:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">resources</code>: These are the non-source files that get added to the classpath</li><li class="listitem" style="list-style-type: disc"><code class="literal">src</code>: Our source code</li><li class="listitem" style="list-style-type: disc"><code class="literal">test</code>: Our testing code</li></ul></div><p>The code <a class="indexterm" id="id56"/>inside <code class="literal">src</code> and <code class="literal">test</code> is already structured into namespaces: by having a quick look, we could say that the name of the namespace is <code class="literal">ns_playground</code>. Let's check the source code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core
  (:gen-class))

(defn -main
"I don't do a whole lot ... yet."
  [&amp; args]
  (println "Hello, World!"))
;; Code for src/ns_playground/core.clj</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<code class="literal">:gen-class</code> was added here in order to create a Java class and allow the Java interpreter to start a static main method. It is not needed if you don't intend to create a standalone program.</p></div></div><p>We can see <a class="indexterm" id="id57"/>that the (<code class="literal">ns ns-playground.core</code>) form has been used at the top, as you might have guessed, this is how we declare a namespace in Clojure.</p><p>If you are observant, you will notice something odd; the namespace has a dash instead of an underscore like the folder.</p><p>There are some reasons that lead to this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clojure like most lisp variable names can have dashes in it (it is actually the preferred style to name the variables, as opposed to camel case in Java).</li><li class="listitem" style="list-style-type: disc">Every namespace in Clojure is represented as a package containing several Java classes. The namespace is used as a name of the Java package and as you know, the dash is not acceptable in class or package names; so every filename and folder name must have low dashes.</li></ul></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Due to the nature of Lisp, you can use dashes in variable names (they will get converted to underscores at compile time). In fact, this is the recommended way to name your variables. In Clojure, (and most Lisps) <code class="literal">some-variable-name</code> is a more idiomatic style than <code class="literal">someVariableName</code>.</p></div></div></div></div><div class="section" title="Creating a new namespace"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Creating a new namespace</h2></div></div></div><p>Let's create<a class="indexterm" id="id58"/> a new namespace; in Cursive Clojure it is easy to do so, just right-click on the <code class="literal">ns_playground</code> package and go to <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Clojure Namespace</strong></span>, it asks for a name and we can call it <code class="literal">hello</code>.</p><p>This creates a <code class="literal">hello.clj</code> file with the following contents:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello)</pre></div><p>As you can see, namespace creation is quite easy; you can do it by hand with two simple steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file; it doesn't have to follow the package naming specification, but it helps to maintain your code order and it is a de facto practice.</li><li class="listitem">Add your namespace declaration.</li></ol></div><p>That's it! It is true, even though a namespace definition can become quite complex, as it is the place <a class="indexterm" id="id59"/>where you define the Java packages that you wish to import, namespaces or functions from those namespaces that you intend to use. But you will normally just use a subset of those capabilities.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Keep in mind that a namespace in Clojure is normally represented by a single file.</p></div></div><p>For your initial namespaces, I will advice you to have two of those capabilities in mind:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">:import</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows you to import the Java classes from a package that you wish to use</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">:require</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows you to bring in whatever Clojure namespace that you wish to use</p>
</td></tr></tbody></table></div><p>The syntax of both <code class="literal">require</code> and the <code class="literal">import</code> is simple, let's look at a couple of examples before we actually use it.</p><p>Let's start with the <code class="literal">import</code> option:</p><div class="informalexample"><pre class="programlisting">(:import java.util.List)</pre></div><p>You'll notice that this is similar to what you can do in Java, we are importing the <code class="literal">List</code> interface here.</p><p>The good thing with Clojure is that it allows you to do some more specific things. Let's check how to import two classes at once:</p><div class="informalexample"><pre class="programlisting">(:import [java.util ArrayList HashMap])</pre></div><p>You can extend this to the number of classes you want to use.</p><p>The <code class="literal">require</code> option uses a similar syntax and then builds some more on it. Let's check requiring a single function from a namespace:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :refer [a-function another-function]])</pre></div><p>As you can see, it is familiar and the interesting part is when you start importing everything:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :refer [:all]])</pre></div><p>You can also use a custom name for everything inside your package:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :as s])

;; And then use everything in the package like this:

(s/a-function 5)</pre></div><p>Or you could<a class="indexterm" id="id60"/> even combine different keywords:</p><div class="informalexample"><pre class="programlisting">(:require [some.package :as s :refer [a-function]])</pre></div><p>Let's try a bit of what we just learned, using the following code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello
  (:import [java.util Date]))

(def addition +)

(defn current-date []
"Returns the current date"
  (new Date))

(defn &lt;3 [love &amp; loved-ones]
"Creates a sequence of all the {loved-ones} {loved} loves"
  (for [loved-one loved-ones]
    (str love " love " loved-one)))

(defn sum-something [something &amp; nums]
"Adds something to all the remaining parameters"
  (apply addition something nums))

(def sum-one (partial sum-something 1))</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>You must have noticed the <code class="literal">&amp;</code> operator in the arguments of the <code class="literal">&lt;3</code> and <code class="literal">sum-something</code> functions; this allows those functions to receive any number of arguments and we can call them, as shown: (<code class="literal">sum-something 1 2 3 4 5 6 7 8</code>) or (<code class="literal">sum-something</code>) They are called <a class="indexterm" id="id61"/>
<span class="strong"><strong>variadic</strong></span> functions. In Java you will call this feature<a class="indexterm" id="id62"/> <span class="strong"><strong>varargs</strong></span>.</p></div></div><p>Everything looks great, but we haven't yet seen how to require and use these functions from some other package. Let's write a test to see how this will be done.</p></div><div class="section" title="Working with namespaces on the REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Working with namespaces on the REPL</h2></div></div></div><p>A <a class="indexterm" id="id63"/>great way of playing with namespaces is by using the REPL and we'll also get the benefit of getting to know it better.</p><p>Since we are going to play with namespace, we need to know of a few functions that will help us move between namespaces and require other namespaces. The functions are listed as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Sample usage</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">in-ns</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets <code class="literal">*ns*</code> to the namespace named by the symbol, creating it if needed.</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">in-ns 'ns-playground.core</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">require</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads <code class="literal">libs</code>, skipping any that are already loaded.</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">require '[clojure.java.io :as io]</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">import</code>
</p>
</td><td style="text-align: left" valign="top">
<p>For each name in <code class="literal">class-name-symbols</code>, adds a mapping from name to the class named by <code class="literal">package.name</code> to the current namespace.</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">import java.util.Date</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">refer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>refers to all public <code class="literal">vars</code> of <code class="literal">ns</code>, subject to filters.</p>
</td><td style="text-align: left" valign="top">
<p>(<code class="literal">refer 'clojure.string :only '[capitalize trim]</code>)</p>
</td></tr></tbody></table></div><p>Let's go into the <a class="indexterm" id="id64"/>REPL window of our IntelliJ. We can check what namespace we are in with the <code class="literal">*ns*</code> instruction. Let's try now:</p><div class="informalexample"><pre class="programlisting">*ns*
=&gt; #&lt;Namespace ns-playground.core&gt;</pre></div><p>Imagine that we need to execute a code and test the code from within the <code class="literal">ns-playground.hello</code> namespace, we can do that with the <code class="literal">in-ns</code> function:</p><div class="informalexample"><pre class="programlisting">(in-ns 'ns-playground.hello)
=&gt; #&lt;Namespace ns-playground.hello&gt;</pre></div><p>We want to know what <code class="literal">str</code> does, it seems to receive three strings:</p><div class="informalexample"><pre class="programlisting">(str "Hello""""world")
=&gt;"Hello world"</pre></div><p>Let's try the <code class="literal">for</code> form now:</p><div class="informalexample"><pre class="programlisting">(for [el ["element1""element2""element3"]] el)
=&gt; ("element1""element2""element3")

(for [el ["element1""element2""element3"]]
  (str "Hello " el))
=&gt; ("Hello element1""Hello element2""Hello element3")</pre></div><p>The <code class="literal">for</code> macro takes <a class="indexterm" id="id65"/>a collection of items and returns a new lazy sequence applying the body of the <code class="literal">for</code> to each element.</p><p>Knowing this, understanding the <code class="literal">&lt;3</code> function is easy, let's try it:</p><div class="informalexample"><pre class="programlisting">(&lt;3 "They""tea")
=&gt; ("They love tea")

(clojure.repl/doc &lt;3)
ns-playground.hello/&lt;3
([&amp; loved-ones])
  Creates a sequence of all the {loved-ones} {loved} loves</pre></div><p>We've used the REPL to test some simple functions, but let's now try to test something else like reading a properties file from the classpath.</p><p>We can add a <code class="literal">test.properties</code> file to the resources folder with the following contents:</p><div class="informalexample"><pre class="programlisting">user=user
test=password
sample=5</pre></div><p>Remember to restart the REPL, as the changes to the contents that some piece of the classpath points to are not visible to a running REPL.</p><p>Let's try reading our properties file as an input stream, we can use the <code class="literal">clojure.java.io</code> namespace to do it, and we can check it as shown:</p><div class="informalexample"><pre class="programlisting">(require '[clojure.java.io :as io])
(io/resource "test.properties")
=&gt; #&lt;URL file:/Users/iamedu/Clojure4Java/ns-playground/resources/test.properties&gt;
(io/input-stream (io/resource "test.properties"))
=&gt; #&lt;BufferedInputStream java.io.BufferedInputStream@2f584e71&gt;
;; Let's now load it into a properties object
(import [java.util Properties])
=&gt; java.util.Properties
(def props (Properties.)) ;; Don't worry about the weird syntax, we will look it soon.
=&gt; #'ns-playground.core/props
(.load props (io/input-stream (io/resource "test.properties")))
props
=&gt; {"user""user", "sample""5", "test""password"}</pre></div><p>We can now define our function for reading properties, we can input this into the REPL:</p><div class="informalexample"><pre class="programlisting">(defn read-properties [path]
  (let [resource (io/resource path)
        is (io/input-stream resource)
        props (Properties.)]
    (.load props is)
    (.close is)
    props))
=&gt; #'ns-playground.core/read-properties
(read-properties "test.properties")
=&gt; {"user""user", "sample""5", "test""password"}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">let</code> form lets us create local 'variables', instead of using the (<code class="literal">io/resource path</code>) directly in the code. We can create a reference once and use it through the code. It allows us to use simpler code and to have a single reference to an object.</p></div></div><p>In the end, we <a class="indexterm" id="id66"/>can redefine the <code class="literal">hello</code> namespace to include everything we've checked, such as this:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.hello
  (:require [clojure.java.io :as io])
  (:import [java.util Date Properties]))

(def addition +)

(defn current-date []
"Returns the current date"
  (new Date))

(defn &lt;3 [love &amp; loved-ones]
"Creates a sequence of all the {loved-ones} {loved} loves"
  (for [loved-one loved-ones]
    (str love " love " loved-one)))

(defn sum-something [something &amp; nums]
"Adds something to all the remaining parameters"
  (apply addition something nums))

(defn read-properties [path]
  (let [resource (io/resource path)
        is (io/input-stream resource)
        props (Properties.)]
    (.load props is)
    props))


(def sum-one (partial sum-something 1))</pre></div><p>Remember to<a class="indexterm" id="id67"/> include the <code class="literal">Properties</code> class in the <code class="literal">import</code> and to define the <code class="literal">:require</code> keyword for <code class="literal">clojure.java.io</code>.</p></div></div>
<div class="section" title="Testing in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Testing in Clojure</h1></div></div></div><p>Clojure <a class="indexterm" id="id68"/>already<a class="indexterm" id="id69"/> comes with a unit testing support built-in, as a matter of fact Leiningen has already created a test for us; let's take a look at it right now.</p><p>Open the <code class="literal">test/ns_playground/core_test.clj</code> file, you should be able to see this code:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core-test
  (:require [clojure.test :refer :all]
            [ns-playground.core :refer :all]))
(deftest a-test
  (testing "FIXME, I fail."
(is (= 0 1))))</pre></div><p>Again, as you can see, we are using <code class="literal">:require</code> to include functions from the <code class="literal">clojure.test</code> and the <code class="literal">ns-playground.core</code> packages.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Remember, the <code class="literal">:refer :all</code> works similar to how <code class="literal">char import static clojure.test.*</code> will work in Java.</p></div></div><div class="section" title="Testing from the command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Testing from the command line</h2></div></div></div><p>Let's first <a class="indexterm" id="id70"/>learn how to run these tests. From the command line, you can run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein test</strong></span>
</pre></div><p>You should get the following output:</p><div class="informalexample"><pre class="programlisting">lein test ns-playground.core-test

lein test :only ns-playground.core-test/a-test

FAIL in (a-test) (core_test.clj:7)
FIXME, I fail.
expected: (= 0 1)
  actual: (not (= 0 1))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.</pre></div><p>We see that<a class="indexterm" id="id71"/> there is one test failing, we will go back to this in a bit; for now, let's see how to test in IntelliJ.</p></div><div class="section" title="Testing in IntelliJ"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Testing in IntelliJ</h2></div></div></div><p>First of all, we <a class="indexterm" id="id72"/>need a new REPL configuration. You can do it as you learned in the previous chapter. You just need to follow the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right click on the <code class="literal">project.clj</code> file and select <span class="strong"><strong>Create REPL for ns-playground,</strong></span> as shown in the following screenshot:<div class="mediaobject"><img alt="Testing in IntelliJ" src="graphics/4289_02_01.jpg"/></div></li><li class="listitem">Then click on <span class="strong"><strong>OK</strong></span> in the next dialog.</li><li class="listitem">After <a class="indexterm" id="id73"/>that, you should run the REPL again by right clicking the <code class="literal">project.clj</code> file and selecting <span class="strong"><strong>Run REPL for ns-playground</strong></span>.</li><li class="listitem">After that you can run any tests, just open your test file and go to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Run Tests</strong></span> in the current NS in REPL. You should see something similar to the following screenshot:<div class="mediaobject"><img alt="Testing in IntelliJ" src="graphics/4289_02_02.jpg"/></div></li><li class="listitem">As you<a class="indexterm" id="id74"/> can see, it signals that your test is currently failing. Let's fix it and run our test again. Change the <code class="literal">(is (= 0 1))</code> line to <code class="literal">(is (= 1 1))</code>.</li><li class="listitem">Now, let's try some real tests for our previously defined functions; don't worry if you can't understand all the code for now, you are not supposed to:<div class="informalexample"><pre class="programlisting">(ns ns-playground.hello-test
  (:import [java.util Date])
  (:require [clojure.test :refer :all]
            [ns-playground.hello :as hello :refer [&lt;3]]
            [ns-playground.core :refer :all]))

(defn- lazy-contains? [col element]
  (not (empty? (filter #(= element %) col))))

(deftest a-test
  (testing "DONT FIXME, I don't fail."
    (is (= 42 42))))

(deftest current-date-is-date
  (testing "Test that the current date is a date"
    (is (instance? Date (hello/current-date)))))

(deftest check-loving-collection
  (testing "Check that I love clojure and you"
    (let [loving-seq (&lt;3 "I""Clojure""you""doggies""chocolate")]
      (is (not (lazy-contains? loving-seq "I love Vogons")))
      (is (lazy-contains? loving-seq "I love Clojure"))
      (is (lazy-contains? loving-seq "I love doggies"))
      (is (lazy-contains? loving-seq "I love chocolate"))
      (is (lazy-contains? loving-seq "I love you")))))</pre></div></li></ol></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>We can't use the Clojure contents function here because it has a different function. It looks for keys in a map.</p></div></div><p>Run the <a class="indexterm" id="id75"/>tests and you'll see that everything passes correctly but there's a lot going on over here, let's go over it little by little:</p><div class="informalexample"><pre class="programlisting">(ns ns-playground.core-test
  (:import [java.util Date])
  (:require [clojure.test :refer :all]
            [ns-playground.hello :as hello :refer [&lt;3]]
            [ns-playground.core :refer :all]))</pre></div><p>This is the namespace declaration, let's list everything it does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It declares the <code class="literal">ns-playground.core-test</code> package.</li><li class="listitem" style="list-style-type: disc">It imports the <code class="literal">java.util.Date</code> class.</li><li class="listitem" style="list-style-type: disc">It makes everything in the <code class="literal">clojure.test</code> namespace available in the current namespace, if we were in Java we might have used <code class="literal">import static clojure.test.*</code> to get a similar effect. We can achieve this with the <code class="literal">:refer :all</code> keywords.</li><li class="listitem" style="list-style-type: disc">It makes everything in the <code class="literal">ns-playground.hello</code> namespace available with the hello shortcut but we need to prefix every function or value defined in <code class="literal">ns-playground.hello</code> with hello and it also makes the <code class="literal">&lt;3</code> function available without a prefix. To generate an alias and make everything available with the <code class="literal">hello</code> alias, we use the <code class="literal">:as</code> keyword and then pass a vector to <code class="literal">:refer</code> to include certain elements.</li><li class="listitem" style="list-style-type: disc">It makes everything in the <code class="literal">ns-playground.core</code> namespace available in the current namespace. We achieve this with the <code class="literal">:refer :all</code> keywords.<div class="informalexample"><pre class="programlisting">(defn- lazy-contains? [col element]
  (not (empty? (filter #(= element %) col))))</pre></div></li></ul></div><p>This is the declaration of a function called <code class="literal">lazy-contains?</code>, it is a <code class="literal">boolean</code> function and it is customary in Clojure to call it a predicate.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>The name of the function including the question mark might be something that looks awkward to you. In Clojure and Lisp, you can use question marks in the names of functions and it is common to do it for functions that return Booleans.</p></div></div><p>It receives two parameters: <code class="literal">col</code> and <code class="literal">element</code>.</p><p>The actual<a class="indexterm" id="id76"/> body of the function looks a bit complicated but it is actually very simple. Whenever you encounter a function that looks similar to the one mentioned in the preceding section, try to read it from the inside out. The innermost part is, as follows:</p><div class="informalexample"><pre class="programlisting">#(= element %)</pre></div><p>This is a shorter way of writing an anonymous function which has a single parameter. If we want to write another function that compares its argument against the <code class="literal">element</code>, without the syntactic sugar, we can do it in the following method:</p><div class="informalexample"><pre class="programlisting">(fn [e1]
  (= element e1))</pre></div><p>This is an anonymous function or in other words it is a function that has no name, but it works as every other function; we will read more about anonymous functions when we get back to functional programming.</p><p>Our anonymous function is a parameter to the following form:</p><div class="informalexample"><pre class="programlisting">(filter #(= element %) col)</pre></div><p>This new form filters the collection <code class="literal">col</code> and returns a new collection with only the elements that pass the test. Let's see an example where we have used the predefined Clojure function <code class="literal">even?</code>:</p><div class="informalexample"><pre class="programlisting">;; This returns only the even numbers in the collection
(filter even? [1 2 3 4])
;;=&gt; (2 4)</pre></div><p>Our filter function now returns every element in the collection that passes the <code class="literal">#(= element %)</code>test. So we get every element that is equal to the element passed to <code class="literal">lazy-contains?</code>.</p><p>We then ask if none of the elements equal to <code class="literal">element</code> in <code class="literal">col</code> with the following form:</p><div class="informalexample"><pre class="programlisting">(empty? (filter #(= element %) col))</pre></div><p>But we want to know if there is some element equal to element, so at last we negate the previous form:</p><div class="informalexample"><pre class="programlisting">(not (empty? (filter #(= element %) col)))</pre></div><p>Imagine that if you had to write this in Java (and I asked to add every element that matches the element to a list), you will have something similar to this:</p><div class="informalexample"><pre class="programlisting">List&lt;T&gt; filteredElements = new ArrayList&lt;T&gt;();
for(T e1 : col) {
    if(e1 == element) {
        filteredElements.add(e1);
    }
}
return !filteredElements.isEmpty();</pre></div><p>There is a big <a class="indexterm" id="id77"/>difference, it is more verbose and to understand it we need to "run" the algorithm in our heads. This is called imperative programming, Clojure allows us to do imperative programming as well as functional programming, which is a type of declarative programming. When you get used to it, you'll see that it's easier to reason about than loops.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Interactive programming means, telling every step of how something should be done to a computer. Declarative programming just asks for a result and doesn't give details of how to achieve it.</p></div></div><p>The actual tests are simple to understand:</p><div class="informalexample"><pre class="programlisting">(deftest current-date-is-date
  (testing "Test that the current date is a date"
    (is (instance? Date (hello/current-date)))))</pre></div><p>This test checks the current date returns an instance of <code class="literal">java.util.Date</code>, the <code class="literal">is</code> form works as the Java assert instruction:</p><div class="informalexample"><pre class="programlisting">(deftest check-loving-collection
  (testing "Check that I love clojure and you"
    (let [loving-seq (&lt;3 "I""Clojure""you""doggies""chocolate")]
      (is (not (lazy-contains? loving-seq "I love Vogons")))
      (is (lazy-contains? loving-seq "I love Clojure"))
      (is (lazy-contains? loving-seq "I love doggies"))
      (is (lazy-contains? loving-seq "I love chocolate"))
      (is (lazy-contains? loving-seq "I love you")))))</pre></div><p>This test checks the <code class="literal">&lt;3</code> function, it checks that the returned collection contains <code class="literal">I love Clojure</code>, <code class="literal">I love doggies</code>, <code class="literal">I love chocolate</code> and <code class="literal">I love you</code> and it should not contain <code class="literal">I love Vogons</code>.</p><p>This test is simple to understand. What might be not so simple to understand is the <code class="literal">&lt;3</code> function, we'll look into it with the REPL.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we got to know some utilities that we can use for better management of our code and we have some more examples of everyday Clojure code. In particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working of namespace in Clojure and their relation to Java packages</li><li class="listitem" style="list-style-type: disc">Writing out-of-the-box unit tests and executing them with Leiningen and Cursive Clojure</li><li class="listitem" style="list-style-type: disc">Delving into the Clojure Interactive development workflow and a bit of the Clojure mindset</li><li class="listitem" style="list-style-type: disc">Writing very simple functions and testing them</li></ul></div><p>In the next chapter, we will learn about Java interop, so we can start using the familiar classes and libraries we already know in our Clojure code.</p><p>We will also learn how to use Clojure from Java, so you can start using it in your everyday Java projects.</p></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;Interacting with Java"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Interacting with Java</h1></div></div></div><p>We know a bit about how to organize our code and how that relates to packages in Java. Now, you surely need to use your old Java code and all the libraries you already know; Clojure encourages a new way to think about programming and it also allows you to use all the dependencies and code that you've already generated.</p><p>Clojure is a <span class="strong"><strong>Java Virtual Machine</strong></span> (<span class="strong"><strong>JVM</strong></span>) language <a class="indexterm" id="id78"/>and as such it is compatible with most Java dependencies and libraries out there; you should be able to use all the tools out there. You should also be able to use your Clojure programs with Java-only programs, this requires a bit of custom coding but in the end you can use Clojure in the right places of your project.</p><p>To be able to do this, we'll have to learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using Maven dependencies</li><li class="listitem" style="list-style-type: disc">Using plain old Java classes from your Clojure code base</li><li class="listitem" style="list-style-type: disc">A bit more about the Clojure language, in particular the <code class="literal">let</code> statements and destructuring</li><li class="listitem" style="list-style-type: disc">Creating a Java interface for your Clojure code</li><li class="listitem" style="list-style-type: disc">Using the Java interface from other Java projects</li></ul></div><div class="section" title="Using Maven dependencies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Using Maven dependencies</h1></div></div></div><p>Let's say<a class="indexterm" id="id79"/> that we want to write an image manipulation program; it is a very simple program that should be able to create thumbnails. Most of our codebase is in Clojure, so we want to write this in Clojure too.</p><p>There are a bunch of Java libraries meant to manipulate images, we decide to use imgscalr, which is very simple to use and it looks like it is available in<a class="indexterm" id="id80"/> Maven Central (<a class="ulink" href="http://search.maven.org/">http://search.maven.org/</a>).</p><p>Let's create a new Leiningen project, as shown:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein new thumbnails</strong></span>
</pre></div><p>Now, we need to edit the <code class="literal">project.clj</code> file in the thumbnails project:</p><div class="informalexample"><pre class="programlisting">(defproject thumbnails "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]])</pre></div><p>You can add the <code class="literal">imgscalr</code> dependency similar to the following code:</p><div class="informalexample"><pre class="programlisting">(defproject thumbnails "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.imgscalr/imgscalr-lib "4.2"]])</pre></div><p>As you can <a class="indexterm" id="id81"/>see, you just need to add a dependency to the <code class="literal">:dependencies</code> vector, the dependencies are automatically resolved from:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Maven Local</li><li class="listitem" style="list-style-type: disc">Maven Central</li><li class="listitem" style="list-style-type: disc">Clojars</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The Maven Local points to your local maven repository that is in the <code class="literal">~/.m2</code> folder. If you wish, you can change it with Leiningen's <code class="literal">:local-repo</code> key.</p></div></div><p>You can add your own repositories, let's say you need to add <a class="indexterm" id="id82"/>
<span class="strong"><strong>jcenter</strong></span> (Bintray's Java repository) you can do so, as shown:</p><div class="informalexample"><pre class="programlisting">(defproject thumbnails "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.imgscalr/imgscalr-lib "4.2"]]
  :repositories [["jcenter" "http://jcenter.bintray.com/"]])</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Leiningen supports a wide array of options to configure your project, for more information you can check the sample at Leiningen's official repository: <a class="ulink" href="https://github.com/technomancy/leiningen/blob/master/sample.project.clj">https://github.com/technomancy/leiningen/blob/master/sample.project.clj</a>.</p></div></div><p>In order to download the dependencies, you have to execute the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein deps</strong></span>
</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>You don't need to execute <code class="literal">lein deps</code> every time you want to download dependencies, you can do it to force a download but Leiningen will automatically download them when it needs to.</p></div></div><p>You can <a class="indexterm" id="id83"/>check the current dependencies by running:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>lein deps :tree</strong></span>
</pre></div><p>You will get something similar to this:</p><div class="informalexample"><pre class="programlisting"> [clojure-complete "0.2.3" :scope "test" :exclusions [[org.clojure/clojure]]]
 [org.clojure/clojure "1.6.0"]
 [org.clojure/tools.nrepl "0.2.6" :scope "test" :exclusions [[org.clojure/clojure]]]
 [org.imgscalr/imgscalr-lib "4.2"]</pre></div><p>This lists your current dependency tree.</p></div></div>
<div class="section" title="Clojure interop syntax"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Clojure interop syntax</h1></div></div></div><p>Clojure was designed to <a class="indexterm" id="id84"/>be a Hosted Language, which means that it can run in different environments or runtimes. One important philosophy aspect is that Clojure does not attempt to get in the way of your original host; this allows you to use your knowledge of the underlying platform to your advantage.</p><p>In this case, we are using the Java platform. Let's look at the basic interrupt syntax that we need to know.</p><div class="section" title="Creating an object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Creating an object</h2></div></div></div><p>There <a class="indexterm" id="id85"/>are two ways to create an object in Clojure; for example, let's have a look at how to create an instance of <code class="literal">java.util.ArrayList</code>.</p><div class="informalexample"><pre class="programlisting">(def a (new java.util.ArrayList 20))</pre></div><p>Here, we are using the <code class="literal">new</code> special form, as you can see it receives a symbol (the name of the class <code class="literal">java.util.ArrayList</code>) and in this case it is an integer.</p><p>The symbol <code class="literal">java.util.ArrayList</code> represents the <code class="literal">classname</code> and any Java class name will do here.</p><p>Next, you<a class="indexterm" id="id86"/> can actually pass any number of parameters (including <code class="literal">0</code> parameters). The next parameters are the parameters of the constructor.</p><p>Lets have a look at the other special syntax that is available to create objects:</p><div class="informalexample"><pre class="programlisting">(def a (ArrayList.))</pre></div><p>The difference here is that we have a trailing dot; we prefer to see this syntax since it is shorter.</p></div><div class="section" title="Calling an instance method"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Calling an instance method</h2></div></div></div><p>Once we <a class="indexterm" id="id87"/>have created our object we can call instance methods. This is done similar to how we call Clojure functions, using the special dot form.</p><p>If we want to add an element to our newly created list, we will have to do it, as shown:</p><div class="informalexample"><pre class="programlisting">(. add a 5)</pre></div><p>This syntax might look a little strange; here is how this syntax is formed:</p><div class="informalexample"><pre class="programlisting">(. instance method-name args*)</pre></div><p>Similar to the two different options that we had when creating an object, we have another way to do this:</p><div class="informalexample"><pre class="programlisting">(.method-name instance args*)</pre></div><p>You might think that this is more familiar, since the method name starting with a dot resembles how we write the Java method calls.</p></div><div class="section" title="Calling a static method or function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Calling a static method or function</h2></div></div></div><p>Being<a class="indexterm" id="id88"/> able to call methods and create objects gives us a great deal of power, with this simple construct we have gained a lot of power; we can now use most of the Java standard libraries and also the custom ones.</p><p>However, we <a class="indexterm" id="id89"/>still need a few more things; one of the most important ones is calling static methods. The static methods have a feel similar to Clojure functions, there is no <code class="literal">this</code> instance, you can simply call them as normal Clojure functions.</p><p>For instance, if we want an <code class="literal">emptyMap</code> from the <code class="literal">Collections</code> class, we can do it as shown:</p><div class="informalexample"><pre class="programlisting">(java.util.Collections/emptyMap)</pre></div><p>You can think of static methods as functions and the class as a namespace. It is not exactly right but the mental model will help you understand it easily.</p></div><div class="section" title="Accessing inner classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Accessing inner classes</h2></div></div></div><p>Another <a class="indexterm" id="id90"/>common doubt when using Java – Clojure interop is how to access inner classes.</p><p>Imagine you want to represent a single entry from a map with the <code class="literal">java.util.AbstractMap.SimpleEntry</code> class.</p><p>You might think that we have to do something similar to this:</p><div class="informalexample"><pre class="programlisting">(java.util.AbstractMap.SimpleEntry. "key" "value")</pre></div><p>That's what you will normally do when writing Java, but in Clojure you might need to do something such as this:</p><div class="informalexample"><pre class="programlisting">(java.util.AbstractMap$SimpleEntry. "key" "value")</pre></div><p>What we are seeing here is actually an exposed implementation detail; if you look at the classes in the JAR files or in your classpath, you will see the precise file name <code class="literal">AbstractMap$SimpleEntry</code>, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Accessing inner classes" src="graphics/B04289_03_01.jpg"/></div><p>This is what you need to keep in mind, always prefix the inner classes with the parent (or more correctly containing) class (in this case <code class="literal">java.util.AbstractMap</code>) and the dollar sign.</p></div></div>
<div class="section" title="Writing a simple image namespace"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Writing a simple image namespace</h1></div></div></div><p>Let's <a class="indexterm" id="id91"/>now write some Clojure code and create a file in <code class="literal">src/thumbnails/image.clj</code>.</p><p>Let's try to do this the Clojure way. First of all, write the namespace declaration and evaluate it:</p><div class="informalexample"><pre class="programlisting">(ns thumbnails.image
  (:require [clojure.java.io :as io])
  (:import [javax.imageio ImageIO]
           [java.awt.image BufferedImageOp]
           [org.imgscalr Scalr Scalr$Mode]))</pre></div><p>Now open up a REPL and write the following code:</p><div class="informalexample"><pre class="programlisting">(def image-stream (io/input-stream "http://imgs.xkcd.com/comics/angular_momentum.jpg"))(def image (ImageIO/read image-stream))
image
(.getWidth image)</pre></div><p>We now have <a class="indexterm" id="id92"/>an image instance and you can call all of the Java methods in the REPL. This is one of Clojure's core concepts, you can play with the REPL and check your code before really writing it and you can do it in an interactive way, as shown:</p><div class="mediaobject"><img alt="Writing a simple image namespace" src="graphics/B04289_03_02.jpg"/></div><p>In the end, we want to stick<code class="literal"> </code>with the following contents:</p><div class="informalexample"><pre class="programlisting">(ns thumbnails.image
  (:require [clojure.java.io :as io])
  (:import [javax.imageio ImageIO]
           [java.awt.image BufferedImageOp]
           [org.imgscalr Scalr Scalr$Mode]))


(defn load-image [image-stream]
  (ImageIO/read image-stream))

(defn save-image [image path]
  (ImageIO/write image "PNG" (io/output-stream path)))

(defn image-size [image]
  [(.getWidth image) (.getHeight image)])

(defn generate-thumbnail [image size]
  (Scalr/resize image Scalr$Mode/FIT_TO_WIDTH size (into-array BufferedImageOp [])))

(defn get-image-width [image-path]
  (let [image (load-image image-path)
        [w _] (image-size image)]
    w))</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>You can see that in this code we use the inner class syntax, with <code class="literal">Scalr$Mode</code>. Mode is not actually a class but an <code class="literal">enum</code>, you can use the same syntax for all other inner types.</p></div></div><p>The code is <a class="indexterm" id="id93"/>pretty simple, it is very similar to what you've already seen; we'll go through the differences either way.</p><p>You can import the following classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">javax.imageio.ImageIO</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.awt.image.BufferedImageOp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.imgscalr.Scalr</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.imgscalr.Scalr.Mode</code></li></ul></div><p>You have to be careful with the <code class="literal">Mode</code> class, since it is an inner class (it is inside another class) Clojure uses the special name <code class="literal">Scalr$Mode</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>When importing inner classes, you have to be careful with the naming process, in Java you will use the name: <code class="literal">org.imgscalr.Scalr.Mode</code>; in Clojure you use the name: <code class="literal">org.imgscalr.Scalr$Mode</code>. The <code class="literal">load-image</code>, <code class="literal">save-image</code>, and <code class="literal">image-size</code> functions are self explanatory and the <code class="literal">generate-thumbnail</code> function is pretty simple as well; however, it has a special detail, it calls the following as the last argument:</p><div class="informalexample"><pre class="programlisting">(into-array BufferedImageOp [])</pre></div></div></div><p>If you look at the <a class="indexterm" id="id94"/>ImageScalr javadoc, (<a class="ulink" href="http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html">http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html</a>) you can see that the <code class="literal">resize</code> method has several overloaded implementations; most of them have a <code class="literal">varargs</code> argument as their last argument. In Clojure, you have to declare these <code class="literal">varargs</code> arguments as an array.</p></div>
<div class="section" title="Writing the tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Writing the tests</h1></div></div></div><p>Now that you <a class="indexterm" id="id95"/>have written your image processing code, it is a good time to write the tests.</p><p>Let's just check if we can generate a thumbnail. Create a new <code class="literal">thumbnails.thumbnail-test</code> namespace, in the tests.</p><p>Remember, if you create the file, it must be named <code class="literal">test/thumbnails/thumbnail_test.clj</code>.</p><p>Add the <a class="indexterm" id="id96"/>following contents to it:</p><div class="informalexample"><pre class="programlisting">(ns thumbnails.thumbnail-test
  (:require [clojure.test :refer :all]
            [clojure.java.io :as io]
            [thumbnails.image :refer :all]))

(deftest test-image-width
  (testing "We should be able to get the image with"
    (let [image-stream (io/input-stream "http://imgs.xkcd.com/comics/angular_momentum.jpg")
          image (load-image image-stream)]
      (save-image image "xkcd-width.png")
      (is (= 600 (get-image-width (io/input-stream "xkcd-width.png")))))))

(deftest test-load-image
  (testing "We should be able to generate thumbnails"
    (let [image-stream (io/input-stream "http://imgs.xkcd.com/comics/angular_momentum.jpg")
          image (load-image image-stream)
          thumbnail-image (generate-thumbnail image 50)]
      (save-image thumbnail-image "xkcd.png")
      (is (= 50 (get-image-width (io/input-stream "xkcd.png")))))))</pre></div><p>Here we are using some unknown features, such as the <code class="literal">let</code> form and destructuring. We will see this in more detail in the next section.</p><div class="section" title="The let statement"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>The let statement</h2></div></div></div><p>Clojure <a class="indexterm" id="id97"/>gives us a <code class="literal">let</code> statement to name things; it allows us to do something very similar to variable declaration in other languages.</p><p>Keep in mind that we are not actually creating a variable in the same sense, as in Java. In Java, whenever we declare a variable. We state that we want to reserve a certain amount of memory to store something in the later stages; it can be a value for primitives or a memory location for objects. What we do here is simply name a value. This is a local scope that is useful to write cleaner and easier to understand code. Lets have a look at how it works:</p><div class="informalexample"><pre class="programlisting">(let [x 42] x)</pre></div><p>This is the simplest <code class="literal">let</code> statement that we could write and it is exactly the same as just writing <code class="literal">42</code>. However, we can write something a little more complex, such as this:</p><div class="informalexample"><pre class="programlisting">(let [x 42
      y (* x x)]
  (println "x is " x " and y " y))</pre></div><p>It looks <a class="indexterm" id="id98"/>self explanatory; to value <code class="literal">42</code> and <code class="literal">y,</code> we are assigning the value of multiplying <code class="literal">42</code> by <code class="literal">42</code>. In the end, we print <code class="literal">x is 42 and y 1764</code>. It is important to note two things here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can use a previously defined value in the <code class="literal">let</code> statement; for example, we use <code class="literal">x</code> when defining <code class="literal">y</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">let</code> statement creates a scope, we can't use <code class="literal">x</code> or <code class="literal">y</code> outside of our <code class="literal">let </code>statement.</li></ul></div><p>The <code class="literal">let</code> statement can even be nested, we could do something similar to the following example:</p><div class="informalexample"><pre class="programlisting">(let [x 42]
  (let [y (* x x)]
    (println "x is " x " and y " y)))</pre></div><p>It is a bit more complicated, since we are opening an unneeded set of parentheses and also writing more code; however, it allows us to see how lexical scope works.</p><p>Lets have a look at another interesting example:</p><div class="informalexample"><pre class="programlisting">(let [x 42]
  (let [y (* x x)]
    (let [x 41]
      (println "x is " x " and y " y))))</pre></div><p>In here, we are masking the value of <code class="literal">x</code> with <code class="literal">41</code> and again these are not variables. We are not changing a memory region, we are merely creating a new scope with a new <span class="emphasis"><em>X</em></span> value.</p><p>Going back to our test, the <code class="literal">let</code> statement begins with the following code:</p><div class="informalexample"><pre class="programlisting">image (load-image image-path)</pre></div><p>It is pretty clear to understand, but the next line might prove a bit more difficult:</p><div class="informalexample"><pre class="programlisting">[w _] (image-size image)</pre></div><p>It looks pretty strange; we are assigning the value of (<code class="literal">image-size image</code>) to <code class="literal">[w _]</code> but <code class="literal">[w _]</code> is not a symbol name!</p><p>What is happening here is that we are using a mechanism called destructuring to take the result of (<code class="literal">image-size image</code>) apart and just use the piece of information that we are interested in, which in this case is the width of the image.</p><p>Destructuring is one of the key features of Clojure, it can be used almost everywhere where symbol binding happens, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Let expressions</li><li class="listitem" style="list-style-type: disc">Function parameter lists</li></ul></div><p>Destructuring <a class="indexterm" id="id99"/>helps write more concise code but it might strike you as strange when you are not used to it. Let's talk about it in depth in the next section.</p></div></div>
<div class="section" title="Destructuring in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Destructuring in Clojure</h1></div></div></div><p>Destructuring <a class="indexterm" id="id100"/>is a feature in Clojure that is not common in other lisps; the <a class="indexterm" id="id101"/>idea is to allow you to write more concise code in scenarios where code doesn't really add value (for example, getting the first element from a list or the second parameter from a function) and concentrating only on what is important to you.</p><p>In order to understand this better, let's see an example of why destructuring can help you:</p><div class="informalexample"><pre class="programlisting">(let [v [1 2 3]] [(first v) (nth v 2)]) ;; [1 3]</pre></div><p>What's wrong with the previous code? Nothing really, but you need to start thinking about what is <code class="literal">v</code>, what the first value of <code class="literal">v</code> is, what the nth function does, and at what index <code class="literal">v</code> starts.</p><p>Instead we can do this:</p><div class="informalexample"><pre class="programlisting">(let [[f s t] [1 2 3]] [f t]) ;; [1 3]</pre></div><p>Once you are used to destructuring, you will see that you don't need to think about how to get the elements you need. In this case, we directly access the first, second, and third elements from our vector and use the first and third out of the three elements. With good naming it can become even easier.</p><p>Lets now take a deep dive into what destructuring is.</p><p>There are two types of destructuring:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sequential destructuring</strong></span>: It <a class="indexterm" id="id102"/>allows us to take sequential data structures apart and bind the values that you are interested in directly to symbols</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Associative destructuring</strong></span>: It <a class="indexterm" id="id103"/>allows us to take maps apart and bind only the key reference values that you are interested in directly to symbols</li></ul></div><div class="section" title="Sequential destructuring"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Sequential destructuring</h2></div></div></div><p>Sequential destructuring <a class="indexterm" id="id104"/>should be easy to understand with some examples; lets have a look:</p><div class="informalexample"><pre class="programlisting">(let [[f s] [1 2]] f) ;; 1
(let [[f s t] [1 2 3]] [f t]) ;; [1 3]
(let [[f] [1 2]] f);; 1
(let [[f s t] [1 2]] t);; nil
(let [[f &amp; t [1 2]] t);; (2)
(let [[f &amp; t [1 2 3]] t);; (2 3)
(let [[f &amp; t [1 2 3]] t);; (2 3)
(let [[f &amp; [_ t]] [1 2 3]] [f t])</pre></div><p>In these examples, as convention, we use <code class="literal">f</code> for first, <code class="literal">s</code> for second, <code class="literal">t</code> for third, and <code class="literal">a</code> for all the others.</p><p>The same destructuring idea and syntax can be used with function parameters, as shown in the next example:</p><div class="informalexample"><pre class="programlisting">(defn func [[f _ t]]
  (+ f t))
(func [1 2 3]) ;; 4</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Here we use the symbol <code class="literal">_</code>, there is a convention in Clojure to use the <code class="literal">_</code> symbol whenever you are not interested in some value and you don't need to use it in the future. In the previous example, we aren't interested in the second parameter of the <code class="literal">func</code> function.</p></div></div><p>As you can see, it lets us write a much more concise code and focus only on what's important, which is the algorithm or business.</p></div><div class="section" title="Associative destructuring"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Associative destructuring</h2></div></div></div><p>We've <a class="indexterm" id="id105"/>already seen sequential destructuring that allows getting certain elements of a sequence by index. In Clojure, there is also associative destructuring, which allows you to take just the keys of the map in which you are interested.</p><p>Again, an example is worth more than a thousand words:</p><div class="informalexample"><pre class="programlisting">(let [{a-value a} {: a-value  5}] a-value) ;; 5
(let [{a-value :a c-value :c} {:a 5 :b 6 :c 7}] c-value) ;; 7
(let [{:keys [a c]} {:a 5 :b 6 :c 7}] c) ;; 7
(let [{:syms [a c]} {'a 5 :b 6 'c 7}] c) ;; 7
(let [{:strs [a c]} {:a 5 :b 6 :c 7 "a" 9}] [a c]) ;; [9 nil]
(let [{:strs [a c] :or {c 42}} {:a 5 :b 6 :c 7 "a" 9}] [a c]) ;; [9 42]</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Thinking of symbols as keys to a map can feel strange, nonetheless it is important to remember this feature; it could come in handy at some point.</p></div></div><p>As you can see, it's pretty simple too, but we have a few more options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can reference some keys and assigning them a name, as shown in the first and second example</li><li class="listitem" style="list-style-type: disc">We can reference keyword keys, as in the third example</li><li class="listitem" style="list-style-type: disc">We can reference string keys, as in the fourth example</li><li class="listitem" style="list-style-type: disc">We can define default values with the <code class="literal">:or</code> keyword!</li></ul></div><p>Destructuring <a class="indexterm" id="id106"/>is one of the most used features of Clojure and it allows you to write very concise code.</p><p>Going back to our test code, it should now be pretty easy to understand the get-<code class="literal">image-width</code> function:</p><div class="informalexample"><pre class="programlisting">(defn get-image-width [image-path]
  (let [image (load-image image-path)
        [w _] (image-size image)]
    w))</pre></div><p>As you can see, it sets the image value as the loaded image and then it calculates the width, gets the width only and returns that value.</p><p>We can now understand the <code class="literal">test-load-image</code> test:</p><div class="informalexample"><pre class="programlisting"> (deftest test-load-image
  (testing "We should be able to generate thumbnails"
    (let [image-stream    (io/input-stream "http://imgs.xkcd.com/comics/angular_momentum.jpg")
          image           (load-image image-stream)
          thumbnail-image (generate-thumbnail image 50)]
      (save-image thumbnail-image "xkcd.png")
      (is (= 50 (get-image-width (io/input-stream "xkcd.png")))))))</pre></div><p>It just initializes an <code class="literal">image-stream</code> value, it then loads an image from that stream and generates a thumbnail. It finally loads the generated thumbnail and checks that the image width is 50px.</p><p>Now that we've written our tests and we are sure that everything works, we can use our little library from the Clojure projects, but what happens if we want to use it from a pure Java (or groovy, or scala) project?</p></div></div>
<div class="section" title="Exposing your code to Java"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Exposing your code to Java</h1></div></div></div><p>If you want to be <a class="indexterm" id="id107"/>able to use Clojure code from other JVM languages, in Clojure, there are a couple of ways in which you can do it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can generate new Java classes and use them as you normally would; it can implement some interface or extend from some other class</li><li class="listitem" style="list-style-type: disc">You can generate a proxy on the fly, this way you can implement a contract (in the form of a class or an interface) that some framework requires with little code and effort</li><li class="listitem" style="list-style-type: disc">You can use the <code class="literal">clojure.java.api</code> package to call Clojure functions directly from Java</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>You can find more information on how this works at the following location: <a class="ulink" href="http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html">http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html</a>.</p></div></div><p>Let's have a look at how we can define a Java class.</p><p>Create a new namespace called <code class="literal">thumbnails.image-java</code> and write the following code:</p><div class="informalexample"><pre class="programlisting">(ns thumbnails.image-java
  (:require [thumbnails.image :as img])
  (:gen-class
    :methods [[loadImage [java.io.InputStream] java.awt.image.BufferedImage]
              [saveImage [java.awt.image.BufferedImage String] void]
              [generateThumbnail [java.awt.image.BufferedImage int] java.awt.image.BufferedImage]]
    :main false
    :name thumbnails.ImageProcessor))

(defn -loadImage [this image-stream]
  (img/load-image image-stream))

(defn -saveImage [this image path]
  (img/save-image image path))

(defn -generateThumbnail [this image size]
  (img/generate-thumbnail image size))</pre></div><p>This code is very similar to the Clojure code that we have already seen, except for the <code class="literal">gen-class</code> directive and the function names starting with a dash.</p><p>Let's review the <code class="literal">gem-class</code> in better detail:</p><div class="informalexample"><pre class="programlisting">(:gen-class
    :methods [[loadImage [java.io.InputStream] java.awt.image.BufferedImage]
              [saveImage [java.awt.image.BufferedImage String] void]
              [generateThumbnail [java.awt.image.BufferedImage int] java.awt.image.BufferedImage]]
    :main false
    :name thumbnails.ImageProcessor)</pre></div><p>When the <a class="indexterm" id="id108"/>Clojure compiler sees this, it generates the byte code of a class but it needs a little help from the keywords to know how to generate the class.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name key defines the name of the class, it is a symbol</li><li class="listitem" style="list-style-type: disc">The main key defines whether this class should have a main method or not</li><li class="listitem" style="list-style-type: disc">The method key defines all the methods and their signatures, it is a vector with three parts: <code class="literal">[methodName [parameterTypes] returnType]</code></li></ul></div><p>The methods are then implemented as functions starting with the (<code class="literal">-</code>) character, the prefix can be changed with the prefix key.</p><p>You also need to tell Clojure to compile this class in advance, in Leiningen it can be achieved with <code class="literal">:aot</code>, go to your <code class="literal">project.clj</code> file and add an <code class="literal">:aot</code> key with the namespace or namespaces to be compiled in a vector; if you want everything to be compiled in advance, you could use the special <code class="literal">:all</code> value.</p><p>In the end, you should have something similar to this:</p><div class="mediaobject"><img alt="Exposing your code to Java" src="graphics/B04289_03_03.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>If you want all of your code to be compiled in advance, you can use <code class="literal">:aot :all </code>in your <code class="literal">project.clj</code>.</p></div></div><p>Now, we can install our library to our Maven local repository. Go to the command line and run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ lein install</strong></span>
</pre></div><p>You'll get <a class="indexterm" id="id109"/>an output similar to the following screenshot:</p><div class="mediaobject"><img alt="Exposing your code to Java" src="graphics/B04289_03_04.jpg"/></div><p>Now, you are good to go; you should have a <code class="literal">thumbnails:thumbnails:0.1.0-SNAPSHOT</code> dependency in your Maven local repository.</p><div class="section" title="Testing from Groovy"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Testing from Groovy</h2></div></div></div><p>In order<a class="indexterm" id="id110"/> to see how this works with several JVM languages, we will use Groovy and Gradle to test. We can use Java and Maven just as easily. Remember that you can get the source from the code bundle so that you don't need to know everything that's happening here.</p><p>There are two files here; in the <code class="literal">build.gradle</code> file, we specify that we want to use our local Maven repository and we specify our dependency, as:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'groovy'

repositories {
  jcenter()
  mavenLocal()
}

dependencies {
  compile "thumbnails:thumbnails:0.1.0-SNAPSHOT"
  testCompile "org.spockframework:spock-core:0.7-groovy-2.0"
}</pre></div><p>Then we can write our test, as the following code:</p><div class="informalexample"><pre class="programlisting">package imaging.java

import thumbnails.ImageProcessor
import spock.lang.*

class ImageSpec extends Specification {
  def "Test we can use imaging tools"() {
    setup:
      def processor = new ImageProcessor()
      def imageStream = getClass().getResourceAsStream("/test.png")

    when:
      def image = processor.loadImage(imageStream)
      def thumbnail = processor.generateThumbnail(image, 100)

    then:
      thumbnail.getWidth() == 100
  }
}</pre></div><p>You can then run the tests:</p><div class="informalexample"><pre class="programlisting">gradle test</pre></div><p>As you can<a class="indexterm" id="id111"/> see, it is very easy to run your code from Java, Groovy, or even Scala. There are other ways to use Clojure with Java, particularly, if you want to implement an interface or generate a class dynamically.</p></div></div>
<div class="section" title="Proxy and reify"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Proxy and reify</h1></div></div></div><p>There are <a class="indexterm" id="id112"/>situations when you are interacting with Java libraries, where you must send an instance of a specific Java class to some method; writing a class isn't the best option, you should rather create an instance that conforms to a contract expected by some framework on the fly. We have two options to do this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proxy</strong></span>: It allows you to implement a Java interface or extend from some super class. In reality, it creates a new object that calls your Clojure functions when needed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Reify</strong></span>: Reify <a class="indexterm" id="id113"/>allows you to implement interfaces and Clojure protocols (we will see them later). It is not capable of extending classes. It is a better performant than the proxy and should be used whenever possible.</li></ul></div><p>Let's look at a minimal example:</p><div class="informalexample"><pre class="programlisting">(import '(javax.swing JFrame JLabel JTextField JButton)
        '(java.awt.event ActionListener)
        '(java.awt GridLayout))
(defn sample []
  (let [frame (JFrame. "Simple Java Integration")
        sample-button (JButton. "Hello")]
    (.addActionListener
     sample-button
     (reify ActionListener
            (actionPerformed
             [_ evt]
             (println "Hello world"))))
    (doto frame
      (.add sample-button)
      (.setSize 100 40)
      (.setVisible true))))
(sample)</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>
<code class="literal">doto</code> is a macro that allows us to call several methods on an instance; you can think of it as a way to call all of the methods separately. It works great with Java Beans!</p></div></div><p>Open up an REPL and write the code; it should show a window with a button that prints <code class="literal">Hello world</code> (in the terminal) when clicked:</p><div class="mediaobject"><img alt="Proxy and reify" src="graphics/B04289_03_05.jpg"/></div><p>If you are familiar <a class="indexterm" id="id114"/>with swing, then you know that the <code class="literal">addActionListener</code> of <code class="literal">JButton</code> needs a callback which is an instance of <code class="literal">ActionListener</code> and we are creating said instance with the <code class="literal">reify</code> function.</p><p>In Java code, you might normally do something similar to the following code:</p><div class="informalexample"><pre class="programlisting">button.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
    System.out.println("Hello world")'
  }
})</pre></div><p>We call this an anonymous class and it is essentially the same as a closure in functional languages. In the previous example, the code was replaced by a reify:</p><div class="informalexample"><pre class="programlisting">  (reify ActionListener
            (actionPerformed
             [_ evt]
             (println "Hello world")))</pre></div><p>The <code class="literal">reify</code> statement <a class="indexterm" id="id115"/>receives the interface that you are implementing and all the methods that you are implementing as you list. In this case, we just implement <code class="literal">actionPerformed</code> to receive the action event.</p><p>This is the structure:</p><div class="informalexample"><pre class="programlisting">(reify InterfaceOrProtocol
  (method [self parameter-list]
    method-body)
  (method2 [self parameter-list]
    method-body))</pre></div><p>This creates an instance of <code class="literal">ActionListener</code>, you can do the same with servlets, threads, collections, lists, or any other Java interface defined by anyone.</p><p>One particular thing that you need to remember here is that you need to always add <code class="literal">self</code> as the first parameter to your method implementations; it takes the place of the <code class="literal">this</code> keyword that works in Java.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, you have gained a lot of power from Clojure with a few new primitives.</p><p>As you can see, there are plenty of ways to interact with your current codebase; specifically, you can now:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use Java code from Clojure</li><li class="listitem" style="list-style-type: disc">Use Clojure code from Java</li><li class="listitem" style="list-style-type: disc">Reuse Java frameworks by creating objects that adhere to their contracts</li></ul></div><p>With all of our new tools in mind, we are ready to tackle more concepts and a little bit more complexity with collections and data structures.</p></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;Collections and Functional Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Collections and Functional Programming</h1></div></div></div><p>We are now comfortable with using Java code from our Clojure programs, and we also know how to expose our Clojure programs with a Java API. However, we need to take a deeper look at Clojure and its true nature, which is functional programming.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basics of functional programming</li><li class="listitem" style="list-style-type: disc">Persistent collections</li><li class="listitem" style="list-style-type: disc">Sequential and associative collections</li><li class="listitem" style="list-style-type: disc">The sequence abstraction</li><li class="listitem" style="list-style-type: disc">Collection types</li><li class="listitem" style="list-style-type: disc">Applying functional programming to collections</li></ul></div><div class="section" title="Basics of functional programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Basics of functional programming</h1></div></div></div><p>This is a<a class="indexterm" id="id116"/> topic that you can read about in lots of different places, and it seems that everyone has their own opinion of what functional programming is. There is however, some common ground that you will find in almost every definition, which relates to the benefits you gain from functional programming, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easier code reuse</li><li class="listitem" style="list-style-type: disc">Functions are easier to test</li><li class="listitem" style="list-style-type: disc">Functions are easier to reason about</li></ul></div><p>In order to get these benefits, you need to take into account the following things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You should think of functions as first class citizens</li><li class="listitem" style="list-style-type: disc">Functions should minimize side effects (they shouldn't change any state)</li><li class="listitem" style="list-style-type: disc">Functions should only depend on their parameters (this is called referential transparency)</li></ul></div><p>Lets take a <a class="indexterm" id="id117"/>look at two examples of functions (or methods) in Java to illustrate how, even in Java, you can get benefits from writing functions without side effects and context dependency.</p><div class="informalexample"><pre class="programlisting">public void payRent(BigDecimal amount) {
  User user = getCurrentUser();
  if(user.payAmount != amount) {
    System.out.println("Cannot pay");
  } else {
    user.money -= amount;
  }
}</pre></div><p>Imagine you had to test the preceding function; you might have a number of problems:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You need to know how to get the current user; you might need to mock a database, or session storage. Or in the worst case scenario, you might need a real session storage service.</li><li class="listitem">How can you know if something was paid for or not?</li></ol></div><p>Now, look at this other example:</p><div class="informalexample"><pre class="programlisting">public boolean payRent(User user, BigDecimal amount, ValidateStrategy strategy) {
  if(strategy.validatePayment(user, amount)) {
    user.money -= amount;
    return true;
  } else {
    return false;
  }
}</pre></div><p>The preceding code is easier to test; you can create a user instance any way you want and with the <code class="literal">ValidateStrategy</code> class (or interface) you could do whatever you need.</p><p>In the end, instead of a side-effect you get a return value stating if the action was possible or not. This way you don't need to mock and you can reuse it in different contexts.</p><p>Now that we have seen some common ground for functional programming, let's take a look at Clojure's value proposition for functional programming:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functions are first class citizens or values. The same as with integers or strings, you can create them in runtime, pass them around, and receive them in other functions.</li><li class="listitem" style="list-style-type: disc">The same way that functions are values, the data structures are also values; they can't be modified in the sense that they can be modified in Java but they are a fixed value, just as an integer is a fixed value.</li><li class="listitem" style="list-style-type: disc">Immutable data structures are very important, they allow for safe and simple multithreaded code.</li><li class="listitem" style="list-style-type: disc">Laziness (of data structures) allows deferring evaluation until needed, to execute just what you must.</li></ul></div></div></div>
<div class="section" title="Persistent collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Persistent collections</h1></div></div></div><p>One of the<a class="indexterm" id="id118"/> most important features in Clojure is that collections are persistent. That does not mean that they are persistent to disk, it means that you can have several historical versions of a collection with the guarantee that updating or looking for something in any of those versions is going to have the same effort (complexity). You get all this with very little extra memory.</p><p>How? It is actually pretty simple. Clojure shares a common structure between several different data structures. If you add a single element to a data structure, Clojure shares the common part between the two structures and keeps track of the differences.</p><p>Let's see what we mean with an example:</p><div class="informalexample"><pre class="programlisting">(def sample-coll [:one :two :three])
(def second-sample-coll (conj sample-coll :four))
(def third-sample-coll (replace {:one 1} sample-coll))

sample-coll ;; [:one :two :three]
second-sample-coll ;; [:one :two :three :four]
third-sample-coll ;; [1 :two :three :four]</pre></div><p>As you can see, when you <code class="literal">conj</code> a new item into a collection, or even when you replace some elements from it, you aren't changing the original collection, you are just generating a new version of it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>In Clojure, you can use <code class="literal">conj(conjoin)</code> as a verb. It means adding new elements into a collection in an efficient manner.</p></div></div><p>This new version doesn't modify the previous collections you had in any way.</p><p>This is a big difference from how common imperative languages work and at the first glance it might seem like a bad idea, but Clojure uses efficient algorithms that give us a couple of advantages, specifically:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Different versions of the same collection share common parts, allowing us to use little memory</li><li class="listitem" style="list-style-type: disc">When some part of the collection is not visible it gets garbage collected</li></ul></div><p>What you get out of this is similar memory usage to what you would have with a mutable collection. Remember that there is a cost in space and time but it is negligible for most use cases.</p><p>Why would you <a class="indexterm" id="id119"/>want to have an immutable data collection? The main advantage is that it is simple to reason about them; passing them around to functions does not change them and when you are writing concurrent code, there is no chance that some other thread has modified your collection and you don't need to worry about explicitly handling locks.</p></div>
<div class="section" title="Types of collections in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Types of collections in Clojure</h1></div></div></div><p>There are<a class="indexterm" id="id120"/> three types of collections in Clojure: counted, sequential, and associative. They <a class="indexterm" id="id121"/>are not mutually exclusive, meaning one collection might be any.</p><p>Let's look at each type:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Counted collection</strong></span>: A counted<a class="indexterm" id="id122"/> collection is a collection which knows its size in constant time. It doesn't need to traverse its elements to get a count.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sequential collection</strong></span>: A sequential <a class="indexterm" id="id123"/>collection can be traversed sequentially; it's the most common approach that you would use for a list. The easiest way to think about this is similar to Java's list, which you can traverse with a for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential collections.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Associative collections</strong></span>: Associative <a class="indexterm" id="id124"/>collections can be accessed by keys; maps are the natural choice here. We said that one collection can be of any type; Clojure's vectors can also be used as associative collections, and each element index can be used as a key. You can think of it as a map where the keys are 0, 1, 2, 3, and so on.</li></ul></div><p>Clojure has some functions that tell us if a given collection is of each type, sequential or associative. As you can guess, vectors return true for both. The following are those functions:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function name</p>
</th><th style="text-align: left" valign="bottom">
<p>List</p>
</th><th style="text-align: left" valign="bottom">
<p>Vector</p>
</th><th style="text-align: left" valign="bottom">
<p>Map</p>
</th><th style="text-align: left" valign="bottom">
<p>Lazy sequence</p>
</th><th style="text-align: left" valign="bottom">
<p>Set</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>counted?</p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>false </p>
</td><td style="text-align: left" valign="top">
<p>true</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>sequential?</p>
</td><td style="text-align: left" valign="top">
<p>true</p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>false</p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>false </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>associative?</p>
</td><td style="text-align: left" valign="top">
<p>false </p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>true </p>
</td><td style="text-align: left" valign="top">
<p>false </p>
</td><td style="text-align: left" valign="top">
<p>false </p>
</td></tr></tbody></table></div><div class="mediaobject"><img alt="Types of collections in Clojure" src="graphics/B04289_04_01.jpg"/></div><p>In the previous<a class="indexterm" id="id125"/> table and diagram, you can see that we take <span class="strong"><strong>Set</strong></span> into account and as you can see, it's neither sequential nor associative.</p><p>We should look at another property; whether a collection is counted or not. It means that a collection knows how many elements it has. Lists, vectors, maps, and sets are all counted; lazy sequences are not counted, since they are generated on the fly and they could even be infinite sequences.</p><p>We will learn more about all of these sequences in the later sections of this chapter.</p></div>
<div class="section" title="The sequence abstraction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>The sequence abstraction</h1></div></div></div><p>Clojure has <a class="indexterm" id="id126"/>some unique features that make it different from <a class="indexterm" id="id127"/>other Lisps; one of them is the sequence abstraction. You can think of it as an interface that collections comply with. Clojure has a standard API of functions that you can use with sequences. Here are some examples of those functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">distinct</code> function: This<a class="indexterm" id="id128"/> function returns a sequence that includes each element of the original sequence just once:<div class="informalexample"><pre class="programlisting">(def c [1 1 2 2 3 3 4 4 1 1])
(distinct c) ;; (1 2 3 4)</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">take</code> function: This <a class="indexterm" id="id129"/>function takes a number of elements from the original sequence:<div class="informalexample"><pre class="programlisting">(take 5 c) ;; (1 1 2 2 3)</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">map</code> function: This <a class="indexterm" id="id130"/>function applies a function to each element of a sequence and creates a new sequence with these elements:<div class="informalexample"><pre class="programlisting">(map #(+ % 1) c) ;; (2 2 3 3 4 4 5 5 2 2)</pre></div></li></ul></div><p>The interesting part here is that these functions receive and return sequences and you can compose them together. It can be seen in the following code:</p><div class="informalexample"><pre class="programlisting"> (-&gt;&gt; c
  (distinct)
  (take 5)
  (reverse)) ;; (4 3 2 1)

;; This is known as a threading macro, it applies distinct, then take 5 then reverse to the
;; collection c so this is the same as writing:
;; (reverse (take 5 (distinct c))) but much more readable</pre></div><p>These are just some functions that accept and return sequences, but there are a lot more that you can use out of the box. The only assumption is that your sequence argument can respond to three functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">first</code>: This function<a class="indexterm" id="id131"/> returns the first of a sequence</li><li class="listitem" style="list-style-type: disc"><code class="literal">rest</code>: This <a class="indexterm" id="id132"/>function returns another sequence, containing everything but the first element</li><li class="listitem" style="list-style-type: disc"><code class="literal">cons</code>: This <a class="indexterm" id="id133"/>function receives two parameters, an item and another <code class="literal">seq</code> and returns a new <code class="literal">seq</code> containing the item followed by all the items in the second parameter</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>One of the functions that you'll find yourself using more is the <code class="literal">seq</code> function, it can convert any collection to a seq, even Java native arrays and objects that implement the <code class="literal">java.util.Iterable</code> interface. One of its main uses is to test a collection for emptiness.</p></div></div></div>
<div class="section" title="Specific collection types in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Specific collection types in Clojure</h1></div></div></div><p>Now<a class="indexterm" id="id134"/> that you know about Clojure's general collection<a class="indexterm" id="id135"/> properties and the sequence abstraction, it is a good time to get to know about Clojure's specific collection implementations.</p><div class="section" title="Vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Vectors</h2></div></div></div><p>Vectors<a class="indexterm" id="id136"/> are Clojure's workhorse; together with map, it is the <a class="indexterm" id="id137"/>most used collection. Don't be afraid of them; they have nothing to do with Java's <code class="literal">java.util.Vector</code>. They are just a series of ordered values, such as a list or an array.</p><p>They have the<a class="indexterm" id="id138"/> following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are immutable</li><li class="listitem" style="list-style-type: disc">They can be accessed sequentially</li><li class="listitem" style="list-style-type: disc">They are associative (they are maps of their indices, meaning that their keys are 0, 1, 2, and so on)</li><li class="listitem" style="list-style-type: disc">They are counted, meaning they have a finite size</li><li class="listitem" style="list-style-type: disc">They have random access, so you can access any element with almost constant time (with the nth function)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">conj</code> function appends a given element to them</li></ul></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>The nth function allows us to get the nth element of any <code class="literal">seq</code>, but you shouldn't use it without care. It has no problem handling vectors and it returns in constant time, but it takes linear time when used with a list, since it has to traverse all the collections looking for the element you asked. Try to use it just with vectors.</p></div></div><p>They have a literal syntax; you can define a vector with square brackets, as shown:</p><div class="informalexample"><pre class="programlisting">[42 4 2 3 4 4 5 5]</pre></div><p>Besides the literal syntax, there's another function that you can use to build a vector. The <code class="literal">vec</code> function can build a vector out of any sequence passed to it:</p><div class="informalexample"><pre class="programlisting">(vec (range 4)) ;; [0 1 2 3]</pre></div><p>Another<a class="indexterm" id="id139"/> important benefit of vectors is that they are used for function arguments for declarations and for <code class="literal">let</code> bindings.</p><p>Take a look at the following example:</p><div class="informalexample"><pre class="programlisting">(def f [some-param &amp; some-other-params] …)

(let [one 1 two (f p p-2 p-3)] …)</pre></div><p>As you can see, the parameters in the function are defined as a vector, same as the <code class="literal">let</code> binding.</p><p>One of the main complaints about Lisps is that they use too many parentheses, Clojure's decision to use vectors instead in these structures is welcomed and makes the code much easier to read.</p><p>There are several ways to access a certain element of a vector:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Using the vector as a function</strong></span>: Vectors <a class="indexterm" id="id140"/>can be used as functions of their keys; we haven't discussed maps yet but you will see that this is because they are associative:<div class="informalexample"><pre class="programlisting">(def v [42 24 13 2 11 "a"])
(v 0) ;; 42
(v 99) ;; java.lang.IndexOutOfBoundsException</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The nth function</strong></span>: The <code class="literal">nth</code> function <a class="indexterm" id="id141"/>can receive an extra parameter for signaling when an index is not found and can be used, as shown:<div class="informalexample"><pre class="programlisting">(nth v 0) ;; 42
(nth v 99 :not-found) ;; :not-found
(nth v 99) ;; java.lang.IndexOutOfBoundsException</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The get function</strong></span>: The <code class="literal">get</code> function<a class="indexterm" id="id142"/> can receive an extra parameter for signaling when an index is not found, it is used as shown. An important thing to keep in mind is that unlike nth, <code class="literal">get</code> cannot be used in sequences:<div class="informalexample"><pre class="programlisting">(get v 0) ;; 42
(get v 99 :not-found) ;; :not-found
(get v 99) ;; nil</pre></div></li></ul></div><p>You should use vectors almost always; in particular, if you want to do any of the following there is no other way to go:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You need random access to a collection (either modifying or accessing it)</li><li class="listitem" style="list-style-type: disc">You need to add elements at the tail of the collection</li></ul></div></div><div class="section" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Lists</h2></div></div></div><p>Lists <a class="indexterm" id="id143"/>are the most important collection type in other Lisps. In Clojure, they are used to represent code, but their functionality is almost limited to that.</p><p>Lists in<a class="indexterm" id="id144"/> Clojure are single linked lists; as you can imagine, this means that they are not good for random access (you need to iterate the list until you get to the wanted index). That said, you can still use lists as sequences with every function of the API.</p><p>Let's list their <a class="indexterm" id="id145"/>properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are immutable</li><li class="listitem" style="list-style-type: disc">They can be accessed sequentially</li><li class="listitem" style="list-style-type: disc">They are not associative</li><li class="listitem" style="list-style-type: disc">They are counted, meaning they have a finite size</li><li class="listitem" style="list-style-type: disc">They shouldn't be accessed in random order. If you want the 99th element, then Clojure will have to visit all the first 98 elements to get the 99th.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">conj</code> function prepends a given element to it</li></ul></div><p>You can use destructuring with lists, as seen in the previous chapter. You shouldn't be afraid to use the first function (or even nth with a small index).</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Lists have their use cases and as you learn more you'll probably be comfortable using them in some places (such as macros), but as a rule of thumb, try to use vectors instead.</p></div></div></div><div class="section" title="Maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Maps</h2></div></div></div><p>Maps<a class="indexterm" id="id146"/> are probably the most important collection type across all languages. They are also very important in Clojure.</p><p>Maps<a class="indexterm" id="id147"/> are collections of key value pairs, which mean that you can access or store an element by a key. We have been calling this type of collection an associative collection. Keys can be of any type of value in Clojure, even functions, lists, sets, vectors, or other maps.</p><div class="section" title="Sorted maps and hash maps"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Sorted maps and hash maps</h3></div></div></div><p>There are two types of maps in Clojure, each one of them with its own advantages.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hash maps</strong></span>: They <a class="indexterm" id="id148"/>are the most <a class="indexterm" id="id149"/>used form of map in Clojure; the literal syntax of maps creates this type of maps. They have a nearly constant lookup time, which makes them extremely fast and usable in most scenarios. Their down-side is that you can't access them in an ordered fashion. You can create them, as shown:<div class="informalexample"><pre class="programlisting">{:one 1 :two 2}
(hash-map :one 1 :two 2)</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sorted maps</strong></span>: If <a class="indexterm" id="id150"/>you need to be <a class="indexterm" id="id151"/>able to access a map's key-value pairs in a certain order, then you have to use a sorted map. The downside of sorted maps is that the lookup time is <span class="emphasis"><em>not</em></span> constant, which means that they are a little slower to access by key. However, when you need to traverse a map in the order of the keys, then this is the only way to go. A strong constraint here is that the keys must be comparable between them. Sorted maps can be created, as shown:<div class="informalexample"><pre class="programlisting">(sorted-map :sample 5 :map :6) ;; {:sample 5, :map 6}
(sorted-map-by &gt; 1 :one 5 :five 3 :three) ;; {5 :five, 3 :three, 1 :one}</pre></div></li></ul></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>Comparable objects are the ones that implement the <code class="literal">compareTo</code> interface.</p></div></div></div><div class="section" title="Common properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Common properties</h3></div></div></div><p>Associative objects, including<a class="indexterm" id="id152"/> maps have the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are functions of their keys:<div class="informalexample"><pre class="programlisting">(def m #{:one 1 :two 2 :three 3})
(m :one) ;; 1
(m 1) ;; nil</pre></div></li><li class="listitem" style="list-style-type: disc">They can be used with associative destructuring:<div class="informalexample"><pre class="programlisting">(let [{:keys [a b c d]} #{:a 5}]
  [a b]) ;
; [:a nil]</pre></div></li><li class="listitem" style="list-style-type: disc">They can be accessed with the <code class="literal">get</code> function:<div class="informalexample"><pre class="programlisting">(get m :one) ;; 1
(get m 1) ;; nil
(get m 1 :not-found) ;; :not-found</pre></div></li></ul></div><p>You can convert a map to a <code class="literal">seq</code> with the <code class="literal">seq</code> function; you will get a sequence where each element is a vector representing a key-value pair in the map:</p><div class="informalexample"><pre class="programlisting">(seq {:one 1 42 :forty-two :6 6}) ;; ([:one 1] [:6 6] [42 :forty-two])
(doseq [[k v] (seq {:one 1 42 :forty-two :6 6})]
  (println k v))
;; :one 1
;; :6 6
;; 42 :forty-two</pre></div><p>
<code class="literal">Doseq</code> is similar to Java's for-each loop. It executes the body for each element in a sequence.</p><p>It works as<a class="indexterm" id="id153"/> shown: <code class="literal">(doseq [x sequence] ;;</code>. This works the same way as the let statement, you can use destructuring if needed:</p><div class="informalexample"><pre class="programlisting">    (body-that-uses x))</pre></div></div></div><div class="section" title="Sets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Sets</h2></div></div></div><p>Clojure sets <a class="indexterm" id="id154"/>are a collection of unique elements. You<a class="indexterm" id="id155"/> can think of them as mathematical sets and as such, Clojure has operations, such as union intersection and difference.</p><p>Let's look at the properties of sets:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are immutable</li><li class="listitem" style="list-style-type: disc">They are associative (their keys are their elements)</li><li class="listitem" style="list-style-type: disc">They are counted, meaning they have a finite size</li><li class="listitem" style="list-style-type: disc">Their elements are unique (contained at most once)</li></ul></div><div class="section" title="Sorted sets and hash sets"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Sorted sets and hash sets</h3></div></div></div><p>There are two kinds of sets: hash-sets and sorted-sets.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hash-set</strong></span>: Besides <a class="indexterm" id="id156"/>the properties that we already saw, hash-sets are unordered. They are implemented using a hash map as a backing implementation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sorted-set</strong></span>: Besides <a class="indexterm" id="id157"/>the properties that we already saw, sorted-sets are sorted. They can be used as a parameter to all the functions that expect a sorted <code class="literal">seq</code>. They can be accessed sequentially in sorted order:<div class="informalexample"><pre class="programlisting">(doseq [x (-&gt;&gt; (sorted-set :b :c :d)
                        (map name))]
    (println x))
;; b
;; c
;; d</pre></div></li></ul></div><p>You can also reverse them without problems, filter them, or map them similarly to a vector or list.</p></div><div class="section" title="Common properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Common properties</h3></div></div></div><p>Sets<a class="indexterm" id="id158"/> are associative, which gives them some properties of maps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are functions of their elements:<div class="informalexample"><pre class="programlisting">(#{:a :b :c :d} :a);; :a
(#{:a :b :c :d} :e);; nil</pre></div></li><li class="listitem" style="list-style-type: disc">They can be used with map destructuring:<div class="informalexample"><pre class="programlisting">(let [{:keys [b]} #{:b}] b);; :b
(let [{:keys [c]} #{:b}] b);; nil
(let [{:keys [c]} (sorted-set :b)] c);; nil
(let [{:keys [b]} (sorted-set :b)] b);; :b</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">get</code> function can be used to access their elements:<div class="informalexample"><pre class="programlisting">(get #{:a :b :c :d} :e :not-found) ;; :not-found
(get #{:a :b :c :d} :a) ;; :a
(get #{:a :b :c :d} :e) ;; nil</pre></div></li></ul></div></div><div class="section" title="Union, difference, and intersection"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Union, difference, and intersection</h3></div></div></div><p>If you <a class="indexterm" id="id159"/>remember<a class="indexterm" id="id160"/> mathematical sets, you'll know that the three main operations you can execute on them are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Union</strong></span> (<code class="literal">union a b</code>): The union includes all of the elements both in <code class="literal">a</code> and <code class="literal">b</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Difference</strong></span> (<code class="literal">difference a b</code>): The difference is all the elements that are in <code class="literal">a</code> except for the elements that are also in <code class="literal">b</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Intersection</strong></span> (<code class="literal">intersection a b</code>): It<a class="indexterm" id="id161"/> includes only the elements that are both in <code class="literal">a</code> and <code class="literal">b</code></li></ul></div><p>Here are some examples:</p><div class="informalexample"><pre class="programlisting">(def a #{:a :b :c :d :e})
(def b #{:a :d :h :i :j :k})

(require '[clojure.set :as s])

(s/union a b) ;; #{:e :k :c :j :h :b :d :i :a}
(s/difference a b) ;; #{:e :c :b}
(s/intersection a b) ;; #{:d :a}</pre></div></div></div><div class="section" title="Applying functional programming to collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Applying functional programming to collections</h2></div></div></div><p>Now that we <a class="indexterm" id="id162"/>have a better understanding of how collections work, we have a better foundation to understand functional programming and how to make the most out of it.</p><p>This<a class="indexterm" id="id163"/> requires a different way of thinking about how to solve problems and you should keep your mind open.</p><p>Something that you might have found really strange about all of the collections is this feature: <span class="emphasis"><em>They are immutable</em></span>.</p><p>This is indeed something quite strange; if you are used to Java, how can you possibly write programs without adding or removing elements from a list or set?</p><p>How is that even possible? In Java, we are used to writing <code class="literal">for</code> and <code class="literal">while</code> loops. We are used to mutating variables every step of the way.</p><p>How can we cope with immutable data structures? Let's find out in the subsequent sections.</p><div class="section" title="The imperative programming model"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec07"/>The imperative programming model</h3></div></div></div><p>The <a class="indexterm" id="id164"/>software industry has been using a single software paradigm for a long time; this paradigm is an imperative programming model.</p><p>In the imperative paradigm, you have to tell the computer what to do at every single step. You are responsible for how the memory works, for whether it is running in a single core or multi core and, if you want to use multi core, you need to make sure that you change the program state correctly and avoid concurrency problems.</p><p>Let's see how you would calculate the factorial in an imperative style:</p><div class="informalexample"><pre class="programlisting">int factorial(int n) {
    int result = 1;
    for (int i = 1; i &lt;= n; i++) {
        result *= i;
    }
    return result;
}</pre></div><p>You are creating a variable result and a variable <code class="literal">i</code>. You change the variable <code class="literal">i</code> each time by assigning it the value <code class="literal">i + 1</code>. You can change the result by multiplying by <code class="literal">i</code>. The computer just executes your orders, comparing, adding, and multiplying. This is what we call the imperative programming model, because you need to tell the computer the exact commands it needs to execute.</p><p>This has worked fine in the past for various reasons, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The tight constraints of memory size forced programmers to make use of the memory as efficient as possible</li><li class="listitem" style="list-style-type: disc">It was easier to think about a single thread of execution and how the computer executes it step-by-step</li></ul></div><p>Of course, there <a class="indexterm" id="id165"/>were some drawbacks. A code can get complicated easily and the world has changed; the constraints that existed many years ago are gone. In addition, most of today's computers have more than one CPU. Multi-threading with shared mutable states is burdensome.</p><p>This makes thinking about this complicated. We get in trouble even in single threaded programs; just think, what would be the outcome of the following code?</p><div class="informalexample"><pre class="programlisting">List l = new ArrayList();
doSomething(l);
System.out.println(l.size());</pre></div><p>Is it <code class="literal">0</code>? You can't possibly know because the <code class="literal">doSomething</code> method gets the list by reference and it can add or remove things without you knowing.</p><p>Now, imagine that you have a multithreaded program and a single <code class="literal">List</code> that can be modified by any of the threads. In the Java world, you have to know about <code class="literal">java.util.concurrent.CopyOnWriteArrayList</code> and you need to know about its implementation details to know when it's a good idea to use it and when not to use it.</p><p>Even with these structures, it is difficult to think about multithreaded code. You still need to think about semaphores, locks, synchronizers, and so on.</p><p>The imperative world might be easy for the easy case, but it is not simple. The whole industry has realized this and there are many new languages and technologies that take ideas from other places. Java 8 has the streaming API and it includes lambda blocks, which are essentially functions. All these ideas are taken from the functional world.</p></div><div class="section" title="The functional paradigm"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec08"/>The functional paradigm</h3></div></div></div><p>There <a class="indexterm" id="id166"/>are other ways of thinking about how to solve a problem; in particular, the functional paradigm has become important lately. It is nothing new; Lisp has supported this kind of programming since it was conceived in 1958. It has probably not been strong until recently, as it requires a more abstract way of thinking.</p><p>For you to get a better idea, let's see a couple of examples of how functional programming looks similar to the following code:</p><div class="informalexample"><pre class="programlisting">(map str [1 2 3 4 5 6]) ;; ("1" "2" "3" "4" "5" "6")

(defn factorial [n]
  (reduce * (range 1 (inc n))))

(factorial 5) ;; 120</pre></div><p>As you <a class="indexterm" id="id167"/>can see, it looks quite different; in the first case, we are passing the <code class="literal">str</code> function to another function called map.</p><p>In the second case, we are passing the <code class="literal">*</code> function to another function called reduce. In both cases, we are using functions as you <a class="indexterm" id="id168"/>would pass a list or a number, they are <span class="strong"><strong>first level citizens</strong></span>.</p><p>One important difference in functional programming is that you don't need to tell the machine how to do things. In the first case, the map traverses the vector and applies the <code class="literal">str</code> function to each element, converting it to a <code class="literal">seq</code> of strings. You don't have to increment the index, you just need to tell the map what function you want to be applied to each element.</p><p>In the factorial case, there is a reduce function that receives the <code class="literal">*</code> and a <code class="literal">seq</code> from <code class="literal">1</code> to <code class="literal">n</code>.</p><p>It just works, you don't need to tell it how to do anything, just what you want done.</p><p>Both <code class="literal">map</code> and <code class="literal">reduce</code> are <a class="indexterm" id="id169"/>
<span class="strong"><strong>higher order functions</strong></span> because they accept functions such as parameters; they are also higher level abstractions.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Higher order functions are functions that either accept a function as an argument, return a function as result, or both.</p></div></div><p>You need to think on another level of abstraction and you don't care how things are really done, just that it gets the work done.</p><p>This comes with some benefit, if the implementation of a map someday changes to become multithreaded, you would just need to update the versions and you would be ready to go!</p></div><div class="section" title="Functional programming and immutability"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Functional programming and immutability</h3></div></div></div><p>You may <a class="indexterm" id="id170"/>have also noticed that functional programming makes working with immutable structures necessary, because you can't mutate some or the other state in every step; you can just describe how you want to create a new collection based on some other collection and then get it. Clojure's efficient collections make it possible to share pieces of collections to keep memory usage at a minimum.</p><p>There are some other benefits to<a class="indexterm" id="id171"/> immutability:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can share your data structures with anyone you want because you are certain that nobody can change your copy.</li><li class="listitem" style="list-style-type: disc">Debugging is simpler because you can test the program with some immutable value instead of some mutating state. When you get a value, you can find out which function returned the value that you got; there are not multiple places where a collection was mutated for you to check.</li><li class="listitem" style="list-style-type: disc">Concurrent programming is simpler; again being certain that nobody can change your copy, even in other concurrently running threads, makes reasoning about your program simpler.</li></ul></div></div><div class="section" title="Laziness"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Laziness</h3></div></div></div><p>Clojure also<a class="indexterm" id="id172"/> supports lazy evaluation of transformations of sequences. Let's take a look at the <code class="literal">range</code> function:</p><div class="informalexample"><pre class="programlisting">(def r (range))</pre></div><p>When running this function without parameters, you are creating an infinite sequence starting from <code class="literal">0</code>.</p><p>It is an infinite sequence; so why does the Clojure REPL return automatically?</p><p>Clojure doesn't compute a collection value until needed, so in order to get a value you would have to do something, such as this:</p><div class="informalexample"><pre class="programlisting">(take 1 r);; (0)
(take 5 r);; (0 1 2 3 4)</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>If you try to print an infinite sequence at the REPL, it will freeze.</p></div></div><p>Here, Clojure is resolving first one element and then five of the collection <code class="literal">r</code> because it needs to print them in the REPL.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Lazy evaluation just works for collections and for sequence processing. Other operations (such as additions, method calls, and so on), are executed eagerly.</p></div></div><p>The interesting part is that you can define a new lazy collection by applying functions like filter and map to a certain collection.</p><p>For instance, let's get a new collection that contains all odd numbers:</p><div class="informalexample"><pre class="programlisting">(def odd-numbers (filter odd? r))
(take 1 odd-numbers)  ;; (1)
(take 2 odd-numbers)  ;; (1 3)
(take 3 odd-numbers)  ;; (1 3 5)</pre></div><p>Now, <code class="literal">odd-numbers</code> is an <a class="indexterm" id="id173"/>infinite sequence of odd numbers and we have just asked for three of them. Whenever a number is already computed, it is not computed again. Let's change our collection a little bit in order to understand how this works:</p><div class="informalexample"><pre class="programlisting">(defn logging-odd? [number]
    (println number) ;; This is terrible, it is a side effect and a source for problems
                     ;; Clojure encourages you to avoid side effects, but it is pragmatic
                     ;; and relies on you knowing what you are doing
    (odd? number))

(def odd-numbers (filter logging-odd? r))

(take 1 odd-numbers)
;; 0
;; 1
;; 2
;; 3
;; 4
;; 5
;; 6
;; 7
;; 8
;; 9
;; 10
;; 11
;; 12
;; 13
;; 14
;; 15
;; 16
;; 17
;; 18
;; 19
;; 20
;; 21
;; 22
;; 23
;; 24
;; 25
;; 26
;; 27
;; 28
;; 29
;; 30
;; 31
;; =&gt; (1)

(take 1 odd-numbers)
;; =&gt; (1)

(take 2 odd-numbers)
;; =&gt; (1 3)

(take 3 odd-numbers)
;; =&gt; (1 3 5)

(take 4 odd-numbers)
;; =&gt; (1 3 5 7)

(take 10 odd-numbers)
;; =&gt; (1 3 5 7 9 11 13 15 17 19)</pre></div><p>As you can see, some<a class="indexterm" id="id174"/> numbers get calculated first; you shouldn't expect or rely on a particular number of elements to be precomputed at a certain time.</p><p>Also, keep in mind that the computation isn't executed again when we ask for the same number of elements, since it has been already cached.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>Collections and functional programming in Clojure are extremely powerful tools that allow us to use a completely different paradigm of programming.</p><p>Here's what we have learned so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The mechanics of immutable collections and what each collection type in Clojure is best for</li><li class="listitem" style="list-style-type: disc">How sequence abstraction and how a lot of Clojure functions are available to work on collections, using this abstraction</li><li class="listitem" style="list-style-type: disc">How functional programming enables us to write simpler programs that work better in parallel environments and help us save resources using laziness</li></ul></div><p>In the subsequent chapters, we will learn about other new Clojure features that give us a new and much more powerful way to implement polymorphism than what Java offers.</p></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;Multimethods and Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Multimethods and Protocols</h1></div></div></div><p>We now have a better understanding of how Clojure works; we understand how to perform simple operations with immutable data structures but we are missing some features that could make our lives much easier.</p><p>If you have been a Java programmer for a while, you are probably thinking about polymorphism and its particular flavor in Java.</p><p>Polymorphism is one of the concepts that enable us to reuse a code. It gives us the ability to interact with different objects with the same API.</p><p>Clojure has a powerful polymorphism paradigm that allows us to write simple code, create code that interacts with types that don't exist yet, and extend code in ways it wasn't devised for when a programmer wrote it.</p><p>To help us with polymorphism in Clojure, we have two important concepts that we will cover in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Multimethods</li><li class="listitem" style="list-style-type: disc">Protocols</li></ul></div><p>Each of them has its own use cases and things it is best at; we will look into them in the next section.</p><p>We will learn each of these different concepts by reviewing what we already know from Java and then we will learn similar concepts from Clojure that give us much more power.</p><div class="section" title="Polymorphism in Java"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Polymorphism in Java</h1></div></div></div><p>Java uses <a class="indexterm" id="id175"/>polymorphism heavily, its collection API is based on it. Probably the best examples of polymorphism in Java are the following classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.List</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.Map</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.Set</code></li></ul></div><p>We know that depending on our use case we should use a particular implementation of these data structures.</p><p>If we prefer to use an ordered Set, we might use a TreeSet.</p><p>If we need a Map in a concurrent environment, we will use a <code class="literal">java.util.concurrent.ConcurrentHashMap</code>.</p><p>The <a class="indexterm" id="id176"/>beautiful thing is that you can write your code using the <code class="literal">java.util.Map</code> and <code class="literal">java.util.Set</code> interfaces and if you need to change to another type of Set or Map, because the conditions have changed or someone has created a better version of the collection for you, you don't need to change any code!</p><p>Lets look at a very simple example of polymorphism in Java.</p><p>Imagine that you have a Shapes hierarchy; it might look similar to the following code:</p><div class="informalexample"><pre class="programlisting">package shapes;

public interface Shape {
  public double getArea();
}

public class Square implements Shape {
  private double side;
  public Square(double side) {
this.side = side;
  }

  public double getArea() {
    return side * side;
  }

}

public class Circle implements Shape {
  private double radius;
  public Circle(double radius) {
this.radius = radius;
  }

  public double getArea() {
    return Math.PI * radius * radius;
  }

}</pre></div><p>You surely are aware of the power of this concept, you can now calculate the summation of all the areas of a collection of figures, such as this:</p><div class="mediaobject"><img alt="Polymorphism in Java" src="graphics/B04289_05_01.jpg"/></div><p>The <code class="literal">totalArea</code> method <a class="indexterm" id="id177"/>doesn't care about the specific types of shapes that you pass to it and you can add new types of shapes, such as rectangles or trapezoids. Your same code will now work with new data types.</p><p>Now, with the same Java code base, imagine that you wanted to add a new function to your shape interface, something simple, such as a <code class="literal">getPerimeter</code> method.</p><p>This seems quite simple; you will have to modify each class that implements the Shape interface. I'm sure you've faced this problem a lot of times when you don't have access to the base source. The solution is to write a wrapper around your Shape objects but this introduces more classes and incidental complexity.</p><p>Clojure has its own idea of polymorphism, it is much simpler but also very powerful; you can in fact solve the perimeter problem with it in a very simple way.</p><p>One way to solve this is with multimethods; lets have a look at how they work.</p></div></div>
<div class="section" title="Multimethods in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Multimethods in Clojure</h1></div></div></div><p>Multimethods <a class="indexterm" id="id178"/>are similar to interfaces, they allow you to write a common contract and then a family of functions can fulfill that interface with a specific implementation.</p><p>They are extremely flexible, as you will see they grant you a very fine control over what function is going to get invoked for a specific data object.</p><p>Multimethods consist of three parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A function (or method) declaration</li><li class="listitem" style="list-style-type: disc">A dispatch function</li><li class="listitem" style="list-style-type: disc">Each possible implementation of the function</li></ul></div><p>One of the most interesting features of multimethods is that you can implement new functions for already existing types without having to write wrappers around your currently existing object.</p><p>The multimethod declaration works the same way as the interface; you define a common contract for the polymorphic function, as shown:</p><div class="informalexample"><pre class="programlisting">(defmulti name docstring? attr-map? dispatch-fn&amp; options)</pre></div><p>The <code class="literal">defmulti</code> macro defines the contract for your multimethod, it consists of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The multimethod's name</li><li class="listitem" style="list-style-type: disc">An optional <code class="literal">doctstring</code> (this is the documentation string)</li><li class="listitem" style="list-style-type: disc">The attribute map</li><li class="listitem" style="list-style-type: disc">The <code class="literal">dispatch-fn</code> function</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The <code class="literal">dispatch</code> function gets called for every piece of content; it generates a dispatch key that is later checked against its function implementation. When the dispatch key and the key in the function implementation match, the function is called.</p></div></div><p>The <code class="literal">dispatch</code> function receives the same parameters that the function you are calling receives and returns a dispatch key that is used to determine the function that should dispatch the request.</p><p>Each implementation function must define a dispatch key, if it matches with the <code class="literal">dispatch</code> function's result, then this function is executed.</p><p>An example should clarify:</p><div class="informalexample"><pre class="programlisting">(defmultiarea :shape)

(defmethodarea :square [{:keys [side]}] (* side side))

(area {:shape :square :side 5})
;;=&gt; 25</pre></div><p>Here, we are defining a multimethod called <code class="literal">area</code>; the <code class="literal">defmulti</code> statement has the following structure:</p><div class="informalexample"><pre class="programlisting">(defmultifunction-name dispatch-function)</pre></div><p>In this case, the<a class="indexterm" id="id179"/> multimethod is called <code class="literal">area</code> and the <code class="literal">dispatch</code> function is the <code class="literal">:shape</code> keyword.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Remember, keywords can be used as functions that look up themselves in maps. So, for example, the result of (<code class="literal">:shape {:shape :square}</code>) is <code class="literal">:square</code>.</p></div></div><p>Afterwards, we define a method, as shown:</p><div class="informalexample"><pre class="programlisting">(defmethodfunction-name dispatch-key [params] function-body)</pre></div><p>Note that the <code class="literal">dispatch-key</code> is always the result of invoking the <code class="literal">dispatch-function</code> with <code class="literal">params</code> as parameters.</p><p>Finally, let's look at the invocation, <code class="literal">(area {:shape :square :side 5})</code> which is calling a multimethod. The first thing that happens is that we call the dispatch function <code class="literal">:shape</code>, as shown:</p><div class="informalexample"><pre class="programlisting">(:shape {:shape :square :side 5})
;; :square</pre></div><p>The <code class="literal">:square</code> function is now the dispatch key, we need to look for the method that has that dispatch key; in this case, the only method that we defined works. So, the function is executed and we get the result of <code class="literal">25</code>.</p><p>It is pretty simple to add the area and perimeter for both square and circle, lets check the implementation:</p><div class="informalexample"><pre class="programlisting">(defmethodarea :circle [{:keys [radius]}]
(* Math/PI radius radius))

(defmultiperimeter :shape)

(defmethodperimeter :square [{:keys [side]}] (* side 4))

(defmethodperimeter :circle [{:keys [radius]}] (* 2 Math/PI radius))</pre></div><p>Now, we have defined how to calculate the perimeter and area of circles and squares with very little effort and without having to define a very strict object hierarchy. However, we are just starting to uncover the power of multimethods.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Keywords can be namespaced, it allows you to keep your code better organized. There are two ways to define a namespaced keyword, such as <code class="literal">:namespace/keyword</code> and <code class="literal">::keyword</code>. When using the <code class="literal">::</code> notation, the used namespace is the current namespace. So if you write <code class="literal">::test</code> in the REPL, you will be defining <code class="literal">:user/test</code>.</p></div></div><p>Let's try another<a class="indexterm" id="id180"/> example, copy the following code into your REPL:</p><div class="mediaobject"><img alt="Multimethods in Clojure" src="graphics/B04289_05_02.jpg"/></div><p>As you can see, it just works as you might expect it to. However, let's see how you can create a keyword hierarchy to be a little bit more flexible than this.</p><div class="section" title="Keyword hierarchies"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Keyword hierarchies</h2></div></div></div><p>You can <a class="indexterm" id="id181"/>declare that a keyword derives from another keyword and then respond to other dispatch keys, for that you can use the <code class="literal">derive</code> function:</p><div class="informalexample"><pre class="programlisting">(derive ::hominid ::primate)</pre></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>When defining a keyword hierarchy, you have to use namespaced keywords.</p></div></div><p>Here, you are declaring that the <code class="literal">::hominid</code> key is derived from the <code class="literal">::animal</code> key and you can now use <code class="literal">::hominid</code> as <code class="literal">::animal</code>; let's see that now:</p><div class="informalexample"><pre class="programlisting">(walk {:type ::hominid})
;; Primate Walk</pre></div><p>We do have some problems when defining hierarchies, for instance what will happen if the same keyword were to be derived from two conflicting keywords? Let's give it a try:</p><div class="informalexample"><pre class="programlisting">(derive ::hominid ::animal)

(walk {:type ::hominid})
;;java.lang.IllegalArgumentException: Multiple methods in multimethod 'walk' match dispatch value: :boot.user/hominid -&gt; :boot.user/animal and :boot.user/primate, and neither is preferred</pre></div><p>We get <a class="indexterm" id="id182"/>an error that says, there are two methods that match the dispatch value. Since our hominid derives both from animal and primate, it doesn't know which to resolve.</p><p>We can work this out explicitly with:</p><div class="informalexample"><pre class="programlisting">(prefer-method walk ::hominid ::primate)
(walk {:type ::hominid})
; Primate walk</pre></div><p>Now, everything works correctly. We know that we prefer to resolve to a primate when calling the walk multimethod with the hominid key.</p><p>You can also define a more specific method, just for the <code class="literal">hominid</code> key:</p><div class="informalexample"><pre class="programlisting">(defmethodwalk ::hominid [_] "Walk in two legs")

(walk {:type ::hominid})
;; Walk in two legs</pre></div><p>The derivation hierarchy can get a little complex and we might need some functions to introspect relationships. Clojure has the following functions to work with type hierarchies.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isa?</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">parents</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">descendants</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">underive</code></li></ul></div><div class="section" title="isa?"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec11"/>isa?</h3></div></div></div><p>The <code class="literal">isa</code> function <a class="indexterm" id="id183"/>checks if a type derives from some other type, it works with Java classes as well as Clojure keywords.</p><p>It is simple to explain with examples:</p><div class="informalexample"><pre class="programlisting">(isa? java.util.ArrayListjava.util.List)
;;=&gt; true

(isa? ::hominid ::animal)
;;=&gt; true

(isa? ::animal ::primate)
;;=&gt; false</pre></div></div><div class="section" title="parents"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec12"/>parents</h3></div></div></div><p>The <code class="literal">parent</code> function<a class="indexterm" id="id184"/> returns a set of a type's parents, they might be Java or Clojure keywords:</p><div class="informalexample"><pre class="programlisting">(parents java.util.ArrayList)
;;=&gt; #{java.io.Serializablejava.util.Listjava.lang.Cloneablejava.util.RandomAccessjava.util.AbstractList}

(parents ::hominid)
#{:user/primate :user/animal}</pre></div></div><div class="section" title="descendants"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec13"/>descendants</h3></div></div></div><p>The <a class="indexterm" id="id185"/>
<code class="literal">descendants</code> function, as you can imagine, returns a set of descendants of the <code class="literal">passd</code> keyword; it is important to keep in mind that in this case only Clojure keywords are allowed:</p><div class="informalexample"><pre class="programlisting">(descendants ::animal)
;;=&gt; #{:boot.user/hominid}</pre></div></div><div class="section" title="underive"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>underive</h3></div></div></div><p>The <a class="indexterm" id="id186"/>
<code class="literal">underive</code> function breaks the relation between two types, as you can imagine it only works with the Clojure keywords:</p><div class="informalexample"><pre class="programlisting">(underive ::hominid ::animal)
;;=&gt; (isa? ::hominid ::animal)</pre></div><p>This function will normally be used at development time and they allow you to play around with your type hierarchy in a very simple and dynamic way.</p></div></div><div class="section" title="A la carte dispatch functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>A la carte dispatch functions</h2></div></div></div><p>Until now, we<a class="indexterm" id="id187"/> have used a keyword as a dispatch function but you can use any function you like with as many arguments as you want. Let's take <a class="indexterm" id="id188"/>a look at some examples:</p><div class="informalexample"><pre class="programlisting">(defn dispatch-func [arg1 arg2]
  [arg2 arg1])</pre></div><p>This is a simple function, but it shows two important facts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">dispatch</code> function can receive more than one argument</li><li class="listitem" style="list-style-type: disc">The <code class="literal">dispatch</code> key can be anything, not just a keyword</li></ul></div><p>Lets have a look at how we can use this <code class="literal">dispatch</code> function:</p><div class="informalexample"><pre class="programlisting">(defmulti sample-multimethod dispatch-func)
;; Here we are saying that we want to use dispatch-func to calculate the dispatch-key

(defmethod sample-multimethod [:second :first] [first second] [:normal-params first second])
(defmethod sample-multimethod [:first :second] [first second] [:switch-params second first])

(sample-multimethod :first :second)
;;=&gt; [:normal-params :first: second]

(sample-multimethod :second :first)
;; =&gt;[:switch-params :first: second]</pre></div><p>We are getting to know the <code class="literal">dispatch</code> function a little bit better; now that you know that you can implement any <code class="literal">dispatch</code> function, you have a very fine grained control over what function gets called and when.</p><p>Lets look at one more example, so we can finally grasp the complete idea:</p><div class="mediaobject"><img alt="A la carte dispatch functions" src="graphics/B04289_05_03.jpg"/></div><p>Now the<a class="indexterm" id="id189"/> true power of multimethods becomes apparent. You <a class="indexterm" id="id190"/>now have an adhoc way of defining polymorphic functions which has the possibility to define type hierarchies and even execute your own logic to determine the function that is going to be called finally.</p></div></div>
<div class="section" title="Protocols in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Protocols in Clojure</h1></div></div></div><p>Multimethods are <a class="indexterm" id="id191"/>just one of the options for polymorphism you have in Clojure, there are other ways to implement polymorphic functions.</p><p>Protocols are a little easier to understand and they might feel more similar to Java interfaces.</p><p>Lets try to define our shape program using protocols:</p><div class="informalexample"><pre class="programlisting">(defprotocol Shape
  "This is a protocol for shapes"
  (perimeter [this] "Calculates the perimeter of this shape")
  (area [this] "Calculates the area of this shape"))</pre></div><p>Here, we have defined a protocol and it is called shaped and everything that implements this protocol must implement the following two functions: <code class="literal">perimeter</code> and <code class="literal">area</code>.</p><p>There are <a class="indexterm" id="id192"/>a number of ways to implement a protocol; one interesting feature is that you can even extend Java classes to implement a protocol without an access to the Java source and without having to recompile anything.</p><p>Let's start by creating a record that implements the type.</p><div class="section" title="Records in Clojure"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Records in Clojure</h2></div></div></div><p>Records work<a class="indexterm" id="id193"/> exactly like maps, but they are much faster if you stick to the predefined keys. Defining a record is similar to defining a class, Clojure knows beforehand about the fields that the record will have, so it can generate byte code on the fly and the code that uses the records is much faster.</p><p>Lets define a <code class="literal">Square</code> record, as shown:</p><div class="informalexample"><pre class="programlisting">(defrecord Square [side]
  Shape
  (perimeter [{:keys [side]}] (* 4 side))
  (area [{:keys [side]}] (* side side)))</pre></div><p>Here, we are defining the <code class="literal">Square</code> record and it has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It has only one field, <code class="literal">size</code>; this is going to work as a map with only the side key</li><li class="listitem" style="list-style-type: disc">It implements the <code class="literal">Shape</code> protocol</li></ul></div><p>Lets have a look at how a record is instantiated and how we can use it:</p><div class="informalexample"><pre class="programlisting">(Square. 5)
;;=&gt; #user/Square{:size 5}

(def square (Square. 5))

(let [{side :side} square] side)
;;=&gt; 5

(let [{:keys [side]} square] side)
;;=&gt; 5

(doseq [[k v] (Square. 5)] (println k v))
;; :side 5</pre></div><p>As you can see it works exactly like a map, you can even associate things to it:</p><div class="informalexample"><pre class="programlisting">(assoc (Square. 5) :hello :world)</pre></div><p>The downside of doing this is that we no longer have the performance guarantees that we had when defining just the record fields; nonetheless, it is a great way of giving some structure to our code.</p><p>We still have<a class="indexterm" id="id194"/> to check how we can use our perimeter and area functions, it is pretty simple. Let's have a look:</p><div class="informalexample"><pre class="programlisting">(perimeter square)
;;=&gt; 20

(area square)
;;=&gt; 25</pre></div><p>Just to continue with the example, let's define the <code class="literal">Circle</code> record:</p><div class="informalexample"><pre class="programlisting">(defrecord Circle [radius]
  Shape
  (perimeter [{:keys [radius]}] (* Math/PI 2 radius))
  (area [{:keys [radius]}] (* Math/PI radius radius)))

(def circle (Circle. 5))

(perimeter circle)
;;=&gt; 31.41592653589793

(area circle)
;;=&gt; 78.53981633974483</pre></div><p>One of the promises was that we will be able to extend our existing records and types without having to touch the current code. Well, lets keep to that promise and check how to extend our records without having to touch existing code.</p><p>Imagine, we need to add a predicate telling us whether a shape has an area or not; we might then define the next protocol, as shown:</p><div class="informalexample"><pre class="programlisting">(defprotocolShapeProperties
  (num-sides [this] "How many sides a shape has"))</pre></div><p>Let's get directly to the extend type, which is going to help us define this <code class="literal">num-sides</code> function for our old protocols. Note that with <code class="literal">extend-type</code> we can even define functions for existing Java types:</p><div class="informalexample"><pre class="programlisting">(extend-type Square
ShapeProperties
  (num-sides [this] 4))

(extend-type Circle
ShapeProperties
  (num-sides [this] Double/POSITIVE_INFINITY))

(num-sides square)
;;=&gt; 4

(num-sides circle)
;;=&gt; Infinity</pre></div><p>Protocols <a class="indexterm" id="id195"/>become much more interesting when you extend them for Java types. Lets create a protocol that includes some functions for list like structures:</p><div class="informalexample"><pre class="programlisting">(defprotocolListOps
  (positive-values [list])
  (negative-values [list])
  (non-zero-values [list]))

(extend-type java.util.List
ListOps
  (positive-values [list]
    (filter #(&gt; % 0) list))
  (negative-values [list]
    (filter #(&lt; % 0) list))
  (non-zero-values [list]
    (filter #(not= % 0) list)))</pre></div><p>And now you can use the positive values, negative values and <code class="literal">non-zero-values</code> with anything that extends from <code class="literal">java.util.List</code>, including Clojure's vectors:</p><div class="informalexample"><pre class="programlisting">(positive-values [-1 0 1])
;;=&gt; (1)

(negative-values [-1 0 1])
;;=&gt; (-1)

(no-zero-values [-1 0 1])
;;=&gt; (-1 1)</pre></div><p>It might not be very exciting to extend <code class="literal">java.util.List</code>, since you can define these three as functions and it works the same way but you can extend any custom Java type with this mechanism.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Summary</h1></div></div></div><p>Now we understand Clojure's way a little bit better and we have a better grasp of what to look for when we need polymorphism. We understand that when needing a polymorphic function we have several options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can implement multimethods if we need a highly customized dispatching mechanism</li><li class="listitem" style="list-style-type: disc">We can implement multimethods if we need to define a complex inheritance structure</li><li class="listitem" style="list-style-type: disc">We can implement a protocol and define a custom type that implements that protocol</li><li class="listitem" style="list-style-type: disc">We can define a protocol and extend existing Java or Clojure types with our custom functions for each type</li></ul></div><p>Polymorphism in Clojure is very powerful. It allows you to extend the functionality of Clojure or Java types that already exist; it feels like adding methods to an interface. The best thing about it is that you don't need to redefine or recompile anything.</p><p>In the next chapter, we will talk about concurrency—one of the key features of Clojure. We will learn about the idea of what the identity and values are and how those key concepts make writing concurrent programs much easier.</p></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Concurrency</h1></div></div></div><p>Programming has changed, in the past we could just rely on computers getting faster year after year. This is proving to be more and more difficult; so, hardware manufacturers are taking a different approach. Now, they are embedding more processors into computers. Nowadays, it's not uncommon to see phones with just or four cores.</p><p>This calls for a different way of writing software, one in which we are able to execute some tasks in other processes, explicitly. The modern languages are trying to make this task feasible and easier for modern developers, and Clojure is no exception.</p><p>In this chapter, we will see how Clojure enables you to write simple concurrent programs by reviewing Clojure's core concepts and primitives; in particular, we need to understand the concept of identity and value that Clojure has embedded into the language. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using your Java knowledge</li><li class="listitem" style="list-style-type: disc">The Clojure model of state and identity</li><li class="listitem" style="list-style-type: disc">Promises</li><li class="listitem" style="list-style-type: disc">Futures</li><li class="listitem" style="list-style-type: disc">Software transactional memory and refs</li><li class="listitem" style="list-style-type: disc">Atoms</li><li class="listitem" style="list-style-type: disc">Agents</li><li class="listitem" style="list-style-type: disc">Validators</li><li class="listitem" style="list-style-type: disc">Watchers</li></ul></div><div class="section" title="Using your Java knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Using your Java knowledge</h1></div></div></div><p>Knowing<a class="indexterm" id="id196"/> Java and your way around Java's threading APIs gives you a great advantage, since Clojure relies on the tools that you already know.</p><p>Here, you'll see how to use threads and you can extend everything you see here to execute other services.</p><p>Before going any further, let's create a new project that we'll use as a sandbox for all of our tests.</p><p>Create it, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Using your Java knowledge" src="graphics/B04289_06_01.jpg"/></div><p>Modify<a class="indexterm" id="id197"/> the <code class="literal">clojure-concurrency.core</code> namespace, so that it looks similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">(ns clojure-concurrency.core)

(defn start-thread [func]
  (.start (Thread. func)))</pre></div><p>It's easy to understand what's happening here. We are creating a thread with our function and then starting it; so that we can use it in the REPL, as follows:</p><div class="mediaobject"><img alt="Using your Java knowledge" src="graphics/B04289_06_02.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>
<code class="literal">java.lang.Thread</code> has <a class="indexterm" id="id198"/>a constructor, which receives an object implementing the runnable interface. You can just pass a Clojure function because every function in Clojure implements runnable and callable interfaces. This means that you can also use the executors transparently in Clojure!</p></div></div><p>We'll see a <code class="literal">nil</code> and <code class="literal">Hello threaded world</code> values in any random order. The <code class="literal">nil</code> value is what the start thread returns.</p><p>The <code class="literal">Hello threaded world</code> is <a class="indexterm" id="id199"/>a message from another thread. With this, we now have the basic tools to get to know and understand how threads work in Clojure.</p></div></div>
<div class="section" title="The Clojure model of state and identity"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>The Clojure model of state and identity</h1></div></div></div><p>Clojure has <a class="indexterm" id="id200"/>very strong opinions about concurrency, in order to take it in a simpler way it redefines what state and identity mean. Let's explore the meaning of this concepts in Clojure.</p><p>When talking about state in Java, you probably think about the values of the attributes of your Java classes. The state in Clojure is similar to Java, it refers to the values of objects but there are very important differences that allow simpler concurrency.</p><p>In Clojure, identity<a class="indexterm" id="id201"/> is an <a class="indexterm" id="id202"/>entity that might have different values over time. Consider the following examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">I have an identity; I will be and continue being this particular individual, my opinions, ideas, and appearance might change over time but I am the same individual with the same identity.</li><li class="listitem" style="list-style-type: disc">You have a bank account; it has a particular number and is run by a particular bank. The amount of money you have in it changes over time, but it is the same bank account.</li><li class="listitem" style="list-style-type: disc">Consider a ticker symbol (such as GOOG), it identifies a stock in the stock market; the value associated with it changes over time, but not its identity.</li></ul></div><p>
<span class="strong"><strong>State</strong></span> is a <a class="indexterm" id="id203"/>value<a class="indexterm" id="id204"/> that an identity took at some point in time. One of its important features is that it is immutable. State is a snapshot of an identity's value at some given time.</p><p>So, in the previous examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Who you are right now, how you feel, how you look, and what you think is your current state</li><li class="listitem" style="list-style-type: disc">The money you currently have in your bank account is its current state</li><li class="listitem" style="list-style-type: disc">The value of the GOOG stock is its current state</li></ul></div><p>All of these states are immutable; it doesn't matter who you are tomorrow or how much you win or spend. It is true and it will always be true that in this particular moment in time you have a certain state.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Rich Hickey, Clojure's author, is a great talker and has several talks in which he explains the ideas and philosophy behind Clojure. In one of them, (Are We There Yet?) he explains this idea of state, identity, and time very extensively.</p></div></div><p>Let's now explain the two key concepts in Clojure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Identity</strong></span>: Throughout<a class="indexterm" id="id205"/> your whole life, you have a single identity; you never stop being you, even if you keep changing throughout your whole life.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>State</strong></span>: At <a class="indexterm" id="id206"/>any given moment in your life, you are a certain person with likes, dislikes, and some beliefs. We call this way of being at a moment of your life, the state. If you look at a particular moment in your life, you will see a fixed value. Nothing will change the fact that you were the way you were in that moment in time. That particular state is immutable; over time, you have different states or values, but each of those states is immutable.</li></ul></div><p>We use this fact to write simpler concurrent programs. Whenever you want to interact with an identity, you look at it and you get its current value (a snapshot at the time), and then you operate with what you have.</p><p>In imperative programming, you normally have a guarantee that you have the latest value but it is very difficult to keep it in a consistent state. The reason for this is that you are relying on a shared mutable state.</p><p>A shared mutable state is the reason why you need to use a synchronized code, locks, and mutexes. It is also the reason for very complex programs, with difficult bugs to track.</p><p>Nowadays, Java is learning the lessons from other programming languages and now it has primitives that allow simpler concurrent programming. These ideas are taken from other languages and newer ideas, so there is a good chance that someday you'll see similar concepts to what you'll study here in other mainstream programming languages.</p><p>There is no guarantee that you'll always have the latest value, but don't worry, you just have to think about things differently and use the concurrency primitives that Clojure gives you.</p><p>This is similar to how you work in real life, you don't know exactly what's happening with all of your friends or co-workers when you do something for them; you talk to them, get the current facts, and then go and get working. While you are at it, something needs to change; in this case we need a coordination mechanism.</p><p>Clojure has various such coordination mechanisms, let's have a look at them.</p></div>
<div class="section" title="Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Promises</h1></div></div></div><p>If <a class="indexterm" id="id207"/>you are a full stack Java developer, there is a good chance that you have met promises in JavaScript.</p><p>Promises are simple abstractions that don't impose strict requirements on you; you can use them to calculate the result on some other thread, light process, or anything you like.</p><p>In Java, there are a couple of ways to achieve this; one of them is with futures (<code class="literal">java.util.concurrentFuture</code>) and if you want something more similar to JavaScript's promise there is a nice implementation called <a class="indexterm" id="id208"/>
<span class="strong"><strong>jdeferred</strong></span> (<a class="ulink" href="https://github.com/jdeferred/jdeferred">https://github.com/jdeferred/jdeferred</a>), which you might have used before.</p><p>In essence a promise is just a promise that you can give to your caller, the caller can use it at any given time. There are two possibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the promise has already been fulfilled, the call returns immediately</li><li class="listitem" style="list-style-type: disc">If not, the caller will block until the promise is fulfilled</li></ul></div><p>Let's take a look at an example; remember to use the start-thread function in the <code class="literal">clojure-concurrency.core</code> package:</p><div class="mediaobject"><img alt="Promises" src="graphics/B04289_06_03.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Promises are only calculated once and then cached. So don't worry about using them as many times as you like once it has been calculated, there is no runtime cost associated!</p></div></div><p>Let's stop here and analyze the code, we are creating a promise called <code class="literal">p</code> and then we start a thread that does two things.</p><p>It tries to get a value from <code class="literal">p</code> (the <code class="literal">deref</code> function tries to read the value from a promise) and then prints <code class="literal">Hello world</code>.</p><p>We won't see the <code class="literal">Hello world</code> message just yet; we will instead see a <code class="literal">nil</code> value. Why is that?</p><p>The start thread returns the <code class="literal">nil</code> value and what happens now is what we described in the first place; <code class="literal">p</code> is the promise and our new thread will block it until it gets a value.</p><p>In order to see the <code class="literal">Hello world</code> message, we need to deliver the promise. Let's do that now:</p><div class="mediaobject"><img alt="Promises" src="graphics/B04289_06_04.jpg"/></div><p>As you can see, we now get the <code class="literal">Hello world</code> message!</p><p>As I said, there<a class="indexterm" id="id209"/> is no need to use another thread. Let's now see another example in the REPL:</p><div class="mediaobject"><img alt="Promises" src="graphics/B04289_06_05.jpg"/></div><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>You can use <code class="literal">@p</code> instead of (<code class="literal">deref p</code>), it works for every identity in this chapter too.</p></div></div><p>In this example we don't create separate threads; we create the promise, deliver it, and then use it in the same thread.</p><p>As you can see, promises are an extremely simple type of synchronization mechanism, you can decide whether to use threads, executor services (which are just thread pools), or some other mechanism, such as lightweight threads.</p><p>Let's have a look at Pulsar library for creating lightweight threads.</p><div class="section" title="Pulsar and lightweight threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Pulsar and lightweight threads</h2></div></div></div><p>Creating a thread is <a class="indexterm" id="id210"/>an expensive operation and it consumes RAM memory. To know how much memory creating a thread consumes in Mac OS X or Linux, run the next command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>java -XX:+PrintFlagsFinal -version | grep ThreadStackSize</strong></span>
</pre></div><p>What you <a class="indexterm" id="id211"/>see here will depend on the OS and JVM version that you are using, with Java 1.8u45 on Mac OS X, we get the following output:</p><div class="mediaobject"><img alt="Pulsar and lightweight threads" src="graphics/B04289_06_06.jpg"/></div><p>I am getting a stack size of 1024 kilobytes per thread. What can we do to improve the numbers? Other languages, such as Erlang and Go create a few threads from the beginning and then execute their tasks using those threads. It becomes important to be able to suspend a particular task and run another in the same thread.</p><p>In Clojure there is a library<a class="indexterm" id="id212"/> called <span class="strong"><strong>Pulsar</strong></span> (<a class="ulink" href="https://github.com/puniverse/pulsar">https://github.com/puniverse/pulsar</a>), which is an interface for a Java API called <a class="indexterm" id="id213"/>
<span class="strong"><strong>Quasar</strong></span> (<a class="ulink" href="https://github.com/puniverse/quasar">https://github.com/puniverse/quasar</a>).</p><p>In order to support Pulsar, as of version 0.6.2, you need to do two things.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add the <code class="literal">[co.paralleluniverse/pulsar "0.6.2"]</code> dependency to your project</li><li class="listitem" style="list-style-type: disc">Add an instrumentation agent to your JVM (<code class="literal">adding :java-agents [[co.paralleluniverse/quasar-core "0.6.2"]]</code> to your <code class="literal">project.clj</code>)</li></ul></div><p>The instrumentation agent should be able to suspend functions in a thread and then change them for other functions. In the end, your <code class="literal">project.clj</code> file should look similar to:</p><div class="informalexample"><pre class="programlisting"> (defproject clojure-concurrency "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
            :dependencies [[org.clojure/clojure "1.6.0"]
            [co.paralleluniverse/pulsar "0.6.2"]]
  :java-agents [[co.paralleluniverse/quasar-core "0.6.2"]])</pre></div><p>Let's write our<a class="indexterm" id="id214"/> last example with promises using Pulsar's lightweight threads called fibers.</p><p>Pulsar comes with<a class="indexterm" id="id215"/> its own promises in the <code class="literal">co.paralleluniverse.pulsar.core</code> package and they can be used as a drop-in replacement for promises in <code class="literal">clojure.core</code>:</p><div class="informalexample"><pre class="programlisting"> (clojure.core/use 'co.paralleluniverse.pulsar.core)
(def p1 (promise))
(def p2 (promise))
(def p3 (promise))
(spawn-fiber #(clojure.core/deliver p2 (clojure.core/+ @p1 5)))
(spawn-fiber #(clojure.core/deliver p3 (clojure.core/+ @p1 @p2)))
(spawn-thread #(println @p3))
(clojure.core/deliver p1 99)
;; 203</pre></div><p>This example is a bit more interesting, we use two of Pulsar's functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">spawn-fiber</code>: This<a class="indexterm" id="id216"/> function creates a light thread, you can create thousands of fibers if you want in a single program. They are cheap to create and as long as you program them carefully, there shouldn't be many problems coming from this.</li><li class="listitem" style="list-style-type: disc"><code class="literal">span-thread</code>: This<a class="indexterm" id="id217"/> is Pulsar's version of start-thread, it creates a real thread and runs it.</li></ul></div><p>In this particular example, we calculate <code class="literal">p2</code> and <code class="literal">p3</code> in two fibers and then <code class="literal">p3</code> in a thread. At this point, everything is waiting for us to deliver the value of <code class="literal">p1</code>; we do it with the <code class="literal">deliver</code> function.</p><p>Pulsar has other very interesting features that allow for simpler parallel programming, have a look at the documentation if you are interested. In the last part of this chapter, we will have a look at <code class="literal">core.async</code>. Pulsar has an interface modelled after <code class="literal">core.async</code>, which you can use if you like.</p></div></div>
<div class="section" title="Futures"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Futures</h1></div></div></div><p>If you have been <a class="indexterm" id="id218"/>using Java for a while, you might know the <code class="literal">java.util.concurrent.Future</code> class, this is Clojure's implementation of futures and it is extremely similar to Java, only a bit simpler. Its interface and usage are almost identical to promises with a very important difference, when using futures everything will run in a different thread automatically.</p><p>Let's see a simple example using futures, in any REPL do the following:</p><div class="informalexample"><pre class="programlisting">(def f (future (Thread/sleep 20000) "Hello world"))
(println @f)</pre></div><p>Your REPL should freeze for 20 seconds and then print <code class="literal">Hello world</code>.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Futures are also cached, so you only need to pay once for the cost of calculation and then you can use them any number of times you want.</p></div></div><p>At first glance, futures look much easier than promises. You don't need to worry about creating threads or fibers, but there are downsides to this approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You have less flexibility; you can only run futures in a predefined thread pool.</li><li class="listitem" style="list-style-type: disc">You should be careful if your futures take too much time, they could end up NOT running because the implicit thread pool has a number of threads available. If they are all busy some of your tasks will end up queued and waiting.</li></ul></div><p>
<code class="literal">Futures</code> have their use cases, if you have very few processor intensive tasks, if you have IO bound tasks, maybe using promises with fibers is a good idea, since they allow you to keep your processor free to run more tasks concurrently.</p></div>
<div class="section" title="Software transactional memory and refs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Software transactional memory and refs</h1></div></div></div><p>One of Clojure's most interesting <a class="indexterm" id="id219"/>features is <span class="strong"><strong>software transactional memory</strong></span> (<span class="strong"><strong>STM</strong></span>). It uses <a class="indexterm" id="id220"/>
<span class="strong"><strong>multiversion concurrency control</strong></span> (<span class="strong"><strong>MVCC</strong></span>), in a very similar fashion to how databases work, implementing a form of optimistic concurrency control.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>MVCC is what databases use for transactions; what this means is that every operation within a transaction has its own copy of variables. After executing its operations, it checks if any of the used variables changed during the transaction and if they did the transaction fails. This is called optimistic concurrency control because we are optimistic and we don't lock any variable; we let every thread do its work thinking that it's going to work correctly and then check if it was correct. In practice, this allows for greater concurrency.</p></div></div><p>Let's start <a class="indexterm" id="id221"/>with the most obvious example, a bank account.</p><p>Let's write some code now, enter into the REPL and write:</p><div class="informalexample"><pre class="programlisting">(def account (ref 20000))
(dosync (ref-set account 10))
(deref account)

(defn test []
  (dotimes [n 5]
    (println n @account)
    (Thread/sleep 2000))
  (ref-set account 90))

(future (dosync (test)))
(Thread/sleep 1000)
(dosync (ref-set account 5))</pre></div><p>Try to write the future and the <code class="literal">dosync</code> functions at the same time so you have the same results.</p><p>We have just three lines of code here but there are quite a few things happening.</p><p>First of all we define a <code class="literal">ref (account)</code>; refs are the managed variables in transactions. They are also the first implementation we see of Clojure's identity idea. Note that the account is an identity now and it might take multiple values throughout its life.</p><p>We now modify its value, we do this within a transaction since refs cannot be modified outside of transactions; thus, the <code class="literal">dosync</code> block.</p><p>In the end, we print the account and we can use (<code class="literal">deref</code> account) or <code class="literal">@account</code>, as we did for promises and futures.</p><p>Refs can be read from anywhere, there is no need for it to be within a transaction.</p><p>Let's look at something a little bit more interesting now, write or copy the next code into the REPL:</p><div class="informalexample"><pre class="programlisting">(def account (ref 20000))

(defn test []
  (println "Transaction started")
  (dotimes [n 5]
    (println n @account)
    (Thread/sleep 2000))
  (ref-set account 90))

(future (dosync (test)))
(future (dosync (Thread/sleep 4000) (ref-set account 5)))</pre></div><p>If everything goes well, you should have an output similar to the following screenshot:</p><div class="mediaobject"><img alt="Software transactional memory and refs" src="graphics/B04289_06_07.jpg"/></div><p>This might <a class="indexterm" id="id222"/>seem a little strange, what is happening?</p><p>The first transaction starts its process using the current value for account, the other transaction then modifies the value of account before the first transaction is finished; Clojure realizes this and it restarts the first transaction.</p><div class="tip" style="" title="Tip"><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>You shouldn't execute functions with side effects within transactions, as there is no guarantee that they will be executed only once. If you need to do something like that you should use an agent.</p></div></div><p>This is the first example of how a transaction works, but using <code class="literal">ref-set</code> is not a good idea in general.</p><p>Let's take a look at another example, the classic example of moving money from an account <span class="emphasis"><em>A</em></span> to an account <span class="emphasis"><em>B</em></span>:</p><div class="informalexample"><pre class="programlisting">(def account-a (ref 10000))
(def account-b (ref 2000))
(def started (clojure.core/promise))

(defn move [acc1 acc2 amount]
  (dosync
    (let [balance1 @acc1
           balance2 @acc2]
      (println "Transaction started")
      (clojure.core/deliver started true)
      (Thread/sleep 5000)
      (when (&gt; balance1 amount)
        (alter acc1 - amount)
        (alter acc2 + amount))
      (println "Transaction finished"))))

(future (move account-a account-b 50))
@started
(dosync (ref-set account-a 20))</pre></div><p>This is a better <a class="indexterm" id="id223"/>example of how transactions work; you will probably see something similar to the following screenshot:</p><div class="mediaobject"><img alt="Software transactional memory and refs" src="graphics/B04289_06_08.jpg"/></div><p>First of all, you need to understand how the <code class="literal">alter</code> function works; it's simple and it receives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ref that it has to modify</li><li class="listitem" style="list-style-type: disc">The function that it has to apply</li><li class="listitem" style="list-style-type: disc">The extra arguments</li></ul></div><p>So this function:</p><div class="informalexample"><pre class="programlisting">(alter ref fun arg1 arg2)</pre></div><p>Is translated to something like this:</p><div class="informalexample"><pre class="programlisting">(ref-set ref (fun @ref arg1 arg2))</pre></div><p>This is the preferred way to modify the current value.</p><p>Let's see a step <a class="indexterm" id="id224"/>by step description of what's going on here:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We define two accounts with a balance of 10000 and 2000.</li><li class="listitem">We try to move 500 units from the first account to the second but first we sleep for 5 seconds.</li><li class="listitem">We announce (using the promise) that we have started the transaction. The current thread moves on, since it was waiting for the started value.</li><li class="listitem">We set the balance of account-a to 20.</li><li class="listitem">The first transaction realizes that something has changed and restarts.</li><li class="listitem">The transaction goes on and is finished this time.</li><li class="listitem">Nothing happens, since the new balance is not enough to move 50 units.</li></ol></div><p>In the end, if you check the balance, like <code class="literal">[@account-a @account-b]</code>, you will see that the first account has 20 and the second account has 2000.</p><p>There is another use case that you should take into account; let's check the following code:</p><div class="informalexample"><pre class="programlisting">(def account (ref 1000))
(def secured (ref false))
(def started (promise))

(defn withdraw [account amount secured]
  (dosync
    (let [secured-value @secured]
      (deliver started true)
      (Thread/sleep 5000)
      (println :started)
      (when-not secured-value
        (alter account - amount))
      (println :finished))))

(future (withdraw account 500 secured))
@started
(dosync (ref-set secured true))</pre></div><p>The idea is that if <code class="literal">secured</code> is set to true, you shouldn't be able to withdraw any money.</p><p>If you run it and then check for the value of <code class="literal">@account</code>, you'll see that even after changing the value of <code class="literal">secured</code> to true a withdrawal occurs. Why is that?</p><p>The reason is that <a class="indexterm" id="id225"/>transactions only check for values that you modify within a transaction or values that you read; here we are reading the secured value before the modification, so the transaction doesn't fail. We can tell the transaction to be a little bit more careful by using the following code:</p><div class="informalexample"><pre class="programlisting"> (ensure secured)
;; instead of
@secured


(def account (ref 1000))
(def secured (ref false))
(def started (promise))

(defn withdraw [account amount secured]
  (dosync
    (let [secured-value (ensure secured)]
      (deliver started true)
      (Thread/sleep 5000)
      (println :started)
      (when-not secured-value
        (alter account - amount))
      (println :finished))))

(future (withdraw account 500 secured))
@started
(dosync (ref-set secured true))</pre></div><p>Here almost the same thing happened. What is the difference?</p><p>There is one subtle difference, the second transaction can't finish until the first transaction is done. If you look at it in detail, you will notice that you can't modify the secured value until after the other transaction runs.</p><p>This is similar to a lock; not the best idea but useful in some cases.</p></div>
<div class="section" title="Atoms"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Atoms</h1></div></div></div><p>We <a class="indexterm" id="id226"/>have now seen how promises, futures, and transactions work in Clojure. We'll now see atoms.</p><p>Even though STM is very useful and powerful you'll see that in practice it is not very commonly used.</p><p>Atoms<a class="indexterm" id="id227"/> are one of Clojure's workhorses, when it comes to concurrent programming.</p><p>You can think of atoms as transactions that modify one single value. You might be thinking, what good is that? Imagine you had lots of events that you want to store in a single vector. If you are used to Java, you probably know that using a <code class="literal">java.util.ArrayList</code> package is bound to have problems; since, you are almost surely going to lose data.</p><p>In that case, you probably want to use a class from the <code class="literal">java.util.concurrent</code> package, how can you guarantee that you'll have no data loss in Clojure?</p><p>It's easy, atoms come to the rescue! Let's try this piece of code:</p><div class="informalexample"><pre class="programlisting">(clojure.core/use 'co.paralleluniverse.pulsar.core)
(def events (atom []))
(defn log-events [count event-id]
  (dotimes [_ count]
    (swap! events conj event-id)))
(dotimes [n 5]
  (spawn-fiber #(log-events 500 n)))</pre></div><p>We are again using Pulsar and its lightweight threads. Here, we define an events atom and a <code class="literal">log-events</code> function.</p><p>The <code class="literal">log-events</code> execute a <code class="literal">swap!</code> a given number of times.</p><p>
<code class="literal">Swap!</code> is similar to the <code class="literal">alter</code> function it receives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The atom that it should modify</li><li class="listitem" style="list-style-type: disc">The function that it applies to the atom</li><li class="listitem" style="list-style-type: disc">The extra arguments</li></ul></div><p>In this case, it gives the atom the new value that comes from:</p><div class="informalexample"><pre class="programlisting">(conj events event-id)</pre></div><p>We then spawn five fibers, each fiber adds 500 events to the events atom.</p><p>After running this, we can check for the number of events from each fiber like this:</p><div class="informalexample"><pre class="programlisting">(count (filter #(= 0 %) @events))
;; 500
(count (filter #(= 1 %) @events))
;; 500
(count (filter #(= 2 %) @events))
;; 500
(count (filter #(= 3 %) @events))
;; 500
(count (filter #(= 4 %) @events))
;; 500</pre></div><p>As you can see, we<a class="indexterm" id="id228"/> have 500 elements from each fiber with no data loss and using Clojure's default data structures. There is no need to use special data structures for each use case, locks, or mutexes. This allows for greater concurrency.</p><p>When you modify an atom, you need to wait for the operation to be complete meaning it is synchronous.</p></div>
<div class="section" title="Agents"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Agents</h1></div></div></div><p>What if <a class="indexterm" id="id229"/>you don't care about the result of some operation? You just need to fire something and then forget it. In that case agents are what you need.</p><p>Agents also run in separate thread pools, there are two functions that you can use to fire an agent:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">send</code>: This executes your function in an implicit thread pool</li><li class="listitem" style="list-style-type: disc"><code class="literal">send-off</code>: This tries to execute your function in a new thread but there's a change, it will reuse another thread</li></ul></div><p>Agents are the way to go if you want to cause side effects in a transaction; since, they will only be executed after the transaction has completed successfully.</p><p>They work in a very simple manner, here is an example usage:</p><div class="informalexample"><pre class="programlisting">(def agt (agent 0))
(defn sum [&amp; nums]
  (Thread/sleep 5000)
  (println :done)
  (apply + nums))
(send agt sum 10) ;; You can replace send with send-off
                  ;; if you want this to be executed in a different thread
@agt</pre></div><p>If you copy and paste the exact previous code you will see a <code class="literal">0</code> and then a <code class="literal">:done</code> message, if you check for the value of <code class="literal">@agt</code>, then you will see the value <code class="literal">10</code>.</p><p>Agents are a good way to execute a given task and modify some value in a different thread with simpler semantics than those of futures or manually modifying values in another thread.</p><div class="section" title="Validators"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Validators</h2></div></div></div><p>We<a class="indexterm" id="id230"/> have seen the primary concurrency primitives now, let's see some utilities that apply to all of them at once.</p><p>We can define a validator that checks if the new value of some function is desirable or not; you can use them for refs, atoms, agents, and even vars.</p><p>The <code class="literal">validator</code> function must receive a single value and return true if the new value is valid or false otherwise.</p><p>Let's create a simple <code class="literal">validator</code> that checks if the new value is lower than <code class="literal">5</code>:</p><div class="informalexample"><pre class="programlisting">(def v (atom 0))
(set-validator! v #(&lt; % 5))
(swap! v + 10)

;; IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)</pre></div><p>We get an exception. The reason is that the new value (<code class="literal">10</code>) is not valid.</p><p>You can add <code class="literal">4</code> without a problem:</p><div class="informalexample"><pre class="programlisting">(swap! v + 4)
;; 4</pre></div><p>Be careful with the validator and agents, since you will probably not know when an exception occurred:</p><div class="informalexample"><pre class="programlisting">(def v (agent 0))
(set-validator! v #(&lt; % 5))
(swap! v + 10)
;; THERE IS NO EXCEPTION</pre></div></div><div class="section" title="Watchers"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Watchers</h2></div></div></div><p>Similar <a class="indexterm" id="id231"/>to validators, there are also watchers. Watchers are functions that are executed whenever Clojure's identities get a new value. An important question is the thread in which watchers run. Watchers run in the same thread as the watched entity (if you add a watcher to an agent it will be run in the agent's thread), it will be run before the agent code executes, so you should be careful and use the old-value new-value instead of reading the value with <code class="literal">deref</code>:</p><div class="informalexample"><pre class="programlisting">(def v (atom 0))
(add-watch v :sample (fn [k i old-value new-value] (println (= i v) k old-value new-value)))
(reset! v 5)</pre></div><p>The <code class="literal">add-watch</code> function receives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ref, atom, agent, or var that should be watched</li><li class="listitem" style="list-style-type: disc">A key that will be passed to the watcher function</li><li class="listitem" style="list-style-type: disc">A function with four parameters: the key, the reference itself, the old value, and the new value</li></ul></div><p>After <a class="indexterm" id="id232"/>executing the previous code we get:</p><div class="informalexample"><pre class="programlisting">true :sample 0 5</pre></div></div></div>
<div class="section" title="core.async"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>core.async</h1></div></div></div><p>The <code class="literal">core.async</code> is yet<a class="indexterm" id="id233"/> another way of programming concurrently; it uses the idea of lightweight threads and channels to communicate between them.</p><div class="section" title="Why lightweight threads?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Why lightweight threads?</h2></div></div></div><p>The <a class="indexterm" id="id234"/>lightweight threads are used in languages, such as go and Erlang. They excel in being able to run thousands of threads in a single process.</p><p>What is the<a class="indexterm" id="id235"/> difference between the lightweight threads and traditional threads?</p><p>The traditional threads need to reserve memory. This also takes some time. If you want to create a couple of thousand threads, you will be using a noticeable amount of memory for each thread; asking the kernel to do that also takes time.</p><p>What is the difference with lightweight threads? To have a couple of hundred lightweight threads, you only need to create a couple of threads. There is no need to reserve memory and lightweight threads are a mere software idea.</p><p>This can be achieved with most languages and Clojure is adding first class support (without changing the language this is part of the Lisp power) with using <code class="literal">core.async</code>! Let's have a look at how it works.</p><p>There are two concepts that you need to keep in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Goblocks</strong></span>: They <a class="indexterm" id="id236"/>are the lightweight threads.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Channels</strong></span>: Channels <a class="indexterm" id="id237"/>are a way to communicate between goblocks, you can think of them as queues. Goblocks can publish a message to the channel and other goblocks can take a message from them. Just as there are integration patterns for queues, there are integration patterns for channels and you will find concepts similar to broadcasting, filtering, and mapping.</li></ul></div><p>Now, let's play a little with each of them so you can understand better how to use them for our program.</p></div><div class="section" title="Goblocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Goblocks</h2></div></div></div><p>You <a class="indexterm" id="id238"/>will find <a class="indexterm" id="id239"/>goblocks in the <code class="literal">clojure.core.async</code> namespace.</p><p>Goblocks are extremely easy to use, you need the go macro and you will do something similar to this:</p><div class="informalexample"><pre class="programlisting">(ns test
  (:require [clojure.core.async :refer [go]]))

(go
  (println "Running in a goblock!"))</pre></div><p>They are similar to threads; you just need to remember that you can create goblocks freely. There can be thousands of running goblocks in a single JVM.</p></div><div class="section" title="Channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Channels</h2></div></div></div><p>You<a class="indexterm" id="id240"/> can <a class="indexterm" id="id241"/>actually use anything you like to communicate between goblocks, but it is recommended that you use channels.</p><p>Channels have two main operations: putting and getting. Let's check how to do it:</p><div class="informalexample"><pre class="programlisting"> (ns test
  (:require [clojure.core.async :refer [go chan &gt;! &lt;!]]))

(let [c (chan)]
  (go (println (str "The data in the channel is" (&lt;! c))))
  (go (&gt;! c 6)))</pre></div><p>That's it!! It looks pretty simple, as you can see there are three main functions that we are using with channels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">chan</code>: This <a class="indexterm" id="id242"/>function creates a channel and the channels can store some messages in a buffer. If you want this functionality, you should just pass the size of the buffer to the <code class="literal">chan</code> function. If no size is specified, the channel can store only one message.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&gt;!</code>: The <a class="indexterm" id="id243"/>put function must be used within a goblock; it receives a channel and the value you want to publish to it. This function blocks, if a channel's buffer is already full. It will block until something is consumed from the channel.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;!</code>: This <a class="indexterm" id="id244"/>takes function; this function must be used within a goblock. It receives the channel you are taking from. It is blocking and if you haven't published something in the channel it will park until there's data available.</li></ul></div><p>There are lots of other functions that you can use with channels, for now let's add two related functions that you will probably use soon:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&gt;!!</code>: The <a class="indexterm" id="id245"/>blocking put, works exactly the same as the <code class="literal">put</code> function; except it can be used from anywhere. Note that if a channel cannot take more data, this function will block the entire thread from where it runs.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;!!</code>: The <a class="indexterm" id="id246"/>blocking works exactly the same as the <code class="literal">take</code> function, except you can use this from anywhere and not just from inside goblocks. Just keep in mind that this blocks the thread where it runs until there's data available.</li></ul></div><p>If you <a class="indexterm" id="id247"/>look into the <code class="literal">core.async</code> API docs (<a class="ulink" href="http://clojure.github.io/core.async/">http://clojure.github.io/core.async/</a>) you will find a fair amount of functions.</p><p>Some of them look similar to the functions that give you functionalities similar to queues, let's take a look at the <code class="literal">broadcast</code> function:</p><div class="informalexample"><pre class="programlisting">(ns test
  (:require [clojure.core.async.lab :refer [broadcast]]
            [clojure.core.async :refer [chan &lt;! &gt;!! go-loop]])

(let [c1 (chan 5)
      c2 (chan 5)
      bc (broadcast c1 c2)]
  (go-loop []
    (println "Getting from the first channel" (&lt;! c1))
    (recur))
  (go-loop []
    (println "Getting from the second channel" (&lt;! C2))
    (recur))
  (&gt;!! bc 5)
  (&gt;!! bc 9))</pre></div><p>With this you can publish it to several channels at the same time, this is helpful if you want to subscribe multiple processes to a single source of events with a great amount of separation of concern.</p><p>If you take a good look, you will also find familiar functions over there: <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Depending on the version of <code class="literal">core.async</code>, some of these functions might not be there anymore.</p></div></div><p>Why are these functions there? Those functions are meant to modify collections of data, right?</p><p>The reason is that there has been a good amount of effort towards using channels as higher-level abstractions.</p><p>The idea is <a class="indexterm" id="id248"/>to see channels as collections of events, if you think of them that way it's easy to see that you can create a new channel by mapping every element of an old channel or you can create a new channel by filtering away some elements.</p><p>In recent versions of Clojure, the abstraction has become even more noticeable with transducers.</p></div><div class="section" title="Transducers"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Transducers</h2></div></div></div><p>Transducers<a class="indexterm" id="id249"/> are a way to separate the computations from the input source. Simply, they are a way to apply a sequence of steps to a sequence or a channel.</p><p>Let's look at an example of a sequence:</p><div class="informalexample"><pre class="programlisting">(let [odd-counts (comp (map count)
                       (filter odd?))
      vs [[1 2 3 4 5 6]
          [:a :c :d :e]
          [:test]]]
  (sequence odd-counts vs))</pre></div><p>The <code class="literal">comp</code> feels similar to the threading macros, it composes functions and stores the steps of the computation.</p><p>The interesting part is that we can use the same odd-counts transformation with a channel, such as:</p><div class="informalexample"><pre class="programlisting">(let [odd-counts (comp (map count)
                       (filter odd?))
      input (chan)
      output (chan 5 odd-counts)]
  (go-loop []
    (let [x (&lt;! output)]
      (println x))
      (recur))
  (&gt;!! input [1 2 3 4 5 6])
  (&gt;!! input [:a :c :d :e])
  (&gt;!! input [:test]))</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Summary</h1></div></div></div><p>We have checked the core Clojure mechanisms for concurrent programming, as you can see, they feel natural and they build on already existing paradigms, such as immutability. The most important idea is what an identity and value is; we now know that we can have the following values as identifiers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refs</li><li class="listitem" style="list-style-type: disc">Atoms</li><li class="listitem" style="list-style-type: disc">Agents</li></ul></div><p>We can also get the snapshot of their value with the defer function or the <code class="literal">@</code> shortcut.</p><p>If we want to use something a little more primitive, we can use promises or futures.</p><p>We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's primitives aren't specific to some concurrency mechanism, so we can use any parallel programming mechanism with any type of Clojure primitive.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Macros in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Macros in Clojure</h1></div></div></div><p>In this chapter, we will get to know one of Clojure's most complicated facilities: macros. We will learn what they are for, how to write them, and how to use them. It can be a little challenging, but there is good news too. You should be aware of some tools from your knowledge of the Java language that can help you understand macros better. We will progress little by little with comparisons to other JVM languages, and in the end, we will write some macros and understand that we have been using them for a while.</p><p>We will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding Lisp's foundational ideas</li><li class="listitem" style="list-style-type: disc">Macros as code modification tools</li><li class="listitem" style="list-style-type: disc">Modifying code in Groovy</li><li class="listitem" style="list-style-type: disc">Writing your first macro</li><li class="listitem" style="list-style-type: disc">Debugging your first macro</li><li class="listitem" style="list-style-type: disc">Macros in the real world</li></ul></div><div class="section" title="Lisp's foundational ideas"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Lisp's foundational ideas</h1></div></div></div><p>Lisp is <a class="indexterm" id="id250"/>a very different beast from what you used to know. According to Paul Graham, there<a class="indexterm" id="id251"/> are nine ideas that make Lisp different (these ideas have existed since the late 1950s), and they are:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Conditionals (remember, we are talking 1950s–1960s)</li><li class="listitem">Functions as first-class citizens</li><li class="listitem">Recursion</li><li class="listitem">Dynamic typing</li><li class="listitem">Garbage collection</li><li class="listitem">Programs as sequences of expressions</li><li class="listitem">The symbol type</li><li class="listitem">Lisp's syntax</li><li class="listitem">The whole language is there all the time: at compilation, runtime—always!</li></ol></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If you can, read Paul Graham's essay <span class="emphasis"><em>Revenge of the Nerds</em></span> (<a class="ulink" href="http://www.paulgraham.com/icad.html">http://www.paulgraham.com/icad.html</a>), where he talks about Lisp, what makes it different, and why the language is important.</p></div></div><p>These ideas <a class="indexterm" id="id252"/>have thrived even after the Lisp age; most of them are common nowadays (can you imagine a language without conditionals?). But the last couple of ideas are what makes us Lisp lovers love the syntax (we will fully understand what they mean through this chapter).</p><p>Common languages are trying to achieve the very same things now with a slightly different approach, and you, as a Java developer, have probably seen this.</p></div></div>
<div class="section" title="Macros as code modification tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Macros as code modification tools</h1></div></div></div><p>One of<a class="indexterm" id="id253"/> the first and most common uses of macros is to be able to modify code; they work on the code level, as you will see. Why should we do that? Let's try to understand the problem with something that you are more familiar with—Java.</p><div class="section" title="Modifying code in Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Modifying code in Java</h2></div></div></div><p>Have <a class="indexterm" id="id254"/>you ever used AspectJ or Spring AOP? Have you ever had problems with tools such as ASM or Javassist?</p><p>You have probably used code modification in Java. It is common in Java EE applications, just not explicit. (Have you ever thought about what the <code class="literal">@Transactional</code> annotation does in Java EE or Spring applications?)</p><p>As developers, we try to automate everything we can, so how could we leave out our own devtools?</p><p>We have tried to create ways to modify the bytecode at runtime so that we don't have to remember to open and close resources, or so that we can decouple dependencies and get dependency injection.</p><p>If you use Spring, you probably know about the following use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">@Transactional</code> annotation modifies the annotated method to ensure that your code is wrapped in a database transaction</li><li class="listitem" style="list-style-type: disc">The <code class="literal">@Autowired</code> annotation looks for the required bean and injects it into the annotated property or method</li><li class="listitem" style="list-style-type: disc">The <code class="literal">@Value</code> annotation looks for a configuration value and then injects it</li></ul></div><p>You could probably think of several other annotations that modify the way your classes work.</p><p>The important thing <a class="indexterm" id="id255"/>here is that you understand why we want to modify code, and you probably already know a few mechanisms for doing it, including AspectJ and Spring AOP.</p><p>Let's take a look at how it is done in the Java world; this is what an aspect in Java looks like:</p><div class="informalexample"><pre class="programlisting">package macros.java;

public aspect SampleJavaAspect {
pointcutanyOperation() : execution(public * *.*(..));

    Object around() : anyOperation() {
System.out.println("We are about to execute this " + thisJoinPointStaticPart.getSignature());
       Object ret = proceed();
       return ret;
    }
}</pre></div><p>Aspects have the advantage that you can modify any code you like without having to touch it. This also has its drawbacks since you could modify the code in ways the original author didn't expect and thus cause bugs.</p><p>Another drawback is that you have an extremely limited field of action; you can wrap your modifications around some code or execute something before or after.</p><p>The libraries that generate this code are extremely complex and they can either create a proxy around your objects or modify the bytecode, at runtime or compile time.</p><p>As you can imagine, there are lots of things that you must be aware of, and anything could go wrong. Hence, debugging could prove complicated.</p></div><div class="section" title="Modifying code in Groovy"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Modifying code in Groovy</h2></div></div></div><p>Groovy <a class="indexterm" id="id256"/>has gone further down the road and it provides us with more solutions and more macro-like features.</p><p>Since <a class="indexterm" id="id257"/>Groovy 1.8, we have got a lot of AST transformations. What does AST stand for? It stands for <a class="indexterm" id="id258"/>
<span class="strong"><strong>abstract syntax tree</strong></span>—sounds complicated, right?</p><p>Before explaining it all, let's check what some of them do.</p><div class="section" title="The @ToString annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec15"/>The @ToString annotation</h3></div></div></div><p>The <code class="literal">@ToString</code> annotation<a class="indexterm" id="id259"/> generates <a class="indexterm" id="id260"/>a simple <code class="literal">toString</code> method that includes information about the class of the object and the value of its properties.</p></div><div class="section" title="The @TupleConstructor annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec16"/>The @TupleConstructor annotation</h3></div></div></div><p>The <code class="literal">@TupleConstructor</code> creates <a class="indexterm" id="id261"/>a <a class="indexterm" id="id262"/>constructor that is able to take all of the values of your class at once. Here is an example:</p><div class="informalexample"><pre class="programlisting">@TupleConstructor
class SampleData {
int size
  String color
boolean big
}

new SampleData(5, "red", false") // We didn't write this constructor</pre></div></div><div class="section" title="The @Slf4j annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec17"/>The @Slf4j annotation</h3></div></div></div><p>The <code class="literal">@Slf4j</code> annotation <a class="indexterm" id="id263"/>adds an instance <a class="indexterm" id="id264"/>of a logger, called log by default, to your class, so you can do this:</p><div class="informalexample"><pre class="programlisting">log.info'hello world'</pre></div><p>This can be done without having to manually declare the log instance, the class name, and so on. There are lots of other things that you can do with this type of annotation, but how do they work?</p><p>Now, what is AST and what does it have to do with Clojure macros? Come to think of it, it actually has a lot to do with them.</p><p>To answer that last question, you'll have to understand a little bit about how compilers work.</p><p>We all know that machines (your machine, the JVM, the Erlang BEAM machine) are not capable of understanding human code, so we need a process to convert whatever developers write into what machines understand.</p><p>One of the most important steps of the process is to create a syntax tree, something similar to the following figure:</p><div class="mediaobject"><img alt="The @Slf4j annotation" src="graphics/B04289_07_01.jpg"/></div><p>This is a very simple example of the following expression:</p><div class="informalexample"><pre class="programlisting">3 + 5</pre></div><p>This <a class="indexterm" id="id265"/>tree is <a class="indexterm" id="id266"/>what we call the abstract syntax tree. Let's see the tree of something that's a bit more complicated, such as this piece of code:</p><div class="informalexample"><pre class="programlisting">if(a &gt; 120) {
  a = a / 5
} else {
  a = 1200 
}</pre></div><p>Thus, the tree will look like the following figure:</p><div class="mediaobject"><img alt="The @Slf4j annotation" src="graphics/B04289_07_02.jpg"/></div><p>As you <a class="indexterm" id="id267"/>can see, the figure is still pretty straightforward, and you can probably understand how someone would execute code from a structure like this one.</p><p>Groovy's AST transformation is a way to meddle with such generated code.</p><p>As you<a class="indexterm" id="id268"/> can imagine, this is a much more powerful approach, but you are now messing with what the compiler generated; the probable downside to this is the complexity of the code.</p><p>Let's check, for instance, the code of the <code class="literal">@Slf4j</code> AST. It should be pretty simple, right? It just adds a log property:</p><div class="informalexample"><pre class="programlisting">            private Expression transformMethodCallExpression(Expression exp) {
MethodCallExpressionmce = (MethodCallExpression) exp;
                if (!(mce.getObjectExpression() instanceofVariableExpression)) {
                    return exp;
                }
VariableExpressionvariableExpression = (VariableExpression) mce.getObjectExpression();
                if (!variableExpression.getName().equals(logFieldName)
                        || !(variableExpression.getAccessedVariable() instanceofDynamicVariable)) {
                    return exp;
                }
                String methodName = mce.getMethodAsString();
                if (methodName == null) return exp;
                if (usesSimpleMethodArgumentsOnly(mce)) return exp;

variableExpression.setAccessedVariable(logNode);

                if (!loggingStrategy.isLoggingMethod(methodName)) return exp;

                return loggingStrategy.wrapLoggingMethodCall(variableExpression, methodName, exp);
            }</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>You can check the complete code at <a class="ulink" href="https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java">https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java</a>, and it's also included with the code bundle of this chapter.</p></div></div><p>This <a class="indexterm" id="id269"/>doesn't look simple at all. It is just a fragment and still looks very complicated. What happens here is that you have to deal with the Java <a class="indexterm" id="id270"/>bytecode format and with compiler complications.</p><p>Here, we should remember point number 8<span class="emphasis"><em> </em></span>that Paul Graham made about the syntax of Lisp.</p><p>Let's write our last code example in Clojure:</p><div class="informalexample"><pre class="programlisting">(if (&gt; a 120)
  (/ a 5)
  1200)</pre></div><p>There's something peculiar about this piece of code: it feels very similar to the AST! This is not a coincidence. Actually, in Clojure and Lisp, you are directly writing the AST. This is one of the features that make Lisp a very simple language; you directly write what the computer understands. This might help you understand a little more about why code is data and data is code.</p><p>Imagine if <a class="indexterm" id="id271"/>you <a class="indexterm" id="id272"/>could modify the AST the same way that you modify any other data structure in your programs. But you can, and that's what macros are for!</p></div></div></div>
<div class="section" title="Writing your first macro"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Writing your first macro</h1></div></div></div><p>Now<a class="indexterm" id="id273"/> that you have a clear understanding of how macros work and what they are for, let's start working with Clojure.</p><p>Let me present you with a challenge: write an <code class="literal">unless</code> function in Clojure, something that works like this:</p><div class="informalexample"><pre class="programlisting">(def a 150)

(my-if (&gt; a 200)
  (println"Bigger than 200")
  (println"Smaller than 200"))</pre></div><p>Let's give it a first try; maybe with something like the following syntax:</p><div class="informalexample"><pre class="programlisting">(defn my-if [cond positive negative]
  (if cond
    positive
    negative))</pre></div><p>Do you know what would happen if you wrote this code and then ran it? If you test it, you will get the following result:</p><div class="informalexample"><pre class="programlisting">Bigger than 200
Smaller than 200
Nil</pre></div><p>What's happening here? Let's modify it a bit so that we get a value and we can understand what's happening. Let's define it a bit differently, and let's return a value so that we see something different:</p><div class="informalexample"><pre class="programlisting">      (def a 500)
(my-if (&gt; a 200)
  (do
    (println"Bigger than 200")
    :bigger)
  (do
    (println"Smaller than 200")
    :smaller))</pre></div><p>We will<a class="indexterm" id="id274"/> get the following output:</p><div class="informalexample"><pre class="programlisting">Bigger than 200
Smaller than 200
:bigger</pre></div><p>What's going on here?</p><p>When you pass parameters to a function, everything is evaluated before the actual code of the function runs, so over here, before the body of your function runs, you execute both of the <code class="literal">println</code> methods. After that, the <code class="literal">if</code> runs correctly and you get <code class="literal">:bigger</code>, but we still got an output for the positive and negative cases of our <code class="literal">if</code>. It looks like our code is not working!</p><p>How can we fix this? With our current tools, we probably need to write closures and change the <code class="literal">my-if</code> code to accept functions as parameters:</p><div class="informalexample"><pre class="programlisting">(defn my-if [cond positive negative]
  (if cond
    (positive)
    (negative)))

      (def a 500)
(my-if (&gt; a 200)
  #(do
    (println"Bigger than 200")
    :bigger)
  #(do
    (println"Smaller than 200")
    :smaller))</pre></div><p>This works, but there are several disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are a lot of constraints now for the code (both clauses should now be functions)</li><li class="listitem" style="list-style-type: disc">It doesn't work for every single case</li><li class="listitem" style="list-style-type: disc">It is very complicated</li></ul></div><p>In order to solve this problem, Clojure gives us macros. Let's have a look at how they work:</p><div class="informalexample"><pre class="programlisting">(defmacro my-if [test positive negative]
  (list 'if test positive negative))

(my-if (&gt; a 200)
  (do
    (println"Bigger than 200")
    :bigger)
  (do
    (println"Smaller than 200")
    :smaller))</pre></div><p>The output will be this:</p><div class="informalexample"><pre class="programlisting">;; Bigger than 200
;; :bigger</pre></div><p>This is <a class="indexterm" id="id275"/>great! It works, but what just happened? Why did we just use a macro and why did it work?</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Macros are not normal Clojure functions; they are supposed to generate code and should return a Clojure form. This means that they should return a list that we can use as normal Clojure code.</p></div></div><p>Macros return code that will be executed later. And here is where point number nine of Paul Graham's list comes into play: you have all of the language all the time.</p><p>In C++, you have a mechanism called a macro; when you use it, you have a very limited set of things that you can do compared to actual C++ code.</p><p>In Clojure, you can manipulate the Clojure code any way you want, and you can use the full language here too! Since Clojure code is data, manipulating the code is as easy as manipulating any other data structure.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Macros are run at compile time, which means that at the time of running the code, there is no trace of macros; every macro call is replaced with the generated code.</p></div></div></div>
<div class="section" title="Debugging your first macro"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Debugging your first macro</h1></div></div></div><p>Now, as<a class="indexterm" id="id276"/> you can imagine, since things can get complicated when using macros, there should be some way to debug them. We have two functions to accomplish that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">macroexpand</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">macroexpand-1</code></li></ul></div><p>The difference between them has to do with recursive macros. There is no rule telling you that you can't use a macro from a macro (the whole language is there all the time, remember?). If you wish to go all the way through any macro, you can use <code class="literal">macroexpand</code>; if you wish to go a single step forward, you can use <code class="literal">macroexpand-1</code>.</p><p>Both of them show you the code generated by a macro call; this is what happens when you compile<a class="indexterm" id="id277"/> your Clojure code.</p><p>Give this a try:</p><div class="informalexample"><pre class="programlisting">(macroexpand-1
'(my-if (&gt; a 200)
    (do
      (println"Bigger than 200")
      :bigger)
    (do
      (println"Smaller than 200")
      :smaller)))

;; (if (&gt; a 200) (do (println"Bigger than 200") :bigger) (do (println"Smaller than 200") :smaller))</pre></div><p>There is not much more to macros than this; you now understand them to a good level of detail.</p><p>There are, however, many common problems that you will come across and tools for solving them that you should know about. Let's have a look.</p><div class="section" title="Quote, syntax quote, and unquoting"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Quote, syntax quote, and unquoting</h2></div></div></div><p>As you can see, the <code class="literal">my-if</code> macro uses a quote in it:</p><div class="informalexample"><pre class="programlisting">(defmacro my-if [test positive negative]
  (list 'if test positive negative))</pre></div><p>This <a class="indexterm" id="id278"/>happens because you need the <code class="literal">if</code> symbol as the first element in the resulting form.</p><p>Quoting is very common in macros, since we need to build code instead of evaluating it on the fly.</p><p>There is another type of quoting very <a class="indexterm" id="id279"/>common in macros—syntax quoting—that makes it easier to write code similar to the final code you want to generate. Let's change the implementation of our macro to this:</p><div class="informalexample"><pre class="programlisting">(defmacro my-if [test positive negative]
  '(if test positive negative))



(macroexpand-1
'(my-if (&gt; a 200)
    (do
      (println"Bigger than 200")
      :bigger)
    (do
      (println"Smaller than 200")
      :smaller)))

;; (if clojure.core/test user/positive user/negative)</pre></div><p>Let's see <a class="indexterm" id="id280"/>what happens here. For one,<code class="literal">(if test positive negative)</code> looks much more beautiful than the <code class="literal">list</code> function we had before, but the code generated with <code class="literal">macroexpand-1</code> looks pretty strange. What happened?</p><p>We just used a different form of quoting that allows us to quote full expressions. It does some interesting things. As you can see, it changes the parameters to fully qualified <code class="literal">var</code> names (<code class="literal">clojure.core/test</code>, <code class="literal">user/positive</code>, <code class="literal">user/negative</code>). This is something that you'll be grateful for in the future, but you don't need this for now.</p><p>What you need are the values of test, positive, and negative. How can you get them in this macro?</p><p>Using syntax quotes, you can ask for something to be evaluated inline with the unquote operator, like this:</p><div class="informalexample"><pre class="programlisting">(defmacro my-if [test positive negative]
(if ~test ~positive ~negative))</pre></div><p>Let's try our macro expansion again and see what we get:</p><div class="mediaobject"><img alt="Quote, syntax quote, and unquoting" src="graphics/B04289_07_03.jpg"/></div></div><div class="section" title="Unquote splicing"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Unquote splicing</h2></div></div></div><p>There <a class="indexterm" id="id281"/>are some other cases that become common in macros. Let's imagine we want to reimplement the <code class="literal">&gt;</code> function as a macro and retain the ability to compare several numbers; what would that look like?</p><p>Maybe a first attempt could be something like this:</p><div class="informalexample"><pre class="programlisting">(defmacro&gt;-macro [&amp;params]
  '(&gt; ~params))

(macroexpand'(&gt;-macro 5 4 3))</pre></div><p>The output <a class="indexterm" id="id282"/>of the preceding code is as follows:</p><div class="mediaobject"><img alt="Unquote splicing" src="graphics/B04289_07_04.jpg"/></div><p>Do you see the problem here?</p><p>The problem is that we are trying to pass a list of values to <code class="literal">clojure.core/&gt;</code> instead of passing the values themselves.</p><p>This is easily solved with something called <a class="indexterm" id="id283"/>
<span class="strong"><strong>unquote splicing</strong></span>. Unquote splicing takes a vector or list of parameters and expands it as if you had used the <code class="literal">as</code> parameter on a function or macro.</p><p>It works like this:</p><div class="informalexample"><pre class="programlisting">(defmacro&gt;-macro [&amp;params]
  '(&gt; ~@params)) ;; In the end this works as if you had written
                 ;; (&gt; 5 4 3)

(macroexpand'(&gt;-macro 5 4 3))</pre></div><p>The output of the preceding code is as follows:</p><div class="mediaobject"><img alt="Unquote splicing" src="graphics/B04289_07_05.jpg"/></div><p>You will <a class="indexterm" id="id284"/>use unquote splicing almost every time you have a variable number of arguments to a macro.</p></div><div class="section" title="gensym"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec50"/>gensym</h2></div></div></div><p>Generating code<a class="indexterm" id="id285"/> can be troublesome, and we end up discovering common issues.</p><p>See if you can find the issue in the following code:</p><div class="informalexample"><pre class="programlisting">(def a-var"hello world")

(defmacro error-macro [&amp;params]
  '(let [a-var"bye world"]
     (println a-var)))

;; (macroexpand-1 '(error-macro))
;; (clojure.core/let [user/a-var user/"bye user/world"] (clojure.core/println user/a-var))</pre></div><p>This is a common issue when generating code. You overwrite another value, Clojure doesn't even let you run this, and it displays something like the following screenshot:</p><div class="mediaobject"><img alt="gensym" src="graphics/B04289_07_06.jpg"/></div><p>But don't worry; there's another way in which you can make sure you are not messing with your environment, which is the <code class="literal">gensym</code> function:</p><div class="informalexample"><pre class="programlisting">(defmacro error-macro [&amp;params]
  (let [a-var-name (gensym'a-var)]
    `(let [~a-var-name "bye world"]
       (println ~a-var-name))))</pre></div><p>The <a class="indexterm" id="id286"/>
<code class="literal">gensym</code> function creates a new <code class="literal">var-name</code> each time the macro is run, which guarantees that there is no other <code class="literal">var-name</code> that it obscures. If you try the macro expansion now, you will get this:</p><div class="informalexample"><pre class="programlisting">(clojure.core/let [a-var922"bye world"] (clojure.core/println a-var922))</pre></div><p>The following screenshot is the result of the preceding code:</p><div class="mediaobject"><img alt="gensym" src="graphics/B04289_07_07.jpg"/></div></div></div>
<div class="section" title="Macros in the real world"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Macros in the real world</h1></div></div></div><p>Do you want to <a class="indexterm" id="id287"/>know when it is that macros are used extensively? Think about <code class="literal">defn</code>; what's more, do this:</p><div class="informalexample"><pre class="programlisting">(macroexpand-1 '(defn sample [a] (println a)))

;; (def sample (clojure.core/fn ([a] (println a))))</pre></div><p>Did you know that <code class="literal">defn</code> is a macro in <code class="literal">clojure.core</code> that creates a function and binds it to a <code class="literal">var</code> in the current namespace?</p><p>Clojure is filled with macros; if you want some samples, you can look at Clojure core, but what else can you do with macros?</p><p>Let's have a <a class="indexterm" id="id288"/>look at some interesting libraries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">yesql</code>: The <a class="indexterm" id="id289"/><code class="literal">yesql</code> library is a very interesting sample of code generation. It reads SQL code from a SQL file and generates the Clojure functions accordingly. Look for the <code class="literal">defquery</code> and <code class="literal">defqueries</code> macros in the <code class="literal">yesql</code> project on GitHub; it can be very enlightening.</li><li class="listitem" style="list-style-type: disc"><code class="literal">core.async</code>: If you are familiar with the <code class="literal">go</code> language and <code class="literal">goroutines</code>, you would probably like to have that same functionality in the Clojure language. This isn't necessary since you could have provided them yourself! The <code class="literal">core.async</code> library is<a class="indexterm" id="id290"/> just <code class="literal">goroutines</code> for Clojure, and it is provided as a library (no obscure language change is needed). This shows a great example of the power of macros.</li><li class="listitem" style="list-style-type: disc"><code class="literal">core.typed</code>: With macros, you can even change the dynamic nature of Lisp. The <code class="literal">core.typed</code> library is<a class="indexterm" id="id291"/> an effort that allows you to define type constraints for your Clojure code; macros are extensively used here to generate boilerplate code and checks. This is probably much more complex.</li></ul></div></div>
<div class="section" title="References"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>References</h1></div></div></div><p>If you need further references, you can look at the following list. There are entire books committed to the<a class="indexterm" id="id292"/> topic of macros. I recommend two in particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mastering Clojure Macros (<a class="ulink" href="https://pragprog.com/book/cjclojure/">https://pragprog.com/book/cjclojure/</a>).</li><li class="listitem" style="list-style-type: disc">Let over <a class="indexterm" id="id293"/>Lambda (<a class="ulink" href="http://letoverlambda.com/">http://letoverlambda.com/</a>).It talks about common Lisp, but the knowledge is very valuable.</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Summary</h1></div></div></div><p>You now understand the power of macros and have a very strong grasp of how they work, but we just touched the tip of the iceberg when it comes to macros.</p><p>In this chapter, we learned about the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Fundamentals of how macros work</li><li class="listitem" style="list-style-type: disc">Modifying your code in Groovy</li><li class="listitem" style="list-style-type: disc">The relation of macros to other tools in the Java world</li><li class="listitem" style="list-style-type: disc">Writing your own macros</li></ul></div><p>I am sure you've enjoyed working with Clojure so far, and moving forward, I'd recommend you to keep reading and exploring this amazing language.</p></div></body></html>