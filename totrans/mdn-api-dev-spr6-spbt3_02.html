<html><head></head><body>
<div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.2.1">Spring Concepts and REST APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about the REST architecture style. </span><span class="koboSpan" id="kobo.3.2">Before we go and implement RESTful web services using Spring and Spring Boot, we need to have a proper understanding of the basic Spring concepts. </span><span class="koboSpan" id="kobo.3.3">In this chapter, you will learn about the Spring fundamentals and features that are required to implement RESTful web services using the Spring Framework. </span><span class="koboSpan" id="kobo.3.4">This will provide the technical perspective required for developing the example e-commerce app. </span><span class="koboSpan" id="kobo.3.5">If you are already aware of the Spring fundamentals required for implementing RESTful APIs, you can move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We’ll cover the following topics as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">to Spring</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Understanding the basic concepts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Spring Framework</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Working with the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">servlet dispatcher</span></span></li>
</ul>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">This chapter covers concepts and does not involve writing actual code. </span><span class="koboSpan" id="kobo.14.2">However, you’ll need basic </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Java knowledge.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Please visit the following link to download the code </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">files: </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter02"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter02</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.20.1">Understanding the patterns and paradigms of Spring</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Spring</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.22.1"> is a framework written in the Java language. </span><span class="koboSpan" id="kobo.22.2">It provides lots of modules, such as Spring Data, Spring Security, Spring Cloud, Spring Web, and so on. </span><span class="koboSpan" id="kobo.22.3">It is popular for building enterprise applications. </span><span class="koboSpan" id="kobo.22.4">Initially, it was looked at as a </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Java Enterprise Edition</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">JEE</span></strong><span class="koboSpan" id="kobo.26.1">) alternative. </span><span class="koboSpan" id="kobo.26.2">However, over the years, it</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.27.1"> has become</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.28.1"> preferred over JEE. </span><span class="koboSpan" id="kobo.28.2">Spring supports </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">dependency injection</span></strong><span class="koboSpan" id="kobo.30.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.31.1">DI</span></strong><span class="koboSpan" id="kobo.32.1">), also known as </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">inversion of control</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.35.1">IoC</span></strong><span class="koboSpan" id="kobo.36.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">aspect-oriented programming</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">AOP</span></strong><span class="koboSpan" id="kobo.40.1">) out of the box at its core. </span><span class="koboSpan" id="kobo.40.2">Apart from Java, Spring also supports</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.41.1"> other JVM languages</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.42.1"> such as Groovy </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">and Kotlin.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">With the introduction of Spring Boot, the turnaround time for the development of web services was reduced. </span><span class="koboSpan" id="kobo.44.2">We can hit the ground running. </span><span class="koboSpan" id="kobo.44.3">This is huge and one of the reasons why Spring has become so </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">popular lately.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Covering Spring fundamentals itself requires a dedicated book. </span><span class="koboSpan" id="kobo.46.2">I’ll try to be concise and cover all the features required for you to go ahead and grasp the required knowledge of REST implementation in a </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">granular way.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">However, before we proceed, we should understand the principles and design patterns that form Spring’s foundations, particularly IoC, DI, </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and AOP.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.50.1">What is IoC?</span></h2>
<p><span class="koboSpan" id="kobo.51.1">Traditional CLI programs</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.52.1"> are the typical method for implementations of procedural programming, where the flow is determined by the programmer and the code runs sequentially, meaning one piece after another. </span><span class="koboSpan" id="kobo.52.2">However, UI-based OS applications determine the flow of programs based on user inputs and events, which </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">are dynamic.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Long ago, when mostly procedural ways of programming were dominant, you would have to look for a way to move the control of flow from the traditional procedural way (where the programmer dictates the flow) to external sources such as a framework or components that determined the control flow of the program. </span><span class="koboSpan" id="kobo.54.2">This movement is what is called IoC. </span><span class="koboSpan" id="kobo.54.3">It is a very generic principle and part of </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">most frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">With the arrival of the </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">OOP</span></strong><span class="koboSpan" id="kobo.60.1">) approach, frameworks soon began</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.61.1"> to offer the IoC container pattern implementation, which </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">supports DI.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.63.1">What is DI?</span></h2>
<p><span class="koboSpan" id="kobo.64.1">Let’s say you are writing</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.65.1"> a program that needs to get some data from a database. </span><span class="koboSpan" id="kobo.65.2">The program therefore requires a database connection. </span><span class="koboSpan" id="kobo.65.3">You could use the JDBC database connection object, instantiating and assigning the database connection object instantly in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the program.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Or you could simply take the connection object as a constructor or a setter/factory method parameter. </span><span class="koboSpan" id="kobo.67.2">Then, the framework will create the connection object per the configuration and assign that object to your program at runtime. </span><span class="koboSpan" id="kobo.67.3">Here, the framework essentially injects the connection object at runtime. </span><span class="koboSpan" id="kobo.67.4">This is called DI. </span><span class="koboSpan" id="kobo.67.5">Spring supports DI for </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">class compositions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.69.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.70.1">The Spring Framework throws an error at runtime if any dependency is unavailable, or if the proper object name is not marked when more than one type of object is available. </span><span class="koboSpan" id="kobo.70.2">In contrast, there are some frameworks that also check these dependencies at compile time, such as Dagger, </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">DI is a type of IoC. </span><span class="koboSpan" id="kobo.72.2">IoC containers construct and maintain implementation objects. </span><span class="koboSpan" id="kobo.72.3">These types of objects (objects required by other objects – a form of dependency) are injected into objects that need them in a constructor, setter, or interface. </span><span class="koboSpan" id="kobo.72.4">This decouples the instantiation and allows DI at runtime. </span><span class="koboSpan" id="kobo.72.5">DI can also be achieved using the Service Locator pattern. </span><span class="koboSpan" id="kobo.72.6">However, we’ll stick to the IoC</span><a id="_idIndexMarker067"/> <span class="No-Break"><span class="koboSpan" id="kobo.73.1">pattern approach.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">We’ll look at IoC more closely with a code example in the following main section of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">this chapter.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.76.1">What is AOP?</span></h2>
<p><span class="koboSpan" id="kobo.77.1">AOP is a programming</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.78.1"> paradigm that works in tandem with OOP. </span><span class="koboSpan" id="kobo.78.2">It’s a good practice in OOP to handle</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.79.1"> only a single responsibility in a particular class – this principle is called the </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">single-responsibility</span></strong><strong class="bold"><span class="koboSpan" id="kobo.81.1"> principle</span></strong><span class="koboSpan" id="kobo.82.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.83.1">SRP</span></strong><span class="koboSpan" id="kobo.84.1">), which is applicable to modules/classes/methods. </span><span class="koboSpan" id="kobo.84.2">For example, if you are writing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Gear</span></strong><span class="koboSpan" id="kobo.86.1"> class in an application for the automotive domain, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Gear</span></strong><span class="koboSpan" id="kobo.88.1"> class should only allow functions related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">gear</span></strong><span class="koboSpan" id="kobo.90.1"> object, or it should not be allowed to perform other functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">braking</span></strong><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">However, in programming models, you often need a feature/function that extends across more than one class. </span><span class="koboSpan" id="kobo.92.3">In fact, in some applications, most classes use features such as logging </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">or metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Features such as logging, security, transaction management, and metrics are required across multiple classes/modules. </span><span class="koboSpan" id="kobo.94.2">The code of these features is also scattered across multiple classes. </span><span class="koboSpan" id="kobo.94.3">In OOP, there is no way to abstract and encapsulate such features. </span><span class="koboSpan" id="kobo.94.4">This is where AOP comes to the rescue. </span><span class="koboSpan" id="kobo.94.5">These features (read: aspects) are cross-cutting concerns that range across multiple points in the object model. </span><span class="koboSpan" id="kobo.94.6">AOP provides a way to let you handle these aspects across </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">multiple classes/modules.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">AOP allows you to do </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.98.1">Abstract and encapsulate </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">cross-cutting concerns.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">Add aspects’ behavior around </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">your code.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Make the code for cross-cutting concerns modular to allow us to easily maintain and </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">extend it.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">Focus on your business logic inside the code. </span><span class="koboSpan" id="kobo.104.2">This makes code clean. </span><span class="koboSpan" id="kobo.104.3">Cross-cutting concerns are encapsulated and </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">maintained separately.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.106.1">Without AOP, it is very difficult and complex to achieve all the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">preceding points.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">This section should have helped you to understand IoC, DI, and AOP conceptually. </span><span class="koboSpan" id="kobo.108.2">Throughout the rest of this chapter, we’ll take a deep dive into the code implementation of these patterns</span><a id="_idIndexMarker070"/> <span class="No-Break"><span class="koboSpan" id="kobo.109.1">and paradigms.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Now, we will go through the fundamentals of the Spring Framework and its basic </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">building blocks.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.112.1">Understanding the application of IoC containers</span></h1>
<p><span class="koboSpan" id="kobo.113.1">The Spring Framework’s backbone</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.114.1"> is the IoC container that is responsible for a bean’s life cycle. </span><span class="koboSpan" id="kobo.114.2">In the Spring</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.115.1"> world, a Java object can be a </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">bean</span></strong><span class="koboSpan" id="kobo.117.1"> if it is instantiated, assembled, and managed by the IoC container. </span><span class="koboSpan" id="kobo.117.2">You create a great number of beans, or objects, for your application. </span><span class="koboSpan" id="kobo.117.3">A bean may have dependencies that require other objects to work. </span><span class="koboSpan" id="kobo.117.4">The IoC container is responsible for injecting the object’s dependencies when it creates that bean. </span><span class="koboSpan" id="kobo.117.5">In the Spring context, IoC is also known </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">as DI.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.119.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.120.1">You can refer to the</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.121.1"> Spring documentation (</span><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/"><span class="koboSpan" id="kobo.122.1">https://docs.spring.io/spring-framework/docs/current/reference/html/</span></a><span class="koboSpan" id="kobo.123.1">) for more information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">Spring Framework.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">The Spring</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.126.1"> Framework’s IoC container</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.127.1"> core is defined in two packages: </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">org.springframework.beans</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.129.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">org.springframework.context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.132.1">BeanFactory</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">org.springframework.beans.factory.BeanFactory</span></strong><span class="koboSpan" id="kobo.135.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">ApplicationContext </span></strong><span class="koboSpan" id="kobo.137.1">(</span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">org.springframework.context.ApplicationContext</span></strong><span class="koboSpan" id="kobo.139.1">) are two important interfaces that provide the basis for IoC containers. </span><em class="italic"><span class="koboSpan" id="kobo.140.1">BeanFactory</span></em><span class="koboSpan" id="kobo.141.1"> provides the configuration framework and basic functionality and takes care of bean instantiation </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">and wiring.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.143.1">ApplicationContext</span></em><span class="koboSpan" id="kobo.144.1"> can also take care of bean instantiation</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.145.1"> and wiring. </span><span class="koboSpan" id="kobo.145.2">However, it primarily</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.146.1"> provides more enterprise-specific functionalities, </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.148.1">Integrated life </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">cycle management</span></span></li>
<li><span class="koboSpan" id="kobo.150.1">Automatic registration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">BeanPostProcessor</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.152.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">BeanFactoryPostProcessor</span></strong></span></li>
<li><span class="koboSpan" id="kobo.154.1">Internationalization (message resource handling) with easy access </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">MessageSource</span></strong></span></li>
<li><span class="koboSpan" id="kobo.157.1">Event publication using a </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">built-in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">ApplicationEvent</span></strong></span></li>
<li><span class="koboSpan" id="kobo.160.1">Provision of </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">WebApplicationContext</span></strong><span class="koboSpan" id="kobo.162.1">, an application-layer-specific context for </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">web applications</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.165.1"> is a sub-interface of </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">BeanFactory</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">Let’s look at its </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">class signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
 public interface </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.171.1"> extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,MessageSource, ApplicationEventPublisher, ResourcePatternResolver {…}</span></pre> <p><span class="koboSpan" id="kobo.172.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">ListableBeanFactory</span></strong><span class="koboSpan" id="kobo.174.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">HierarchicalBeanFactory</span></strong><span class="koboSpan" id="kobo.176.1"> are sub-interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">BeanFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Spring recommends the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.182.1"> due to these additional features as well as its state-of-the-art bean </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">management functionalities.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Now you know that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.186.1"> interface represents the IoC container and manages</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.187.1"> the beans, but you must be wondering how it determines which beans to instantiate, assemble, and configure. </span><span class="koboSpan" id="kobo.187.2">Where does it get its instructions? </span><span class="koboSpan" id="kobo.187.3">The answer is configuration metadata. </span><span class="koboSpan" id="kobo.187.4">Configuration metadata allows you to express your application objects and the interdependencies among those objects. </span><span class="koboSpan" id="kobo.187.5">Configuration metadata can be represented in three ways: through XML configuration, Java annotations, and Java code. </span><span class="koboSpan" id="kobo.187.6">You write the business objects and provide the configuration metadata, and the Spring container generates a fully configured, ready-to-use system as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.189.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.191.1"><img alt="Figure 2.1 – Spring ﻿container" src="image/Figure_02.1_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">Figure 2.1 – Spring container</span></p>
<p><span class="koboSpan" id="kobo.193.1">Now that you have some understanding</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.194.1"> of how beans are managed, let’s learn more about what a bean is and what it </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">can do.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.196.1">Defining a bean and its scope</span></h1>
<p><span class="koboSpan" id="kobo.197.1">Beans are Java objects</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.198.1"> that are managed by the IoC containers. </span><span class="koboSpan" id="kobo.198.2">The developer supplies the configuration metadata to an IoC container, which then uses the metadata to construct, assemble, and manage the beans. </span><span class="koboSpan" id="kobo.198.3">Each bean should have a unique identifier inside a container. </span><span class="koboSpan" id="kobo.198.4">A bean</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.199.1"> can even have more than one identity using </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">an </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.201.1">alias</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">You can define beans</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.204.1"> using XML, Java, and annotations. </span><span class="koboSpan" id="kobo.204.2">Let’s declare a simple bean using a </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">Java-based configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
public class SampleBean {  public void init() { // initialization logic }
  public void destroy() { // destruction logic }
  // bean code
}
public interface BeanInterface {
  // interface code
}
public class BeanInterfaceImpl implements BeanInterface
                {
  // bean code
}
</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">@Configuration</span></strong><span class="koboSpan" id="kobo.208.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">AppConfig</span></strong><span class="koboSpan" id="kobo.210.1"> {
  </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">@Bean</span></strong><span class="koboSpan" id="kobo.212.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.213.1">initMethod</span></strong><span class="koboSpan" id="kobo.214.1"> = "init", </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">destroyMethod</span></strong><span class="koboSpan" id="kobo.216.1"> = "destroy",
    </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">name = {"sampleBean", "sb"}"</span></strong><span class="koboSpan" id="kobo.218.1">)
  </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">@Description</span></strong><span class="koboSpan" id="kobo.220.1">("Demonstrate a simple bean")
  public SampleBean sampleBean() {
    return new SampleBean();
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">@Bean</span></strong><span class="koboSpan" id="kobo.222.1">
  public BeanInterface beanInterface() {
    return new BeanInterfaceImpl();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.223.1">In the preceding code, the bean</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.224.1"> is declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">AppConfig</span></strong><span class="koboSpan" id="kobo.226.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">@Configuration</span></strong><span class="koboSpan" id="kobo.228.1"> is a class-level annotation that indicates that the class contains code for configuration. </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">@Bean</span></strong><span class="koboSpan" id="kobo.230.1"> is a method-level annotation used to define the bean. </span><span class="koboSpan" id="kobo.230.2">You can also pass the bean’s initialization and destruction life cycle method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">@Bean</span></strong><span class="koboSpan" id="kobo.232.1"> annotation attributes as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">preceding code.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">In general, a bean’s name is a class name with its initial letter in lowercase. </span><span class="koboSpan" id="kobo.234.2">For example, the bean name of </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">BeanInterface</span></strong><span class="koboSpan" id="kobo.236.1"> would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">beanInterface</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">However, you can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">name</span></strong><span class="koboSpan" id="kobo.240.1"> attribute to define a bean name and its aliases – as we can see in the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">SampleBean</span></strong><span class="koboSpan" id="kobo.242.1"> has two bean names: </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">sampleBean</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.244.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">sb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.247.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.248.1">The default methods for destructions are close/shutdown public methods, which are called by the container automatically. </span><span class="koboSpan" id="kobo.248.2">However, if you wish to follow a different method, you can use the preceding code. </span><span class="koboSpan" id="kobo.248.3">If you don’t want the container to call the default destruction method, you can assign an empty string to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">destroyMethod</span></strong><span class="koboSpan" id="kobo.250.1"> attribute (</span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">destroyMethod = ""</span></strong><span class="koboSpan" id="kobo.252.1">).</span></p>
<p><span class="koboSpan" id="kobo.253.1">You can also create a bean using the interfaces shown in the previous code for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">BeanInterface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1"> bean.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">@Bean</span></strong><span class="koboSpan" id="kobo.258.1"> annotation should be inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">@Component</span></strong><span class="koboSpan" id="kobo.260.1"> annotation. </span><span class="koboSpan" id="kobo.260.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">@Component</span></strong><span class="koboSpan" id="kobo.262.1"> annotation is a generic way to declare a bean. </span><span class="koboSpan" id="kobo.262.2">A class annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">@Configuration</span></strong><span class="koboSpan" id="kobo.264.1"> lets the method return a bean annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">@bean</span></strong><span class="koboSpan" id="kobo.266.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">@Configuration</span></strong><span class="koboSpan" id="kobo.268.1"> is meta-annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">@Component</span></strong><span class="koboSpan" id="kobo.270.1">; therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">@Bean</span></strong><span class="koboSpan" id="kobo.272.1"> annotation works inside it. </span><span class="koboSpan" id="kobo.272.2">There are other annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">@Controller</span></strong><span class="koboSpan" id="kobo.274.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">@Service</span></strong><span class="koboSpan" id="kobo.276.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">@Repository</span></strong><span class="koboSpan" id="kobo.278.1">, which are also annotated </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">@Component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">@Description</span></strong><span class="koboSpan" id="kobo.284.1"> annotation, as the name suggests, is used to describe a bean. </span><span class="koboSpan" id="kobo.284.2">When monitoring tools are used, these descriptions</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.285.1"> help us to understand the beans </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">at runtime.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.287.1">The @ComponentScan annotation</span></h2>
<p><span class="koboSpan" id="kobo.288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">@ComponentScan</span></strong><span class="koboSpan" id="kobo.290.1"> annotation allows the auto-scanning</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.291.1"> of beans. </span><span class="koboSpan" id="kobo.291.2">It takes a few arguments, such as base packages and their classes. </span><span class="koboSpan" id="kobo.291.3">The Spring container then investigates all the classes inside the base package and looks for beans. </span><span class="koboSpan" id="kobo.291.4">It scans all classes annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">@Component</span></strong><span class="koboSpan" id="kobo.293.1">, or other annotations that are meta-annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">@Component</span></strong><span class="koboSpan" id="kobo.295.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">@Configuration</span></strong><span class="koboSpan" id="kobo.297.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">@Controller</span></strong><span class="koboSpan" id="kobo.299.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">By default, Spring Boot takes the default base package from the class, which has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">@ComponentClass</span></strong><span class="koboSpan" id="kobo.303.1"> annotation. </span><span class="koboSpan" id="kobo.303.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">basePackageClasses</span></strong><span class="koboSpan" id="kobo.305.1"> attribute to identify which packages should </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">be scanned.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Another way to scan more than two packages is by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">basePackages</span></strong><span class="koboSpan" id="kobo.309.1"> attribute. </span><span class="koboSpan" id="kobo.309.2">It allows you to scan more than </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">one package.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">If you want to use more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">@ComponentScan</span></strong><span class="koboSpan" id="kobo.313.1">, then you can wrap them inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">@ComponentScans</span></strong><span class="koboSpan" id="kobo.315.1"> annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
@Configuration</span><strong class="bold"><span class="koboSpan" id="kobo.318.1">@ComponentScans</span></strong><span class="koboSpan" id="kobo.319.1">({
  </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">@ComponentScan</span></strong><span class="koboSpan" id="kobo.321.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.322.1">basePackages</span></strong><span class="koboSpan" id="kobo.323.1"> = "com.packt.modern.api"),
  </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">@ComponentScan</span></strong><span class="koboSpan" id="kobo.325.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.326.1">basePackageClasses</span></strong><span class="koboSpan" id="kobo.327.1"> = AppConfig.class)
})
class AppConfig { //code }</span></pre>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.328.1">The bean’s scope</span></h2>
<p><span class="koboSpan" id="kobo.329.1">Spring containers</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.330.1"> are responsible for creating a bean’s instances. </span><span class="koboSpan" id="kobo.330.2">How instances will be created by the Spring container is defined by the scope. </span><span class="koboSpan" id="kobo.330.3">The default scope is singleton, where only one instance will be created per IoC container, and the same instance will be injected. </span><span class="koboSpan" id="kobo.330.4">If you want to create a new instance each time it is requested, you can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">prototype</span></strong><span class="koboSpan" id="kobo.332.1"> scope for </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the bean.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">singleton</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">prototype</span></strong><span class="koboSpan" id="kobo.338.1"> scopes are available for all Spring-based applications. </span><span class="koboSpan" id="kobo.338.2">There are four more scopes available for web applications: </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">request</span></strong><span class="koboSpan" id="kobo.340.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">session</span></strong><span class="koboSpan" id="kobo.342.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">application</span></strong><span class="koboSpan" id="kobo.344.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">websocket</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">For these last four scopes, the application context should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">web-aware</span></strong><span class="koboSpan" id="kobo.348.1">, as Spring Boot-based web applications </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">are web-aware.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">The following table contains all </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">the scopes:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.352.1">Scope</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.353.1">Usage</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">singleton</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.355.1">Creates a new instance per IoC container. </span><span class="koboSpan" id="kobo.355.2">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">default scope.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">prototype</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.358.1">Creates a new instance for each injection (for </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">collaborated beans).</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">request</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><em class="italic"><span class="koboSpan" id="kobo.361.1">Only for web-aware context</span></em><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">A single bean instance will be created for each HTTP request and will be valid throughout the HTTP request </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">life cycle.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">session</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><em class="italic"><span class="koboSpan" id="kobo.365.1">Only for web-aware context</span></em><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">A single bean instance will be created for each HTTP session and will be valid throughout the HTTP session </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">life cycle.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">application</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><em class="italic"><span class="koboSpan" id="kobo.369.1">Only for web-aware context</span></em><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">A single instance will be created for the application scope, and be valid throughout the life cycle </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">of servlet-context.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">websocket</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><em class="italic"><span class="koboSpan" id="kobo.373.1">Only for web-aware context</span></em><span class="koboSpan" id="kobo.374.1">. </span><span class="koboSpan" id="kobo.374.2">A single instance will be created for each </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">WebSocket session.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.376.1">Let’s see how we can define</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.377.1"> the singleton and prototype scopes </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">in code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
@Configurationpublic class AppConfig {
  // no scope is defined so default singleton
  // scope is applied.
</span><span class="koboSpan" id="kobo.379.2">  // If you want to define it explicitly, you can
  // do that using
  // </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">@Scope</span></strong><span class="koboSpan" id="kobo.381.1">(value =
      ConfigurableBeanFactory.</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">SCOPE_SINGLETON</span></strong><span class="koboSpan" id="kobo.383.1">)
  // OR
  // </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">@Scope</span></strong><span class="koboSpan" id="kobo.385.1">(ConfigurableBeanFactory.SCOPE_SINGLETON)
  // Here,
  // ConfigurableBeanFactory.SCOPE_SINGLETON
  // is a string constant with value "singleton".
</span><span class="koboSpan" id="kobo.385.2">  @Bean
  public SingletonBean singletonBean() {
    return new SingletonBean();
  }
  @Bean
  @Scope(</span><strong class="bold"><span class="koboSpan" id="kobo.386.1">ConfigurableBeanFactory</span></strong><span class="koboSpan" id="kobo.387.1">.</span><strong class="bold"><span class="koboSpan" id="kobo.388.1">SCOPE_PROTOTYPE</span></strong><span class="koboSpan" id="kobo.389.1">)
  public PrototypeBean prototypeBean() {
    return new PrototypeBean();
  }
  @Bean
  </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">@Scope</span></strong><span class="koboSpan" id="kobo.391.1">(value =
       </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">WebApplicationContext</span></strong><span class="koboSpan" id="kobo.393.1">.</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">SCOPE_REQUEST</span></strong><span class="koboSpan" id="kobo.395.1">,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
  // You need a proxyMode attribute because when
  // web-aware context is instantiated,
  // you don't have any HTTP request.
</span><span class="koboSpan" id="kobo.395.2">  // Therefore, Spring injects the proxy as a
  // dependency and instantiates the bean when the
  // HTTP request is invoked. </span><span class="koboSpan" id="kobo.395.3">OR, in short you
  // can simply write @RequestScope, a shortcut
  </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">@RequestScope</span></strong><span class="koboSpan" id="kobo.397.1">
  public ReqScopedBean requestScopedBean() {
    return new ReqScopedBean();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.398.1">Similarly, you can create</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.399.1"> a web-aware context-related bean </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
@Configurationpublic class AppConfig {
  @Bean
  </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">@Scope</span></strong><span class="koboSpan" id="kobo.403.1">(value =
     WebApplicationContext.</span><strong class="bold"><span class="koboSpan" id="kobo.404.1">SCOPE_REQUEST</span></strong><span class="koboSpan" id="kobo.405.1">,
     proxyMode = ScopedProxyMode.TARGET_CLASS)
  // You need a proxyMode attribute because when
  // web-aware context is instantiated, you
  // don't have any HTTP request. </span><span class="koboSpan" id="kobo.405.2">Therefore,
  // Spring injects the proxy as a dependency and
  // instantiate the bean when HTTP request is
  // invoked. </span><span class="koboSpan" id="kobo.405.3">OR, in short you can annotate with
  // @SessionScope, a shortcut for above
  </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">@SessionScope</span></strong><span class="koboSpan" id="kobo.407.1">
  public ReqScopedBean requestScopedBean() {
    return new ReqScopedBean();
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">@ApplicationScope</span></strong><span class="koboSpan" id="kobo.409.1">
  public ReqScopedBean requestScopedBean() {
    return new ReqScopedBean();
  }
  // here "scopeName" is alias for value
  // interestingly, no shortcut. </span><span class="koboSpan" id="kobo.409.2">Also hard coded
  // value for websocket
  </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">@Scope</span></strong><span class="koboSpan" id="kobo.411.1">(scopeName = "websocket",
      proxyMode = ScopedProxyMode.TARGET_CLASS)
  public ReqScopedBean requestScopedBean() {
    return new ReqScopedBean();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.412.1">We have now succinctly covered beans</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.413.1"> here. </span><span class="koboSpan" id="kobo.413.2">However, you can explore more on this topic in the official Spring documentation (</span><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition"><span class="koboSpan" id="kobo.414.1">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition</span></a><span class="koboSpan" id="kobo.415.1">). </span><span class="koboSpan" id="kobo.415.2">For now, let us move on and start learning</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.416.1"> how to </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">configure beans.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.418.1">Configuring beans using Java</span></h1>
<p><span class="koboSpan" id="kobo.419.1">Before Spring 3, you could only define</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.420.1"> beans using XML. </span><span class="koboSpan" id="kobo.420.2">Spring 3 introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">@Configuration</span></strong><span class="koboSpan" id="kobo.422.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">@Bean</span></strong><span class="koboSpan" id="kobo.424.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">@import</span></strong><span class="koboSpan" id="kobo.426.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">@DependsOn</span></strong><span class="koboSpan" id="kobo.428.1"> annotations to configure and define Spring beans </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">using Java.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">You have already learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">@Configuration</span></strong><span class="koboSpan" id="kobo.432.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">@Bean</span></strong><span class="koboSpan" id="kobo.434.1"> annotations in the </span><em class="italic"><span class="koboSpan" id="kobo.435.1">Defining a bean and its scope</span></em><span class="koboSpan" id="kobo.436.1"> section. </span><span class="koboSpan" id="kobo.436.2">Now, you will explore how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">@Import</span></strong><span class="koboSpan" id="kobo.438.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">DependsOn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> annotations.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">@Import</span></strong><span class="koboSpan" id="kobo.444.1"> annotation is more useful when you develop an application without </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">using autoconfiguration.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.446.1">The @Import annotation</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">@Import</span></strong><span class="koboSpan" id="kobo.448.1"> is used for modularizing</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.449.1"> configurations when you have more than one configuration class. </span><span class="koboSpan" id="kobo.449.2">You can import the bean’s definitions from other configuration classes, and this is useful when you instantiate the context manually. </span><span class="koboSpan" id="kobo.449.3">Spring Boot uses auto-configuration, so you don’t need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">@Import</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">However, you would have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">@Import</span></strong><span class="koboSpan" id="kobo.453.1"> to modularize the configurations if you want to instantiate the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">context manually.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Let’s say the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">FooConfig</span></strong><span class="koboSpan" id="kobo.457.1"> configuration class contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">FooBean</span></strong><span class="koboSpan" id="kobo.459.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">BarConfig</span></strong><span class="koboSpan" id="kobo.461.1"> configuration class contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">BarBean</span></strong><span class="koboSpan" id="kobo.463.1">. </span><span class="koboSpan" id="kobo.463.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">BarConfig</span></strong><span class="koboSpan" id="kobo.465.1"> class also imports </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">FooConfig</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.467.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">@Import</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
@Configurationpublic class FooConfig {
  @Bean
  public FooBean fooBean() {
    return new FooBean();
  }
}
@Configuration
@Import(FooConfig.class)
public class BarConfig {
  @Bean
  public BarBean barBean() {
    return new BarBean();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.471.1">Now, while instantiating the container (context), you can just supply </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">BarConfig</span></strong><span class="koboSpan" id="kobo.473.1"> to load both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">FooBean</span></strong><span class="koboSpan" id="kobo.475.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">BarBean</span></strong><span class="koboSpan" id="kobo.477.1"> definitions</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.478.1"> in the Spring container, shown </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
public static void main(String[] args) {  ApplicationContext appContext = new
     AnnotationConfigApplicationContext(
       BarConfig.class);
  // Get FooBean &amp; BarBean beans from context
  FooBean fooBean =
     appContext.getBean(FooBean.class);
  BarBean barBean =
    appContext.getBean(BarBean.class);
}</span></pre>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.481.1">The @DependsOn annotation</span></h2>
<p><span class="koboSpan" id="kobo.482.1">The Spring container</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.483.1"> manages the bean initialization order. </span><span class="koboSpan" id="kobo.483.2">What if you have a bean that depends on another bean? </span><span class="koboSpan" id="kobo.483.3">You want to make sure that the required bean is initialized before the bean that depends on it. </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">@DependsOn</span></strong><span class="koboSpan" id="kobo.485.1"> helps you to achieve this when you configure beans using Java (not </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">through XML).</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">You will get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">NoSuchBeanDefinitionException</span></strong><span class="koboSpan" id="kobo.489.1"> exception if a bean’s initialization order is messed up and the Spring container fails to find the dependency as </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">a result.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">Let’s assume we have a bean called </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">BazBean</span></strong><span class="koboSpan" id="kobo.493.1"> that depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">FooBean</span></strong><span class="koboSpan" id="kobo.495.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">BarBean</span></strong><span class="koboSpan" id="kobo.497.1"> beans. </span><span class="koboSpan" id="kobo.497.2">You can make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">@DependsOn</span></strong><span class="koboSpan" id="kobo.499.1"> annotation to maintain the initialization order. </span><span class="koboSpan" id="kobo.499.2">The Spring container will follow the instructions and initialize both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">FooBean</span></strong><span class="koboSpan" id="kobo.501.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">BarBean</span></strong><span class="koboSpan" id="kobo.503.1"> beans before creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">BazBean</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">Here’s how</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.506.1"> the code </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">would look:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
@Configurationpublic class AppConfig {
  @Bean
  public FooBean fooBean() {
    return new FooBean();
  }
  @Bean
  public BarBean barBean () {
    return new BarBean ();
  }
  @Bean
  @DependsOn({"fooBean","barBean"})
  public BazBean bazBean (){
    return new BazBean ();
  }
}</span></pre>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.509.1">How to code DI</span></h1>
<p><span class="koboSpan" id="kobo.510.1">Have a look at the following</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.511.1"> example. </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">CartService</span></strong><span class="koboSpan" id="kobo.513.1"> has a dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">CartRepository</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">CartRepository</span></strong><span class="koboSpan" id="kobo.517.1"> instantiation is done inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">CartService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1"> constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
public class CartService {  private CartRepository repository;
  public CartService() {
    this.repository = new CartRepositoryImpl();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.521.1">We can decouple this dependency in the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">following way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
public class CartService {  private CartRepository repository;
  public CartService(CartRepository repository) {
    this.repository = repository;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.524.1">If you create a bean of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">CartRepository</span></strong><span class="koboSpan" id="kobo.526.1"> implementation, you can easily inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">CartRepository</span></strong><span class="koboSpan" id="kobo.528.1"> bean using configuration metadata. </span><span class="koboSpan" id="kobo.528.2">Before that, let’s have a look at the Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">container again.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">You have seen how </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.532.1"> can be initialized in the </span><em class="italic"><span class="koboSpan" id="kobo.533.1">The @Import annotation</span></em><span class="koboSpan" id="kobo.534.1"> subsection of this chapter. </span><span class="koboSpan" id="kobo.534.2">When it gets created, it takes all the metadata from the bean’s configuration. </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">@Import</span></strong><span class="koboSpan" id="kobo.536.1"> allows you to have </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">multiple configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Each bean can have its dependencies, that is, a bean may need other objects to work (compositions), as in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">CartService</span></strong><span class="koboSpan" id="kobo.540.1"> example. </span><span class="koboSpan" id="kobo.540.2">These dependencies can be defined using constructors, setter methods, or properties. </span><span class="koboSpan" id="kobo.540.3">These dependent objects (part of the constructors, setter method arguments, or class properties) are injected by the Spring container (</span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.542.1">) using the bean’s definition and its scope. </span><span class="koboSpan" id="kobo.542.2">We’ll next investigate each of these</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.543.1"> ways to define </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">the DI.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.545.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.546.1">DI virtually makes a class independent of its dependencies. </span><span class="koboSpan" id="kobo.546.2">Therefore, a change in the dependency won’t impact the class (no code change) as long as the interface contract is not broken. </span><span class="koboSpan" id="kobo.546.3">Indeed, you can change the underlying implementation of the dependency or use a different </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">implementation class.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.548.1">Using a constructor to define a dependency</span></h2>
<p><span class="koboSpan" id="kobo.549.1">Now, you’ll see</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.550.1"> how you can</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.551.1"> inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">CartRepository</span></strong><span class="koboSpan" id="kobo.553.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">CartService</span></strong><span class="koboSpan" id="kobo.555.1"> constructor. </span><span class="koboSpan" id="kobo.555.2">A way to inject a dependency using a constructor is </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
@Configurationpublic class AppConfig {
  @Bean
  public CartRepository cartRepository() {
    return new CartRepositoryImpl();
  }
  @Bean
  public CartService cartService() {
    return new CartService(cartRepository());
  }
}</span></pre>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.558.1">Using a setter method to define a dependency</span></h2>
<p><span class="koboSpan" id="kobo.559.1">Now, let’s change</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.560.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">CartService</span></strong><span class="koboSpan" id="kobo.562.1"> class. </span><span class="koboSpan" id="kobo.562.2">Instead of having</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.563.1"> a constructor, use the setter method to instantiate </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">the dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
public class CartService {private CartRepository repository;
  public void setCartRepository(CartRepository repository) {
    this.repository = repository;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.566.1">Now, you can</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.567.1"> use the following configuration to inject</span><a id="_idIndexMarker103"/> <span class="No-Break"><span class="koboSpan" id="kobo.568.1">the dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
@Configurationpublic class AppConfig {
  @Bean
  public CartRepository cartRepository() {
    return new CartRepositoryImpl();
  }
  @Bean
  public CartService cartService() {
    CartService service = new CartService();
    Service.setCartService(cartRepository());
    return service;
  }
}</span></pre>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.570.1">Using a class property to define a dependency</span></h2>
<p><span class="koboSpan" id="kobo.571.1">Spring also provides</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.572.1"> an out-of-the-box solution for injecting</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.573.1"> a dependency using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">@Autowired</span></strong><span class="koboSpan" id="kobo.575.1"> annotation. </span><span class="koboSpan" id="kobo.575.2">It makes code look cleaner. </span><span class="koboSpan" id="kobo.575.3">Have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
@Servicepublic class CartService {
  @Autowired
  private CartRepository repository;
}</span></pre>
<p><span class="koboSpan" id="kobo.578.1">The Spring container</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.579.1"> will take care</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.580.1"> of injecting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">CartRepository</span></strong><span class="koboSpan" id="kobo.582.1"> bean. </span><span class="koboSpan" id="kobo.582.2">You’ll learn more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">@Autowired</span></strong><span class="koboSpan" id="kobo.584.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">next section.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.586.1">Configuring a bean’s metadata using annotations</span></h1>
<p><span class="koboSpan" id="kobo.587.1">The Spring Framework</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.588.1"> provides lots of annotations to configure</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.589.1"> the metadata for beans. </span><span class="koboSpan" id="kobo.589.2">However, we’ll focus on the most used annotations: </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">@Autowired</span></strong><span class="koboSpan" id="kobo.591.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">@Qualifier</span></strong><span class="koboSpan" id="kobo.593.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">@Inject</span></strong><span class="koboSpan" id="kobo.595.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">@Resource</span></strong><span class="koboSpan" id="kobo.597.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">@Primary</span></strong><span class="koboSpan" id="kobo.599.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">@Value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.603.1">How to use @Autowired?</span></h2>
<p><span class="koboSpan" id="kobo.604.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">@Autowired</span></strong><span class="koboSpan" id="kobo.606.1"> annotation allows you</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.607.1"> to define the configuration in a bean’s class itself, instead of writing a separate configuration class annotated </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">@Configuration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">@Autowired</span></strong><span class="koboSpan" id="kobo.613.1"> annotation can be applied to a field (as we saw in the class property-based DI example), constructor, setter, or </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">any method.</span></span></p>
<p><span class="koboSpan" id="kobo.615.1">The Spring container makes use of reflections to inject the beans annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">@Autowired</span></strong><span class="koboSpan" id="kobo.617.1">. </span><span class="koboSpan" id="kobo.617.2">This also makes it more costly than other </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">injection approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Please make a note that applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">@Autowired</span></strong><span class="koboSpan" id="kobo.621.1"> to class members will only work if there is no constructor or setter method to inject the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">dependent bean.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">Here is a code example</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.624.1"> demonstrating the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">@Autowired</span></strong><span class="koboSpan" id="kobo.626.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">inject dependencies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
@Componentpublic class CartService {
  private CartRepository repository;
  private ARepository aRepository;
  private BRepository bRepository;
  private CRepository cRepository;
  </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">@Autowired</span></strong><span class="koboSpan" id="kobo.630.1"> // member(field) based auto wiring
  private AnyBean anyBean;
  </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">@Autowired</span></strong><span class="koboSpan" id="kobo.632.1"> // constructor based autowired
  public CartService(CartRepository repository) {
    this.repository = repository;
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">@Autowired</span></strong><span class="koboSpan" id="kobo.634.1"> // Setter based auto wiring
  public void setARepository(ARepository aRepo) {
   this.aRepository = aRepo;
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">@Autowired</span></strong><span class="koboSpan" id="kobo.636.1"> // method based auto wiring
  public void xMethod(BRepository bRepo, CRepository cRepo) {
   this.bRepository = bRepo;
   this.cRepository = cRepo;
  }
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">@Autowired</span></strong><span class="koboSpan" id="kobo.638.1"> works based on reflection. </span><span class="koboSpan" id="kobo.638.2">However, to remove the ambiguity, matching beans are found and injected using type matching, qualifier matching, or name matching in this order</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.639.1"> of precedence. </span><span class="koboSpan" id="kobo.639.2">These are applicable to both field and setter </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">method injections.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.641.1">Matching by type</span></h2>
<p><span class="koboSpan" id="kobo.642.1">The following example works</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.643.1"> because type matches take precedence. </span><span class="koboSpan" id="kobo.643.2">The code finds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">CartService</span></strong><span class="koboSpan" id="kobo.645.1"> bean and injects it </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">CartController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
@Configurationpublic class AppConfig {
  @Bean
  public CartRepository cartRepository() {
    return new CartRepositoryImpl();
  }
  @Bean
  public CartService cartService() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">CartService service = new CartService();</span></strong><span class="koboSpan" id="kobo.651.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">service.setCartRepository(cartRepository());</span></strong><span class="koboSpan" id="kobo.653.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">return service;</span></strong><span class="koboSpan" id="kobo.655.1">
  }
}
@Controller
public class CartController {
  </span><strong class="bold"><span class="koboSpan" id="kobo.656.1">@Autowired</span></strong><span class="koboSpan" id="kobo.657.1">
  private CartService service;
}</span></pre>
<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.658.1">Matching by qualifier</span></h2>
<p><span class="koboSpan" id="kobo.659.1">Let’s assume</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.660.1"> there is more than one bean of a given type. </span><span class="koboSpan" id="kobo.660.2">As a result, the Spring container won’t be able to determine the correct bean by </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">type matching:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
@Configurationpublic class AppConfig {
  </span><strong class="bold"><span class="koboSpan" id="kobo.663.1">@Bean</span></strong><span class="koboSpan" id="kobo.664.1">
  public CartService cartService1() {
    return new CartServiceImpl1();
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.665.1">@Bean</span></strong><span class="koboSpan" id="kobo.666.1">
  public CartService cartService2() {
    return new CartServiceImpl2();
  }
}
@Controller
public class CartController {
  </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">@Autowired</span></strong><span class="koboSpan" id="kobo.668.1">
  private CartService service1;
  </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">@Autowired</span></strong><span class="koboSpan" id="kobo.670.1">
  private CartService service2;
}</span></pre>
<p><span class="koboSpan" id="kobo.671.1">This example, when run, will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">NoUniqueBeanDefinitionException</span></strong><span class="koboSpan" id="kobo.673.1">. </span><span class="koboSpan" id="kobo.673.2">To sort this out, we can make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Qualifier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">If you look closely, you’ll find that the configuration class has two beans identified by their method names: </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">cartService1</span></strong><span class="koboSpan" id="kobo.679.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">cartService2</span></strong><span class="koboSpan" id="kobo.681.1">. </span><span class="koboSpan" id="kobo.681.2">Or, you can also make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">value</span></strong><span class="koboSpan" id="kobo.683.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">@Bean</span></strong><span class="koboSpan" id="kobo.685.1"> annotation to give it a name/alias. </span><span class="koboSpan" id="kobo.685.2">Now, you can use these names</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.686.1"> to assign the same type to these two different beans using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">@Qualifier</span></strong><span class="koboSpan" id="kobo.688.1"> annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
@Controllerpublic class CartController {
  @Autowired
  </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">@Qualifier("cartService1")</span></strong><span class="koboSpan" id="kobo.692.1">
  private CartService service1;
  @Autowired
  </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">@Qualifier("cartService2")</span></strong><span class="koboSpan" id="kobo.694.1">
  private CartService service2;
}</span></pre>
<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.695.1">Matching by name</span></h2>
<p><span class="koboSpan" id="kobo.696.1">Let’s define a service</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.697.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">@Service</span></strong><span class="koboSpan" id="kobo.699.1"> annotation, which is a specialized type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">@Component</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">Let’s assume we have a component</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.702.1"> scan </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">in place:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
@Service(value="cartServc")public class CartService {
  // code
}
@Controller
public class CartController {
  @Autowired
  private CartService cartServc;
}</span></pre>
<p><span class="koboSpan" id="kobo.705.1">This code works because the field name of </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">CartController</span></strong><span class="koboSpan" id="kobo.707.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">CartService</span></strong><span class="koboSpan" id="kobo.709.1"> is the same as was given to the value attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">@Service</span></strong><span class="koboSpan" id="kobo.711.1"> annotation. </span><span class="koboSpan" id="kobo.711.2">If you change the field name from </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">cartServc</span></strong><span class="koboSpan" id="kobo.713.1"> to something else, it will fail </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">NoUniqueBeanDefinitionException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">There are other annotations: </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">@Inject</span></strong><span class="koboSpan" id="kobo.719.1"> (JSR-330: </span><a href="https://jcp.org/en/jsr/detail?id=330"><span class="koboSpan" id="kobo.720.1">https://jcp.org/en/jsr/detail?id=330</span></a><span class="koboSpan" id="kobo.721.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">@Resource</span></strong><span class="koboSpan" id="kobo.723.1"> (JSR-250: </span><a href="https://jcp.org/en/jsr/detail?id=250"><span class="koboSpan" id="kobo.724.1">https://jcp.org/en/jsr/detail?id=250</span></a><span class="koboSpan" id="kobo.725.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">@Inject</span></strong><span class="koboSpan" id="kobo.727.1"> also requires the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">javax.inject</span></strong><span class="koboSpan" id="kobo.729.1"> library. </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">@Resource</span></strong><span class="koboSpan" id="kobo.731.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">@Inject</span></strong><span class="koboSpan" id="kobo.733.1"> are similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">@Autowired</span></strong><span class="koboSpan" id="kobo.735.1"> and can be used for injecting dependencies. </span><span class="koboSpan" id="kobo.735.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">@Autowired</span></strong><span class="koboSpan" id="kobo.737.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">@Inject</span></strong><span class="koboSpan" id="kobo.739.1"> have the same execution</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.740.1"> path precedence</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.741.1"> (by type, then by qualifier, then by name). </span><span class="koboSpan" id="kobo.741.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">@Resource</span></strong><span class="koboSpan" id="kobo.743.1"> execution path preference</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.744.1"> is by name (the first preference), then by type, and lastly </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">by qualifier.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.746.1">What is the purpose of @Primary?</span></h2>
<p><span class="koboSpan" id="kobo.747.1">In the previous</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.748.1"> subsection, we saw that </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">@Qualifier</span></strong><span class="koboSpan" id="kobo.750.1"> helps you to resolve which type should be used when multiple beans are available for injection. </span><span class="koboSpan" id="kobo.750.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">@Primary</span></strong><span class="koboSpan" id="kobo.752.1"> annotation allows you to set one of the type’s beans as the default. </span><span class="koboSpan" id="kobo.752.2">Bean annotation with </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">@Primary</span></strong><span class="koboSpan" id="kobo.754.1"> will be injected into </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">auto-wired fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
@Configurationpublic class AppConfig {
  @Bean
  </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">@Primary</span></strong><span class="koboSpan" id="kobo.758.1">
  public CartService cartService1() {
    return new CartServiceImpl1();
  }
  @Bean
  public CartService cartService2() {
    return new CartServiceImpl2();
  }
}
@Controller
public class CartController {
  @Autowired
  private CartService service;
}</span></pre>
<p><span class="koboSpan" id="kobo.759.1">In this example, the bean marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">@Primary</span></strong><span class="koboSpan" id="kobo.761.1"> will be used to inject the dependency</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.762.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">CartController</span></strong><span class="koboSpan" id="kobo.764.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">CartService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.768.1">When can we use @Value?</span></h2>
<p><span class="koboSpan" id="kobo.769.1">Spring supports the use</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.770.1"> of external property files via </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">&lt;xyz&gt;.properties</span></strong><span class="koboSpan" id="kobo.772.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">&lt;xyz&gt;.yml</span></strong><span class="koboSpan" id="kobo.774.1">. </span><span class="koboSpan" id="kobo.774.2">Let’s say you want to use the value of any property in your code. </span><span class="koboSpan" id="kobo.774.3">You can achieve this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">@Value</span></strong><span class="koboSpan" id="kobo.776.1"> annotation. </span><span class="koboSpan" id="kobo.776.2">Let’s have a look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">example code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
@Configuration@PropertySource("classpath:application.properties")
public class AppConfig {}
@Controller
public class CartController {
  @Value("${default.currency}")
  String defaultCurrency;
}</span></pre>
<p><span class="koboSpan" id="kobo.779.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">defaultCurrency</span></strong><span class="koboSpan" id="kobo.781.1"> field would take its value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">default.currency</span></strong><span class="koboSpan" id="kobo.783.1"> field defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">application.properties</span></strong><span class="koboSpan" id="kobo.785.1"> file. </span><span class="koboSpan" id="kobo.785.2">If you are using Spring Boot, you don’t need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">@PropertySource</span></strong><span class="koboSpan" id="kobo.787.1">. </span><span class="koboSpan" id="kobo.787.2">You just need to place </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">application.yml</span></strong><span class="koboSpan" id="kobo.789.1"> or the properties file under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">src/main/resources</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">Now that you have</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.793.1"> some idea of how a bean’s metadata can be configured to achieve different results, let us move on to writing some code for AOP, which we introduced conceptually earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">this chapter.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.795.1">Writing code for AOP</span></h1>
<p><span class="koboSpan" id="kobo.796.1">We discussed AOP previously</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.797.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.798.1">Understanding the patterns and paradigms of Spring</span></em><span class="koboSpan" id="kobo.799.1"> section. </span><span class="koboSpan" id="kobo.799.2">In simple terms, AOP is a programming</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.800.1"> paradigm that solves cross-cutting concerns such as logging, transactions, and security. </span><span class="koboSpan" id="kobo.800.2">These cross-cutting concerns are known as </span><em class="italic"><span class="koboSpan" id="kobo.801.1">aspects</span></em><span class="koboSpan" id="kobo.802.1"> in AOP. </span><span class="koboSpan" id="kobo.802.2">They allow you to modularize your code and place cross-cutting concerns in a </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">central location.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">The following code captures the time taken by a method </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">to execute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
class Test  public void performSomeTask() {
    long start = System.currentTimeMillis();
    // Business Logic
    long executionTime =
           System.currentTimeMillis() - start;
    System.out.println("Time taken: " + executionTime + "ms");
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.807.1">Time calculations are used for monitoring performance. </span><span class="koboSpan" id="kobo.807.2">This code captures the execution time (how long the code takes to run). </span><span class="koboSpan" id="kobo.807.3">If you have hundreds of methods in your application, then you need to add a time-capturing piece of code in each one of them to monitor the time taken for their execution. </span><span class="koboSpan" id="kobo.807.4">But what if you later wanted to modify the time-capturing code? </span><span class="koboSpan" id="kobo.807.5">You would have to modify the code in all those places. </span><span class="koboSpan" id="kobo.807.6">You don’t want to do that. </span><span class="koboSpan" id="kobo.807.7">This is where AOP helps you. </span><span class="koboSpan" id="kobo.807.8">It makes your cross-cutting </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">code modular.</span></span></p>
<p><span class="koboSpan" id="kobo.809.1">Let’s create an AOP example for capturing the amount of time a method takes to execute. </span><span class="koboSpan" id="kobo.809.2">Here, logging monitoring time will be our aspect that will capture the amount of time taken by a method for </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">its execution.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">As the first step, you’ll define an annotation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">TimeMonitor</span></strong><span class="koboSpan" id="kobo.813.1">) to target the method. </span><span class="koboSpan" id="kobo.813.2">Methods annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">@TimeMonitor</span></strong><span class="koboSpan" id="kobo.815.1"> will log the time taken by that method. </span><span class="koboSpan" id="kobo.815.2">This will help us to identify the pointcut. </span><span class="koboSpan" id="kobo.815.3">The pointcut is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">Aspect</span></strong><span class="koboSpan" id="kobo.817.1"> class’s </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">code explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)
public @interface </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">TimeMonitor</span></strong><span class="koboSpan" id="kobo.821.1"> {}</span></pre>
<p><span class="koboSpan" id="kobo.822.1">Next, we need</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.823.1"> to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">Aspect</span></strong><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">Aspects insert additional logic during the execution of the program</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.826.1"> at a certain point. </span><span class="koboSpan" id="kobo.826.2">This point is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.827.1">join point</span></strong><span class="koboSpan" id="kobo.828.1">. </span><span class="koboSpan" id="kobo.828.2">The join point could be a field</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.829.1"> being modified, a method being called, or an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">being thrown.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">@Aspect</span></strong><span class="koboSpan" id="kobo.833.1"> annotation is used to mark the class as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">Aspect</span></strong><span class="koboSpan" id="kobo.835.1">. </span><span class="koboSpan" id="kobo.835.2">The time-monitoring aspect has been defined using the </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.837.1">@Aspect</span></strong><span class="koboSpan" id="kobo.838.1">@Component
public class TimeMonitorAspect {
  </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">@Around</span></strong><span class="koboSpan" id="kobo.840.1">("@annotation(TimeMonitor)")
  public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.nanoTime();
    Object proceed = joinPoint.proceed();
    long exeTime = System.nanoTime() - start;
    System.out.println(joinPoint.getSignature()
      .getName() + " took: " + exeTime + " ns");
    return proceed;
  }
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">@Around</span></strong><span class="koboSpan" id="kobo.842.1"> is a method annotation</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.843.1"> that defines </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Advice</span></strong><span class="koboSpan" id="kobo.845.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">Advice</span></strong><span class="koboSpan" id="kobo.847.1"> is an action taken by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Aspect</span></strong><span class="koboSpan" id="kobo.849.1"> at a specific time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Joinpoint</span></strong><span class="koboSpan" id="kobo.851.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">Advice</span></strong><span class="koboSpan" id="kobo.853.1"> could be any of </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">@Before</span></strong><span class="koboSpan" id="kobo.856.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">Advice</span></strong><span class="koboSpan" id="kobo.858.1"> executes before </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">JoinPoint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">After</span></strong><span class="koboSpan" id="kobo.863.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">Advice</span></strong><span class="koboSpan" id="kobo.865.1"> executes after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.867.1">. </span><span class="koboSpan" id="kobo.867.2">It has </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">three subtypes:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">@After</span></strong><span class="koboSpan" id="kobo.870.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">Advice</span></strong><span class="koboSpan" id="kobo.872.1"> executes after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.874.1"> irrespective of the method’s outcome – successful </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">or failed</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">@AfterReturning</span></strong><span class="koboSpan" id="kobo.877.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">Advice</span></strong><span class="koboSpan" id="kobo.879.1"> executes after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">JoinPoint</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.881.1">executes successfully</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">@AfterThrowing</span></strong><span class="koboSpan" id="kobo.883.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">Advice</span></strong><span class="koboSpan" id="kobo.885.1"> executes after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.887.1"> throws </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">an exception</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">@Around</span></strong><span class="koboSpan" id="kobo.890.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Advice</span></strong><span class="koboSpan" id="kobo.892.1"> executes before and after </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">JoinPoint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">.</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">TimeMonitorAspect</span></strong><span class="koboSpan" id="kobo.897.1"> executes at the method level because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">MonitorTime</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Advice</span></strong><span class="koboSpan" id="kobo.900.1"> target is </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">a method.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">@Around</span></strong><span class="koboSpan" id="kobo.903.1"> also takes an expression argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">@annotation(com.packt.modern.api.TimeMonitor)</span></strong><span class="koboSpan" id="kobo.905.1">. </span><span class="koboSpan" id="kobo.905.2">This predicate expression is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.906.1">pointcut</span></strong><span class="koboSpan" id="kobo.907.1">, which determines whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">Advice</span></strong><span class="koboSpan" id="kobo.909.1"> needs to be executed</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.910.1"> or not. </span><span class="koboSpan" id="kobo.910.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">logTime</span></strong><span class="koboSpan" id="kobo.912.1"> method will be executed</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.913.1"> for all the methods annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">@TimeMonitor</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">Spring supports</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.916.1"> the AspectJ expression syntax (</span><a href="https://www.eclipse.org/aspectj/doc/released/quick5.pdf"><span class="koboSpan" id="kobo.917.1">https://www.eclipse.org/aspectj/doc/released/quick5.pdf</span></a><span class="koboSpan" id="kobo.918.1">). </span><span class="koboSpan" id="kobo.918.2">These expressions are dynamic in nature, allowing flexibility while defining </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">the pointcut.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.921.1"> is added as a method </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">logTime()</span></strong><span class="koboSpan" id="kobo.923.1"> parameter. </span><span class="koboSpan" id="kobo.923.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.925.1"> object, you can capture all the information of the target and proxy. </span><span class="koboSpan" id="kobo.925.2">You can capture the method’s full signature, class name, method name, arguments, and so on using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">JoinPoint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.927.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">That’s all we need to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">TimeMonitorAspect</span></strong><span class="koboSpan" id="kobo.930.1">. </span><span class="koboSpan" id="kobo.930.2">Now you can simply add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">@TimeMonitor</span></strong><span class="koboSpan" id="kobo.932.1"> annotation to log the computed time taken by the methods as </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.934.1">
class Test {  @TimeMonitor
  public void performSomeTask() {
    // Business Logic
  }
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.936.1"> also allows you to capture the target object and proxy. </span><span class="koboSpan" id="kobo.936.2">You might be wondering what these are. </span><span class="koboSpan" id="kobo.936.3">These are created by the Spring AOP module and are important for AOP to work. </span><span class="koboSpan" id="kobo.936.4">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Advice</span></strong><span class="koboSpan" id="kobo.938.1"> is applied to the target object. </span><span class="koboSpan" id="kobo.938.2">Spring AOP creates a subclass of the target object and overrides the methods and advice is inserted. </span><span class="koboSpan" id="kobo.938.3">On the other hand, the proxy is an object that is created after some advice is applied to the target object using</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.939.1"> the CGLIB or JDK</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.940.1"> proxy lib. </span><span class="koboSpan" id="kobo.940.2">(CGLIB generates code, and Spring makes use of it for generating the proxy classes and related code. </span><span class="koboSpan" id="kobo.940.3">The JDK proxy lib is also used for generating proxy classes </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">and instances.)</span></span></p>
<p><span class="koboSpan" id="kobo.942.1">Now that we have covered some important concepts in Spring, let us get to know Spring Boot, one of the best tools for developing Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">web applications.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.944.1">Why use Spring Boot?</span></h1>
<p><span class="koboSpan" id="kobo.945.1">Nowadays, Spring Boot</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.946.1"> is the obvious choice for developing state-of-the-art, production-ready</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.947.1"> web applications specific to Spring. </span><span class="koboSpan" id="kobo.947.2">Its website (</span><a href="https://projects.spring.io/spring-boot/"><span class="koboSpan" id="kobo.948.1">https://projects.spring.io/spring-boot/</span></a><span class="koboSpan" id="kobo.949.1">) also outlines its </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">huge advantages.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">Spring Boot is an amazing</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.952.1"> Spring tool created by </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">Pivotal</span></strong><span class="koboSpan" id="kobo.954.1"> that was released for General Availability in April 2014. </span><span class="koboSpan" id="kobo.954.2">It was developed based on the request of SPR-9888 (</span><a href="https://jira.spring.io/browse/SPR-9888"><span class="koboSpan" id="kobo.955.1">https://jira.spring.io/browse/SPR-9888</span></a><span class="koboSpan" id="kobo.956.1">) with the title </span><em class="italic"><span class="koboSpan" id="kobo.957.1">Improved support for containerless web </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.958.1">application architectures</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.960.1">You might be wondering: why </span><em class="italic"><span class="koboSpan" id="kobo.961.1">containerless</span></em><span class="koboSpan" id="kobo.962.1">? </span><span class="koboSpan" id="kobo.962.2">Because today’s cloud</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.963.1"> environment, with its </span><strong class="bold"><span class="koboSpan" id="kobo.964.1">Platform-as-a-Service</span></strong><span class="koboSpan" id="kobo.965.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.966.1">PaaS</span></strong><span class="koboSpan" id="kobo.967.1">) offerings, provides most of the features offered by container-based web architectures, such as reliability, management, and scaling. </span><span class="koboSpan" id="kobo.967.2">Therefore, Spring Boot focuses on making itself an </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">ultralight container.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">Spring Boot has its own default configurations and also supports auto-configuration to make production-ready</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.970.1"> web application development simple. </span><strong class="bold"><span class="koboSpan" id="kobo.971.1">Spring Initializr</span></strong><span class="koboSpan" id="kobo.972.1"> (</span><a href="http://start.spring.io"><span class="koboSpan" id="kobo.973.1">http://start.spring.io</span></a><span class="koboSpan" id="kobo.974.1">) is a web-based service where you simply</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.975.1"> choose your build tools, such as </span><em class="italic"><span class="koboSpan" id="kobo.976.1">Maven</span></em><span class="koboSpan" id="kobo.977.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.978.1">Gradle</span></em><span class="koboSpan" id="kobo.979.1">, along with the project metadata, such as the group, artifacts, and any dependencies. </span><span class="koboSpan" id="kobo.979.2">Once you fill in the required fields, you simply click on the </span><strong class="bold"><span class="koboSpan" id="kobo.980.1">Generate Project</span></strong><span class="koboSpan" id="kobo.981.1"> button to be provided with a Spring Boot project that you can use for your </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">production application.</span></span></p>
<p><span class="koboSpan" id="kobo.983.1">On the page at the preceding</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.984.1"> link, we can see the default </span><strong class="bold"><span class="koboSpan" id="kobo.985.1">Packaging</span></strong><span class="koboSpan" id="kobo.986.1"> option is </span><strong class="bold"><span class="koboSpan" id="kobo.987.1">Jar</span></strong><span class="koboSpan" id="kobo.988.1">, which we are going to use throughout</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.989.1"> this book. </span><span class="koboSpan" id="kobo.989.2">You would use the </span><strong class="bold"><span class="koboSpan" id="kobo.990.1">War</span></strong><span class="koboSpan" id="kobo.991.1"> packaging option (for </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">web archive</span></strong><span class="koboSpan" id="kobo.993.1">) if you wanted to deploy the application on a web server such as </span><em class="italic"><span class="koboSpan" id="kobo.994.1">WebLogic</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.995.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.996.1">Tomcat</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.998.1"><img alt="Figure 2.2 – Spring Initializr" src="image/Figure_02.2_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.999.1">Figure 2.2 – Spring Initializr</span></p>
<p><span class="koboSpan" id="kobo.1000.1">In simple words, Spring Initializr does all the configuration for us so we can focus on writing our business</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.1001.1"> logic </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">and APIs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1003.1">Building and running the code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1004.1">You can build the code</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.1005.1"> by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">gradlew clean build</span></strong><span class="koboSpan" id="kobo.1007.1"> from the</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.1008.1"> root of the project and running the service using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">java -jar build/libs/Chapter02-0.0.1-SNAPSHOT.jar</span></strong><span class="koboSpan" id="kobo.1010.1">. </span><span class="koboSpan" id="kobo.1010.2">Make sure to use Java 17 in </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">the path.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">In the next section, let’s dig into servlet dispatcher, which is responsible for Spring MVC and REST </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">controller features.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.1014.1">Understanding the importance of servlet dispatcher</span></h1>
<p><span class="koboSpan" id="kobo.1015.1">In the previous chapter, you learned that RESTful web services</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.1016.1"> are developed on top of the HTTP protocol. </span><span class="koboSpan" id="kobo.1016.2">Java has a Servlets feature to work with HTTP. </span><span class="koboSpan" id="kobo.1016.3">Servlets allow you to have path mapping that can work at REST endpoints and provides the HTTP method for identification. </span><span class="koboSpan" id="kobo.1016.4">Servlets also allow you to form different types of response objects, including JSON and XML. </span><span class="koboSpan" id="kobo.1016.5">However, they offer a somewhat crude way of implementing REST endpoints, as you must still handle the request URI, parse the parameters, and convert JSON/XML and the responses on </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">Spring MVC comes</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.1019.1"> to your rescue. </span><span class="koboSpan" id="kobo.1019.2">Spring MVC is based on the </span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.1021.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1022.1">MVC</span></strong><span class="koboSpan" id="kobo.1023.1">) pattern and has been part of the Spring Framework since its first release. </span><span class="koboSpan" id="kobo.1023.2">MVC is a well-known </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">design pattern:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1025.1">Model</span></strong><span class="koboSpan" id="kobo.1026.1">: Models are Java objects (called POJOs) that contain the application data. </span><span class="koboSpan" id="kobo.1026.2">They also represent the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1028.1">View</span></strong><span class="koboSpan" id="kobo.1029.1">: The view is a presentation layer that consists of HTML/JSP/template files. </span><span class="koboSpan" id="kobo.1029.2">The view renders the data from models and generates the </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">HTML output.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1031.1">Controller</span></strong><span class="koboSpan" id="kobo.1032.1">: The controller processes the user requests and builds </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">the model.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.1034.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.1035.1"> is part of Spring MVC. </span><span class="koboSpan" id="kobo.1035.2">It works as a front</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.1036.1"> controller, that is, it handles all the incoming HTTP requests. </span><span class="koboSpan" id="kobo.1036.2">Spring MVC is a web framework that allows you to develop traditional web applications where UI apps are also part of the backend. </span><span class="koboSpan" id="kobo.1036.3">However, you’ll develop RESTful web services, and the UI will be based on the React JavaScript library; therefore, we’ll keep the servlet dispatcher role limited to implementing the REST endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">@RestController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">Let’s have a look at the flow of an example user request in Spring MVC for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">REST controller:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1042.1">The user sends the HTTP request, which is received </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">DispatcherServlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.1047.1"> passes the baton to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">HandlerMapping</span></strong><span class="koboSpan" id="kobo.1049.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">HandlerMapping</span></strong><span class="koboSpan" id="kobo.1051.1"> does the job of finding the correct controller for the requested URI and passes it back </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">DispatcherServlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.1056.1"> then makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.1058.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">handle </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">Controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.1063.1"> calls the appropriate method </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">Controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">Controller</span></strong><span class="koboSpan" id="kobo.1068.1"> then executes the associated business logic and forms </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">the response.</span></span></li>
<li><span class="koboSpan" id="kobo.1070.1">Spring makes use of the marshaling/unmarshalling of the request and response objects for JSON/XML conversion from Java and </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">vice versa.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1072.1">Let’s see a visual representation</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.1073.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">this process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.1075.1"><img alt="Figure 2.3 – DispatcherServlet" src="image/Figure_02.3_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1076.1">Figure 2.3 – DispatcherServlet</span></p>
<p><span class="koboSpan" id="kobo.1077.1">You now have a good understanding of the importance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.1079.1">, which is key for REST </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">API</span></span><span class="No-Break"><a id="_idIndexMarker151"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1"> implementation.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1082.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1083.1">This chapter helped you learn about Spring’s key concepts: beans, DI, and AOP. </span><span class="koboSpan" id="kobo.1083.2">You also learned how to define the scope of beans and create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.1085.1"> programmatically, using it to get the beans. </span><span class="koboSpan" id="kobo.1085.2">You can define beans’ configuration metadata using Java and annotations and have learned how to use different beans of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">same type.</span></span></p>
<p><span class="koboSpan" id="kobo.1087.1">You also implemented an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">Aspect</span></strong><span class="koboSpan" id="kobo.1089.1"> example, applying a module approach to a cross-cutting concern, and learned the key concepts of the AOP </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">programming paradigm.</span></span></p>
<p><span class="koboSpan" id="kobo.1091.1">Since we are going to implement REST APIs in this book, it is important to understand the servlet </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">dispatcher concept.</span></span></p>
<p><span class="koboSpan" id="kobo.1093.1">In the next chapter, we’ll implement our first REST API application using the OpenAPI Specification and use a Spring controller to </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">implement it.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.1095.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1096.1">How do you define a bean with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">prototype scope?</span></span></li>
<li><span class="koboSpan" id="kobo.1098.1">What is the difference between prototype and </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">singleton beans?</span></span></li>
<li><span class="koboSpan" id="kobo.1100.1">What is required for a session and request scope </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">to work?</span></span></li>
<li><span class="koboSpan" id="kobo.1102.1">What is the relationship between advice and pointcut in terms </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">of AOP?</span></span></li>
<li><span class="koboSpan" id="kobo.1104.1">Write an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Aspect</span></strong><span class="koboSpan" id="kobo.1106.1"> for logging that prints the method and argument names before the method execution, and prints a message with the return type (if any) after the method’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">successful execution.</span></span></li>
</ol>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1108.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1109.1">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">@Scope</span></strong><span class="koboSpan" id="kobo.1111.1"> annotation </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">as shown:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1113.1">
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></pre></li> <li><span class="koboSpan" id="kobo.1114.1">Beans defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">singleton</span></strong><span class="koboSpan" id="kobo.1116.1"> scope are instantiated only once per Spring container. </span><span class="koboSpan" id="kobo.1116.2">The same instance is injected every time it is requested, whereas with a bean defined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">prototype</span></strong><span class="koboSpan" id="kobo.1118.1"> scope, the container creates a new instance every time the injection is done by the Spring container for the requested bean. </span><span class="koboSpan" id="kobo.1118.2">In short, a container creates a single bean per container for a singleton-scoped bean, whereas a container creates a new instance every time there is a new injection for </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">prototype-scoped beans.</span></span></li>
<li><span class="koboSpan" id="kobo.1120.1">Session and request scopes only work when a web-aware Spring context is used. </span><span class="koboSpan" id="kobo.1120.2">Other scopes that also need a web-aware context to work are application and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">WebSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1"> scopes.</span></span></li>
<li><span class="koboSpan" id="kobo.1123.1">Advice is an action taken by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">Aspect</span></strong><span class="koboSpan" id="kobo.1125.1"> at a specific time (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.1127.1">). </span><span class="koboSpan" id="kobo.1127.2">Aspects perform the additional logic (advice) at a certain point (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">JoinPoint</span></strong><span class="koboSpan" id="kobo.1129.1">), such as a method being called, an exception being thrown, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.1131.1">The following code will print the method name and argument names before the method execution, and a message with the return type after the </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">method execution:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
@Aspect@Componentpublic class TimeMonitorAspect { @Around("@annotation(TimeMonitor)") public Object logTime(ProceedingJoinPoint   joinPoint) throws Throwable {  System.out.println(String.format("Method    Name: %s, Arg Name: %s",    joinPoint.getSignature().getName(),    Arrays.toString(((CodeSignature)    joinPoint.getSignature())    .getParameterNames())));  Object proceed = joinPoint.proceed();  System.out.println(String.format("Method    %s contains the following return type:    %s",joinPoint.getSignature().getName(),    ((MethodSignature)    joinPoint.getSignature()).    getReturnType().toGenericString()));  return proceed; }}</span></pre></li> </ol>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.1134.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1135.1">IoC containers and the DI </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">pattern: </span></span><a href="https://martinfowler.com/articles/injection.html"><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">https://martinfowler.com/articles/injection.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.1138.1">The Spring Framework documentation: 6.0.0-M5 was the latest at the time of writing this </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">book: </span></span><a href="https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/"><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1141.1">Spring Boot 2 </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1142.1">Fundamentals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">: </span></span><a href="https://www.packtpub.com/product/spring-boot-2-fundamentals/9781838821975"><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">https://www.packtpub.com/product/spring-boot-2-fundamentals/9781838821975</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1145.1">Developing Java Applications with Spring and Spring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1146.1">Boot:</span></em></span><span class="No-Break"> </span><a href="https://www.packtpub.com/product/developing-java-applications-with-spring-and-spring-boot/9781789534757"><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">https://www.packtpub.com/product/developing-java-applications-with-spring-and-spring-boot/9781789534757</span></span></a></li>
</ul>
</div>
</body></html>