- en: Securing Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a key requirement of every enterprise system. In this chapter, we
    will learn how to effectively secure Quarkus services using a variety of approaches.
    The first approach we will put into practice embeds the security layer within
    our service. This can still be considered a valid solution for rapid application
    development and testing. On the other hand, when moving our service into production,
    we need to avoid this extreme centralization. Therefore, the next strategy we
    will learn about is how the Quarkus service can connect to a distributed security
    system such as Keycloak. The last topic in this chapter is about encrypting the
    HTTP channel through some easy configuration steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing our customer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Quarkus services with Elytron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Quarkus services with Keycloak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Quarkus services with MicroProfile JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTTPS with Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Securing our customer service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Quarkus security infrastructure derives from the standard **Java Enterprise
    Edition** (**Java EE**) specification, which is based on a simple role-based security
    model. By using that, you can specify your security constraints through annotations
    and configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of Java annotations, the following ones can be used to specify security
    constraints that can be applied either on a single method or on a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.RolesAllowed`: This is the most common annotation
    as it specifies one or more roles that have been authorized to invoke a certain
    method or class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.RunAs`: This annotation assigns a role dynamically
    during the invocation of a method or class. It can be a handy option if we need
    to temporarily allow the execution of some methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.PermitAll`: This annotation allows us to release
    security constraints from methods. It can be useful in some scenarios where you
    haven''t identified which role will be entitled to invoke a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.DenyAll`: This annotation is the exact opposite
    of `@PermitAll` as it denies access to a method or class that bears this annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To keep things simple, we will define a simple security policy for our customer
    service application. This will include two roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User** **role**: This role will be entitled to perform *read-only* operations,
    such as querying the `Customer` list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin** **role**: This role will be entitled to perform all the available
    operations, including create, update, and delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code for our `CustomerEndpoint` class, which has been
    decorated with the `@RolesAllowed` security annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, we won't include the `OrderEndpoint` class here, which
    has been updated in the same way in order to secure read methods with the **user**
    role and the write methods with the **admin** role.
  prefs: []
  type: TYPE_NORMAL
- en: Having defined our security policy, we can now choose which security provider
    will be applied to our service. This will require us to add the right settings
    in `application.properties` and include the dependencies in our project's `pom.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the Elytron security provider, which doesn't require us to
    install any external applications or tools to secure our service.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Quarkus services with Elytron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elytron is a security framework that has been created to unify the security
    aspects of WildFly and JBoss' **Enterprise Application Platform** (**EAP**). It
    comes as a consequence that this framework has been initially designed for monolithic
    applications in order to provide coverage on every aspect of security. What is
    the advantage of using Elytron in a container-ready native platform such as Quarkus?
  prefs: []
  type: TYPE_NORMAL
- en: Although it may look like an oversimplified solution to securing your assets,
    it can prove to be advantageous when developing or testing applications that include
    security roles. Out of the box, Quarkus provides an implementation of a **file-based
    security realm** in order to provide **role-based access control** (**RBAC**)
    to our basic endpoints with minimal configuration requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of libraries, at the time of writing this book, there are three available
    Elytron extensions we can use to secure our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-elytron-security-properties-file`: Provides support for basic authentication
    via property files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-elytron-security-jdbc`: Provides support for database authentication
    via JDBC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-elytron-security-oauth2`: Provides support for OAuth2 authentication.
    This extension may be deprecated in future versions of Quarkus and replaced by
    a reactive Vert.x version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since our customer application already uses a database as a backend, we will
    show you how to use database authentication. Please check out the source code
    in the `Chapter07/elytron-demo` folder before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the `pom.xml` file, we have added the following extension to our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure authentication, we need to specify which table contains the list
    of users and roles. We also need to add a couple of users with different roles.
    For this purpose, we have included the following SQL statements in the `import.sql`
    script, which are located in the `src/main/resources` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the `application.properties` file, we need to activate JDBC authentication
    by providing some basic configuration parameters for it. Here is the list of properties
    we have added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly discuss these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The `quarkus.security.jdbc.enabled` property, when set to true, enables JDBC
    authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quarkus.security.jdbc.principal-query.sql` property is used to specify
    the SQL statements that will check for a valid username/password combination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quarkus.security.jdbc.principal-query.clear-password-mapper.enabled` property,
    when set to true, configures a mapper that maps a column that's returned from
    a SQL query to a clear password key type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quarkus.security.jdbc.principal-query.clear-password-mapper.password-index`
    property sets the column index from the clear text authentication query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `quarkus.security.jdbc.principal-query.attribute-mappings.0.index`
    and `quarkus.security.jdbc.principal-query.attribute-mappings.0.to` are used to
    bind the second field in the authentication query (`index=2`) with the principal's
    role (groups).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all you need to secure your service using the Elytron security domain.
    With all the pieces in the right place, we will be using a test class that verifies
    authentication against the REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test class that performs basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our test class needs to be adjusted so that it can fit the new secured scenario.
    In practice, we need to send the header files with the user''s credentials, along
    with the HTTP request, with them to authorize the service''s execution. Thanks
    to the Fluent `RestAssured` API, it is fairly easy to plug the `auth()` method
    into our HTTP request, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we have to use a preemptive basic authentication. This means
    that the authentication details are sent in the request header immediately, regardless
    of whether the server has already challenged the authentication. Without that,
    the current Vert.x implementation in Quarkus would return an unauthorized response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the PostgreSQL database has been started, our test class is ready
    to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that all of the CRUD operations have completed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will cover how to use Keycloak to leverage OpenID ([https://openid.net/](https://openid.net/))
    security standards in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Quarkus services with Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Keycloak** ([https://www.keycloak.org/](https://www.keycloak.org/)) is an
    open source access management solution that builds on top of the WildFly application
    server. You can adopt it in your architecture to leverage a wide variety of features,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client adapters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Sign-On** (**SSO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity management and social login**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard protocols (OpenID Connect or SAML)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A rich admin console**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A user account management console**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to these features and the ability to connect to existing identity standards,
    Keycloak has become a de facto standard for many large organizations. A supported
    version of it, known as **Red Hat Single Sign-On** (**RH-SSO**:[https://access.redhat.com/products/red-hat-single-sign-on](https://access.redhat.com/products/red-hat-single-sign-on)),
    is also available for enterprise customers.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, Keycloak acts as the main security endpoint for the applications
    in your network. Therefore, your applications don't have to add login forms to
    authenticate users and store their credentials. Instead, applications are configured
    to point to Keycloak, which supports protocol standards such as OpenID or SAML
    to secure your endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In short, client applications will be redirected from their domain to Keycloak's
    identity server, where they exhibit their credentials. This way, your services
    are completely isolated from your security policies and from your user's credentials.
    Instead, services are granted a digitally signed identity token or assertion.
    These tokens hold identity information (such as name or email address) but can
    also hold information about roles that are authorized to perform business operations.
    In the next section, we will learn how to configure Keycloak so that we can issue
    tokens that can be used to access our example customer service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Keycloak extension to our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `Chapter07/keycloak-demo` folder, you will find another version
    of our customer service application that uses Keycloak to secure the REST endpoints.
    To use Keycloak authorization and the OpenID extension, we have included the following
    set of dependencies in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that all the required libraries are in place, let's learn how to install
    Keycloak Identity Server and load a security realm in it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be using Docker to quickly take the reins of Keycloak.
    First, we need to pull the Keycloak image and start a container instance. The
    following command will start the Keycloak Server in the background and choose
    `8180` as the HTTP port and expose the host and port locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console, you should see that the server has managed to start successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that Keycloak is up and running, let's load a realm, which contains a valid
    security configuration that we will apply to our service.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the security realm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key aspect of Keycloak configuration is the security realm, which contains
    all the configuration (user, roles, client policies, and many others) that are
    pertinent to one security context. When you start Keycloak for the first time,
    it will contain just one realm: the **master** realm. This is the top level in
    the hierarchy of realms. You shouldn''t use this realm to configure users and
    services in your organization. Instead, consider using the master realm for administrators
    who are in charge of defining the other realms in your organization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our GitHub repository for this chapter contains an application realm named
    **Quarkus realm** that will be useful for our purposes. We will show you how to
    import it and then we will walk through its configuration so that you will be
    able to create new realms based on this template. Let''s proceed with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by connecting to the Keycloak console, which is available at `http://localhost:8180`.
    An authentication challenge will be displayed. Log in with `admin/admin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b04d01d-7e6d-4543-bd34-6cd80142e3cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, from the top-left panel, choose to add a new realm, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16b183e1-d7f3-4303-86e3-cf2377431073.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose to Import a realm and point to the JSON file (`quarkus-realm.json`)
    that contains an export of Quarkus'' realm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/864912ae-fa33-4d16-82a6-c190a1d55b47.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Create to continue. Now, let's look at a short overview of the realm's
    options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the realm settings window, you will be able to define some core settings,
    such as the domain name, and your login settings, predefine your tokens'' lifespan
    and timeouts, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5781993e-6718-4d52-a2cb-95756ac16a49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of our learning path, we will not vary these settings. In the
    realm panel, you will be able to verify that we have included the same roles (admin
    and user) so that they match our existing security constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/889a139b-e185-4ac5-89d9-48f463110248.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have recreated the same list of users that we tested in our file-based
    Elytron domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecc9c4d6-5a0c-41cd-b451-fef370f51552.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From within the Role Mappings tab, you can check that the test user is a member
    of the user role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07d431be-45f1-442e-b6f4-9828a25de68a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, the admin user will be assigned to both the admin and the
    user role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccaa9f2a-04d7-4402-9867-d9d386bebf81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve looked at the users and roles, let''s discuss a key aspect
    of the realm''s client configuration, which is displayed in the following UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/724afdbe-9817-4458-af06-c3788a30efb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at some of the key aspects of the client configuration. First and
    foremost, we have to define the client protocol. There are two types of client
    authentication protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenID Connect** (**OIDC**) is an authentication system where the client
    requests an access token that''s used to call other services on behalf of the
    authenticated user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAML** authentication requires Keycloak to provide an SSO for the users of
    your organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our needs, OIDC token-based authentication is what we need to grant access
    to our services. We also need to select whether we will be using the standard
    flow or the implicit flow for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The default option (Standard Flow Enabled) involves an initial browser redirection
    to/from the OIDC provider (Keycloak) for user authentication and consent. Then,
    a second back-channel request is needed to retrieve the ID token. This flow offers
    optimal security since tokens aren't revealed to the browser and the client can
    be safely authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s depict this flow in the form of a sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79970357-6452-4a8f-a669-7696771cf27a.png)'
  prefs: []
  type: TYPE_IMG
- en: To provide a better performance, Keycloak also supports **implicit flows**,
    which occur when the access token is sent immediately after successful authentication.
    Although this option may scale better (since there is no additional request to
    exchange the code for tokens), you will be in charge of monitoring when the token
    expires so that you can issue a fresh one.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've chosen to use the standard flow, we will specify an appropriate
    Valid Redirect URI, which needs to be set to the default HTTP port of our application
    running on Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Access Type, we have configured it to be confidential, which requires
    client applications to provide a secret in order to obtain an ID token. When you
    set the Access Type to confidential, you will be able to choose the Client Authenticator
    from the Credentials tab, which defines the type of credential you will use for
    your client and its secret. The secret that''s defined for this client ID is mysecret,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/302fa96c-9029-4ea0-a071-761c46de61ab.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to change the default secret, just click on the Regenerate Secret
    button and update your client applications accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured Keycloak, we will use this realm to execute a test
    using a bearer token authentication. However, before that, we will configure our
    Quarkus service accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Quarkus for Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Believe it or not, once we have configured the identity server, we don''t have
    much work to do in our Quarkus application. We only need to provide the Keycloak
    URL and client settings to the `application.properties` configuration file of
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration, we have provided the mandatory settings to
    connect to the Keycloak Identity Server. We have also added a property named `keycloak.url`
    to define Keycloak''s IP address and port. In the following table, we have added
    some details about each parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.oidc.enabled` | When set to true, the OIDC extension will be enabled.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.oidc.auth-server-url` | The root URL where Keycloak authenticates
    client requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.oidc.client-id` | The client ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.oidc.credentials.secret` | The client secret. |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.keycloak.policy-enforcer.enable` | By enabling the policy enforcer,
    requests are not allowed in, although there is no policy associated with that
    resource. |'
  prefs: []
  type: TYPE_TB
- en: Other than this, if you are planning to run Keycloak on a different machine
    from your application, it is recommended to enable HTTP CORS so that you can access
    Keycloak across domain boundaries (check out [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml),
    *Managing Data Persistence with Quarkus*, for more details about this).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's dive into the test class that will be used to perform CRUD operations
    that have been authorized through Keycloak's Identity Server.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the test class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our test class is composed of two blocks. In the first block, we retrieve a
    token for the `test` user and the `admin` user. Then, we use both tokens to test
    the application. More specifically, the `test` token, which belongs to the user
    role, will be used for `GET` requests. On the other hand, the `admin` token will
    be used to authorize `POST`, `PUT`, and `DELETE` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first block of the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code issues a `POST` request against the auth URL of our Keycloak realm.
    The request contains the username and password, along with the client's ID (`quarkus_client`)
    and its secret (`mysecret`) as parameters. The `RESTAssured` API verifies that
    a status code of 200 is returned and returns the response object. Then, we extracted
    the token contained in the JSON response, which is under the `access_token` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to debug the low-level details of your token claim, you can use
    a tool such as `curl` to inspect the response returned by Keycloak. For example,
    if you are going to request a token for the `test` user, then here is a plain
    `curl` command that will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second block of code, we access our service by including the user''s
    token in each REST call. We do this using the `oauth2` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The test can be executed will the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should expect it to complete successfully, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have just managed to set up an enterprise-grade security
    infrastructure for your service.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering principal and role information at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on to the next authentication schema, it''s worth noting that
    you can determine the principal name and roles at runtime by injecting the `SecurityIdentity`
    interface that represents the currently logged-in user. In this short excerpt,
    we will learn how to retrieve and log the user that''s connected, the name/surname
    they used to register, and the set of roles they are entitled to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, when accessing the list of customers, the service will log the
    following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can check all the available methods in the `SecurityIdentity` interface
    by having a look at its source code, which is available at [https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java](https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java).
  prefs: []
  type: TYPE_NORMAL
- en: Securing Quarkus services with MicroProfile JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we covered how to use Keycloak to authenticate and
    authorize requests using a bearer token. A bearer token alone, however, is a simplified
    security schema since it's based on exchanging a potentially arbitrary string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any client in possession of a valid bearer token can use it to get access to
    the associated resources without demonstrating his/her identity, which can only
    be verified with a cryptographic key. In order to fill this gap, we will learn
    how to use **JSON Web Tokens** (**JWTs**), an encoding standard for tokens, using
    a JSON data payload that can be signed and encrypted. A JWT includes the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: This is a Base64-encoded string and consists of two parts: the
    type of the token, which is JWT, and the hashing algorithm being used, such as
    HMAC SHA256 or RSA. Here is a sample decoded header JWT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2e38798b-1c5b-4a97-aa74-9707936283fb.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Payload**: This is also a Base64-encoded string that contains claims. Claims
    are statements about an entity (user or group) and additional metadata. Here is
    a sample payload that''s been returned to our service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/63798a61-1827-4eb8-aa76-5227b85c28ae.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Signature**: The signature is used to verify that the message wasn''t altered
    along the way. In the case of tokens that have been signed with a private key,
    it can also assert that the sender of the JWT is who they say they are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e81e186a-8dc6-4855-8154-1084234e507f.png)'
  prefs: []
  type: TYPE_IMG
- en: The JWT token can also be provided by Keycloak, so we don't have to change our
    realm configuration to use it with JWT. On the other hand, we had to include the
    **groups claim** so that the JWT token will map the token subject's group memberships
    to the application-level roles defined in the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'This information has been included in our realm (in the Mappers section of
    our client configuration) through the Token Claim Name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f504a1fb-2814-4c7b-87dd-f079aa810861.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's configure our service so that it can use this authentication schema.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our service to use JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our proof of concept project can be located in the `Chapter07/jwt-demo` folder.
    We recommend that you import it into your IDE to compare it with the other projects
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we have replaced the Keycloak authorization and the OpenID extension
    with the `quarkus-smallrye-jwt` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we included a different set of properties for our project. The following
    is the code for the `application.properties` configuration file, which targets
    the same Keycloak Server and provides details about the public key location and
    authentication mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table provides a brief description of each property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `mp.jwt.verify.publickey.location` | The location where the provider''s public
    key is stored. It can be a relative path or a URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `mp.jwt.verify.issuer` | Specifies the value of the **iss** (short for **issuer**)
    claim of the JWT that the server will accept as valid. |'
  prefs: []
  type: TYPE_TB
- en: '| `quarkus.smallrye-jwt.realmName` | The security realm that''s used for authentication.
    |'
  prefs: []
  type: TYPE_TB
- en: Now, we are ready to execute our test class using the JWT authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Running our test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `CustomerEndpointTest` class contains the same code we used to verify the
    Keycloak authentication. Behind the scenes, however, it will execute the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the access token fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform signature verification using the realm's RSA public key, which is available
    at the location defined in the `mp.jwt.verify.publickey.location` system property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The test can be executed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that it completes successfully, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As for pure Keycloak authentication, let's learn how to gather more information
    from the JWT context.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting JWT claims and token information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage the information contained in the JWT programmatically, we can inject
    the relevant API into our services. The main class, `org.eclipse.microprofile.jwt.JsonWebToken`,
    can be injected plainly with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This class provides methods that we can use to retrieve the token itself, its
    subject, and the claims contained in the token. More details can be found in the
    source code, which is available at [https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java](https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a shortcut for retrieving a specific claim can be done through
    the `@Claim` annotation, which includes its `standard` attribute and the name
    of the `Claim`. Use the following code to inject the groups and the username contained
    in the token''s claim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That was our last topic on Keycloak for this chapter. Now, let's dissect one
    more security topic, which is about using SSL for HTTP communication.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTPS with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section of this chapter is dedicated to encrypting the HTTP communication
    in Quarkus. In order to do that, you need to provide a valid (either self-signed
    or signed by a CA) Keystore or PEM certificate in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s learn how to generate a self-signed PEM key and certificate pair.
    The simplest way to do this is by using the OpenSSL tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will generate a certificate named `cert.pem` and a related
    key file named `key.pem` in the current directory. Next, configure the filesystem
    path to your certificate and the key file in your `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you can also generate and use a Keystore that already contains
    a default entry with a certificate. You can generate it using the `keytool` utility
    and provide a password for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the only file that will be created will be `keystore.jks`; we
    can include it in our configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can specify the port that''s used by the Undertow server to bind
    the HTTPS protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As a proof of concept, you can build and run the application contained in `Chapter07/https`
    to verify that it can be accessed through the SSL port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de4d6adf-ffc2-41b4-b073-6d458234591c.png)'
  prefs: []
  type: TYPE_IMG
- en: The warning you can see in the browser's bar simply means that the SSL certificate
    that's being used isn't being issued by a trusted authority.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the basic configuration steps that we need
    to follow in order to secure our application at the transport level. Now, we don't
    communicate with our customer service through a clear text channel; instead, we
    use a **Secure Sockets Layer** (**SSL**) to secure our connection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by discussing the security policies that can be applied
    to Quarkus services. Out of the box, you can provide file-based security authentication
    and authorization by using the Elytron extension. Then, we took a closer look
    at Keycloak, which can be used to provide enterprise-grade security standards
    by supporting the OpenID standards. We covered a basic example using a bearer
    token and a more complex one using a digitally signed token, both in compliance
    with the JWT specification. Finally, we discovered how to generate and configure
    certificates to secure access to our Quarkus endpoints using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover some advanced tactics that can improve the
    untapped potential of Quarkus services!
  prefs: []
  type: TYPE_NORMAL
