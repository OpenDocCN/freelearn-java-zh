- en: Securing Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护应用程序
- en: Security is a key requirement of every enterprise system. In this chapter, we
    will learn how to effectively secure Quarkus services using a variety of approaches.
    The first approach we will put into practice embeds the security layer within
    our service. This can still be considered a valid solution for rapid application
    development and testing. On the other hand, when moving our service into production,
    we need to avoid this extreme centralization. Therefore, the next strategy we
    will learn about is how the Quarkus service can connect to a distributed security
    system such as Keycloak. The last topic in this chapter is about encrypting the
    HTTP channel through some easy configuration steps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是每个企业系统的一个关键要求。在本章中，我们将学习如何使用各种方法有效地保护Quarkus服务。我们将首先实践的方法是在我们的服务中嵌入安全层。这仍然可以被视为快速应用程序开发和测试的有效解决方案。另一方面，当我们的服务投入生产时，我们需要避免这种极端的集中化。因此，我们将学习的下一个策略是Quarkus服务如何连接到分布式安全系统，如Keycloak。本章的最后一个主题是关于通过一些简单的配置步骤加密HTTP通道。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Securing our customer service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护我们的客户服务
- en: Securing Quarkus services with Elytron
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elytron保护Quarkus服务
- en: Securing Quarkus services with Keycloak
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Keycloak保护Quarkus服务
- en: Securing Quarkus services with MicroProfile JWT
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MicroProfile JWT保护Quarkus服务
- en: Using HTTPS with Quarkus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS与Quarkus
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章项目的源代码，地址为[https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07)。
- en: Securing our customer service
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护我们的客户服务
- en: The Quarkus security infrastructure derives from the standard **Java Enterprise
    Edition** (**Java EE**) specification, which is based on a simple role-based security
    model. By using that, you can specify your security constraints through annotations
    and configuration files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus安全基础设施源自标准的**Java企业版**（**Java EE**）规范，该规范基于简单的基于角色的安全模型。通过使用它，您可以通过注解和配置文件指定您的安全约束。
- en: 'In terms of Java annotations, the following ones can be used to specify security
    constraints that can be applied either on a single method or on a class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java注解方面，以下注解可以用来指定可以应用于单个方法或类的安全约束：
- en: '`@javax.annotation.security.RolesAllowed`: This is the most common annotation
    as it specifies one or more roles that have been authorized to invoke a certain
    method or class.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.RolesAllowed`：这是最常见的注解，因为它指定了一个或多个被授权调用特定方法或类的角色。'
- en: '`@javax.annotation.security.RunAs`: This annotation assigns a role dynamically
    during the invocation of a method or class. It can be a handy option if we need
    to temporarily allow the execution of some methods.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.RunAs`：此注解在方法或类的调用期间动态分配一个角色。如果我们需要临时允许执行某些方法，这可以是一个方便的选项。'
- en: '`@javax.annotation.security.PermitAll`: This annotation allows us to release
    security constraints from methods. It can be useful in some scenarios where you
    haven''t identified which role will be entitled to invoke a method.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.PermitAll`：此注解允许我们从方法中释放安全约束。在某些场景中，如果您还没有确定哪个角色将有权调用方法，这可能很有用。'
- en: '`@javax.annotation.security.DenyAll`: This annotation is the exact opposite
    of `@PermitAll` as it denies access to a method or class that bears this annotation.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@javax.annotation.security.DenyAll`：此注解与`@PermitAll`正好相反，因为它拒绝访问带有此注解的方法或类。'
- en: 'To keep things simple, we will define a simple security policy for our customer
    service application. This will include two roles:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将为我们的客户服务应用程序定义一个简单的安全策略。这包括两个角色：
- en: '**User** **role**: This role will be entitled to perform *read-only* operations,
    such as querying the `Customer` list.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户** **角色**：此角色将有权执行*只读*操作，例如查询`客户`列表。'
- en: '**Admin** **role**: This role will be entitled to perform all the available
    operations, including create, update, and delete.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员** **角色**：此角色将有权执行所有可用的操作，包括创建、更新和删除。'
- en: 'The following is the code for our `CustomerEndpoint` class, which has been
    decorated with the `@RolesAllowed` security annotation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `CustomerEndpoint` 类的代码，该类已被 `@RolesAllowed` 安全注解装饰：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the sake of brevity, we won't include the `OrderEndpoint` class here, which
    has been updated in the same way in order to secure read methods with the **user**
    role and the write methods with the **admin** role.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们这里不包括已更新的 `OrderEndpoint` 类，它同样被更新以保护带有 **用户** 角色的读取方法和带有 **管理员** 角色的写入方法。
- en: Having defined our security policy, we can now choose which security provider
    will be applied to our service. This will require us to add the right settings
    in `application.properties` and include the dependencies in our project's `pom.xml`
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的安全策略之后，我们现在可以选择将哪个安全提供者应用于我们的服务。这需要我们在 `application.properties` 中添加正确的设置，并在我们项目的
    `pom.xml` 文件中包含依赖项。
- en: We will start with the Elytron security provider, which doesn't require us to
    install any external applications or tools to secure our service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Elytron 安全提供者开始，它不需要我们安装任何外部应用程序或工具来保护我们的服务。
- en: Securing Quarkus services with Elytron
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elytron 保护 Quarkus 服务
- en: Elytron is a security framework that has been created to unify the security
    aspects of WildFly and JBoss' **Enterprise Application Platform** (**EAP**). It
    comes as a consequence that this framework has been initially designed for monolithic
    applications in order to provide coverage on every aspect of security. What is
    the advantage of using Elytron in a container-ready native platform such as Quarkus?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Elytron 是一个安全框架，它被创建出来以统一 WildFly 和 JBoss 的 **企业应用平台**（**EAP**）的安全方面。因此，这个框架最初是为单体应用程序设计的，以便覆盖安全方面的每一个方面。在
    Quarkus 这样的容器就绪的本地平台上使用 Elytron 有什么优势？
- en: Although it may look like an oversimplified solution to securing your assets,
    it can prove to be advantageous when developing or testing applications that include
    security roles. Out of the box, Quarkus provides an implementation of a **file-based
    security realm** in order to provide **role-based access control** (**RBAC**)
    to our basic endpoints with minimal configuration requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来是一个过于简化的保护资产的方法，但它可以在开发或测试包含安全角色的应用程序时证明是有益的。开箱即用，Quarkus 提供了一个基于文件的
    **安全域** 实现，以提供最小配置要求下的 **基于角色的访问控制**（**RBAC**）。
- en: 'In terms of libraries, at the time of writing this book, there are three available
    Elytron extensions we can use to secure our applications:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我们有三个可用的 Elytron 扩展，我们可以使用它们来保护我们的应用程序：
- en: '`quarkus-elytron-security-properties-file`: Provides support for basic authentication
    via property files.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-elytron-security-properties-file`：通过属性文件提供基本身份验证的支持。'
- en: '`quarkus-elytron-security-jdbc`: Provides support for database authentication
    via JDBC.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-elytron-security-jdbc`：通过 JDBC 提供数据库身份验证的支持。'
- en: '`quarkus-elytron-security-oauth2`: Provides support for OAuth2 authentication.
    This extension may be deprecated in future versions of Quarkus and replaced by
    a reactive Vert.x version.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-elytron-security-oauth2`：提供 OAuth2 身份验证的支持。这个扩展可能在 Quarkus 的未来版本中被弃用，并可能被一个反应式
    Vert.x 版本所取代。'
- en: Since our customer application already uses a database as a backend, we will
    show you how to use database authentication. Please check out the source code
    in the `Chapter07/elytron-demo` folder before you move on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的客户应用程序已经使用数据库作为后端，我们将向您展示如何使用数据库身份验证。在继续之前，请检查 `Chapter07/elytron-demo`
    文件夹中的源代码。
- en: 'As shown in the `pom.xml` file, we have added the following extension to our
    project:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `pom.xml` 文件所示，我们已经向我们的项目中添加了以下扩展：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To configure authentication, we need to specify which table contains the list
    of users and roles. We also need to add a couple of users with different roles.
    For this purpose, we have included the following SQL statements in the `import.sql`
    script, which are located in the `src/main/resources` folder:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置身份验证，我们需要指定哪个表包含用户和角色的列表。我们还需要添加几个具有不同角色的用户。为此，我们在 `src/main/resources`
    文件夹中的 `import.sql` 脚本中包含了以下 SQL 语句：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, within the `application.properties` file, we need to activate JDBC authentication
    by providing some basic configuration parameters for it. Here is the list of properties
    we have added:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `application.properties` 文件中，我们需要通过提供一些基本的配置参数来激活 JDBC 身份验证。以下是添加的属性列表：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s quickly discuss these properties:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速讨论这些属性：
- en: The `quarkus.security.jdbc.enabled` property, when set to true, enables JDBC
    authentication.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `quarkus.security.jdbc.enabled` 属性设置为 true 时，启用 JDBC 认证。
- en: The `quarkus.security.jdbc.principal-query.sql` property is used to specify
    the SQL statements that will check for a valid username/password combination.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus.security.jdbc.principal-query.sql` 属性用于指定将检查有效用户名/密码组合的 SQL 语句。'
- en: The `quarkus.security.jdbc.principal-query.clear-password-mapper.enabled` property,
    when set to true, configures a mapper that maps a column that's returned from
    a SQL query to a clear password key type.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `quarkus.security.jdbc.principal-query.clear-password-mapper.enabled` 属性设置为
    true 时，配置了一个将 SQL 查询返回的列映射到明文密码键类型的映射器。
- en: The `quarkus.security.jdbc.principal-query.clear-password-mapper.password-index`
    property sets the column index from the clear text authentication query.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus.security.jdbc.principal-query.clear-password-mapper.password-index`
    属性设置了来自明文认证查询的列索引。'
- en: Finally, `quarkus.security.jdbc.principal-query.attribute-mappings.0.index`
    and `quarkus.security.jdbc.principal-query.attribute-mappings.0.to` are used to
    bind the second field in the authentication query (`index=2`) with the principal's
    role (groups).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`quarkus.security.jdbc.principal-query.attribute-mappings.0.index` 和 `quarkus.security.jdbc.principal-query.attribute-mappings.0.to`
    用于将认证查询中的第二个字段（`index=2`）绑定到主体的角色（组）。
- en: That's all you need to secure your service using the Elytron security domain.
    With all the pieces in the right place, we will be using a test class that verifies
    authentication against the REST endpoints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您使用 Elytron 安全域来保护服务所需的所有内容。当所有部件都放在正确的位置时，我们将使用一个测试类来验证对 REST 端点的认证。
- en: Creating a test class that performs basic authentication
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个执行基本身份验证的测试类
- en: 'Our test class needs to be adjusted so that it can fit the new secured scenario.
    In practice, we need to send the header files with the user''s credentials, along
    with the HTTP request, with them to authorize the service''s execution. Thanks
    to the Fluent `RestAssured` API, it is fairly easy to plug the `auth()` method
    into our HTTP request, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试类需要调整，以便它可以适应新的受保护场景。实际上，我们需要在 HTTP 请求中发送带有用户凭证的头部文件，以授权服务的执行。多亏了 Fluent
    `RestAssured` API，将 `auth()` 方法插入我们的 HTTP 请求相当简单，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that we have to use a preemptive basic authentication. This means
    that the authentication details are sent in the request header immediately, regardless
    of whether the server has already challenged the authentication. Without that,
    the current Vert.x implementation in Quarkus would return an unauthorized response.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用预防性基本身份验证。这意味着认证详情会立即发送在请求头中，无论服务器是否已经挑战了认证。没有这个，当前在 Quarkus 中的 Vert.x
    实现将返回一个未授权的响应。
- en: 'Assuming that the PostgreSQL database has been started, our test class is ready
    to be executed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 PostgreSQL 数据库已经启动，我们的测试类准备就绪，可以执行：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see that all of the CRUD operations have completed successfully:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到所有的 CRUD 操作都已完成成功：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the next section, we will cover how to use Keycloak to leverage OpenID ([https://openid.net/](https://openid.net/))
    security standards in our application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用 Keycloak 在我们的应用程序中利用 OpenID ([https://openid.net/](https://openid.net/))
    安全标准。
- en: Securing Quarkus services with Keycloak
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Keycloak 保护 Quarkus 服务
- en: '**Keycloak** ([https://www.keycloak.org/](https://www.keycloak.org/)) is an
    open source access management solution that builds on top of the WildFly application
    server. You can adopt it in your architecture to leverage a wide variety of features,
    such as the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keycloak** ([https://www.keycloak.org/](https://www.keycloak.org/)) 是一个基于
    WildFly 应用服务器的开源访问管理解决方案。您可以在您的架构中采用它，以利用以下各种功能：'
- en: '**Client adapters**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端适配器**'
- en: '**Single Sign-On** (**SSO**)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单点登录** (**SSO**)'
- en: '**Identity management and social login**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份管理和社交登录**'
- en: '**Standard protocols (OpenID Connect or SAML)**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准协议（OpenID Connect 或 SAML**）'
- en: '**A rich admin console**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富的管理控制台**'
- en: '**A user account management console**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户账户管理控制台**'
- en: Thanks to these features and the ability to connect to existing identity standards,
    Keycloak has become a de facto standard for many large organizations. A supported
    version of it, known as **Red Hat Single Sign-On** (**RH-SSO**:[https://access.redhat.com/products/red-hat-single-sign-on](https://access.redhat.com/products/red-hat-single-sign-on)),
    is also available for enterprise customers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些功能和连接到现有身份标准的能力，Keycloak已成为许多大型组织的既定标准。它的一个受支持的版本，被称为**红帽单点登录**（**RH-SSO**：[https://access.redhat.com/products/red-hat-single-sign-on](https://access.redhat.com/products/red-hat-single-sign-on)），也适用于企业客户。
- en: Once installed, Keycloak acts as the main security endpoint for the applications
    in your network. Therefore, your applications don't have to add login forms to
    authenticate users and store their credentials. Instead, applications are configured
    to point to Keycloak, which supports protocol standards such as OpenID or SAML
    to secure your endpoints.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Keycloak将成为您网络中应用程序的主要安全端点。因此，您的应用程序不需要添加登录表单来验证用户并存储其凭证。相反，应用程序被配置为指向Keycloak，它支持OpenID或SAML等协议标准，以保护您的端点。
- en: In short, client applications will be redirected from their domain to Keycloak's
    identity server, where they exhibit their credentials. This way, your services
    are completely isolated from your security policies and from your user's credentials.
    Instead, services are granted a digitally signed identity token or assertion.
    These tokens hold identity information (such as name or email address) but can
    also hold information about roles that are authorized to perform business operations.
    In the next section, we will learn how to configure Keycloak so that we can issue
    tokens that can be used to access our example customer service.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，客户端应用将从其域名重定向到Keycloak的身份服务器，在那里它们展示其凭证。这样，您的服务与您的安全策略和用户凭证完全隔离。相反，服务被授予一个数字签名的身份令牌或断言。这些令牌包含身份信息（如姓名或电子邮件地址），也可以包含有关授权执行业务操作的角色的信息。在下一节中，我们将学习如何配置Keycloak，以便我们可以发行可以用来访问我们的示例客户服务的令牌。
- en: Adding a Keycloak extension to our service
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Keycloak扩展添加到我们的服务中
- en: 'Within the `Chapter07/keycloak-demo` folder, you will find another version
    of our customer service application that uses Keycloak to secure the REST endpoints.
    To use Keycloak authorization and the OpenID extension, we have included the following
    set of dependencies in the `pom.xml` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter07/keycloak-demo`文件夹中，您将找到我们客户服务应用程序的另一个版本，该版本使用Keycloak来保护REST端点。为了使用Keycloak授权和OpenID扩展，我们在`pom.xml`文件中包含了以下依赖项集：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that all the required libraries are in place, let's learn how to install
    Keycloak Identity Server and load a security realm in it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必需的库都已就绪，让我们学习如何安装Keycloak身份服务器并在其中加载一个安全领域。
- en: Setting up Keycloak
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Keycloak
- en: 'In this section, we will be using Docker to quickly take the reins of Keycloak.
    First, we need to pull the Keycloak image and start a container instance. The
    following command will start the Keycloak Server in the background and choose
    `8180` as the HTTP port and expose the host and port locally:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Docker快速掌握Keycloak的控制权。首先，我们需要拉取Keycloak镜像并启动一个容器实例。以下命令将在后台启动Keycloak服务器，并将`8180`作为HTTP端口，并本地暴露主机和端口：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the console, you should see that the server has managed to start successfully:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，你应该看到服务器已经成功启动：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that Keycloak is up and running, let's load a realm, which contains a valid
    security configuration that we will apply to our service.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Keycloak已经启动并运行，让我们加载一个领域，它包含我们将应用于我们的服务的有效安全配置。
- en: Defining the security realm
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义安全领域
- en: 'A key aspect of Keycloak configuration is the security realm, which contains
    all the configuration (user, roles, client policies, and many others) that are
    pertinent to one security context. When you start Keycloak for the first time,
    it will contain just one realm: the **master** realm. This is the top level in
    the hierarchy of realms. You shouldn''t use this realm to configure users and
    services in your organization. Instead, consider using the master realm for administrators
    who are in charge of defining the other realms in your organization.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak配置的一个关键方面是安全领域，它包含与一个安全上下文相关的所有配置（用户、角色、客户端策略等）。当您第一次启动Keycloak时，它将包含一个领域：**主领域**。这是领域层次结构中的顶级。您不应该使用此领域来配置您组织中的用户和服务。相反，考虑使用主领域为负责定义您组织中的其他领域的管理员。
- en: 'Our GitHub repository for this chapter contains an application realm named
    **Quarkus realm** that will be useful for our purposes. We will show you how to
    import it and then we will walk through its configuration so that you will be
    able to create new realms based on this template. Let''s proceed with the following
    steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的 GitHub 仓库包含一个名为 **Quarkus 领域**的应用程序领域，这对我们的目的很有用。我们将向您展示如何导入它，然后我们将逐步介绍其配置，以便您可以根据此模板创建新的领域。让我们按照以下步骤进行：
- en: 'Start by connecting to the Keycloak console, which is available at `http://localhost:8180`.
    An authentication challenge will be displayed. Log in with `admin/admin`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先连接到 Keycloak 控制台，该控制台位于 `http://localhost:8180`。将显示身份验证挑战。使用 `admin/admin`
    登录：
- en: '![](img/7b04d01d-7e6d-4543-bd34-6cd80142e3cd.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b04d01d-7e6d-4543-bd34-6cd80142e3cd.png)'
- en: 'Now, from the top-left panel, choose to add a new realm, as shown in the following
    screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从左上角的面板中选择添加一个新的领域，如下面的截图所示：
- en: '![](img/16b183e1-d7f3-4303-86e3-cf2377431073.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16b183e1-d7f3-4303-86e3-cf2377431073.png)'
- en: 'Choose to Import a realm and point to the JSON file (`quarkus-realm.json`)
    that contains an export of Quarkus'' realm:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择导入一个领域，并指向包含 Quarkus 领域导出的 JSON 文件（`quarkus-realm.json`）：
- en: '![](img/864912ae-fa33-4d16-82a6-c190a1d55b47.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/864912ae-fa33-4d16-82a6-c190a1d55b47.png)'
- en: Click on Create to continue. Now, let's look at a short overview of the realm's
    options.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建以继续。现在，让我们简要概述一下领域的选项。
- en: 'Within the realm settings window, you will be able to define some core settings,
    such as the domain name, and your login settings, predefine your tokens'' lifespan
    and timeouts, and more:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域设置窗口中，您将能够定义一些核心设置，例如域名和您的登录设置，预定义您的令牌有效期和超时时间，等等：
- en: '![](img/5781993e-6718-4d52-a2cb-95756ac16a49.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5781993e-6718-4d52-a2cb-95756ac16a49.png)'
- en: 'For the purpose of our learning path, we will not vary these settings. In the
    realm panel, you will be able to verify that we have included the same roles (admin
    and user) so that they match our existing security constraints:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的学习路径，我们将不会更改这些设置。在领域面板中，您将能够验证我们已经包含了相同的角色（管理员和用户），以便它们与我们的现有安全约束相匹配：
- en: '![](img/889a139b-e185-4ac5-89d9-48f463110248.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/889a139b-e185-4ac5-89d9-48f463110248.png)'
- en: 'Here, we have recreated the same list of users that we tested in our file-based
    Elytron domain:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重新创建了我们在基于文件的 Elytron 领域中测试过的相同用户列表：
- en: '![](img/ecc9c4d6-5a0c-41cd-b451-fef370f51552.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecc9c4d6-5a0c-41cd-b451-fef370f51552.png)'
- en: 'From within the Role Mappings tab, you can check that the test user is a member
    of the user role:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在“角色映射”选项卡中，您可以检查测试用户是否是用户角色的成员：
- en: '![](img/07d431be-45f1-442e-b6f4-9828a25de68a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07d431be-45f1-442e-b6f4-9828a25de68a.png)'
- en: 'On the other hand, the admin user will be assigned to both the admin and the
    user role:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，管理员用户将被分配给管理员和用户角色：
- en: '![](img/ccaa9f2a-04d7-4402-9867-d9d386bebf81.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccaa9f2a-04d7-4402-9867-d9d386bebf81.png)'
- en: 'Now that we''ve looked at the users and roles, let''s discuss a key aspect
    of the realm''s client configuration, which is displayed in the following UI:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了用户和角色，让我们讨论领域客户端配置的一个关键方面，如下面的 UI 所示：
- en: '![](img/724afdbe-9817-4458-af06-c3788a30efb4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/724afdbe-9817-4458-af06-c3788a30efb4.png)'
- en: 'Let''s look at some of the key aspects of the client configuration. First and
    foremost, we have to define the client protocol. There are two types of client
    authentication protocols:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看客户端配置的一些关键方面。首先，我们必须定义客户端协议。有两种类型的客户端身份验证协议：
- en: '**OpenID Connect** (**OIDC**) is an authentication system where the client
    requests an access token that''s used to call other services on behalf of the
    authenticated user.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（**OIDC**）是一种身份验证系统，客户端请求一个访问令牌，该令牌用于代表经过身份验证的用户调用其他服务。'
- en: '**SAML** authentication requires Keycloak to provide an SSO for the users of
    your organization.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAML**身份验证要求 Keycloak 为您的组织用户提供单点登录（SSO）。'
- en: For our needs, OIDC token-based authentication is what we need to grant access
    to our services. We also need to select whether we will be using the standard
    flow or the implicit flow for authentication.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的需求，基于 OIDC 令牌的身份验证是我们需要授予我们的服务访问权限的。我们还需要选择我们将使用标准流程还是隐式流程进行身份验证。
- en: The default option (Standard Flow Enabled) involves an initial browser redirection
    to/from the OIDC provider (Keycloak) for user authentication and consent. Then,
    a second back-channel request is needed to retrieve the ID token. This flow offers
    optimal security since tokens aren't revealed to the browser and the client can
    be safely authenticated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选项（启用标准流程）涉及将浏览器重定向到/从 OIDC 提供商（Keycloak）进行用户认证和同意。然后，需要一个第二个回传请求来检索 ID 令牌。此流程提供最佳安全性，因为令牌不会暴露给浏览器，并且客户端可以安全地认证。
- en: 'Let''s depict this flow in the form of a sequence diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以序列图的形式描述这个流程：
- en: '![](img/79970357-6452-4a8f-a669-7696771cf27a.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79970357-6452-4a8f-a669-7696771cf27a.png)'
- en: To provide a better performance, Keycloak also supports **implicit flows**,
    which occur when the access token is sent immediately after successful authentication.
    Although this option may scale better (since there is no additional request to
    exchange the code for tokens), you will be in charge of monitoring when the token
    expires so that you can issue a fresh one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的性能，Keycloak 还支持 **隐式流程**，这发生在访问令牌在成功认证后立即发送时。虽然这个选项可能具有更好的可扩展性（因为不需要额外的请求来交换代码以获取令牌），但你将负责监控令牌何时过期，以便你可以发放一个新的令牌。
- en: Since we've chosen to use the standard flow, we will specify an appropriate
    Valid Redirect URI, which needs to be set to the default HTTP port of our application
    running on Quarkus.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了使用标准流程，我们将指定一个适当的有效重定向 URI，这需要设置为运行在 Quarkus 上的应用程序的默认 HTTP 端口。
- en: 'For the Access Type, we have configured it to be confidential, which requires
    client applications to provide a secret in order to obtain an ID token. When you
    set the Access Type to confidential, you will be able to choose the Client Authenticator
    from the Credentials tab, which defines the type of credential you will use for
    your client and its secret. The secret that''s defined for this client ID is mysecret,
    as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问类型，我们将其配置为机密类型，这要求客户端应用程序提供密钥以获取 ID 令牌。当你将访问类型设置为机密时，你将能够从凭据选项卡中选择客户端认证器，它定义了你将用于客户端及其密钥的凭据类型。为该客户端
    ID 定义的密钥是 mysecret，如下面的截图所示：
- en: '![](img/302fa96c-9029-4ea0-a071-761c46de61ab.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/302fa96c-9029-4ea0-a071-761c46de61ab.png)'
- en: If you want to change the default secret, just click on the Regenerate Secret
    button and update your client applications accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改默认密钥，只需点击“重新生成密钥”按钮，并相应地更新你的客户端应用程序。
- en: Now that we have configured Keycloak, we will use this realm to execute a test
    using a bearer token authentication. However, before that, we will configure our
    Quarkus service accordingly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 Keycloak，我们将使用这个域来执行一个使用携带令牌认证的测试。然而，在那之前，我们将相应地配置我们的 Quarkus 服务。
- en: Configuring Quarkus for Keycloak
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Quarkus 以支持 Keycloak
- en: 'Believe it or not, once we have configured the identity server, we don''t have
    much work to do in our Quarkus application. We only need to provide the Keycloak
    URL and client settings to the `application.properties` configuration file of
    our application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，一旦我们配置了身份服务器，在我们的 Quarkus 应用程序中就没有太多工作要做。我们只需要将 Keycloak URL 和客户端设置提供给我们的应用程序的
    `application.properties` 配置文件：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding configuration, we have provided the mandatory settings to
    connect to the Keycloak Identity Server. We have also added a property named `keycloak.url`
    to define Keycloak''s IP address and port. In the following table, we have added
    some details about each parameter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们提供了连接到 Keycloak 身份服务器的必需设置。我们还添加了一个名为 `keycloak.url` 的属性来定义 Keycloak
    的 IP 地址和端口。在下面的表中，我们添加了一些关于每个参数的详细信息：
- en: '| **Parameter** | **Description** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `quarkus.oidc.enabled` | When set to true, the OIDC extension will be enabled.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.oidc.enabled` | 当设置为 true 时，将启用 OIDC 扩展。 |'
- en: '| `quarkus.oidc.auth-server-url` | The root URL where Keycloak authenticates
    client requests. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.oidc.auth-server-url` | Keycloak 认证客户端请求的根 URL。 |'
- en: '| `quarkus.oidc.client-id` | The client ID. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.oidc.client-id` | 客户端 ID。 |'
- en: '| `quarkus.oidc.credentials.secret` | The client secret. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.oidc.credentials.secret` | 客户端密钥。 |'
- en: '| `quarkus.keycloak.policy-enforcer.enable` | By enabling the policy enforcer,
    requests are not allowed in, although there is no policy associated with that
    resource. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.keycloak.policy-enforcer.enable` | 通过启用策略执行器，即使没有与该资源关联的策略，也不允许请求进入。
    |'
- en: Other than this, if you are planning to run Keycloak on a different machine
    from your application, it is recommended to enable HTTP CORS so that you can access
    Keycloak across domain boundaries (check out [Chapter 5](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml),
    *Managing Data Persistence with Quarkus*, for more details about this).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，如果您打算在不同于应用程序的机器上运行Keycloak，建议启用HTTP CORS，这样您就可以跨域访问Keycloak（有关此内容的更多详细信息，请参阅[第5章](078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml)，*使用Quarkus管理数据持久性*)。
- en: Now, let's dive into the test class that will be used to perform CRUD operations
    that have been authorized through Keycloak's Identity Server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解将用于执行通过Keycloak身份服务器授权的CRUD操作的测试类。
- en: Coding the test class
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试类
- en: Our test class is composed of two blocks. In the first block, we retrieve a
    token for the `test` user and the `admin` user. Then, we use both tokens to test
    the application. More specifically, the `test` token, which belongs to the user
    role, will be used for `GET` requests. On the other hand, the `admin` token will
    be used to authorize `POST`, `PUT`, and `DELETE` requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试类由两个部分组成。在第一个部分中，我们为`test`用户和`admin`用户检索令牌。然后，我们使用这两个令牌来测试应用程序。更具体地说，属于用户角色的`test`令牌将用于`GET`请求。另一方面，`admin`令牌将用于授权`POST`、`PUT`和`DELETE`请求。
- en: 'Here is the first block of the test class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试类的第一个部分：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code issues a `POST` request against the auth URL of our Keycloak realm.
    The request contains the username and password, along with the client's ID (`quarkus_client`)
    and its secret (`mysecret`) as parameters. The `RESTAssured` API verifies that
    a status code of 200 is returned and returns the response object. Then, we extracted
    the token contained in the JSON response, which is under the `access_token` key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码向我们的Keycloak域的认证URL发出`POST`请求。请求包含用户名和密码，以及客户端ID（`quarkus_client`）及其密钥（`mysecret`）作为参数。`RESTAssured`
    API验证返回状态码为200，并返回响应对象。然后，我们从JSON响应中提取了包含在`access_token`键下的令牌。
- en: 'If you want to debug the low-level details of your token claim, you can use
    a tool such as `curl` to inspect the response returned by Keycloak. For example,
    if you are going to request a token for the `test` user, then here is a plain
    `curl` command that will do the job:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想调试令牌声明的底层细节，您可以使用像`curl`这样的工具来检查Keycloak返回的响应。例如，如果您要为`test`用户请求令牌，那么以下是一个简单的`curl`命令，可以完成这项工作：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the second block of code, we access our service by including the user''s
    token in each REST call. We do this using the `oauth2` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第二部分中，我们通过在每个REST调用中包含用户的令牌来访问我们的服务。我们使用`oauth2`方法来做这件事：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The test can be executed will the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以通过以下命令执行：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should expect it to complete successfully, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该期望它能够成功完成，如下所示：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Congratulations! You have just managed to set up an enterprise-grade security
    infrastructure for your service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经成功为您的服务搭建了一个企业级的安全基础设施。
- en: Gathering principal and role information at runtime
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时收集主体和角色信息
- en: 'Before moving on to the next authentication schema, it''s worth noting that
    you can determine the principal name and roles at runtime by injecting the `SecurityIdentity`
    interface that represents the currently logged-in user. In this short excerpt,
    we will learn how to retrieve and log the user that''s connected, the name/surname
    they used to register, and the set of roles they are entitled to:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一个认证方案之前，值得注意的是，您可以通过注入表示当前登录用户的`SecurityIdentity`接口来在运行时确定主体名称和角色。在这段简短的摘录中，我们将学习如何检索和记录已连接的用户、他们用于注册的姓名/姓氏以及他们有权获得的角色集：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, when accessing the list of customers, the service will log the
    following information:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当访问客户列表时，服务将记录以下信息：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can check all the available methods in the `SecurityIdentity` interface
    by having a look at its source code, which is available at [https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java](https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看其源代码来检查`SecurityIdentity`接口中所有可用的方法，该源代码可在[https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java](https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java)找到。
- en: Securing Quarkus services with MicroProfile JWT
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile JWT保护Quarkus服务
- en: In the previous example, we covered how to use Keycloak to authenticate and
    authorize requests using a bearer token. A bearer token alone, however, is a simplified
    security schema since it's based on exchanging a potentially arbitrary string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们介绍了如何使用Keycloak通过携带令牌进行身份验证和授权请求。然而，仅携带令牌本身是一个简化的安全模式，因为它基于交换一个可能任意字符串。
- en: 'Any client in possession of a valid bearer token can use it to get access to
    the associated resources without demonstrating his/her identity, which can only
    be verified with a cryptographic key. In order to fill this gap, we will learn
    how to use **JSON Web Tokens** (**JWTs**), an encoding standard for tokens, using
    a JSON data payload that can be signed and encrypted. A JWT includes the following
    sections:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何拥有有效携带令牌的客户都可以使用它来获取相关资源，而无需证明其身份，因为身份只能通过加密密钥进行验证。为了填补这一空白，我们将学习如何使用**JSON
    Web Tokens**（JWTs），这是一种用于令牌的编码标准，它使用可以签名和加密的JSON数据负载。JWT包括以下部分：
- en: '**Header**: This is a Base64-encoded string and consists of two parts: the
    type of the token, which is JWT, and the hashing algorithm being used, such as
    HMAC SHA256 or RSA. Here is a sample decoded header JWT:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：这是一个Base64编码的字符串，由两部分组成：令牌的类型，即JWT，以及正在使用的哈希算法，例如HMAC SHA256或RSA。以下是一个示例解码头部JWT：'
- en: '![](img/2e38798b-1c5b-4a97-aa74-9707936283fb.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e38798b-1c5b-4a97-aa74-9707936283fb.png)'
- en: '**Payload**: This is also a Base64-encoded string that contains claims. Claims
    are statements about an entity (user or group) and additional metadata. Here is
    a sample payload that''s been returned to our service:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载**：这也是一个Base64编码的字符串，包含声明。声明是关于实体（用户或组）及其附加元数据的陈述。以下是我们服务返回的示例负载：'
- en: '![](img/63798a61-1827-4eb8-aa76-5227b85c28ae.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63798a61-1827-4eb8-aa76-5227b85c28ae.png)'
- en: '**Signature**: The signature is used to verify that the message wasn''t altered
    along the way. In the case of tokens that have been signed with a private key,
    it can also assert that the sender of the JWT is who they say they are:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：签名用于验证消息在传输过程中未被更改。对于使用私钥签名的令牌，它还可以断言JWT的发送者是其所声称的人：'
- en: '![](img/e81e186a-8dc6-4855-8154-1084234e507f.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e81e186a-8dc6-4855-8154-1084234e507f.png)'
- en: The JWT token can also be provided by Keycloak, so we don't have to change our
    realm configuration to use it with JWT. On the other hand, we had to include the
    **groups claim** so that the JWT token will map the token subject's group memberships
    to the application-level roles defined in the services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌也可以由Keycloak提供，因此我们无需更改领域配置即可使用JWT。另一方面，我们必须包含**组声明**，以便JWT令牌将令牌主体的组成员映射到服务中定义的应用程序级别角色。
- en: 'This information has been included in our realm (in the Mappers section of
    our client configuration) through the Token Claim Name field:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息已通过Token Claim Name字段包含在我们的领域（客户端配置的Mappers部分）中：
- en: '![](img/f504a1fb-2814-4c7b-87dd-f079aa810861.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f504a1fb-2814-4c7b-87dd-f079aa810861.png)'
- en: Now, let's configure our service so that it can use this authentication schema.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置我们的服务，使其能够使用此身份验证方案。
- en: Configuring our service to use JWT
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置我们的服务以使用JWT
- en: Our proof of concept project can be located in the `Chapter07/jwt-demo` folder.
    We recommend that you import it into your IDE to compare it with the other projects
    in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的证明概念项目可以位于`Chapter07/jwt-demo`文件夹中。我们建议您将其导入到您的IDE中，以便与其他章节中的项目进行比较。
- en: 'First off, we have replaced the Keycloak authorization and the OpenID extension
    with the `quarkus-smallrye-jwt` extension:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将Keycloak授权和OpenID扩展替换为`quarkus-smallrye-jwt`扩展：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we included a different set of properties for our project. The following
    is the code for the `application.properties` configuration file, which targets
    the same Keycloak Server and provides details about the public key location and
    authentication mechanism:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的项目包含了一组不同的属性。以下是`application.properties`配置文件的代码，它针对同一Keycloak服务器，并提供了公钥位置和身份验证机制的详细信息：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following table provides a brief description of each property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了每个属性：
- en: '| **Parameter** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| `mp.jwt.verify.publickey.location` | The location where the provider''s public
    key is stored. It can be a relative path or a URL. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `mp.jwt.verify.publickey.location` | 存储提供者公钥的位置。它可以是相对路径或URL。|'
- en: '| `mp.jwt.verify.issuer` | Specifies the value of the **iss** (short for **issuer**)
    claim of the JWT that the server will accept as valid. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `mp.jwt.verify.issuer` | 指定 JWT 的 **iss**（代表 **issuer**）声明的值，服务器将接受该值为有效。|'
- en: '| `quarkus.smallrye-jwt.realmName` | The security realm that''s used for authentication.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `quarkus.smallrye-jwt.realmName` | 用于认证的安全域。|'
- en: Now, we are ready to execute our test class using the JWT authentication mechanism.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用 JWT 认证机制来执行我们的测试类。
- en: Running our test
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'Our `CustomerEndpointTest` class contains the same code we used to verify the
    Keycloak authentication. Behind the scenes, however, it will execute the following
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CustomerEndpointTest` 类包含我们用来验证 Keycloak 认证的相同代码。然而，在幕后，它将执行以下步骤：
- en: Request the access token.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求访问令牌。
- en: Validate the access token fields.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证访问令牌字段。
- en: Perform signature verification using the realm's RSA public key, which is available
    at the location defined in the `mp.jwt.verify.publickey.location` system property.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用领域提供的 RSA 公钥执行签名验证，该公钥位于 `mp.jwt.verify.publickey.location` 系统属性定义的位置。
- en: 'The test can be executed with the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以通过以下命令执行：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see that it completes successfully, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到它成功完成，如下所示：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As for pure Keycloak authentication, let's learn how to gather more information
    from the JWT context.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 至于纯 Keycloak 认证，让我们学习如何从 JWT 上下文中获取更多信息。
- en: Injecting JWT claims and token information
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入 JWT 声明和令牌信息
- en: 'To manage the information contained in the JWT programmatically, we can inject
    the relevant API into our services. The main class, `org.eclipse.microprofile.jwt.JsonWebToken`,
    can be injected plainly with the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式管理 JWT 中包含的信息，我们可以将相关的 API 注入到我们的服务中。主类 `org.eclipse.microprofile.jwt.JsonWebToken`
    可以通过以下命令直接注入：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This class provides methods that we can use to retrieve the token itself, its
    subject, and the claims contained in the token. More details can be found in the
    source code, which is available at [https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java](https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供了我们可以用来检索令牌本身、其主题以及令牌中包含的声明的函数。更多详细信息可以在源代码中找到，源代码位于 [https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java](https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java)。
- en: 'On the other hand, a shortcut for retrieving a specific claim can be done through
    the `@Claim` annotation, which includes its `standard` attribute and the name
    of the `Claim`. Use the following code to inject the groups and the username contained
    in the token''s claim:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以通过 `@Claim` 注解来获取特定的声明，它包括其 `standard` 属性和 `Claim` 的名称。使用以下代码注入令牌声明中的组和用户名：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That was our last topic on Keycloak for this chapter. Now, let's dissect one
    more security topic, which is about using SSL for HTTP communication.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是本章关于 Keycloak 的最后一个主题。现在，让我们剖析另一个安全主题，即使用 SSL 进行 HTTP 通信。
- en: Using HTTPS with Quarkus
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quarkus 的 HTTPS
- en: The last section of this chapter is dedicated to encrypting the HTTP communication
    in Quarkus. In order to do that, you need to provide a valid (either self-signed
    or signed by a CA) Keystore or PEM certificate in your configuration.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一节专门讨论了在 Quarkus 中加密 HTTP 通信。为了做到这一点，您需要在配置中提供一个有效的（无论是自签名还是由 CA 签名）密钥库或
    PEM 证书。
- en: 'First, let''s learn how to generate a self-signed PEM key and certificate pair.
    The simplest way to do this is by using the OpenSSL tool, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何生成一个自签名的 PEM 密钥和证书对。最简单的方法是使用 OpenSSL 工具，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command will generate a certificate named `cert.pem` and a related
    key file named `key.pem` in the current directory. Next, configure the filesystem
    path to your certificate and the key file in your `application.properties`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在当前目录下生成一个名为 `cert.pem` 的证书和一个相关名为 `key.pem` 的密钥文件。接下来，在您的 `application.properties`
    中配置证书和密钥文件的文件系统路径：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On the other hand, you can also generate and use a Keystore that already contains
    a default entry with a certificate. You can generate it using the `keytool` utility
    and provide a password for it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您还可以生成并使用一个已经包含默认条目和证书的密钥库。您可以使用 `keytool` 工具生成它，并为它提供一个密码：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our case, the only file that will be created will be `keystore.jks`; we
    can include it in our configuration as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，唯一将被创建的文件将是 `keystore.jks`；我们可以在配置中包含它，如下所示：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can specify the port that''s used by the Undertow server to bind
    the HTTPS protocol:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以指定 Undertow 服务器使用的端口来绑定 HTTPS 协议：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As a proof of concept, you can build and run the application contained in `Chapter07/https`
    to verify that it can be accessed through the SSL port:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为概念验证，你可以构建并运行位于 `Chapter07/https` 中的应用程序，以验证它可以通过 SSL 端口访问：
- en: '![](img/de4d6adf-ffc2-41b4-b073-6d458234591c.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de4d6adf-ffc2-41b4-b073-6d458234591c.png)'
- en: The warning you can see in the browser's bar simply means that the SSL certificate
    that's being used isn't being issued by a trusted authority.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器栏中可以看到的警告只是意味着正在使用的 SSL 证书不是由受信任的机构签发的。
- en: In this section, we have covered the basic configuration steps that we need
    to follow in order to secure our application at the transport level. Now, we don't
    communicate with our customer service through a clear text channel; instead, we
    use a **Secure Sockets Layer** (**SSL**) to secure our connection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了我们需要遵循的基本配置步骤，以确保我们的应用程序在传输层的安全性。现在，我们不再通过明文通道与客户服务进行通信；相反，我们使用
    **安全套接字层** (**SSL**) 来保护我们的连接。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by discussing the security policies that can be applied
    to Quarkus services. Out of the box, you can provide file-based security authentication
    and authorization by using the Elytron extension. Then, we took a closer look
    at Keycloak, which can be used to provide enterprise-grade security standards
    by supporting the OpenID standards. We covered a basic example using a bearer
    token and a more complex one using a digitally signed token, both in compliance
    with the JWT specification. Finally, we discovered how to generate and configure
    certificates to secure access to our Quarkus endpoints using HTTPS.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时讨论了可以应用于 Quarkus 服务的安全策略。默认情况下，你可以通过使用 Elytron 扩展提供基于文件的认证和授权。然后，我们更详细地探讨了
    Keycloak，它可以通过支持 OpenID 标准来提供企业级的安全标准。我们介绍了使用载体令牌的基本示例，以及一个更复杂的示例，使用数字签名的令牌，两者都符合
    JWT 规范。最后，我们发现了如何生成和配置证书，以使用 HTTPS 保护对 Quarkus 终端的访问。
- en: In the next chapter, we will cover some advanced tactics that can improve the
    untapped potential of Quarkus services!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些高级策略，这些策略可以提升 Quarkus 服务的潜在能力！
