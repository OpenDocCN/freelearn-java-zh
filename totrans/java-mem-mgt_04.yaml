- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Freeing Memory with Garbage Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allocated memory needs to be deallocated when it is no longer needed. In some
    languages, the developer needs to take care of that. In some others, such as Java,
    this happens automatically. For Java, the garbage collector does this. The deallocation
    of memory is necessary for an application to keep running. Without the ability
    to free memory when it is no longer needed, we would only be able to allocate
    memory once, and eventually, we would run out of memory. In this chapter, we will
    be learning more about freeing memory on the heap using the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a tough topic! Before you are ready for this chapter, you’ll need
    to have a clear understanding of the heap space. Again, we’ll visualize the concepts
    as much as possible to increase your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that will be discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Object eligibility for **garbage** **collection** (**GC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking by the garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweeping by the garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different GC implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  prefs: []
  type: TYPE_NORMAL
- en: Being eligible for GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that objects on the heap are removed when they are no longer
    needed. The right question to ask, then, would be, *when are objects no* *longer
    needed?*
  prefs: []
  type: TYPE_NORMAL
- en: 'That question is easy to answer but leads to a complex problem at the same
    time. Let’s first have a look at the answer: *objects on the heap are no longer
    needed when they don’t have a connection to* *the stack*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects don’t have a connection to the stack when the stack doesn’t store the
    reference to the object in a variable. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we create the object, which gets created on the heap. The
    `o` variable holds a reference to an object of type `Object` on the stack. We
    use the object because we have the reference stored. In this case, we are printing
    it on the second line of the example, which is clearly a rather silly output since
    the `toString()` method of `Object` is only going to be returning the following
    output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the next line, we set the variable to `null`. This overrides the reference
    to the object and simply points nowhere, as there is no object stored in `o` anymore.
    Nothing else in our application holds a reference to the `Object` we’ve created.
    Thus, it becomes eligible for GC.
  prefs: []
  type: TYPE_NORMAL
- en: This example was rather simple. To demonstrate how difficult this problem actually
    is, let’s look at a slightly more complex problem and illustrate it with some
    diagrams. The question that we need to answer here is, *which objects are eligible
    for GC on* *each line?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.1 – Overview of the stack and heap for the eligibility example](img/Figure_4.1_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Overview of the stack and heap for the eligibility example
  prefs: []
  type: TYPE_NORMAL
- en: 'On the fifth line, we set our `p1` to `null`. Does this mean that `p1` is eligible
    for GC? Quick reminder: an object on the heap is eligible for GC as soon as it
    doesn’t have a connection to the stack anymore. But let’s look at what happens
    after executing line 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Overview of the heap and the stack after executing line 5](img/Figure_4.2_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Overview of the heap and the stack after executing line 5
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the connection to the stack in `p1` is gone. But this doesn’t
    mean that there’s no connection to the stack anymore. There’s still an indirect
    connection. We can go from the stack to the list of `Person` object, and from
    there we can still access the object that `p1` was holding a reference to, since
    the list still holds a reference to that object. Therefore, none of the objects
    on the heap is eligible for GC after line 5.
  prefs: []
  type: TYPE_NORMAL
- en: This changes after line 6\. At line 6, we set the variable that held the list
    to `null`. This means that `p1` no longer has a connection to the stack after
    this line, as you can see in *Figure 4**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Overview of the heap and stack at the end of the code](img/Figure_4.3_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Overview of the heap and stack at the end of the code
  prefs: []
  type: TYPE_NORMAL
- en: There is no connection between the list and the stack, and now both the `List`
    object and the first instance of the `Person` object are eligible for GC. Meanwhile,
    the `p2` and `p3` variables still hold a reference to the objects on the heap,
    and therefore these objects are not eligible for GC.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not hard to tell which ones are ready for GC once you understand the direct
    and indirect connection from the heap back to the stack. However, figuring out
    which ones have a connection with the stack will require some time, and this will
    slow down the rest of the application. There are a few ways to do it, but each
    comes with its own downsides with respect to accuracy or performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This complex problem is language-agnostic: how do we determine whether an object
    still has a connection to the stack? The solution we’ll be discussing is of course
    Java-specific. Finding objects that are no longer needed is done by the garbage
    collector in the marking phase. The marking phase consists of a special algorithm
    that determines what objects are eligible for GC.'
  prefs: []
  type: TYPE_NORMAL
- en: Marking by the garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Marking marks any live objects and anything not marked as ready to be garbage
    collected. The objects keep a special bit that determines whether they are marked
    or not. Upon creation, the bit is `0`. In the mark phase, if an object is still
    in use and should not be removed, it gets set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The heap is constantly changing and so is the stack. Objects on the heap that
    do not have a connection to the step are eligible for GC. They are unreachable
    and there is no possible way for the application to be using these objects. The
    objects that are not ready for removal are marked; the unmarked objects will be
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: How exactly this is implemented differs depending on the implementation of Java
    and the specific garbage collector you are using. But at a high level, this process
    starts from the stack. All the object references on the stack are followed and
    the objects are marked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our previous example, this is how they would be marked. We are
    using the following code sample where we do not set the reference of `personList`
    to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Before the GC starts, all the objects are unmarked. This means the special bit
    is `0`, which is the value they get upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Before garbage collection starts, none of the objects is marked](img/Figure_4.4_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Before garbage collection starts, none of the objects is marked
  prefs: []
  type: TYPE_NORMAL
- en: So, to start off with, all of them are unmarked, as we can tell from all the
    `0` after the objects. The next step is to mark the objects with a connection
    to the stack by changing the `0` to a `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Marking step one: direct connection to the stack](img/Figure_4.5_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5 – Marking step one: direct connection to the stack'
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not enough to just mark the ones with a direct connection to the stack.
    Right now, the object referred to by `Person p1` would be eligible for GC even
    though it is reachable. This is also why the references of each object are also
    traveled and marked, until there are no more nested objects. *Figure 4**.6* shows
    what our example looks like after the marking phase.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – After marking](img/Figure_4.6_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – After marking
  prefs: []
  type: TYPE_NORMAL
- en: All the objects on our heap are marked, as we can tell by the `1` after every
    object. So, in our example, none of the objects is eligible for GC as they are
    all still reachable.
  prefs: []
  type: TYPE_NORMAL
- en: There are different algorithms that play an important role in the marking phase.
    The first one that we are going to have a look at is the stop-the-world approach.
  prefs: []
  type: TYPE_NORMAL
- en: Stop-the-world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think about how this could be done for a second. While you are checking all
    the variables on the stack and marking all their objects and the nested objects,
    new objects could have been created in the meantime. It’s possible that you missed
    that part of the stack. This would lead to unmarked objects (remember, objects
    are initially unmarked upon creation) that should have been marked, and they would
    be removed as a result. That would be very problematic.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this impacts performance as the garbage collector needs to pause
    the execution of the main application in order to make sure no new objects will
    be created during the marking phase. This strategy is called stop-the-world, which
    – as dramatic as it sounds – is a Java term. There also are other strategies in
    the field of computer science, one of them being reference counting, which we
    will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting and islands of isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another implementation approach is of counting the number of references on an
    object. All objects would contain a count of the number of times they were referenced
    as some sort of property. This way, executing GC is nothing more than just removing
    all the objects with a `0` for the number of times they are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that this is a lot better than pausing the application,
    and so, why don’t we use it? The answer to that is islands of isolation. This
    is not some modern-day social phenomenon; islands of isolation are objects that
    just reference each other without having a connection to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the stack and heap for the following code sample. We have a `Nest`
    class in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating two `Nest` instances and setting them to be each other’s `nest`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let’s have a look at what it would like to count the references and pause after
    line 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Overview after the creation of both Nest objects and assigning
    them to each other’s field](img/Figure_4.7_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Overview after the creation of both Nest objects and assigning
    them to each other’s field
  prefs: []
  type: TYPE_NORMAL
- en: After line 4, both counters are 2\. The objects are referenced by both the other
    object and the stack. This changes after line 5 and 6 since the references to
    the stack are removed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Overview after setting the stack references to null](img/Figure_4.8_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Overview after setting the stack references to null
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell by the code, after the execution of the line with comment 6
    at the end, both objects are unreachable from the stack. However, if we would
    use the counting of the references, they would both still have a `1`, since they
    are both referring to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these objects don’t have a `0` count but also do not have a connection
    to the stack. They are islands: islands of isolation. They should be garbage collected,
    but the simple counting garbage collector cannot detect them because they don’t
    have a reference count of `0`. The more advanced garbage collector, which marks
    all the elements with a connection to the stack that needs to pause the application,
    does garbage collect them, as they don’t have a connection to the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Java uses the more-accurate marking phase to pause the application.
    Without the marking garbage collector, islands of isolation would lead to a memory
    leak: memory that could be released but is never made available for the application
    to use again.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about how the memory is freed up after being marked.
  prefs: []
  type: TYPE_NORMAL
- en: Sweeping by the garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the objects that need to be kept are marked, it’s time to start the next
    phase to actually free the memory. This deletion of the objects is called sweeping
    in GC jargon. To make it more interesting, we have three kinds of sweeping:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal sweeping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweeping with compacting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweeping with copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to discuss all these in more detail with illustrations to help
    you understand what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: Normal sweeping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normal sweeping is the removal of unmarked objects. *Figure 4**.9* shows five
    objects in memory. Two of them, the ones with an **x** in them, will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Schematic overview of memory with marked objects](img/Figure_4.9_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Schematic overview of memory with marked objects
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory blocks are not of equal sizes; some of them are smaller while others
    are larger. After sweeping the unreachable objects, the memory looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Schematic overview of memory after sweeping](img/Figure_4.10_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Schematic overview of memory after sweeping
  prefs: []
  type: TYPE_NORMAL
- en: The memory has been freed up by the sweeping and the gaps in between the memory
    blocks can be allocated again. However, only blocks that fit in between the gaps
    can be stored there. The memory is now fragmented, and this can lead to problems
    with storing larger memory blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fragmentation of memory happens after storing the memory first and then removing
    blocks from the middle. In between the memory blocks, new memory can be allocated.
    This is shown in *Figure 4**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Allocation of new objects in fragmented memory](img/Figure_4.11_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Allocation of new objects in fragmented memory
  prefs: []
  type: TYPE_NORMAL
- en: The new memory blocks are stored in the gaps. This works well in the specific
    displayed situation, where the memory blocks fit the gaps. If the memory blocks
    don’t fit in between the gaps (or at the end in this overview), we have a problem.
    Let’s look at a situation where we want to store a new block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Attempting to store a large block of memory that is less than
    the memory available](img/Figure_4.12_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Attempting to store a large block of memory that is less than
    the memory available
  prefs: []
  type: TYPE_NORMAL
- en: If we would look at the total memory available, the block seen in the preceding
    figure would fit. However, we cannot store it in the fragmented memory as there
    isn’t enough contiguous memory available to store the new block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Schematic overview that shows that the new memory block doesn’t
    fit](img/Figure_4.13_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Schematic overview that shows that the new memory block doesn’t
    fit
  prefs: []
  type: TYPE_NORMAL
- en: 'Not being able to fit in a block of requested memory would lead to an error:
    `OutOfMemoryError`. Even though we are not out of memory and technically there
    is enough memory available to store the new block, it doesn’t fit because the
    memory that’s available is fragmented. This is a problem with normal sweeping.
    It is a very efficient and easy process, but it leads to fragmented memory. This
    process could be favorable if there is plenty of memory and the application just
    needs to free up memory fast. When memory is tighter, it is favorable to use one
    of the other options for sweeping: sweeping with compacting or sweeping with copying.
    Let’s have a look at sweeping with compacting first.'
  prefs: []
  type: TYPE_NORMAL
- en: Sweeping with compacting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sweeping with compacting is a two-step process. Just like in normal sweeping,
    the memory blocks are deleted. This time, we do not accept the fragmented memory
    as the end result but execute an extra step called compacting. This moves the
    blocks of memory to ensure there are no gaps between them. The process is shown
    in *Figure 4**.14*. We assume the same memory blocks are ready for removal, as
    shown in *Figure 4**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Sweeping with compacting](img/Figure_4.14_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Sweeping with compacting
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time we do not end up with fragmented memory. Therefore,
    we will not get `OutOfMemoryError`. That sounds amazing, but as always, magic
    comes at a price. In this case, the price is performance. The compacting of the
    memory is a costly process in terms of performance, since all the memory blocks
    need to be moved (and this needs to happen mostly sequentially).
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative to this costly compacting process and that’s sweeping
    with copying. Don’t forget about sweeping with compacting just yet as sweeping
    with copying comes with its own cost.
  prefs: []
  type: TYPE_NORMAL
- en: Sweeping with copying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sweeping with copying is a clever process. We need two memory regions for this.
    Instead of deleting the memory blocks we no longer need, we delete all the memory
    blocks! But not before we’ve copied the ones we still need to the second memory
    region (refer to *Figure 4**.15*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Sweeping with copying before the actual sweeping](img/Figure_4.15_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Sweeping with copying before the actual sweeping
  prefs: []
  type: TYPE_NORMAL
- en: First, we have our memory region with the objects that are no longer needed,
    and then we have a second memory region that is not allocated yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we copy all the objects we need to the second memory region.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Sweeping with copying after copying](img/Figure_4.16_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Sweeping with copying after copying
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only copied and not swept anything yet. That’s exactly what
    the next step is going to do: clear the first memory region, since all the objects
    we still need are kept in the second memory region. The result is shown in *Figure
    4**.17*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Schematic overview of the memory after sweeping with copying](img/Figure_4.17_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Schematic overview of the memory after sweeping with copying
  prefs: []
  type: TYPE_NORMAL
- en: After sweeping the first memory region, we have all our objects that are still
    reachable in the second memory region. This is better in terms of performance
    than sweeping with compacting, but as you can imagine, this requires more free
    memory to be available.
  prefs: []
  type: TYPE_NORMAL
- en: Which types of sweeping are used depends on the selected implementation of the
    garbage collector. There are rather many implementations out there. We are going
    to explore the most common ones in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GC implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard JVM has five implementations for GC. Other Java implementations
    can have other GC implementations, such as the garbage collectors from IBM and
    Azul. The way these work is relatively easy to grasp after understanding the following
    five implementations that come with the standard JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: Serial GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMS (concurrent mark sweep) GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: G1 GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZGC (Z garbage collector)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will examine in detail how these implementations work a little later (however,
    we will not be discussing all the different command-line options for each of them).
    But, before we discuss how these specific garbage collectors work, another concept
    needs to be addressed: the concept of generational GC.'
  prefs: []
  type: TYPE_NORMAL
- en: Generational GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a large Java application running, pausing the entire program in
    order to wait for the garbage collector to have marked every single live object
    would be a performance nightmare. Luckily, they thought of something cleverer
    by making use of the different generations on the heap. Not all of the soon-to-be-explained
    garbage collectors use this strategy, but some of them do.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of running a full garbage collector round at once, generational garbage
    collectors focus on a certain part of memory, for example, the young generation.
    This approach would work well for applications that have most of their objects
    die young. It saves a lot of marking.
  prefs: []
  type: TYPE_NORMAL
- en: The generational garbage collectors often work with a **remembered set**. This
    is a set that has all the references from objects to the young generation coming
    from the old generation. This way, the old generation does not need to be scanned
    since the references to the young generation are already in the remembered set.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that have most of their objects in the tenured generation will
    not thrive with the approach of focusing on the young generation with their GC.
    Since, in this scenario, the heap is especially heavy on the old generation, only
    collecting the young generation will not free a high ratio of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Often generational garbage collectors have to use different strategies for different
    memory areas. For example, the young generation could be garbage collected with
    a stop-the-world garbage collector that copies the entire set of reachable objects
    to the old generation and then deletes the young generation. Meanwhile, the old
    generation could work with compacting and perhaps an alternative to stop-the-world,
    such as the CMS garbage collector, which we’ll see while going over the different
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the different options for sweeping and both the stop-the-world
    and the generational garbage collector, we are in a better position to understand
    the five implementations that we listed earlier. (So, hold on, you’ve almost made
    it through this tough chapter!)
  prefs: []
  type: TYPE_NORMAL
- en: Serial GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **serial GC** runs on a single thread and uses the stop-the-world strategy.
    This means that the application is not running its main tasks when the garbage
    collector runs. It is the simplest option for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: For the young generation, it uses the mark strategy to identify which objects
    are eligible for GC and the sweep with copying approach for the actual freeing
    of the memory. For the old generation, it uses the mark and sweep with compacting
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: The serial garbage collector is ideal for small programs, but for larger programs
    such as **Spring** or **Quarkus** applications, there are better options.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **parallel garbage collector** is the default garbage collector of Java
    8\. It uses the mark-and-copy approach for the young generation and the mark-sweep-compact
    approach for the old generation, just like the serial garbage collector. However,
    and this might come as a surprise, it does so in parallel. In this case, parallel
    means that uses multiple threads to clean up the heap space. So, there is not
    one single thread taking care of the marking, copying, and compacting phases,
    but multiple threads. Even though it is still stop-the-world, it performs better
    than the serial garbage collector, since the world needs to be stopped for a shorter
    amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: The parallel garbage collector will work well on machines with multiple cores.
    On (rarer) single-core machines, the serial garbage collector is probably a better
    choice, due to the costs of managing multiple threads and not really parallel
    processing on the single core.
  prefs: []
  type: TYPE_NORMAL
- en: CMS GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Concurrent Mark Sweep Garbage Collector** (**CMS GC**) has an improved
    mark-and-sweep algorithm. It manages to do this with multiple threads and reduces
    the pause time drastically. This is the main difference between CMS GC and parallel
    garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Not all systems can handle sharing resources between the main application and
    the garbage collector, though, but if they can, it is a great upgrade in terms
    of performance compared to the parallel garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The CMS GC is a generational garbage collector as well. It has separate cycles
    for the young and old generation. For the young generation, it uses mark and copy
    with stop-the-world. So, during the GC of the young generation, the main application
    threads are paused.
  prefs: []
  type: TYPE_NORMAL
- en: The old generation is garbage collected with *mostly concurrent* mark and sweep.
    The term mostly concurrent means that it does most of the GC concurrently, but
    it will still use stop-the-world twice in a GC cycle. It pauses all the main application
    threads for the first time at the very beginning, then during the marking for
    a very short time, and then for a (usually) somewhat longer time around the middle
    of the GC cycle to do the final marking.
  prefs: []
  type: TYPE_NORMAL
- en: These pauses are typically very short, because the CMS GC attempts to collect
    enough of the old generation while running concurrently to the main application
    threads and, this way, prevent it from getting full. Sometimes, this is not possible.
    If the CMS GC cannot free up enough while the old generation is getting full,
    or the application fails to allocate an object, the CMS GC pauses all the application
    threads and the main focus shifts to GC. The situation in which this garbage collector
    fails to do the GC mostly concurrently is called *concurrent* *mode failure*.
  prefs: []
  type: TYPE_NORMAL
- en: If the collector then still cannot free up enough memory, `OutOfMemoryError`
    gets thrown. This happens when 98% of the application time is spent on GC and
    less than 2% of the heap is recovered.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a lot different from the other garbage collectors that we’ve discussed.
    The very short pauses of the CMS GC sound pretty good already, but there are even
    later upgrades available. Let’s have a look at the G1 GC.
  prefs: []
  type: TYPE_NORMAL
- en: G1 GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **G1** (**garbage-first**) garbage collector came with Java 7 (minor version
    4) and is an upgrade of the CMS GC. It combines different algorithms in a clever
    way. The G1 collector is parallel, concurrent, and aims for short pauses of the
    application. It employs a technique called incrementally compacting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The G1 garbage collector divides the heap into smaller regions: much smaller
    than the generational garbage collector. It works with these smaller memory segments
    to mark and sweep them. It keeps track of the amount of reachable and unreachable
    objects per memory region. The regions with the most unreachable objects are garbage
    collected first since that frees up the most memory. That’s why it is called the
    garbage-first garbage collector. Regions with the most garbage are collected first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does all this while copying objects from one region to another region. This
    will result in freeing up the first region completely. This way the G1 GC kills
    two birds with one stone: achieving GC and compacting at the same time. This is
    why it is such an upgrade compared to earlier mentioned garbage collector.'
  prefs: []
  type: TYPE_NORMAL
- en: The G1 GC is a great garbage collector. You may wonder whether this garbage
    collector manages to work without stop-the-world. No, the compacting still needs
    to happen this way. But due to the smaller regions, the pauses are much shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another new feature of the G1 GC garbage collector is *string deduplication*.
    This is literally what you’d think it is: the garbage collector runs a process
    to inspect the `String` objects. When it finds `String` objects that contain the
    same content but refer to different `char` arrays on the heap, they will be updated
    to both point to the same `char` array. This makes the other `char` array eligible
    for GC and this way, the memory usage is optimized. As if this wasn’t exciting
    enough, it happens completely concurrently! This option will need to be enabled
    using the following command: `-XX:+UseStringDeduplication`.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the CMS GC, the G1 GC tries to do a lot of the GC concurrently. So,
    the application threads don’t need to be paused most of the time. However, if
    the G1 GC cannot free up enough memory and the application is allocating more
    than can be freed up concurrently, the application threads need to be paused.
  prefs: []
  type: TYPE_NORMAL
- en: The G1 garbage collector is the go-to GC for powerful systems that are high
    performing and have a large memory space. This is not the most recently added
    garbage collector though. Let’s have a look at the ZGC.
  prefs: []
  type: TYPE_NORMAL
- en: Z GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 15 gave us yet another production-ready implementation of the garbage collector,
    the **Z garbage collector** (**ZGC**). It does all the garbage collecting concurrently
    and does not need to pause the application for more than 10 ms per pause.
  prefs: []
  type: TYPE_NORMAL
- en: It manages to do this by starting with marking the live objects. It doesn’t
    keep a map but uses **reference coloring**. Reference coloring means that the
    live state of reference is stored as the bits that are part of the reference.
    This requires some extra bits, which is why the ZGC only works on 64-bit systems
    and not on 32-bit systems.
  prefs: []
  type: TYPE_NORMAL
- en: Fragmentation is avoided by using relocation. This process happens in parallel
    with the application in order to avoid pauses of more than 10 ms, but this happens
    while the application is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Without extra measurements, this could lead to unpleasant surprises. Imagine
    that we were trying to access a certain object with the reference, but while doing
    so, it got relocated and has a new reference. The old memory location could be
    overwritten or cleared already. In such a scenario, debugging would be a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Java team would not push a garbage collector to production with
    issues like that. They introduced load barriers to deal with this. The load barriers
    run whenever a reference from the heap is loaded. It checks the metadata bits
    of the reference and, based on the result, it may or may not do some processing
    before retrieving the result. This magic is called remapping.
  prefs: []
  type: TYPE_NORMAL
- en: The five garbage collectors we’ve just discussed are the main options to choose
    from at the moment of writing this book. Your options depend on the Java version
    that you’re using, the system configuration, and the type of application. In order
    to make sure the garbage collector performs well, monitoring should be in place.
    This is exactly what we’re going to look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring GC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to decide upon the right garbage collector, you’ll need to know your
    application. There are a few metrics that are especially important for the GC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Allocation rate**: How fast the application allocates objects in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap population**: The number of objects and their size living on the heap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation rate**: How often references are updated in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Average object live time**: The time the objects live on average. One application
    may have objects that die young, while another application may have objects that
    live longer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monitoring of the performance of the GC requires different metrics. The
    most important ones are mark time, compaction time, and GC cycle time. The mark
    time entails the time it takes the garbage collector to find all the live objects
    on the heap. Compaction time is how long it takes the garbage collector to free
    up all the space and relocate the objects. The GC cycle time is how long it takes
    the garbage collector to perform a full GC.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is little heap space available, you’ll see the CPU usage for
    GC increase. Choosing the right amount of memory will improve the performance
    of your application. The greater the amount of available memory, the easier the
    garbage collector can function.
  prefs: []
  type: TYPE_NORMAL
- en: The copy-and-compact collector needs to have enough space available for copying
    and relocating. This is a much more costly process when available memory is limited.
    Only a small memory segment could be copied to free up a bit more so that hopefully
    a bit more can be copied next time, and so on. The CPU usage of the garbage collector
    is the highest on low memory. On the other end of the spectrum, in the hypothetical
    situation that we would have unlimited memory, we wouldn’t really need to garbage
    collect at all.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18762_06.xhtml#_idTextAnchor086), we’re going to have a look
    at the usage of JVM tuning for memory management to improve the functioning of
    the JVM memory. There, we’ll also see how we can tune a garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how the GC of the heap works in more depth. Objects
    on the heap are eligible for GC when they don’t have a connection to the stack
    anymore, whether directly or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector determines which objects are eligible for GC in the marking
    phase. Objects that have a connection to the stack are marked. The objects that
    are eligible for GC are unmarked.
  prefs: []
  type: TYPE_NORMAL
- en: After this marking phase, the actual removal happens in the sweeping phase.
    We discussed three kinds of sweeping, normal sweeping, sweeping with compacting,
    and sweeping with copying.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the different implementations of the garbage collectors.
    A subset of them are the generational garbage collectors. These garbage collectors
    focus on one of the generations of the heap and, consequently, do not need to
    scan all the objects of the heap during the marking phase. After that, we discussed
    five common implementations of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to zoom in on the Metaspace.
  prefs: []
  type: TYPE_NORMAL
