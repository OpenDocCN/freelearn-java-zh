- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Freeing Memory with Garbage Collection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用垃圾回收释放内存
- en: Allocated memory needs to be deallocated when it is no longer needed. In some
    languages, the developer needs to take care of that. In some others, such as Java,
    this happens automatically. For Java, the garbage collector does this. The deallocation
    of memory is necessary for an application to keep running. Without the ability
    to free memory when it is no longer needed, we would only be able to allocate
    memory once, and eventually, we would run out of memory. In this chapter, we will
    be learning more about freeing memory on the heap using the garbage collector.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要分配的内存时，需要释放它。在某些语言中，开发者需要负责这一点。在其他一些语言中，例如Java，这会自动发生。对于Java，垃圾收集器会这样做。内存的释放对于应用程序保持运行是必要的。如果没有在不再需要时释放内存的能力，我们只能分配一次内存，最终我们会耗尽内存。在本章中，我们将学习如何使用垃圾收集器在堆上释放内存。
- en: This can be a tough topic! Before you are ready for this chapter, you’ll need
    to have a clear understanding of the heap space. Again, we’ll visualize the concepts
    as much as possible to increase your understanding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的话题！在你准备好这一章之前，你需要对堆空间有一个清晰的理解。再次强调，我们将尽可能地可视化这些概念，以增加你的理解。
- en: 'Here are the topics that will be discussed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将讨论以下主题：
- en: Object eligibility for **garbage** **collection** (**GC**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的**垃圾回收**（**GC**）资格
- en: Marking by the garbage collector
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器的标记
- en: Sweeping by the garbage collector
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器的清除
- en: Different GC implementations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的GC实现
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management)。
- en: Being eligible for GC
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有资格进行GC
- en: We already know that objects on the heap are removed when they are no longer
    needed. The right question to ask, then, would be, *when are objects no* *longer
    needed?*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，当堆上的对象不再需要时，它们会被移除。那么，接下来要问的正确问题是，*对象何时不再需要*？
- en: 'That question is easy to answer but leads to a complex problem at the same
    time. Let’s first have a look at the answer: *objects on the heap are no longer
    needed when they don’t have a connection to* *the stack*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那个问题很容易回答，但同时也引出了一个复杂的问题。让我们首先看看答案：*当对象不再与* *栈* *有连接时，堆上的对象就不再需要了*。
- en: 'Objects don’t have a connection to the stack when the stack doesn’t store the
    reference to the object in a variable. Here is a simple example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈不存储对象的引用变量时，对象与栈没有连接。这里有一个简单的例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the first line, we create the object, which gets created on the heap. The
    `o` variable holds a reference to an object of type `Object` on the stack. We
    use the object because we have the reference stored. In this case, we are printing
    it on the second line of the example, which is clearly a rather silly output since
    the `toString()` method of `Object` is only going to be returning the following
    output to the console:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了对象，它在堆上被创建。`o`变量持有对栈上`Object`类型对象的引用。我们使用对象是因为我们存储了引用。在这种情况下，我们在示例的第二行打印它，这显然是一个相当愚蠢的输出，因为`Object`的`toString()`方法只会返回以下输出到控制台：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the next line, we set the variable to `null`. This overrides the reference
    to the object and simply points nowhere, as there is no object stored in `o` anymore.
    Nothing else in our application holds a reference to the `Object` we’ve created.
    Thus, it becomes eligible for GC.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们将变量设置为`null`。这覆盖了对对象的引用，并且简单地指向了某个地方，因为没有对象存储在`o`中。我们的应用程序中没有其他东西持有对创建的`Object`的引用。因此，它变得有资格进行GC。
- en: This example was rather simple. To demonstrate how difficult this problem actually
    is, let’s look at a slightly more complex problem and illustrate it with some
    diagrams. The question that we need to answer here is, *which objects are eligible
    for GC on* *each line?*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当简单。为了展示这个问题实际上有多复杂，让我们看看一个稍微复杂一些的问题，并用一些图表来展示。我们需要回答的问题是，*在每一行中，哪些对象有资格进行GC*？
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Figure 4.1 – Overview of the stack and heap for the eligibility example](img/Figure_4.1_B18762.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 资格示例的栈和堆概述](img/Figure_4.1_B18762.jpg)'
- en: Figure 4.1 – Overview of the stack and heap for the eligibility example
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 资格示例的栈和堆概述
- en: 'On the fifth line, we set our `p1` to `null`. Does this mean that `p1` is eligible
    for GC? Quick reminder: an object on the heap is eligible for GC as soon as it
    doesn’t have a connection to the stack anymore. But let’s look at what happens
    after executing line 5:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五行，我们将 `p1` 设置为 `null`。这意味着 `p1` 有资格进行 GC 吗？快速提醒：堆上的对象一旦不再与栈有连接，就有资格进行 GC。但是，让我们看看执行第
    5 行之后会发生什么：
- en: '![Figure 4.2 – Overview of the heap and the stack after executing line 5](img/Figure_4.2_B18762.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 执行第 5 行后的堆和栈概述](img/Figure_4.2_B18762.jpg)'
- en: Figure 4.2 – Overview of the heap and the stack after executing line 5
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 执行第 5 行后的堆和栈概述
- en: As we can see, the connection to the stack in `p1` is gone. But this doesn’t
    mean that there’s no connection to the stack anymore. There’s still an indirect
    connection. We can go from the stack to the list of `Person` object, and from
    there we can still access the object that `p1` was holding a reference to, since
    the list still holds a reference to that object. Therefore, none of the objects
    on the heap is eligible for GC after line 5.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`p1` 与栈的连接已经消失。但这并不意味着没有与栈的连接。仍然存在间接连接。我们可以从栈到 `Person` 对象的列表，然后我们可以继续访问
    `p1` 持有引用的对象，因为列表仍然持有对该对象的引用。因此，在执行第 5 行之后，堆上的所有对象都没有资格进行 GC。
- en: This changes after line 6\. At line 6, we set the variable that held the list
    to `null`. This means that `p1` no longer has a connection to the stack after
    this line, as you can see in *Figure 4**.3*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这在执行第 6 行后发生变化。在第 6 行，我们将持有列表的变量设置为 `null`。这意味着 `p1` 在此行之后不再与栈有连接，正如你在 *图 4.3*
    中可以看到的那样。
- en: '![Figure 4.3 – Overview of the heap and stack at the end of the code](img/Figure_4.3_B18762.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 代码结束时的堆和栈概述](img/Figure_4.3_B18762.jpg)'
- en: Figure 4.3 – Overview of the heap and stack at the end of the code
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 代码结束时的堆和栈概述
- en: There is no connection between the list and the stack, and now both the `List`
    object and the first instance of the `Person` object are eligible for GC. Meanwhile,
    the `p2` and `p3` variables still hold a reference to the objects on the heap,
    and therefore these objects are not eligible for GC.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和栈之间没有连接，现在 `List` 对象和 `Person` 对象的第一个实例都有资格进行 GC。同时，`p2` 和 `p3` 变量仍然持有对堆上对象的引用，因此这些对象没有资格进行
    GC。
- en: It’s not hard to tell which ones are ready for GC once you understand the direct
    and indirect connection from the heap back to the stack. However, figuring out
    which ones have a connection with the stack will require some time, and this will
    slow down the rest of the application. There are a few ways to do it, but each
    comes with its own downsides with respect to accuracy or performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了从堆到栈的直接和间接连接，就不难判断哪些对象已准备好进行 GC。然而，确定哪些对象与栈有连接将需要一些时间，这将减慢应用程序的其他部分。有几种方法可以做到这一点，但每种方法都有其自身的缺点，无论是关于准确性还是性能。
- en: 'This complex problem is language-agnostic: how do we determine whether an object
    still has a connection to the stack? The solution we’ll be discussing is of course
    Java-specific. Finding objects that are no longer needed is done by the garbage
    collector in the marking phase. The marking phase consists of a special algorithm
    that determines what objects are eligible for GC.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂的问题与语言无关：我们如何确定一个对象是否仍然与栈有连接？我们将讨论的解决方案当然是 Java 特定的。在标记阶段，通过垃圾回收器找到不再需要的对象。标记阶段由一个特殊的算法组成，该算法确定哪些对象有资格进行
    GC。
- en: Marking by the garbage collector
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收器的标记
- en: Marking marks any live objects and anything not marked as ready to be garbage
    collected. The objects keep a special bit that determines whether they are marked
    or not. Upon creation, the bit is `0`. In the mark phase, if an object is still
    in use and should not be removed, it gets set to `1`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 标记会标记任何活动对象以及那些未标记为准备垃圾回收的对象。对象保留一个特殊的位来决定它们是否被标记。在创建时，该位是 `0`。在标记阶段，如果一个对象仍在使用且不应被移除，则将其设置为
    `1`。
- en: The heap is constantly changing and so is the stack. Objects on the heap that
    do not have a connection to the step are eligible for GC. They are unreachable
    and there is no possible way for the application to be using these objects. The
    objects that are not ready for removal are marked; the unmarked objects will be
    removed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和栈都在不断变化。堆上没有与步骤连接的对象有资格进行 GC。它们是不可达的，应用程序没有可能使用这些对象。那些尚未准备好移除的对象被标记；未标记的对象将被移除。
- en: How exactly this is implemented differs depending on the implementation of Java
    and the specific garbage collector you are using. But at a high level, this process
    starts from the stack. All the object references on the stack are followed and
    the objects are marked.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这究竟是如何实现的，取决于 Java 的实现以及你使用的特定垃圾回收器。但从高层次来看，这个过程从栈开始。栈上所有对象引用都会被跟踪，对象会被标记。
- en: 'If we look at our previous example, this is how they would be marked. We are
    using the following code sample where we do not set the reference of `personList`
    to `null`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾之前的例子，这就是它们的标记方式。我们使用以下代码示例，其中我们没有将`personList`的引用设置为`null`：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before the GC starts, all the objects are unmarked. This means the special bit
    is `0`, which is the value they get upon creation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾回收开始之前，所有对象都是未标记的。这意味着特殊位是 `0`，这是它们在创建时得到的值。
- en: '![Figure 4.4 – Before garbage collection starts, none of the objects is marked](img/Figure_4.4_B18762.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 在垃圾回收开始之前，没有任何对象被标记](img/Figure_4.4_B18762.jpg)'
- en: Figure 4.4 – Before garbage collection starts, none of the objects is marked
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 在垃圾回收开始之前，没有任何对象被标记
- en: So, to start off with, all of them are unmarked, as we can tell from all the
    `0` after the objects. The next step is to mark the objects with a connection
    to the stack by changing the `0` to a `1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，所有对象都是未标记的，正如我们可以从对象后面的所有 `0` 来判断。下一步是将与栈有连接的对象标记，通过将 `0` 改为 `1`。
- en: '![Figure 4.5 – Marking step one: direct connection to the stack](img/Figure_4.5_B18762.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 标记步骤一：与栈的直接连接](img/Figure_4.5_B18762.jpg)'
- en: 'Figure 4.5 – Marking step one: direct connection to the stack'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 标记步骤一：与栈的直接连接
- en: But it’s not enough to just mark the ones with a direct connection to the stack.
    Right now, the object referred to by `Person p1` would be eligible for GC even
    though it is reachable. This is also why the references of each object are also
    traveled and marked, until there are no more nested objects. *Figure 4**.6* shows
    what our example looks like after the marking phase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅标记与栈有直接连接的对象是不够的。目前，由`Person p1`引用的对象即使可达，也有资格进行垃圾回收。这也是为什么每个对象的引用也会被遍历并标记，直到没有更多的嵌套对象。*图
    4.6* 展示了标记阶段之后我们的例子看起来是什么样子。
- en: '![Figure 4.6 – After marking](img/Figure_4.6_B18762.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 标记后](img/Figure_4.6_B18762.jpg)'
- en: Figure 4.6 – After marking
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 标记后
- en: All the objects on our heap are marked, as we can tell by the `1` after every
    object. So, in our example, none of the objects is eligible for GC as they are
    all still reachable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们堆上的所有对象都被标记了，我们可以从每个对象后面的 `1` 来判断。所以，在我们的例子中，没有任何对象有资格进行垃圾回收，因为它们仍然都是可达的。
- en: There are different algorithms that play an important role in the marking phase.
    The first one that we are going to have a look at is the stop-the-world approach.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记阶段，有不同算法发挥着重要作用。我们将首先探讨的是停止世界方法。
- en: Stop-the-world
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止世界
- en: Think about how this could be done for a second. While you are checking all
    the variables on the stack and marking all their objects and the nested objects,
    new objects could have been created in the meantime. It’s possible that you missed
    that part of the stack. This would lead to unmarked objects (remember, objects
    are initially unmarked upon creation) that should have been marked, and they would
    be removed as a result. That would be very problematic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这该如何实现。当你检查栈上的所有变量并标记它们及其嵌套对象时，新对象可能在此期间被创建。有可能你错过了栈的那部分。这会导致未标记的对象（记住，对象在创建时最初是未标记的）应该被标记，结果它们会被移除。这将非常有问题。
- en: The solution to this impacts performance as the garbage collector needs to pause
    the execution of the main application in order to make sure no new objects will
    be created during the marking phase. This strategy is called stop-the-world, which
    – as dramatic as it sounds – is a Java term. There also are other strategies in
    the field of computer science, one of them being reference counting, which we
    will look at next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题会影响性能，因为垃圾回收器需要暂停主应用程序的执行，以确保在标记阶段不会创建新的对象。这种策略被称为停止世界，尽管听起来很戏剧化，但它是一个
    Java 术语。在计算机科学领域还有其他策略，其中之一是引用计数，我们将在下一节中探讨。
- en: Reference counting and islands of isolation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用计数和隔离孤岛
- en: Another implementation approach is of counting the number of references on an
    object. All objects would contain a count of the number of times they were referenced
    as some sort of property. This way, executing GC is nothing more than just removing
    all the objects with a `0` for the number of times they are referenced.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方法是计数一个对象上的引用数量。所有对象都会包含一个计数，表示它们被引用的次数作为某种属性。这样，执行 GC 仅仅是移除所有引用次数为 `0`
    的对象。
- en: You might be thinking that this is a lot better than pausing the application,
    and so, why don’t we use it? The answer to that is islands of isolation. This
    is not some modern-day social phenomenon; islands of isolation are objects that
    just reference each other without having a connection to the stack.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这比暂停应用程序要好得多，那么为什么我们不使用它呢？答案是孤岛。这不是某种现代社会现象；孤岛是那些仅仅相互引用而没有与堆栈连接的对象。
- en: 'Let’s explore the stack and heap for the following code sample. We have a `Nest`
    class in this example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索以下代码示例的栈和堆。在这个例子中，我们有一个 `Nest` 类：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are creating two `Nest` instances and setting them to be each other’s `nest`
    property:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 `Nest` 实例，并将它们设置为彼此的 `nest` 属性：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let’s have a look at what it would like to count the references and pause after
    line 4.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在第四行之后想要计数引用并暂停的情况。
- en: '![Figure 4.7 – Overview after the creation of both Nest objects and assigning
    them to each other’s field](img/Figure_4.7_B18762.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 创建两个 Nest 对象并将它们分配给彼此的字段后的概览](img/Figure_4.7_B18762.jpg)'
- en: Figure 4.7 – Overview after the creation of both Nest objects and assigning
    them to each other’s field
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 创建两个 Nest 对象并将它们分配给彼此的字段后的概览
- en: After line 4, both counters are 2\. The objects are referenced by both the other
    object and the stack. This changes after line 5 and 6 since the references to
    the stack are removed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行之后，两个计数器都是 2。对象被另一个对象和堆栈所引用。这会在第五行和第六行之后改变，因为堆栈的引用被移除了。
- en: '![Figure 4.8 – Overview after setting the stack references to null](img/Figure_4.8_B18762.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 设置堆栈引用为 null 后的概览](img/Figure_4.8_B18762.jpg)'
- en: Figure 4.8 – Overview after setting the stack references to null
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 设置堆栈引用为 null 后的概览
- en: As you can tell by the code, after the execution of the line with comment 6
    at the end, both objects are unreachable from the stack. However, if we would
    use the counting of the references, they would both still have a `1`, since they
    are both referring to each other.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，在执行末尾注释 6 的行之后，两个对象都无法从堆栈中访问。然而，如果我们使用引用计数，它们仍然都会有一个 `1`，因为它们都相互引用。
- en: 'Since these objects don’t have a `0` count but also do not have a connection
    to the stack. They are islands: islands of isolation. They should be garbage collected,
    but the simple counting garbage collector cannot detect them because they don’t
    have a reference count of `0`. The more advanced garbage collector, which marks
    all the elements with a connection to the stack that needs to pause the application,
    does garbage collect them, as they don’t have a connection to the stack.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些对象没有 `0` 的计数，但也没有与堆栈的连接。它们是孤岛：孤立的孤岛。它们应该被垃圾收集，但简单的计数垃圾收集器无法检测到它们，因为它们没有
    `0` 的引用计数。更高级的垃圾收集器，它会标记所有与堆栈有连接且需要暂停应用程序的元素，会将它们垃圾收集，因为它们没有与堆栈的连接。
- en: 'Therefore, Java uses the more-accurate marking phase to pause the application.
    Without the marking garbage collector, islands of isolation would lead to a memory
    leak: memory that could be released but is never made available for the application
    to use again.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java 使用更精确的标记阶段来暂停应用程序。如果没有标记垃圾收集器，孤岛会导致内存泄漏：本可以释放但从未再次提供给应用程序使用的内存。
- en: Next, let’s talk about how the memory is freed up after being marked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈标记之后如何释放内存。
- en: Sweeping by the garbage collector
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器清扫
- en: 'Once the objects that need to be kept are marked, it’s time to start the next
    phase to actually free the memory. This deletion of the objects is called sweeping
    in GC jargon. To make it more interesting, we have three kinds of sweeping:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦需要保留的对象被标记，就到了开始下一阶段以实际释放内存的时候了。在 GC 术语中，这种对象的删除称为清扫。为了使其更有趣，我们有三种清扫方式：
- en: Normal sweeping
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常清扫
- en: Sweeping with compacting
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩清扫
- en: Sweeping with copying
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制清扫
- en: We are going to discuss all these in more detail with illustrations to help
    you understand what’s going on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过插图详细讨论所有这些，以帮助您理解正在发生的事情。
- en: Normal sweeping
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正常清除
- en: Normal sweeping is the removal of unmarked objects. *Figure 4**.9* shows five
    objects in memory. Two of them, the ones with an **x** in them, will be removed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正常清除是移除未标记的对象。*图 4.9* 显示了内存中的五个对象。其中两个，带有 **x** 的那些，将被移除。
- en: '![Figure 4.9 – Schematic overview of memory with marked objects](img/Figure_4.9_B18762.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 带有标记对象的内存示意图](img/Figure_4.9_B18762.jpg)'
- en: Figure 4.9 – Schematic overview of memory with marked objects
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 带有标记对象的内存示意图
- en: 'The memory blocks are not of equal sizes; some of them are smaller while others
    are larger. After sweeping the unreachable objects, the memory looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 内存块的大小并不相等；其中一些较小，而另一些较大。在清除不可达的对象之后，内存看起来如下：
- en: '![Figure 4.10 – Schematic overview of memory after sweeping](img/Figure_4.10_B18762.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 清除后的内存示意图](img/Figure_4.10_B18762.jpg)'
- en: Figure 4.10 – Schematic overview of memory after sweeping
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 清除后的内存示意图
- en: The memory has been freed up by the sweeping and the gaps in between the memory
    blocks can be allocated again. However, only blocks that fit in between the gaps
    can be stored there. The memory is now fragmented, and this can lead to problems
    with storing larger memory blocks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过清除和内存块之间的间隙，内存已被释放，可以再次分配。然而，只有适合间隙的块才能存储在那里。现在内存是碎片化的，这可能导致存储较大内存块时出现问题。
- en: Fragmentation
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碎片化
- en: Fragmentation of memory happens after storing the memory first and then removing
    blocks from the middle. In between the memory blocks, new memory can be allocated.
    This is shown in *Figure 4**.11*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在首先存储内存然后从中移除块之后，会发生内存碎片化。在内存块之间，可以分配新的内存。这如图 *图 4.11* 所示。
- en: '![Figure 4.11 – Allocation of new objects in fragmented memory](img/Figure_4.11_B18762.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 分散内存中新对象分配](img/Figure_4.11_B18762.jpg)'
- en: Figure 4.11 – Allocation of new objects in fragmented memory
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 分散内存中新对象分配
- en: The new memory blocks are stored in the gaps. This works well in the specific
    displayed situation, where the memory blocks fit the gaps. If the memory blocks
    don’t fit in between the gaps (or at the end in this overview), we have a problem.
    Let’s look at a situation where we want to store a new block.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 新的内存块存储在间隙中。在特定显示的情况下，这种方法效果很好，因为内存块适合间隙。如果内存块不适合间隙之间（或在此概述的末尾），我们就会遇到问题。让我们看看我们想要存储一个新块的情况。
- en: '![Figure 4.12 – Attempting to store a large block of memory that is less than
    the memory available](img/Figure_4.12_B18762.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 尝试存储小于可用内存的大块内存](img/Figure_4.12_B18762.jpg)'
- en: Figure 4.12 – Attempting to store a large block of memory that is less than
    the memory available
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 尝试存储小于可用内存的大块内存
- en: If we would look at the total memory available, the block seen in the preceding
    figure would fit. However, we cannot store it in the fragmented memory as there
    isn’t enough contiguous memory available to store the new block.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看总的可用内存，前面图中的块是适合的。然而，我们无法在碎片化内存中存储它，因为没有足够的连续内存来存储新块。
- en: '![Figure 4.13 – Schematic overview that shows that the new memory block doesn’t
    fit](img/Figure_4.13_B18762.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 示意概述显示新内存块不合适](img/Figure_4.13_B18762.jpg)'
- en: Figure 4.13 – Schematic overview that shows that the new memory block doesn’t
    fit
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 示意概述显示新内存块不合适
- en: 'Not being able to fit in a block of requested memory would lead to an error:
    `OutOfMemoryError`. Even though we are not out of memory and technically there
    is enough memory available to store the new block, it doesn’t fit because the
    memory that’s available is fragmented. This is a problem with normal sweeping.
    It is a very efficient and easy process, but it leads to fragmented memory. This
    process could be favorable if there is plenty of memory and the application just
    needs to free up memory fast. When memory is tighter, it is favorable to use one
    of the other options for sweeping: sweeping with compacting or sweeping with copying.
    Let’s have a look at sweeping with compacting first.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的内存块无法容纳，将导致错误：`OutOfMemoryError`。尽管我们没有用完内存，并且从技术上讲有足够的内存来存储新的块，但它无法容纳，因为可用的内存是碎片化的。这是正常清除操作的问题。这是一个非常高效且简单的过程，但它会导致内存碎片化。如果内存充足，并且应用程序只需要快速释放内存，这个过程可能是可取的。当内存更紧张时，最好使用其他清除操作的选项之一：压缩后的清除操作或复制后的清除操作。让我们首先看看压缩后的清除操作。
- en: Sweeping with compacting
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩后的清除操作
- en: Sweeping with compacting is a two-step process. Just like in normal sweeping,
    the memory blocks are deleted. This time, we do not accept the fragmented memory
    as the end result but execute an extra step called compacting. This moves the
    blocks of memory to ensure there are no gaps between them. The process is shown
    in *Figure 4**.14*. We assume the same memory blocks are ready for removal, as
    shown in *Figure 4**.9*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩后的清除操作是一个两步过程。就像在正常清除操作中一样，内存块被删除。这次，我们不接受碎片化的内存作为最终结果，而是执行一个额外的步骤，称为压缩。这会将内存块移动以确保它们之间没有间隙。过程如图
    *4.14* 所示。我们假设与图 *4.9* 所示相同的内存块已准备好删除。
- en: '![Figure 4.14 – Sweeping with compacting](img/Figure_4.14_B18762.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 压缩后的清除操作](img/Figure_4.14_B18762.jpg)'
- en: Figure 4.14 – Sweeping with compacting
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 压缩后的清除操作
- en: As you can see, this time we do not end up with fragmented memory. Therefore,
    we will not get `OutOfMemoryError`. That sounds amazing, but as always, magic
    comes at a price. In this case, the price is performance. The compacting of the
    memory is a costly process in terms of performance, since all the memory blocks
    need to be moved (and this needs to happen mostly sequentially).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次我们没有得到碎片化的内存。因此，我们不会得到 `OutOfMemoryError`。这听起来很棒，但就像往常一样，魔法是有代价的。在这种情况下，代价是性能。从性能的角度来看，内存的压缩是一个代价高昂的过程，因为所有内存块都需要移动（这通常需要按顺序进行）。
- en: There is an alternative to this costly compacting process and that’s sweeping
    with copying. Don’t forget about sweeping with compacting just yet as sweeping
    with copying comes with its own cost.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代价高昂的压缩过程有一个替代方案，那就是复制后的清除操作。别忘了压缩后的清除操作，因为复制后的清除操作也有其自身的成本。
- en: Sweeping with copying
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制后的清除操作
- en: Sweeping with copying is a clever process. We need two memory regions for this.
    Instead of deleting the memory blocks we no longer need, we delete all the memory
    blocks! But not before we’ve copied the ones we still need to the second memory
    region (refer to *Figure 4**.15*).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 复制后的清除操作是一个巧妙的过程。为此我们需要两个内存区域。我们不是删除不再需要的内存块，而是删除所有内存块！但在删除之前，我们需要将我们仍然需要的内存块复制到第二个内存区域（参见图
    *4.15*）。
- en: '![Figure 4.15 – Sweeping with copying before the actual sweeping](img/Figure_4.15_B18762.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 实际清除操作前的复制操作](img/Figure_4.15_B18762.jpg)'
- en: Figure 4.15 – Sweeping with copying before the actual sweeping
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 实际清除操作前的复制操作
- en: First, we have our memory region with the objects that are no longer needed,
    and then we have a second memory region that is not allocated yet.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的内存区域，其中包含不再需要的对象，然后我们有一个尚未分配的第二个内存区域。
- en: In the next step, we copy all the objects we need to the second memory region.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将所有需要的对象复制到第二个内存区域。
- en: '![Figure 4.16 – Sweeping with copying after copying](img/Figure_4.16_B18762.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 复制后的清除操作](img/Figure_4.16_B18762.jpg)'
- en: Figure 4.16 – Sweeping with copying after copying
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 复制后的清除操作
- en: 'So far, we have only copied and not swept anything yet. That’s exactly what
    the next step is going to do: clear the first memory region, since all the objects
    we still need are kept in the second memory region. The result is shown in *Figure
    4**.17*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只进行了复制，还没有进行清除。这正是下一步将要做的：清除第一个内存区域，因为所有我们仍然需要的对象都保存在第二个内存区域中。结果如图 *4.17*
    所示。
- en: '![Figure 4.17 – Schematic overview of the memory after sweeping with copying](img/Figure_4.17_B18762.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 清除操作后的内存示意图](img/Figure_4.17_B18762.jpg)'
- en: Figure 4.17 – Schematic overview of the memory after sweeping with copying
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 使用复制清扫后的内存示意图
- en: After sweeping the first memory region, we have all our objects that are still
    reachable in the second memory region. This is better in terms of performance
    than sweeping with compacting, but as you can imagine, this requires more free
    memory to be available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在清扫第一个内存区域之后，我们所有的对象都仍然可以在第二个内存区域中访问。这在性能上比带有压缩的清扫更好，但正如你可以想象的那样，这需要更多的可用空闲内存。
- en: Which types of sweeping are used depends on the selected implementation of the
    garbage collector. There are rather many implementations out there. We are going
    to explore the most common ones in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的清扫类型取决于垃圾回收器的选择实现。现在有很多实现。我们将在下一节中探讨最常见的一些。
- en: Exploring GC implementations
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GC实现
- en: 'The standard JVM has five implementations for GC. Other Java implementations
    can have other GC implementations, such as the garbage collectors from IBM and
    Azul. The way these work is relatively easy to grasp after understanding the following
    five implementations that come with the standard JVM:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标准JVM有五种GC实现。其他Java实现可以有其他的GC实现，例如IBM和Azul的垃圾回收器。在理解了标准JVM附带的以下五种实现之后，这些工作方式相对容易理解：
- en: Serial GC
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列GC
- en: Parallel GC
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行GC
- en: CMS (concurrent mark sweep) GC
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS（并发标记清除）GC
- en: G1 GC
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: G1 GC
- en: ZGC (Z garbage collector)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZGC（Z垃圾回收器）
- en: 'We will examine in detail how these implementations work a little later (however,
    we will not be discussing all the different command-line options for each of them).
    But, before we discuss how these specific garbage collectors work, another concept
    needs to be addressed: the concept of generational GC.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后详细检查这些实现是如何工作的（然而，我们不会讨论每个的不同的命令行选项）。但在我们讨论这些特定的垃圾回收器是如何工作的之前，另一个概念需要被解决：代式GC的概念。
- en: Generational GC
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代式GC
- en: If you have a large Java application running, pausing the entire program in
    order to wait for the garbage collector to have marked every single live object
    would be a performance nightmare. Luckily, they thought of something cleverer
    by making use of the different generations on the heap. Not all of the soon-to-be-explained
    garbage collectors use this strategy, but some of them do.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大型Java应用程序正在运行，为了等待垃圾回收器标记每个活动的对象而暂停整个程序，将会是一个性能噩梦。幸运的是，他们通过利用堆上的不同代想出了一个更聪明的办法。并非所有即将解释的垃圾回收器都使用这种策略，但其中一些确实如此。
- en: Instead of running a full garbage collector round at once, generational garbage
    collectors focus on a certain part of memory, for example, the young generation.
    This approach would work well for applications that have most of their objects
    die young. It saves a lot of marking.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与一次性运行完整的垃圾回收器不同，代式垃圾回收器专注于内存的某个部分，例如，年轻代。这种方法对于大多数对象都年轻死亡的应用程序来说效果很好。它节省了很多标记。
- en: The generational garbage collectors often work with a **remembered set**. This
    is a set that has all the references from objects to the young generation coming
    from the old generation. This way, the old generation does not need to be scanned
    since the references to the young generation are already in the remembered set.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代式垃圾回收器通常与**记忆集**一起工作。这是一个包含所有从老年代到年轻代对象引用的集合。这样，老年代就不需要被扫描，因为指向年轻代的引用已经在记忆集中了。
- en: Applications that have most of their objects in the tenured generation will
    not thrive with the approach of focusing on the young generation with their GC.
    Since, in this scenario, the heap is especially heavy on the old generation, only
    collecting the young generation will not free a high ratio of memory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数对象都在持久代的应用程序，使用GC专注于年轻代的方法不会繁荣。因为在这种情况下，堆特别重的是老年代，只收集年轻代不会释放高比例的内存。
- en: Often generational garbage collectors have to use different strategies for different
    memory areas. For example, the young generation could be garbage collected with
    a stop-the-world garbage collector that copies the entire set of reachable objects
    to the old generation and then deletes the young generation. Meanwhile, the old
    generation could work with compacting and perhaps an alternative to stop-the-world,
    such as the CMS garbage collector, which we’ll see while going over the different
    implementations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代垃圾收集器必须为不同的内存区域使用不同的策略。例如，年轻代可以使用停止世界垃圾收集器进行垃圾收集，将整个可到达对象集复制到老年代，然后删除年轻代。同时，老年代可以使用压缩，也许还有停止世界的替代方案，如CMS垃圾收集器，我们将在查看不同实现时看到。
- en: Now that we have discussed the different options for sweeping and both the stop-the-world
    and the generational garbage collector, we are in a better position to understand
    the five implementations that we listed earlier. (So, hold on, you’ve almost made
    it through this tough chapter!)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了清扫的不同选项以及停止世界和代垃圾收集器，我们现在处于更好的位置来理解我们之前列出的五种实现。（所以，坚持住，你几乎已经通过了这个艰难的章节！）
- en: Serial GC
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serial GC
- en: The **serial GC** runs on a single thread and uses the stop-the-world strategy.
    This means that the application is not running its main tasks when the garbage
    collector runs. It is the simplest option for garbage collection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行GC** 在单个线程上运行并使用停止世界策略。这意味着当垃圾收集器运行时，应用程序不会执行其主要任务。这是垃圾收集的最简单选项。'
- en: For the young generation, it uses the mark strategy to identify which objects
    are eligible for GC and the sweep with copying approach for the actual freeing
    of the memory. For the old generation, it uses the mark and sweep with compacting
    approach.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于年轻代，它使用标记策略来识别哪些对象有资格进行GC，并使用复制方法进行实际的内存释放。对于老年代，它使用标记和压缩的清除方法。
- en: The serial garbage collector is ideal for small programs, but for larger programs
    such as **Spring** or **Quarkus** applications, there are better options.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 串行垃圾收集器适用于小型程序，但对于像**Spring**或**Quarkus**应用程序这样的大型程序，有更好的选择。
- en: Parallel GC
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parallel GC
- en: The **parallel garbage collector** is the default garbage collector of Java
    8\. It uses the mark-and-copy approach for the young generation and the mark-sweep-compact
    approach for the old generation, just like the serial garbage collector. However,
    and this might come as a surprise, it does so in parallel. In this case, parallel
    means that uses multiple threads to clean up the heap space. So, there is not
    one single thread taking care of the marking, copying, and compacting phases,
    but multiple threads. Even though it is still stop-the-world, it performs better
    than the serial garbage collector, since the world needs to be stopped for a shorter
    amount of time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行垃圾收集器** 是Java 8的默认垃圾收集器。它对年轻代使用标记-复制方法，对老年代使用标记-清除-压缩方法，就像串行垃圾收集器一样。然而，这可能是个惊喜，它是以并行的方式做到这一点的。在这种情况下，并行意味着使用多个线程来清理堆空间。所以，不是只有一个线程负责标记、复制和压缩阶段，而是多个线程。尽管它仍然是停止世界，但由于世界需要停止的时间更短，所以它的性能比串行垃圾收集器更好。'
- en: The parallel garbage collector will work well on machines with multiple cores.
    On (rarer) single-core machines, the serial garbage collector is probably a better
    choice, due to the costs of managing multiple threads and not really parallel
    processing on the single core.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 并行垃圾收集器在多核机器上运行良好。在（较少见的）单核机器上，由于管理多个线程的成本以及单核上实际上并没有并行处理，串行垃圾收集器可能是一个更好的选择。
- en: CMS GC
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMS GC
- en: The **Concurrent Mark Sweep Garbage Collector** (**CMS GC**) has an improved
    mark-and-sweep algorithm. It manages to do this with multiple threads and reduces
    the pause time drastically. This is the main difference between CMS GC and parallel
    garbage collector.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发标记清除垃圾收集器**（**CMS GC**）有一个改进的标记-清除算法。它通过多个线程实现这一点，并大大减少了暂停时间。这是CMS GC与并行垃圾收集器之间的主要区别。'
- en: Not all systems can handle sharing resources between the main application and
    the garbage collector, though, but if they can, it is a great upgrade in terms
    of performance compared to the parallel garbage collector.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并非所有系统都能处理主应用程序和垃圾收集器之间的资源共享，但如果它们可以，与并行垃圾收集器相比，这将是一个性能上的巨大提升。
- en: The CMS GC is a generational garbage collector as well. It has separate cycles
    for the young and old generation. For the young generation, it uses mark and copy
    with stop-the-world. So, during the GC of the young generation, the main application
    threads are paused.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CMS GC 也是一个代式垃圾回收器。它为年轻代和老年代分别设置了不同的周期。对于年轻代，它使用带有停止世界的标记和复制。因此，在年轻代的垃圾回收期间，主要的应用线程会被暂停。
- en: The old generation is garbage collected with *mostly concurrent* mark and sweep.
    The term mostly concurrent means that it does most of the GC concurrently, but
    it will still use stop-the-world twice in a GC cycle. It pauses all the main application
    threads for the first time at the very beginning, then during the marking for
    a very short time, and then for a (usually) somewhat longer time around the middle
    of the GC cycle to do the final marking.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 老年代使用 *主要并发* 标记和清除进行垃圾回收。这里的“主要并发”意味着它大部分的垃圾回收是并发的，但在垃圾回收周期中仍会使用两次停止世界的操作。它第一次在垃圾回收周期的开始时暂停所有主要的应用线程，然后在标记阶段非常短暂地暂停，然后在垃圾回收周期中间的某个时候（通常）稍微长一点的时间进行最终标记。
- en: These pauses are typically very short, because the CMS GC attempts to collect
    enough of the old generation while running concurrently to the main application
    threads and, this way, prevent it from getting full. Sometimes, this is not possible.
    If the CMS GC cannot free up enough while the old generation is getting full,
    or the application fails to allocate an object, the CMS GC pauses all the application
    threads and the main focus shifts to GC. The situation in which this garbage collector
    fails to do the GC mostly concurrently is called *concurrent* *mode failure*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些暂停通常非常短，因为 CMS GC 尝试在并发于主应用线程的同时收集足够的旧代内存，从而防止它填满。有时，这是不可能的。如果 CMS GC 在旧代内存填满时无法释放足够的内存，或者应用程序无法分配对象，CMS
    GC 会暂停所有应用线程，主要关注点转向垃圾回收。这种垃圾回收器无法主要并发进行垃圾回收的情况被称为 *并发* *模式失败*。
- en: If the collector then still cannot free up enough memory, `OutOfMemoryError`
    gets thrown. This happens when 98% of the application time is spent on GC and
    less than 2% of the heap is recovered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收集器仍然无法释放足够的内存，则会抛出 `OutOfMemoryError`。这种情况发生在应用程序的 98% 的时间都花在垃圾回收上，而堆中恢复的内存不到
    2%。
- en: This is not a lot different from the other garbage collectors that we’ve discussed.
    The very short pauses of the CMS GC sound pretty good already, but there are even
    later upgrades available. Let’s have a look at the G1 GC.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他我们讨论过的垃圾回收器并没有太多不同。CMS GC 的非常短的暂停时间听起来已经相当不错了，但还有更晚的升级可用。让我们来看看 G1 GC。
- en: G1 GC
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: G1 GC
- en: The **G1** (**garbage-first**) garbage collector came with Java 7 (minor version
    4) and is an upgrade of the CMS GC. It combines different algorithms in a clever
    way. The G1 collector is parallel, concurrent, and aims for short pauses of the
    application. It employs a technique called incrementally compacting.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**G1**（垃圾优先）垃圾回收器随着 Java 7（次要版本 4）推出，是 CMS GC 的升级。它以巧妙的方式结合了不同的算法。G1 收集器是并行、并发，并旨在缩短应用程序的暂停时间。它采用了一种称为增量压缩的技术。'
- en: 'The G1 garbage collector divides the heap into smaller regions: much smaller
    than the generational garbage collector. It works with these smaller memory segments
    to mark and sweep them. It keeps track of the amount of reachable and unreachable
    objects per memory region. The regions with the most unreachable objects are garbage
    collected first since that frees up the most memory. That’s why it is called the
    garbage-first garbage collector. Regions with the most garbage are collected first.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: G1 垃圾回收器将堆分成更小的区域：比代式垃圾回收器小得多。它与这些较小的内存段一起工作，对它们进行标记和清除。它跟踪每个内存区域中可达和不可达对象的数量。具有最多不可达对象的区域首先进行垃圾回收，因为这样可以释放最多的内存。这就是为什么它被称为垃圾优先垃圾回收器。具有最多垃圾的区域首先被收集。
- en: 'It does all this while copying objects from one region to another region. This
    will result in freeing up the first region completely. This way the G1 GC kills
    two birds with one stone: achieving GC and compacting at the same time. This is
    why it is such an upgrade compared to earlier mentioned garbage collector.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它在将对象从一个区域复制到另一个区域的同时完成所有这些操作。这将导致第一个区域完全释放。这样，G1 GC 一石二鸟：同时实现垃圾回收和压缩。这就是为什么它相对于之前提到的垃圾回收器来说是一个如此大的升级。
- en: The G1 GC is a great garbage collector. You may wonder whether this garbage
    collector manages to work without stop-the-world. No, the compacting still needs
    to happen this way. But due to the smaller regions, the pauses are much shorter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC是一个优秀的垃圾收集器。你可能想知道这个垃圾收集器是否能够不停止世界来工作。不，压缩仍然需要以这种方式发生。但由于区域较小，暂停时间要短得多。
- en: 'Another new feature of the G1 GC garbage collector is *string deduplication*.
    This is literally what you’d think it is: the garbage collector runs a process
    to inspect the `String` objects. When it finds `String` objects that contain the
    same content but refer to different `char` arrays on the heap, they will be updated
    to both point to the same `char` array. This makes the other `char` array eligible
    for GC and this way, the memory usage is optimized. As if this wasn’t exciting
    enough, it happens completely concurrently! This option will need to be enabled
    using the following command: `-XX:+UseStringDeduplication`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC垃圾收集器的另一个新特性是*字符串去重*。这实际上就是你所想的：垃圾收集器运行一个进程来检查`String`对象。当它找到包含相同内容但引用堆上不同`char`数组的`String`对象时，它们将被更新为都指向同一个`char`数组。这使得另一个`char`数组有资格进行GC，从而优化了内存使用。更令人兴奋的是，这一切都是完全并发发生的！此选项需要使用以下命令启用：`-XX:+UseStringDeduplication`。
- en: Just like the CMS GC, the G1 GC tries to do a lot of the GC concurrently. So,
    the application threads don’t need to be paused most of the time. However, if
    the G1 GC cannot free up enough memory and the application is allocating more
    than can be freed up concurrently, the application threads need to be paused.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CMS GC一样，G1 GC试图并发地做很多事情。因此，应用程序线程大多数时候不需要暂停。然而，如果G1 GC无法释放足够的内存，并且应用程序分配的内存超过了可以并发释放的内存，那么应用程序线程需要暂停。
- en: The G1 garbage collector is the go-to GC for powerful systems that are high
    performing and have a large memory space. This is not the most recently added
    garbage collector though. Let’s have a look at the ZGC.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾收集器是针对性能强大且内存空间大的系统的首选GC。但这并不是最近添加的垃圾收集器。让我们看看ZGC。
- en: Z GC
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Z GC
- en: Java 15 gave us yet another production-ready implementation of the garbage collector,
    the **Z garbage collector** (**ZGC**). It does all the garbage collecting concurrently
    and does not need to pause the application for more than 10 ms per pause.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java 15为我们提供了垃圾收集器的另一个生产就绪实现，即**Z垃圾收集器**（**ZGC**）。它并发地执行所有垃圾回收，并且不需要在每次暂停时使应用程序停止超过10毫秒。
- en: It manages to do this by starting with marking the live objects. It doesn’t
    keep a map but uses **reference coloring**. Reference coloring means that the
    live state of reference is stored as the bits that are part of the reference.
    This requires some extra bits, which is why the ZGC only works on 64-bit systems
    and not on 32-bit systems.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过首先标记活动对象来实现这一点。它不保留映射，而是使用**引用着色**。引用着色意味着引用的活动状态存储为构成引用的位。这需要一些额外的位，这就是为什么ZGC只能在64位系统上运行，而不能在32位系统上运行。
- en: Fragmentation is avoided by using relocation. This process happens in parallel
    with the application in order to avoid pauses of more than 10 ms, but this happens
    while the application is being executed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用重新定位来避免碎片化。这个过程与应用程序并行发生，以避免超过10毫秒的暂停，但这是在应用程序执行的同时发生的。
- en: Without extra measurements, this could lead to unpleasant surprises. Imagine
    that we were trying to access a certain object with the reference, but while doing
    so, it got relocated and has a new reference. The old memory location could be
    overwritten or cleared already. In such a scenario, debugging would be a nightmare.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 没有额外的测量，这可能会导致不愉快的惊喜。想象一下，我们正在尝试使用参考访问某个对象，但在做这个过程中，它被重新定位并且有了新的参考。旧的内存位置可能已经被覆盖或清除。在这种情况下，调试将是一场噩梦。
- en: Of course, the Java team would not push a garbage collector to production with
    issues like that. They introduced load barriers to deal with this. The load barriers
    run whenever a reference from the heap is loaded. It checks the metadata bits
    of the reference and, based on the result, it may or may not do some processing
    before retrieving the result. This magic is called remapping.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Java团队不会将存在那样问题的垃圾收集器推向生产。他们引入了加载屏障来处理这个问题。加载屏障在从堆加载引用时运行。它检查引用的元数据位，并根据结果，在检索结果之前可能或可能不会进行一些处理。这种魔法被称为重映射。
- en: The five garbage collectors we’ve just discussed are the main options to choose
    from at the moment of writing this book. Your options depend on the Java version
    that you’re using, the system configuration, and the type of application. In order
    to make sure the garbage collector performs well, monitoring should be in place.
    This is exactly what we’re going to look at in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的五个垃圾回收器是目前写作本书时可以选择的主要选项。你的选择取决于你使用的Java版本、系统配置以及应用程序的类型。为了确保垃圾回收器表现良好，需要实施监控。这正是我们将在下一节中探讨的内容。
- en: Monitoring GC
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控GC
- en: 'In order to decide upon the right garbage collector, you’ll need to know your
    application. There are a few metrics that are especially important for the GC:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定合适的垃圾回收器，你需要了解你的应用程序。有几个指标对于GC特别重要：
- en: '**Allocation rate**: How fast the application allocates objects in memory.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配率**：应用程序在内存中分配对象的速度。'
- en: '**Heap population**: The number of objects and their size living on the heap.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆内存占用**：堆上存活的对象的数量和大小。'
- en: '**Mutation rate**: How often references are updated in memory.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变率**：内存中引用更新的频率。'
- en: '**Average object live time**: The time the objects live on average. One application
    may have objects that die young, while another application may have objects that
    live longer.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均对象存活时间**：对象平均存活的时间。一个应用程序可能有存活时间短的对象，而另一个应用程序可能有存活时间长的对象。'
- en: The monitoring of the performance of the GC requires different metrics. The
    most important ones are mark time, compaction time, and GC cycle time. The mark
    time entails the time it takes the garbage collector to find all the live objects
    on the heap. Compaction time is how long it takes the garbage collector to free
    up all the space and relocate the objects. The GC cycle time is how long it takes
    the garbage collector to perform a full GC.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 监控垃圾回收器的性能需要不同的指标。其中最重要的包括标记时间、压缩时间和GC周期时间。标记时间是指垃圾回收器在堆上找到所有存活对象所需的时间。压缩时间是指垃圾回收器释放所有空间并重新定位对象所需的时间。GC周期时间是指垃圾回收器执行完整GC所需的时间。
- en: Whenever there is little heap space available, you’ll see the CPU usage for
    GC increase. Choosing the right amount of memory will improve the performance
    of your application. The greater the amount of available memory, the easier the
    garbage collector can function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每当可用的堆空间很少时，你会看到垃圾回收（GC）的CPU使用率增加。选择合适的内存量可以提高你应用程序的性能。可用的内存量越大，垃圾回收器的工作就越容易。
- en: The copy-and-compact collector needs to have enough space available for copying
    and relocating. This is a much more costly process when available memory is limited.
    Only a small memory segment could be copied to free up a bit more so that hopefully
    a bit more can be copied next time, and so on. The CPU usage of the garbage collector
    is the highest on low memory. On the other end of the spectrum, in the hypothetical
    situation that we would have unlimited memory, we wouldn’t really need to garbage
    collect at all.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并压缩收集器需要足够的可用空间来进行复制和重新定位。当可用内存有限时，这是一个成本更高的过程。只能复制一小段内存来释放更多空间，希望下次能复制更多，依此类推。垃圾回收器的CPU使用率在低内存时最高。在另一端，在假设我们有无限内存的情况下，我们实际上根本不需要进行垃圾回收。
- en: In [*Chapter 6*](B18762_06.xhtml#_idTextAnchor086), we’re going to have a look
    at the usage of JVM tuning for memory management to improve the functioning of
    the JVM memory. There, we’ll also see how we can tune a garbage collector.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18762_06.xhtml#_idTextAnchor086)中，我们将探讨如何使用JVM调优来管理内存，以改善JVM内存的功能。在那里，我们还将了解如何调整垃圾回收器。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how the GC of the heap works in more depth. Objects
    on the heap are eligible for GC when they don’t have a connection to the stack
    anymore, whether directly or indirectly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地了解了堆的GC工作原理。当堆上的对象不再与栈有直接或间接的连接时，它们就有资格进行GC。
- en: The garbage collector determines which objects are eligible for GC in the marking
    phase. Objects that have a connection to the stack are marked. The objects that
    are eligible for GC are unmarked.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器在标记阶段确定哪些对象有资格进行GC。与栈有连接的对象会被标记。有资格进行GC的对象不会被标记。
- en: After this marking phase, the actual removal happens in the sweeping phase.
    We discussed three kinds of sweeping, normal sweeping, sweeping with compacting,
    and sweeping with copying.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记阶段之后，实际的删除操作发生在清除阶段。我们讨论了三种清除方式，即正常清除、压缩清除和复制清除。
- en: Then, we discussed the different implementations of the garbage collectors.
    A subset of them are the generational garbage collectors. These garbage collectors
    focus on one of the generations of the heap and, consequently, do not need to
    scan all the objects of the heap during the marking phase. After that, we discussed
    five common implementations of the garbage collector.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了垃圾收集器的不同实现方式。其中之一是代际垃圾收集器。这些垃圾收集器专注于堆内存中的一代，因此，在标记阶段不需要扫描堆内存中的所有对象。之后，我们讨论了垃圾收集器的五种常见实现。
- en: In the next chapter, we’re going to zoom in on the Metaspace.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将聚焦于元空间（Metaspace）。
