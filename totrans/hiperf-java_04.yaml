- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Object Pooling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our mission to make our Java applications highly performant includes a look
    at Java **object pooling**. This chapter dives into the concept of object pooling
    in Java and how to achieve high performance with them in your Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The chapter begins with an explanation of object pooling and how to implement
    an **object pool** in Java. Sample code is provided to help you understand object
    pooling operations specific to the Java programming language. You will also have
    the opportunity to learn about the advantages and disadvantages of object pooling
    in Java. Finally, the chapter shows how you can implement performance testing
    with Java object pools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Jumping into the object pool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and disadvantages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a strong theoretical understanding
    of Java object pooling as well as hands-on implementation experience. This experience
    can help ensure you get high performance out of your Java applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Jumping into the object pool
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into the object pool, let’s look at what an object pool is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Object pool
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: An object pool is a collection (pool) of objects that can be reused.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Using object pools is an optimization approach that can positively impact the
    performance of an application. Instead of recreating objects every time we need
    them, we pool a collection of objects and simply recycle them. To help understand
    object pooling, consider a real-world example of a physical library. The library
    can lend out books (our objects) and return them to the collection (our pool)
    when the person is done with the book. This allows the library to reissue the
    book to the next person that needs it. Consider the alternative. If the library
    destroyed (garbage collection) the book after each use, it would have to create
    a new one each time it is needed. This would not be efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Database example
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common object pooling implementation in Java programming is with database
    connections. The typical approach to database connections is to open a connection
    to the database and then perform the desired operations to update or query the
    database. The **open-query-close** process is used. The problem with this approach
    is that opening and closing databases frequently can impact the overall performance
    of the Java application. This processing overhead is something we should try to
    avoid.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The object pooling approach, with our database example, involves maintaining
    a pool of pre-created database requests that are idle. When the app signals a
    request for a database connection, one is used from the pool. The next section
    demonstrates how to create and use these pools in a Java application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an object pool in Java
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing an object pool, based on the database connection example from the
    previous section, involves a database connection class, an object pool class,
    and a class that contains a `main()` method. Let’s look at each of these individually.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This example simulates object pooling and does not connect to an actual database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have our `DBConnect` class. This is the class that we will pool:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see by the preceding code, there are placeholders for functionality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `DBConnectObjectPool` class to maintain a collection (pool)
    of `DBConnect` objects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown in the preceding code, we assume a maximum number of connections. This
    is considered a best practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have a partial application to demonstrate how to use our object
    pool:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When our application requests a database connection, one is provided from the
    pool. In the case when a connection is not available from the pool, a new one
    is created. We do check to ensure that we do not exceed the maximum number of
    allowed connections. Lastly, after a `DBConnect` object is used, it is returned
    to the object pool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of object pooling
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand what object pooling is and how to implement it in Java,
    we should consider if this is the right strategy for our application. With most
    application code optimization approaches, there are both advantages and disadvantages.
    This section looks at both.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several potential advantages of using object pooling. These advantages
    can be grouped into performance, resource management, and scalability categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Performance advantages
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing object pooling stands to allow us to avoid the overhead from object
    creation. This approach is especially useful in high transaction applications
    and when system response time is important. Through object pooling, we can help
    ensure our Java applications are able to be more performant by avoiding excessive
    object creation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: We can also experience consistent performance between app usage. For example,
    using object pooling should result in consistent app performance with both a minimal
    load and a heavy load. This predictable behavior is possible due to the stability
    of our application. That stability is enabled by avoiding frequent object creation
    and a heavy reliance on garbage collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Resource management advantages
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of object pooling advantages, a resource refers to real time,
    processing load, and memory. Reducing the number of object creation and destruction
    operations is a benefit of the object pooling approach. The example used earlier
    in this chapter was with database connections. That example was used because database
    connection operations are notoriously resource hogs. The object pooling approach
    reduces the time it takes to perform these operations and is less resource intensive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Another resource management advantage is that it increases our memory management
    schema. When object creation is not controlled, the amount of memory consumed
    is variable and could result in system errors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Scalability advantages
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third category of advantages is the ability for our applications to be more
    scalable. This is especially true when we have applications with a large number
    of simultaneous users. It is also beneficial when dealing with database connections
    where the database is a shared resource. The object pool essentially serves as
    a buffer for those requests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Another reason our applications that use object pooling are more scalable is
    the increased amount of control we have with our resources. In the database connection
    example presented earlier in this chapter, we set the maximum number of objects
    that could be in the pool.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, there are more potential disadvantages to using object pooling
    than there are advantages. These disadvantages can be grouped into code complexity
    and resource management categories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Code complexity disadvantages
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like with any non-standard programming approach, object pooling adds complexity
    to our code. We create our object pooling-related classes, which must contain
    algorithms to manage the object pool and interfaces with the main program. Although
    it is not apt to result in bloated code, it can make it difficult to maintain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling, when implemented in a Java application, adds another component
    to test each time the system, connected systems, or data changes. This can be
    time and resource intensive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Resource management disadvantages
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is always a risk, especially during peak load times, of having enough
    available resources. When we set a maximum size of our object pools, they might
    not be sufficient to handle those peak load times. This can also be referred to
    as **resource starvation** because all objects in our pool have been allocated,
    preventing new requests from being queued. These delays can result in overall
    performance lag and user dissatisfaction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Working with memory allocation and deallocation can be problematic. If we do
    not, for example, manage how objects are returned to the pool, there could be
    data loss. This could compound a situation where there are no objects available
    in the pool. Implementing error checking and exception handling becomes critical.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to maintain the balance of an object pool being too large or
    too small. If it is too small, it could result in extensive queue times for pooled
    objects. If the pool is too large, the application might overconsume memory, taking
    away from other areas of the application that could make use of it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: After looking at both the advantages and disadvantages, you should be able to
    determine whether object pooling is ideally suited for your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we implement object pooling in our Java applications, we want to do three
    things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Ensure our program works
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove that our implementation resulted in greater performance
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantify the optimization
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous sections, we looked at how to implement object pools in Java. In
    this section, we will look at how to design a performance test, how to implement
    the object pooling performance test, and how to analyze the testing results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Designing a performance test
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we decide to implement a performance test, our first action is to design
    the test. The questions we need to answer here include the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: What is our goal?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What will we measure?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will we measure?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What conditions will exist for our tests?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these questions in mind, we can start designing our performance test. We
    should have a clear goal or set of goals for our performance test. We might, for
    example, want to focus on system memory, CPU load, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a specific goal, we must decide what to measure. In testing, what
    we measure are considered **key performance indicators** (**KPIs**). The performance
    testing of object pools might be memory usage, CPU use, data throughput, and response
    time. These are just some examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will need to set up our test environment and create test scenarios.
    The test environment closely replicates the production system. You might duplicate
    your system in a development environment, so the live system is not impacted.
    Likewise, the test scenarios should closely resemble the real-world use of your
    system. To the extent possible, we should create as many different scenarios as
    needed to represent what our live system handles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are ready to document your test plan and implement it. The
    next section covers how to implement a performance test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a performance test
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing your test plan should not be terribly difficult. Here, you are
    simply putting your plan into action. The test environment is established, and
    you run your test scenarios. As the test is running, you should be collecting
    the data for later analysis. Of critical importance is the ability to reproduce
    your test conditions to support future comparative tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how a performance test might be written in Java using the database
    connection example from this chapter. We will set the goal of decreasing the time
    our application takes to obtain a database connection from our object pool and
    perform a simple operation on that database. Our test plan will compare the results
    of our test with the same test on a version of our application that does not implement
    an object pool.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code starts with the class declaration and class variables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will write the first part of the `main()` method. This first snippet
    of code will be how we perform the test with our object pool:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will write the code to test without using the object pool:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With both sets of performance testing written, we need to add the ability to
    calculate and output the results. We generate the results by simply subtracting
    the `startTime` value from the `endTime` value and converting it to milliseconds.
    We then output the results to the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple example of an object pool performance test is intended to give you
    a general idea of how to code these tests. Every application is different and
    how you write your performance tests will vary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once our tests have concluded, we can analyze the results. How you analyze the
    results will depend on your goals and KPIs. The analysis task should not be rushed.
    Remember, you collected this data so it could help inform your decision on your
    object pool. The complexity will vary based on the performance test plan.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the database connection example, we can simply add it to the bottom of
    our `DBConnectionPerformanceTest` class to compare the two sets of results. Here
    is the first section of that code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we simply check to see whether `totalTime_withPooling` is less
    than `totalTime_withoutPooling`. If this is the case, the relevant results are
    displayed on the console.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will check to see whether `totalTime_withPooling` is greater than
    `totalTime_withoutPooling`. The relevant results are displayed on the console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our final code snippet executes when the first two conditions are not met.
    This means that both tests took the same amount of time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with all testing, you should document your plan, the test results, your analysis,
    your conclusions, and your actions following the testing. This robust documentation
    approach will help you retain the history of your testing in detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took an in-depth look at Java object pooling. It was suggested
    that object pooling is an important technique for ensuring our Java applications
    perform at a high level. Armed with theoretical knowledge, the chapter explored
    the advantages and disadvantages of object pooling. We focused on areas such as
    memory, CPU use, and code complexity. Finally, we demonstrated how to create a
    performance testing plan, how to implement it, and how to analyze the results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on algorithm efficiencies. Our goal will
    be to ensure our algorithms have low time complexities. The chapter will demonstrate
    inefficient algorithms and how to transform them to support high performance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注算法效率。我们的目标将是确保我们的算法具有低时间复杂度。本章将展示低效算法以及如何将它们转换为支持高性能。
