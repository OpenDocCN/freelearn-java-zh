<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Data classes and their usage</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Work is in progress on data classes under the Project Amber. It proposes to bring to developers a simplified way of modelling data as data, by introducing special classes with the keyword record. The state of the data class would be able to be captured using the class header, which is in stark contrast to what the existing <strong class="calibre20">Plain Old Java Objects</strong> (<strong class="calibre20">POJO</strong>) offer at present.</p>
<p class="calibre6">In the chapter, we'll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">An introduction to the data classes</li>
<li class="calibre11">Need of the data classes and their limitations</li>
<li class="calibre11">Aggregate and exploded form of a data class</li>
<li class="calibre11">Pattern matching with data classes</li>
<li class="calibre11">Inheritance with abstract data classes and interfaces</li>
<li class="calibre11">Adding variables and methods</li>
<li class="calibre11">Overriding default behavior</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction to the data classes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">We know of two versions of data classes—POJO (the old and existing way) and the new proposed data classes. To appreciate the data classes that is in works under the Project Amber, you'll need to know what the capabilities and limitations of existing POJO classes are and why do we need the new proposed data classes.</p>
<div class="packt_infobox">POJO is not implemented using a language construct. The proposed data classes would include changes or additions to the programming language.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What is a data class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">As a Java developer, you probably have used and created POJOs in some or all your projects. It is a class that encapsulates a set of data, without any additional behavior to manipulate its state. It usually includes constructors, accessors, mutators, and the overridden methods from the object class, namely—<kbd class="calibre9">hashCode()</kbd>, <kbd class="calibre9">equals()</kbd>, and <kbd class="calibre9">toString()</kbd>. The accessors and mutators allow access and assignment to the state variables. Additionally, the mutators might include code to check the range of values that are assigned to the instance state. Here's an example:</p>
<pre class="calibre14">final class Emp { 
    private String name; 
    private int age; 
 
    public Emp(String name, int age) { 
        this.name = name; 
        this.age = age; 
    } 
 
    // accessor methods - getName, getAge 
    public String getName() { 
        return name; 
    } 
 
    public int getAge() { 
        return age; 
    } 
 
    // mutator methods - setName, setAge 
    public void setName() { 
        this.name = name; 
    } 
 
    public void setAge() { 
        this.age = age; 
    } 
 
    public boolean equals(Object obj) { 
        if (obj == null || (!(obj instanceof Emp))) 
            return false; 
        else { 
            if ( ( ((Emp)obj).getName().equals(this.name) &amp;&amp; 
                 ( ((Emp)obj).getAge() ) == this.age)) { 
                return true; 
            } 
            else 
                return false; 
        } 
    } 
 
    public String toString() { 
        return name + ":" + age; 
    } 
    public int hashCode() { 
        // ..code 
    } 
} </pre>
<p class="calibre6">One of the cases is to use the <kbd class="calibre9">Emp</kbd> <span class="calibre8">class </span>to save employee data to your database. Here's an example:</p>
<pre class="calibre14">interface EmpDAO { 
    Emp read(); 
    void write(Emp emp); 
    List&lt;Emp&gt; getAllEmp(); 
} </pre>
<p class="calibre6">Similarly, you could also use the <kbd class="calibre9">Emp</kbd> class to be passed in a message, to be sent over the network, to insert it into a JSON object and many more.</p>
<p class="calibre6">This all looks good. More importantly, this has been working fine ever since Java was introduced to the developers. So, what is the problem?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Need of adding data classes to the language</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Imagine securing the borders of a country. The norm for it is to be guarded by the defense forces. Will the level of security change based on the relationship between the neighboring countries (cordial, neuter or tense)? What happens if the borders are porous<span class="calibre8">, or</span><span class="calibre8"> say, for example, the way it is in Western Europe for the Schengen countries? Now, compare guarding borders of a country with guarding our homes or, say, securing the contents of a cabinet in a room.</span></p>
<p class="calibre6">Though each instances in the preceding example is talking about security of an entity and its protection from a physical attack, they all have varied requirements.</p>
<p class="calibre6">Similarly, until now, the classes in Java have been used to model a wide range of requirements. While this works well for a lot of cases, it doesn't work for some. If you want to make the same size fit all, you'll need a lot of adjustments for most of them. Compare it with using the same trouser size for individuals with varied height and waist size, as shown in the following image:</p>
<div class="cdpaligncenter"><img src="Images/bc0292c8-734a-4741-ae41-63ea941069a6.png" width="1651" height="1344" class="calibre25"/></div>
<p class="calibre6">In the past, enum were added to the Java language (version 5). Even though a class can be programmed to create an enumeration of primitives or objects, enums simplified the process for a developer.</p>
<div class="packt_infobox">Enums reduced the coding for developers. At the same time, it made the intent of the enum explicit to its users</div>
<p class="calibre6">In the preceding section, <kbd class="calibre9">Emp</kbd> <span class="calibre8">POJO </span>is just a carrier of its data. However, to season a class to behave like a data class, requires a developer to define multiple methods—constructs, accessor, mutator, and other methods from the object class. You might argue that you can use an IDE to easily generate all these methods for your class. You are right! And it's quite simple to do so.</p>
<p class="calibre6">But it only takes care of the writing part of code. What happens to the reading of the code by the users of the class? As developers, we all understand that a piece of code might be written just once, but it is read multiple times. This is the reason, why experienced programmers stress on good coding practices, for comprehending, reading and maintaining code.</p>
<p class="calibre6">When definition of data classes is induced in the language, the readers of the code would know its explicit intent of just being a data class. The developers would not need to dig their claws deep into the code, finding code, that was in addition to them just being a data class, so as they don't miss any important information.</p>
<p class="calibre6">It will also prevent the developers from using half-baked classes as data class. At times developers tend to use classes that might not include all the relevant methods (like <kbd class="calibre9">equals()</kbd> or <kbd class="calibre9">hashCode()</kbd>), as a data class, but it is sure a good recipe to insert subtle bugs in your applications. A collection class like <kbd class="calibre9">Map</kbd>, requires a class to implement its <kbd class="calibre9">equals()</kbd> and <kbd class="calibre9">hashCode()</kbd> methods to function properly and efficiently.</p>
<div class="packt_infobox">Introducing data classes with the change in language would decrease the verbosity of the language, broadcast the intent of the structure to all.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deep dive into data classes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The syntax to define a data class looks simple. However, both the syntax and the semantics are important.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">An example</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's get started by re-defining the <kbd class="calibre9">Emp</kbd> class, which we used in the beginning of the chapter, as a data class:</p>
<pre class="calibre14">record Emp(String name, int age) { }      // data class - one liner code </pre>
<p class="calibre6">The preceding code uses the keyword <kbd class="calibre9">record</kbd> to define a data class, accepting comma separated variable name and type, required to store the state. The compiler automatically generates default implements for the Object methods (<kbd class="calibre9">equals()</kbd>, <kbd class="calibre9">hashCode()</kbd>, <kbd class="calibre9">toString()</kbd>) for data classes.</p>
<p class="calibre6">The code looks clear and compact. A reader would immediately know the intent of this single line of code, a carrier of data <kbd class="calibre9">name</kbd> (type <kbd class="calibre9">String</kbd>) and <kbd class="calibre9">age</kbd> (type <kbd class="calibre9">int</kbd>). Another advantage for a reader is that she wouldn't need to read through constructors, accessors, mutators, or methods of the object class, just to ascertain that they are doing what they are supposed to, not more, which they should be aware of.</p>
<p class="calibre6">Behind the scenes, the record class <kbd class="calibre9">Emp</kbd> is converted to the following by the Java compiler:</p>
<pre class="calibre14">final class Emp extends java.lang.DataClass { 
    final String name; 
    final int age; 
 
    public Emp(String name, int age) { 
        this.name = name; 
        this.age = age; 
    } 
 
    // deconstructor 
    // public accessor methods 
    // default implementation of equals, hashCode, and toString 
} </pre>
<p class="calibre6">The preceding data class is an example of a non-abstract data class. A data class can also be defined as an abstract data class. A non-abstract data class is implicitly final. In both cases, a data class would get default implementations of <kbd class="calibre9">hashCode()</kbd>, <kbd class="calibre9">equals()</kbd> and <kbd class="calibre9">toString()</kbd>, and accessor methods. For an abstract data class, the constructors would be protected.</p>
<p class="calibre6">In the following image, the compiler looks happy to convert one liner code for the data class, to a full-fledged class:</p>
<div class="cdpaligncenter"><img src="Images/4c986559-e3f7-4fad-ba6a-aac011072490.png" width="1379" height="1171" class="calibre26"/></div>
<div class="packt_infobox">A data class is implicitly final.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Aggregate and exploded form of a data class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Aggregate form of a data class would be the name of the data class. Its exploded form would refer to the variables used to store its data. Conversion from aggregate to exploded form is also referred to as the deconstruction pattern.</p>
<p class="calibre6">Referring to the example, we used in our preceding section:</p>
<pre class="calibre14">record Emp(String name, int age) { }       </pre>
<p class="calibre6"><kbd class="calibre9">Emp</kbd> is the aggregate form of the data class <kbd class="calibre9">Emp</kbd>. Its exploded form would be <kbd class="calibre9">String name</kbd> and <kbd class="calibre9">int age</kbd>. The language would need easy conversion between the two, so that they can be used with other language constructs like <kbd class="calibre9">switch</kbd>.</p>
<div class="packt_infobox">Deconstruction pattern refers to the conversion from aggregate form to exploded form for a data class.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The limitations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">When you use the keyword <kbd class="calibre9">record</kbd> to define your data class, you'll be limited by what the language allows you to do. You'll no longer have the finer control on whether your data class is extensible, whether its state is mutable, whether you can control the range of values that can be assigned to your fields, accessibility to your fields. You might also be limited when it comes to having additional fields or multiple constructors.</p>
<div class="packt_infobox">Data class is still in works at Oracle. They finer details are still being worked on. Just a month back, the keyword <kbd class="calibre13">datum</kbd> was used to define a data class, changed to <kbd class="calibre13">record</kbd> now.</div>
<p class="calibre6">Now-a-days, developers aren't limited to working with a single programming language. Java programmers usually work with, or, are aware of the other programming language that work on the JVM, like Scala, Kotlin, or Groovy. The experience of working with varied languages brings a lot of expectations and assumptions on the capabilities and limitations of the data classes (defined using <kbd class="calibre9">record</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Examples from the past – changes to define enums</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Prior to the introduction of enums, developers often used <kbd class="calibre9">public</kbd>, <kbd class="calibre9">static</kbd>, and <kbd class="calibre9">final</kbd> variables to define constants. For example:</p>
<pre class="calibre14">class Size { 
    public final static int SMALL = 1; 
    public final static int MEDIUM = 2; 
    public final static int LARGE = 3; 
} </pre>
<p class="calibre6">The major drawback of using <kbd class="calibre9">public</kbd>, <kbd class="calibre9">static</kbd>, <kbd class="calibre9">final</kbd>, <kbd class="calibre9">int</kbd> variables is type safety, any <kbd class="calibre9">int</kbd> value could be assigned to a variable of type <kbd class="calibre9">int</kbd>, instead of <kbd class="calibre9">Size.SMALL</kbd>, <kbd class="calibre9">Size.MEDIUM</kbd> or <kbd class="calibre9">Size.LARGE</kbd> constants.</p>
<p class="calibre6">Java 5 introduced enums, an addition to the language construct, to enable developers to define an enumeration of constants. Here's a quick example:</p>
<pre class="calibre14">enum Size {SMALL, MEDIUM, LARGE} 
class SmallTShirt { 
    Size size = Size.SMALL; 
    //..other code 
} </pre>
<p class="calibre6">With a variable of type <kbd class="calibre9">Size</kbd>, assignment is limited to the constants defined in <kbd class="calibre9">Size</kbd>. An enum is a perfect example of how language can simplify implementation of a model at the cost of certain constraints. Enums limit the extensibility to interfaces. Other than that, enums are full-fledged classes. As a developer you can add state and behavior to it. Another benefit is that an enum can also in <kbd class="calibre9">switch</kbd> constructs, which was earlier limited to primitives and a <kbd class="calibre9">String</kbd> class.</p>
<div class="packt_infobox">A new language construct is like a new human relationship—biological or otherwise. It has its own share of joys and sorrows.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Pattern matching with the data classes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">When you define your data classes using the <kbd class="calibre9">record</kbd> <span class="calibre8">keyword,</span> you get the added advantage of conversion of aggregate and exploded form of your data class. For an example, here's how the switch statement might explode the data:</p>
<pre class="calibre14">interface Garment {} 
record Button(float radius, Color color); 
record Shirt(Button button, double price); 
record Trousers(float length, Button button, double price); 
record Cap(..) 
 
switch (garment) { 
     case Shirt(Button(var a1, var a2), Color a3): ... 
     case Trousers(float a1, Button(var a2, var a3), double a4): ... 
     .... 
} </pre>
<p class="calibre6">The switch statement can use a data class, without using its exploded form. The following is good as well:</p>
<pre class="calibre14">switch (garment) { 
     case Shirt(Button a1, Color a2): ... 
     case Trousers(float a1, Button a2, double a3): ... 
     .... 
}  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Encapsulating state</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The record classes encapsulate the fields, providing default implementation of JavaBean style accessor methods (public methods to set value of fields). The values can be assigned during initialization of data class instances, using its constructors.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Data classes and inheritance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">At present, the proposal is to decline the following inheritance cases:</p>
<ul class="calibre10">
<li class="calibre11">A data class extends a regular class</li>
<li class="calibre11">A regular class extends a data class</li>
<li class="calibre11">A data class extends another data class</li>
</ul>
<p class="calibre6">Allowing any of the preceding cases would violate the contract of a data class being carrier of data. At present, the following restrictions are proposed for data classes and inheritance with interfaces and abstract data classes:</p>
<ul class="calibre10">
<li class="calibre11">Non-abstract and abstract data classes can extend other abstract data classes</li>
<li class="calibre11">An abstract or non-abstract data class can extend any interface(s).</li>
</ul>
<p class="calibre6">The following image sums up these inheritance rules.</p>
<div class="cdpaligncenter"><img src="Images/c2e8214d-58a0-4bda-a870-b1f0461d1ada.png" width="1548" height="768" class="calibre27"/></div>
<p class="calibre6">Let's get started by defining an abstract data class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Extending an abstract data class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In the following example, the <kbd class="calibre9">Emp</kbd> <span class="calibre8">abstract data class </span>is being extended by non-abstract data class <kbd class="calibre9">Manager</kbd>:</p>
<pre class="calibre14">abstract record Emp(String name, int age); 
record Manager(String name, int age, String country) extends Emp(name, age); </pre>
<p class="calibre6">When a non-abstract data class extends an abstract data class, it accepts all the data in its header, the ones that are required for itself and for its base class.</p>
<div class="packt_infobox">A data class can extend a single abstract data class.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing interfaces</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">A data class can implement an interface and its abstract methods, or just inherit its default methods. Here's an example:</p>
<pre class="calibre14">interface Organizer {} 
interface Speaker { 
   abstract void conferenceTalk(); 
} 
 
abstract record Emp(String name, int age); 
 
record Manager(String name, int age, String country)  
   extends Emp(name, age)  
   implements Organizer; 
 
record Programmer(String name, int age, String programmingLang)  
   extends Emp(name, age)  
   implements Organizer, Speaker { 
        public void conferenceTalk() { 
            //.. code 
        } 
    }; </pre>
<div class="packt_infobox">A data class can implement single or multiple interfaces.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Additional variables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Though allowed, before adding variables or fields to a data class, ask yourself—<em class="calibre7">Are the fields derived from the state?</em> Fields which are not derived from the state, pose a serious violation to the initial concept of the data classes. Here's an example, which defines an additional field <kbd class="calibre9">style</kbd>, derived from the state of data class, <kbd class="calibre9">Emp</kbd>:</p>
<pre class="calibre14">record Emp(String name, int age) { 
    private String style; 
    Emp(String name, int age) { 
        //.. initialize name and age 
        if (age =&gt; 15 &amp;&amp; age =&lt; 30) style = "COOL"; 
        else if (age &gt;= 31 &amp;&amp; age &lt;= 50) style = "SAFE"; 
        else if (age &gt;= 51) style = "ELEGANT"; 
    } 
    public String getStyle() { 
        return style; 
    } 
} </pre>
<p class="calibre6">The preceding code works well because the state of the data class <kbd class="calibre9">Emp</kbd> is still derived from its state (fields <kbd class="calibre9">name</kbd> and <kbd class="calibre9">age</kbd>). The method <kbd class="calibre9">getStyle</kbd> doesn't interfere with the state of <kbd class="calibre9">Emp</kbd>, it is purely implementation detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Overriding implicit behaviour</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Imagine you want to limit the values that can be passed to a field in your data class during its instantiation. This is feasible, just override the default constructor. Here's an example:</p>
<pre class="calibre14">record Emp(String name, int age) { 
    // override default constructor 
    @Override 
    public Emp(String name, int age) { 
        // validate age 
        if (age &gt; 70) 
            throw new IllegalArgumentException("Not employable above 70 years"); 
        else { 
            // call default constructor 
            default.this(name, age); 
        } 
    } 
} </pre>
<p class="calibre6">Similarly, you can also override the default implementation of object methods such as <kbd class="calibre9">equals()</kbd>, <kbd class="calibre9">hashCode()</kbd> and <kbd class="calibre9">toString()</kbd> and others methods such as the accessor methods.</p>
<p class="calibre6">Overriding the default behavior of the methods of your data class, doesn't defeat the purpose of their creation. They are still working as data classes, with finer control on their working. Let's compare it with the POJOs, which were earlier used to model data classes. The compiler doesn't auto-generate any methods for a POJO. So, a user still needs to read all the code, looking for code that isn't the default implementation of its methods. In case of the data classes, this overridden behavior is very explicit. So, a user doesn't have to worry about reading all the code, he/she can assume default implementation of the behavior, which hasn't been overridden by the developer.</p>
<div class="packt_infobox">Overriding behavior explicitly states the places where a data class diverts from its default behavior, reducing the amount of code that must be read by a user to understand its behavior.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Additional methods and constructors</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The compiler generates a default constructor for a data class, together with accessor methods, and default implementation of the methods from the object class. A developer can overload the constructors and add more methods to a data class:</p>
<pre class="calibre14">record Emp(String name, int age) { 
    // overloading constructor 
    public Emp(String name, String style) { 
            this.name = name; 
            if (style.equals("COOL") age = 20; 
            else if (style.equals("SAFE") age = 30; 
            else if (style.equals("ELEGANT") age = 50; 
            else age = 70; 
        } 
    } 
    public String fancyOutput() {                 // additional method 
        return "My style is COOL"; 
    } 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Mutability</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Work is still in progress on whether the data classes should be designated as mutable or immutable. Both have their own advantages and disadvantages. Immutable data works well in multi-threaded, parallel or concurrent systems. On the other hand, mutable data is also data. Mutable data works well with cases that require frequent modification to data. The following image depicts the confusion:</p>
<div class="cdpaligncenter"><img src="Images/33c2eb96-0e4f-4bbd-a647-d80ec95e1a47.png" width="698" height="522" class="calibre28"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Thread safety</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Since the data classes are not yet designated to be immutable, it is the responsibility of the developers to use them in thread safe configurations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Data classes proposes to bring to developers a simple and concise way to model data as data. It will include language changes with the introduction of keyword record. The work is still in progress on the data classes at Oracle. The proposed data classes are different from the existing POJOs, which are full-fledged classes which are modelled as data classes by developers. Data classes will use the keyword record to encapsulate data in its class header.</p>
<p class="calibre6">Until now, classes have been used to model and implement a wide range of requirements. Though this has been working fine, it does require extra work at places where the cost far exceeds the benefits it offers. With an example from the past (enums), you covered how addition of a feature empowers developers to use a concise way to defining entities, but which might lose some of the finer control. Similarly, the data classes offer a simplified way of encapsulating just a set of data.</p>
<p class="calibre6">You covered the need of the data classes with their importance in reducing the code that should be read by any developer. The main goal of the data classes is to model data as data, and not to reduce the boilerplate code.</p>
<p class="calibre6">The Java platform provides default implementation of the methods to access the state a data class, default constructor and default implementations of the methods of class object (<kbd class="calibre9">equals()</kbd>, <kbd class="calibre9">hashCode()</kbd>, and <kbd class="calibre9">toString()</kbd>). You can add fields or behaviors (including constructors) to a data class, and also override the default implementation of all its methods. Data classes can be defined as abstract. They can extend abstract classes and implement interfaces.</p>
<p class="calibre6">You covered the aggregate and the exploded form of a data class. The data classes can be used with other language constructs like switch.</p>
<p class="calibre6">By default, the data classes are not mutable, including the arrays defined as the data member. Since these structures are not immutable, a developer must include code to ensure thread safety, when working with them.</p>


            </article>

            
        </section>
    </div>



  </body></html>