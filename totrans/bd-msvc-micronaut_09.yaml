- en: '*Chapter 6*: Testing Microservices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：测试微服务'
- en: In a rather simple definition, **software testing** is verifying that a produced
    software application is functioning as expected. Since the early days of programming
    languages and software development, good precedents have been set to ensure they
    are **functioning as expected**. Almost all programming languages (barring some
    scripting languages) have robust compilers to catch anomalies at compile time.
    Though compile-time checks are good to start with, they can't verify whether a
    software application will run just as expected at runtime. For peace of mind,
    software development teams perform various kinds of testing to verify that a software
    application will function as expected. And any testing exercise will increase
    manifold with an increase in the number of distributed components or, put simply,
    it's rather more easy to test a monolithic application than a distributed one.
    To save time and decrease the turnaround time to deliver a feature, it's efficient
    to automate testing at various levels.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个相当简单的定义中，**软件测试**是验证产生的软件应用程序是否按预期工作。自从编程语言和软件开发初期以来，已经建立了良好的先例来确保它们**按预期工作**。几乎所有编程语言（除了某些脚本语言）都有强大的编译器来在编译时捕获异常。尽管编译时检查是一个好的开始，但它们不能验证软件应用程序在运行时是否会按预期运行。为了安心，软件开发团队会执行各种类型的测试来验证软件应用程序将按预期工作。随着分布式组件数量的增加，任何测试练习都会成倍增加，简单来说，测试单体应用程序比分布式应用程序要容易得多。为了节省时间和减少交付特性的周转时间，自动化不同级别的测试是高效的。
- en: 'In this chapter, we will explore how we can automate testing at various levels
    of microservices. We will dive into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在不同级别的微服务中自动化测试。我们将深入以下主题：
- en: Understanding the testing pyramid
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试金字塔
- en: Unit testing in the Micronaut framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micronaut框架中的单元测试
- en: Service testing in the Micronaut framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micronaut框架中的服务测试
- en: Integration testing using test containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试容器进行集成测试
- en: By the end of this chapter, you will have handy knowledge of automating testing
    at various levels of microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握在微服务不同级别自动化测试的实用知识。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available on the book's
    GitHub at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在Windows 10和macOS上运行。本章涵盖的代码示例可在本书的GitHub上找到，地址为[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06)。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具需要在开发环境中安装和设置：
- en: '**Java SDK** version 13 or above (we used Java 14)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**版本13或更高（我们使用了Java 14）'
- en: '**Maven**: It is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：这是可选的，只有当你想使用Maven作为构建系统时才需要。然而，我们建议在任何开发机器上设置Maven。下载和安装Maven的说明可以在[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)找到。'
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发IDE**：根据您的偏好，可以使用任何基于Java的IDE，但为了编写本章，使用了IntelliJ。'
- en: '**Git**: Instructions to download and install it can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：下载和安装的说明可以在[https://git-scm.com/downloads](https://git-scm.com/downloads)找到。'
- en: '**PostgreSQL**: Instructions to download and install it can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：下载和安装的说明可以在[https://www.postgresql.org/download/](https://www.postgresql.org/download/)找到。'
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service offering
    of up to 512 MB storage. However, if a local database is preferred, then instructions
    to download and install it can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation to write this chapter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**: MongoDB Atlas 提供了高达 512 MB 存储空间的免费在线数据库服务。然而，如果您更喜欢本地数据库，可以在[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)找到下载和安装的说明。我们使用本地安装来编写这一章节。'
- en: '**REST client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST 客户端**：可以使用任何 HTTP REST 客户端。我们使用了 Advanced REST Client Chrome 插件。'
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：有关下载和安装 Docker 的说明，请参阅[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。'
- en: Understanding the testing pyramid
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试金字塔
- en: 'The testing pyramid is an easy concept to understand the relative notion of
    performance, expense, and robustness for the different kinds of testing. The following
    diagram shows various kinds of testing in the testing pyramid and how much effort
    is required:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔是一个易于理解不同测试类型相对性能、成本和健壮性的概念。以下图表显示了测试金字塔中的各种测试类型以及所需的努力：
- en: '![Figure 6.1 – Test pyramid'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 测试金字塔'
- en: '](img/Figure_6.1_B16585.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B16585.jpg)'
- en: Figure 6.1 – Test pyramid
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 测试金字塔
- en: As depicted in the preceding diagram, unit testing is fast, robust, and inexpensive
    whereas as we go towards the top of the pyramid, testing becomes sluggish, brittle,
    and expensive. Though all kinds of testing are required to fully verify whether
    the application is working as expected, a fine balance is critical to cut expenses
    and increase robustness and speed. Put simply, have a lot of unit tests, a number
    of service tests, and very few end-to-end tests. This will ensure quality at a
    greater speed and with less cost.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，单元测试快速、健壮且成本低，而当我们接近金字塔的顶部时，测试变得缓慢、脆弱且昂贵。尽管所有类型的测试都是验证应用程序是否按预期工作所必需的，但良好的平衡对于降低成本、提高健壮性和速度至关重要。简单来说，要有大量的单元测试、一定数量的服务测试和非常少的端到端测试。这将确保以更快的速度和更低的成本保证质量。
- en: In the next section, we will begin the automated testing journey with unit testing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从单元测试开始自动化测试之旅。
- en: Unit testing in the Micronaut framework
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Micronaut 框架中的单元测试
- en: In the object-oriented paradigm, an object can assume multiple behaviors. These
    behaviors are defined by their methods. Effective unit testing probes a single
    behavior of an object at a time. This doesn't translate to testing a method as
    a method can change its behavior by taking different execution paths (if the method
    has forked control flow). Therefore, essentially, a unit test will probe one execution
    path of a method at a time. Iteratively, we can add more unit tests to probe other
    execution paths in the same or other methods. This bottom-up approach relies on
    verifying behaviors at smaller, isolated levels so the application as a whole
    will work as expected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的范式下，一个对象可以具有多种行为。这些行为由它们的方法定义。有效的单元测试一次探测一个对象的行为。这并不意味着测试一个方法，因为方法可以通过不同的执行路径（如果方法有分叉的控制流）改变其行为。因此，本质上，单元测试一次将探测一个方法的单个执行路径。迭代地，我们可以添加更多的单元测试来探测相同或不同方法中的其他执行路径。这种自下而上的方法依赖于在较小、隔离的级别验证行为，以确保整个应用程序按预期工作。
- en: 'To perform a unit test, isolation is required. Essentially, we need to isolate
    the object''s behavior (that we want to test) while ignoring the object''s interaction
    with other objects/components within the system. To achieve this isolation, we
    have various mechanisms in unit testing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行单元测试，需要隔离。本质上，我们需要隔离对象的行为（我们想要测试的行为），同时忽略对象与系统内其他对象/组件的交互。为了实现这种隔离，我们在单元测试中有各种机制：
- en: '**Mocking**: Mocking is an operation to create a test double in which a testing
    framework will create a mock/dummy object based on the class definition of the
    object (compile time). To isolate the subject object''s interaction with other
    interacting objects, we can simply mock the interacting objects. When a unit test
    is executed for the subject object, it will skip interactions with other objects.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**：模拟是一个创建测试替身的操作，其中测试框架将根据对象的类定义创建一个模拟/虚拟对象（编译时）。为了隔离主题对象与其他交互对象的交互，我们可以简单地模拟交互对象。当对主题对象执行单元测试时，它将跳过与其他对象的交互。'
- en: '**Spying**: Using spying we create a test double by probing the actual instance
    of the object (runtime). A spy object will just be the same as the real object
    barring any stubs. Stubs are used to define a dummy invocation so that the spy
    object will execute normally but when an invocation matches a stub definition,
    then it will execute the dummy behavior defined by the stub.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视**：通过监视，我们通过探测对象的实际实例（运行时）创建一个测试替身。监视对象将只是与真实对象相同，除了任何存根。存根用于定义一个虚拟调用，以便监视对象可以正常执行，但当调用与存根定义匹配时，它将执行由存根定义的虚拟行为。'
- en: Though mocking and spying can help to isolate the behavior, sometimes the subject
    object may not be interacting with other objects so no test doubles are required.
    In the next section, we will begin with how to implement unit tests in the Micronaut
    framework using JUnit 5.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟和监视可以帮助隔离行为，但有时主题对象可能没有与其他对象交互，因此不需要测试替身。在下一节中，我们将从如何在Micronaut框架中使用JUnit
    5实现单元测试开始。
- en: Unit testing using JUnit 5
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JUnit 5进行单元测试
- en: 'In order to learn how to implement unit tests in the Micronaut framework, we
    will resume the code base from [*Chapter 5*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106),
    *Integrating Microservices Using* *the* *Event-Driven Architecture*. We will continue
    with the pet-owner microservice and make sure you have the following dependencies
    added to the project `pom.xml`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何在Micronaut框架中实现单元测试，我们将从[*第5章*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106)，*使用事件驱动架构集成微服务*继续代码库。我们将继续使用宠物-所有者微服务，并确保你已经将以下依赖项添加到项目的`pom.xml`文件中：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By importing the preceding JUnit dependencies, we can leverage the JUnit and
    Micronaut test toolkit in the pet-owner microservice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入前面的JUnit依赖项，我们可以在宠物-所有者微服务中利用JUnit和Micronaut测试工具包。
- en: 'Next, we will create a `TestUtil` class in `com.packtpub.micronaut.util` that
    can encapsulate some essential testing methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`com.packtpub.micronaut.util`中创建一个`TestUtil`类，它可以封装一些基本的测试方法：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `TestUtil`, we have added the `equalsVerifier()` method, which can verify
    whether two objects are equal or not. This method takes a class type as an input
    parameter to assert different conditions on tested objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TestUtil`中，我们添加了`equalsVerifier()`方法，该方法可以验证两个对象是否相等。此方法接受一个类类型作为输入参数，以对测试对象的不同条件进行断言。
- en: In the next section, we will explore how to unit test a domain object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何对领域对象进行单元测试。
- en: Unit testing a domain object
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试领域对象
- en: 'A domain object is simply a `Owner` class in the pet-owner microservice. In
    the followed code snippet, we are creating an `OwnerTest` class to assert the
    equality of two owner instances:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 领域对象在宠物-所有者微服务中简单来说就是一个`Owner`类。在下面的代码片段中，我们创建了一个`OwnerTest`类来断言两个所有者实例的相等性：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `OnwerTest` class contains a test method, `equalsVerifier()`. An annotation,
    `org.junit.jupiter.api.Test`, is used to mark it as a test method. To verify the
    expected behavior, we are using assert statements. Similarly, we can define test
    classes for other domain objects in the pet-owner microservice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnwerTest`类包含一个测试方法`equalsVerifier()`。使用`org.junit.jupiter.api.Test`注解将其标记为测试方法。为了验证预期的行为，我们使用断言语句。同样，我们可以在宠物-所有者微服务中为其他领域对象定义测试类。'
- en: In the next section, we will unit test a mapper object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对映射器对象进行单元测试。
- en: Unit testing a mapper object
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试映射器对象
- en: 'Our mapper objects in the pet-owner microservice are simple and we can create
    a basic test for an `OwnerMapper` class using the `@Test` annotation. In the following
    code snippet, `OwnerMapperTest` is unit-testing the `fromId()` method in `OwnerMapper`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在宠物-所有者微服务中的映射器对象很简单，我们可以使用`@Test`注解为`OwnerMapper`类创建一个基本的测试。在下面的代码片段中，`OwnerMapperTest`正在对`OwnerMapper`中的`fromId()`方法进行单元测试：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `OwnerMapperTest` class contains a test method, `testEntityFromId()`. To
    verify the expected behavior we are using `assert` statements. Similarly, we can
    define test classes for other mapper objects in the pet-owner microservice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerMapperTest` 类包含一个测试方法 `testEntityFromId()`。为了验证预期的行为，我们使用了 `assert` 语句。同样，我们还可以为宠物-所有者微服务中的其他映射对象定义测试类。'
- en: Hitherto, we wrote simple unit tests for domain and mapper objects that didn't
    require any test doubles. In the next section, we will explore how we can use
    mocking to create the desired test doubles.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为不需要任何测试替身的领域和映射对象编写了简单的单元测试。在下一节中，我们将探讨如何使用模拟来创建所需的测试替身。
- en: Using mocks in unit testing
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单元测试中使用模拟
- en: As we discussed before, mocking a testing framework will create a test double
    based on the class definition. These test doubles come in handy in unit testing
    an object where the object invokes methods on other objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模拟测试框架将基于类定义创建一个测试替身。这些测试替身在单元测试中调用其他对象的方法的对象时非常有用。
- en: 'In order to learn about mocking in unit testing, we will work on the `VetService`
    class in the pet-clinic microservice. Let''s look at `VetServiceImpl` in the pet-clinic
    microservice:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解单元测试中的模拟，我们将对宠物诊所微服务中的 `VetService` 类进行工作。让我们看看宠物诊所微服务中的 `VetServiceImpl`：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`VetService` instantiates `VetRepository`, `SpecialtyRepository`, `VetMapper`,
    and `SpecialtyMapper` in the constructor. These instantiated objects are then
    used in `VetService` methods. To unit test the `VetService` object, we would need
    to define mocks for some of these interacting objects.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetService` 在构造函数中实例化了 `VetRepository`、`SpecialtyRepository`、`VetMapper` 和
    `SpecialtyMapper`。这些实例化的对象随后在 `VetService` 方法中使用。为了对 `VetService` 对象进行单元测试，我们需要为这些交互对象定义模拟对象。'
- en: 'Let''s create `VetServiceTest` to encapsulate unit tests for `VetService`.
    In this test class, we will mock some interacting objects using the `@MockBean`
    annotation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `VetServiceTest` 来封装 `VetService` 的单元测试。在这个测试类中，我们将使用 `@MockBean` 注解模拟一些交互对象：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `VetServiceTest` class is annotated with the `@MicronautTest` annotation.
    It runs the test class as an actual Micronaut application with the full application
    context, thereby avoiding the artificial separation between production code and
    test code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetServiceTest` 类被 `@MicronautTest` 注解标记。它将测试类作为一个实际的 Micronaut 应用程序运行，具有完整的应用程序上下文，从而避免了生产代码和测试代码之间的人工分离。'
- en: To inject the interacting objects, we are using `@Inject` annotations. `@Inject`
    injects a bean from the application context into the class. Furthermore, using
    the `@MockBean` annotation, we are overriding the runtime beans for `VetRepository`
    and `SpecialtyRepository`. `@MockBean` will replace the actual objects with mocked
    objects in the application context.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注入交互对象，我们使用了 `@Inject` 注解。`@Inject` 将应用程序上下文中的一个 bean 注入到类中。此外，使用 `@MockBean`
    注解，我们正在覆盖 `VetRepository` 和 `SpecialtyRepository` 的运行时 bean。`@MockBean` 将在应用程序上下文中用模拟对象替换实际对象。
- en: 'We can easily use these test double mocks in writing a unit test for the `VetService`
    method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用这些测试替身模拟在编写 `VetService` 方法的单元测试：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, you can see how we are defining stubs for the
    mocked `VetRepository` and `SpecialtyRepository` classes. Usually, a mock stub
    takes the form of `when(object.methodCall()).thenReturn(result)`, except in the
    case of void method calls, where it is `doNothing().when(object).methodCall()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到我们是如何为模拟的 `VetRepository` 和 `SpecialtyRepository` 类定义存根的。通常，模拟存根的形式为
    `when(object.methodCall()).thenReturn(result)`，除非是 void 方法调用，此时为 `doNothing().when(object).methodCall()`。
- en: Ideally, it's prudent to follow up mock stubs with `verify()` statements. `verify()`
    will confirm that, indeed, the desired method calls were made while executing
    the unit test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在模拟存根之后跟随 `verify()` 语句是谨慎的。`verify()` 将确认在执行单元测试期间确实调用了所需的方法调用。
- en: In the next section, we will explore another way of creating test doubles using
    spies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨另一种使用间谍创建测试替身的方法。
- en: Using spies in unit testing
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单元测试中使用间谍
- en: As we discussed before, spying on a testing framework will create a test double
    based on the actual runtime object of the class. While mocking creates a full
    test double of the real object, with spying we can control whether the test double
    is partial or full. In a spied object, we can stub some method calls while keeping
    other method calls real. In such a scenario, the unit test will make dummy as
    well as real calls. Therefore, spying gives a bit more control over what we want
    to fake.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，在测试框架上间谍将基于类的实际运行时对象创建一个测试双胞胎。虽然模拟创建了一个完整的真实对象测试双胞胎，但在间谍中，我们可以控制测试双胞胎是部分还是完整的。在间谍对象中，我们可以存根一些方法调用，同时保持其他方法调用为真实。在这种情况下，单元测试将进行模拟和真实调用。因此，间谍为我们提供了更多控制权，以确定我们想要伪造的内容。
- en: 'In order to learn about spying in unit testing, we will work on the `SpecialtyService`
    class in the pet-clinic microservice. Let''s look at `SpecialtyServiceImpl` in
    the pet-clinic microservice:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解单元测试中的间谍技术，我们将在 pet-clinic 微服务中处理 `SpecialtyService` 类。让我们看看 pet-clinic
    微服务中的 `SpecialtyServiceImpl`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`SpecialtyService` is instantiating `SpecialtyRepository` and `SpecialtyMapper`
    in the constructor. These instantiated objects are then used in `SpecialtyService`
    methods. To unit test the `SpecialtyService` object, we would need to define spies
    for some of these interacting objects.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpecialtyService` 在构造函数中实例化了 `SpecialtyRepository` 和 `SpecialtyMapper`。这些实例化的对象随后在
    `SpecialtyService` 方法中使用。为了对 `SpecialtyService` 对象进行单元测试，我们需要为这些交互对象定义一些间谍。'
- en: 'Let''s create `SpecialtyServiceTest` for encapsulating unit tests for `SpecialtyService`.
    In this test class, we will spy some interacting objects using the `@MockBean`
    annotation and `spy()` method in JUnit:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `SpecialtyServiceTest` 来封装 `SpecialtyService` 的单元测试。在这个测试类中，我们将使用 `@MockBean`
    注解和 JUnit 中的 `spy()` 方法来间谍一些交互对象：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `SpecialtyServiceTest` class is annotated with `@MicronautTest`, which runs
    the test class as an actual Micronaut application with the full application context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpecialtyServiceTest` 类被 `@MicronautTest` 注解，它将测试类作为实际的 Micronaut 应用程序运行，具有完整的应用程序上下文。'
- en: 'Using the `@MockBean` annotation, we are overriding the runtime bean for `SpecialtyRepository`.
    `@MockBean` will replace the actual object with the spied object in the application
    context. On the spied `SpecialtyRepository` object, we can easily define some
    stubs that will be executed in the test method instead of the actual invocation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@MockBean` 注解，我们正在覆盖 `SpecialtyRepository` 的运行时 Bean。`@MockBean` 将在应用程序上下文中用间谍对象替换实际对象。在间谍
    `SpecialtyRepository` 对象上，我们可以轻松定义一些在测试方法中执行而不是实际调用的存根：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, you can see how we are defining stubs for the
    spied `SpecialtyRepository` instance. Usually, a spy stub takes the form of `doReturn(result).when(object).methodCall()`,
    except in the case of void method calls, where it is `doNothing().when(object).methodCall()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到我们是如何为间谍 `SpecialtyRepository` 实例定义存根的。通常，间谍存根的形式为 `doReturn(result).when(object).methodCall()`，除非是
    void 方法调用，此时为 `doNothing().when(object).methodCall()`。
- en: Again, it's prudent to follow up spied stubs with `verify()` statements. These
    will confirm whether the desired method calls were made while executing the unit
    test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在间谍存根之后跟随 `verify()` 语句是明智的。这些语句将确认在执行单元测试时是否执行了期望的方法调用。
- en: Hitherto, we have learned the various ways to unit test using mocks and spies.
    In the next section, we will explore how we can perform service testing in the
    Micronaut framework.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用模拟和间谍进行单元测试的各种方法。在下一节中，我们将探讨如何在 Micronaut 框架中执行服务测试。
- en: Service testing in the Micronaut framework
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Micronaut 框架中的服务测试
- en: '**Service testing** is the next level to unit testing. By testing all the endpoints
    in a microservice and repeating this process for all the other microservices,
    we can make sure that all the services are working as expected edge to edge. It
    raises the quality check to the next level. Having said that, as we discussed
    before, as we move up in the test pyramid, test cases become more brittle, expensive,
    and sluggish, therefore, we need to establish a fine balance of not testing too
    much on the higher levels.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务测试**是单元测试的下一级。通过测试微服务中的所有端点，并对所有其他微服务重复此过程，我们可以确保所有服务都按预期从边缘到边缘工作。它将质量检查提升到下一个层次。话虽如此，正如我们之前讨论的，当我们向上移动到测试金字塔时，测试用例变得更加脆弱、昂贵和缓慢，因此，我们需要在高级别上不过度测试之间建立良好的平衡。'
- en: To learn how we can perform service testing in the Micronaut framework, we will
    continue with the pet-clinic microservice. In the following sections, we will
    go into testing all the REST endpoints of a service. We will use the `@Order`
    annotation to establish the order of execution of a test in the suite. An ordered
    test suite can help in starting from scratch and cleaning up at the end. In the
    following examples, we will create, get, update, and finally delete the resource.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何在 Micronaut 框架中执行服务测试，我们将继续使用 pet-clinic 微服务。在接下来的几节中，我们将进入测试服务的所有 REST
    端点。我们将使用 `@Order` 注解来建立套件中测试的执行顺序。一个有序的测试套件可以帮助从头开始并最终清理。在以下示例中，我们将创建、获取、更新，最后删除资源。
- en: Creating the test suite
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建测试套件
- en: 'To test the `VetResource` endpoints, let''s create a `VetResourceIntegrationTest`
    class. This suite will encapsulate all the happy and unhappy integration tests:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `VetResource` 端点，让我们创建一个 `VetResourceIntegrationTest` 类。这个套件将封装所有快乐和不快乐的集成测试：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a few things to ponder in the preceding code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，有几个值得思考的点：
- en: '`transactional = false` ensures that the suite runs without the transaction.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transactional = false` 确保套件在没有事务的情况下运行。'
- en: '`@Property` annotation overrides the application configuration. And in our
    case, we are disabling the security.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Property` 注解覆盖了应用程序配置。在我们的情况下，我们禁用了安全。'
- en: '`TestInstance.Lifecycle.PER_CLASS` boots up the instance and keeps the application
    context for the whole suite. You can instantiate a test object and application
    context at the test method level using `@TestInstance(TestInstance.Lifecycle.PER_METHOD)`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestInstance.Lifecycle.PER_CLASS` 启动实例并保持整个套件的应用程序上下文。您可以在测试方法级别使用 `@TestInstance(TestInstance.Lifecycle.PER_METHOD)`
    实例化测试对象和应用程序上下文。'
- en: '`@TestMethodOrder annotation` in JUnit is used to define the execution order
    of each test method in the test suite.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 中的 `@TestMethodOrder` 注解用于定义测试套件中每个测试方法的执行顺序。
- en: '**@Inject @Client**: This annotation injects a reactive HTTP client (built
    in Micronaut) to perform RESTful calls to the resource endpoints.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Inject @Client**：此注解注入了一个反应式 HTTP 客户端（内置在 Micronaut 中），用于对资源端点执行 RESTful
    调用。'
- en: After setting up the test suite, we are good to perform service testing. In
    the next few sections, we will cover all the restful calls in the test methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好测试套件后，我们可以进行服务测试。在接下来的几节中，我们将介绍测试方法中的所有 REST 调用。
- en: Testing the create endpoint
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试创建端点
- en: '`VetResource` has a POST endpoint for creating a new `Vet`. It accepts `VetDTO`
    in the request body. Let''s use the HTTP client to create a vet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetResource` 有一个用于创建新 `Vet` 的 POST 端点。它接受请求体中的 `VetDTO`。让我们使用 HTTP 客户端创建一个兽医：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding test, we are creating a `VetDTO` object and invoking the POST
    endpoint using the HTTP client. To make the reactive client return the observable
    and make a pseudo-synchronous call, we are using `blockingFirst()`. It blocks
    the thread until the observable emits an item, then returns the first item emitted
    by the observable. Finally, we are asserting to confirm the expected versus the
    actual behavior.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们正在创建一个 `VetDTO` 对象，并使用 HTTP 客户端调用 POST 端点。为了使反应式客户端返回可观察对象并执行伪同步调用，我们使用了
    `blockingFirst()`。它阻塞线程直到可观察对象发出一个项，然后返回可观察对象发出的第一个项。最后，我们断言以确认预期的与实际的行为。
- en: Testing the `GET` endpoint
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 `GET` 端点
- en: 'In the proceeding test, we created a new vet in the POST endpoint service test.
    We can leverage just the persisted vet to test the `GET` endpoint:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的测试中，我们在 POST 端点服务测试中创建了一个新的兽医。我们可以仅利用持久化的兽医来测试 `GET` 端点：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding tests, we are testing two endpoints, `getVet()` and `getAllVets()`.
    To make the reactive client return the results, we are using the `blockingFirst()`
    operator. While `getAllVets()` will return a list of vets, `getVet()` will return
    the desired vet object only.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们正在测试两个端点，`getVet()` 和 `getAllVets()`。为了使反应式客户端返回结果，我们使用了 `blockingFirst()`
    操作符。虽然 `getAllVets()` 将返回兽医列表，但 `getVet()` 只会返回所需的兽医对象。
- en: Testing the update endpoint
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试更新端点
- en: 'To test the `update` endpoint, we will leverage the vet resource persisted
    in the created endpoint service test, therefore, use an order after the `create`
    and `GET` calls:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `update` 端点，我们将利用创建的端点服务测试中持久化的兽医资源，因此，在 `create` 和 `GET` 调用之后使用一个顺序：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding test, we tested the `updateVet()` endpoint. We first fetched
    the persisted vet and then updated the first and last name before invoking the
    update endpoint. Finally, we asserted to confirm the actual behavior meets the
    expected behavior.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们测试了`updateVet()`端点。我们首先获取了持久化的vet，然后更新了名字和姓氏，在调用更新端点之前。最后，我们断言以确认实际行为符合预期行为。
- en: Testing the delete endpoint
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试删除端点
- en: 'To test the `delete` endpoint, we will leverage the vet resource persisted
    in the earlier endpoint calls. Therefore, we will use an order after the `create`,
    `GET`, and `update` calls:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`delete`端点，我们将利用在早期端点调用中持久化的vet资源。因此，我们将在`create`、`GET`和`update`调用之后使用一个订单：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding test, we tested the `deleteVet()` endpoint. We are passing
    the previously persisted `vetId`. And after the successful service call, we are
    asserting to confirm the actual behavior meets the expected behavior by comparing
    the database size before and after the service call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们测试了`deleteVet()`端点。我们传递了之前持久化的`vetId`。在成功调用服务后，我们通过比较服务调用前后的数据库大小来断言以确认实际行为符合预期行为。
- en: The test orders in the suite ensure that we always start from scratch and leave
    it clean after finishing all the tests in the suite. There are pros and cons to
    this pattern for service testing compared to setting up and cleaning up at the
    test method level. You can pick and choose a pattern after analyzing the application
    requirements and whether to use suite setup and cleanup or at the test method
    level.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 套件中的测试订单确保我们始终从头开始，并在完成套件中的所有测试后将其清理干净。与在测试方法级别设置和清理相比，这种模式对于服务测试既有优点也有缺点。您可以根据分析应用程序需求和是否使用套件设置和清理或测试方法级别来选择和选择一种模式。
- en: In the next section, we will explore the exciting world of `Testcontainers`
    for integration testing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索`Testcontainers`在集成测试中的精彩世界。
- en: Integration testing using Testcontainers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Testcontainers进行集成测试
- en: '`Testcontainers` is a Java library that elegantly marries the world of testing
    with Docker virtualization. Using the `Testcontainers` library, we can set up,
    instantiate, and inject any Docker container into the testing code. This approach
    opens up many avenues for performing integration testing. In the test suite or
    test method setup, we can boot up a Dockerized database, Kafka or email server
    or any integrating app, perform the integration tests, and destroy the Dockerized
    app in the cleanup. With this pattern, we are up close to the production environment
    while not impacting the environment with any after-testing side effects.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Testcontainers`是一个Java库，它优雅地将测试世界与Docker虚拟化相结合。使用`Testcontainers`库，我们可以设置、实例化和注入任何Docker容器到测试代码中。这种方法为执行集成测试开辟了许多途径。在测试套件或测试方法设置中，我们可以启动一个Docker化的数据库、Kafka或邮件服务器或任何集成应用程序，执行集成测试，并在清理中销毁Docker化的应用程序。使用这种模式，我们接近生产环境，同时不会对环境产生任何测试后的副作用。'
- en: To learn how we can use the `Testcontainers` library, we will experiment on
    the pet-clinic-reviews microservice that integrates with MongoDB. In the next
    section, we will begin setting up `Testcontainers` in the Micronaut application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何使用`Testcontainers`库，我们将在与MongoDB集成的pet-clinic-reviews微服务上进行实验。在下一节中，我们将开始设置Micronaut应用程序中的`Testcontainers`。
- en: Setting up the Testcontainers in the Micronaut application
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Micronaut应用程序中设置Testcontainers
- en: 'To use `Testcontainers` in the pet-clinic-reviews microservice, add the following
    dependencies in the project `pom.xml`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要在pet-clinic-reviews微服务中使用`Testcontainers`，请在项目的`pom.xml`文件中添加以下依赖项：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By importing a MongoDB flavored test container, we will be able to leverage
    the MongoDB Docker toolkit. After importing the required `Testcontainers` dependencies,
    let''s set up an abstract class that can provide any app containers required by
    the integration tests:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入一个MongoDB风格的测试容器，我们将能够利用MongoDB Docker工具包。在导入所需的`Testcontainers`依赖项后，让我们设置一个抽象类，它可以提供集成测试所需的任何应用程序容器：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `AbstractContainerBaseTest`, we configure and boot up a MongoDB instance
    in Docker statically. The static nature of this container will simplify access
    and avoid booting up too many instances at the test suite or test method level.
    `Testcontainers` elegantly, and with minimal code, pulls up a MongoDB Docker image,
    boots it up, and starts it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AbstractContainerBaseTest`中，我们配置并启动Docker中的MongoDB实例。这个容器的静态性质将简化访问并避免在测试套件或测试方法级别启动太多实例。`Testcontainers`优雅地，用最少的代码拉取MongoDB
    Docker镜像，启动它，并使其运行。
- en: In the next section, we will write integration tests using `Testcontainers`
    for `VetReviewRepository`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 `Testcontainers` 为 `VetReviewRepository` 编写集成测试。
- en: Writing integration tests using Testcontainers
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Testcontainers 编写集成测试
- en: 'In the preceding section, we covered how we can use `Testcontainers` to create
    a Dockerized MongoDB. We will proceed to test `VetReviewRepository` using the
    Docker MongoDB instance. Let''s begin with the test suite and test method setups:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们介绍了如何使用 `Testcontainers` 创建 Docker 化的 MongoDB。我们将继续使用 Docker MongoDB
    实例来测试 `VetReviewRepository`。让我们从测试套件和测试方法设置开始：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the test suite setup, we are overriding the application properties for MongoDB.
    Furthermore, we are fetching the `VetReviewRepository` bean from the application
    context. This will make sure we are injecting the repository bean that is communicating
    with the Dockerized MongoDB. And, in the test method setup, we are ensuring that
    the MongoDB container is running before we execute the test method. Since we have
    set up at the test suite and test method level, let''s jump ahead in writing an
    integration test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试套件设置中，我们正在覆盖 MongoDB 的应用程序属性。此外，我们从应用程序上下文中获取 `VetReviewRepository` 实例。这将确保我们注入的是与
    Docker 化的 MongoDB 通信的仓库实例。在测试方法设置中，我们确保在执行测试方法之前 MongoDB 容器正在运行。由于我们在测试套件和测试方法级别进行了设置，让我们继续编写集成测试：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `saveVetReview()` test, we are creating a new vet review and invoking
    on `VetReviewRepository` to persist this vet review. Finally, we are asserting
    that the vet review was persisted successfully by fetching and comparing the values.
    We are using the `@Order` pattern in the test suite so later tests can ensure
    the cleanup.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `saveVetReview()` 测试中，我们创建一个新的兽医评审并调用 `VetReviewRepository` 来持久化这个评审。最后，我们通过获取并比较值来断言兽医评审已成功持久化。我们在测试套件中使用
    `@Order` 模式，以便后续测试可以确保清理。
- en: In this section, we explored how `Testcontainers` can simplify integration tests
    by spinning off Docker instances of the database or other service components.
    We implemented integration tests for `VetReviewRepository` by creating a MongoDB
    test container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何通过启动数据库或其他服务组件的 Docker 实例来简化集成测试。我们通过创建 MongoDB 测试容器实现了 `VetReviewRepository`
    的集成测试。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter with the testing pyramid and striking a fine balance in
    test automation with unit testing, service testing, and integration testing. We
    jumpstarted with some basics of unit testing, such as leveraging mocks and spies
    to write unit tests. We then dived into how we can write service tests to test
    various RESTful endpoints using a reactive HTTP client in the Micronaut framework.
    Finally, we explored the exciting world of test containers for integration testing.
    We wrote integration tests using `Testcontainer` to instantiate MongoDB in the
    test environment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从测试金字塔开始，在单元测试、服务测试和集成测试的自动化测试中找到一个良好的平衡。我们首先介绍了单元测试的一些基础知识，例如利用模拟和间谍来编写单元测试。然后我们深入探讨了如何在
    Micronaut 框架中使用响应式 HTTP 客户端编写服务测试以测试各种 RESTful 端点。最后，我们探索了集成测试的激动人心的世界，我们使用 `Testcontainer`
    在测试环境中实例化 MongoDB。
- en: This chapter provides you with a firm understanding of testing at various levels,
    such as unit, service, or integration in the Micronaut framework. After subtle
    yet nimble theoretical discussions, we followed up with good hands-on examples
    to enhance your practical skillset in automated testing in the Micronaut framework.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了对 Micronaut 框架中不同级别测试（如单元、服务或集成）的深入理解。在细微而灵活的理论讨论之后，我们通过一些实用的示例来增强您在
    Micronaut 框架中自动化测试的实践技能。
- en: In the next chapter, we will explore how we can handle microservice architecture
    concerns in the Micronaut framework.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 Micronaut 框架中处理微服务架构问题。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is unit testing?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是什么？
- en: What is mocking in unit testing?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试中的模拟是什么？
- en: How can we mock in the Micronaut framework using JUnit?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中使用 JUnit 进行模拟？
- en: What is spying in unit testing?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试中的间谍活动是什么？
- en: How can we spy in the Micronaut framework using JUnit?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中使用 JUnit 进行间谍活动？
- en: How can we write service tests in the Micronaut framework?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中编写服务测试？
- en: What are test containers?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试容器是什么？
- en: How can you use test containers in the Micronaut framework?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Micronaut 框架中使用测试容器？
- en: How do you write integration tests in the Micronaut framework?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中编写集成测试？
