- en: '*Chapter 6*: Testing Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a rather simple definition, **software testing** is verifying that a produced
    software application is functioning as expected. Since the early days of programming
    languages and software development, good precedents have been set to ensure they
    are **functioning as expected**. Almost all programming languages (barring some
    scripting languages) have robust compilers to catch anomalies at compile time.
    Though compile-time checks are good to start with, they can't verify whether a
    software application will run just as expected at runtime. For peace of mind,
    software development teams perform various kinds of testing to verify that a software
    application will function as expected. And any testing exercise will increase
    manifold with an increase in the number of distributed components or, put simply,
    it's rather more easy to test a monolithic application than a distributed one.
    To save time and decrease the turnaround time to deliver a feature, it's efficient
    to automate testing at various levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore how we can automate testing at various levels
    of microservices. We will dive into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the testing pyramid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing in the Micronaut framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service testing in the Micronaut framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing using test containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have handy knowledge of automating testing
    at various levels of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and macOS. Code examples covered in this chapter are available on the book's
    GitHub at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK** version 13 or above (we used Java 14)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: It is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install it can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Instructions to download and install it can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service offering
    of up to 512 MB storage. However, if a local database is preferred, then instructions
    to download and install it can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation to write this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testing pyramid is an easy concept to understand the relative notion of
    performance, expense, and robustness for the different kinds of testing. The following
    diagram shows various kinds of testing in the testing pyramid and how much effort
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Test pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Test pyramid
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in the preceding diagram, unit testing is fast, robust, and inexpensive
    whereas as we go towards the top of the pyramid, testing becomes sluggish, brittle,
    and expensive. Though all kinds of testing are required to fully verify whether
    the application is working as expected, a fine balance is critical to cut expenses
    and increase robustness and speed. Put simply, have a lot of unit tests, a number
    of service tests, and very few end-to-end tests. This will ensure quality at a
    greater speed and with less cost.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will begin the automated testing journey with unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the object-oriented paradigm, an object can assume multiple behaviors. These
    behaviors are defined by their methods. Effective unit testing probes a single
    behavior of an object at a time. This doesn't translate to testing a method as
    a method can change its behavior by taking different execution paths (if the method
    has forked control flow). Therefore, essentially, a unit test will probe one execution
    path of a method at a time. Iteratively, we can add more unit tests to probe other
    execution paths in the same or other methods. This bottom-up approach relies on
    verifying behaviors at smaller, isolated levels so the application as a whole
    will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a unit test, isolation is required. Essentially, we need to isolate
    the object''s behavior (that we want to test) while ignoring the object''s interaction
    with other objects/components within the system. To achieve this isolation, we
    have various mechanisms in unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocking**: Mocking is an operation to create a test double in which a testing
    framework will create a mock/dummy object based on the class definition of the
    object (compile time). To isolate the subject object''s interaction with other
    interacting objects, we can simply mock the interacting objects. When a unit test
    is executed for the subject object, it will skip interactions with other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spying**: Using spying we create a test double by probing the actual instance
    of the object (runtime). A spy object will just be the same as the real object
    barring any stubs. Stubs are used to define a dummy invocation so that the spy
    object will execute normally but when an invocation matches a stub definition,
    then it will execute the dummy behavior defined by the stub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though mocking and spying can help to isolate the behavior, sometimes the subject
    object may not be interacting with other objects so no test doubles are required.
    In the next section, we will begin with how to implement unit tests in the Micronaut
    framework using JUnit 5.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing using JUnit 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to learn how to implement unit tests in the Micronaut framework, we
    will resume the code base from [*Chapter 5*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106),
    *Integrating Microservices Using* *the* *Event-Driven Architecture*. We will continue
    with the pet-owner microservice and make sure you have the following dependencies
    added to the project `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By importing the preceding JUnit dependencies, we can leverage the JUnit and
    Micronaut test toolkit in the pet-owner microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a `TestUtil` class in `com.packtpub.micronaut.util` that
    can encapsulate some essential testing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In `TestUtil`, we have added the `equalsVerifier()` method, which can verify
    whether two objects are equal or not. This method takes a class type as an input
    parameter to assert different conditions on tested objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to unit test a domain object.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a domain object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A domain object is simply a `Owner` class in the pet-owner microservice. In
    the followed code snippet, we are creating an `OwnerTest` class to assert the
    equality of two owner instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `OnwerTest` class contains a test method, `equalsVerifier()`. An annotation,
    `org.junit.jupiter.api.Test`, is used to mark it as a test method. To verify the
    expected behavior, we are using assert statements. Similarly, we can define test
    classes for other domain objects in the pet-owner microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will unit test a mapper object.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a mapper object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our mapper objects in the pet-owner microservice are simple and we can create
    a basic test for an `OwnerMapper` class using the `@Test` annotation. In the following
    code snippet, `OwnerMapperTest` is unit-testing the `fromId()` method in `OwnerMapper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `OwnerMapperTest` class contains a test method, `testEntityFromId()`. To
    verify the expected behavior we are using `assert` statements. Similarly, we can
    define test classes for other mapper objects in the pet-owner microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Hitherto, we wrote simple unit tests for domain and mapper objects that didn't
    require any test doubles. In the next section, we will explore how we can use
    mocking to create the desired test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Using mocks in unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed before, mocking a testing framework will create a test double
    based on the class definition. These test doubles come in handy in unit testing
    an object where the object invokes methods on other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn about mocking in unit testing, we will work on the `VetService`
    class in the pet-clinic microservice. Let''s look at `VetServiceImpl` in the pet-clinic
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`VetService` instantiates `VetRepository`, `SpecialtyRepository`, `VetMapper`,
    and `SpecialtyMapper` in the constructor. These instantiated objects are then
    used in `VetService` methods. To unit test the `VetService` object, we would need
    to define mocks for some of these interacting objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `VetServiceTest` to encapsulate unit tests for `VetService`.
    In this test class, we will mock some interacting objects using the `@MockBean`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `VetServiceTest` class is annotated with the `@MicronautTest` annotation.
    It runs the test class as an actual Micronaut application with the full application
    context, thereby avoiding the artificial separation between production code and
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: To inject the interacting objects, we are using `@Inject` annotations. `@Inject`
    injects a bean from the application context into the class. Furthermore, using
    the `@MockBean` annotation, we are overriding the runtime beans for `VetRepository`
    and `SpecialtyRepository`. `@MockBean` will replace the actual objects with mocked
    objects in the application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily use these test double mocks in writing a unit test for the `VetService`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see how we are defining stubs for the
    mocked `VetRepository` and `SpecialtyRepository` classes. Usually, a mock stub
    takes the form of `when(object.methodCall()).thenReturn(result)`, except in the
    case of void method calls, where it is `doNothing().when(object).methodCall()`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, it's prudent to follow up mock stubs with `verify()` statements. `verify()`
    will confirm that, indeed, the desired method calls were made while executing
    the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore another way of creating test doubles using
    spies.
  prefs: []
  type: TYPE_NORMAL
- en: Using spies in unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed before, spying on a testing framework will create a test double
    based on the actual runtime object of the class. While mocking creates a full
    test double of the real object, with spying we can control whether the test double
    is partial or full. In a spied object, we can stub some method calls while keeping
    other method calls real. In such a scenario, the unit test will make dummy as
    well as real calls. Therefore, spying gives a bit more control over what we want
    to fake.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn about spying in unit testing, we will work on the `SpecialtyService`
    class in the pet-clinic microservice. Let''s look at `SpecialtyServiceImpl` in
    the pet-clinic microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`SpecialtyService` is instantiating `SpecialtyRepository` and `SpecialtyMapper`
    in the constructor. These instantiated objects are then used in `SpecialtyService`
    methods. To unit test the `SpecialtyService` object, we would need to define spies
    for some of these interacting objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `SpecialtyServiceTest` for encapsulating unit tests for `SpecialtyService`.
    In this test class, we will spy some interacting objects using the `@MockBean`
    annotation and `spy()` method in JUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `SpecialtyServiceTest` class is annotated with `@MicronautTest`, which runs
    the test class as an actual Micronaut application with the full application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `@MockBean` annotation, we are overriding the runtime bean for `SpecialtyRepository`.
    `@MockBean` will replace the actual object with the spied object in the application
    context. On the spied `SpecialtyRepository` object, we can easily define some
    stubs that will be executed in the test method instead of the actual invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see how we are defining stubs for the
    spied `SpecialtyRepository` instance. Usually, a spy stub takes the form of `doReturn(result).when(object).methodCall()`,
    except in the case of void method calls, where it is `doNothing().when(object).methodCall()`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it's prudent to follow up spied stubs with `verify()` statements. These
    will confirm whether the desired method calls were made while executing the unit
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Hitherto, we have learned the various ways to unit test using mocks and spies.
    In the next section, we will explore how we can perform service testing in the
    Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Service testing in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Service testing** is the next level to unit testing. By testing all the endpoints
    in a microservice and repeating this process for all the other microservices,
    we can make sure that all the services are working as expected edge to edge. It
    raises the quality check to the next level. Having said that, as we discussed
    before, as we move up in the test pyramid, test cases become more brittle, expensive,
    and sluggish, therefore, we need to establish a fine balance of not testing too
    much on the higher levels.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn how we can perform service testing in the Micronaut framework, we will
    continue with the pet-clinic microservice. In the following sections, we will
    go into testing all the REST endpoints of a service. We will use the `@Order`
    annotation to establish the order of execution of a test in the suite. An ordered
    test suite can help in starting from scratch and cleaning up at the end. In the
    following examples, we will create, get, update, and finally delete the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the test suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the `VetResource` endpoints, let''s create a `VetResourceIntegrationTest`
    class. This suite will encapsulate all the happy and unhappy integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things to ponder in the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transactional = false` ensures that the suite runs without the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Property` annotation overrides the application configuration. And in our
    case, we are disabling the security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestInstance.Lifecycle.PER_CLASS` boots up the instance and keeps the application
    context for the whole suite. You can instantiate a test object and application
    context at the test method level using `@TestInstance(TestInstance.Lifecycle.PER_METHOD)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@TestMethodOrder annotation` in JUnit is used to define the execution order
    of each test method in the test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Inject @Client**: This annotation injects a reactive HTTP client (built
    in Micronaut) to perform RESTful calls to the resource endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting up the test suite, we are good to perform service testing. In
    the next few sections, we will cover all the restful calls in the test methods.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the create endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`VetResource` has a POST endpoint for creating a new `Vet`. It accepts `VetDTO`
    in the request body. Let''s use the HTTP client to create a vet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we are creating a `VetDTO` object and invoking the POST
    endpoint using the HTTP client. To make the reactive client return the observable
    and make a pseudo-synchronous call, we are using `blockingFirst()`. It blocks
    the thread until the observable emits an item, then returns the first item emitted
    by the observable. Finally, we are asserting to confirm the expected versus the
    actual behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the `GET` endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the proceeding test, we created a new vet in the POST endpoint service test.
    We can leverage just the persisted vet to test the `GET` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding tests, we are testing two endpoints, `getVet()` and `getAllVets()`.
    To make the reactive client return the results, we are using the `blockingFirst()`
    operator. While `getAllVets()` will return a list of vets, `getVet()` will return
    the desired vet object only.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the update endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the `update` endpoint, we will leverage the vet resource persisted
    in the created endpoint service test, therefore, use an order after the `create`
    and `GET` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we tested the `updateVet()` endpoint. We first fetched
    the persisted vet and then updated the first and last name before invoking the
    update endpoint. Finally, we asserted to confirm the actual behavior meets the
    expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the delete endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test the `delete` endpoint, we will leverage the vet resource persisted
    in the earlier endpoint calls. Therefore, we will use an order after the `create`,
    `GET`, and `update` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we tested the `deleteVet()` endpoint. We are passing
    the previously persisted `vetId`. And after the successful service call, we are
    asserting to confirm the actual behavior meets the expected behavior by comparing
    the database size before and after the service call.
  prefs: []
  type: TYPE_NORMAL
- en: The test orders in the suite ensure that we always start from scratch and leave
    it clean after finishing all the tests in the suite. There are pros and cons to
    this pattern for service testing compared to setting up and cleaning up at the
    test method level. You can pick and choose a pattern after analyzing the application
    requirements and whether to use suite setup and cleanup or at the test method
    level.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the exciting world of `Testcontainers`
    for integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing using Testcontainers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Testcontainers` is a Java library that elegantly marries the world of testing
    with Docker virtualization. Using the `Testcontainers` library, we can set up,
    instantiate, and inject any Docker container into the testing code. This approach
    opens up many avenues for performing integration testing. In the test suite or
    test method setup, we can boot up a Dockerized database, Kafka or email server
    or any integrating app, perform the integration tests, and destroy the Dockerized
    app in the cleanup. With this pattern, we are up close to the production environment
    while not impacting the environment with any after-testing side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn how we can use the `Testcontainers` library, we will experiment on
    the pet-clinic-reviews microservice that integrates with MongoDB. In the next
    section, we will begin setting up `Testcontainers` in the Micronaut application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Testcontainers in the Micronaut application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use `Testcontainers` in the pet-clinic-reviews microservice, add the following
    dependencies in the project `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing a MongoDB flavored test container, we will be able to leverage
    the MongoDB Docker toolkit. After importing the required `Testcontainers` dependencies,
    let''s set up an abstract class that can provide any app containers required by
    the integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In `AbstractContainerBaseTest`, we configure and boot up a MongoDB instance
    in Docker statically. The static nature of this container will simplify access
    and avoid booting up too many instances at the test suite or test method level.
    `Testcontainers` elegantly, and with minimal code, pulls up a MongoDB Docker image,
    boots it up, and starts it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will write integration tests using `Testcontainers`
    for `VetReviewRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests using Testcontainers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, we covered how we can use `Testcontainers` to create
    a Dockerized MongoDB. We will proceed to test `VetReviewRepository` using the
    Docker MongoDB instance. Let''s begin with the test suite and test method setups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test suite setup, we are overriding the application properties for MongoDB.
    Furthermore, we are fetching the `VetReviewRepository` bean from the application
    context. This will make sure we are injecting the repository bean that is communicating
    with the Dockerized MongoDB. And, in the test method setup, we are ensuring that
    the MongoDB container is running before we execute the test method. Since we have
    set up at the test suite and test method level, let''s jump ahead in writing an
    integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `saveVetReview()` test, we are creating a new vet review and invoking
    on `VetReviewRepository` to persist this vet review. Finally, we are asserting
    that the vet review was persisted successfully by fetching and comparing the values.
    We are using the `@Order` pattern in the test suite so later tests can ensure
    the cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how `Testcontainers` can simplify integration tests
    by spinning off Docker instances of the database or other service components.
    We implemented integration tests for `VetReviewRepository` by creating a MongoDB
    test container.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter with the testing pyramid and striking a fine balance in
    test automation with unit testing, service testing, and integration testing. We
    jumpstarted with some basics of unit testing, such as leveraging mocks and spies
    to write unit tests. We then dived into how we can write service tests to test
    various RESTful endpoints using a reactive HTTP client in the Micronaut framework.
    Finally, we explored the exciting world of test containers for integration testing.
    We wrote integration tests using `Testcontainer` to instantiate MongoDB in the
    test environment.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides you with a firm understanding of testing at various levels,
    such as unit, service, or integration in the Micronaut framework. After subtle
    yet nimble theoretical discussions, we followed up with good hands-on examples
    to enhance your practical skillset in automated testing in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how we can handle microservice architecture
    concerns in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is mocking in unit testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we mock in the Micronaut framework using JUnit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is spying in unit testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we spy in the Micronaut framework using JUnit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we write service tests in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are test containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use test containers in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write integration tests in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
