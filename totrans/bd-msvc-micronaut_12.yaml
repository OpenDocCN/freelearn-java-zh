- en: '*Chapter 8*: Deploying Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The literal meaning of *deployment* is to bring resources into effective action.
    Therefore, in the microservices context, it means to bring microservices into
    effective action. Any service deployment is a multi-step process and often involves
    building the artifacts and then pushing the artifacts to a runtime environment.
    In the microservices world, an effective strategy for microservices deployment
    is crucial. Essentially, we need to watch out for the following when planning
    a deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: Continue with the pattern of *separation of concern* and self-isolate the artifact-building
    process for each microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decouple any connection requirements within microservices and let the service
    discovery or an implementation close to service discovery handle the microservice
    bindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a seamless deployment process that can handle instantiating all of
    the microservice application components in a unified and automated way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into these aforementioned concerns while covering
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the container artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the container artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be well versed in these aspects of microservices
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the commands and technical instructions in this chapter run on Windows
    10 and macOS. The code examples covered in this chapter are available in the book''s
    GitHub repo here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08
    )'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A development IDE**: Based on your preference, any Java-based IDE can be
    used, but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install this can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Instructions to download and install this can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred then instructions
    to download and install it can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for writing this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A REST client**: Any HTTP REST client can be used. We used the **Advanced
    REST Client** Chrome plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the container artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To deploy any application, the first step is to build all the required artifacts.
    And building an artifact typically involves checking out the source code and compiling
    and creating a deployable artifact. In regard to microservices, often, this deployable
    form is a Docker container image. Docker images have elegantly decoupled the runtime
    topology requirements. A Docker image is platform agnostic and can be deployed
    to any host machine that runs Docker. In the next section, we will dive into how
    to build Docker images for the microservices in our pet-clinic application.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the Micronaut microservices using Jib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jib is a containerizing framework from Google that can seamlessly tie with
    Java build frameworks such as Maven or Gradle to build container images. Jib has
    hugely simplified the process to create container (Docker) images. Let''s quickly
    see the workflow without Jib to create a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Docker containerization workflow without Jib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Docker containerization workflow without Jib
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, to build a Docker image without Jib
    we need to build the **Source code** and create a **Docker file**. The **Docker
    daemon** then uses the build context to create a **Container image** and push
    it to the repository/registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to the preceding workflow, Jib simplifies the whole process as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Docker containerization with Jib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Docker containerization with Jib
  prefs: []
  type: TYPE_NORMAL
- en: Jib takes the configuration from the build file such as project's `pom` file
    or a Gradle file to build the container image and uploads it to the configured
    repository/registry.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Jib for containerizing our microservices in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the pet-owner microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the pet-owner microservice, we will simplify configuration management to
    use local `application.properties`. We can still use `consul` for configuration
    management, but to focus on the containerization aspect, we opt to use a local
    `application.properties` file. Delete or back up the `bootstrap.yml` file and
    make the following changes to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to ponder in these application properties changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.docker.internal` instead of localhost to point to the Postgres instance
    installed on the host operating system (outside Docker).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consul` service. To use Dockerized `consul` from a pet-owner Docker container,
    we will need to specify the service name instead of localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: We are specifying a fixed port to run the pet-owner microservice
    as this will expose this port later in the deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, to use anything from the host machine we should use `host.docker.internal`,
    and to use any Docker service container we must specify the Docker service name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the previous application configuration changes, we can proceed
    to containerization. To containerize the pet-owner microservice we will use Jib.
    Make the following changes in the project''s `pom` file build settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `pom` changes, we are using `jib-maven-plugin` to build the
    container image. The `<configuration>` section specifies the Docker configurations
    such as the `<from>` image (which is pointing to use JDK 13). To name the created
    image, we use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and change directory to the `pet-owner` root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type and run the `mvn compile jib:dockerBuild` command in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the command to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These instructions will create a local Docker image that can be verified using
    the `docker images | grep pet-owner` command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Verifying the pet-owner image in the local Docker registry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Verifying the pet-owner image in the local Docker registry
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the output of `docker images`. A `pet-owner-0.1-image`
    image is stored in the local Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the pet-clinic microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the pet-clinic microservice container ready, make the following changes
    to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few things to ponder in application properties changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.docker.internal` instead of localhost to point to Postgres installed
    in the host operating system (outside Docker).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consul` service. To use Dockerized `consul` from the pet-clinic Docker container,
    we will need to specify the service name instead of localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kafka server**: In our Docker services, we will configure a **Kafka** service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: We are specifying a fixed port to run the pet-clinic microservice
    as we will expose this port later in the deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making the preceding application configuration changes, we can proceed
    to containerization. To containerize the pet-clinic microservice we will use Jib.
    Make the following changes in the project''s `pom` file build settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `pom` changes, we use `jib-maven-plugin` to build the container
    image. The `<configuration>` section specifies Docker configurations such as the
    `<from>` image (which is pointing to use JDK 13). To name the created image we
    use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and change directory to the `pet-clinic` root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type and run the `mvn compile jib:dockerBuild` command in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the command to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic` command in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the pet-clinic-reviews microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the pet-clinic-reviews microservice container ready, make the following
    changes to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few things to ponder in application properties changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`host.docker.internal` instead of localhost to point to the Mongo DB instance
    installed on the host operating system (outside Docker).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consul` service. To use Dockerized `consul` from the `pet-clinic-reviews`
    Docker container, we will need to specify the service name instead of localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kafka` service. To use Dockerized `consul` from the `pet-clinic-reviews` Docker
    container, we will need to specify the service name instead of localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: We are specifying a fixed port to run the pet-clinic-reviews microservice
    as we will expose this port later in the deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making the preceding application configuration changes, we can proceed
    to containerization. To containerize the `pet-clinic-reviews` microservice we
    will use Jib. Make the following changes in the project''s `pom` fie build settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `pom` changes, we are using `jib-maven-plugin` to build the
    container image. The `<configuration>` section specifies Docker configurations
    such as the `<from>` image (which is pointing to use JDK 13). To name the created
    image, we use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and change directory to the `pet-clinic-reviews` root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type and run the `mvn compile jib:dockerBuild` command in terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the command to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic-reviews` command in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the pet-clinic-concierge microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the pet-clinic-concierge microservice container ready, make the following
    changes to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few things to ponder in application properties changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`consul` service. To use Dockerized `consul` from the pet-clinic-concierge
    Docker container we will need to specify the service name instead of localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-concierge` microservice as we will expose this port later in the
    deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making the preceding application configuration changes we can proceed
    to containerization. To containerize the `pet-clinic-concierge` microservice (the
    API gateway) we will use `jib`. Make the following changes in the project''s `pom`
    file build settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `pom` changes, we use `jib-maven-plugin` to build the container
    image. The `<configuration>` section specifies Docker configurations such as the
    `<from>` image (which is pointing to use JDK 13). To name the created image we
    use `<to>` along with `<creationTime>` to correctly stamp the time coordinates
    on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the terminal and change directory to the `pet-clinic-concierge` root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type and run the `mvn compile jib:dockerBuild` command in terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the command to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding instructions will create a local Docker image that can be verified
    using the `docker images | grep pet-clinic-concierge` command in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have containerized all the microservices. We can verify these images
    in the Docker Dashboard as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Verifying the Docker images in the Docker UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Verifying the Docker images in the Docker UI
  prefs: []
  type: TYPE_NORMAL
- en: In the Docker UI, we can simply go to **Images** and under the **LOCAL** tab,
    we can filter all the pet-clinic application images. In the next section, we will
    use these Docker images in our pet-clinic application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the container artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored how we can use `Jib` to simplify microservice
    containerization. In this section, we will dive into how we can make the end-to-end
    deployment seamless and unified using Docker orchestration with `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: Using docker-compose to deploy the pet-clinic services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker-compose` is a tool available under the Docker ecosystem and is very
    intuitive in defining and deploying a multi-container application. With a simple
    YAML-flavored syntax, we can set up all the services and their dependencies and
    use a single command to deploy the whole application. We will create a `docker-compose`
    file for the pet-clinic application covering all the necessary services/components,
    including microservices, service discovery, and the Apache Kafka ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s define the ancillary services in `docker-compose` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous code, we see the `docker-compose` file. We begin by defining
    a service for the `consul` service discovery. We will expose `consul` on port
    `8500`. Furthermore, we will define services for the Apache Kafka ecosystem; that
    is, Zookeeper, Kafka, and the Kafdrop UI. Once these services are defined in the
    `docker-compose` file, we can proceed to the pet-clinic microservices. Refer to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While defining the configurations for the `pet-clinic` microservices, we can
    specify the dependencies using `depends_on`. This will ensure that Docker instantiates
    the services as per the dependency order. Also, for deploying each service, we
    will be using the `pet-clinic` microservices Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `docker-compose` file is defined for the `pet-clinic` application,
    refer to the following instructions to deploy the pet-clinic application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `bash` terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the directory to the location where the `docker-compose` file is stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type and run the `docker compose up` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for Docker to instantiate the containers as specified in the `docker-compose`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the successful run of the `docker-compose` command, we can verify the
    `pet-clinic` application in the Docker Dashboard, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16585_Fixed.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see the status of all the services in
    the pet-clinic application. You can click on a service and monitor the logs and
    access the web interface (if any). Furthermore, we can check the `consul` service
    discovery for the health of the pet-clinic microservices. Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Verifying the microservices health in service discovery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Verifying the microservices health in service discovery
  prefs: []
  type: TYPE_NORMAL
- en: In the `consul` service discovery, we can observe the health of each instance
    of a microservice. In the preceding screenshot, we can see all the `pet-clinic`
    microservices are running normally.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice container orchestration is the bedrock of any deployment strategy.
    For the scope of this chapter, we covered the local Docker deployment of the pet-clinic
    application, but the container images built can be deployed anywhere, be it locally
    or in a cloud environment, using a container orchestration tool such as `docker-compose`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we jumpstarted our understanding with a discussion about making
    Micronaut microservices container ready. Later, we dived into using Jib for creating
    the container images for each microservice. We saw how to define all the service
    container configurations using `docker-compose` and seamlessly deploy all the
    required service components using a single command.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter enhances the deployment aspects of your Micronaut microservices
    journey by equipping you with first-hand knowledge on containerization and automated
    deployment. This skill set is much sought after in microservices application development
    and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore various ways to monitor different aspects
    of the pet-clinic application in Micronaut.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Jib?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use Jib to create a Docker container in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we connect to localhost from a Docker container in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we deploy a multi-service application using `docker-compose` in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we perform Docker containerization of a Micronaut microservices application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
