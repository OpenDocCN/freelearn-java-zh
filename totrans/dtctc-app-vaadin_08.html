<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding Reporting Capabilities</h1>
                </header>
            
            <article>
                
<p>Many business applications require the generation of reports as part of their functionality. A<span> </span><em>report</em> is the representation of data in a certain format for a particular audience. A<span> <em>R</em></span><em>eport Generator</em><span> </span>(or<span> <em>R</em></span><em>eport Viewer</em>) is an application or an application module that allows end users to visualize and download reports. <span>Very often, a report generator takes data from a database and produces a document in a format suitable for printing on paper. We will focus on this type of report generator in this chapter. </span>There are many ready-to-use report generators with advanced features, such as business intelligence and analytics, but these systems are out of the scope of this book.</p>
<p>In this chapter, we'll learn how to render<span> </span><kbd>JasperReports</kbd><span> </span>in a Vaadin application without having to deal with report designers or XML design formats. Instead, we'll use a Java API to design the reports, similarly to how you use Java to design a web UI using Vaadin Framework. We'll also discuss background report generation and Server Push, a mechanism that allows us to update the client from a separate thread running on the server.</p>
<p><span>This chapter covers the following topics:</span></p>
<ul>
<li class="p1"><span class="s1">Integrating <kbd>JasperReports</kbd> with Vaadin</span></li>
<li class="p1"><span class="s1">Rendering runtime-generated HTML</span></li>
<li class="p1"><span class="s1">Long-running background tasks</span></li>
<li class="p1"><span class="s1">Server Push</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/9sdD5q">https://goo.gl/9sdD5q</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The example application</h1>
                </header>
            
            <article>
                
<p><span>Throughout the chapter, </span>we'll develop a <span class="packt_screen">Report Viewer</span>. The following is a screenshot of the finished application:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-214 image-border" src="assets/87b75f20-24db-4db6-8cc1-817384e4ad7d.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The data model</h1>
                </header>
            
            <article>
                
<p>The data model is based on a simple SQL table,<span> </span><kbd>Call</kbd>, that contains columns for the ID, client name, phone number, city, start time, duration, and status. The following is a JPA Entity representing this table:</p>
<pre><span>@Entity<br/></span><span>@Data<br/></span><span>public class </span><strong>Call</strong> {<br/><br/>    <span>@Id<br/></span><span>    @GeneratedValue<br/></span><span>    </span><span>private </span>Long <span>id</span>;<br/><br/>    <span>private </span>String <span>client</span>;<br/><br/>    <span>private </span>String <span>phoneNumber</span>;<br/><br/>    <span>@Enumerated</span>(EnumType.<span>STRING</span>)<br/>    <span>private </span>City <span>city</span>;<br/><br/>    <span>private </span>LocalDateTime <span>startTime</span>;<br/><br/>    <span>private </span>Integer <span>duration</span>;<br/><br/>    <span>@Enumerated</span>(EnumType.<span>STRING</span>)<br/>    <span>private </span>Status <span>status</span>;<br/>}</pre>
<p><kbd>Status</kbd> and<span> </span><kbd>City</kbd><span> </span>are simple Java <kbd>enums</kbd> that define some test values:</p>
<pre><span>public enum </span><strong>Status</strong> {<br/>    <span>RECEIVED</span><span>, </span><span>MISSED</span><span><br/></span>}<br/><br/><span>public enum </span><strong>City</strong> {<br/><span>    BOGOTA</span><span>, </span><span>TURKU</span><span>, </span><span>LONDON</span><span>, </span><span>BERLIN</span><span>, </span><span>HELSINKI</span><span>, </span><span>TOKYO</span><span>, </span><span>SAN_FRANCISCO</span><span>, </span><span>SIDNEY</span><span>, </span><span>LAGOS</span><span>, </span><span>VANCOUVER</span><span>, </span><span>SANTIAGO</span><span>, </span><span>BEIJING</span><span><br/></span>}</pre>
<p>Notice the<span> </span><kbd>@Enumerated</kbd><span> </span>annotations in the<span> </span><kbd>city</kbd><span> </span>and<span> </span><kbd>status</kbd><span> </span>fields of the<span> </span><kbd>Call</kbd><span> </span>class. This is used to persist the value as a string in the database instead of an integer representing the value, which allows us to use simpler SQL queries for the reports.</p>
<p>We'll use two persistence frameworks in this application. For parts of the application that require saving data or running business logic, we'll use JPA. For reports data, we'll use MyBatis. In your applications you can, of course, use only one framework. The reason behind choosing MyBatis for report generation is that it's a great fit for constructing and maintaining complex SQL queries. SQL, in turn, is a powerful language and a perfect fit for reporting. The ability to copy an SQL query from your code and run it directly on a SQL client eases implementation and maintenance as you can quickly see the data you'd get in a report without having to compile or execute the application. Each report<span> </span>has<span> </span>its own <strong>data transfer model</strong> (<strong>DTO</strong>), a class that encapsulates the data to be rendered in a report in a convenient format. The advantage of this is that we don't have to query extra data not used in the report and so free the web server from data processing to some extent.</p>
<p>The configuration of both frameworks is implemented in the<span> </span><kbd>JPAService</kbd><span> </span>and<span> </span><kbd>MyBatisService</kbd><span> </span>classes and the<span> </span><kbd>persistence.xml</kbd><span> </span>and<span> </span><kbd>mybatis-config.xml</kbd><span> </span>files. <span>A file-based H2 database is used by default, but you'll find configuration examples for MySQL and PostgreSQL as comments in the configuration files.</span></p>
<div class="packt_infobox">You can find the complete source code of this chapter's example in the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8\chapter-08</kbd><span> </span>Maven project of the source code that accompanies this book.</div>
<p>Since a report viewer doesn't make sense without data, the example application includes a random data generator that populates the<span> </span><kbd>Call</kbd><span> </span>table with random data. When the table is empty, the generator will fill it with initial data representing phone calls made in the past 6 months at a rate of one million calls per year. If the table is not empty, the generator will "fill" the time span between the time of the last call in the table and the current time using the same rate. Additionally, the generator runs a background thread that inserts random data at runtime. This generator is meant to simulate a real-life situation in which data is constantly inserted into the database, sometimes even when the application is not running. You can find the implementation in the<span> </span><kbd>DataGenerator</kbd><span> </span>class. The<span> </span><kbd>DataGenerator</kbd><span> </span>functionality is invoked from a<span> </span><kbd>ServletContextListener</kbd><span> that is </span>defined in the<span> </span><kbd>WebConfig</kbd><span> </span>class. The initial time span and the rate used in the generator is configurable via parameters, in case you want to use different values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Vaadin UI</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>VaadinServlet</kbd> is configured in the<span> </span><kbd>WebConfig</kbd> class. The<span> </span><kbd>UI</kbd><span> </span>implementation is realized in the<span> </span><kbd>VaadinUI</kbd><span> </span>class. For reference, the following snippet of code shows the implementation of the layout of the example application:</p>
<pre><span>@Title</span>(<span>"Report Viewer"</span>)<br/><span>public class </span>VaadinUI <span>extends </span>UI {<br/><br/>    <span>private </span>HorizontalLayout <strong>header </strong>= <span>new </span>HorizontalLayout()<span>;<br/></span><span>    private </span>Panel <strong>panel </strong>= <span>new </span>Panel()<span>;<br/></span><span>    private </span>MenuBar.MenuItem <span>annualLegalReportItem</span><span>;<br/></span><span><br/></span><span>    </span><span>@Override<br/></span><span>    </span><span>protected void </span><span>init</span>(VaadinRequest vaadinRequest) {<br/>        MenuBar menuBar = <span>new </span>MenuBar()<span>;<br/></span><span>        </span>menuBar.addStyleName(ValoTheme.<span>MENUBAR_BORDERLESS</span>)<span>;<br/></span><span>        </span>MenuBar.MenuItem reportsMenuItem = menuBar.addItem(<span>"Reports"</span><span>, </span>VaadinIcons.<span>FILE_TABLE</span><span>, null</span>)<span>;<br/></span><span>        </span>reportsMenuItem.addItem(<span>"Worldwide Calls in the Last Hour"</span><span>, </span>VaadinIcons.<span>PHONE_LANDLINE</span><span>,<br/></span><span>                </span>i -&gt; <strong>showLastHourCallReport()</strong>)<span>;<br/></span><span>        </span>reportsMenuItem.addItem(<span>"Monthly Capacity Report"</span><span>, </span>VaadinIcons.<span>BAR_CHART_H</span><span>,<br/></span><span>                </span>i -&gt; <strong>showMonthlyCapacityReport()</strong>)<span>;<br/></span><span>        </span><span>annualLegalReportItem </span>= reportsMenuItem.addItem(<span>"Annual Legal Report"</span><span>, </span>VaadinIcons.<span>FILE_TEXT_O</span><span>,<br/></span><span>                </span>i -&gt; <strong>generateAnnualLegalReport()</strong>)<span>;<br/></span><span><br/></span><span>        </span><span>header</span>.addComponents(menuBar)<span>;<br/></span><span><br/></span><span>        </span><span>panel</span>.addStyleName(ValoTheme.<span>PANEL_WELL</span>)<span>;<br/></span><span><br/></span><span>        </span>VerticalLayout mainLayout = <span>new </span>VerticalLayout(<span>header</span>)<span>;<br/></span><span>        </span>mainLayout.addComponentsAndExpand(<span>panel</span>)<span>;<br/></span><span>        </span>setContent(mainLayout)<span>;<br/></span><span>    </span>}<br/>    ...<br/>}</pre>
<p>We are going to develop three different reports. The <kbd>showLastHourCallReport</kbd>,<span> </span><kbd>showMonthlyCapacityReport</kbd>, and<span> </span><kbd>generateAnnualLegalReport</kbd> methods include the logic to modify the UI in order to show the respective report inside the<span> </span><kbd>panel</kbd><span> </span>component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating JasperReports with Vaadin</h1>
                </header>
            
            <article>
                
<p><kbd>JasperReports</kbd> is an open-source reporting engine to produce reports that can be rendered in a variety of formats, such as HTML, PDF, Microsoft Excel, ODT (OpenOffice), and others. Typically, reports are designed in a visual editor (iReport Designer) or XML files (JRXML). The design is compiled into a Jasper file (<kbd>*.jasper</kbd>), filled with data, and exported to the desired format.</p>
<p><kbd>DynamicJasper</kbd> and <kbd>DynamicReports</kbd> are two open-source libraries that abstract away the JRXML format and provide APIs to design reports in Java. This is a good match for the philosophy of the Vaadin Framework which allows you to implement HTML-based web applications in Java. In this chapter, we'll use <kbd>DynamicJasper</kbd>, but the concepts are similar if you prefer <kbd>DynamicReports</kbd>. Some of the concepts can be also used if you plan to design reports in JRXML files directly or through the iReport Designer tool.</p>
<p>You can include <kbd>DynamicJasper</kbd> by adding the following dependency to your<span> </span><kbd>pom.xml</kbd><span> </span>file:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>ar.com.fdvs<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>DynamicJasper<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>5.1.0<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p>In order to export to Microsoft Office formats, you need to add Apache POI as a dependency:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span><strong>org.apache.poi</strong><span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span><strong>poi-ooxml</strong><span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>3.10-FINAL<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the data</h1>
                </header>
            
            <article>
                
<p>A crucial part of report generation is data gathering. Data is arguably the most important input in a report. Having good "infrastructure code" for data gathering will highly improve maintainability in report modules. In this chapter, we'll use an SQL database, since it's probably the most common kind of data store in use. This means reports are filled with data queried using SQL. Reporting doesn't require saving data, only reading. <span>SQL queries in reports tend to have multiple lines and are sometimes generated dynamically. </span>MyBatis seems to be an excellent choice for reporting modules. MyBatis allows query definition in XML files, which, unlike Java Strings, help with long multi-line SQL queries and dynamic query definitions.</p>
<p>To use XML-based mappers with MyBatis, specify the name of the XML file using the<span> </span><kbd>resource</kbd><span> </span>attribute of the<span> </span><kbd>mapper</kbd><span> </span>element in the MyBatis configuration file:</p>
<pre><span>&lt;configuration&gt;<br/></span><span>    ...</span><span><br/></span><span>    &lt;mappers&gt;<br/></span><span>        &lt;mapper </span><strong>resource="mappers/ReportsMapper.xml"</strong><span>/&gt;<br/></span><span>    &lt;/mappers&gt;<br/></span><span>&lt;/configuration&gt;<br/></span></pre>
<p>The<span> </span><kbd>ReportsMapper.xml</kbd><span> </span>file is defined as follows:</p>
<pre><span>&lt;?</span><span>xml version</span><span>="1.0" </span><span>encoding</span><span>="UTF-8" </span><span>?&gt;<br/></span><span>&lt;!DOCTYPE </span><span>mapper </span><span>PUBLIC </span><span>"-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span>&gt;<br/></span><span><br/></span><span>&lt;mapper </span><span>namespace</span><span>="<strong>packt.vaadin.datacentric.chapter08.reports.ReportsMapper</strong>"</span><span>&gt;<br/></span><span>    ...<br/></span><span>&lt;/mapper&gt;<br/></span></pre>
<p>This file defines the mapper Java interface to use. All queries defined inside the<span> </span><kbd>mapper</kbd><span> </span>element are mapped to the corresponding methods in the<span> </span><kbd>ReportsMapper</kbd><span> </span>class. For example, we can define a method to get all the calls before a given time as follows:</p>
<pre><span>public interface </span>ReportsMapper {<br/><br/>    List&lt;<strong>CallDto</strong>&gt; <strong>findCallsBefore</strong>(LocalDateTime time)<span>;</span><span><br/></span>}</pre>
<p>Notice that we are not using the JPA Entity as a result type. Instead, we are using a DTO with, and only with, the required Java fields to store the data from the SQL query:</p>
<pre><span>@Data<br/></span><span>public class </span><strong>CallDto</strong> {<br/>    <span>private </span>String <span>client</span><span>;</span><span><br/></span><span>    private </span>String <span>phoneNumber</span><span>;</span><span><br/></span><span>    private </span>City <span>city</span><span>;</span><span><br/></span><span>    private </span>LocalDateTime <span>startTime</span><span>;</span><span><br/></span><span>    private </span>Integer <span>duration</span><span>;</span><span><br/></span><span>    private </span>Status <span>status</span><span>;</span><span><br/></span>}</pre>
<p>We can map an SQL query to the<span> </span><kbd>findCallsBefore</kbd><span> </span>method as follows:</p>
<pre><span>&lt;mapper </span><span>namespace</span><span>="packt.vaadin.datacentric.chapter08.reports.ReportsMapper"</span><span>&gt;<br/></span><span><br/></span><span>    &lt;select </span><span>id</span><span>="<strong>findCallsBefore</strong>" </span><span>resultType</span><span>="<strong>packt.vaadin.datacentric.chapter08.reports.CallDto</strong>"</span><span>&gt;<br/></span><span>        </span>SELECT<br/>          city,<br/>          client,<br/>          phoneNumber,<br/>          startTime,<br/>          duration,<br/>          status<br/>        FROM Call<br/>        WHERE startTime &gt;= #{time}<br/>        ORDER BY startTime DESC<br/>    <span>&lt;/select&gt;<br/></span><span><br/></span><span>&lt;/mapper&gt;<br/></span></pre>
<p>The UI doesn't consume the mapper interface directly. Instead, we can define more high-level methods in a service class. For example, the <em>Worldwide Calls in the Last Hour</em><span> </span>report, the data from which the previous query comes, uses the<span> </span><kbd>lastHourCalls</kbd><span> </span>method in the<span> </span><kbd>ReportsService</kbd><span> </span>class:</p>
<pre><span>public class </span><strong>ReportsService</strong> {<br/><br/>    <span>public static </span>List&lt;CallDto&gt; <strong>lastHourCalls</strong>() {<br/>        <span>try </span>(SqlSession session = MyBatisService.<span>getSqlSessionFactory</span>().openSession()) {<br/>            LocalDateTime startOfHour = LocalDateTime.<span>now</span>().minusHours(<span>1</span>)<span>;<br/></span><span>            </span>ReportsMapper mapper = session.getMapper(ReportsMapper.<span>class</span>)<span>;<br/></span><span>            return </span>mapper.<strong>findCallsBefore</strong>(startOfHour)<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre>
<p>This allows for reusing queries when the data is the same but different processing (such as formatting, or computation of input parameters) <span>is required</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the report</h1>
                </header>
            
            <article>
                
<p>Let's start with the implementation of a simple report, the <em>Worldwide Calls in the Last Hour</em><span> report, shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-215 image-border" src="assets/4767d103-c821-450a-af22-404e3574a55c.png" style=""/></div>
<p>To create a report using <kbd>DynamicJasper</kbd>, you have to create an object of type<span> </span><kbd>DynamicReport</kbd>. This is done by using the<span> </span><kbd>DynamicReportBuilder</kbd><span> </span>class, which provides methods to add the title, header, columns, and other elements that form the report. The<span> </span><kbd>DynamicReportBuilder</kbd><span> </span>class implements the<span> </span><em>builder pattern</em><span> </span>to allow creating the report step by step and a method to build the<span> </span><kbd>DynamicReport</kbd><span> </span>instance. There are several subclasses of<span> </span><kbd>DynamicReportBuilder</kbd>; we'll follow the examples given in the official documentation and use the<span> </span><kbd>FastReportBuilder</kbd><span> </span>class.</p>
<p>We can start by configuring the title and header information, enabling full page width, setting the text to show when there's no data, and enabling a background color for odd rows:</p>
<pre>DynamicReport report = <strong>new FastReportBuilder()</strong><br/>        .setTitle(<span>"Worldwide Calls in the Last Hour"</span>)<br/>        .addAutoText(<span>"CONFIDENTIAL"</span><span>, </span>AutoText.<span>POSITION_HEADER</span><span>, </span>AutoText.<span>ALIGMENT_LEFT</span><span>, </span><span>200</span><span>, new </span>Style())<br/>        .addAutoText(LocalDateTime.<span>now</span>().toString()<span>, </span>AutoText.<span>POSITION_HEADER</span><span>, </span>AutoText.<span>ALIGNMENT_RIGHT</span><span>, </span><span>200</span><span>, new </span>Style())<br/>        .setUseFullPageWidth(true)<br/>        .setWhenNoData("(no calls)", new Style())<br/>        .setPrintBackgroundOnOddRows(true)<br/>        .<strong>build()</strong>;</pre>
<p>Notice how, after configuring the report, we end the sentence by calling the<span> </span><kbd>build</kbd><span> </span>method, which returns an instance of<span> </span><kbd>DynamicReport</kbd>. All configuration calls happen between the instantiation (<kbd>new FastReportBuilder()</kbd>) and the call to<span> </span><kbd>build()</kbd>.</p>
<p>The report data is defined by columns. Columns are configured with the<span> </span><kbd>addColumn</kbd><span> </span>method. The<span> </span><kbd>addColumn</kbd><span> </span>method accepts an instance of type<span> </span><kbd>AbstractColumn</kbd><span> </span>that we can create by using <kbd>ColumnBuilder</kbd>, also <span>a builder class. The following snippet of code demonstrates how to create the seven columns that make up the report:</span></p>
<pre>DynamicReport report = <span>new </span>FastReportBuilder()<br/>        ...<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"city"</span><span>, </span>City.<span>class</span>)<br/>                .setTitle(<span>"City"</span>)<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"client"</span><span>, </span>String.<span>class</span>)<br/>                .setTitle(<span>"Client"</span>)<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"phoneNumber"</span><span>, </span>String.<span>class</span>)<br/>                .setTitle(<span>"Phone number"</span>)<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"startTime"</span><span>, </span>LocalDateTime.<span>class</span>)<br/>                .setTitle(<span>"Date"</span>)<br/>                .setTextFormatter(DateTimeFormatter.<span>ISO_DATE</span>.toFormat())<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"startTime"</span><span>, </span>LocalDateTime.<span>class</span>)<br/>                .setTextFormatter(DateTimeFormatter.<span>ISO_LOCAL_TIME</span>.toFormat())<br/>                .setTitle(<span>"Start time"</span>)<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"duration"</span><span>, </span>Integer.<span>class</span>)<br/>                .setTitle(<span>"Minutes"</span>)<br/>                .build())<br/>        .addColumn(ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"status"</span><span>, </span>Status.<span>class</span>)<br/>                .setTitle(<span>"Status"</span>).build())<br/>        .build()<span>;<br/></span></pre>
<p>For each column, we have to specify the name of the corresponding Java property in the<span> </span><kbd>CallDto</kbd><span> </span>class and its type. We can also specify the title and<span> </span><em>text<span> </span>formatters</em> when needed.</p>
<p>The<span> </span><kbd>DynamicReport</kbd><span> </span>instance defines the visual structure of the report. With this in place, we can create a<span> </span><kbd>JasperPrint</kbd> object, which represents a page-oriented document that can be later exported to multiple formats. We first need to get the data from the service class, and then pass the<span> </span><kbd>DynamicReport</kbd><span> </span>instance and the data to the<span> </span><kbd>generateJasperPrint</kbd><span> </span>method of the<span> </span><kbd>DynamicJasperHelper</kbd><span> </span>class:</p>
<pre>List&lt;<strong>CallDto</strong>&gt; <strong>calls</strong> = <strong>ReportsService.lastHourCalls()</strong><span>;<br/></span><strong>JasperPrint print</strong> = DynamicJasperHelper.<strong>generateJasperPrint</strong>(<strong>report</strong><span>, new </span>ClassicLayoutManager()<span>, </span><strong>calls</strong>)<span>;<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering a report as HTML</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>JasperPrint</kbd><span> </span>instance can be exported to several formats. Since we are interested in rendering the report in a Vaadin web application, we can export the report to HTML and use a<span> </span><kbd>Label</kbd><span> </span>configured with<span> </span><kbd>ContentMode.HTML</kbd> as follows:</p>
<pre>ByteArrayOutputStream <strong>outputStream</strong> = new ByteArrayOutputStream()<br/>HtmlExporter exporter = <span>new </span><strong>HtmlExporter</strong>()<span>;<br/></span>exporter.setExporterOutput(<span>new </span>SimpleHtmlExporterOutput(<strong>outputStream</strong>))<span>;<br/></span>exporter.setExporterInput(<span>new </span>SimpleExporterInput(<strong>print</strong>))<span>;<br/></span>exporter.exportReport()<span>;<br/></span><span><br/></span>outputStream.flush()<span>;<br/></span>Label htmlLabel = <span>new </span>Label(<span>""</span><span>, </span><strong>ContentMode.HTML</strong>)<span>;<br/></span>htmlLabel.<strong>setValue(outputStream.toString("UTF-8"))</strong><span>;<br/></span></pre>
<p>The<span> </span><kbd>HtmlExporter</kbd><span> </span>class sends its output to an<span> </span><kbd>OutputStream</kbd>, which we can convert to<span> </span><kbd>String</kbd><span> </span>and set as a<span> </span><kbd>Label</kbd> value. This<span> </span><kbd>Label</kbd><span> </span>can be added to any Vaadin layout, as shown in this snippet of code, which also takes into account exception handling and resources:</p>
<pre><span>public class </span><strong>LastHourCallReport extends Composite</strong> {<br/><br/>    <span>public </span><span>LastHourCallReport</span>() {<br/>        <span>try </span>(ByteArrayOutputStream outputStream = <span>new </span>ByteArrayOutputStream()) {<br/>            DynamicReport report = <span>new </span>FastReportBuilder()<br/>                    ...<br/>                    .build()<span>;<br/></span><span>            ...<br/><br/></span><span>            Label htmlLabel = new Label("", ContentMode.HTML);<br/></span>            htmlLabel.setValue(outputStream.toString(<span>"UTF-8"</span>))<span>;<br/></span><span>            </span><strong>setCompositionRoot(htmlLabel)</strong><span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(JRException | IOException e) {<br/>            <span>throw new </span>RuntimeException(e)<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding charts</h1>
                </header>
            
            <article>
                
<p>Adding charts with <kbd>DynamicJasper</kbd> is done through the<span> </span><kbd>addChart</kbd><span> </span>method of the<span> </span><kbd>FastReportBuilder</kbd><span> </span>class. The following snippet of code shows the full configuration of the <em>Monthly Capacity Report</em>:</p>
<pre>DynamicReportBuilder reportBuilder = <span>new </span>FastReportBuilder()<br/>        .setUseFullPageWidth(<span>true</span>)<br/>        .setTitle(<span>"Monthly Capacity Report"</span>)<br/>        .setWhenNoData(<span>"(no data)"</span><span>, new </span>Style())<br/>        .addAutoText(<span>"CONFIDENTIAL"</span><span>, </span>AutoText.<span>POSITION_HEADER</span><span>, </span>AutoText.<span>ALIGMENT_LEFT</span><span>, </span><span>200</span><span>, new </span>Style())<br/>        .addAutoText(LocalDateTime.<span>now</span>().toString()<span>, </span>AutoText.<span>POSITION_HEADER</span><span>, </span>AutoText.<span>ALIGNMENT_RIGHT</span><span>, </span><span>200</span><span>, new </span>Style())<br/>        .addColumn(monthColumn = ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"monthName"</span><span>, </span>String.<span>class</span>)<br/>                .setTitle(<span>"Month"</span>)<br/>                .build())<br/>        .addColumn(callsColumn = ColumnBuilder.<span>getNew</span>()<br/>                .setColumnProperty(<span>"calls"</span><span>, </span>Integer.<span>class</span>)<br/>                .setTitle(<span>"Calls"</span>)<br/>                .build())<br/>        .<strong>addChart</strong>(<span>new </span><strong>DJBar3DChartBuilder</strong>()<br/>                .<strong>setCategory</strong>((PropertyColumn) <strong>monthColumn</strong>)<br/>                .<strong>addSerie</strong>(<strong>callsColumn</strong>)<br/>                .build())<span>;<br/></span></pre>
<p>Notice how we need a reference to the columns containing the data we want to use in the chart. The<span> </span><kbd>setCategory</kbd><span> </span>and<span> </span><kbd>addSeries</kbd><span> </span>methods accept these references.</p>
<p><span>In order to render charts, we must configure an <kbd>ImageServlet</kbd>, which is provided by the <kbd>JasperReports</kbd> library. This servlet serves the images that make up the charts. In the example application for this chapter, the servlet is declared in the <kbd>WebConfig</kbd> class as a static inner class:</span></p>
<pre><span>@WebServlet</span>(<span>"<strong>/image</strong>"</span>)<br/><span>public static class </span>ReportsImageServlet <span>extends </span><strong>ImageServlet</strong> {<br/>}</pre>
<p>You can use any suitable URL. This needs to be configured in the output used by the exporter class (for example,<span> </span><kbd>HTMLExporter</kbd>). Additionally, the<span> </span><kbd>JasperPrint</kbd><span> </span>instance has to be set in the HTTP session. The following snippet of code shows the extra configuration needed when rendering charts:</p>
<pre><span>...<br/></span>JasperPrint print = ...<span><br/></span><strong>VaadinSession.getCurrent().getSession().setAttribute(ImageServlet.DEFAULT_JASPER_PRINT_SESSION_ATTRIBUTE, print)</strong><span><strong>;</strong><br/></span><span><br/></span>SimpleHtmlExporterOutput exporterOutput = ...<span><br/></span><strong>exporterOutput.setImageHandler(new WebHtmlResourceHandler("image?image={0}"))</strong><span><strong>;</strong><br/></span><span><br/></span>HtmlExporter exporter = <span>new </span>HtmlExporter()<span>;<br/></span><strong>exporter.setExporterOutput(exporterOutput);<br/></strong><span>...</span></pre>
<p>The<span> </span><kbd>WebHtmlResourceHandler</kbd><span> </span>constructor accepts a string with the URL pattern to use by the internal image handler in the exporter. Notice how the pattern starts with <kbd>image</kbd>. This is the same value used in the <kbd>ImageServlet</kbd> mapping.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a report in a background task</h1>
                </header>
            
            <article>
                
<p>Report generation may involve expensive computation due to large amounts of data, connections to external systems, and data processing. In many situations, report data is gathered directly from the original source, typically an SQL database. This has two clear drawbacks. The first problem is that as the application runs, more and more data is added into the database, making reports run slower with time. The second problem is that report generation <span>may heavily use the database at certain times, </span>interfering with the usage of other parts of the application.</p>
<p>One step toward improving this situation is to progressively and continuously generate the data required for reporting. For example, consider the following query that calculates the average on a column:</p>
<pre>SELECT AVG(column_name) FROM table_name</pre>
<p>Instead of using this query, you can use the following formula to continuously calculate the average (<em>an</em>) from the previous average value (<em>a<sub>n-1</sub></em>) every time a new value (<em>x<sub>n</sub></em>) is persisted:</p>
<div class="CenterAlign"><img class="fm-editor-equation" src="assets/60ffbf40-b3f8-49ab-9fda-9919bf948027.png" style="width:11.33em;height:2.58em;"/></div>
<p>This, of course, doesn't take into account<span> </span><em>delete</em><span> </span>operations, and requires calculating the average any time a new value is persisted in the database, but the key idea of this simple example is to try to <em>help</em><span> </span>the application to pre-generate data for reporting, as data is added, modified, or deleted in order to minimize the amount of computational power required at report generation time.</p>
<p>When pre-processing data, or when there are computations that depend on time or external data sources, report generation may take longer than a normal request to the application. In these cases, you can use background threads to generate the report and notify the user when the report is ready. In the example application, you can see an <span class="packt_screen">Annual legal</span> <span class="packt_screen"><span class="packt_screen">repor</span><span class="packt_screen">t</span></span><span> </span>option in the<span> </span><span class="packt_screen">Reports</span><span> </span>menu. Generating this report is expensive in terms of application time, so instead of locking the application's usage until the report is ready, the application shows a notification saying that the report is being generated and starts the process in a background thread, letting users visualize other reports in the meantime:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-216 image-border" src="assets/90ca15da-48ba-4d88-8ec1-c13cec185d20.png" style=""/></div>
<p>When the report is ready, the application notifies you again and shows a button that allows you to download the report:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-217 image-border" src="assets/c8567025-ebb9-4d95-9c83-5de508691eb4.png" style=""/></div>
<p>The next sections explain how to implement this behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting a report to a PDF</h1>
                </header>
            
            <article>
                
<p>HTML is the best option to render a report in a browser. However, <kbd>JasperReports</kbd> and <kbd>DynamicJasper</kbd> support many other formats. These formats are available as implementations of the <kbd>JRExporter</kbd><span> </span>interface. One of them is the <kbd>JRPdfExporter</kbd><span> </span>class. The example application includes the<span> </span><kbd>LastHourCallReport</kbd><span> </span>class, which, in contrast to previous report implementations, is not a Vaadin UI component. Since we want to allow users to download this report, we don't really need a UI component for it. Instead,<span> </span><kbd>LastHourCallReport</kbd> is a helper class that configures the report, exports it as a PDF, and exposes the content of the file through an<span> </span><kbd>OutputStream</kbd> suitable for the<span> </span><kbd>FileDownloader</kbd><span> </span>class, part of Vaadin Framework.</p>
<p>Omitting the details about the report configuration, which we already covered in previous sections, the following is the implementation of the<span> </span><kbd>LastHourCallReport</kbd><span> </span>class:</p>
<pre><span>public class </span>AnnualLegalReport {<br/><br/>    <span>public static </span><strong>ByteArrayOutputStream getOutputStream()</strong> {<br/>        <span>try </span>(ByteArrayOutputStream outputStream = <span>new </span>ByteArrayOutputStream()) {<br/>            DynamicReport report = <span>new </span>FastReportBuilder()<br/>                    ... configure report ...<br/>                    .build()<span>;<br/></span><span><br/></span><span>            </span>List&lt;ClientCountDto&gt; clients = ReportsService.<span>countYearCallsByClient</span>()<span>;<br/></span><span>            </span>JasperPrint print = DynamicJasperHelper.<span>generateJasperPrint</span>(report<span>, new </span>ClassicLayoutManager()<span>, </span>clients)<span>;<br/></span><span><br/></span><span>            </span><strong>JRPdfExporter exporter</strong> = <span>new </span>JRPdfExporter()<span>;<br/></span><span>            </span>exporter.setExporterOutput(<span>new </span>SimpleOutputStreamExporterOutput(outputStream))<span>;<br/></span><span>            </span>exporter.setExporterInput(<span>new </span>SimpleExporterInput(print))<span>;<br/></span><span>            </span>exporter.exportReport()<span>;<br/></span><span><br/></span><span>            </span>outputStream.flush()<span>;<br/></span><strong>            return outputStream</strong><span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(JRException | IOException e) {<br/>            <span>throw new </span>RuntimeException(e)<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre>
<p>We need to call the<span> </span><kbd>getOutputStream</kbd><span> </span>method from a new thread and modify the UI, also from this new thread, to add a button that downloads the PDF file. In order to modify the UI from a separate thread, we need to enable and use<span> </span>Server Push.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server Push</h1>
                </header>
            
            <article>
                
<p>Let's examine what happens if we modify the UI from a separate thread without using Server Push:</p>
<pre><span>@Title</span>(<span>"Report Viewer"</span>)<br/><span>public class </span>VaadinUI <span>extends </span>UI {<br/><br/>    private HorizontalLayout <strong>header</strong> = new HorizontalLayout();<br/>    private MenuBar.MenuItem <strong>annualLegalReportItem</strong>;<br/>    ...<br/><br/>    <span>private void </span><span>generateAnnualLegalReport</span>() {<br/>        Notification.<span>show</span>(<span>"Report generation started"</span><span>,<br/></span><span>                </span><span>"You'll be notified once the report is ready."</span><span>, </span>Notification.Type.<span>TRAY_NOTIFICATION</span>)<span>;<br/></span><span>        </span><span>annualLegalReportItem</span>.setEnabled(<span>false</span>)<span>;<br/></span><span><br/></span><strong>        new Thread(() -&gt; {</strong><br/>            ByteArrayOutputStream outputStream = <strong>AnnualLegalReport.getOutputStream()</strong><span>;<br/></span><span>            </span>ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray())<span>;<br/></span>            Button button = <span>new </span>Button(<span>"Download Annual Legal Report"</span><span>, </span>VaadinIcons.<span>DOWNLOAD_ALT</span>)<span>;<br/></span><span>            </span><strong>header.addComponent(button)</strong><span><strong>;</strong><br/></span><span><br/></span><span>            </span>FileDownloader downloader = <span>new </span>FileDownloader(<span>new </span>StreamResource(() -&gt; {<br/>                <strong>header.removeComponent(button)</strong><span><strong>;</strong><br/></span><span>                </span><strong>annualLegalReportItem.setEnabled(true)</strong><span>;<br/></span><span>                return </span><span>inputStream</span><span>;<br/></span><span>            </span>}<span>, </span><span>"annual-legal-report.pdf"</span>))<span>;<br/></span><span>            </span>downloader.extend(button)<span>;<br/></span><span><br/></span><span>            </span><strong>Notification.show("Report ready for download", Notification.Type.TRAY_NOTIFICATION)</strong><span><strong>;</strong><br/></span><span>        </span><strong>}).start()</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p><span>When the user clicks the corresponding option in the menu, </span>the<span> </span><kbd>generateAnnualLegalReport</kbd><span> </span>method is called. The method starts a new thread, so we end up with two threads; the one that started when the HTTP request happened (the menu option is clicked) and the one started by the <kbd>generateAnnualLegalReport</kbd><span> method. When the HTTP request finishes, the user is able to continue using the application in the browser. At some point later, the <kbd>AnnualLegalReport.getOutputStream()</kbd> method finishes and the application tries to modify the UI. However, this is happening in a separate background thread in the server. All changes to the UI are lost or may fail, since the thread is not associated with the UI instance, and <kbd>NullPointerExceptions</kbd> may be thrown by the framework (this is the case with the <kbd>Notification.show</kbd> method).</span></p>
<p><span>You can get a lock on the session in order to guarantee a UI instance is available and avoid </span><kbd>NullPointerExceptions</kbd> <span>by wrapping any code that modifies the UI from outside a request-handling thread with the <kbd>UI.access(Runnable)</kbd> method:</span></p>
<pre><strong>new Thread(() -&gt; {</strong><br/>    ByteArrayOutputStream outputStream = AnnualLegalReport.<span>getOutputStream</span>()<span>;<br/></span><span>    </span>ByteArrayInputStream inputStream = <span>new </span>ByteArrayInputStream(outputStream.toByteArray())<span>;<br/></span><strong>    access(() -&gt; {</strong><br/>        Button button = <span>new </span>Button(<span>"Download Annual Legal Report"</span><span>, </span>VaadinIcons.<span>DOWNLOAD_ALT</span>)<span>;<br/></span><span>        </span><span>header</span>.addComponent(button)<span>;<br/></span><span><br/></span><span>        </span>FileDownloader downloader = <span>new </span>FileDownloader(<span>new </span>StreamResource(() -&gt; {<br/>            <span>header</span>.removeComponent(<span>button</span>)<span>;<br/></span><span>            </span><span>annualLegalReportItem</span>.setEnabled(<span>true</span>)<span>;<br/></span><span>            return </span><span>inputStream</span><span>;<br/></span><span>        </span>}<span>, </span><span>"annual-legal-report.pdf"</span>))<span>;<br/></span><span>        </span>downloader.extend(button)<span>;<br/></span><span><br/></span><span>        </span>Notification.<span>show</span>(<span>"Report ready for download"</span><span>, </span>Notification.Type.<span>TRAY_NOTIFICATION</span>)<span>;<br/></span><strong>    });<br/>}).start();<br/></strong></pre>
<p>There's still one problem; the server needs to send the changes to the browser, something we can achieve by enabling<span> </span><strong>Server Push</strong>. <span>Server Push is a technique that starts a communication process from the server to the client, in opposition to a typical HTTP request where the communication is initiated by the client (web browser). In order to use Server Push, you need to add the <kbd>vaadin-push</kbd> dependency in your <kbd>pom.xml</kbd> file:</span></p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>com.vaadin<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>vaadin-push<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>To enable Server Push, you can annotate the UI implementation class with<span> </span><kbd>@Push</kbd>:</p>
<pre><span>@Push<br/></span><span>@Title</span>(<span>"Report Viewer"</span>)<br/><span>public class </span>VaadinUI <span>extends </span>UI { ... }</pre>
<p>The<span> </span><kbd>Push</kbd><span> </span>annotation accepts two optional parameters:<span> </span><kbd>value</kbd><span> </span>and<span> </span><kbd>transport</kbd>.The first one, <kbd>value</kbd>, configures the<span> </span><em>push mode</em><span> </span>to use. There are two main options:<span> </span><kbd>PushMode.AUTOMATIC</kbd><span> </span>and<span> </span><kbd>PushMode.MANUAL</kbd>.<span> </span><kbd>AUTOMATIC</kbd> means all changes to the UI are automatically sent to the client once the<span> </span><kbd>UI.access</kbd><span> </span>method finishes (technically, once the session lock is released).<span> </span><kbd>MANUAL</kbd><span> </span>means you have to call<span> </span><kbd>UI.push</kbd><span> </span>to make the UI changes available in the browser. The second parameter,<span> </span><kbd>transport</kbd>,<span> </span>configures<span> </span>the<span> </span><em>transport type</em><span> </span>to use. There are three options:<span> </span><kbd>Transport.WEBSOCKET</kbd><span> </span>(which uses the standard<span> </span><em>WebSockets</em><span> </span>protocol, a different protocol than HTTP, for all communications between the server and the client), <kbd>Transport.WEBSOCKET_XHR</kbd> (which uses WebSockets for server-to-client communication and XHR for client-to-server communication), and<span> </span><kbd>Transport.LONG_POLLING</kbd><span> </span>(a technique that uses the standard HTTP protocol where the client requests the server for data, the server holds the request until new data is available, and the process is repeated again).</p>
<p>You also have to enable the asynchronous operation mode for the<span> </span><kbd>VaadinServlet</kbd> in order to optimize resources and allow XHR as a fallback mechanism when WebSockets is not available:</p>
<pre><span>@WebServlet</span>(<span>value </span>= <span>"/*"</span><span>, </span><strong>asyncSupported = true</strong>)<br/><span>@VaadinServletConfiguration</span>(<span>ui </span>= VaadinUI.<span>class, </span><span>productionMode </span>= <span>false</span>)<br/><span>public static class </span>chapter08VaadinServlet <span>extends </span>VaadinServlet {<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to render <kbd>JasperReports</kbd> in Vaadin applications. We used <kbd>DynamicJasper</kbd>, which allowed us to use the Java Programming Language to design the reports. We also learned how to generate a report in a background thread running on the server and notify the client once the report is ready by using Server Push.</p>
<p>In the next chapter, you will learn about how to handle large volumes of data in UIs by using lazy loading.</p>


            </article>

            
        </section>
    </body></html>