<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Java 9 Language Enhancements</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we gained insight into some exciting new features contained in Java 9. Our focus was on javac, the JDK libraries, and test suites. We learned about memory management improvements including memory allocation, heap optimizations, and enhanced garbage collection. We also covered changes to the compilation process, type testing, annotations, and runtime compiler tests.</p>
<p>This chapter covers some changes in Java 9 that impact variable handlers, depreciation warnings, improvements on Project Coin changes implemented in Java 7, and import statement processing. These represent changes to the Java language itself.</p>
<p>The topics we will cover here are:</p>
<ul>
<li>Variable handlers</li>
<li>Import statement depreciation warnings</li>
<li>Project Coin</li>
<li>Import statement processing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with variable handlers [JEP 193]</h1>
                </header>
            
            <article>
                
<p>Variable handlers are typed references to variables and are governed by the <kbd>java.lang.invoke.VarHandle</kbd> abstract class. <span>The</span> <kbd>VarHandle</kbd> <span>method's signature is polymorphic. This provides for great variability in both method signatures and return types. Here is a code sample demonstrating how a <kbd>VarHandle</kbd> might be used:</span></p>
<pre>    . . . <br/><br/>    class Example <br/>    {<br/>      int myInt;<br/>      . . . <br/>    }<br/>    . . . <br/>    class Sample <br/>    {<br/>      static final VarHandle VH_MYINT;<br/><br/>      static <br/>      {<br/>        try <br/>        {<br/>          VH_MYINT =  <br/>            MethodHandles.lookup().in(Example.class)<br/>            .findVarHandle(Example.class, "myInt", int.class);<br/>        } <br/>        catch (Exception e) <br/>        {<br/>          throw new Error(e);<br/>        }<br/>      }<br/>    }<br/><br/>    . . . </pre>
<p>As you can see in the preceding code snippet, the <kbd>VarHandle.lookup()</kbd> <span>performs the same operation as those</span> that are performed by a <kbd>MethodHandle.lookup()</kbd> method.</p>
<p>The aim of this JEP was to standardize the way in which methods of the following classes are invoked:</p>
<ul>
<li><kbd>java.util.concurrent.atomic</kbd></li>
<li><kbd>sun.misc.Unsafe</kbd>&lt;/li&gt;</li>
</ul>
<p>Specifically, methods that:</p>
<ul>
<li>accessed/mutated object fields</li>
<li>accessed/mutated elements of an array</li>
</ul>
<p>In addition, this JEP resulted in two fence operations for memory ordering and object reachability. In the spirit of due diligence, special attention was given to ensure the JVM's safety. It was important to ensure that memory errors did not result from these changes. Data integrity, usability, and, of course, performance were key components of the aforementioned due diligence and are explained as follows:</p>
<ul>
<li><strong>Safety</strong>: Corrupt memory states must not be possible.</li>
<li><strong>Data integrity</strong>: Ensure access to an object's field uses identical rules used by:
<ul>
<li><kbd>getfield</kbd> byte code</li>
<li><kbd>putfield</kbd> byte code</li>
</ul>
</li>
<li><strong>Usability</strong>: The benchmark for usability was the <kbd>sun.misc.Unsafe</kbd> API. The goal was to make the new API easier to use than the benchmark.</li>
<li><strong>Performance</strong>: There could be no degradation of performance compared to the use of the <kbd>sun.misc.Unsafe</kbd> API. The goal was to outperform that API.</li>
</ul>
<div class="packt_infobox">In Java, a fence operation is what javac does to force a constraint on memory in the form of a barrier instruction. These operations occur before and after the barrier instruction, essentially fencing them in.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with the AtoMiC Toolkit</h1>
                </header>
            
            <article>
                
<p>The <kbd>java.util.concurrent.atomic</kbd> <span>package is a collection of 12 sub-classes that support operations on single variables that are thread-safe and lock-free. In this context, thread-safe refers to code that accesses or mutates a shared single variable without impeding on other threads executing on the variable at the same time. This superclass was introduced in Java 7.</span></p>
<p>Here is a list of the 12 sub-classes in the AtoMiC Toolkit. The class names, as you would expect, are self-descriptive:</p>
<table>
<tbody>
<tr>
<td><strong>Atomic subclass</strong></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicBoolean</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicInteger</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicIntegerArray</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicIntegerFieldUpdater&lt;T&gt;</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicLong</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicLongArray</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicLongFieldUpdater&lt;T&gt;</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicMarkableReference&lt;V&gt;</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent.atomic.AtomicReference&lt;V&gt;</kbd></td>
</tr>
<tr>
<td><span><kbd>java.util.concurrent.atomic.AtomicReferenceArray&lt;E&gt;</kbd></span></td>
</tr>
<tr>
<td><span><kbd>java.util.concurrent.atomic.AtomicReferenceFieldUpdater&lt;T,V&gt;</kbd></span></td>
</tr>
<tr>
<td><span><kbd>java.util.concurrent.atomic.AtomicStampedReference&lt;V&gt;</kbd></span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Volatile variables, fields, and array elements can be asynchronously modified by concurrent threads.</p>
<div class="packt_infobox">In Java, the <kbd>volatile</kbd> keyword is used to inform the javac utility to read the value, field, or array element from the main memory and not to cache them.</div>
<p>Here is a code snippet that demonstrates the use of the volatile keyword for an instance variable:</p>
<pre>    public class Sample <br/>    {<br/>      private static volatile Sample myVolatileVariable; // a<br/>       volatile instance variable<br/><br/>      public static Sample getVariable() // getter method<br/>      {<br/>        if (myVolatileVariable != null) <br/>        {<br/>          return myVolatileVariable;<br/>        }<br/>        // this section executes if myVolatileVariable == null<br/>        synchronized(Sample.class)<br/>        {<br/>          if (myVolatileVariable == null)<br/>          {<br/>            myVolatileVariable =  new Sample();<br/>          }<br/>        }<br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the sun.misc.Unsafe class</h1>
                </header>
            
            <article>
                
<p>The <kbd>sun.misc.Unsafe</kbd> class, like other <kbd>sun</kbd> classes, is not officially documented or supported. It has been used to circumvent some of Java's built-in memory management safety features. While this can be viewed as a window to greater control and flexibility in our code, it is a terrible programming practice.</p>
<p>The class had a single private constructor, so an instance of the class could not easily be instantiated. So, if we tried to instantiate an instance with <kbd><span>myUnsafe = new Unsafe()</span></kbd>, a <kbd>SecurityException</kbd> would be thrown in most circumstances. This somewhat unreachable class has over 100 methods that permitted operations on arrays, classes, and objects. Here is a brief sampling of those methods:</p>
<table>
<tbody>
<tr>
<td><strong>Arrays</strong></td>
<td><strong>Classes</strong></td>
<td><strong>Objects</strong></td>
</tr>
<tr>
<td><kbd><span>arrayBaseOffset</span></kbd></td>
<td><kbd><span>defineAnonymousClass</span></kbd></td>
<td><kbd><span>allocateInstance</span></kbd></td>
</tr>
<tr>
<td><kbd><span>arrayIndexScale</span></kbd></td>
<td><kbd><span>defineClass</span></kbd></td>
<td><kbd><span>objectFieldOffset</span></kbd></td>
</tr>
<tr>
<td/>
<td><kbd><span>ensureClassInitialized</span></kbd></td>
<td/>
</tr>
<tr>
<td/>
<td><kbd><span>staticFieldOffset</span></kbd></td>
<td/>
</tr>
</tbody>
</table>
<p><span>Here is a secondary grouping of the <kbd>sun.misc.Unsafe</kbd> class method for information, memory, and synchronization:</span></p>
<table>
<tbody>
<tr>
<td><strong>Information</strong></td>
<td><strong>Memory</strong></td>
<td><strong>Synchronization</strong></td>
</tr>
<tr>
<td><kbd>addressSize</kbd></td>
<td><kbd>allocateMemory</kbd></td>
<td><kbd>compareAndSwapInt</kbd></td>
</tr>
<tr>
<td><kbd>pageSize</kbd></td>
<td><kbd>copyMemory</kbd></td>
<td><kbd>monitorEnter</kbd></td>
</tr>
<tr>
<td/>
<td><kbd>freeMemory</kbd></td>
<td><kbd>monitorExit</kbd></td>
</tr>
<tr>
<td/>
<td><kbd>getAddress</kbd></td>
<td><kbd>putOrderedEdit</kbd></td>
</tr>
<tr>
<td/>
<td><kbd>getInt</kbd></td>
<td><kbd>tryMonitorEnter</kbd></td>
</tr>
<tr>
<td/>
<td><kbd>putInt</kbd></td>
<td/>
</tr>
</tbody>
</table>
<p> </p>
<p><span>The</span> <kbd>sun.misc.Unsafe</kbd> <span>class was earmarked for removal in Java 9. There was actually some opposition to this decision in the programming industry. To put their concerns to rest, the class has been depreciated, but will not be completely removed. A special flag can be sent to the JVM to utilize the original API.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Eliding depreciation warnings on import statements [JEP 211]</h1>
                </header>
            
            <article>
                
<p>This is one of the more simplistic JEPs for Java 9. Quite often, when we compile our programs, we receive many warnings and errors. The compiler errors must be fixed as they are typically syntactical in nature. The warnings, on the other hand, should be reviewed and appropriately addressed. Some of the warning messages are ignored by developers.</p>
<p>This JEP provides slight relief in the number of warnings we receive. Specifically, depreciation warnings caused by import statements are no longer generated. Prior to Java 9, we could suppress deprecated warning messages with the following annotation:</p>
<pre>    @SupressWarnings</pre>
<p>Now, with Java 9, the compiler will suppress depreciated warnings if one or more of the following cases is true:</p>
<ul>
<li>If the <kbd>@Deprecated</kbd> annotation is used</li>
<li><span>If the</span> <kbd>@SuppressWarnings</kbd> <span>annotation is used</span></li>
<li>If the use of the warning-generating code and the declaration are within the ancestor class</li>
<li>If the use of the warning-generating code is within an import statement</li>
</ul>
<p>The fourth condition listed was an addition in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Milling Project Coin [JEP 213]</h1>
                </header>
            
            <article>
                
<p>Project Coin was a feature set of minor changes introduced in Java 7. These changes are listed as follows:</p>
<ul>
<li>Strings in <kbd>switch</kbd> statements</li>
<li>Binary integral literals</li>
<li>Using underscores in numeric literals</li>
<li>Implementing multi-catch</li>
<li>Allowing for more precise re-throwing of exceptions</li>
<li>Generic instance creation improvements</li>
<li>Addition of the <kbd>try-with-resources</kbd> statement</li>
<li>Improvements to invoking <kbd>varargs</kbd> methods</li>
</ul>
<p>Detailed information can be found in the following Oracle presentation: <a href="http://www.oracle.com/us/technologies/java/project-coin-428201.pdf">http://www.oracle.com/us/technologies/java/project-coin-428201.pdf</a>.</p>
<p>JEP 213 focused on improvements to Project Coin's enhancements. There were five such enhancements, each detailed as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the @SafeVarargs annotation</h1>
                </header>
            
            <article>
                
<p>In Java 9, we can use th<span>e</span> <kbd>@SafeVarargs</kbd> <span>annotation with private instance methods. When we use this annotation, we are asserting that the method does not contain any harmful operations on the <kbd>varargs</kbd> passed as parameters to the method.</span></p>
<p>The syntax for usage is:</p>
<pre>    @SafeVarargs // this is the annotation<br/>    static void methodName(...) <br/>    {<br/><br/>      /*<br/>      The contents of the method or constructor must not <br/>      perform any unsafe or potentially unsafe operations <br/>      on the varargs parameter or parameters.<br/>      */<br/><br/>    }</pre>
<p><span>Use of the <kbd>@SafeVarargs</kbd> annotation is restricted to:</span></p>
<ul>
<li><span>Static methods</span></li>
<li><span>Final instance methods</span></li>
<li><span>Private instance methods</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The try-with-resource statement</h1>
                </header>
            
            <article>
                
<p>The <kbd>try-with-resource</kbd> statement previously required a new variable to be declared for each resource in the statement when a final variable was used. Here is the syntax for the <kbd>try-with-resource</kbd> statement prior to Java 9 (in Java 7 or 8):</p>
<pre>    try ( // open resources ) <br/>    {<br/>      // use resources<br/>    } catch (// error) <br/>    {  // handle exceptions<br/>    }<br/>    // automatically close resources</pre>
<p>Here is a code snippet using the preceding syntax:</p>
<pre>    try ( Scanner xmlScanner = new Scanner(new File(xmlFile));<br/>    {<br/>       while (xmlScanner.hasNext())<br/>       {<br/>          // read the xml document and perform needed operations<br/>       }<br/>      xmlScanner.close();<br/>    } catch (FileNotFoundException fnfe)<br/>      {<br/>         System.out.println("Your XML file was not found.");<br/>      }</pre>
<p>Now, with Java 9, the <kbd>try-with-resource</kbd> statement can manage final variables without requiring a new variable declaration. So, we can now rewrite the earlier code, as shown here in Java 9:</p>
<pre>    Scanner xmlScanner = new Scanner(newFile(xmlFile));<br/>    try ( while (xmlScanner.hasNext())<br/>    {<br/>       {<br/>         // read the xml document and perform needed operations<br/>       }<br/>       xmlScanner.close();<br/>    } catch (FileNotFoundException fnfe)<br/>      {<br/>         System.out.println("Your XML file was not found.");<br/>      }</pre>
<p>As you can see, the <kbd>xmlScanner</kbd> object reference is contained inside the <kbd>try-with-resource</kbd> statement block, which provides for automatic resource management. The resource will automatically be closed as soon as the <kbd>try-with-resource</kbd> statement block is exited.</p>
<div class="packt_tip">You can also use <span>a</span> <kbd>finally</kbd> block as part of the <kbd>try-with-resource</kbd> statement.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the diamond operator</h1>
                </header>
            
            <article>
                
<p>Introduced in Java 9, the diamond operator can be used with anonymous classes if the inferred data type is denotable. When a data type is inferred, it suggests that the Java Compiler can determine the data types in a method's invocation. This includes the declaration and any included arguments.</p>
<div class="packt_infobox">The diamond operator is the less-than and greater-than symbol pair (<kbd>&lt;&gt;</kbd> ). It is not new to Java 9; rather, the specific use with anonymous classes is.</div>
<p>The diamond operator was introduced in Java 7 and made instantiating generic classes simpler. Here is a pre-Java 7 example:</p>
<pre>    ArrayList&lt;Student&gt; roster = new ArrayList&lt;Student&gt;();</pre>
<p>Then, in Java 7, we could rewrite it:</p>
<pre>    ArrayList&lt;Student&gt; roster = new ArrayList&lt;&gt;();</pre>
<p>The problem was that this method could not be used for anonymous classes. Here is an example in Java 8 that works fine:</p>
<pre>    public interface Example&lt;T&gt; <br/>    {<br/>      void aMethod()<br/>      {<br/>        // interface code goes here<br/>      }<br/>    }<br/><br/>    Example example = new Example&lt;Integer&gt;() <br/>    {<br/>      @Override<br/>      public void aMethod() <br/>      {<br/>        // code<br/>      }<br/>    };</pre>
<p>While the preceding code works fine, when we change it to use the diamond operator, as shown here, a compiler error will occur:</p>
<pre>    public interface Example&lt;T&gt; <br/>    {<br/>      void aMethod()<br/>      {<br/>        // interface code goes here<br/>      }<br/>    }<br/><br/>    Example example = new Example&lt;&gt;() <br/>    {<br/>      @Override<br/>      public void aMethod() <br/>      {<br/>        // code<br/>      }<br/>    };</pre>
<p>The error results from using the diamond operator with anonymous inner classes. Java 9 to the rescue. While the preceding code results in a compile time error in Java 8, it works fine in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discontinuing use of the underscore</h1>
                </header>
            
            <article>
                
<p>The underscore character ( <kbd>_</kbd> ) can no longer be used as a legal identifier name. Earlier attempts to remove the underscore in an identifier name were incomplete. The use of such would generate a combination of errors and warnings. With Java 9, the warnings are now errors. Consider the following sample code:</p>
<pre>    public class Java9Tests <br/>    { <br/>      public static void main(String[] args) <br/>      {<br/>        int _ = 319;<br/>        if ( _ &gt; 300 )<br/>        {<br/>          System.out.println("Your value us greater than 300."); <br/>        } <br/>        else <br/>        {<br/>          System.out.println("Your value is not greater than 300.");<br/>        }<br/>      }<br/>    }</pre>
<p>The preceding code, in Java 8, will result in compiler warnings for <kbd>int _ = 319;</kbd> <span>and</span> <kbd>if ( _ &gt; 300 )</kbd> <span>statements. The warning is</span> <em>as of release 9, '_' is a keyword, and may not be used as an identifier</em><span>. So, in Java 9, you will not be able to use the underscore by itself as a legal identifier.</span></p>
<div class="packt_tip">It is considered bad programming practice to use identifier names that are not self-descriptive. So, the use of the underscore character by itself as an identifier name should not be a problematic change.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making use of private interface methods</h1>
                </header>
            
            <article>
                
<p>Lambda expressions were a big part of the Java 8 release. As a follow-up to that improvement, private methods in interfaces are now feasible. Previously, we could not share data between non-abstract methods of an interface. With Java 9, this data sharing is possible. Interface methods can now be private. Let's look at some sample code.</p>
<p>This first code snippet is how we might code an interface in Java 8:</p>
<pre>    . . . <br/>    public interface characterTravel<br/>    {<br/>      pubic default void walk()<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        p = p +1;<br/>      }<br/>      public default void run()<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        p = p +4;<br/>      }<br/>      public default void fastWalk()<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        p = p +2;<br/>      }<br/>      public default void retreat()<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        p = p - 1;<br/>      }<br/>      public default void fastRetreat()<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        p = p - 4;<br/>      }<br/>    }</pre>
<p>Now, in Java 9, we can rewrite this code. As you can see next, the redundant code has been moved into a single private method called <kbd>characterTravel</kbd>:</p>
<pre>    . . . <br/>    public interface characterTravel<br/>    {<br/>      pubic default void walk()<br/>      {<br/>        characterTravel("walk");<br/>      }<br/>      public default void run()<br/>      {<br/>        characterTravel("run");<br/>      }<br/>      public default void fastWalk()<br/>      {<br/>        characterTravel("fastWalk");<br/>      }<br/>      public default void retreat()<br/>      {<br/>        characterTravel("retreat");<br/>      }<br/>      public default void fastRetreat()<br/>      {<br/>        characterTravel("fastRetreat");<br/>      }<br/>      private default void characterTravel(String pace)<br/>      {<br/>        Scanner scanner = new Scanner(System.in);<br/>        System.out.println("Enter desired pacing: ");<br/>        int p = scanner.nextInt();<br/>        if (pace.equals("walk"))<br/>        {<br/>          p = p +1;<br/>        }<br/>        else if (pace.equals("run"))<br/>        {<br/>          p = p + 4;<br/>        }<br/>        else if (pace.equals("fastWalk"))<br/>        {<br/>          p = p + 2;<br/>        }<br/>        else if (pace.equals("retreat"))<br/>        {<br/>          p = p - 1;<br/>        }<br/>        else if (pace.equals("fastRetreat"))<br/>        {<br/>          p = p - 4;<br/>        }<br/>        else<br/>        {<br/>          //<br/>        }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing import statements correctly [JEP 216]</h1>
                </header>
            
            <article>
                
<p>JEP 216 was issued as a fix to javac in regards to how import statements are processed. Prior to Java 9, there were instances where the order of import statements would impact if the source code was accepted or not.</p>
<p>When we develop applications in Java, we typically add import statements as we need them, resulting in an unordered list of import statements. IDEs do a great job of color-coding import statements that are not used, as well as informing us of import statements we need but that have not been included. It should not matter what order the import statements are in; there is no applicable hierarchy.</p>
<p><span>javac</span> <span>compiles classes in</span> <span>two primary</span> <span>steps. Specific to handling import statements, these steps are type resolution and member resolution. The type resolution consists of a review of the abstract syntax tree to identify declarations of classes and interfaces. The member resolution includes determining the class hierarchy and individual class variables and members.</span></p>
<p>With Java 9, the order we list import statements in our classes and files will no longer impact the compilation process. Let's look at an example:</p>
<pre>    package samplePackage;<br/><br/>    import static SamplePackage.OuterPackage.Nested.*;<br/>    import SamplePackage.Thing.*;<br/><br/>    public class OuterPackage <br/>    {<br/>      public static class Nested implements Inner <br/>      { <br/>        // code<br/>      }<br/>    }<br/><br/>    package SamplePackage.Thing;<br/><br/>    public interface Inner <br/>    {<br/>      // code<br/>    }</pre>
<p>In the preceding example, type resolution occurs and results in the following realizations:</p>
<ul>
<li><kbd>SamplePackage.OuterPackage</kbd> exists</li>
<li><kbd>SamplePackage.OuterPackage.Nested</kbd> exists</li>
<li><kbd>SamplePackage.Thing.Innner</kbd> exists</li>
</ul>
<p>The next step is member resolution, and this is where the problem existed prior to Java 9. Here is an overview of the sequential steps javac would use to conduct the member resolution for our sample code:</p>
<ol>
<li>Resolution of <kbd>SamplePackage.OuterPackage</kbd> begins.</li>
<li>The <kbd>SamplePackage.OuterPackage.Nested</kbd> import is processed.</li>
<li>Resolution of the <kbd>SamplePackage.Outer.Nested</kbd> class begins.</li>
<li>The inner interface is type checked, although, because it is not in scope at this point, inner cannot be resolved.</li>
<li>Resolution of <kbd>SamplePackage.Thing</kbd> begins. This step includes importing all member types of <kbd>SamplePackage.Thing</kbd> into scope.</li>
</ol>
<p>So the error occurs, in our example, because <kbd>Inner</kbd> is out of scope when resolution is attempted. If steps 4 and 5 were swapped, it would not have been a problem.</p>
<p>The solution to the problem, implemented in Java 9, was to break the member resolution steps into additional sub-steps. Here are those steps:</p>
<ol>
<li>Analyze the import statements.</li>
<li>Create the hierarchy (class and interfaces).</li>
<li>Analyze class headers and type parameters.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered changes in Java 9 with regards to variable handlers and how they relate to the Atomic Toolkit. We also covered depreciation warnings and why they are now suppressed under specific circumstances. Five enhancements to changes introduced with Java 7 as part of Project Coin were also reviewed. Finally, we explored the improvements to import statement processing.</p>
<p>In the next chapter, we will examine the structure of a Java module as specified by Project Jigsaw. We will take a deep dive into how Project Jigsaw is implemented as part of the Java platform. Code snippets from a sample e-commerce application are used throughout the chapter to demonstrate Java 9's modular system. Internal changes to the Java platform, in regards to the modular system, are also discussed.</p>


            </article>

            
        </section>
    </body></html>