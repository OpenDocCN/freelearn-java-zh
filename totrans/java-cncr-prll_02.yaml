- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduction to Java’s Concurrency Foundations: Threads, Processes, and Beyond'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048), where we embark
    on a culinary-inspired exploration of Java’s concurrency model, likening it to
    a bustling kitchen. In this dynamic environment, **threads** are akin to nimble
    sous chefs, each skillfully managing their specific tasks with speed and precision.
    They work in unison, seamlessly sharing the kitchen space and resources. Imagine
    each thread whisking through their assigned recipes, contributing to the overall
    culinary process in a synchronized dance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, processes are comparable to larger, independent kitchens,
    each equipped with their unique menus and resources. These processes operate autonomously,
    handling complex tasks in their self-contained domains without the interference
    of neighboring kitchens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we delve into the nuances of these two essential components
    of Java’s concurrency. We’ll explore the life cycle of a thread and understand
    how it wakes up, performs its duties, and eventually rests. Similarly, we’ll examine
    the independent freedom and resource management of processes. Our journey will
    also take us through the `java.util.concurrent` package, a well-stocked pantry
    of tools designed for orchestrating threads and processes with efficiency and
    harmony. By the end of this chapter, you’ll gain a solid understanding of how
    to manage these concurrent elements, enabling you to build robust and efficient
    Java applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to install a Java **integrated development environment** (**IDE**)
    on your laptop. Here are a few Java IDEs and their download URLs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA**:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download** **URL**: [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing**: Free Community Edition with limited features, Ultimate Edition
    with full features requires a subscription'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eclipse IDE**:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download** **URL**: [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing**: Free and open source'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache NetBeans**:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download URL**:[https://netbeans.apache.org/front/main/download/index.html](https://netbeans.apache.org/front/main/download/index.html)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing**: Free and open source'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code (****VS Code)**:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Download** **URL**: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing**: Free and open source'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code offers a lightweight and customizable alternative to the other options
    on this list. It’s a great choice for developers who prefer a less resource-intensive
    IDE and want the flexibility to install extensions tailored to their specific
    needs. However, it may not have all the features out of the box compared to the
    more established Java IDEs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the code in this chapter can be found on GitHub:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Java’s kitchen of concurrency – unveiling threads and processes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java的并发厨房——揭示线程和进程
- en: Mastering Java’s concurrency tools, threads and processes, is akin to acquiring
    the skills of a culinary master. This section equips you with the knowledge to
    design efficient and responsive Java applications, ensuring your programs run
    smoothly even when juggling multiple tasks like a Michelin-starred kitchen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握Java的并发工具——线程和进程，就像获得了一位烹饪大师的技能。本节将为您提供设计高效且响应迅速的Java应用程序的知识，确保您的程序即使在处理多个任务时也能平稳运行，就像一位米其林星级厨房的厨师一样。
- en: What are threads and processes?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和进程是什么？
- en: In the realm of Java concurrency, **threads** are like sous chefs in a kitchen.
    Each sous chef (thread) is assigned a particular task, working diligently to contribute
    to the overall meal preparation. Just as sous chefs share a common kitchen space
    and resources, threads operate in parallel within the same Java process, sharing
    memory and resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java并发的领域，**线程**就像厨房中的副厨师。每位副厨师（线程）被分配了特定的任务，勤奋地工作以贡献于整体餐点的准备。正如副厨师共享共同的厨房空间和资源一样，线程在同一个Java进程中并行操作，共享内存和资源。
- en: Now, picture a large restaurant with separate kitchens for different specialties,
    such as a pizza oven room, a pastry department, and a main course kitchen. Each
    of these is a **process**. Unlike threads that share a single kitchen, processes
    have their own dedicated resources and operate independently. They’re like separate
    restaurants, ensuring that complex dishes such as intricate pastries get the dedicated
    attention they deserve, without interfering with the main course preparation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一家大型餐厅，拥有为不同特色菜系而设的独立厨房，例如比萨烤箱房、糕点部门和主菜厨房。这些每个都是**进程**。与共享单个厨房的线程不同，进程拥有自己的专用资源和独立运作。它们就像独立的餐厅，确保复杂的菜肴，如精致的糕点，能够得到应有的专注，而不会干扰主菜的准备工作。
- en: In essence, threads are like nimble sous chefs sharing the kitchen, while processes
    are like independent restaurant kitchens with dedicated chefs and resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，线程就像敏捷的副厨师共享厨房，而进程则像拥有专用厨师和资源的独立餐厅厨房。
- en: Similarities and differences
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相似之处与不同之处
- en: Imagine our bustling restaurant kitchen once again, this time buzzing with both
    threads and processes. While they both contribute to a smooth culinary operation,
    they do so in distinct ways, like skilled chefs with different specialties. Let’s
    dive into their similarities and differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们繁忙的餐厅厨房再次热闹起来，这次是线程和进程同时忙碌。虽然它们都为流畅的烹饪操作做出了贡献，但它们以不同的方式做到这一点，就像拥有不同专长的熟练厨师。让我们深入了解它们的相似之处和不同之处。
- en: 'Both threads and processes share the following similarities:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程有以下相似之处：
- en: '**Multitasking masters**: Both threads and processes allow Java applications
    to handle multiple tasks concurrently. Imagine serving multiple tables simultaneously,
    with no single dish left waiting.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多任务大师**：线程和进程都允许Java应用程序同时处理多个任务。想象一下同时服务多张餐桌，没有一道菜会等待。'
- en: '**Resource sharing**: Both threads within a process and processes themselves
    can share resources, such as files or databases, depending on their configuration.
    This allows for efficient data access and collaboration.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源共享**：进程内的线程和进程本身可以根据其配置共享资源，如文件或数据库。这允许高效的数据访问和协作。'
- en: '**Independent execution**: Both threads and processes have their own independent
    execution paths, meaning they can run their own instructions without interrupting
    each other. Think of separate chefs working on different dishes, each following
    their own recipe.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立执行**：线程和进程都有自己的独立执行路径，这意味着它们可以运行自己的指令而不会相互干扰。想象一下不同的厨师在准备不同的菜肴，每个厨师都遵循自己的食谱。'
- en: 'Threads and processes are different in the following areas:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程在以下方面有所不同：
- en: '**Scope**: Threads exist within a single process, sharing their memory space
    and resources like ingredients and cooking tools. Processes, on the other hand,
    are completely independent, each with its own isolated kitchen and resources.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：线程存在于单个进程中，共享它们的内存空间和资源，如原料和烹饪工具。另一方面，进程是完全独立的，每个进程都有自己的独立厨房和资源。'
- en: '**Isolation**: Threads share the same memory space, making them susceptible
    to interference and data corruption. Processes, with their separate kitchens,
    offer greater isolation and security, preventing accidental contamination and
    protecting sensitive data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creation and management**: Creating and managing threads is simpler and more
    lightweight within a process. Processes, as independent entities, require more
    system resources and are more complex to control.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Threads offer finer-grained control and can be switched quickly,
    potentially faster execution for smaller tasks. Processes, with their separate
    resources, can be more efficient for larger, independent workloads.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both threads and processes are valuable tools in the Java chef’s toolbox, each
    fulfilling specific needs. By understanding their similarities and differences,
    we can choose the right approach to create culinary masterpieces or, rather, masterful
    Java applications!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of threads in Java
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In exploring the life cycle of a thread, akin to the work shift of a sous chef
    in our kitchen metaphor, we focus on the pivotal stages that define a thread’s
    existence within a Java application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**New state**: When a thread is created using the new keyword or by extending
    the Thread class, it enters the **new state**. It is akin to a sous chef arriving
    at the kitchen, ready but not yet engaged in cooking.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()` method is called. Here, it’s akin to the sous chef prepped and waiting
    for their turn to cook. The thread scheduler decides when to allocate **central
    processing unit** (**CPU**) time to the thread, based on thread priorities and
    system policies.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run()` method. This is similar to the sous chef actively working on their
    assigned tasks in the kitchen. At any given moment, only one thread can be in
    the Running state on a single processor core.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait()`, `join()`, or `sleep()` methods.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sleep(long milliseconds)` or `wait(long milliseconds)`. This is comparable
    to a sous chef taking a scheduled break during their shift, knowing they will
    resume work after a certain time has elapsed.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run()` method or is interrupted using the `interrupt()` method. This is comparable
    to a sous chef finishing their tasks and ending their shift. Once terminated,
    a thread cannot be restarted.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This life cycle is crucial to understanding how threads are managed within a
    Java program. It dictates how threads are born (created), run (`start()` and `run()`),
    pause (`wait(), join(), sleep()`), wait with a timeout (`sleep(long)`, `wait(long)`),
    and ultimately end their execution (completing `run()` or being interrupted).
    Understanding these key methods and their impact on thread states is essential
    for effective concurrent programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take this knowledge to the real world and explore how threads are
    used in everyday Java applications!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Activity – differentiating threads and processes in a practical scenario
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the vibrant kitchen of Java concurrency, the following Java code demonstrates
    how threads (chefs) perform tasks (preparing dishes) within a process (the kitchen).
    This analogy will help illustrate the concepts of thread and process in a real-world
    scenario:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a breakdown of the roles of threads in the preceding Java code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService` kitchen creates a pool of three threads to simulate three
    chefs working concurrently.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit()` method assigns tasks (preparing a dish, searching for recipes, updating
    the menu) to individual threads within the pool.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent execution**: Threads enable these tasks to run simultaneously,
    potentially improving performance and responsiveness.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.sleep(1000)`. This simulates the time taken by the chef to perform
    the task. During this sleep period, other threads can continue their execution,
    demonstrating the concurrent nature of the program.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.sleep()` can throw `InterruptedException`, each task is wrapped in
    a try-catch block. If an interruption occurs during sleep, the exception is caught,
    and the thread’s interrupted status is restored using `Thread.currentThread().interrupt()`.
    This ensures proper handling of interruptions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following points present a discussion on the roles of processes in the
    preceding Java code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Java runtime**: The entire Java program, including the kitchen simulation,
    runs within a single operating system process'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource allocation**: The process has its own memory space, allocated by
    the operating system, to manage variables, objects, and code execution'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: It provides the environment for threads to exist and operate
    within'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key takeaways from the code example we just saw are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**Threads within a process**: Threads are lightweight execution units that
    share the same process’s memory and resources'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: Threads enable multiple tasks to be executed concurrently
    within a single process, taking advantage of multiple CPU cores if available'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process management**: The operating system manages processes, allocating
    resources and scheduling their execution'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s shift gears and explore the tools that unlock their full potential:
    the `java.util.concurrent` package. This treasure trove of classes and interfaces
    provides the building blocks for crafting robust and efficient concurrent programs,
    ready to tackle any multitasking challenge your Java app throws at them!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency toolkit – java.util.concurrent
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of your Java application as a bustling restaurant. Orders stream in, ingredients
    need prepping, and dishes must be cooked and delivered seamlessly. Now, imagine
    managing this chaos without efficient systems – it’s a recipe for disaster! Fortunately,
    the `java.util.concurrent` package acts as your restaurant’s high-tech equipment,
    streamlining operations and preventing chaos. With sophisticated tools such as
    thread pools for managing chefs (threads), locks and queues for coordinating tasks,
    and powerful concurrency utilities, you can orchestrate your Java application
    like a Michelin-starred chef. So, dive into this toolkit and unlock the secrets
    of building smooth, responsive, and efficient Java programs that truly wow your
    users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a glimpse at the key elements within this package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Threads and executors
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `ExecutorService` and `ThreadPoolExecutor` play crucial roles in orchestrating
    concurrent tasks:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService`: A versatile interface for managing thread pools:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedThreadPool` for a fixed number of threads'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CachedThreadPool` for a pool that grows as needed'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SingleThreadExecutor` for sequential execution'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScheduledThreadPool` for delayed or periodic tasks'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThreadPoolExecutor`: A concrete implementation of `ExecutorService`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecutorService`, providing fine-grained control over thread pool behavior.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Granular control**: It allows you to customize thread pool parameters such
    as the following:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Core pool size (initial threads)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum pool size (maximum threads)
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep-alive time (idle thread timeout)
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue capacity (waiting tasks)
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct usage**: It involves instantiating it directly in your code. This
    approach gives you complete control over the thread pool’s behavior, as you can
    specify parameters such as core pool size, maximum pool size, keep-alive time,
    queue capacity, and thread factory. This method is suitable when you need fine-grained
    control over the thread pool characteristics. Here’s an example of direct usage:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `ThreadPoolExecutor` is directly instantiated with specific
    parameters. It creates a thread pool with a core pool size of `2`, a maximum pool
    size of `4`, a keep-alive time of `5000` milliseconds, and a work queue capacity
    of `10` tasks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The code uses `IntStream.range()` and `forEach` to submit tasks to the thread
    pool. Each task prints a formatted string containing the task number, current
    pool size, and queue size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to select the right tool for your tasks based on the requirements.
    You may keep the following in mind:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService` for most cases, benefiting from its simplicity and flexibility
    in choosing appropriate implementations'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThreadPoolExecutor` when you need precise control over thread pool configuration
    and behavior'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding their strengths and use cases, you can expertly manage thread
    pools and unlock the full potential of concurrency in your Java projects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The next group of elements in this package is synchronization and coordination.
    Let us explore this category in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本包中的下一组元素是同步和协调。让我们在下一节中探索这个类别。
- en: Synchronization and coordination
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和协调
- en: 'Synchronization and coordination are crucial in multi-threaded environments
    to manage shared resources and ensure thread-safe operations. Java provides several
    classes and interfaces for this purpose, each serving specific use cases in concurrent
    programming:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同步和协调在多线程环境中至关重要，用于管理共享资源并确保线程安全操作。Java为此提供了几个类和接口，每个都服务于并发编程中的特定用例：
- en: '**Lock**: A flexible interface for controlling access to shared resources:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lock**：一个用于控制对共享资源访问的灵活接口：'
- en: '**Exclusive access**: Assert fine-grained control over shared resources, ensuring
    only one thread can access a critical section of code at a time'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独占访问**：对共享资源进行细粒度控制，确保一次只有一个线程可以访问代码的关键部分'
- en: '**Use cases**: Protecting shared data structures, coordinating access to files
    or network connections, and preventing race conditions'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：保护共享数据结构，协调对文件或网络连接的访问，以及防止竞态条件'
- en: '`Semaphore`: A class for managing access to a limited pool of resources, preventing
    resource exhaustion:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`：一个用于管理对有限资源池访问的类，防止资源耗尽：'
- en: '**Resource management**: This regulates access to a pool of resources, allowing
    multiple threads to share a finite number of resources concurrently'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：这调节对资源池的访问，允许多个线程并发共享有限数量的资源'
- en: '**Use cases**: Limiting concurrent connections to a server, managing thread
    pools, and implementing producer-consumer patterns'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：限制对服务器的并发连接，管理线程池，以及实现生产者-消费者模式'
- en: '`CountDownLatch`: This is also a class in the `java.util.concurrent` package,
    which allows threads to wait for a set of operations to complete before proceeding:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`：这也是`java.util.concurrent`包中的一个类，允许线程在继续之前等待一组操作完成：'
- en: '**Task coordination**: Synchronize threads by requiring a set of tasks to complete
    before proceeding. Threads wait at the latch until a counter reaches zero.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务协调**：通过要求在继续之前完成一组任务来同步线程。线程在计数器达到零之前在闩锁上等待。'
- en: '**Use cases**: Waiting for multiple services to start before launching an application,
    ensuring initialization tasks finish before starting a main process, and managing
    test execution order.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：在启动应用程序之前等待多个服务启动，确保初始化任务在启动主过程之前完成，以及管理测试执行顺序。'
- en: '`CyclicBarrier`: This is another class in the `java.util.concurrent` package,
    used for synchronizing threads that perform interdependent tasks. Unlike `CountDownLatch`,
    `CyclicBarrier` can be reused after the waiting threads are released:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：这是`java.util.concurrent`包中的另一个类，用于同步执行相互依赖任务的线程。与`CountDownLatch`不同，`CyclicBarrier`在等待线程释放后可以被重用：'
- en: '**Barrier for synchronization**: Gather a group of threads at a common barrier
    point, allowing them to proceed only when all threads have reached that point'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步屏障**：在公共屏障点上聚集一组线程，只有当所有线程都达到该点时才允许它们继续'
- en: '**Use cases**: Dividing work among threads and then regrouping, performing
    parallel computations followed by a merge operation, and implementing rendezvous
    points'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：在多个线程中分配工作然后重新分组，执行并行计算后进行合并操作，以及实现会合点'
- en: Each of these tools serves a distinct purpose in coordinating threads and ensuring
    harmonious execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的每一个都在协调线程和确保和谐执行中发挥着独特的作用。
- en: The last group in the package is concurrent collections and atomic variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的最后一组是并发集合和原子变量。
- en: Concurrent collections and atomic variables
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发集合和原子变量
- en: Concurrent collections are designed specifically for thread-safe storage and
    retrieval of data in multi-threaded environments. Key members include `ConcurrentHashMap`,
    `ConcurrentLinkedQueue`, and `CopyOnWriteArrayList`. These collections offer thread-safe
    operations without the need for external synchronization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合是专门为多线程环境中的线程安全存储和检索数据而设计的。关键成员包括`ConcurrentHashMap`、`ConcurrentLinkedQueue`和`CopyOnWriteArrayList`。这些集合提供了线程安全操作，无需外部同步。
- en: Atomic variables provide thread-safe operations for simple variables (integers,
    longs, references), eliminating the need for explicit synchronization in many
    cases. Key members include `AtomicInteger`, `AtomicLong`, and `AtomicReference`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed discussion on the advanced uses and optimized access patterns
    of these concurrent collections, refer to the *Leveraging thread-safe collections*
    *to mitigate concurrency issues* section later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at a code example to see how java.util.concurrent is implemented.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercise – implementing a concurrent application using java.util.concurrent
    tools
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this hands-on exercise, we’ll create a simulated real-world application
    that demonstrates the use of various `java.util.concurrent` elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: Our application will be a basic order processing system where orders
    are placed and processed in parallel, and various concurrent elements are utilized
    to manage synchronization, coordination, and data integrity. Here is the Java
    code example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code example uses many concurrency elements such as the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutorService` is used to handle multiple tasks (order processing) in a
    thread pool, enabling parallel execution'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentLinkedQueue` is a thread-safe queue used to hold and manage orders
    efficiently in a concurrent environment'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CopyOnWriteArrayList` provides a thread-safe list implementation, suitable
    for storing processed orders where iteration is more frequent than modification'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap` offers a high-performance, thread-safe map to track the
    status of each order'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReentrantLock` is used to ensure exclusive access to the payment processing
    section of the code, thus avoiding concurrency issues'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Semaphore` controls the number of concurrent validations, preventing resource
    exhaustion'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AtomicInteger` is a thread-safe integer, used for counting processed orders
    safely in a concurrent context'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these classes and interfaces plays a vital role in ensuring thread safety
    and efficient concurrency management in the `OrderProcessingSystem`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points we have learned are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient threading**: This uses a thread pool to handle multiple orders
    concurrently, potentially improving performance'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization**: This employs locks and semaphores to coordinate access
    to shared resources and critical sections, ensuring data consistency and preventing
    race conditions'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread-safe data**: This manages orders and statuses with thread-safe collections
    to support concurrent access'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status tracking**: This maintains order statuses for monitoring and reporting'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example demonstrates how these concurrent utilities can be combined to
    build a multi-threaded, synchronized, and coordinated application for order processing.
    Each utility serves a specific purpose, from managing concurrent tasks to ensuring
    data integrity and synchronization among threads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how synchronization and locking mechanisms are used in
    Java applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨同步和锁定机制在Java应用程序中的应用。
- en: Synchronization and locking mechanisms
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步和锁定机制
- en: Imagine a bakery where multiple customers place orders simultaneously. Without
    proper synchronization, two orders could be mixed up, ingredients double counted,
    or payments processed incorrectly. This is where locking steps in, acting like
    a *hold, please* sign, allowing one thread to use the oven or cash register at
    a time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个面包店，多个客户同时下订单。如果没有适当的同步，两个订单可能会混淆，成分可能会被重复计算，或者付款可能会处理错误。这就是锁定介入的地方，它就像一个“请稍等”的标志，允许一次只有一个线程使用烤箱或收银机。
- en: '**Synchronization and locking mechanisms** are the guardians of data integrity
    and application stability in concurrent environments. They prevent race conditions,
    ensure atomic operations (complete or not, never partial), and guarantee predictable
    execution order, ultimately creating a reliable and efficient multi-threaded process.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步和锁定机制**是并发环境中数据完整性和应用程序稳定性的守护者。它们防止竞争条件，确保原子操作（无论完成与否，永远不是部分操作），并保证可预测的执行顺序，最终创建一个可靠和高效的多线程进程。'
- en: Let’s delve into the world of synchronization and locking mechanisms, explore
    why they’re crucial, and how to wield them effectively to build robust and performant
    concurrent applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入同步和锁定机制的世界，探讨它们为什么至关重要，以及如何有效地运用它们来构建健壮和性能良好的并发应用程序。
- en: The power of synchronization – protecting critical sections for thread-safe
    operations
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步的力量——保护临界区以进行线程安全操作
- en: 'In Java, the keyword **synchronized** acts as a gatekeeper for sensitive code
    blocks. When a thread enters a synchronized block, it acquires a lock on the associated
    object, preventing other threads from entering the same block until the lock is
    released. This ensures exclusive access to shared resources and prevents data
    corruption. There are three different locks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，关键字**synchronized**充当敏感代码块的门卫。当一个线程进入同步块时，它会获取关联对象的锁，防止其他线程进入相同的块，直到锁被释放。这确保了对共享资源的独占访问，并防止数据损坏。存在三种不同的锁：
- en: '**Object-level locks**: When a thread enters a synchronized block, it acquires
    a lock on the instance of the object associated with the block. This lock is released
    when the thread exits the block.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象级锁**：当一个线程进入同步块时，它会获取与块关联的对象实例的锁。当线程退出块时，这个锁会被释放。'
- en: '**Class-level locks**: For static methods and blocks, the lock is acquired
    on the class object itself, ensuring synchronization across all instances of the
    class.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类级锁**：对于静态方法和块，锁是在类对象本身上获取的，确保了类所有实例的同步。'
- en: '**Monitor object**: The **Java virtual machine** (**JVM**) employs a monitor
    object for each object and class to manage synchronization. This monitor object
    tracks the thread holding the lock and coordinates access to the locked resource.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器对象**：**Java虚拟机**（**JVM**）为每个对象和类使用一个监视器对象来管理同步。这个监视器对象跟踪持有锁的线程，并协调对锁定资源的访问。'
- en: 'In cloud environments, locking mechanisms find their primary applications in
    several critical areas: coordinating distributed services, accessing shared data,
    and managing state – specifically maintaining and updating internal state information
    securely across multiple threads. Beyond traditional synchronization, there exist
    various alternative and sophisticated locking techniques. Let’s delve into these
    together.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，锁定机制在几个关键领域找到其主要应用：协调分布式服务、访问共享数据和管理状态——特别是安全地跨多个线程维护和更新内部状态信息。除了传统的同步之外，还存在各种替代和复杂的锁定技术。让我们一起来探讨这些技术。
- en: Beyond the gatekeeper – exploring advanced locking techniques
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越门卫——探索高级锁定技术
- en: 'In our exploration of Java’s concurrency tools, we’ve seen basic synchronization
    methods. Now, let’s delve into advanced locking techniques that offer greater
    control and flexibility for complex scenarios. These techniques are particularly
    useful in high-concurrency environments or when dealing with intricate resource
    management challenges:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Java并发工具的过程中，我们已经看到了基本的同步方法。现在，让我们深入探讨高级锁定技术，这些技术为复杂场景提供了更大的控制和灵活性。这些技术在高并发环境或处理复杂的资源管理挑战时尤其有用：
- en: '`ReentrantLock` provides the ability to attempt a lock with a timeout, preventing
    threads from getting indefinitely blocked.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock`提供了尝试带超时时间的锁的能力，防止线程无限期地阻塞。'
- en: '`ReentrantLock` can be used to ensure that if a document is taking too long
    to print, other jobs can be processed in the meantime, avoiding a bottleneck.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWriteLock` allows multiple threads to read a resource concurrently but
    requires exclusive access for writing.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWriteLock` optimizes performance by allowing concurrent reads while maintaining
    data integrity during updates.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StampedLock` offers a mode where a lock can be acquired with an option to
    convert it to a read or write lock.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StampedLock` allows for more concurrency with the flexibility to upgrade a
    read lock to a write lock when an update is necessary.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReentrantLock`, which allows threads to communicate about the lock status.
    A condition object is essentially a more advanced and flexible version of the
    traditional wait-notify object mechanism.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a Java code example demonstrating the use of `ReentrantLock`
    with a condition object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, the `PrinterManager` class includes a condition object, `readyCondition`,
    created from `printerLock`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The `printDocument` method makes threads wait if the printer is not ready (`isPrinterReady`
    is false). Threads call `await()` on `readyCondition`, which suspends them until
    they are signaled or the timeout occurs.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `makePrinterReady` method simulates an event where the printer becomes
    ready. When this method is called, it changes the `isPrinterReady` flag to true
    and calls `signal()` on `readyCondition` to wake up one waiting thread.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` method simulates the scenario where the printer becomes ready after
    a delay, and multiple worker threads are trying to use the printer.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assumes a simplistic representation of a printer using a Boolean variable
    (`isPrinterReady`). In reality, you would need to integrate with the actual printer’s
    API, library, or driver to communicate with the printer and determine its readiness
    state.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provided code is a simplified example to demonstrate the concept of thread
    synchronization and waiting for a condition (in this case, the printer being ready)
    using locks and conditions in Java. While it illustrates the basic principles,
    it may not be directly applicable to a real-world scenario without further modifications
    and enhancements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and applying these advanced locking techniques, you can enhance
    the performance and reliability of your Java applications. Each technique serves
    a specific purpose and choosing the right one depends on the specific requirements
    and characteristics of your application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of Java’s advanced locking techniques, we delve deeper into the
    mechanics and use cases of tools such as `ReentrantLock`, `ReadWriteLock`, and
    `StampedLock`. For instance, `ReentrantLock` offers a higher level of control
    compared to intrinsic locks, with features such as fairness policies and the ability
    to interrupt lock waiting threads. Consider a scenario where multiple threads
    are competing to access a shared database. Here, `ReentrantLock` with a fairness
    policy ensures that threads gain database access in the order they requested it,
    preventing resource hogging and enhancing system fairness.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `ReadWriteLock` splits the lock into two parts: a read lock and
    a write lock. This separation allows multiple threads to read data simultaneously,
    but only one thread can write at a time, thereby increasing read efficiency in
    scenarios where write operations are less frequent, such as in caching systems.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`StampedLock`, on the other hand, provides lock modes that support both read
    and write locks and also offers a method for lock conversion. Imagine a navigation
    application where map data is read frequently but updated less often. `StampedLock`
    can initially grant a read lock to display the map and then convert it to a write
    lock when an update is needed, minimizing the time during which other threads
    are prevented from reading the map.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore some common pitfalls to avoid.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and preventing deadlocks in multi-threaded applications
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we explore the bustling kitchen of Java concurrency, where threads work like
    sous chefs in a harmonious rhythm, we come across a notorious kitchen hitch –
    the **deadlock**. Much like sous chefs vying for the same kitchen appliance, threads
    in Java can find themselves in a deadlock when they wait on each other to relinquish
    shared resources. Preventing such deadlocks is vital to ensure that our multi-threaded
    applications, akin to our kitchen operations, continue to run smoothly without
    any disruptive standstills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent deadlocks, we can employ several strategies:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid circular wait**: We can design our application to prevent the circular
    chain of dependencies. One way is to impose a strict order in which locks are
    acquired.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize hold and wait**: Try to ensure that a thread requests all the required
    resources at once, rather than acquiring one and waiting for others.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource allocation graphs**: Use these graphs to detect the possibility
    of deadlocks in the system.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeouts**: Implementing timeouts can be a simple yet effective way. If a
    thread cannot acquire all its resources within a given timeframe, it releases
    the acquired resources and retries later.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread dump analysis**: Regularly analyze thread dumps for signs of potential
    deadlocks.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After delving into the theoretical aspects of locking mechanisms in cloud environments,
    we shift gears to practical application. In this next section, we dive into hands-on
    activities focused on deadlocks, a pivotal challenge in concurrent programming.
    This hands-on approach aims not just to understand but to develop efficient Java
    applications in the face of these complex issues.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on activity – deadlock detection and resolution
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We simulate a real-world scenario involving two processes trying to access two
    database tables. We’ll represent the tables as shared resources and the processes
    as threads. Each thread will try to lock both tables to perform some operations.
    We’ll then demonstrate a deadlock and refactor the code to resolve it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a Java program that simulates a deadlock when two threads
    try to access two tables (resources):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, each thread (representing a Lambda function) tries to lock two
    resources (`Item1Lock` and `Item2Lock`) in a nested manner. However, each thread
    locks one resource and then attempts to lock the other resource that may already
    be locked by the other thread. This scenario creates a deadlock situation because
    of the following reasons:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '`lambdaFunction1` locks `Item1` and waits to lock `Item2`, which might already
    be locked by `Lambda` `Function 2`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambdaFunction2` locks `Item2` and waits to lock `Item1`, which might already
    be locked by `Lambda` `Function 1`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Lambda functions end up waiting indefinitely for the other to release the
    lock, causing a deadlock
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.sleep(100)` in each thread is crucial as it simulates a delay, allowing
    time for the other thread to acquire a lock on the other resource, thus increasing
    the likelihood of a deadlock'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example illustrates a basic deadlock scenario in a concurrent environment,
    similar to what might occur in distributed systems involving multiple resources.
    To resolve the deadlock, we ensure that both threads acquire locks in a consistent
    order; it prevents a situation where each thread holds one lock and waits for
    the other. Let us look at this refactoring code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both `lambdaFunction1` and `lambdaFunction2` now acquire the locks in the same
    order, first `Item1Lock` and then `Item2Lock`. By ensuring that both threads acquire
    locks in a consistent order, we prevent a situation where each thread holds one
    lock and waits for the other. This eliminates the deadlock condition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another real-world scenario where two processes are waiting for
    file access, we can simulate file operations using locks. Each process will try
    to lock a file (represented as `ReentrantLock`) for exclusive access.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate this scenario:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code demonstrates a technique for detecting and preventing deadlocks when
    working with concurrent processes that require access to shared resources – in
    this case, two files represented by `ReentrantLock`. Let’s break down how the
    deadlock occurs and how it is prevented:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '`fileLock1` and `fileLock2` are `ReentrantLock` objects that simulate locks
    on two shared files.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process1` and `process2`), each trying to access both files. However, they
    attempt to acquire the locks in opposite orders. `process1` tries to lock `fileLock1`
    first, then `fileLock2`; `process2` does the opposite.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`process1` locks `fileLock1` and `process2` locks `fileLock2` at the same time,
    they will each wait indefinitely for the other lock to be released, creating a
    deadlock situation.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acquireFileLocksWithTimeout` method attempts to acquire each lock with a timeout
    (`tryLock(1000`, `TimeUnit.MILLISECONDS)`). This timeout prevents a process from
    waiting indefinitely for a lock, reducing the chance of a deadlock.*   `Thread.sleep(2000)`)
    and checks whether both processes are still active. If they are, it suspects a
    deadlock and interrupts one of the processes (`process2.interrupt()`), helping
    to recover from the deadlock situation.*   `InterruptedException`, the program
    checks whether the current thread holds either lock and, if so, releases it. This
    ensures that resources are not left in a locked state, which could perpetuate
    the deadlock.*   `acquireFileLocksWithTimeout` method guarantees that both locks
    are released, even if an exception occurs or the thread is interrupted. This is
    crucial for preventing deadlocks and ensuring resource availability for other
    processes.*   **Key takeaways**:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deadlock detection**: The program actively checks for deadlock conditions
    and takes measures to resolve them'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management**: Careful management of lock acquisition and release
    is essential in concurrent programming to avoid deadlocks'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeouts as a preventive measure**: Using timeouts when attempting to acquire
    locks can prevent processes from being indefinitely blocked'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach demonstrates effective strategies for handling potential deadlocks
    in concurrent processes, especially when dealing with shared resources such as
    files or database connections in a multi-threaded environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In our culinary world of Java concurrency, deadlocks are like kitchen gridlocks
    where sous chefs find themselves stuck, unable to access the tools they need because
    another chef is using them. Mastering the art of preventing these kitchen standstills
    is a crucial skill for any adept Java developer. By understanding and applying
    strategies to avoid these deadlocks, we ensure that our multi-threaded applications,
    much like a well-organized kitchen, operate smoothly, deftly handling the intricate
    dance of concurrent tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss task management and data sharing in concurrency in Java;
    it involves understanding how to effectively handle asynchronous tasks and ensuring
    data integrity across concurrent operations. Let’s delve into this topic.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Employing Future and Callable for result-bearing task execution
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, Future and Callable are used together to execute tasks asynchronously
    and obtain results at a later point in time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`call()`: This method encapsulates the task’s logic and returns the result'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: This method retrieves the result, blocking if necessary until completion*   `isDone()`:
    This method checks whether the task is finished*   `ExecutorService` accepts Callables,
    returning Futures for tracking completion and results'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of Callable and Future interfaces:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Callable interface defines the task that produces a result. The Future interface
    acts as a handle for managing and retrieving that result, enabling asynchronous
    coordination and result-bearing task execution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points in this code are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous execution**: Callable and Future enable the task to execute
    independently of the main thread, potentially improving performance'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result retrieval**: The Future object allows the main thread to retrieve
    the task’s result when it becomes available, ensuring synchronization'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible coordination**: Futures can be used for dependency management and
    creating complex asynchronous workflows'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe data sharing between concurrent tasks
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutable data and thread-local storage are fundamental concepts for concurrency
    and can greatly simplify thread-safe programming. Let’s explore them in detail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Immutable data** is a fundamental concept where an object’s state cannot
    be changed once it is created. Any attempt to modify such objects results in the
    creation of new ones, leaving the original untouched. This is in stark contrast
    to **mutable data**, where the state of an object can be directly altered after
    its creation.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Its benefits are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**It eliminates the need for synchronization**: When immutable data is shared
    across threads, there is no need for synchronization mechanisms such as locks
    or semaphores'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhances thread safety**: Immutability by its very nature guarantees thread-safe
    operations'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplifies reasoning**: With immutability, there’s no concern about unexpected
    changes from other threads, making the code more predictable and easier to debug'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of immutable data types are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings**: In Java, string objects are immutable'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boxed primitives**: These include integers and Boolean'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate` in Java 8'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Final classes with immutable fields**: Custom classes designed to be immutable'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: Often used in functional programming languages. Tuples are data
    structures that store a fixed set of elements where each element can be of a different
    type. Tuples are immutable, meaning that once created, the values inside them
    cannot be changed. While Java does not have a built-in tuple class like some other
    languages (Python, for instance), you can simulate tuples using custom classes
    or available classes from libraries.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example of how you might create and use a tuple-like structure
    in Java:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let us now explore thread local storage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Thread local storage** or **TLS** is a method of storing data that is local
    to a thread. In this model, each thread has its own separate storage, which is
    not accessible to other threads.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Its benefits are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplifies data sharing**: TLS provides a straightforward approach to storing
    data specific to each thread, and each thread can access its data independently
    without the need for coordination'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduces contention**: By keeping data separate for each thread, TLS minimizes
    potential conflicts and bottlenecks'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improves maintainability**: Code that utilizes TLS is often clearer and easier
    to understand'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of using TLS are discussed in the following points:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**User session management**: In web applications, storing user-specific data
    such as sessions'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Counters or temporary variables**: Keeping track of thread-specific computations'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Storing frequently used, thread-specific data for performance
    optimization'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While both immutable data and TLS contribute significantly to thread safety
    and simplify concurrency management, they serve different purposes and scenarios:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**: Immutable data ensures consistency and safety of the data itself
    across multiple threads. In contrast, TLS is about providing a separate data storage
    space for each thread.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use cases**: Use immutable data for shared structures and values that are
    read-only. TLS is ideal for managing data that is specific to each thread and
    not meant for cross-thread sharing.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between immutable data and TLS should be based on the specific requirements
    of your application and the nature of the data access patterns involved. Leveraging
    both immutable data and TLS can further enhance the safety and simplicity of your
    concurrent systems, harnessing the strengths of each approach.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging thread-safe collections to mitigate concurrency issues
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having already explored the basics of concurrent collections and atomic variables,
    let’s focus on advanced strategies for utilizing these thread-safe collections
    to further mitigate concurrency issues in Java.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advanced uses of concurrent collections:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap`: Ideal for scenarios with a high volume of concurrent read
    and write operations. Utilize its advanced functions such as `computeIfAbsent`
    for atomic operations combining checking and adding elements.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentLinkedQueue`: Best for queue-based data processing models, especially
    in producer-consumer patterns. Its non-blocking nature is essential for high-throughput
    scenarios.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CopyOnWriteArrayList`: Use when the list is largely read-only but needs occasional
    modifications. Its iterator provides a stable snapshot view, making it reliable
    for iterations even when concurrent modifications occur.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap`. This combination can lead to highly efficient parallel
    algorithms.*   `ConcurrentHashMap` and performing multiple related operations
    that need to be atomic as a whole.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the advantages of atomic variables in addition to their basic
    use cases:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`updateAndGet` or `accumulateAndGet` in `AtomicInteger` or `AtomicLong`, which
    allow complex calculations in a single atomic step.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AtomicInteger` are guaranteed to have immediate visibility to other threads,
    which is crucial for ensuring up-to-date data visibility.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between concurrent collections and atomic variables
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding when to choose concurrent collections and when to use atomic
    variables is crucial for developing efficient, robust, and thread-safe Java applications.
    This knowledge allows you to tailor your choice of data structures and synchronization
    mechanisms to the specific needs and characteristics of your application. Making
    the right choice between these two options can significantly impact the performance,
    scalability, and reliability of your concurrent applications. This section delves
    into the considerations for selecting between concurrent collections, which are
    ideal for complex data structures, and atomic variables, which are best suited
    for simpler, single-value scenarios:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**Data complexity**: Choose concurrent collections for managing complex data
    structures with multiple elements and relationships. Use atomic variables when
    dealing with single values requiring atomic operations without the overhead of
    a full collection structure.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap` has excellent scalability for concurrent access, whereas
    atomic variables are lightweight and efficient for simpler use cases.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By deepening your understanding of when and how to use these advanced features
    of thread-safe collections and atomic variables, you can optimize your Java applications
    for concurrency, ensuring both data integrity and exceptional performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent best practices for robust applications
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While [*Chapter 5*](B20937_05.xhtml#_idTextAnchor131), *Mastering Concurrency
    Patterns in Cloud Computing*, of our book delves into Java concurrency patterns
    specifically tailored for cloud environments, it is crucial to lay the groundwork
    with some best practices and general strategies for concurrent programming.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practices in concurrent programming include the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**Master concurrency primitives**: Master the basics of concurrency primitives
    in Java, such as synchronized, volatile, lock, and condition. Understanding their
    semantics and usage is crucial for writing correct concurrent code.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Minimize shared state**: Limit the amount of shared state between threads.
    The more data shared, the higher the complexity and potential for concurrency
    issues. Aim for immutability where feasible.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InterruptedException`, restore the interrupt status by calling `Thread.currentThread().interrupt()`.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExecutorService`, `CountDownLatch`, and `CyclicBarrier` to manage threads
    and synchronization.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AtomicInteger`, can be more scalable than lock-based approaches.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cautious with lazy initialization**: Lazy initialization in a concurrent
    setting can be tricky. Double-checked locking with a volatile variable is a common
    pattern but requires careful implementation to be correct.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test concurrency thoroughly**: Concurrent code should be rigorously tested
    under conditions that simulate real-world scenarios. This includes testing for
    thread safety, potential deadlocks, and race conditions.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document concurrency assumptions**: Clearly document the assumptions and
    design decisions related to concurrency in your code. This helps maintainers understand
    the concurrency strategies employed.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize thread allocation**: Balance the number of threads with the workload
    and the system’s capabilities. Overloading a system with too many threads can
    lead to performance degradation due to excessive context switching.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor and tune performance**: Regularly monitor the performance of your
    concurrent applications and tune parameters such as thread pool sizes or task
    partitioning strategies for optimal results.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid blocking threads unnecessarily**: Design tasks and algorithms to avoid
    keeping threads in a blocked state unnecessarily. Utilize concurrent algorithms
    and data structures that allow threads to progress independently.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These best practices form the bedrock of robust, efficient, and maintainable
    concurrent applications, irrespective of their specific domain, such as cloud
    computing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048), let’s reflect
    on the essential concepts and best practices we’ve uncovered in our exploration
    of Java’s concurrency. This summary, akin to a chef’s final review of a successful
    banquet, will encapsulate the crucial learnings and strategies for effective concurrent
    programming in Java.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We learned about threads and processes. Threads, like nimble sous chefs, are
    the fundamental units of execution, working in shared environments (kitchens).
    Processes are like independent kitchens, each with its resources, operating in
    isolation. We journeyed through a thread’s life cycle, from creation to termination,
    highlighting the critical stages and how they are managed within the Java environment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Like coordinating a team of chefs, we’ve explored various synchronization techniques
    and locking mechanisms essential for managing access to shared resources and preventing
    conflicts. Next, we tackled the challenge of deadlocks, understanding how to detect
    and resolve these standstills in concurrent programming, much like resolving bottlenecks
    in a busy kitchen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delved into advanced tools such as `StampedLock` and condition objects.
    We equipped you with sophisticated methods for specific concurrency scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: A pivotal part of this chapter was the discussion on concurrent best practices
    for robust applications. We discussed best practices in concurrent programming.
    These practices are akin to the golden rules in a professional kitchen, ensuring
    efficiency, safety, and quality. We emphasized the importance of understanding
    concurrency patterns, proper resource management, and the judicious use of synchronization
    techniques to build robust and resilient Java applications.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, through hands-on activities and real-world examples, we’ve seen how
    to apply these concepts and practices, enhancing our understanding of when and
    how to utilize different synchronization strategies and locking mechanisms effectively.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave you the tools and best practices to conquer concurrency’s
    complexities. You’re now primed to design robust, scalable applications that thrive
    in the multi-threaded world. However, our culinary journey isn’t over! In [*Chapter
    3*](B20937_03.xhtml#_idTextAnchor077), *Mastering Parallelism in Java*, we ascend
    to the grand hall of **parallel processing**, where we’ll learn to harness multiple
    cores for even more potent Java magic. Prepare to leverage your concurrency expertise
    as we unlock the true power of parallel programming.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the primary difference between threads and processes in Java’s concurrency
    model?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Threads and processes are essentially the same.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Threads are independent, while processes share a memory space.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Threads share a memory space, while processes are independent and have their
    own memory.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Processes are used only in web applications, while threads are used in desktop
    applications.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the `java.util.concurrent` package in Java?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides tools for building graphical user interfaces.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It offers a set of classes and interfaces for managing threads and processes
    efficiently.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is used exclusively for database connectivity.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It enhances the security features of Java applications.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which scenario best illustrates the use of `ReadWriteLock` in Java?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing user sessions in a web application.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowing multiple threads to read a resource concurrently but requiring exclusive
    access for writing.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypting sensitive data before sending it over a network.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Serializing objects for saving the state of an application.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `CountDownLatch` in Java’s concurrency model function?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It dynamically adjusts the priority of thread execution.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows a set of threads to wait for a series of events to occur.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a mechanism for threads to exchange data.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is used for automatic memory management in multi-threaded applications.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main advantage of using `AtomicInteger` over traditional synchronization
    techniques in Java?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It offers enhanced security features for web applications.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows for lock-free thread-safe operations on a single integer value.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is used for managing database transactions.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a framework for building graphical user interfaces.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
