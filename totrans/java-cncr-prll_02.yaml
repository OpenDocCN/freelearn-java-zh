- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: 'Introduction to Java’s Concurrency Foundations: Threads, Processes, and Beyond'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发基础简介：线程、进程及其他
- en: Welcome to [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048), where we embark
    on a culinary-inspired exploration of Java’s concurrency model, likening it to
    a bustling kitchen. In this dynamic environment, **threads** are akin to nimble
    sous chefs, each skillfully managing their specific tasks with speed and precision.
    They work in unison, seamlessly sharing the kitchen space and resources. Imagine
    each thread whisking through their assigned recipes, contributing to the overall
    culinary process in a synchronized dance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第二章*](B20937_02.xhtml#_idTextAnchor048)，在这里我们将开始一次以烹饪为灵感的Java并发模型探索，将其比作一个繁忙的厨房。在这个动态环境中，**线程**就像敏捷的主厨，每个都熟练地以速度和精度管理自己的特定任务。他们协同工作，无缝地共享厨房空间和资源。想象一下每个线程都在他们的指定食谱中快速搅拌，通过同步的舞蹈为整个烹饪过程做出贡献。
- en: On the other hand, processes are comparable to larger, independent kitchens,
    each equipped with their unique menus and resources. These processes operate autonomously,
    handling complex tasks in their self-contained domains without the interference
    of neighboring kitchens.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，进程可以比作更大、独立的厨房，每个都配备了独特的菜单和资源。这些进程独立运行，在其自包含的领域中处理复杂任务，而不受邻近厨房的干扰。
- en: In this chapter, we delve into the nuances of these two essential components
    of Java’s concurrency. We’ll explore the life cycle of a thread and understand
    how it wakes up, performs its duties, and eventually rests. Similarly, we’ll examine
    the independent freedom and resource management of processes. Our journey will
    also take us through the `java.util.concurrent` package, a well-stocked pantry
    of tools designed for orchestrating threads and processes with efficiency and
    harmony. By the end of this chapter, you’ll gain a solid understanding of how
    to manage these concurrent elements, enabling you to build robust and efficient
    Java applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Java并发这两个基本组件的细微差别。我们将研究线程的生命周期，了解它是如何醒来、执行其职责，并最终休息的。同样，我们将检查进程的独立自由和资源管理。我们的旅程还将带我们了解`java.util.concurrent`包，这是一个为高效和和谐地编排线程和进程而设计的工具丰富的储藏室。到本章结束时，你将获得如何管理这些并发元素的良好理解，这将使你能够构建健壮和高效的Java应用程序。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You need to install a Java **integrated development environment** (**IDE**)
    on your laptop. Here are a few Java IDEs and their download URLs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的笔记本电脑上安装一个Java **集成开发环境**（**IDE**）。以下是一些Java IDE及其下载链接：
- en: '**IntelliJ IDEA**:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA**：'
- en: '**Download** **URL**: [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载链接**：[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)'
- en: '**Pricing**: Free Community Edition with limited features, Ultimate Edition
    with full features requires a subscription'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价**：免费社区版，功能有限，完整功能的终极版需要订阅'
- en: '**Eclipse IDE**:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse IDE**：'
- en: '**Download** **URL**: [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载链接**：[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)'
- en: '**Pricing**: Free and open source'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价**：免费和开源'
- en: '**Apache NetBeans**:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache NetBeans**：'
- en: '**Download URL**:[https://netbeans.apache.org/front/main/download/index.html](https://netbeans.apache.org/front/main/download/index.html)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载链接**：[https://netbeans.apache.org/front/main/download/index.html](https://netbeans.apache.org/front/main/download/index.html)'
- en: '**Pricing**: Free and open source'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价**：免费和开源'
- en: '**Visual Studio Code (****VS Code)**:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code (VS Code)**：'
- en: '**Download** **URL**: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载链接**：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
- en: '**Pricing**: Free and open source'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价**：免费和开源'
- en: VS Code offers a lightweight and customizable alternative to the other options
    on this list. It’s a great choice for developers who prefer a less resource-intensive
    IDE and want the flexibility to install extensions tailored to their specific
    needs. However, it may not have all the features out of the box compared to the
    more established Java IDEs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code提供了对列表中其他选项的轻量级和可定制的替代方案。它是那些更喜欢资源消耗较少的IDE并希望安装针对其特定需求的扩展的开发者的绝佳选择。然而，与更成熟的Java
    IDE相比，它可能没有所有开箱即用的功能。
- en: 'Further, the code in this chapter can be found on GitHub:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism](https://github.com/PacktPublishing/Java-Concurrency-and-Parallelism)'
- en: Java’s kitchen of concurrency – unveiling threads and processes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java的并发厨房——揭示线程和进程
- en: Mastering Java’s concurrency tools, threads and processes, is akin to acquiring
    the skills of a culinary master. This section equips you with the knowledge to
    design efficient and responsive Java applications, ensuring your programs run
    smoothly even when juggling multiple tasks like a Michelin-starred kitchen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握Java的并发工具——线程和进程，就像获得了一位烹饪大师的技能。本节将为您提供设计高效且响应迅速的Java应用程序的知识，确保您的程序即使在处理多个任务时也能平稳运行，就像一位米其林星级厨房的厨师一样。
- en: What are threads and processes?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和进程是什么？
- en: In the realm of Java concurrency, **threads** are like sous chefs in a kitchen.
    Each sous chef (thread) is assigned a particular task, working diligently to contribute
    to the overall meal preparation. Just as sous chefs share a common kitchen space
    and resources, threads operate in parallel within the same Java process, sharing
    memory and resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java并发的领域，**线程**就像厨房中的副厨师。每位副厨师（线程）被分配了特定的任务，勤奋地工作以贡献于整体餐点的准备。正如副厨师共享共同的厨房空间和资源一样，线程在同一个Java进程中并行操作，共享内存和资源。
- en: Now, picture a large restaurant with separate kitchens for different specialties,
    such as a pizza oven room, a pastry department, and a main course kitchen. Each
    of these is a **process**. Unlike threads that share a single kitchen, processes
    have their own dedicated resources and operate independently. They’re like separate
    restaurants, ensuring that complex dishes such as intricate pastries get the dedicated
    attention they deserve, without interfering with the main course preparation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一家大型餐厅，拥有为不同特色菜系而设的独立厨房，例如比萨烤箱房、糕点部门和主菜厨房。这些每个都是**进程**。与共享单个厨房的线程不同，进程拥有自己的专用资源和独立运作。它们就像独立的餐厅，确保复杂的菜肴，如精致的糕点，能够得到应有的专注，而不会干扰主菜的准备工作。
- en: In essence, threads are like nimble sous chefs sharing the kitchen, while processes
    are like independent restaurant kitchens with dedicated chefs and resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，线程就像敏捷的副厨师共享厨房，而进程则像拥有专用厨师和资源的独立餐厅厨房。
- en: Similarities and differences
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相似之处与不同之处
- en: Imagine our bustling restaurant kitchen once again, this time buzzing with both
    threads and processes. While they both contribute to a smooth culinary operation,
    they do so in distinct ways, like skilled chefs with different specialties. Let’s
    dive into their similarities and differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们繁忙的餐厅厨房再次热闹起来，这次是线程和进程同时忙碌。虽然它们都为流畅的烹饪操作做出了贡献，但它们以不同的方式做到这一点，就像拥有不同专长的熟练厨师。让我们深入了解它们的相似之处和不同之处。
- en: 'Both threads and processes share the following similarities:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程有以下相似之处：
- en: '**Multitasking masters**: Both threads and processes allow Java applications
    to handle multiple tasks concurrently. Imagine serving multiple tables simultaneously,
    with no single dish left waiting.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多任务大师**：线程和进程都允许Java应用程序同时处理多个任务。想象一下同时服务多张餐桌，没有一道菜会等待。'
- en: '**Resource sharing**: Both threads within a process and processes themselves
    can share resources, such as files or databases, depending on their configuration.
    This allows for efficient data access and collaboration.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源共享**：进程内的线程和进程本身可以根据其配置共享资源，如文件或数据库。这允许高效的数据访问和协作。'
- en: '**Independent execution**: Both threads and processes have their own independent
    execution paths, meaning they can run their own instructions without interrupting
    each other. Think of separate chefs working on different dishes, each following
    their own recipe.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立执行**：线程和进程都有自己的独立执行路径，这意味着它们可以运行自己的指令而不会相互干扰。想象一下不同的厨师在准备不同的菜肴，每个厨师都遵循自己的食谱。'
- en: 'Threads and processes are different in the following areas:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程在以下方面有所不同：
- en: '**Scope**: Threads exist within a single process, sharing their memory space
    and resources like ingredients and cooking tools. Processes, on the other hand,
    are completely independent, each with its own isolated kitchen and resources.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：线程存在于单个进程中，共享它们的内存空间和资源，如原料和烹饪工具。另一方面，进程是完全独立的，每个进程都有自己的独立厨房和资源。'
- en: '**Isolation**: Threads share the same memory space, making them susceptible
    to interference and data corruption. Processes, with their separate kitchens,
    offer greater isolation and security, preventing accidental contamination and
    protecting sensitive data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：线程共享相同的内存空间，这使得它们容易受到干扰和数据损坏的影响。进程，由于它们有各自的厨房，提供了更大的隔离性和安全性，防止意外污染并保护敏感数据。'
- en: '**Creation and management**: Creating and managing threads is simpler and more
    lightweight within a process. Processes, as independent entities, require more
    system resources and are more complex to control.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和管理**：在进程内部创建和管理线程更为简单和轻量级。进程作为独立的实体，需要更多的系统资源，并且更难以控制。'
- en: '**Performance**: Threads offer finer-grained control and can be switched quickly,
    potentially faster execution for smaller tasks. Processes, with their separate
    resources, can be more efficient for larger, independent workloads.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：线程提供了更细粒度的控制，并且可以快速切换，对于较小的任务可能具有更快的执行速度。进程，由于它们有独立的资源，对于较大的、独立的工作负载可能更有效率。'
- en: Both threads and processes are valuable tools in the Java chef’s toolbox, each
    fulfilling specific needs. By understanding their similarities and differences,
    we can choose the right approach to create culinary masterpieces or, rather, masterful
    Java applications!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程都是Java厨师工具箱中的宝贵工具，各自满足特定的需求。通过理解它们的相似之处和不同之处，我们可以选择正确的方法来创建烹饪杰作，或者说，是精湛的Java应用程序！
- en: The life cycle of threads in Java
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java中线程的生命周期
- en: 'In exploring the life cycle of a thread, akin to the work shift of a sous chef
    in our kitchen metaphor, we focus on the pivotal stages that define a thread’s
    existence within a Java application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索线程的生命周期时，类似于我们厨房比喻中的副厨师的工作班次，我们关注定义线程在Java应用程序中存在的关键阶段：
- en: '**New state**: When a thread is created using the new keyword or by extending
    the Thread class, it enters the **new state**. It is akin to a sous chef arriving
    at the kitchen, ready but not yet engaged in cooking.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新状态**：当使用 `new` 关键字或通过扩展 Thread 类创建线程时，它进入 **新状态**。这就像副厨师到达厨房，准备就绪但尚未开始烹饪。'
- en: '`start()` method is called. Here, it’s akin to the sous chef prepped and waiting
    for their turn to cook. The thread scheduler decides when to allocate **central
    processing unit** (**CPU**) time to the thread, based on thread priorities and
    system policies.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `start()` 方法。在这里，它相当于副厨师准备就绪，等待轮到他们烹饪。线程调度器根据线程优先级和系统策略决定何时分配 **中央处理单元**
    (**CPU**) 时间给线程。
- en: '`run()` method. This is similar to the sous chef actively working on their
    assigned tasks in the kitchen. At any given moment, only one thread can be in
    the Running state on a single processor core.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()` 方法。这类似于副厨师在厨房中积极完成分配的任务。在任何给定时刻，单个处理器核心上只能有一个线程处于运行状态。'
- en: '`wait()`, `join()`, or `sleep()` methods.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`、`join()` 或 `sleep()` 方法。'
- en: '`sleep(long milliseconds)` or `wait(long milliseconds)`. This is comparable
    to a sous chef taking a scheduled break during their shift, knowing they will
    resume work after a certain time has elapsed.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep(long milliseconds)` 或 `wait(long milliseconds)`。这相当于副厨师在班次中安排休息，知道在经过一段时间后会继续工作。'
- en: '`run()` method or is interrupted using the `interrupt()` method. This is comparable
    to a sous chef finishing their tasks and ending their shift. Once terminated,
    a thread cannot be restarted.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `run()` 方法或通过 `interrupt()` 方法中断。这相当于副厨师完成他们的任务并结束班次。一旦终止，线程无法重新启动。
- en: This life cycle is crucial to understanding how threads are managed within a
    Java program. It dictates how threads are born (created), run (`start()` and `run()`),
    pause (`wait(), join(), sleep()`), wait with a timeout (`sleep(long)`, `wait(long)`),
    and ultimately end their execution (completing `run()` or being interrupted).
    Understanding these key methods and their impact on thread states is essential
    for effective concurrent programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生命周期对于理解Java程序中线程的管理至关重要。它决定了线程是如何诞生的（创建）、运行（`start()` 和 `run()`）、暂停（`wait()`、`join()`、`sleep()`）、带超时的等待（`sleep(long)`、`wait(long)`），以及最终结束它们的执行（完成
    `run()` 或被中断）。理解这些关键方法和它们对线程状态的影响对于有效的并发编程至关重要。
- en: Now, let’s take this knowledge to the real world and explore how threads are
    used in everyday Java applications!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这一知识应用到现实世界中，探索线程在日常Java应用程序中的使用方式！
- en: Activity – differentiating threads and processes in a practical scenario
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动性 - 在实际场景中区分线程和进程
- en: 'In the vibrant kitchen of Java concurrency, the following Java code demonstrates
    how threads (chefs) perform tasks (preparing dishes) within a process (the kitchen).
    This analogy will help illustrate the concepts of thread and process in a real-world
    scenario:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在充满活力的Java并发厨房中，以下Java代码演示了线程（厨师）如何在进程（厨房）中执行任务（准备菜肴）。这个类比将有助于在现实场景中说明线程和进程的概念：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a breakdown of the roles of threads in the preceding Java code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面Java代码中线程作用的分解：
- en: '`ExecutorService` kitchen creates a pool of three threads to simulate three
    chefs working concurrently.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`厨房创建了一个包含三个线程的线程池来模拟三个厨师同时工作。'
- en: '`submit()` method assigns tasks (preparing a dish, searching for recipes, updating
    the menu) to individual threads within the pool.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`方法将任务（准备菜肴、寻找食谱、更新菜单）分配给池中的各个线程。'
- en: '**Concurrent execution**: Threads enable these tasks to run simultaneously,
    potentially improving performance and responsiveness.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发执行**：线程使得这些任务可以同时运行，可能提高性能和响应速度。'
- en: '`Thread.sleep(1000)`. This simulates the time taken by the chef to perform
    the task. During this sleep period, other threads can continue their execution,
    demonstrating the concurrent nature of the program.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.sleep(1000)`。这模拟了厨师完成任务所需的时间。在这段睡眠期间，其他线程可以继续执行，展示了程序的并发特性。'
- en: '`Thread.sleep()` can throw `InterruptedException`, each task is wrapped in
    a try-catch block. If an interruption occurs during sleep, the exception is caught,
    and the thread’s interrupted status is restored using `Thread.currentThread().interrupt()`.
    This ensures proper handling of interruptions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.sleep()`可能会抛出`InterruptedException`，每个任务都被包裹在try-catch块中。如果在睡眠期间发生中断，异常将被捕获，并使用`Thread.currentThread().interrupt()`恢复线程的中断状态。这确保了中断的正确处理。'
- en: 'The following points present a discussion on the roles of processes in the
    preceding Java code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点讨论了在前面Java代码中进程的作用：
- en: '**Java runtime**: The entire Java program, including the kitchen simulation,
    runs within a single operating system process'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java运行时**：整个Java程序，包括厨房模拟，都在单个操作系统进程中运行'
- en: '**Resource allocation**: The process has its own memory space, allocated by
    the operating system, to manage variables, objects, and code execution'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：进程有自己的内存空间，由操作系统分配，用于管理变量、对象和代码执行'
- en: '**Environment**: It provides the environment for threads to exist and operate
    within'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：它为线程提供存在的环境并在其中操作'
- en: 'The key takeaways from the code example we just saw are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码示例的关键要点如下：
- en: '**Threads within a process**: Threads are lightweight execution units that
    share the same process’s memory and resources'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程内的线程**：线程是轻量级的执行单元，它们共享相同进程的内存和资源'
- en: '**Concurrency**: Threads enable multiple tasks to be executed concurrently
    within a single process, taking advantage of multiple CPU cores if available'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：线程使得多个任务可以在单个进程中并发执行，如果可用，可以利用多个CPU核心'
- en: '**Process management**: The operating system manages processes, allocating
    resources and scheduling their execution'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程管理**：操作系统管理进程，分配资源并调度它们的执行'
- en: 'Now, let’s shift gears and explore the tools that unlock their full potential:
    the `java.util.concurrent` package. This treasure trove of classes and interfaces
    provides the building blocks for crafting robust and efficient concurrent programs,
    ready to tackle any multitasking challenge your Java app throws at them!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换一下思路，探索解锁它们全部潜能的工具：`java.util.concurrent`包。这个类和接口的宝库为构建健壮和高效的并发程序提供了构建块，随时准备应对Java应用程序抛出的任何多任务挑战！
- en: The concurrency toolkit – java.util.concurrent
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发工具包——java.util.concurrent
- en: Think of your Java application as a bustling restaurant. Orders stream in, ingredients
    need prepping, and dishes must be cooked and delivered seamlessly. Now, imagine
    managing this chaos without efficient systems – it’s a recipe for disaster! Fortunately,
    the `java.util.concurrent` package acts as your restaurant’s high-tech equipment,
    streamlining operations and preventing chaos. With sophisticated tools such as
    thread pools for managing chefs (threads), locks and queues for coordinating tasks,
    and powerful concurrency utilities, you can orchestrate your Java application
    like a Michelin-starred chef. So, dive into this toolkit and unlock the secrets
    of building smooth, responsive, and efficient Java programs that truly wow your
    users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的Java应用程序想象成一个繁忙的餐厅。订单源源不断地涌入，食材需要准备，菜肴必须无缝烹饪和送达。现在，想象一下在没有高效系统管理这种混乱的情况下——那是一场灾难！幸运的是，`java.util.concurrent`包充当您餐厅的高科技设备，简化操作并防止混乱。有了诸如线程池管理厨师（线程）、锁和队列协调任务以及强大的并发实用工具等复杂工具，您可以像米其林星级厨师一样编排您的Java应用程序。所以，深入这个工具包，揭开构建平滑、响应迅速且高效的Java程序的秘密，真正让您的用户惊叹。
- en: Let’s take a glimpse at the key elements within this package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一瞥这个包内的关键元素。
- en: Threads and executors
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和执行器
- en: 'Both `ExecutorService` and `ThreadPoolExecutor` play crucial roles in orchestrating
    concurrent tasks:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService` 和 `ThreadPoolExecutor` 在编排并发任务中扮演着至关重要的角色：'
- en: '`ExecutorService`: A versatile interface for managing thread pools:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`：一个用于管理线程池的多功能接口：'
- en: '`FixedThreadPool` for a fixed number of threads'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedThreadPool` 用于固定数量的线程'
- en: '`CachedThreadPool` for a pool that grows as needed'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CachedThreadPool` 用于按需增长的线程池'
- en: '`SingleThreadExecutor` for sequential execution'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleThreadExecutor` 用于顺序执行'
- en: '`ScheduledThreadPool` for delayed or periodic tasks'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPool` 用于延迟或周期性任务'
- en: '`ThreadPoolExecutor`: A concrete implementation of `ExecutorService`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`：`ExecutorService`的一个具体实现：'
- en: '`ExecutorService`, providing fine-grained control over thread pool behavior.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService`，提供对线程池行为的精细控制。'
- en: '**Granular control**: It allows you to customize thread pool parameters such
    as the following:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精细控制**：它允许您自定义线程池参数，如下所示：'
- en: Core pool size (initial threads)
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心池大小（初始线程数）
- en: Maximum pool size (maximum threads)
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大池大小（最大线程数）
- en: Keep-alive time (idle thread timeout)
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持活动时间（空闲线程超时）
- en: Queue capacity (waiting tasks)
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列容量（等待任务）
- en: '**Direct usage**: It involves instantiating it directly in your code. This
    approach gives you complete control over the thread pool’s behavior, as you can
    specify parameters such as core pool size, maximum pool size, keep-alive time,
    queue capacity, and thread factory. This method is suitable when you need fine-grained
    control over the thread pool characteristics. Here’s an example of direct usage:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接使用**：它涉及直接在您的代码中实例化它。这种方法让您完全控制线程池的行为，因为您可以指定核心池大小、最大池大小、保持活动时间、队列容量和线程工厂等参数。当您需要精细控制线程池特性时，此方法很适用。以下是一个直接使用的示例：'
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `ThreadPoolExecutor` is directly instantiated with specific
    parameters. It creates a thread pool with a core pool size of `2`, a maximum pool
    size of `4`, a keep-alive time of `5000` milliseconds, and a work queue capacity
    of `10` tasks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`ThreadPoolExecutor` 直接使用特定参数进行实例化。它创建了一个具有`2`个核心池大小、`4`个最大池大小、`5000`毫秒的保持活动时间和`10`个任务的工作队列容量的线程池。
- en: The code uses `IntStream.range()` and `forEach` to submit tasks to the thread
    pool. Each task prints a formatted string containing the task number, current
    pool size, and queue size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`IntStream.range()`和`forEach`将任务提交到线程池。每个任务打印一个包含任务编号、当前池大小和队列大小的格式化字符串。
- en: 'You need to select the right tool for your tasks based on the requirements.
    You may keep the following in mind:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据任务需求选择合适的工具。您可以考虑以下因素：
- en: '`ExecutorService` for most cases, benefiting from its simplicity and flexibility
    in choosing appropriate implementations'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数情况，使用`ExecutorService`，因为它简单且灵活，可以选择合适的实现
- en: '`ThreadPoolExecutor` when you need precise control over thread pool configuration
    and behavior'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要精确控制线程池配置和行为时使用`ThreadPoolExecutor`
- en: Understanding their strengths and use cases, you can expertly manage thread
    pools and unlock the full potential of concurrency in your Java projects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它们的优点和使用场景，您可以熟练地管理线程池并释放Java项目中并发的全部潜力。
- en: The next group of elements in this package is synchronization and coordination.
    Let us explore this category in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本包中的下一组元素是同步和协调。让我们在下一节中探索这个类别。
- en: Synchronization and coordination
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步和协调
- en: 'Synchronization and coordination are crucial in multi-threaded environments
    to manage shared resources and ensure thread-safe operations. Java provides several
    classes and interfaces for this purpose, each serving specific use cases in concurrent
    programming:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同步和协调在多线程环境中至关重要，用于管理共享资源并确保线程安全操作。Java为此提供了几个类和接口，每个都服务于并发编程中的特定用例：
- en: '**Lock**: A flexible interface for controlling access to shared resources:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lock**：一个用于控制对共享资源访问的灵活接口：'
- en: '**Exclusive access**: Assert fine-grained control over shared resources, ensuring
    only one thread can access a critical section of code at a time'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独占访问**：对共享资源进行细粒度控制，确保一次只有一个线程可以访问代码的关键部分'
- en: '**Use cases**: Protecting shared data structures, coordinating access to files
    or network connections, and preventing race conditions'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：保护共享数据结构，协调对文件或网络连接的访问，以及防止竞态条件'
- en: '`Semaphore`: A class for managing access to a limited pool of resources, preventing
    resource exhaustion:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`：一个用于管理对有限资源池访问的类，防止资源耗尽：'
- en: '**Resource management**: This regulates access to a pool of resources, allowing
    multiple threads to share a finite number of resources concurrently'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：这调节对资源池的访问，允许多个线程并发共享有限数量的资源'
- en: '**Use cases**: Limiting concurrent connections to a server, managing thread
    pools, and implementing producer-consumer patterns'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：限制对服务器的并发连接，管理线程池，以及实现生产者-消费者模式'
- en: '`CountDownLatch`: This is also a class in the `java.util.concurrent` package,
    which allows threads to wait for a set of operations to complete before proceeding:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`：这也是`java.util.concurrent`包中的一个类，允许线程在继续之前等待一组操作完成：'
- en: '**Task coordination**: Synchronize threads by requiring a set of tasks to complete
    before proceeding. Threads wait at the latch until a counter reaches zero.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务协调**：通过要求在继续之前完成一组任务来同步线程。线程在计数器达到零之前在闩锁上等待。'
- en: '**Use cases**: Waiting for multiple services to start before launching an application,
    ensuring initialization tasks finish before starting a main process, and managing
    test execution order.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：在启动应用程序之前等待多个服务启动，确保初始化任务在启动主过程之前完成，以及管理测试执行顺序。'
- en: '`CyclicBarrier`: This is another class in the `java.util.concurrent` package,
    used for synchronizing threads that perform interdependent tasks. Unlike `CountDownLatch`,
    `CyclicBarrier` can be reused after the waiting threads are released:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：这是`java.util.concurrent`包中的另一个类，用于同步执行相互依赖任务的线程。与`CountDownLatch`不同，`CyclicBarrier`在等待线程释放后可以被重用：'
- en: '**Barrier for synchronization**: Gather a group of threads at a common barrier
    point, allowing them to proceed only when all threads have reached that point'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步屏障**：在公共屏障点上聚集一组线程，只有当所有线程都达到该点时才允许它们继续'
- en: '**Use cases**: Dividing work among threads and then regrouping, performing
    parallel computations followed by a merge operation, and implementing rendezvous
    points'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：在多个线程中分配工作然后重新分组，执行并行计算后进行合并操作，以及实现会合点'
- en: Each of these tools serves a distinct purpose in coordinating threads and ensuring
    harmonious execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的每一个都在协调线程和确保和谐执行中发挥着独特的作用。
- en: The last group in the package is concurrent collections and atomic variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的最后一组是并发集合和原子变量。
- en: Concurrent collections and atomic variables
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发集合和原子变量
- en: Concurrent collections are designed specifically for thread-safe storage and
    retrieval of data in multi-threaded environments. Key members include `ConcurrentHashMap`,
    `ConcurrentLinkedQueue`, and `CopyOnWriteArrayList`. These collections offer thread-safe
    operations without the need for external synchronization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合是专门为多线程环境中的线程安全存储和检索数据而设计的。关键成员包括`ConcurrentHashMap`、`ConcurrentLinkedQueue`和`CopyOnWriteArrayList`。这些集合提供了线程安全操作，无需外部同步。
- en: Atomic variables provide thread-safe operations for simple variables (integers,
    longs, references), eliminating the need for explicit synchronization in many
    cases. Key members include `AtomicInteger`, `AtomicLong`, and `AtomicReference`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量为简单变量（整数、长整型、引用）提供了线程安全的操作，在许多情况下消除了显式同步的需要。关键成员包括 `AtomicInteger`、`AtomicLong`
    和 `AtomicReference`。
- en: For a more detailed discussion on the advanced uses and optimized access patterns
    of these concurrent collections, refer to the *Leveraging thread-safe collections*
    *to mitigate concurrency issues* section later in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些并发集合的高级用法和优化访问模式的更详细讨论，请参阅本章后面的 *利用线程安全集合* *减轻并发问题* 部分。
- en: Next, we will look at a code example to see how java.util.concurrent is implemented.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个代码示例，看看 `java.util.concurrent` 是如何实现的。
- en: Hands-on exercise – implementing a concurrent application using java.util.concurrent
    tools
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动手练习 - 使用 java.util.concurrent 工具实现并发应用程序
- en: For this hands-on exercise, we’ll create a simulated real-world application
    that demonstrates the use of various `java.util.concurrent` elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动手练习中，我们将创建一个模拟的真实世界应用程序，演示了各种 `java.util.concurrent` 元素的使用。
- en: 'Scenario: Our application will be a basic order processing system where orders
    are placed and processed in parallel, and various concurrent elements are utilized
    to manage synchronization, coordination, and data integrity. Here is the Java
    code example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：我们的应用程序将是一个基本的订单处理系统，其中订单并行放置和处理，并利用各种并发元素来管理同步、协调和数据完整性。以下是 Java 代码示例：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code example uses many concurrency elements such as the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例使用了许多并发元素，如下所示：
- en: '`ExecutorService` is used to handle multiple tasks (order processing) in a
    thread pool, enabling parallel execution'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService` 用于在线程池中处理多个任务（订单处理），实现并行执行'
- en: '`ConcurrentLinkedQueue` is a thread-safe queue used to hold and manage orders
    efficiently in a concurrent environment'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue` 是一个线程安全的队列，用于在并发环境中高效地持有和管理订单'
- en: '`CopyOnWriteArrayList` provides a thread-safe list implementation, suitable
    for storing processed orders where iteration is more frequent than modification'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList` 提供了一个线程安全的列表实现，适用于存储迭代频率高于修改的已处理订单'
- en: '`ConcurrentHashMap` offers a high-performance, thread-safe map to track the
    status of each order'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 提供了一个高性能、线程安全的映射，用于跟踪每个订单的状态'
- en: '`ReentrantLock` is used to ensure exclusive access to the payment processing
    section of the code, thus avoiding concurrency issues'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 用于确保对代码中支付处理部分的独占访问，从而避免并发问题'
- en: '`Semaphore` controls the number of concurrent validations, preventing resource
    exhaustion'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore` 控制并发验证的数量，防止资源耗尽'
- en: '`AtomicInteger` is a thread-safe integer, used for counting processed orders
    safely in a concurrent context'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger` 是一个线程安全的整数，用于在并发环境中安全地计数已处理的订单'
- en: Each of these classes and interfaces plays a vital role in ensuring thread safety
    and efficient concurrency management in the `OrderProcessingSystem`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类和接口在确保 `OrderProcessingSystem` 中的线程安全和高效并发管理中发挥着至关重要的作用。
- en: 'The key points we have learned are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的关键点如下：
- en: '**Efficient threading**: This uses a thread pool to handle multiple orders
    concurrently, potentially improving performance'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效线程**：这使用线程池来并发处理多个订单，可能提高性能'
- en: '**Synchronization**: This employs locks and semaphores to coordinate access
    to shared resources and critical sections, ensuring data consistency and preventing
    race conditions'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**：这通过锁和信号量来协调对共享资源和关键段的访问，确保数据一致性并防止竞态条件'
- en: '**Thread-safe data**: This manages orders and statuses with thread-safe collections
    to support concurrent access'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程安全数据**：这使用线程安全集合来管理订单和状态，以支持并发访问'
- en: '**Status tracking**: This maintains order statuses for monitoring and reporting'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态跟踪**：这维护订单状态以进行监控和报告'
- en: This example demonstrates how these concurrent utilities can be combined to
    build a multi-threaded, synchronized, and coordinated application for order processing.
    Each utility serves a specific purpose, from managing concurrent tasks to ensuring
    data integrity and synchronization among threads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本例演示了如何将这些并发实用工具组合起来构建一个用于订单处理的线程安全、同步和协调的应用程序。每个实用工具都服务于特定的目的，从管理并发任务到确保线程间的数据完整性和同步。
- en: Next, we will explore how synchronization and locking mechanisms are used in
    Java applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨同步和锁定机制在Java应用程序中的应用。
- en: Synchronization and locking mechanisms
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步和锁定机制
- en: Imagine a bakery where multiple customers place orders simultaneously. Without
    proper synchronization, two orders could be mixed up, ingredients double counted,
    or payments processed incorrectly. This is where locking steps in, acting like
    a *hold, please* sign, allowing one thread to use the oven or cash register at
    a time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个面包店，多个客户同时下订单。如果没有适当的同步，两个订单可能会混淆，成分可能会被重复计算，或者付款可能会处理错误。这就是锁定介入的地方，它就像一个“请稍等”的标志，允许一次只有一个线程使用烤箱或收银机。
- en: '**Synchronization and locking mechanisms** are the guardians of data integrity
    and application stability in concurrent environments. They prevent race conditions,
    ensure atomic operations (complete or not, never partial), and guarantee predictable
    execution order, ultimately creating a reliable and efficient multi-threaded process.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步和锁定机制**是并发环境中数据完整性和应用程序稳定性的守护者。它们防止竞争条件，确保原子操作（无论完成与否，永远不是部分操作），并保证可预测的执行顺序，最终创建一个可靠和高效的多线程进程。'
- en: Let’s delve into the world of synchronization and locking mechanisms, explore
    why they’re crucial, and how to wield them effectively to build robust and performant
    concurrent applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入同步和锁定机制的世界，探讨它们为什么至关重要，以及如何有效地运用它们来构建健壮和性能良好的并发应用程序。
- en: The power of synchronization – protecting critical sections for thread-safe
    operations
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步的力量——保护临界区以进行线程安全操作
- en: 'In Java, the keyword **synchronized** acts as a gatekeeper for sensitive code
    blocks. When a thread enters a synchronized block, it acquires a lock on the associated
    object, preventing other threads from entering the same block until the lock is
    released. This ensures exclusive access to shared resources and prevents data
    corruption. There are three different locks:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，关键字**synchronized**充当敏感代码块的门卫。当一个线程进入同步块时，它会获取关联对象的锁，防止其他线程进入相同的块，直到锁被释放。这确保了对共享资源的独占访问，并防止数据损坏。存在三种不同的锁：
- en: '**Object-level locks**: When a thread enters a synchronized block, it acquires
    a lock on the instance of the object associated with the block. This lock is released
    when the thread exits the block.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象级锁**：当一个线程进入同步块时，它会获取与块关联的对象实例的锁。当线程退出块时，这个锁会被释放。'
- en: '**Class-level locks**: For static methods and blocks, the lock is acquired
    on the class object itself, ensuring synchronization across all instances of the
    class.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类级锁**：对于静态方法和块，锁是在类对象本身上获取的，确保了类所有实例的同步。'
- en: '**Monitor object**: The **Java virtual machine** (**JVM**) employs a monitor
    object for each object and class to manage synchronization. This monitor object
    tracks the thread holding the lock and coordinates access to the locked resource.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器对象**：**Java虚拟机**（**JVM**）为每个对象和类使用一个监视器对象来管理同步。这个监视器对象跟踪持有锁的线程，并协调对锁定资源的访问。'
- en: 'In cloud environments, locking mechanisms find their primary applications in
    several critical areas: coordinating distributed services, accessing shared data,
    and managing state – specifically maintaining and updating internal state information
    securely across multiple threads. Beyond traditional synchronization, there exist
    various alternative and sophisticated locking techniques. Let’s delve into these
    together.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，锁定机制在几个关键领域找到其主要应用：协调分布式服务、访问共享数据和管理状态——特别是安全地跨多个线程维护和更新内部状态信息。除了传统的同步之外，还存在各种替代和复杂的锁定技术。让我们一起来探讨这些技术。
- en: Beyond the gatekeeper – exploring advanced locking techniques
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越门卫——探索高级锁定技术
- en: 'In our exploration of Java’s concurrency tools, we’ve seen basic synchronization
    methods. Now, let’s delve into advanced locking techniques that offer greater
    control and flexibility for complex scenarios. These techniques are particularly
    useful in high-concurrency environments or when dealing with intricate resource
    management challenges:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Java并发工具的过程中，我们已经看到了基本的同步方法。现在，让我们深入探讨高级锁定技术，这些技术为复杂场景提供了更大的控制和灵活性。这些技术在高并发环境或处理复杂的资源管理挑战时尤其有用：
- en: '`ReentrantLock` provides the ability to attempt a lock with a timeout, preventing
    threads from getting indefinitely blocked.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock`提供了尝试带超时时间的锁的能力，防止线程无限期地阻塞。'
- en: '`ReentrantLock` can be used to ensure that if a document is taking too long
    to print, other jobs can be processed in the meantime, avoiding a bottleneck.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 可以用来确保如果文档打印时间过长，其他工作可以在其间进行处理，避免瓶颈。'
- en: '`ReadWriteLock` allows multiple threads to read a resource concurrently but
    requires exclusive access for writing.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteLock` 允许多个线程并发读取资源，但在写入时需要独占访问。'
- en: '`ReadWriteLock` optimizes performance by allowing concurrent reads while maintaining
    data integrity during updates.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteLock` 通过允许并发读取来优化性能，同时在更新期间保持数据完整性。'
- en: '`StampedLock` offers a mode where a lock can be acquired with an option to
    convert it to a read or write lock.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StampedLock` 提供了一种模式，其中可以以选项的方式获取锁，并将其转换为读锁或写锁。'
- en: '`StampedLock` allows for more concurrency with the flexibility to upgrade a
    read lock to a write lock when an update is necessary.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StampedLock` 允许更高的并发性，并在需要更新时，可以将读锁升级为写锁。'
- en: '`ReentrantLock`, which allows threads to communicate about the lock status.
    A condition object is essentially a more advanced and flexible version of the
    traditional wait-notify object mechanism.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReentrantLock` 允许线程就锁的状态进行通信。条件对象本质上是一种更高级和灵活的传统等待-通知对象机制的版本。'
- en: 'Let’s look at a Java code example demonstrating the use of `ReentrantLock`
    with a condition object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 Java 代码示例，演示了如何使用条件对象与 `ReentrantLock` 结合使用：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, the `PrinterManager` class includes a condition object, `readyCondition`,
    created from `printerLock`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`PrinterManager` 类包含了一个由 `printerLock` 创建的条件对象 `readyCondition`：
- en: The `printDocument` method makes threads wait if the printer is not ready (`isPrinterReady`
    is false). Threads call `await()` on `readyCondition`, which suspends them until
    they are signaled or the timeout occurs.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当打印机未准备就绪（`isPrinterReady` 为 false）时，`printDocument` 方法会使线程等待。线程在 `readyCondition`
    上调用 `await()`，这将使它们挂起，直到被信号通知或超时发生。
- en: The new `makePrinterReady` method simulates an event where the printer becomes
    ready. When this method is called, it changes the `isPrinterReady` flag to true
    and calls `signal()` on `readyCondition` to wake up one waiting thread.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `makePrinterReady` 方法模拟了一个事件，即打印机准备就绪。当此方法被调用时，它将 `isPrinterReady` 标志更改为
    true，并在 `readyCondition` 上调用 `signal()` 以唤醒一个等待的线程。
- en: The `main` method simulates the scenario where the printer becomes ready after
    a delay, and multiple worker threads are trying to use the printer.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 方法模拟了打印机在延迟后准备就绪的场景，此时多个工作线程正在尝试使用打印机。'
- en: The code assumes a simplistic representation of a printer using a Boolean variable
    (`isPrinterReady`). In reality, you would need to integrate with the actual printer’s
    API, library, or driver to communicate with the printer and determine its readiness
    state.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码假设使用布尔变量（`isPrinterReady`）对打印机的简单表示。实际上，你需要与实际打印机的 API、库或驱动程序集成，以与打印机通信并确定其就绪状态。
- en: The provided code is a simplified example to demonstrate the concept of thread
    synchronization and waiting for a condition (in this case, the printer being ready)
    using locks and conditions in Java. While it illustrates the basic principles,
    it may not be directly applicable to a real-world scenario without further modifications
    and enhancements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码是一个简化的示例，用于演示在 Java 中使用锁和条件实现线程同步和等待条件（在这种情况下，打印机就绪）的概念。虽然它说明了基本原理，但可能需要进一步的修改和增强才能直接应用于现实场景。
- en: By understanding and applying these advanced locking techniques, you can enhance
    the performance and reliability of your Java applications. Each technique serves
    a specific purpose and choosing the right one depends on the specific requirements
    and characteristics of your application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解和应用这些高级锁定技术，你可以提高 Java 应用程序的性能和可靠性。每种技术都有其特定的用途，选择正确的一种取决于你应用程序的具体需求和特性。
- en: In the realm of Java’s advanced locking techniques, we delve deeper into the
    mechanics and use cases of tools such as `ReentrantLock`, `ReadWriteLock`, and
    `StampedLock`. For instance, `ReentrantLock` offers a higher level of control
    compared to intrinsic locks, with features such as fairness policies and the ability
    to interrupt lock waiting threads. Consider a scenario where multiple threads
    are competing to access a shared database. Here, `ReentrantLock` with a fairness
    policy ensures that threads gain database access in the order they requested it,
    preventing resource hogging and enhancing system fairness.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java高级锁定技术的领域，我们深入探讨了`ReentrantLock`、`ReadWriteLock`和`StampedLock`等工具的机制和用例。例如，`ReentrantLock`与内置锁相比提供了更高的控制级别，具有公平策略和中断等待锁线程的能力。考虑一个多个线程竞争访问共享数据库的场景。在这里，具有公平策略的`ReentrantLock`确保线程按请求的顺序获取数据库访问权限，防止资源垄断并增强系统公平性。
- en: 'Similarly, `ReadWriteLock` splits the lock into two parts: a read lock and
    a write lock. This separation allows multiple threads to read data simultaneously,
    but only one thread can write at a time, thereby increasing read efficiency in
    scenarios where write operations are less frequent, such as in caching systems.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`ReadWriteLock` 将锁分为两部分：读锁和写锁。这种分离允许多个线程同时读取数据，但一次只能有一个线程写入，从而在写操作较少的场景中（例如在缓存系统中）提高读效率。
- en: '`StampedLock`, on the other hand, provides lock modes that support both read
    and write locks and also offers a method for lock conversion. Imagine a navigation
    application where map data is read frequently but updated less often. `StampedLock`
    can initially grant a read lock to display the map and then convert it to a write
    lock when an update is needed, minimizing the time during which other threads
    are prevented from reading the map.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`StampedLock` 提供了支持读锁和写锁的锁模式，并提供了一种锁转换方法。想象一个导航应用程序，其中地图数据经常被读取但很少更新。`StampedLock`
    可以最初授予读锁以显示地图，然后在需要更新时将其转换为写锁，从而最小化阻止其他线程读取地图的时间。
- en: In the next section, we’ll explore some common pitfalls to avoid.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些需要避免的常见陷阱。
- en: Understanding and preventing deadlocks in multi-threaded applications
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和防止多线程应用程序中的死锁
- en: As we explore the bustling kitchen of Java concurrency, where threads work like
    sous chefs in a harmonious rhythm, we come across a notorious kitchen hitch –
    the **deadlock**. Much like sous chefs vying for the same kitchen appliance, threads
    in Java can find themselves in a deadlock when they wait on each other to relinquish
    shared resources. Preventing such deadlocks is vital to ensure that our multi-threaded
    applications, akin to our kitchen operations, continue to run smoothly without
    any disruptive standstills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索Java并发领域的繁忙厨房，其中线程像和谐节奏中的副厨师一样工作，我们遇到了一个臭名昭著的厨房故障——**死锁**。就像争夺同一厨房设备的副厨师一样，Java中的线程可能会发现自己处于死锁状态，因为它们在等待对方释放共享资源。防止此类死锁对于确保我们的多线程应用程序（类似于我们的厨房操作）继续平稳运行，没有任何破坏性的停滞至关重要。
- en: 'To prevent deadlocks, we can employ several strategies:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止死锁，我们可以采用几种策略：
- en: '**Avoid circular wait**: We can design our application to prevent the circular
    chain of dependencies. One way is to impose a strict order in which locks are
    acquired.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免循环等待**：我们可以设计我们的应用程序以防止依赖关系的循环链。一种方法是在获取锁时强制执行严格的顺序。'
- en: '**Minimize hold and wait**: Try to ensure that a thread requests all the required
    resources at once, rather than acquiring one and waiting for others.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化持有和等待**：尽量确保线程一次性请求所有必需的资源，而不是获取一个资源然后等待其他资源。'
- en: '**Resource allocation graphs**: Use these graphs to detect the possibility
    of deadlocks in the system.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配图**：使用这些图来检测系统中死锁的可能性。'
- en: '**Timeouts**: Implementing timeouts can be a simple yet effective way. If a
    thread cannot acquire all its resources within a given timeframe, it releases
    the acquired resources and retries later.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：实现超时可能是一种简单而有效的方法。如果线程在给定时间内无法获取所有资源，它将释放已获取的资源并在稍后重试。'
- en: '**Thread dump analysis**: Regularly analyze thread dumps for signs of potential
    deadlocks.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程转储分析**：定期分析线程转储以寻找潜在死锁的迹象。'
- en: After delving into the theoretical aspects of locking mechanisms in cloud environments,
    we shift gears to practical application. In this next section, we dive into hands-on
    activities focused on deadlocks, a pivotal challenge in concurrent programming.
    This hands-on approach aims not just to understand but to develop efficient Java
    applications in the face of these complex issues.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究云环境中锁定机制的理论方面之后，我们将重点转向实际应用。在接下来的部分中，我们将深入实践操作，专注于死锁，这是并发编程中的一个关键挑战。这种实践方法不仅旨在理解，而且旨在面对这些复杂问题开发高效的Java应用程序。
- en: Hands-on activity – deadlock detection and resolution
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践活动 - 死锁检测和解决
- en: We simulate a real-world scenario involving two processes trying to access two
    database tables. We’ll represent the tables as shared resources and the processes
    as threads. Each thread will try to lock both tables to perform some operations.
    We’ll then demonstrate a deadlock and refactor the code to resolve it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟了一个现实场景，涉及两个进程试图访问两个数据库表。我们将表表示为共享资源，将进程表示为线程。每个线程将尝试锁定两个表以执行一些操作。然后我们将演示死锁并重构代码以解决它。
- en: 'First, let’s create a Java program that simulates a deadlock when two threads
    try to access two tables (resources):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个Java程序来模拟两个线程尝试访问两个表（资源）时的死锁：
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, each thread (representing a Lambda function) tries to lock two
    resources (`Item1Lock` and `Item2Lock`) in a nested manner. However, each thread
    locks one resource and then attempts to lock the other resource that may already
    be locked by the other thread. This scenario creates a deadlock situation because
    of the following reasons:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，每个线程（代表Lambda函数）尝试以嵌套方式锁定两个资源（`Item1Lock`和`Item2Lock`）。然而，每个线程锁定一个资源后，然后尝试锁定另一个可能已被其他线程锁定的资源。这种情况由于以下原因导致死锁：
- en: '`lambdaFunction1` locks `Item1` and waits to lock `Item2`, which might already
    be locked by `Lambda` `Function 2`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambdaFunction1`锁定`Item1`并等待锁定`Item2`，而`Item2`可能已被`Lambda` `Function 2`锁定'
- en: '`lambdaFunction2` locks `Item2` and waits to lock `Item1`, which might already
    be locked by `Lambda` `Function 1`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambdaFunction2`锁定`Item2`并等待锁定`Item1`，而`Item1`可能已被`Lambda` `Function 1`锁定'
- en: Both Lambda functions end up waiting indefinitely for the other to release the
    lock, causing a deadlock
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Lambda函数最终无限期地等待对方释放锁，导致死锁
- en: '`Thread.sleep(100)` in each thread is crucial as it simulates a delay, allowing
    time for the other thread to acquire a lock on the other resource, thus increasing
    the likelihood of a deadlock'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程中的`Thread.sleep(100)`至关重要，因为它模拟了延迟，为其他线程获取另一个资源的锁提供了时间，从而增加了死锁的可能性
- en: 'This example illustrates a basic deadlock scenario in a concurrent environment,
    similar to what might occur in distributed systems involving multiple resources.
    To resolve the deadlock, we ensure that both threads acquire locks in a consistent
    order; it prevents a situation where each thread holds one lock and waits for
    the other. Let us look at this refactoring code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了在并发环境中基本死锁场景，类似于在涉及多个资源的分布式系统中可能发生的情况。为了解决死锁，我们确保两个线程以一致的方式获取锁；它防止了每个线程持有锁并等待另一个锁的情况。让我们看看这个重构代码：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both `lambdaFunction1` and `lambdaFunction2` now acquire the locks in the same
    order, first `Item1Lock` and then `Item2Lock`. By ensuring that both threads acquire
    locks in a consistent order, we prevent a situation where each thread holds one
    lock and waits for the other. This eliminates the deadlock condition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`lambdaFunction1`和`lambdaFunction2`都按照相同的顺序获取锁，首先是`Item1Lock`然后是`Item2Lock`。通过确保两个线程以一致的方式获取锁，我们防止了每个线程持有锁并等待另一个锁的情况。这消除了死锁条件。
- en: Let’s look at another real-world scenario where two processes are waiting for
    file access, we can simulate file operations using locks. Each process will try
    to lock a file (represented as `ReentrantLock`) for exclusive access.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个现实场景，其中两个进程正在等待文件访问，我们可以使用锁来模拟文件操作。每个进程将尝试锁定一个文件（表示为`ReentrantLock`）以进行独占访问。
- en: 'Let’s demonstrate this scenario:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示这个场景：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code demonstrates a technique for detecting and preventing deadlocks when
    working with concurrent processes that require access to shared resources – in
    this case, two files represented by `ReentrantLock`. Let’s break down how the
    deadlock occurs and how it is prevented:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了在处理需要访问共享资源（在这种情况下，由`ReentrantLock`表示的两个文件）的并发进程时，检测和防止死锁的技术。让我们分析死锁是如何发生的以及它是如何被预防的：
- en: '`fileLock1` and `fileLock2` are `ReentrantLock` objects that simulate locks
    on two shared files.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileLock1`和`fileLock2`是`ReentrantLock`对象，它们模拟了对两个共享文件的锁定。'
- en: '`process1` and `process2`), each trying to access both files. However, they
    attempt to acquire the locks in opposite orders. `process1` tries to lock `fileLock1`
    first, then `fileLock2`; `process2` does the opposite.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process1`和`process2`（每个都试图访问两个文件）。然而，它们尝试以相反的顺序获取锁。`process1`首先尝试锁定`fileLock1`，然后是`fileLock2`；`process2`则相反。'
- en: '`process1` locks `fileLock1` and `process2` locks `fileLock2` at the same time,
    they will each wait indefinitely for the other lock to be released, creating a
    deadlock situation.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process1`锁定`fileLock1`，而`process2`同时锁定`fileLock2`，它们将无限期地等待对方释放锁，从而产生死锁情况。'
- en: '`acquireFileLocksWithTimeout` method attempts to acquire each lock with a timeout
    (`tryLock(1000`, `TimeUnit.MILLISECONDS)`). This timeout prevents a process from
    waiting indefinitely for a lock, reducing the chance of a deadlock.*   `Thread.sleep(2000)`)
    and checks whether both processes are still active. If they are, it suspects a
    deadlock and interrupts one of the processes (`process2.interrupt()`), helping
    to recover from the deadlock situation.*   `InterruptedException`, the program
    checks whether the current thread holds either lock and, if so, releases it. This
    ensures that resources are not left in a locked state, which could perpetuate
    the deadlock.*   `acquireFileLocksWithTimeout` method guarantees that both locks
    are released, even if an exception occurs or the thread is interrupted. This is
    crucial for preventing deadlocks and ensuring resource availability for other
    processes.*   **Key takeaways**:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acquireFileLocksWithTimeout`方法尝试在超时时间内获取每个锁（`tryLock(1000`, `TimeUnit.MILLISECONDS)`）。这个超时防止进程无限期地等待锁，减少了死锁的可能性。*   `Thread.sleep(2000)`)并检查两个进程是否仍然活跃。如果它们仍然活跃，它怀疑存在死锁，并中断其中一个进程（`process2.interrupt()`），有助于从死锁情况中恢复。*   如果发生`InterruptedException`，程序检查当前线程是否持有任一锁，如果是，则释放它。这确保了资源不会被锁定在状态，这可能会持续死锁。*   `acquireFileLocksWithTimeout`方法保证即使在发生异常或线程被中断的情况下，也会释放两个锁。这对于防止死锁和确保其他进程的资源可用性至关重要。*   **关键要点**：'
- en: '**Deadlock detection**: The program actively checks for deadlock conditions
    and takes measures to resolve them'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁检测**：程序主动检查死锁条件并采取措施解决它们'
- en: '**Resource management**: Careful management of lock acquisition and release
    is essential in concurrent programming to avoid deadlocks'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：在并发编程中，仔细管理锁的获取和释放对于避免死锁至关重要'
- en: '**Timeouts as a preventive measure**: Using timeouts when attempting to acquire
    locks can prevent processes from being indefinitely blocked'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时作为预防措施**：在尝试获取锁时使用超时可以防止进程被无限期阻塞'
- en: This approach demonstrates effective strategies for handling potential deadlocks
    in concurrent processes, especially when dealing with shared resources such as
    files or database connections in a multi-threaded environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法展示了处理并发过程中潜在死锁的有效策略，尤其是在处理多线程环境中的共享资源，如文件或数据库连接时。
- en: In our culinary world of Java concurrency, deadlocks are like kitchen gridlocks
    where sous chefs find themselves stuck, unable to access the tools they need because
    another chef is using them. Mastering the art of preventing these kitchen standstills
    is a crucial skill for any adept Java developer. By understanding and applying
    strategies to avoid these deadlocks, we ensure that our multi-threaded applications,
    much like a well-organized kitchen, operate smoothly, deftly handling the intricate
    dance of concurrent tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java并发烹饪世界中，死锁就像厨房交通堵塞一样，副厨师发现自己被困住，无法访问他们需要的工具，因为另一个厨师正在使用它们。掌握预防这些厨房僵局的技艺是任何熟练的Java开发者必备的关键技能。通过理解和应用避免这些死锁的策略，我们确保我们的多线程应用程序，就像一个组织良好的厨房一样，能够平稳运行，巧妙地处理并发任务的复杂舞蹈。
- en: Next, we will discuss task management and data sharing in concurrency in Java;
    it involves understanding how to effectively handle asynchronous tasks and ensuring
    data integrity across concurrent operations. Let’s delve into this topic.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Java并发中的任务管理和数据共享；这涉及到理解如何有效地处理异步任务，并确保并发操作中的数据完整性。让我们深入探讨这个主题。
- en: Employing Future and Callable for result-bearing task execution
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Future和Callable执行结果携带的任务
- en: 'In Java, Future and Callable are used together to execute tasks asynchronously
    and obtain results at a later point in time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，Future和Callable一起使用以异步执行任务并在稍后时间点获取结果：
- en: '`call()`: This method encapsulates the task’s logic and returns the result'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: This method retrieves the result, blocking if necessary until completion*   `isDone()`:
    This method checks whether the task is finished*   `ExecutorService` accepts Callables,
    returning Futures for tracking completion and results'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of Callable and Future interfaces:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Callable interface defines the task that produces a result. The Future interface
    acts as a handle for managing and retrieving that result, enabling asynchronous
    coordination and result-bearing task execution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The key points in this code are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous execution**: Callable and Future enable the task to execute
    independently of the main thread, potentially improving performance'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result retrieval**: The Future object allows the main thread to retrieve
    the task’s result when it becomes available, ensuring synchronization'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible coordination**: Futures can be used for dependency management and
    creating complex asynchronous workflows'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe data sharing between concurrent tasks
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutable data and thread-local storage are fundamental concepts for concurrency
    and can greatly simplify thread-safe programming. Let’s explore them in detail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Immutable data** is a fundamental concept where an object’s state cannot
    be changed once it is created. Any attempt to modify such objects results in the
    creation of new ones, leaving the original untouched. This is in stark contrast
    to **mutable data**, where the state of an object can be directly altered after
    its creation.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Its benefits are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**It eliminates the need for synchronization**: When immutable data is shared
    across threads, there is no need for synchronization mechanisms such as locks
    or semaphores'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhances thread safety**: Immutability by its very nature guarantees thread-safe
    operations'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplifies reasoning**: With immutability, there’s no concern about unexpected
    changes from other threads, making the code more predictable and easier to debug'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of immutable data types are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings**: In Java, string objects are immutable'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boxed primitives**: These include integers and Boolean'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate` in Java 8'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Final classes with immutable fields**: Custom classes designed to be immutable'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: Often used in functional programming languages. Tuples are data
    structures that store a fixed set of elements where each element can be of a different
    type. Tuples are immutable, meaning that once created, the values inside them
    cannot be changed. While Java does not have a built-in tuple class like some other
    languages (Python, for instance), you can simulate tuples using custom classes
    or available classes from libraries.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example of how you might create and use a tuple-like structure
    in Java:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let us now explore thread local storage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Thread local storage** or **TLS** is a method of storing data that is local
    to a thread. In this model, each thread has its own separate storage, which is
    not accessible to other threads.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程局部存储**或**TLS**是一种将数据存储在线程局部的方法。在这个模型中，每个线程都有自己的独立存储，其他线程无法访问。'
- en: 'Its benefits are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其好处如下：
- en: '**Simplifies data sharing**: TLS provides a straightforward approach to storing
    data specific to each thread, and each thread can access its data independently
    without the need for coordination'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化数据共享**：TLS提供了一种简单的方法来存储特定于每个线程的数据，每个线程都可以独立访问其数据，而无需协调'
- en: '**Reduces contention**: By keeping data separate for each thread, TLS minimizes
    potential conflicts and bottlenecks'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少竞争**：通过为每个线程保留独立的数据，TLS最小化了潜在的冲突和瓶颈'
- en: '**Improves maintainability**: Code that utilizes TLS is often clearer and easier
    to understand'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可维护性**：利用TLS的代码通常更清晰、更容易理解'
- en: 'Some examples of using TLS are discussed in the following points:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几点讨论了使用TLS的一些示例：
- en: '**User session management**: In web applications, storing user-specific data
    such as sessions'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户会话管理**：在Web应用程序中，存储特定于用户的诸如会话等数据'
- en: '**Counters or temporary variables**: Keeping track of thread-specific computations'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器或临时变量**：跟踪线程特定的计算'
- en: '**Caching**: Storing frequently used, thread-specific data for performance
    optimization'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：存储频繁使用的、线程特定的数据以优化性能'
- en: 'While both immutable data and TLS contribute significantly to thread safety
    and simplify concurrency management, they serve different purposes and scenarios:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可变数据和TLS都对线程安全做出了重大贡献，简化了并发管理，但它们服务于不同的目的和场景：
- en: '**Scope**: Immutable data ensures consistency and safety of the data itself
    across multiple threads. In contrast, TLS is about providing a separate data storage
    space for each thread.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：不可变数据确保了数据本身在多个线程中的一致性和安全性。相比之下，TLS是关于为每个线程提供独立的数据存储空间。'
- en: '**Use cases**: Use immutable data for shared structures and values that are
    read-only. TLS is ideal for managing data that is specific to each thread and
    not meant for cross-thread sharing.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：对于共享的只读结构和值，使用不可变数据。TLS对于管理特定于每个线程且不打算跨线程共享的数据是理想的。'
- en: The choice between immutable data and TLS should be based on the specific requirements
    of your application and the nature of the data access patterns involved. Leveraging
    both immutable data and TLS can further enhance the safety and simplicity of your
    concurrent systems, harnessing the strengths of each approach.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据和TLS之间的选择应基于您应用程序的具体要求和涉及的数据访问模式。利用不可变数据和TLS可以进一步增强并发系统的安全性和简单性，利用每种方法的优点。
- en: Leveraging thread-safe collections to mitigate concurrency issues
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用线程安全的集合来减轻并发问题
- en: Having already explored the basics of concurrent collections and atomic variables,
    let’s focus on advanced strategies for utilizing these thread-safe collections
    to further mitigate concurrency issues in Java.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在已经探讨了并发集合和原子变量的基础知识之后，让我们专注于利用这些线程安全的集合在Java中进一步减轻并发问题的高级策略。
- en: 'The following are the advanced uses of concurrent collections:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些并发集合的高级用法：
- en: '`ConcurrentHashMap`: Ideal for scenarios with a high volume of concurrent read
    and write operations. Utilize its advanced functions such as `computeIfAbsent`
    for atomic operations combining checking and adding elements.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`：适用于高并发读写操作的场景。利用其高级功能，如`computeIfAbsent`，进行原子操作，结合检查和添加元素。'
- en: '`ConcurrentLinkedQueue`: Best for queue-based data processing models, especially
    in producer-consumer patterns. Its non-blocking nature is essential for high-throughput
    scenarios.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue`：最适合基于队列的数据处理模型，尤其是在生产者-消费者模式中。其非阻塞特性对于高吞吐量场景至关重要。'
- en: '`CopyOnWriteArrayList`: Use when the list is largely read-only but needs occasional
    modifications. Its iterator provides a stable snapshot view, making it reliable
    for iterations even when concurrent modifications occur.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList`：当列表主要是只读的但偶尔需要修改时使用。其迭代器提供了一个稳定的快照视图，即使在并发修改发生时也能保证迭代的可靠性。'
- en: '`ConcurrentHashMap`. This combination can lead to highly efficient parallel
    algorithms.*   `ConcurrentHashMap` and performing multiple related operations
    that need to be atomic as a whole.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`。这种组合可以导致高度高效的并行算法。*   `ConcurrentHashMap` 和执行多个需要作为一个整体原子操作的相关操作。'
- en: 'The following are the advantages of atomic variables in addition to their basic
    use cases:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本用例之外，原子变量的以下优点：
- en: '`updateAndGet` or `accumulateAndGet` in `AtomicInteger` or `AtomicLong`, which
    allow complex calculations in a single atomic step.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger`或`AtomicLong`中的`updateAndGet`或`accumulateAndGet`，允许在单个原子步骤中进行复杂计算。'
- en: '`AtomicInteger` are guaranteed to have immediate visibility to other threads,
    which is crucial for ensuring up-to-date data visibility.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger`保证对其他线程具有立即可见性，这对于确保数据可见性至关重要。'
- en: Choosing between concurrent collections and atomic variables
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在并发集合和原子变量之间进行选择
- en: 'Understanding when to choose concurrent collections and when to use atomic
    variables is crucial for developing efficient, robust, and thread-safe Java applications.
    This knowledge allows you to tailor your choice of data structures and synchronization
    mechanisms to the specific needs and characteristics of your application. Making
    the right choice between these two options can significantly impact the performance,
    scalability, and reliability of your concurrent applications. This section delves
    into the considerations for selecting between concurrent collections, which are
    ideal for complex data structures, and atomic variables, which are best suited
    for simpler, single-value scenarios:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时选择并发集合以及何时使用原子变量对于开发高效、健壮和线程安全的Java应用程序至关重要。这种知识使您能够根据应用程序的具体需求和特点来调整数据结构和同步机制的选择。在这两种选项之间做出正确的选择可以显著影响并发应用程序的性能、可扩展性和可靠性。本节深入探讨了在以下两种选择之间的考虑：适用于复杂数据结构的并发集合，以及适用于更简单、单值场景的原子变量：
- en: '**Data complexity**: Choose concurrent collections for managing complex data
    structures with multiple elements and relationships. Use atomic variables when
    dealing with single values requiring atomic operations without the overhead of
    a full collection structure.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复杂性**：选择并发集合来管理具有多个元素和关系的复杂数据结构。在处理需要原子操作而不需要完整集合结构的单值时使用原子变量。'
- en: '`ConcurrentHashMap` has excellent scalability for concurrent access, whereas
    atomic variables are lightweight and efficient for simpler use cases.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`在并发访问方面具有出色的可扩展性，而原子变量对于更简单的用例来说轻量级且高效。'
- en: By deepening your understanding of when and how to use these advanced features
    of thread-safe collections and atomic variables, you can optimize your Java applications
    for concurrency, ensuring both data integrity and exceptional performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深化对何时以及如何使用这些线程安全集合和原子变量的高级特性的理解，您可以优化Java应用程序的并发性能，确保数据完整性和卓越的性能。
- en: Concurrent best practices for robust applications
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于健壮应用程序的并发最佳实践
- en: While [*Chapter 5*](B20937_05.xhtml#_idTextAnchor131), *Mastering Concurrency
    Patterns in Cloud Computing*, of our book delves into Java concurrency patterns
    specifically tailored for cloud environments, it is crucial to lay the groundwork
    with some best practices and general strategies for concurrent programming.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第5章](B20937_05.xhtml#_idTextAnchor131)，《云计算中的并发模式精通》这本书深入探讨了针对云环境定制的Java并发模式，但了解一些并发编程的最佳实践和一般策略是至关重要的。
- en: 'Best practices in concurrent programming include the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的最佳实践包括以下内容：
- en: '**Master concurrency primitives**: Master the basics of concurrency primitives
    in Java, such as synchronized, volatile, lock, and condition. Understanding their
    semantics and usage is crucial for writing correct concurrent code.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**掌握并发原语**：掌握Java中并发原语的基础，例如synchronized、volatile、lock和condition。理解它们的语义和用法对于编写正确的并发代码至关重要。'
- en: '**Minimize shared state**: Limit the amount of shared state between threads.
    The more data shared, the higher the complexity and potential for concurrency
    issues. Aim for immutability where feasible.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最小化共享状态**：限制线程之间的共享状态量。共享的数据越多，复杂性越高，并发问题出现的可能性也越大。在可能的情况下追求不可变性。'
- en: '`InterruptedException`, restore the interrupt status by calling `Thread.currentThread().interrupt()`.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获`InterruptedException`时，通过调用`Thread.currentThread().interrupt()`来恢复中断状态。
- en: '`ExecutorService`, `CountDownLatch`, and `CyclicBarrier` to manage threads
    and synchronization.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ExecutorService`、`CountDownLatch`和`CyclicBarrier`来管理线程和同步。
- en: '`AtomicInteger`, can be more scalable than lock-based approaches.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger`可能比基于锁的方法更具有可扩展性。'
- en: '**Cautious with lazy initialization**: Lazy initialization in a concurrent
    setting can be tricky. Double-checked locking with a volatile variable is a common
    pattern but requires careful implementation to be correct.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谨慎使用延迟初始化**：在并发环境中，延迟初始化可能会很棘手。使用volatile变量的双重检查锁定是一种常见的模式，但需要仔细实现才能保证正确。'
- en: '**Test concurrency thoroughly**: Concurrent code should be rigorously tested
    under conditions that simulate real-world scenarios. This includes testing for
    thread safety, potential deadlocks, and race conditions.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**彻底测试并发**：并发代码应该在模拟真实场景的条件下进行严格测试。这包括测试线程安全性、潜在的死锁和竞态条件。'
- en: '**Document concurrency assumptions**: Clearly document the assumptions and
    design decisions related to concurrency in your code. This helps maintainers understand
    the concurrency strategies employed.'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录并发假设**：清楚地记录与代码中并发相关的假设和设计决策。这有助于维护者理解所采用的并发策略。'
- en: '**Optimize thread allocation**: Balance the number of threads with the workload
    and the system’s capabilities. Overloading a system with too many threads can
    lead to performance degradation due to excessive context switching.'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化线程分配**：根据工作负载和系统的能力平衡线程数量。过度加载系统导致过多线程可能会因为过多的上下文切换而导致性能下降。'
- en: '**Monitor and tune performance**: Regularly monitor the performance of your
    concurrent applications and tune parameters such as thread pool sizes or task
    partitioning strategies for optimal results.'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和调整性能**：定期监控并发应用程序的性能，并调整线程池大小或任务分区策略等参数以获得最佳结果。'
- en: '**Avoid blocking threads unnecessarily**: Design tasks and algorithms to avoid
    keeping threads in a blocked state unnecessarily. Utilize concurrent algorithms
    and data structures that allow threads to progress independently.'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免不必要的线程阻塞**：设计任务和算法以避免不必要地将线程保持在阻塞状态。利用允许线程独立进度的并发算法和数据结构。'
- en: These best practices form the bedrock of robust, efficient, and maintainable
    concurrent applications, irrespective of their specific domain, such as cloud
    computing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践构成了稳健、高效和可维护的并发应用程序的基础，无论其特定领域如何，例如云计算。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we conclude [*Chapter 2*](B20937_02.xhtml#_idTextAnchor048), let’s reflect
    on the essential concepts and best practices we’ve uncovered in our exploration
    of Java’s concurrency. This summary, akin to a chef’s final review of a successful
    banquet, will encapsulate the crucial learnings and strategies for effective concurrent
    programming in Java.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束[*第二章*](B20937_02.xhtml#_idTextAnchor048)时，让我们回顾一下在我们探索Java并发过程中发现的必要概念和最佳实践。这个总结，就像厨师对一场成功宴会的最终评审，将包含关键的见解和策略，以实现有效的Java并发编程。
- en: We learned about threads and processes. Threads, like nimble sous chefs, are
    the fundamental units of execution, working in shared environments (kitchens).
    Processes are like independent kitchens, each with its resources, operating in
    isolation. We journeyed through a thread’s life cycle, from creation to termination,
    highlighting the critical stages and how they are managed within the Java environment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了线程和进程。线程，就像敏捷的副厨师，是执行的基本单位，在共享环境中（厨房）工作。进程就像独立的厨房，每个都有自己的资源，独立运行。我们经历了一个线程的生命周期，从创建到终止，突出了关键阶段以及它们如何在Java环境中被管理。
- en: Like coordinating a team of chefs, we’ve explored various synchronization techniques
    and locking mechanisms essential for managing access to shared resources and preventing
    conflicts. Next, we tackled the challenge of deadlocks, understanding how to detect
    and resolve these standstills in concurrent programming, much like resolving bottlenecks
    in a busy kitchen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像协调一群厨师一样，我们探讨了各种同步技术和锁定机制，这些对于管理对共享资源的访问和防止冲突至关重要。接下来，我们解决了死锁的挑战，理解了如何在并发编程中检测和解决这些僵局，就像解决繁忙厨房中的瓶颈一样。
- en: Then, we delved into advanced tools such as `StampedLock` and condition objects.
    We equipped you with sophisticated methods for specific concurrency scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了高级工具，如`StampedLock`和条件对象。我们为您提供了针对特定并发场景的复杂方法。
- en: A pivotal part of this chapter was the discussion on concurrent best practices
    for robust applications. We discussed best practices in concurrent programming.
    These practices are akin to the golden rules in a professional kitchen, ensuring
    efficiency, safety, and quality. We emphasized the importance of understanding
    concurrency patterns, proper resource management, and the judicious use of synchronization
    techniques to build robust and resilient Java applications.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键部分是关于构建健壮应用程序的并发最佳实践的讨论。我们讨论了并发编程的最佳实践。这些实践类似于专业厨房中的黄金法则，确保效率、安全和质量。我们强调了理解并发模式、适当资源管理和审慎使用同步技术以构建健壮和有弹性的Java应用程序的重要性。
- en: Moreover, through hands-on activities and real-world examples, we’ve seen how
    to apply these concepts and practices, enhancing our understanding of when and
    how to utilize different synchronization strategies and locking mechanisms effectively.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过实际操作和现实世界案例，我们已经看到了如何应用这些概念和实践，增强了我们对何时以及如何有效地利用不同的同步策略和锁定机制的理解。
- en: This chapter gave you the tools and best practices to conquer concurrency’s
    complexities. You’re now primed to design robust, scalable applications that thrive
    in the multi-threaded world. However, our culinary journey isn’t over! In [*Chapter
    3*](B20937_03.xhtml#_idTextAnchor077), *Mastering Parallelism in Java*, we ascend
    to the grand hall of **parallel processing**, where we’ll learn to harness multiple
    cores for even more potent Java magic. Prepare to leverage your concurrency expertise
    as we unlock the true power of parallel programming.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了征服并发复杂性的工具和最佳实践。现在，您已经准备好设计健壮、可扩展的应用程序，在多线程世界中茁壮成长。然而，我们的烹饪之旅还没有结束！在[*第3章*](B20937_03.xhtml#_idTextAnchor077)《精通Java并行性》中，我们将进入**并行处理**的大厅，我们将学习如何利用多个核心来发挥更强大的Java魔法。准备好利用您的并发专业知识，随着我们解锁并行编程的真正力量。
- en: Questions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the primary difference between threads and processes in Java’s concurrency
    model?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java并发模型中线程和进程的主要区别是什么？
- en: Threads and processes are essentially the same.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程和进程本质上是一样的。
- en: Threads are independent, while processes share a memory space.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程是独立的，而进程共享内存空间。
- en: Threads share a memory space, while processes are independent and have their
    own memory.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程共享内存空间，而进程是独立的，并且有自己的内存。
- en: Processes are used only in web applications, while threads are used in desktop
    applications.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程仅在Web应用程序中使用，而线程在桌面应用程序中使用。
- en: What is the role of the `java.util.concurrent` package in Java?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java中的`java.util.concurrent`包的作用是什么？
- en: It provides tools for building graphical user interfaces.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了构建图形用户界面的工具。
- en: It offers a set of classes and interfaces for managing threads and processes
    efficiently.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一套用于高效管理线程和进程的类和接口。
- en: It is used exclusively for database connectivity.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它专门用于数据库连接。
- en: It enhances the security features of Java applications.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它增强了Java应用程序的安全性。
- en: Which scenario best illustrates the use of `ReadWriteLock` in Java?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个场景最能说明Java中`ReadWriteLock`的使用？
- en: Managing user sessions in a web application.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web应用程序中管理用户会话。
- en: Allowing multiple threads to read a resource concurrently but requiring exclusive
    access for writing.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许多个线程并发读取资源，但需要写入时独占访问。
- en: Encrypting sensitive data before sending it over a network.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过网络发送之前加密敏感数据。
- en: Serializing objects for saving the state of an application.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化对象以保存应用程序的状态。
- en: How does `CountDownLatch` in Java’s concurrency model function?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java并发模型中的`CountDownLatch`是如何工作的？
- en: It dynamically adjusts the priority of thread execution.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以动态调整线程执行的优先级。
- en: It allows a set of threads to wait for a series of events to occur.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许一组线程等待一系列事件发生。
- en: It provides a mechanism for threads to exchange data.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为线程提供了交换数据的一种机制。
- en: It is used for automatic memory management in multi-threaded applications.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它用于多线程应用程序中的自动内存管理。
- en: What is the main advantage of using `AtomicInteger` over traditional synchronization
    techniques in Java?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AtomicInteger`而不是Java中的传统同步技术的主要优势是什么？
- en: It offers enhanced security features for web applications.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为Web应用程序提供了增强的安全性功能。
- en: It allows for lock-free thread-safe operations on a single integer value.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许在单个整数值上执行无锁线程安全的操作。
- en: It is used for managing database transactions.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它用于管理数据库事务。
- en: It provides a framework for building graphical user interfaces.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一个构建图形用户界面的框架。
