- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing data is another important software development topic. Java hands
    us collections to deal with various data structures. It also gives us generics
    to achieve type safety and avoid duplicate code in our applications. We cannot
    say we’re masters of Java without understanding how to use collections and generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why we devoted this chapter to the Java collections framework. In this
    chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The collections framework and its interfaces – `List`, `Set`, `Map`, and `Queue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several implementations of each collection type and their basic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting collections using natural ordering and the `Comparable` and `Comparator`
    interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic hashing concepts and their relevance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of the Java
    collections framework and generics, and you’ll be ready to manage data and use
    collections in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter (*Exercise* section) can be found on GitHub at: [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch13/exercises).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collections** are worth getting to know. Collections are a much more elegant
    way of dealing with multiple values in one variable than arrays. A common example
    of a collection would be a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing any proper Java application without collections would be very complicated.
    You’d probably start by creating some classes that will act like Java’s built-in
    collections. They play a vital role in software development as they provide a
    means to manage and organize data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons why we need them, but let’s just list (collection pun)
    a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing large amounts of data**: As applications grow in complexity, they
    often need to deal with large amounts of data. Collections help store and manage
    these datasets. They also come with helpful methods that make it easier to perform
    typical operations on data, such as searching and filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storing and manipulating various data structures**: Different data structures
    have unique characteristics and are suited for specific tasks. Collections provide
    a diverse set of data structures. This way, we get to choose the most appropriate
    one for our requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensuring efficient data management and access**: Collections offer a wide
    range of functionality. This helps us optimize data management and data access
    in our applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there are different data structures, we also need to have different collection
    types. Let’s have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of different collection types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java collections framework offers quite a few different collection types.
    This ensures that developers don’t go ahead and build custom data structure classes
    for all sorts of problems. This would make it very hard for different applications
    to communicate and there would be a lot of boilerplate code necessary for so many
    tasks. It’s a good thing Java comes with these built-in collection interfaces
    and implementations. Let’s have a look at the main interfaces first. You don’t
    need to understand the tiniest details of the coding examples; we’ll explain all
    of it in more detail after.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common data structures is the list. **Lists** are ordered and
    indexed collections that allow duplicate elements. They are useful when the order
    of elements is important, and you need to access elements based on their index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a list where we are storing a sequence of student names
    in a class, where the order of names is significant. This is a list that only
    holds elements of the `String` type. As you can see, `List` is an interface. When
    we instantiate it, we need to choose a class that implements `List`. In this case,
    we’re choosing `ArrayList`. This is a very common choice, but there are other
    options as well, such as `LinkedList`. There are a few important differences,
    but we won’t dive into those here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have seen that `List` can hold strings, but collections can hold
    any type of object, including custom objects. Let’s say we have a `Person` object.
    This is what that may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we’ll mostly use `String` for our examples but do keep in mind
    that this could be any object (and that includes other collections).
  prefs: []
  type: TYPE_NORMAL
- en: There are unordered collections that don’t allow duplicates as well. These are
    of the `Set` type. Let’s have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sets** are (commonly) unordered collections that do not allow duplicate elements.
    They are useful when you need to store unique elements but don’t need to care
    about their order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we need a data structure for all the email addresses we need to send
    a newsletter to. We don’t want to have any duplicates present because that would
    result in duplicate mail for the receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to worry about adding duplicates, nothing happens if you try
    to do that. You’ll see different implementations of `Set` later, including two
    types that maintain a particular order of their elements. But let’s have a look
    at another data structure first: maps.'
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Maps** store key-value pairs and provide lookups based on the key. They are
    useful when you need to associate values with unique keys, such as storing user
    information based on their usernames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, maps use different methods. Even though `Map` is part of the
    collections framework, it’s a bit of an odd one. `Map` is the only main interface
    that doesn’t extend the `Collection` interface. `List`, `Set`, and `Queue` do.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need an ordered collection that only allows access to the beginning
    and/or the end of the collection. We can use queues for this.
  prefs: []
  type: TYPE_NORMAL
- en: Queues and deques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Queues** allow you to add elements to the beginning of the queue and access
    elements at the ends. There’s a special queue that allows insertion and removal
    at both ends. This is known as a **deque**. Deque stands for double-ended queue.
    So, queues follow the **First-In, First-Out** (**FIFO**) principle, while deques
    can be used as both a queue (FIFO) and a stack, which follows the **Last-In, First-Out**
    (**LIFO**) principle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are useful for tasks that require processing elements in a specific order,
    such as when implementing a task scheduler. Here’s an example of a print job queue
    where tasks are processed in the order they are received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at these interfaces in a bit more detail, starting again with `List`.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the `List` interface is a part of the Java collections framework and it
    is used to represent an ordered collection of elements. Elements in a `List` interface
    can be accessed by their position (index) and can include duplicates. Since `List`
    is an interface, it cannot be instantiated. Two commonly used implementations
    of the `List` interface are `ArrayList` and `LinkedList`. Since these are implementation
    classes, they can be instantiated. Let’s explore what they are.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ArrayList` is a resizable array-backed implementation of the `List` interface.
    It provides fast random access to elements and is efficient for read-heavy operations.
    Random access means directly reaching any item using its index quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayList` dynamically resizes itself when elements are added or removed.
    Adding and removing elements is somewhat slower. `LinkedList` is optimized for
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LinkedList` is an implementation of the `List` interface based on a doubly
    linked list data structure. Not only does it implement `List` but it also implements
    `Queue` and `Deque`. It provides fast insertion and deletion of elements at the
    beginning and end of the list, as well as efficient traversal in both directions.
    However, accessing elements by index can be slower in `LinkedList` compared to
    `ArrayList` as elements must be traversed from the head or tail of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming examples could be happening on both an `ArrayList` and a `LinkedList`
    in the same way. The difference is the performance (which is not a significant
    difference for the small amounts of data in these examples).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basic operations for lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add, remove, alter, and access items on lists. Let’s have a look at how
    to perform these everyday operations. There are a lot of other useful methods
    for lists, but we’ll stick to the must-haves and start with adding elements to
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can add elements to a `List` interface using the `add()` method. The `add()`
    method has two forms: `add(E element)` and `add(int index, E element`). The first
    one adds the element to the end of the list, while the second one adds the element
    at the specified index. This will shift all the other elements that follow one
    index up. Here, `E` is the placeholder for the actual type. If it’s a list of
    the `String` type, we can only add strings to the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at a simple example that uses a list of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an instance of `ArrayList`. This is a list of the `String`
    type, as we can see by the word `String` between the angle (`<>`) brackets. We
    then go ahead and add `Julie` to the list. After that, we specify the position.
    Instead of adding `Janice` after `Julie`, we add `Janice` at index `0`. This makes
    `Julie` change from index `0` to index `1`.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we have a list with two `String` elements in it. Let’s see how we
    can access these elements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting elements from a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get elements from a `List` interface using the `get()` method, which
    takes an index as an argument. We’ll continue from our previous example. Here’s
    how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will get the element at index `1`, which is `Julie`, and store it in a
    variable called `name`. We can also alter the elements in a list. This can be
    done with the `set()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Changing elements in a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can change elements in a `List` interface using the `set()` method, which
    takes an index and a new element as arguments. We’re going to alter the element
    at index `1` here:'
  prefs: []
  type: TYPE_NORMAL
- en: ames.set(1, "Monica");
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have updated the value of `Julie` to `Monica`. If we want, we
    can also remove elements from a list.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `remove()` method to remove elements. The `remove()` method
    has two forms: `remove(int index)` and `remove(Object o`). The first one removes
    an element at a certain position, while the second one removes an element with
    a certain value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the list is empty again, because we’ve removed both elements.
    We removed `Monica` by using index `1` and we removed `Janice` by looking for
    an element with that value.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are different ways to iterate through a list. We’re going to have a look
    at the two most common ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can use a regular `for` loop to iterate through a list. In this
    case, we’re iterating over the list names. Let’s assume we didn’t remove both
    elements just now and it still has `Janice` and `Monica` in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also achieve this same output by using a for-each loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the regular for and for-each loop is that we have access
    to the index with the regular for. The for-each loop makes it easier to access
    the elements since we don’t need to make sure we stay within the bounds, use the
    index, and update the index.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few more methods available, but these are the most important
    ones to get you started. Now, let’s have a look at the `Set` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about all the collection in the official documentation
    here:     [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/doc-files/coll-overview.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Set` interface is part of the Java collections framework and represents
    a generally unordered collection of unique elements. This means that an element
    can only be in the set once. The commonly used implementations of the `Set` interface
    are `HashSet`, `TreeSet`, and `LinkedHashSet`. Let’s have a quick look at each.
  prefs: []
  type: TYPE_NORMAL
- en: HashSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the most popular set first: `HashSet`. This is a widely used
    implementation of the `Set` interface based on a hash table. A hash table stores
    data in key-value pairs, enabling fast lookup by computing an item’s key hash.
    It provides constant-time performance for basic operations such as `add`, `remove`,
    and `contains` (checking whether a `Set` interface contains a certain value).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Constant-time complexity* means that the time it takes to perform these operations
    does not increase when the number of elements in the set grows, assuming that
    the hash function used to distribute the elements among the buckets does its job
    well. We’ll cover hashing and bucket distribution in more detail at the end of
    this chapter, but hashing is pretty much the process of turning a certain value
    into another value – for example, turning a string into a number.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that hash-based data structures such as `HashSet` do not guarantee
    any specific order of the elements stored in them. This is because the elements
    are placed in the set based on their hash values, which might not be related to
    any meaningful order to humans such as ascending or chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: TreeSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TreeSet` is an implementation of the `Set` interface based on a tree. It maintains
    elements in a sorted order according to their natural ordering or according to
    a custom comparator provided during instantiation. `TreeSet` provides logarithmic
    time performance for common operations such as `add`, `remove`, and `contains`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Logarithmic time complexity* means that the time it takes to perform these
    operations increases logarithmically with the size of the input, making `TreeSet`
    an efficient choice for reasonably large datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to hash-based data structures such as `HashSet`, which do not maintain
    any specific order of elements, `TreeSets` are an excellent choice when you need
    a set that maintains elements in sorted order. This can be useful for tasks such
    as maintaining a list of unique items in sorted order, finding the smallest or
    largest element in a set quickly, or performing range queries on a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: Tree explained
  prefs: []
  type: TYPE_NORMAL
- en: A *tree* in computer science is not something you’d have in your backyard. In
    computer science, a tree is a hierarchical data structure that represents relationships
    between different nodes. Each node is a data point. The first node, called the
    root, has no parents. Every other node descends (directly or indirectly) from
    the root along a single path. The nodes at the very ends of the paths, which have
    no children, are called *leaf nodes*. This structure is ideal for representing
    hierarchical relationships because each node has a parent (except for the root)
    and potentially many children, much like the branches and leaves of a natural
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: In a tree, you can think of a path from the root to any node as a journey. Each
    step in the path represents a relationship between parent and child nodes. The
    *height* of a tree is the number of steps in the longest path from the root to
    a leaf. The *depth* of a node is the number of steps in the path from the root
    to that node. Trees with small heights relative to the number of nodes they contain
    are often efficient at finding nodes or adding and removing them. They are valuable
    for several use cases, such as organizing files in a filesystem or storing sorted
    data for efficient lookups, such as in `TreeSet`.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LinkedHashSet` is an implementation of the `Set` interface that maintains
    elements in the order they were inserted and it is backed by a combination of
    a hash table and a doubly-linked list. `LinkedHashSet` provides constant-time
    performance for basic operations while preserving insertion order.'
  prefs: []
  type: TYPE_NORMAL
- en: You would typically choose this implementation when the insertion order is important
    and the elements don’t need to be sorted. And, since it’s a `Set`, of course,
    the elements need to be unique (otherwise, `List` might be more logical). An example
    of a use case for `LinkedHashSet` would be maintaining a list of unique items
    in the order they were visited, such as web page browsing history or a playlist
    of unique songs in the order they were added. Another example is tracking events
    or user actions in an application in the order they occurred while ensuring that
    each event or action is processed only once.
  prefs: []
  type: TYPE_NORMAL
- en: To do all this, we do need to be able to perform some basic operations. So,
    let’s have a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic operations on a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operations on a `Set` interface are very similar to the operations on `List`.
    Of course, we don’t work with the index for the methods on `Set`. We’ll start
    by learning how to add to sets.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to a set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like we did for `List`, we can add elements to a `Set` interface using
    the `add()` method. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sets cannot contain duplicate values. Adding the same value twice won’t give
    an error and won’t add the value another time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the same ease, we could have created a `LinkedHashSet` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have also created a `TreeSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The operations on these sets would be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the elements in a set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot change elements in a `Set` directly. To modify an element, we must
    remove the old element and add the new one. So, let’s learn how to remove elements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from a set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can remove elements from a `Set` interface using the `remove()` method.
    We cannot remove by index like we can for `List`, because the elements don’t have
    an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After this, the set will only have one value, namely `Elizabeth`. Since sets
    don’t have indexes, accessing the elements works a bit differently for them as
    well. We can access elements via iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can iterate through a set using a `for-each` loop. We can’t use a regular
    `for` loop since we don’t have an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After the removal, our `Set` interface only has one name left. So, this `for-each`
    loop will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it for `Set`. Now, let’s explore the `Map` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another member of the collections framework is the `Map` interface. This interface
    represents a collection of key-value pairs. Keys are unique, while values can
    be duplicated. That’s why we use the key to add and access the key-value pairs
    in a map. The commonly used implementations of the `Map` interface that we’ll
    discuss are `HashMap` and `TreeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: HashMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the most popular one is `HashMap`. This is a widely used implementation
    of the `Map` interface that’s based on a hash table. Just like `HashSet`, it provides
    constant-time performance for basic operations. However, it does not guarantee
    any specific order of the keys. `HashMap` is suitable for situations where you
    need fast lookups and modifications, such as storing configuration settings or
    counting word occurrences in a piece of text. When the order is important, we
    can use `TreeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: TreeMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TreeMap` is an implementation of the `Map` interface that’s based on a tree.
    It maintains key-value pairs in a sorted order according to their natural ordering
    or a custom comparator provided during instantiation. We’ll look at custom comparators
    soon as well, but it’s pretty much a way of specifying the order in which it needs
    to be sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TreeMap` provides logarithmic time performance for common operations such
    as getting elements from the map and adding elements to the map. `TreeMap` is
    useful for scenarios where you need to maintain a sorted collection of key-value
    pairs, such as managing a leaderboard or tracking time-based events.'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LinkedHashMap` is another implementation of the `Map` interface. It combines
    the strengths of `HashMap` and `TreeMap` by providing constant-time performance
    for basic operations, similar to `HashMap`, while also maintaining the insertion
    order of key-value pairs. This order is the sequence in which keys are added to
    the map.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedHashMap` is essentially a `HashMap` implementation with an additional
    linked list that connects all entries, which allows it to remember the order of
    insertion. This is particularly useful in scenarios where the sequence of data
    matters, such as caching operations or maintaining a record of user activities.'
  prefs: []
  type: TYPE_NORMAL
- en: Its usage is very similar to the other two implementations. We won’t be showing
    all the implementations here because the basic operations are the same for each
    implementation. The only difference is that they have a specific order when you
    iterate over them, but iterating over them is done in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations on maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Map` is quite different from the other collections. Let’s learn how to perform
    the basic operations on `Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no `add()` method for `Map`. We can add elements to a `Map` interface
    using the `put()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This adds two key-value pairs to `Map`. Let’s see how we can get the values
    out again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting elements from a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can get elements from a `Map` interface using the `get()` method. This is
    how we can get the `Integer` value associated with the `Ross` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the key to modify the values of the map.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the elements of a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can change the elements in a `Map` interface using the `put()` method with
    an existing key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code changes the value of `8` to `9` for the `Chandler` key. We
    cannot change the key. If we need to do this, we need to remove the key-value
    pair and add a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key is also used for removing elements from a map. We can do this with the
    `remove()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our map only contains one key-value pair. We can iterate through
    a map as well. This is a bit different than what we did for `List` and `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can iterate through the key-value pairs, the values, and the keys with a
    for-each loop. We need to call different methods on our map object to achieve
    this. We can use the `entrySet()`, `keySet()`, and `values()` methods for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we still have two key-value pairs in our map, with `Ross`
    and `Chandler` as keys. The following code snippet loops through the key-value
    pairs using the `entrySet()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`entrySet()` provides a set of `Map.Entry` objects. On this object, we can
    use the `getKey()` and `getValue()` methods to get the key and the value, respectively.
    This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also loop through the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be surprised that this is the same output as the previous snippet
    and contains the values as well, but this is because we are using the key to obtain
    the value. This is not possible when we loop through the values. Here’s how we
    can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can only see the values, since that is what we’re looping through.
    Next, let’s have a look at the last main interface: `Queue`.'
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last in line is the `Queue` interface. It’s part of the Java collections
    framework and allows FIFO data storage. The head of the queue is the oldest element,
    and the tail is the newest element. Queues are useful for processing tasks in
    the order they are received. There is also a sub-interface called `Deque`, which
    is a special type of queue that allows you to get elements from both the head
    and the tail of the queue. This is why it can also be used for LIFO systems.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll only briefly deal with the different types of queues since this is the
    collection that’s typically least used in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Queue implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Queue` interface extends the `Collection` interface. There are several
    implementations, with some of the most common ones being `PriorityQueue`, `LinkedList`,
    and `ArrayDeque`. The `Deque` interface, which extends the `Queue` interface,
    adds support for double-ended queues, allowing the insertion and removal of elements
    from both ends of the queue. `LinkedList` and `ArrayDeque` are `Deque` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operations on the Queue interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic operations on the `Queue` interface are a bit special because the
    elements can only be accessed at the ends of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add elements to a queue using the `add()` or `offer()` methods. If a
    queue is at its maximum capacity, the `add()` method throws an exception when
    it cannot add to the queue. `offer()` would return `false` if it cannot add the
    element to the queue. Looking at the verbs it seems logical; *offer* is without
    obligation and the queue can turn down the offer when it’s full, hence there is
    no exception if it’s full. It simply returns false if it cannot append it to the
    queue. Whereas *add* really intents to add, if it doesn’t work an exception will
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can use both for `LinkedList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For objects of the `Deque` type, adding to the beginning of the queue works
    with different methods. `LinkedList` so happens to be of the `Deque` type. The
    `add` and `offer` methods add to the end of the queue, and so do the `Deque` type’s
    special methods, `addLast()` and `offerLast()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to add to the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The order of the elements in the queue is now (from head to tail) *Task 4, Task
    3, Task 1,* *Task 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting elements from a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can get the element at the head of a `Queue` interface using the `peek()`
    or `element()` method. They just return the value, without removing it from the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to get the head of the queue with the `peek()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The value of `head` becomes *Task 4*. The `element()` method throws an exception
    when it cannot return a value, while the `peek()` method doesn’t. The `peek()`
    method returns `null` when the queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: For `Deque`, we can get elements at both the head and the tail. For the head,
    we can use `getFirst()` and `peekFirst()`. For the tail, we can use `getLast()`
    and `peekLast()`. Please note that `getFirst()` is the `Deque` equivalent of Queue’s
    `element()`, even though these differ in name quite a bit.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder, why do we have two methods that do the same for all of these.
    They don’t do the same, there’s an important difference. The `getFirst()`, `getLast()`,
    and `element()` methods attempt to retrieve an end of the queue, but if the queue
    is empty, it throws a `NoSuchElementException`. In contrast, the `peek()`, `peekFirst()`,
    and `peekLast()` methods also retrieve the ends of the queue but return `null`
    if the queue is empty, thus they will not throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the elements in a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot change elements in a `Queue` interface directly. To modify an element,
    we must remove the old element and add the new one. So, let’s see how to remove
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can remove elements from a queue using the `remove()` or `poll()` methods.
    These methods do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the head of the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the head of the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is going to store *Task 4* in `removedElement`. At this point, the values
    in the queue will be *Task 3*, *Task 1*, *Task 2*.
  prefs: []
  type: TYPE_NORMAL
- en: This may not surprise you, but for `Deque`, we can remove elements from both
    ends. For the head, we use `removeFirst()` and `pollFirst()`. For the tail, we
    can use `removeLast()` and `pollLast()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the difference is in how they deal with null values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove()`, `removeFirst()`, and `removeLast()` throw a `NoSuchElementException`
    if the queue is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll()`, `pollFirst()`, and `pollLast()` return null without throwing an exception,
    signaling that the queue was empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to remove elements, let’s learn how to iterate through
    a `Queue` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a queue or deque
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can iterate through a queue or deque using a for-each loop. This doesn’t
    remove theiterating through” elements from the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The reason it’s not printing *Task 4* is that we removed it in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered the basics of the four main interfaces and some of the most
    common implementations. We can do more with collections, such as sorting them.
    Let’s have a look at how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve learned how to create collections and how to perform basic operations
    on them. They have a lot of useful built-in methods, and one of them helps us
    sort collections. The reason we are paying attention to this one is because it’s
    not as straightforward as some of the others.
  prefs: []
  type: TYPE_NORMAL
- en: Some types have a natural order, such as numbers. They can be easily sorted
    from small to large. The same goes for strings – we can sort them A-Z. But how
    do we sort a collection that contains custom objects of the `Task` type?
  prefs: []
  type: TYPE_NORMAL
- en: Stick with me – soon, you’ll be able to do both natural ordering and custom
    ordering while using the `sort` method that’s built into collections.
  prefs: []
  type: TYPE_NORMAL
- en: Natural ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we talk about natural ordering, we mean the default sorting order for
    a particular data type. For example, numbers are sorted in ascending order, while
    strings are sorted lexicographically. But still, Java wouldn’t know this without
    us telling them that’s what we want. That’s why Java’s built-in classes, such
    as `Integer` and `String`, implement the `Comparable` interface. This is what
    tells Java what the natural order is. Two interfaces are relevant for ordering:
    `Comparable` and `Comparator`. We will cover these next.'
  prefs: []
  type: TYPE_NORMAL
- en: The Comparable and Comparator interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a class implements the `Comparable` interface, we need to implement the
    `compareTo()` method. Here’s an example of how a class would implement that interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code is omitted, but as you can see it implements the interface. Now it
    needs to override the `compareTo` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method defines how to sort two objects of the same type. The `compareTo()`
    method takes another object of the same type as an argument and returns a negative,
    zero, or positive integer based on how the two objects compare.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the outcomes mean:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the two objects are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive value if the object is greater than the passed-in object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative value if the object the method is called on is less than the passed-in
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Comparator` interface does something similar but is not meant to be implemented
    by a class. This interface is used for creating a custom `Comparator` on the fly
    and is typically implemented with a Lambda expression. We haven’t seen Lambda
    expressions yet, but we will in the next chapter. `Comparator` can be passed to
    the `sort` method, to tell the `sort` method how to sort the items.
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparator` is not for natural sorting orders but for “one-off” sorting orders.
    It contains one method, `compare()`. This method takes two objects as arguments
    and returns a negative, zero, or positive integer based on the comparison. Here
    are what the values mean for the result of compare:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the two objects are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive value if the first object is greater than the second (hence they
    are in the wrong order).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative value if the first object is less than the second (hence they are
    in the right order).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright, enough talking. Let’s see some implementations of `Comparable` and
    `Comparator`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing compareTo()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, there are roughly two options when we want to sort our custom types:'
  prefs: []
  type: TYPE_NORMAL
- en: Give them a natural order by making them implement `Comparable.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement `Comparator` and pass this to the `sort` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the first one. We’re going to give our `Person` class a natural
    order. To implement the natural ordering for a custom class, we need to implement
    the `Comparable` interface and the `compareTo()` method. Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Person` class is given a natural order by implementing the `Comparable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` class now implements `Comparable<Person>`. This means that `Person`
    objects can now be compared to each other based on a natural ordering, which is
    determined by the `compareTo()` method. This method takes one input parameter.
    And it is always going to compare that one to the instance the `compareTo()` was
    called. It should return `0` if the objects are equal, a positive value if the
    object the method is called on is greater than the input parameter, and a negative
    value if the input parameter is bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Person` class has two attributes: `age` (an integer) and `name` (a string).
    The constructor initializes these attributes with the given values. The `compareTo()`
    method is defined to compare `Person` objects based on their age, but we could
    also have chosen the length of the name to just give an example. In this `compareTo()`
    method, we use the `Integer.compare()` method to perform the comparison. It takes
    two integer values as arguments and returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the two integers are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive value if the first integer is greater than the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative value if the first integer is less than the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of the `compareTo()` method, this means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If two `Person` objects have the same age, the method will return `0.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current `Person` object’s age is greater than the other object’s age,
    the method will return a positive value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current `Person` object’s age is less than the other object’s age, the
    method will return a negative value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These return values determine the natural ordering of the `Person` objects
    when they’re sorted. In this case, the objects will be sorted by their age. Let’s
    have a look at how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Before sorting, the elements have the order they were added in. After sorting,
    they are sorted from age low to high, so we get `Huub`, `Anne`, and `Joep`.
  prefs: []
  type: TYPE_NORMAL
- en: But again, since we wrote it, we could have chosen anything. And whatever we
    choose determines the natural order. Natural order is, for example, to sort strings
    A-Z and numbers 0-9\. What the natural order for your custom class is, is up to
    you. It depends on how you implement the `compareTo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we’ll need a different order than specified in the `compareTo()`
    method. For example, sorting strings by the length of the word. Luckily, we can
    also create an order that is not connected to the class. Let’s have a look at
    how to do custom sorting next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing compare()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to implement custom ordering using the `Comparator`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate class (not typical)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an anonymous inner class (better)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement it with a Lambda expression (most common)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to sort a list of `Person` objects by their names, we can create
    this anonymous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new `Comparator` object called `nameComparator` that implements
    the `Comparator` interface. This custom comparator will be used to compare `Person`
    objects based on their names. The `compare()` method is implemented within the
    anonymous inner class. Inside the `compare()` method, we use the `compareTo()`
    method of the `String` class to perform a lexicographic comparison between the
    names of the two `Person` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compare()` method in the `Comparator` interface follows the same rules
    for return values as the `compareTo()` method in the `Comparable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: If the two objects being compared are equal, the method will return `0.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first object is greater than the second, the method will return a positive
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first object is less than the second, the method will return a negative
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the custom comparator to sort a list of `Person` objects, we can pass
    the `nameComparator` object as an argument to the `Collections.sort()` method,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `personList` will be sorted according to the names of the `Person`
    objects in alphabetical order, as specified by `nameComparator`. If we don’t specify
    `nameComparator`, it will use the natural order and sort by age. Before sorting,
    the elements have the order they were added in. After sorting, they are sorted
    by name, A-Z, so we get `Anne`, `Huub`, and `Joep`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Comparator with a Lambda expression
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more common to use a Lambda expression to implement the `Comparator`
    interface. This way, we have a shorter syntax for creating a comparator without
    the need for an anonymous inner class. You don’t need to understand this yet,
    but here’s an example of using a Lambda expression to create a comparator that
    sorts Person objects by their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparator<Person> nameComparatorLambda = (p1,` `p2) ->`'
  prefs: []
  type: TYPE_NORMAL
- en: '`p1.getName().compareTo(p2.getName());`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This works the same. We can pass it as an argument to the `Collections.sort()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collections.sort(personList, nameComparatorLambda);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we now have custom comparators, we can create as many as we can think
    of. Here’s another example of sorting `Person` objects by the length of their
    names using a Lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Comparator<Person> nameLengthComparator = (p1,` `p2) ->`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Integer.compare(p1.getName().length(),`'
  prefs: []
  type: TYPE_NORMAL
- en: '`p2.getName().length());`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collections.sort(personList, nameLengthComparator);`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `nameLengthComparator` compares `Person` objects based on the length of
    their names. `personList` will be sorted in ascending order of the name lengths.
    Our names all have a length of four, and therefore they will remain in the order
    they were added.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using `Comparator` over the natural order defined by the `Comparable`
    interface is that you can define multiple custom orderings for the same class
    without modifying the class itself. In addition, we can easily change the ordering
    criteria at runtime by providing a different `Comparator` object to the `Collections.sort()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Which option we choose depends on what we need. If we want to give our object
    a natural order, we have to implement the `Comparable` interface. If we don’t
    have access to the class directly, or we want to specify an order that should
    not be the natural order, we can use `Comparator`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use comparators when we create `TreeSets` and `TreeMaps`. This will
    determine how the values in these collections are going to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: TreeSets and TreeMaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TreeSet` and `TreeMap` are sorted collections that use the natural order of
    their elements or a custom comparator for sorting. This is why we cannot create
    `TreeSets` or `TreeMaps` for objects that don’t have a natural order (they don’t
    implement the `Comparable` interface) without providing a custom comparator during
    the creation of `TreeSet` or `TreeMap`. Let’s see how to do this for each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: The order of elements in TreeSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a quick reminder, `TreeSet` is a `Set` implementation that stores elements
    in sorted order. That’s why the elements in `TreeSet` must implement the `Comparable`
    interface or a custom comparator must be passed along during the construction
    of `TreeSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of creating a `TreeSet` class of `Person` objects using the
    natural order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Person` class implements the `Comparable` interface, so
    `TreeSet` will use the natural order defined by the `compareTo()` method in the
    `Person` class (this was sorted by age).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a `TreeSet` class with a custom comparator, you can pass
    the comparator as an argument to the `TreeSet` constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `TreeSet` will be sorted by the names of the `Person` objects,
    as specified by `nameComparator`. We can do something similar for `TreeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The order of elements in TreeMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you’ve forgotten, `TreeMap` is a `Map` implementation that stores key-value
    pairs in a sorted order based on the keys. That’s why the keys in `TreeMap` must
    implement the `Comparable` interface or we should send in a custom comparator
    when we create `TreeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a `TreeMap` class of `Person` objects as keys and their ages
    as values using the natural order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Person` class implements the `Comparable` interface, so
    `TreeMap` will use the natural order defined by the `compareTo()` method in the
    `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create a `TreeMap` class with a custom comparator, you can pass
    the comparator as an argument to the `TreeMap` constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, this `TreeMap` will be sorted by the names of the `Person` objects, as
    specified by `nameComparator`.
  prefs: []
  type: TYPE_NORMAL
- en: So, `TreeSet` and `TreeMap` are sorted collections that use either the natural
    order of their elements or a custom comparator to sort their contents.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `Comparable` interface and custom comparators, you can define multiple
    orderings for your custom classes and easily control the sorting behavior of your
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Working with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been working with generics in this chapter. Generics are flexible and
    used for (amongst others) collections. We were passing in values to these collections
    by the specified type between the angle brackets. We can create a collection with
    a type parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `List` interface and the `ArrayList` class are created with
    a type parameter (generic). This makes the class a lot more flexible, while still
    ensuring type safety. Let’s have a look at how this was done before generics to
    understand why they are so great.
  prefs: []
  type: TYPE_NORMAL
- en: Life before generics – objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we didn’t have generics, all collections would have objects. You’d have
    to manually check to make sure the item in the list was of the type you hoped
    it was. And if it was, you’d have to cast it to this type to use this, much like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a list without specifying any type. This creates
    a list of the `Object` type. And as you probably remember, all Java objects are
    of the `Object` type. Then, we added two strings and an integer to it. This is
    technically allowed since the list accepts objects of any type, but it can lead
    to logical errors in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Later, when we iterate over the list, we must manually check the type of each
    item with `instanceof` before we can safely cast it to a string with `(String)
    item`. If we try to cast an item of the wrong type, the code will throw a `ClassCastException`
    error at runtime. This can be time-consuming and error-prone, which is one of
    the main reasons why generics were introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a closer look at generics and see them outside of the collection
    use case. We’ll learn how to create a class with a generic and why we would do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Use case of generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating two types that we are going to be putting in a bag class.
    We’ll do this first without generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a public `class` called `Laptop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a public `class` called `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A book and a laptop are typical things to store in a bag. Let’s write the Java
    code to do this. Without generics, we would need two classes. The first will be
    for `Laptop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The second will be for `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two custom classes, `Laptop` and `Book`, and two bag classes,
    `LaptopBag` and `BookBag`, each holding a specific type of item. However, there
    is a lot of duplicate code in the `LaptopBag` and `BookBag` classes. We could
    solve this by, instead of making `Bag` specific for one type, allowing it to hold
    `Object` types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This class allows us to add a `Laptop`, `Book`, or `Person` class. Pretty much
    anything – it doesn’t care. But that comes with some disadvantages as well. Since
    the `ObjectBag` class can store any type of object, there is no way to ensure
    type safety at compile time. This can lead to runtime exceptions, such as `ClassCastException`,
    if we accidentally mix different types of objects in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Very much related to this is the casting we need to do when retrieving an object
    from `ObjectBag`. To get access to all its methods and fields, we need to explicitly
    cast it back to its original type. This adds verbosity to our code and increases
    the chances of getting a `ClassCastException` error.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, generics come to the rescue! Generics offer a way to create flexible
    and type-safe classes that can handle different types without the disadvantages
    associated with using an `Object` type. So, let’s see how we can rewrite the `ObjectBag`
    class using generics.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generics are used by specifying a type parameter within angle brackets, such
    as `<T>`, where `T` represents a type. Here’s a generic solution that uses a single
    `Bag` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the generic type parameter, `<T>`, we can now create a more flexible
    `Bag` class that can hold any type of item, such as `Laptop` or `Book`. At the
    same time, we can ensure type safety and avoid the need for explicit casting.
    Here’s how we can use the `Bag` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To conclude, generics add flexibility when you’re creating reusable classes,
    all while maintaining type safety. However, sometimes, we may want to restrict
    the types that can be used with a generic class. This is where bounded generics
    come into play. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without bounded generics, we may run into situations where we need to call methods
    specific to a certain type or its subclasses within the generic class. We cannot
    do that directly as the generic class knows nothing about the specific methods
    of the types it handles. Here’s a short example to illustrate the need for bounded
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have an interface called `Measurable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to have a class that is a lot like `Bag`, but only accepts generics
    that implement the `Measurable` interface. That’s why we need to create a generic
    `MeasurementBag` class that can only hold objects that implement the `Measurable`
    interface. We can use bounded generics to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By using `<T extends Measurable>`, we specify that the generic type, `T`, must
    be a class that implements the `Measurable` interface. This ensures that only
    objects of types that implement `Measurable` can be used with the `MeasurementBag`
    class. That’s why we can safely call the `getMeasurement()` method within the
    `MeasurementBag` class – since we know that `T` is guaranteed to implement the
    `Measurable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: So, these bounded generics allow us to restrict the types that are used in the
    generic class and ensure that they share a common set of methods. That’s why it’s
    safe to call those methods within the generic class. Does this sound familiar
    to what collections do? For example, `Collections.sort()` requires a collection
    with objects that implement `Comparable` when we only pass in one argument (the
    collection). Generics and bounded type parameters are actually very common in
    Java’s own code.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen bounded generics that specify an upper bound (a superclass
    or interface) for the generic type. This ensures that only objects of that type
    or its subclasses can be used with the generic class. There are also lower bounds,
    but these are out of scope here. You may run into these in the Java source code,
    but it’s not very likely you’ll be working with these yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into another concept that’s important for using custom objects with
    `HashMap` and `HashSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing and overriding hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hashing is an important concept in Java. It is used to efficiently store and
    retrieve data in various data structures, such as `HashMaps` and `HashSets`. It’s
    also a very interesting topic. You’ll get quite far without understanding what
    this does, but at some point, you may wonder about the horrible performance of
    your `HashMap` class. And understanding what is going on is not possible without
    understanding hashing. So, let’s discuss the basic concepts of hashing, the role
    of the `hashCode()` method in collections, and best practices for overriding the
    `hashCode()` method in your custom classes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic hashing concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hashing is a method that transforms data into a piece of code called a hash
    code. Think of it like taking a huge pile of books and assigning each book a unique
    number. A good hash function should give different books different numbers and
    spread them evenly. This makes it easy to find and organize the books. All objects
    in Java have a `hashCode()` method.
  prefs: []
  type: TYPE_NORMAL
- en: hashCode() and its role in collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Object` class has the `hashCode()` method defined. Since all classes inherit
    from `Object` (indirectly), all the objects have the `hashCode()` method. This
    method returns an integer value. Two objects that are the same should have the
    same hash code.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an object in a `HashMap` or `HashSet` class, its `hashCode()` is
    used to decide its position in the data structure. When we create custom classes,
    we sometimes need to override `hashCode()`.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding hashCode() and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a custom class and plan to use it as a key in a `HashMap` class
    or an element in a `HashSet` class, we need to override the `hashCode()` method.
    This ensures that our class has a consistent and efficient hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices for overriding `hashCode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Include all fields that are used in the `equals()` method. This way, equal objects
    have the same hash code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a simple algorithm to combine the hash codes of individual fields, such
    as multiplying by a prime number and adding the hash codes of the fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of `hashCode()` implemented in our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `hashCode()` method has been added.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining hashCode() in more detail
  prefs: []
  type: TYPE_NORMAL
- en: The numbers `17` and `31` are used as part of the hash code calculation for
    the `Person` class. These are both prime numbers and using prime numbers in hash
    code calculations helps to produce a better distribution of hash codes and reduces
    the likelihood of hashcode collisions. `17` is used as the initial value for the
    result variable. It’s an arbitrary prime number that helps ensure that the hash
    code calculation starts with a non-zero value.
  prefs: []
  type: TYPE_NORMAL
- en: By doing so, it reduces the likelihood of generating similar hash codes for
    different objects, which, in turn, helps minimize collisions. `31` is used as
    a multiplier in the hashcode calculation. Multiplying the current result by a
    prime number (`31`, in this case) before adding the next field’s hash code helps
    mix the hash codes of individual fields more effectively. This results in a better
    distribution of hash codes across the possible range. `31` is often chosen because
    it can be computed efficiently using bitwise operations (that is, `x * 31` is
    the same as `(x << 5) -` `x)`).
  prefs: []
  type: TYPE_NORMAL
- en: Using hashCode() in custom generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating custom generic classes, we may need to use the `hashCode()` method
    of the objects being stored. To do this, we can simply call the `hashCode()` method
    on the object or use the `Objects.hashCode()` utility method, which handles null
    values gracefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Understanding hashing and the `hashCode()` method is important when working
    with Java collections, especially when using custom classes combined with hashed
    collections. If we follow best practices for overriding `hashCode()` and using
    it in custom generic types, we can achieve better performance when adding and
    accessing elements in our collections.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may not have noticed directly, but we’ve been longing for this! We can
    finally add collections and generics to the applications of our apps. Life will
    get easier. Let’s look at some exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Our park has an assortment of dinosaurs and their related data. Implement a
    `List` interface that stores a custom dinosaur class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to ensure that the most dangerous dinosaurs are taken care of first.
    Write a `PriorityQueue` class that sorts dinosaurs based on a custom `Comparator`
    interface, such as their danger level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics can make our code more reusable. Create a class called `Crate` with
    a generic for the thing you’d like to store in there. This could be food or drinks
    for the restaurant, but also dinosaurs if we need to relocate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three instances of your `Crate` class with different classes in your
    program – for example, `Dinosaur`, `Jeep`, and `DinosaurFood`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hashing is essential for efficient data handling. Override the `hashCode()`
    method in your dinosaur class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Challenging: We have some issues with finding personnel for the restaurants.
    Let’s automate the ordering at the ice cream store in our park. Write a program
    that does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask how many ice creams the guest would list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For every ice cream, ask what flavor they would like (come up with a few choices
    for flavors, make them dinosaur-themed if you dare) and how many scoops.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, let’s assume that each guest can only order every flavor once.
    Add all the ice creams and their descriptions to a `List` interface that contains
    maps. These maps will represent the ice creams and the amount of scoops.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Challenging: Elaborate on *Exercise 13.6*. Print the order (loop over the list!)
    and say it will be ready at the current time plus 10 minutes (you need to calculate
    this, not print that literally!)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – advanced dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the number of dinosaurs in our park increases, the need for a more sophisticated
    data management system becomes apparent. Generics and collections to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to build on the dinosaur care system. The system should handle
    collections of dinosaurs, allowing functionalities such as sorting dinosaurs based
    on various parameters, ensuring the uniqueness of dinosaurs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the steps we’re going to take.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Add additional** **Java classes**:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package named `collections`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this package, create a class named `DinosaurComparator`. This class should
    implement `Comparator<Dinosaur>`. Override the `compare()` method to sort dinosaurs
    based on various parameters, such as age, size, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Normally you don’t create a class for comparator, but we don’t see lambdas until
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Extend the dinosaur** **care system**:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `List` interface in the `DinosaurCareSystem` class that holds the
    `Dinosaur` objects to a `Set` interface. This will ensure the uniqueness of the
    dinosaurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method called `sortDinosaurs()` that sorts the `Dinosaur` set using
    `DinosaurComparator`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some sample code to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the `DinosaurComparator` class that you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Interact with** **the system**:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `main` class, you can interact with the `DinosaurCareSystem` object
    similar to what did in the previous steps, but now, add the functionality to sort
    the dinosaurs based on the parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want more? You can expand on this by adding more functionalities, such
    as sorting based on different parameters, searching for dinosaurs based on their
    properties, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, you’ve made your way through another tough chapter. In this chapter,
    we explored the fundamentals of collections and generics in Java. We began by
    discussing the need for collections in programming and provided an overview of
    the different collection types available in Java, including `List`, `Set`, `Map`,
    `Queue`, and `Deque`. We examined the specific implementations of each collection
    type, such as `ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, `HashMap`, `TreeMap`,
    and more, along with their differences and appropriate use cases. We also covered
    basic operations, such as adding, removing, and iterating through elements in
    each collection.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to sorting collections. We made the distinction between natural
    ordering and custom ordering with the use of the `Comparable` and `Comparator`
    interfaces. We learned how to implement the `compareTo()` and `compare()` methods,
    as well as how to sort lists, sets, and maps using `Collections.sort()` and the
    `TreeSet` and `TreeMap` classes.
  prefs: []
  type: TYPE_NORMAL
- en: We then delved into generics, explaining their importance in providing type
    safety. The syntax and basic usage of generics were demonstrated, including the
    use of the `extends` keyword in bounded generics.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we proceeded to learn how to create custom generic types by defining generic
    classes. We also covered the implications of not having generics, and how to create
    instances of generic types.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we discussed basic hashing concepts and the role of the `hashCode()`
    method in collections. We provided guidelines for overriding `hashCode()` and
    best practices for its implementation, emphasizing its significance in custom
    generic types.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have gained a solid understanding of the differences
    between `List`, `Set`, `Map`, and `Queue`, as well as have basic knowledge of
    working with generics and hashing. You are now ready for the next exciting topic:
    Lambda expressions.'
  prefs: []
  type: TYPE_NORMAL
