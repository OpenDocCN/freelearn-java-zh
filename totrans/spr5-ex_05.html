<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Reactive Web Clients</h1>
                </header>
            
            <article>
                
<p class="mce-root">Until now, we have created the whole project infrastructure to consume the Twitter stream. We have created an application which stores the tracked hashtags.</p>
<p>In this chapter, we will learn how to use the Spring Reactive Web Client and make HTTP calls using the reactive paradigm, which is one of the most anticipated features of Spring 5.0. We will call the Twitter REST APIs asynchronously and use the Project Reactor to provide an elegant way to work with streams.</p>
<p>We will be introduced to Spring Messaging for the RabbitMQ. We will interact with the RabbitMQ broker using the Spring Messaging API and see how Spring helps developers use the high-level abstractions for that.</p>
<p>At the end of this chapter, we will wrap up the application and create a docker image.</p>
<p>In this chapter, we will learn about:</p>
<ul>
<li>Reactive web clients</li>
<li>Spring Messaging for RabbitMQ</li>
<li>RabbitMQ Docker usage</li>
<li>Spring Actuator</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Twitter Gathering project</h1>
                </header>
            
            <article>
                
<p>We learned how to create Spring Boot projects with the amazing Spring Initializr. In this chapter, we will create a project in a different way, to show you an alternative way of creating a Spring Boot project.</p>
<p>Create the <kbd>tweet-gathering</kbd> folder, in any directory. We can use the following command:</p>
<pre><strong>mkdir tweet-gathering</strong></pre>
<p>Then, we can access the folder created previously and copy the <kbd>pom.xml</kbd> file located at <span>GitHub: </span><a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/pom.xml</a>. </p>
<p>Open the <kbd>pom.xml</kbd> on IDE.</p>
<p>There are some interesting dependencies here.  The <kbd>jackson-module-kotlin</kbd> helps to work with JSON in Kotlin language. Another interesting dependency is <kbd>kotlin-stdlib</kbd>, which provides the Kotlin standard libraries in our classpath.</p>
<p>In the plugin sections, the most important plugin is the <kbd>kotlin-maven-plugin</kbd>, which permits and configures the build for our Kotlin code.</p>
<p>In the next section, we will create a folder structure to start the code.</p>
<p>Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project structure</h1>
                </header>
            
            <article>
                
<p>The project structure follows the maven suggested pattern. We will code the project in the Kotlin language, then we will create a <kbd>kotlin</kbd> folder to store our code.</p>
<p>We made that configuration on the <kbd>pom.xml</kbd> created before, so it will work fine. Let's take a look at the correct folder structure for the project:</p>
<div class="CDPAlignCenter CDPAlign"><img height="326" src="assets/438c8a02-e527-43ec-ad1c-c769881b21b2.png" width="456"/></div>
<p>As we can see, the base package is the <kbd>springfive.twittergathering</kbd> package. Then, we will start to create sub-packages in this package as soon.</p>
<p><span>Let's create our infrastructure for the microservice.</span></p>
<div class="packt_infobox">The full source code can be found at <span>GitHub:  </span><a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter05/tweet-gathering.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting the RabbitMQ server with Docker</h1>
                </header>
            
            <article>
                
<p>We can use Docker to spin up the RabbitMQ server. We do not want to install the server on our developer machines as it can create library conflicts and a lot of files. Let's understand how to start RabbitMQ in a Docker container.</p>
<p>Let's do that in the next couple of sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pulling the RabbitMQ image from Docker Hub</h1>
                </header>
            
            <article>
                
<p>We need to pull the RabbitMQ image from Docker Hub. We will use the image from the official repository as it is more safe and reliable.</p>
<p>To get the image, we need to use the following command:</p>
<pre><strong>docker pull rabbitmq:3.7.0-management-alpine</strong></pre>
<p>Wait for the download to end and then we can move forward to the next section. In the next section, we will learn how to set up the RabbitMQ server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting the RabbitMQ server</h1>
                </header>
            
            <article>
                
<p>To start the RabbitMQ server, we will run the Docker command. There are some considerations which we need to pay attention to; we will run this container on the Twitter Docker network created previously, but we will expose some ports on the host, as it makes it easier to interact with the broker.</p>
<p>Also, we will use the management image because it provides a page which enables us to manage and see the RabbitMQ information on something similar to a control panel.</p>
<p>Let's run:</p>
<pre><strong>docker run -d --name rabbitmq --net twitter -p 5672:5672 -p 15672:15672 rabbitmq:3.7.0-management-alpine</strong></pre>
<p>Wait for a few seconds so that RabbitMQ establishes the connections and then we can connect to the management page. To do that, go to <kbd>http://localhost:15672</kbd> and log on to the system. The default user is <span class="packt_screen">guest</span>, and the password is <kbd>guest</kbd> as well. The control panel looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="479" src="assets/a1d84684-2304-4d27-baec-65b63d1ff099.png" width="883"/></div>
<p>There is a lot of interesting information on the panel, but for now, we are going to explore the channels and some interesting parts.</p>
<p>Awesome. Our RabbitMQ server is up and running. We will use the infrastructure soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Messaging AMQP</h1>
                </header>
            
            <article>
                
<p>This project supports the AMQP-based messaging solutions. There is a high-level API to interact with desired brokers. These interactions can send and receive messages from a broker. </p>
<p>Like in the other Spring projects, these facilities are provided by the <em>template</em> classes, which expose the core features provided by the broker and implemented by the Spring Module.</p>
<p>This project has two parts: <kbd>spring-amqp</kbd> is the base abstraction, and <kbd>spring-rabbit</kbd> is the RabbitMQ implementation for RabbitMQ. We will use <kbd>spring-rabbit</kbd> because we are using the RabbitMQ broker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Spring AMQP in our pom.xml</h1>
                </header>
            
            <article>
                
<p>Let's add the <kbd>spring-amqp</kbd> jars to our project. <kbd><span>spring-amqp</span></kbd> has a starter dependency which configures some common things for us, such as <kbd>ConnectionFactory</kbd> and <kbd>RabbitTemplate</kbd>, so we will use that. To add this dependency, we will configure our <kbd>pom.xml</kbd> follows:</p>
<pre style="padding-left: 60px"><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-amqp<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>The next step is to configure the connections; we will use the <kbd>application.yaml</kbd> file because we are using the starter. In the next section, we will do the configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating Spring Application and RabbitMQ</h1>
                </header>
            
            <article>
                
<p>We have configured the <kbd>spring-amqp</kbd> dependencies in our project. Now, it is time to configure the RabbitMQ connections properly. We will use the <kbd>RabbitMQTemplate</kbd> to send messages to the broker; this has some converters which help us convert our domain models into JSON and vice versa.</p>
<p>Let's configure our RabbitMQ connections. The configurations should be in the <kbd>application.yaml</kbd> file and should look like this:</p>
<pre style="padding-left: 60px"><span>spring:<br/></span><span>  rabbitmq:<br/></span><span>    host: </span>localhost<br/>    <span>username: </span>guest<br/>    <span>password: </span>guest<br/>    <span>port: </span><span>5672</span></pre>
<p>As we can see, some Spring configurations are quite similar to others, the same style, and the node in <kbd>yaml</kbd> is the name of the technology followed by a couple of attributes.</p>
<p>We are using the default credentials for the RabbitMQ. The host and port are related to the RabbitMQ Broker address. The configuration is quite simple but does a lot of things for us such as <kbd>ConnectionFactory</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding RabbitMQ exchanges, queues, and bindings</h1>
                </header>
            
            <article>
                
<p>We are doing some interesting things with RabbitMQ. We configured connections successfully. There are some other things that we have not done yet, such as configuring the exchanges, queue, and bindings, but before we do that, let's understand a little bit more about these terms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exchanges</h1>
                </header>
            
            <article>
                
<p>Exchanges are RabbitMQ entities where the messages are sent. We can make an analogy with a river where the water is flowing; the river is the course of the messages. There are four different kinds of exchanges which we will understand in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Direct exchanges</h1>
                </header>
            
            <article>
                
<p>The direct exchanges allow for route messages based on the routing key. The name is self-explanatory, it permits to send the messages directly to the specified customer, who is the one listening to the exchange. Remember, it uses the routing key as the argument to route the message to the customers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fanout exchanges</h1>
                </header>
            
            <article>
                
<p>The fanout exchanges route the messages for all the queues bound independently of the routing key. All the bound queues will receive the message sent to fanout exchanges. They can be used to have the topic behavior or distributed listings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Topic exchanges</h1>
                </header>
            
            <article>
                
<p>The topic exchanges are similar to direct exchanges, but topic exchanges enable us to use pattern matching as compared to the direct exchanges, which permit only the exact routing key. We will use this exchange in our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Header exchanges</h1>
                </header>
            
            <article>
                
<p>Header exchanges are self-explanatory, the behavior is like the topic exchange, but instead of using the routing key, it uses the header attributes to match the correct queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queues</h1>
                </header>
            
            <article>
                
<p>Queues are the buffer where the exchanges will write the messages respecting the routing key. Queues are the place where consumers get the messages which are published to exchanges. Messages are routed to queues depending on the exchange type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bindings</h1>
                </header>
            
            <article>
                
<p>Binding can be thought of as a link between exchanges and queues. We can say that it is a kind of traffic cop which instructs the messages where they should be redirected based on the configuration, in this case, links.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring exchanges, queues, and bindings on Spring AMQP</h1>
                </header>
            
            <article>
                
<p>The Spring AMQP project has abstractions for all the RabbitMQ entities listed previously, and we need to configure it to interact with the broker. As we did in other projects, we need a <kbd>@Configuration</kbd> class, which will declare the beans for the Spring container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring exchanges, queues, and bindings in yaml</h1>
                </header>
            
            <article>
                
<p>We need to configure the entity names to instruct the framework to connect with the broker entities. We will use the <kbd>application.yaml</kbd> file to store these names, since it is easier to maintain and is the correct way to store application infrastructure data.</p>
<p>The section with the entity names should look like this snippet:</p>
<pre style="padding-left: 60px"><span>queue:<br/></span><span>  twitter: </span>twitter-stream<br/><span>exchange:<br/></span><span>  twitter: </span>twitter-exchange<br/><span>routing_key:<br/></span><span>  track: </span>track.*</pre>
<p>The properties are self-explanatory, the <kbd>exchange</kbd> node has the name of the exchange, the <kbd>queue</kbd> node has the queue name, and finally, the <kbd>routing_key</kbd> node has the routing argument.</p>
<p>Awesome. The properties are configured, and now we will create our <kbd>@Configuration</kbd> class. Let's do that in the next section. We are almost ready to interact with the RabbitMQ broker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring Spring beans for RabbitMQ</h1>
                </header>
            
            <article>
                
<p>Now, let's create our configuration class. The class is pretty simple and as we will see with the Spring abstraction, they are easy to understand too, especially because the class names allude to the RabbitMQ entities.</p>
<p>Let's create our class:</p>
<pre><span>package </span>springfive.twittergathering.infra.rabbitmq<br/><br/><span>import </span>com.fasterxml.jackson.databind.ObjectMapper<br/><span>import </span>com.fasterxml.jackson.module.kotlin.KotlinModule<br/><span>import </span>org.springframework.amqp.core.Binding<br/><span>import </span>org.springframework.amqp.core.BindingBuilder<br/><span>import </span>org.springframework.amqp.core.Queue<br/><span>import </span>org.springframework.amqp.core.TopicExchange<br/><span>import </span>org.springframework.amqp.support.converter.Jackson2JsonMessageConverter<br/><span>import </span>org.springframework.beans.factory.annotation.<span>Value<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span><br/></span><span>@Configuration<br/></span><span>open class </span>RabbitMQConfiguration(<span>@Value</span>(<span>"</span><span>\$</span><span>{queue.twitter}"</span>) <span>private val </span><span>queue</span>:String<span>,<br/></span><span>                                 @Value</span>(<span>"</span><span>\$</span><span>{exchange.twitter}"</span>) <span>private val        <br/></span><span>exchange</span>:String<span>,<br/></span><span>                                 @Value</span>(<span>"</span><span>\$</span><span>{routing_key.track}"</span>) <span>private val </span><span>routingKey</span>:String){<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><strong>queue():Queue</strong>{<br/>        <span>return </span>Queue(<span>this</span>.<span>queue</span><span>,false</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><strong>exchange():TopicExchange</strong>{<br/>        <span>return </span>TopicExchange(<span>this</span>.<span>exchange</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><strong>binding(queue: Queue, exchange: TopicExchange): Binding</strong> {<br/>        <span>return </span>BindingBuilder.bind(queue).to(exchange).with(<span>this</span>.<span>routingKey</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>converter</span>(): Jackson2JsonMessageConverter {<br/>        <span>return </span>Jackson2JsonMessageConverter(ObjectMapper().registerModule(KotlinModule()))<br/>    }<br/><br/>}</pre>
<p>There are interesting things to pay attention to here. In the <kbd>RabbitMQConfiguration</kbd> constructor, we injected the values configured in the <kbd>application.yaml</kbd> file to name the entities. After that, we started to configure the Spring beans for the container to allow it to inject them into the Spring-managed classes. The key point here is that if they do not exist in the RabbitMQ broker, Spring will create them. Thanks, Spring, we appreciate that and love how helpful that is. </p>
<p>We can see the DSL to declare <kbd>Binding</kbd>, it makes the developer's life easier and prevents errors in the code.</p>
<p>On the last part of the class, we declared the <kbd>Jackson2JsonMessageConverter</kbd>. These converters are used to convert the domain models in JSON and vice versa. It enables us to receive the domain object on Listener instead of an array of bytes or strings. The same behavior can be used in the <kbd>Producers</kbd>, we are able to send the domain object instead of JSON. </p>
<p>We need to supply the <kbd>ObjectMapper</kbd> to <kbd>Jackson2JsonMessageConverter</kbd>, and we have used the Kotlin module because of the way Kotlin handles data classes, which do not have no-args constructors.</p>
<p>Excellent job! Our infrastructure is fully configured. Let's code the producers and consumers right now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming messages with Spring Messaging</h1>
                </header>
            
            <article>
                
<p>Spring AMQP provides the <kbd>@RabbitListener</kbd> annotation; it will configure the subscriber for the desired queue, it removes a lot of infrastructure code, such as connect to <kbd><span>RabbitListenerConnectionFactory</span></kbd>, and creates a consumer programmatically. It makes the creation of queue consumers really easy.</p>
<p>The <kbd>spring-boot-starter-amqp</kbd> provides some automatic configurations for us. When we use this module, Spring will <span>automatically </span><span>create a </span><span><kbd>RabbitListenerConnectionFactory</kbd> for us and configure the Spring converters to convert JSON to domain classes automatically.</span></p>
<p>Pretty simple. Spring AMQP really provides a super high-level abstraction for developers.</p>
<p>Let's see an example which will be used in our application soon:</p>
<pre style="padding-left: 60px"><strong>@RabbitListener(queues = ["twitter-track-hashtag"])</strong><br/><span>fun </span><span>receive</span>(hashTag:TrackedHashTag) {<br/>...<br/>}</pre>
<div class="packt_infobox">The full source code can be found at GitHub: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter05/tweet-gathering/src/main/kotlin/springfive/twittergathering/domain/service/TwitterGatherRunner.kt.</a></div>
<p>A piece of cake. The code is really easy to understand and it makes it possible to pay attention only to the business rules. The infrastructure is not a good thing to maintain because this does not bring real value to the business, as it is only a piece of technology. Spring tries to abstract the whole infrastructure code to help developers write business code. It is a real asset provided by the Spring Framework.</p>
<p>Thanks, Spring Team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Producing messages with Spring Messaging</h1>
                </header>
            
            <article>
                
<p>The <kbd>spring-amqp</kbd> module provides a <kbd>RabbitTemplate</kbd> class, which abstracts high-level RabbitMQ driver classes. It improves the developer performance and makes the application void of bugs because the Spring modules are a very well-tested set of codes. We will use the <kbd>convertAndSend()</kbd> function which permits to pass <span>exchange, the routing key, and the message object</span> as parameters. Remember this function uses Spring converters to convert our model class into a JSON string.</p>
<p>There are a lot of overloaded functions for <kbd>convertAndSend()</kbd>, and depending on the use case, others could be more appropriate. We will use the simple one as we saw before.</p>
<p>Let's see the piece of code which sends the message to the broker:</p>
<pre style="padding-left: 60px"><span>this</span>.<span>rabbitTemplate</span>.convertAndSend(<span>"twitter-exchange"</span><span>,</span><span>"track.</span><span>${</span>hashTag.<span>queue</span><span>}</span><span>"</span><span>,</span><span>it</span>)</pre>
<p>Good. The first parameter is the <kbd>Exchange</kbd> name, and the second is the <kbd>RoutingKey</kbd>. Finally, we have the message object, which will be converted into a JSON string.</p>
<p>We will see the code in action soon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling Twitter in our application</h1>
                </header>
            
            <article>
                
<p>In this section, we will enable the use of Twitter APIs on our Twitter Gathering application. This application should get Tweets based on the query specified by the user. This query was registered on the previous microservice that we created in the previous chapter.</p>
<p>When the user calls the API to register <kbd>TrackedHashTag</kbd>, the microservice will store the <kbd>TrackedHashTag</kbd> on the Redis database and send the message through the RabbitMQ. Then, this project will start to gather Tweets based on that. This is the data flow. In the next chapter, we will do a reactive stream and dispatch Tweets through our Reactive API. It will be amazing.</p>
<p>However, for now, we need to configure the Twitter credentials; we will do that using Spring beans – let's implement it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Producing Twitter credentials</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>@Configuration</kbd> class to provide our Twitter configuration objects. The <kbd>@Configuration</kbd> class is really good to provide infrastructure beans, if we do not have starter projects for the required module.</p>
<p>Also, we will use the <kbd>application.yaml</kbd> file to store the Twitter credentials. This kind of configuration should not be kept in the source code repository because it is sensitive data and should not be shared with others. Then, the Spring Framework enables us to declare properties in the <kbd>yaml</kbd> file and configures the environment variables to fill these properties at runtime. It is an excellent way to keep sensitive data out of the source code repository.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Twitter credentials in application.yaml</h1>
                </header>
            
            <article>
                
<p>To start configuring the Twitter API in our application, we must provide the credentials. We will use the <kbd>yaml</kbd> file for this. Let's add credentials in our <kbd>application.yaml</kbd>:</p>
<pre style="padding-left: 60px"><span>twitter:<br/></span><span>  consumer-key: </span><strong>${consumer-key}</strong><br/>  <span>consumer-secret: </span><strong>${consumer-secret}</strong><br/>  <span>access-token: </span><strong>${access-token}</strong><br/>  <span>access-token-secret: </span><strong>${access-token-secret}</strong></pre>
<p>Easy peasy. The properties have been declared and then we used the <kbd>$</kbd> to instruct the Spring Framework that this value will be received as an environment variable. Remember, we configured the Twitter account in the previous chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modelling objects to represent Twitter settings</h1>
                </header>
            
            <article>
                
<p>We must create abstractions and an amazing data model for our applications. This will create some models which make the developer's life easier to understand and code. Let's create our Twitter settings models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Twittertoken</h1>
                </header>
            
            <article>
                
<p>This class represents the application token previously configured in Twitter. The token can be used for the application authentication only. Our model should look like this:</p>
<pre style="padding-left: 60px"><span>data class </span>TwitterToken(<span>val </span><span>accessToken</span>: String<span>,val </span><span>accessTokenSecret</span>: String)</pre>
<p>I love the Kotlin way to declare data classes—totally immutable and without boilerplate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TwitterAppSettings</h1>
                </header>
            
            <article>
                
<p><kbd>TwitterAppSettings</kbd> represents the consumer key and consumer secret. It is a kind of identity for our application, from Twitter's perspective. Our model is pretty simple and must look like this:</p>
<pre style="padding-left: 60px"><span>data class </span>TwitterAppSettings(<span>val </span><span>consumerKey</span>: String<span>,val </span><span>consumerSecret</span>: String)</pre>
<p>Good job, our models are ready. It is time to produce the objects for the Spring Container. We will do that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring Twitter credentials for the Spring container</h1>
                </header>
            
            <article>
                
<p>Let's produce our Twitter configuration objects. As a pattern we have been using, we will use the <kbd>@Configuration</kbd> class for that. The class should be as follows:</p>
<pre><span>package </span>springfive.twittergathering.infra.twitter<br/><br/><span>import </span>org.springframework.beans.factory.annotation.<span>Value<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span><br/></span><span><br/></span><span>@Configuration<br/></span><span>open class </span>TwitterConfiguration(<span>@Value</span>(<span>"</span><span>\$</span><span>{twitter.consumer-key}"</span>) <span>private val </span><span>consumerKey</span>: String<span>,<br/></span><span>                                @Value</span>(<span>"</span><span>\$</span><span>{twitter.consumer-secret}"</span>) <span>private val </span><span>consumerSecret</span>: String<span>,<br/></span><span>                                @Value</span>(<span>"</span><span>\$</span><span>{twitter.access-token}"</span>) <span>private val </span><span>accessToken</span>: String<span>,<br/></span><span>                                @Value</span>(<span>"</span><span>\$</span><span>{twitter.access-token-secret}"</span>) <span>private val </span><span>accessTokenSecret</span>: String) {<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>twitterAppSettings</span>(): TwitterAppSettings {<br/>        <span>return </span>TwitterAppSettings(<span>consumerKey</span><span>, </span><span>consumerSecret</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>twitterToken</span>(): TwitterToken {<br/>        <span>return </span>TwitterToken(<span>accessToken</span><span>, </span><span>accessTokenSecret</span>)<br/>    }<br/><br/>}</pre>
<p>Pretty simple and a Spring way to declare beans. We are improving how we use Spring step by step. Well done!</p>
<p>Now, we are done with Twitter configurations. We will consume the Twitter API using the WebClient from the Spring WebFlux, which supports the reactive programming paradigm. Let's understand something before we run the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring reactive web clients</h1>
                </header>
            
            <article>
                
<p>This is a pretty new feature which was added in Spring Framework 5. It enables us to interact with HTTP services, using the reactive paradigm.</p>
<p>It is not a replacement for a <kbd>RestTemplate</kbd> provided by Spring, however, it is an addition to working with reactive applications. Do not worry, the <kbd>RestTemplate</kbd> is an excellent and tested implementation for interaction with HTTP services in traditional applications.</p>
<p>Also, the <kbd>WebClient</kbd> implementation supports the <kbd>text/event-stream</kbd> mime type which can enable us to consume server events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Producing WebClient in a Spring Way</h1>
                </header>
            
            <article>
                
<p>Before we start to call the Twitter APIs, we want to create an instance of <kbd>WebClient</kbd> in a Spring way. It means we are looking for a way to inject the instance, using the Dependency Injection Pattern.</p>
<p>To achieve this, we can use the <kbd>@Configuration</kbd> annotation and create a <kbd>WebClient</kbd> instance, using the <kbd>@Bean</kbd> annotation to declare the bean for the Spring container. Let's do that:</p>
<pre style="padding-left: 60px"><span>package </span>springfive.twittergathering.infra.web<br/><br/><span>import </span>org.springframework.context.annotation.<span>Bean<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span>import </span>org.springframework.web.reactive.function.client.WebClient<br/><span><br/></span><span><strong>@Configuration</strong><br/></span><span>open class </span>WebClientProducer {<br/><br/>    <span><strong>@Bean</strong><br/></span><span>    open fun </span><span>webClient</span>(): WebClient? {<br/>        <span>return </span>WebClient.create()<br/>    }<br/><br/>}</pre>
<p>There are a couple of known annotations in this class; this is a pretty standard way to declare bean instances in a Spring way. It makes it possible to inject an instance of <kbd>WebClient</kbd> in other Spring-managed classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the models to gather Tweets</h1>
                </header>
            
            <article>
                
<p>If we want to consume the Twitter APIs asynchronously and reactively, then we should create the API client. Before we code the client, we need to create our classes for modeling, according to our requirements.</p>
<p>We do not need all Tweets' attributes. We expect the following attributes:</p>
<ul>
<li><kbd>id</kbd></li>
<li><kbd>text</kbd></li>
<li><kbd>createdAt</kbd></li>
<li><kbd>user</kbd></li>
</ul>
<p>Then, we will model our class based on the attributes listed.</p>
<p>Let's start with the user attribute. This attribute is a JSON attribute, and we will create a separated class for that. The class should look like this:</p>
<pre style="padding-left: 60px"><strong>@JsonIgnoreProperties(ignoreUnknown = true)</strong><br/><span>data class </span>TwitterUser(<span>val </span><span>id</span>:String<span>,val </span><span>name</span>:String)</pre>
<p>We have used the Kotlin <kbd>data class,</kbd> it fits our use case well, and we want to use that as a data container. Also, we need to put in <kbd>@JsonIgnoreProperties(ignoreUnknown = true)</kbd> because this annotation instructs the Spring converters to ignore the attribute when it is missing in the JSON response. That is the important part of this portion of code.</p>
<p>We have created the <kbd>TwitterUser</kbd> class, which represents the user who created the Tweet. Now, we will create the <kbd>Tweet</kbd> class which represents the Tweet. Let's create our class:</p>
<pre style="padding-left: 60px"><strong>@JsonIgnoreProperties(ignoreUnknown = true)</strong><br/><span>data class </span>Tweet(<span>val </span><span>id</span>:String<span>, val </span><span>text</span>:String<span>, <strong>@JsonProperty</strong></span>(<span>"created_at"</span>)<span>val </span><span>createdAt</span>:String<span>, val </span><span>user</span>:TwitterUser)</pre>
<p>There are some common things for us and one that's new. The <kbd>@JsonProperty</kbd> permits developers to customize the attribute name on the class which has a different attribute name in JSON; this is common for Java developers because they usually use <em>CamelCase</em> as a way to name attributes, and in JSON notation, people usually use <em>SnakeCase</em>. This annotation can help us to solve this mismatch between the programming language and JSON. </p>
<div class="packt_infobox">We can find a more detailed explanation of snake case <span>here</span>: <a href="https://en.wikipedia.org/wiki/Snake_case">https://en.wikipedia.org/wiki/Snake_case</a>. Also, we can find a full explanation of camel case here: <a href="https://en.wikipedia.org/wiki/Camel_case">https://en.wikipedia.org/wiki/Camel_case</a>.</div>
<p><span>Good. Our API objects are ready. With these objects, we are enabled to interact with the APIs.</span> <span>We will create a service to collect the Tweets. We will do that in the next section. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication with Twitter APIs</h1>
                </header>
            
            <article>
                
<p>With our objects ready, we need to create a class to help us handle the Twitter authentication. We will use the Twitter Application Only Auth authentication model. This kind of authentication should be used for backend applications.</p>
<p>The application using this kind of authentication can:</p>
<ul>
<li>Pull user timelines</li>
<li>Access friends and followers of any account</li>
<li>Access lists and resources</li>
<li>Search in Tweets</li>
<li>Retrieve any user information</li>
</ul>
<p>As we can see, the application is a read-only Twitter API consumer.</p>
<div class="packt_infobox">We can use the Twitter documentation to understand this kind of authentication in detail. The documentation can be found here: <a href="https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request">https://developer.twitter.com/en/docs/basics/authentication/guides/authorizing-a-request.</a></div>
<p>We will follow the Twitter documentation to authorize our request, which is a kind of cooking recipe, so we must follow all the steps. The final class should look like this:</p>
<pre><span>package </span>springfive.twittergathering.infra.twitter<br/><br/><span>import </span>org.springframework.util.StringUtils<br/><span>import </span>springfive.twittergathering.infra.twitter.EncodeUtils.computeSignature<br/><span>import </span>springfive.twittergathering.infra.twitter.EncodeUtils.encode<br/><span>import </span>java.util.*<br/><span><br/></span><span>object </span>Twitter {<br/><br/>    <span>private val </span><span>SIGNATURE_METHOD </span>= <span>"HMAC-SHA1"<br/></span><span><br/></span><span>    </span><span>private val </span><span>AUTHORIZATION_VERIFY_CREDENTIALS </span>= <span>"OAuth " </span>+<br/>            <span>"oauth_consumer_key=</span><span>\"</span><span>{key}</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_signature_method=</span><span>\"</span><span>" </span>+ <span>SIGNATURE_METHOD </span>+ <span>"</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_timestamp=</span><span>\"</span><span>{ts}</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_nonce=</span><span>\"</span><span>{nonce}</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_version=</span><span>\"</span><span>1.0</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_signature=</span><span>\"</span><span>{signature}</span><span>\"</span><span>, " </span>+<br/>            <span>"oauth_token=</span><span>\"</span><span>{token}</span><span>\"</span><span>"<br/></span><span><br/></span><span>    </span><span>fun </span><strong>buildAuthHeader</strong>(appSettings: TwitterAppSettings<span>, </span>twitterToken: TwitterToken<span>, </span>method: String<span>, </span>url: String<span>, </span>query: String):String{<br/>        <span>val </span>ts = <span>"" </span>+ Date().<span>time </span>/ <span>1000<br/></span><span>        </span><span>val </span>nounce = UUID.randomUUID().toString().<span>replace</span>(<span>"-"</span>.<span>toRegex</span>()<span>, </span><span>""</span>)<br/>        <span>val </span>parameters = <span>"oauth_consumer_key=</span><span>${</span>appSettings.<span>consumerKey</span><span>}</span><span>&amp;oauth_nonce=</span><span>$</span>nounce<span>&amp;oauth_signature_method=</span><span>$</span><span>SIGNATURE_METHOD</span><span>&amp;oauth_timestamp=</span><span>$</span>ts<span>&amp;oauth_token=</span><span>${</span>encode(twitterToken.<span>accessToken</span>)<span>}</span><span>&amp;oauth_version=1.0&amp;track=</span><span>${</span>encode(query)<span>}</span><span>"<br/></span><span>        </span><span>val </span>signature = <span>"</span><span>$</span>method<span>&amp;" </span>+ encode(url) + <span>"&amp;" </span>+ encode(parameters)<br/>        <span>var </span>result = <span>AUTHORIZATION_VERIFY_CREDENTIALS<br/></span><span>        </span>result = StringUtils.replace(result<span>, </span><span>"{nonce}"</span><span>, </span>nounce)<br/>        result = StringUtils.replace(result<span>, </span><span>"{ts}"</span><span>, </span><span>"" </span>+ ts)<br/>        result = StringUtils.replace(result<span>, </span><span>"{key}"</span><span>, </span>appSettings.<span>consumerKey</span>)<br/>        result = StringUtils.replace(result<span>, </span><span>"{signature}"</span><span>, </span>encode(computeSignature(signature<span>, </span><span>"</span><span>${</span>appSettings.<span>consumerSecret</span><span>}</span><span>&amp;</span><span>${</span>encode(twitterToken.<span>accessTokenSecret</span>)<span>}</span><span>"</span>)))<br/>        result = StringUtils.replace(result<span>, </span><span>"{token}"</span><span>, </span>encode(twitterToken.<span>accessToken</span>))<br/>        <span>return </span>result<br/>    }<br/><br/>}<br/><br/><span>data class </span>TwitterToken(<span>val </span><span>accessToken</span>: String<span>,val </span><span>accessTokenSecret</span>: String)<br/><br/><span>data class </span>TwitterAppSettings(<span>val </span><span>consumerKey</span>: String<span>,val </span><span>consumerSecret</span>: String)</pre>
<p>It is a recipe. The function, <kbd>buildAuthHeader</kbd>, will create the authorization header using the rules to authorize the request. We have signed some request headers combined with a request body. Moreover, replace the template values with our Twitter credentials objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some words about server-sent events (SSE)</h1>
                </header>
            
            <article>
                
<p>Server-sent events (SSE) is a technology where the server sends events to the client, instead of the client polling the server to check the information availability. The message flow will not get interrupted until the client or server closes the stream.</p>
<p>The most important thing to understand here is the direction of the information flow. The server decides when to send data to a client.</p>
<p>It is very important to handle resource load and bandwidth usage. The client will receive the chunk of data instead to apply load on the server through the polling techniques.</p>
<p>Twitter has a stream API and the Spring Framework WebClient supports SSE. It is time to consume the Twitter stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the gather service</h1>
                </header>
            
            <article>
                
<p>The <kbd>TweetGatherService</kbd> will be responsible for interacting with Twitter APIs and collecting the request tweets according to the requested hashtag. The service will be a Spring bean with some inject attributes. The class should look like this:</p>
<pre><span>package </span>springfive.twittergathering.domain.service<br/><br/><span>import </span>com.fasterxml.jackson.annotation.<span>JsonIgnoreProperties<br/></span><span>import </span>com.fasterxml.jackson.annotation.<span>JsonProperty<br/></span><span>import </span>org.springframework.http.MediaType<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span>import </span>org.springframework.web.reactive.function.BodyInserters<br/><span>import </span>org.springframework.web.reactive.function.client.WebClient<br/><span>import </span>reactor.core.publisher.Flux<br/><span>import </span>springfive.twittergathering.infra.twitter.Twitter<br/><span>import </span>springfive.twittergathering.infra.twitter.TwitterAppSettings<br/><span>import </span>springfive.twittergathering.infra.twitter.TwitterToken<br/><br/><span><br/></span><span>@Service<br/></span><span>class </span>TweetGatherService(<span>private val </span><span>twitterAppSettings</span>: TwitterAppSettings<span>,<br/></span><span>                         private val </span><span>twitterToken</span>: TwitterToken<span>,<br/></span><span>                         private val </span><span>webClient</span>: WebClient) {<br/><br/>    <span>fun </span><span>streamFrom</span>(query: String): <strong>Flux&lt;Tweet&gt;</strong> {<br/>        <span>val </span>url = <span>"https://stream.twitter.com/1.1/statuses/filter.json"<br/></span><span>        </span><span>return this</span>.<span>webClient</span>.mutate().baseUrl(url).build()<br/>                .post()<br/>                .<strong>body(BodyInserters.fromFormData("track", query))</strong><br/>                .header(<span>"Authorization"</span><span>, </span>Twitter.buildAuthHeader(<span>twitterAppSettings</span><span>, </span><span>twitterToken</span><span>, </span><span>"POST"</span><span>, </span>url<span>, </span>query))<br/>                .accept(MediaType.<span>TEXT_EVENT_STREAM</span>)<br/>                .retrieve().bodyToFlux(Tweet::<span>class</span>.<span>java</span>)<br/>    }<br/><br/>}<br/><br/><span>@JsonIgnoreProperties</span>(<span>ignoreUnknown = </span><span>true</span>)<br/><span>data class </span>Tweet(<span>val </span><span>id</span>: String = <span>""</span><span>, val </span><span>text</span>: String = <span>""</span><span>, @JsonProperty</span>(<span>"created_at"</span>) <span>val </span><span>createdAt</span>: String = <span>""</span><span>, val </span><span>user</span>: TwitterUser = TwitterUser(<span>""</span><span>, </span><span>""</span>))<br/><br/><span>@JsonIgnoreProperties</span>(<span>ignoreUnknown = </span><span>true</span>)<br/><span>data class </span>TwitterUser(<span>val </span><span>id</span>: String<span>, val </span><span>name</span>: String)</pre>
<p>There are some important points here. The first is the function declaration; take a look at <kbd>Flux&lt;Tweet&gt;</kbd>, it means the data can never get interrupted because it represents the N values. In our case, we will consume the Twitter stream until the client or server interrupts the data flow. </p>
<p>After that, we configured the HTTP request body with our desired track to get events. After that, we configured the Accept HTTP header; it is essential to instruct the WebClient what kind of mime type it needs to consume.</p>
<p>Finally, we have used our <kbd>Twitter.buildAuthHeader</kbd> function to configure the Twitter authentication.</p>
<p>Awesome, we are ready to start to consume the Twitter API, and we only need to code the trigger to use that function. We will do that in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening to the Rabbit Queue and consuming the Twitter API</h1>
                </header>
            
            <article>
                
<p>We will consume the Twitter API, but when?</p>
<p>We need to start to get Tweets when the request for tracking the hashtags comes to our application. To reach that goal, we will implement the RabbitMQ Listener when the <kbd>TrackedHashTag</kbd> gets registered on our microservice. The application will send the message to the broker to start consuming the Twitter stream.</p>
<p>Let's take a look at the code and step by step understand the behaviors; the final code should look like this:</p>
<pre><span>package </span>springfive.twittergathering.domain.service<br/><br/><span>import </span>org.springframework.amqp.rabbit.annotation.<span>RabbitListener<br/></span><span>import </span>org.springframework.amqp.rabbit.core.RabbitTemplate<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span>import </span>reactor.core.publisher.Mono<br/><span>import </span>reactor.core.scheduler.Schedulers<br/><span>import </span>springfive.twittergathering.domain.TrackedHashTag<br/><span>import </span>java.util.concurrent.CompletableFuture<br/><span>import </span>java.util.concurrent.TimeUnit<br/><span><br/></span><span>@Service<br/></span><span>class </span>TwitterGatherRunner(<span>private val </span><span>twitterGatherService</span>: TweetGatherService<span>,private val </span><span>rabbitTemplate</span>: RabbitTemplate) {<br/><br/>    <strong>@RabbitListener(queues = ["twitter-track-hashtag"])</strong><br/>    <span>fun </span><span>receive</span>(hashTag:TrackedHashTag) {<br/>        <span>val </span>streamFrom = <span>this</span>.<span>twitterGatherService</span>.streamFrom(hashTag.<span>hashTag</span>).filter(<span>{<br/></span><span>            </span><strong>return@filter it.id.isNotEmpty() &amp;&amp; it.text.isNotEmpty() &amp;&amp;  <br/>             it.createdAt.isNotEmpty()</strong><br/>        <span>}</span>)<br/>        <span>val </span>subscribe = streamFrom.subscribe(<span>{<br/></span><span>            </span><strong>println(it.text)</strong><br/>            <strong>Mono.fromFuture(CompletableFuture.runAsync {<br/>                this.rabbitTemplate.convertAndSend("twitter- <br/>                 exchange","track.${hashTag.queue}",it)</strong><br/>            <span>}</span>)<br/>        <span>}</span>)<br/>        <strong>Schedulers.elastic().schedule({ subscribe.dispose() },10L,TimeUnit.SECONDS)</strong><br/>    }<br/><br/>}</pre>
<p>Keep calm. We will cover the whole code. In the <kbd>@RabbitListener,</kbd> we configured the name of the queue we want to consume. The Spring AMQP module will configure our listener automatically for us and start to consume the desired queue. As we can see, we received the <kbd>TrackedHashTag</kbd> object; remember the converters on the previous sections.</p>
<p>The first instruction will start to consume the Twitter stream. <span>The stream returns a</span> flux and can have a lot of data events there. After the consumer, we want to filter the data on the flow. We want <kbd>Tweet</kbd> in which the <kbd>id</kbd>, <kbd>text</kbd>, and <kbd>createdAt</kbd> are not null. </p>
<p>Then, we subscribe this stream and start to receive the data in the flow. Also, the <kbd>subscribes</kbd> function returns the disposable object which will be helpful in the next steps. We have created an anonymous function which will print the <kbd>Tweet</kbd> on the console and send the Tweet to the RabbitMQ queue, to be consumed in another microservice.</p>
<p>Finally, we use the schedulers to stop the data flow and consume the data for 10 seconds.</p>
<p>Before you test the Twitter stream, we need to change the Tracked Hashtag Service to send the messages through the RabbitMQ. We will do that in the next sections. The changes are small ones and we will do them quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the Tracked Hashtag Service</h1>
                </header>
            
            <article>
                
<p>To run the whole solution, we need to make some changes to the Tracked Hashtag Service project. The changes are simple and basic; configure the RabbitMQ connection and change the service to send the messages to the broker.</p>
<p>Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the Spring Starter RabbitMQ dependency</h1>
                </header>
            
            <article>
                
<p>As we did before in the Twitter Gathering project, we need to add <kbd>spring-boot-starter-amqp</kbd> to provide some auto-configuration for us. To do that, we need to add the following snippet to our <kbd>pom.xml</kbd>:</p>
<pre style="padding-left: 60px"><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-boot-starter-amqp<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Right. Now, it is time to configure the RabbitMQ connections. We will do this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the RabbitMQ connections</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>application.yaml</kbd> to configure the RabbitMQ connections. Then, we need to create a couple of properties in it and the Spring AMQP module will use that provided configuration to start the connection factory.</p>
<p>It is pretty simple to configure it. The final <kbd>yaml</kbd> file for Tracked Hashtag should look like this:</p>
<pre style="padding-left: 60px">spring:
  rabbitmq:
    host: localhost
    username: guest
    password: guest
    port: 5672
  redis:
    host: 127.0.0.1
    port: 6379

server:
  port: 9090

queue:
  twitter: twitter-track-hashtag
exchange:
  twitter: twitter-track-exchange
routing_key:
  track: "*"
---
spring:
  profiles: docker
  rabbitmq:
    host: rabbitmq
    username: guest
    password: guest
    port: 5672
  redis:
    host: redis
    port: 6379

server:
  port: 9090

queue:
  twitter: twitter-track-hashtag
exchange:
  twitter: twitter-track-exchange
routing_key:
  track: "*"</pre>
<p>There are two profiles in this yaml. Take a look at the different host for the RabbitMQ. In the default profile, we are able to connect the localhost because we exposed the RabbitMQ ports on the host. But on the Docker profile, we are not able to connect the localhost, we need to connect to the <kbd>rabbitmq</kbd> host, which is the host for the Twitter network.</p>
<p>Our RabbitMQ connection is ready to use. Let's try it in the next section. Let's go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating exchanges, queues, and bindings for the Twitter Hashtag Service</h1>
                </header>
            
            <article>
                
<p>Let's declare our RabbitMQ entities for the Tracked Hashtag usage. We will do that using the <kbd>@Configuration</kbd> class.</p>
<p>The RabbitMQ connection should look like this:</p>
<pre><span>package </span>springfive.twittertracked.infra.rabbitmq<br/><br/><span>import </span>com.fasterxml.jackson.databind.ObjectMapper<br/><span>import </span>com.fasterxml.jackson.module.kotlin.KotlinModule<br/><span>import </span>org.springframework.amqp.core.Binding<br/><span>import </span>org.springframework.amqp.core.BindingBuilder<br/><span>import </span>org.springframework.amqp.core.Queue<br/><span>import </span>org.springframework.amqp.core.TopicExchange<br/><span>import </span>org.springframework.amqp.support.converter.Jackson2JsonMessageConverter<br/><span>import </span>org.springframework.beans.factory.annotation.<span>Value<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span><br/></span><span>@Configuration<br/></span><span>open class </span>RabbitMQConfiguration(<span>@Value</span>(<span>"</span><span>\$</span><span>{queue.twitter}"</span>) <span>private val </span><span>queue</span>:String<span>,<br/></span><span>                                 @Value</span>(<span>"</span><span>\$</span><span>{exchange.twitter}"</span>) <span>private val </span><span>exchange</span>:String<span>,<br/></span><span>                                 @Value</span>(<span>"</span><span>\$</span><span>{routing_key.track}"</span>) <span>private val </span><span>routingKey</span>:String){<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>queue</span>():Queue{<br/>        <span>return </span>Queue(<span>this</span>.<span>queue</span><span>,false</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>exchange</span>():TopicExchange{<br/>        <span>return </span>TopicExchange(<span>this</span>.<span>exchange</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>binding</span>(queue: Queue<span>, </span>exchange: TopicExchange): Binding {<br/>        <span>return </span>BindingBuilder.bind(queue).to(exchange).with(<span>this</span>.<span>routingKey</span>)<br/>    }<br/><br/>    <span>@Bean<br/></span><span>    open fun </span><span>converter</span>(): Jackson2JsonMessageConverter {<br/>        <span>return </span>Jackson2JsonMessageConverter(ObjectMapper().registerModule(KotlinModule()))<br/>    }<br/><br/>}</pre>
<p>Pretty straightforward. We declared one exchange, queue, and binding, as we did before.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending the messages to the broker</h1>
                </header>
            
            <article>
                
<p>This is the most interesting part now. When we want to save the <kbd>TrackedHashTag</kbd>, we must send the pretty new entity to the RabbitMQ. This process will send the message, and then the Twitter Gathering microservice will start to consume the stream in ten seconds.</p>
<p>We need to change the <kbd>TrackedHashTagService</kbd> a little bit; the final version should look like this:</p>
<pre><span>package </span>springfive.twittertracked.domain.service<br/><br/><span>import </span>org.springframework.amqp.rabbit.core.RabbitTemplate<br/><span>import </span>org.springframework.beans.factory.annotation.<span>Value<br/></span><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span>import </span>reactor.core.publisher.Mono<br/><span>import </span>springfive.twittertracked.domain.TrackedHashTag<br/><span>import </span>springfive.twittertracked.domain.repository.TrackedHashTagRepository<br/><span>import </span>java.util.concurrent.CompletableFuture<br/><span><br/></span><span>@Service<br/></span><span>class </span>TrackedHashTagService(<span>private val </span><span>repository</span>: TrackedHashTagRepository<span>,<br/></span><span>                            private val </span><span>rabbitTemplate</span>: RabbitTemplate<span>,<br/></span><span>                            @Value</span>(<span>"</span><span>\$</span><span>{exchange.twitter}"</span>) <span>private val </span><span>exchange</span>: String<span>,<br/></span><span>                            @Value</span>(<span>"</span><span>\$</span><span>{routing_key.track}"</span>) <span>private val </span><span>routingKey</span>: String) {<br/><br/>    <span>fun </span><span>save</span>(hashTag: TrackedHashTag) {<br/>        this.repository.save(hashTag).subscribe { data -&gt;<br/>            <strong>Mono.fromFuture(CompletableFuture.runAsync {</strong><br/><strong>                this.rabbitTemplate.convertAndSend(this.exchange, this.routingKey,  <br/>                hashTag)</strong><br/><strong>            })</strong><br/>        }<br/>    }<br/><br/>    <span>fun </span><span>all</span>() = <span>this</span>.<span>repository</span>.findAll()<br/><br/>}</pre>
<p>Awesome job. When the new entity comes, it will be sent to the broker. We have finished our changes on the Tracked Hashtag Service.</p>
<p>Finally, we are able to test the whole flow. Let's start to play and perceive the real power of our built application.</p>
<p>It's showtime!!!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the microservice's integrations</h1>
                </header>
            
            <article>
                
<p>Now, we are ready to test the whole solution. Before you start, we need to check the following infrastructure items:</p>
<ul>
<li>Redis</li>
<li>RabbitMQ</li>
</ul>
<p>If the items are up and running, we can jump to the next section.</p>
<div class="packt_infobox">We can use the <kbd>docker ps</kbd> command, and the command should list the Redis and RabbitMQ containers in running mode.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running Tracked Hashtag Service</h1>
                </header>
            
            <article>
                
<p>There is no special thing to run this application. It includes the infrastructure connections which are configured in the default profile in <kbd>application.yaml</kbd>.</p>
<p>Run the main function present on the <kbd>TrackedHashTagApplication</kbd>. We can use the IDE or command line to do that.</p>
<p>Check the console output; the output will be presented on the IDE or command line. We want to find the following line:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/693c333b-d14e-40fb-bfdb-66a4297ee0f9.png"/></div>
<p>It means the first application is fully operational and we are able to run Twitter Gathering. Please keep the application running as it is required.</p>
<p>Let's run Twitter Gathering!!!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Twitter Gathering</h1>
                </header>
            
            <article>
                
<p>This application is a little bit more complicated to run. We need to configure some environment variables for that. It is required because we do not want the Twitter application credentials in our repository.</p>
<p>It is pretty simple to do in the IDE. To do that, we can configure the run configuration. Let's do it:</p>
<ol>
<li>Click on the <span class="packt_screen">Edit Configurations...</span><strong> </strong>like in the following image:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="79" src="assets/07088397-9d6c-4b4c-b869-363fbf29531d.png" width="514"/></div>
<p style="padding-left: 60px">Then, we are able to see the <span class="packt_screen">Environment variables</span> like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="189" src="assets/a0251ce5-b76a-4b51-ae10-fdef199f1dc2.png" width="591"/></div>
<ol start="2">
<li>We need to click on <strong>...</strong>, as highlighted in the proceeding image.</li>
<li>The next screen will be shown and we can configure the <span class="packt_screen">Environment Variable</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="356" src="assets/e3e70570-87ff-4d8a-a157-da89622fc957.png" width="312"/></div>
<ol start="4">
<li>We need to configure the following environment variables:
<ul>
<li><span class="packt_screen">consumer-key</span></li>
<li><span class="packt_screen">consumer-secret</span></li>
<li><span class="packt_screen">access-token</span></li>
<li><span class="packt_screen">access-token-secret</span></li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">These values should be filled with the <span class="packt_screen">Twitter Application Management</span> values.</p>
<p>Then, we can run the application. Run it!!</p>
<p>Now, we should see the following lines in the console, which means the application is running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ff9703d-2e38-4a23-aab0-57e5a83c7a9d.png"/></div>
<p>Awesome, our two microservices are running. Let's trigger the Twitter stream. We will do that in the next section.</p>
<div class="packt_infobox">There are other ways to run the application, for example, with the maven Spring Boot goals or Java command line. If you prefer to run in the Java command line, keep in mind the <kbd>-D</kbd> argument to pass environment variables.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing stuff</h1>
                </header>
            
            <article>
                
<p>We are excited to test the full integration. We can use the <kbd>curl</kbd> tool to send request data to the Tracked Hashtag Service. We want to track the <kbd>"bitcoin"</kbd> from Twitter. </p>
<p>We can execute the following command line:</p>
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"hashTag":"bitcoin","queue":"bitcoin"}' \</strong><br/><strong>http://localhost:9090/api/tracked-hash-tag</strong></pre>
<p>Check the HTTP status code; it should be HTTP status 200. After that, we can check the console from the Twitter Gathering project, and there should be a lot of Tweets logged.</p>
<p>Take a look at the log, the log must have Tweets like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="292" src="assets/dce09e86-356a-46f0-8ad8-bb5d10c3a28b.png" width="785"/></div>
<p>Awesome!</p>
<p>Great work guys, we have the full application integrated with RabbitMQ and the Twitter stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Actuator</h1>
                </header>
            
            <article>
                
<p>The Spring Boot Actuator is a kind of helper when the application is running in production. The project provides built-in information of a deployed application.</p>
<p>In the microservices world, monitoring instances of applications are the key point to getting success. In these environments, there are usually many applications calling the other applications over the network protocols such as HTTP. The network is an unstable environment and sometimes it will fail; we need to track these incidents to make sure the application is up and fully operational.</p>
<p>The Spring Boot Actuator helps developers in these situations. The project exposes a couple of HTTP APIs with application information, such as the memory usage, CPU usage, application health check, and the infrastructure components of the application, such as a connection with databases and message brokers, as well.</p>
<p>One of the most important points is that the information is exposed over HTTP. It helps integrations with external monitor applications such as Nagios and Zabbix, for instance. There is no specific protocol for exposing this information.</p>
<p>Let's add it to our project and try a couple of endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Spring Boot Actuator in our pom.xml</h1>
                </header>
            
            <article>
                
<p>Spring Boot Actuator is pretty simple to configure in our <kbd>pom.xml</kbd>. We extended the parent pom of Spring Boot, so it is not necessary to specify the version of the dependency.</p>
<p>Let's configure our new dependency:</p>
<pre class="programlisting" style="padding-left: 60px"><span class="hl-tag">&lt;dependencies&gt;</span>
  <span class="hl-tag">&lt;dependency&gt;</span>
    <span class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span class="hl-tag">&lt;/groupId&gt;</span>
    <span class="hl-tag">&lt;artifactId&gt;</span><strong>spring-boot-starter-actuator</strong><span class="hl-tag">&lt;/artifactId&gt;</span>
  <span class="hl-tag">&lt;/dependency&gt;</span>
<span class="hl-tag">&lt;/dependencies&gt;</span></pre>
<p>Awesome, really easy. Let's understand a little bit more before we test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actuator Endpoints</h1>
                </header>
            
            <article>
                
<p>The projects have a lot of built-in endpoints and they will be up when the application started. Remember, we have used the starter project, which is the one that configures it automatically for us.</p>
<p>There are several endpoints for different requirements, and we will take a look at the most used in production microservices.</p>
<ul>
<li><kbd>/health</kbd>: The most known actuator endpoint; it shows the application's health, and usually, there is a <kbd>status</kbd> attribute</li>
<li><kbd>/configprops</kbd>: Displays a collapse <kbd>@ConfigurationProperties</kbd></li>
<li><kbd>/env</kbd>: Exposes properties from the Spring <kbd>ConfigurableEnvironment</kbd></li>
<li><kbd>/dump</kbd>: Shows the thread dump</li>
<li><kbd>/info</kbd>: We can put some arbitrary information at this endpoint</li>
<li><kbd>/metrics</kbd>: Metrics from the running application</li>
<li><kbd>/mappings</kbd>: <kbd>@RequestMappings</kbd> endpoints from the current application</li>
</ul>
<p>There is another important endpoint to show the application logs over the HTTP interface. The <kbd>/logfile</kbd> endpoint can help us visualize logfiles.</p>
<div class="packt_infobox">The list of endpoints created by the Spring Boot Actuator can be found at: <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application custom information</h1>
                </header>
            
            <article>
                
<p>There is one particular endpoint which we can use to expose custom information from our application. This information will be exposed to <kbd>/info</kbd> endpoint. </p>
<p>To configure that, we can use the <kbd>application.yaml</kbd> file and put the desired information respecting the pattern, as follows:</p>
<pre style="padding-left: 60px"><strong>info</strong>:<br/>  project: "twitter-gathering"<br/>  kotlin: @kotlin.version@</pre>
<p>Thr desired properties must be preceded by the <kbd>info. *</kbd>. Then, we can test our first actuator endpoint and check our <kbd>/info</kbd> resource.</p>
<p>Let's try to access the <kbd>http://localhost:8081/info</kbd>. The information filled on <kbd>application.yaml</kbd> should be displayed, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="115" src="assets/ef882dee-d213-488f-83c9-81ff4119644b.png" width="597"/></div>
<p>As we can see, the properties are exposed from the HTTP endpoint. We can use that to put the application version, for instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing endpoints</h1>
                </header>
            
            <article>
                
<p>In version 2 of  Spring Boot, the Spring Actuator management endpoints are disabled by default, because these endpoints can have sensitive data of a running application. Then, we need to configure to enable these endpoints properly.</p>
<p><span>There is a special point to pay attention to. If the application is exposed publicly, you should protect these endpoints.</span></p>
<p>Let's enable our management endpoints:</p>
<pre style="padding-left: 60px"><span>management:<br/></span><span>  endpoints:<br/></span><span>    web:<br/></span><strong>      expose: "*"</strong></pre>
<p>In the preceding configuration, we enabled all the management endpoints, and then we can start to test some endpoints.</p>
<p>Let's test some endpoints. First, we will test the metrics endpoints. This endpoint shows the metrics available for the running application. Go to <kbd>http://localhost:8081/actuator/metrics</kbd> and check the result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="256" src="assets/9a5582e9-5f54-4a81-ba83-c62808f0787b.png" width="598"/></div>
<div class="packt_infobox">We are using port <kbd>8081</kbd> because we configured the property <kbd>server.port</kbd> in <kbd>application.yaml</kbd>. The port can be changed as you desire.</div>
<p>There are a lot of metrics configured automatically for us. That endpoint exposes only the available metrics. To check the metric value, we need to use another endpoint. Let's check the value of the<span> </span><kbd>http.server.request</kbd>.</p>
<p>The base endpoint to check the value is: <kbd>http://localhost:8081/actuator/metrics/{metricName}</kbd>. Then, we need to go to: <span><kbd>http://localhost:8081/actuator/metrics/http.server.requests</kbd>. The result should be:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="288" src="assets/5d482622-a6d0-46e9-8d6c-a8100da65714.png" width="447"/></div>
<p>As you can see, the server received eight calls. Try to hit a few more times to see the metrics changing. </p>
<p>Awesome job. Our microservice is ready for production. We have the docker image and endpoints for monitoring our services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned and put into practice a lot of Spring Advanced concepts, such as RabbitMQ integration.</p>
<p>We have created a fully reactive WebClient and took advantage of the reactive paradigm; it enables resource computational optimization and increases performance for the application.</p>
<p>Also, we have integrated two microservices through the RabbitMQ broker. This is an excellent solution to integrating applications because it decouples the applications and also permits you to scale the application horizontally really easily. Message-driven is one of the required characteristics to build a reactive application; it can be found at Reactive Manifesto (<a href="https://www.reactivemanifesto.org/en">https://www.reactivemanifesto.org/en</a>).</p>
<p>In the next chapter, we will improve our solution and create a new microservice to stream the filtered Tweets for our clients. We will use RabbitMQ one more time.</p>


            </article>

            
        </section>
    </body></html>