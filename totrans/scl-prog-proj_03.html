<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Handling Errors</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will continue working on the retirement calculator that we implemented in <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml">Chapter 2</a>, <em>Developing a Retirement Calculator</em>. Our calculator worked correctly as long as we passed the right arguments, but would fail badly with a horrible stack trace if any of the parameters were wrong. Our program only worked for what we call the <em>happy path</em>.</p>
<p>The reality of writing production software is that all kinds of error scenarios can occur. Some of them are recoverable, some of them must be presented to the user in an attractive way, and, for some hardware-related errors, we might need to let the program crash.</p>
<p>In this chapter, we will introduce exception handling, explain what referential transparency is, and try to convince you that exceptions are not the best way to deal with errors. Then, we will explain how to use functional programming constructs to effectively handle the possibility of an error.</p>
<p>In each section, we will briefly introduce a new concept, and then use it in a Scala worksheet to get a sense of how to use it. After that, we will apply this new knowledge to improve the retirement calculator.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Using exceptions when necessary</li>
<li>Understanding referential transparency</li>
<li>Using <kbd>Option</kbd> to represent optional values</li>
<li>Using <kbd>Either</kbd> to handle errors sequentially</li>
<li>Using <kbd>Validated</kbd> to handle errors in parallel</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p>If you have not completed <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml">Chapter 2</a><a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml"/>, <em>Developing a Retirement Calculator</em>, then you can check out the retirement calculator project at GitHub. If you are not already familiar with Git, I would advise that you read the documents at <a href="https://guides.github.com/introduction/git-handbook/">https://guides.github.com/introduction/git-handbook/</a> <span>first</span><span>.</span></p>
<p>To begin the setup, go through the following steps:</p>
<ol>
<li>Create an account at <a href="https://github.com/">https://github.com/</a> if you do not have one already.</li>
<li>Go to the retirement calculator project at <a href="https://github.com/PacktPublishing/Scala-Programming-Projects">https://github.com/PacktPublishing/Scala-Programming-Projects</a>. Click on <span class="packt_screen">Fork</span> in the top-right corner to fork the project into your account.</li>
<li>Once the project is forked, click on <span class="packt_screen">Clone or download</span>, and copy the URL into the clipboard.</li>
<li>In IntelliJ, go to <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project from Version Control</span> | <span class="packt_screen">GitHub</span> and make the following edits:
<ul>
<li><span class="packt_screen">Git repository URL</span><strong>:</strong> Paste the URL of your forked repository</li>
<li><span class="packt_screen">Parent directory</span><strong>:</strong> Choose a location</li>
<li><span class="packt_screen">Directory name</span><strong>:</strong> Keep <kbd>retirement_calculator</kbd></li>
<li>Click on <span class="packt_screen">Clone</span></li>
</ul>
</li>
<li>The project should be imported in IntelliJ. Click on <span class="packt_screen">git: master</span> in the bottom-right of the screen and select <span class="packt_screen">Remote branches</span> | <span class="packt_screen">origin/chapter2</span> | <span class="packt_screen">C</span><span class="packt_screen">heckout as new local branch</span>. Name the new branch <kbd>chapter3_yourusername</kbd> to distinguish it from the final solution, which is in the <kbd>origin/chapter3</kbd> branch.</li>
<li>Build the project with <em>Ctrl</em> + <em>F9</em>. Everything should compile.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using exceptions</h1>
                </header>
            
            <article>
                
<p>Exceptions are one of the mechanisms that we can use in Scala to handle error scenarios. It consists of two statements:</p>
<ul>
<li>The <kbd>throw exceptionObject</kbd> statement stops the current function and passes the exception up to the caller.</li>
<li>The <kbd>try { myFunc() } catch { case pattern1 =&gt; recoverExpr1 }</kbd> statement catches any exception thrown by <kbd>myFunc()</kbd> if the exception matches one of the patterns inside the <kbd>catch</kbd> block:</li>
<li style="padding-left: 30px">If an exception is thrown by <kbd>myFunc</kbd>, but no pattern matches the exception, the function stops, and the exception is passed up to the caller again. If there is no <kbd>try...catch</kbd> block in the call chain that can catch the exception, the whole program stops.</li>
<li style="padding-left: 30px">If an exception is thrown by <kbd>myFunc</kbd>, and the <kbd>pattern1</kbd> pattern matches the exception, the <kbd>try...catch</kbd> block will return the <kbd>recoverExpr1</kbd> expression at the right of the arrow.</li>
<li style="padding-left: 30px">If no exception is thrown, the <kbd>try...catch</kbd> block returns the result returned by <kbd>myFunc()</kbd>.</li>
</ul>
<p>This mechanism comes from Java, and since the Scala SDK sits on top of the Java SDK, many function calls to the SDK can throw exceptions. If you are familiar with Java, the Scala exception mechanism differs slightly. Exceptions in Scala are always <em>unchecked</em>, which means that the compiler will never force you to catch an exception or declare that a function can throw an exception.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Throwing exceptions</h1>
                </header>
            
            <article>
                
<p>The following is a code snippet that demonstrates how exceptions can be thrown. You can paste it in the Scala console or in a Scala worksheet:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int</span>)<br/><span>case class </span>AgeNegativeException(message: <span>String</span>) <span>extends </span>Exception(message)<br/><br/><span>def </span><span>createPerson</span>(description: <span>String</span>): Person = {<br/>  <span>val </span>split = description.split(<span>" "</span>)<br/>  <span>val </span>age = split(<span>1</span>).toInt<br/>  <span>if </span>(age &lt; <span>0</span>)<br/>    <span>throw </span><span>AgeNegativeException</span>(s<span>"age: $age should be &gt; 0"</span>)<br/>  <span>else<br/></span><span>    </span><span>Person</span>(split(<span>0</span>)<span>, </span>age)</pre>
<p>The <kbd>createPerson</kbd> function creates the <kbd>Person</kbd> object if the string passed in an argument is correct, but throws different types of exceptions if it is not. In the preceding code, we also implemented our own <kbd>AgeNegativeException</kbd> isntance, which is thrown if the age passed in the string is negative, as shown in the following code:</p>
<pre>scala&gt;<strong> createPerson("John 25")</strong><br/>res0: Person = Person(John,25)<br/><br/>scala&gt; <strong>createPerson("John25")</strong><br/>java.lang.ArrayIndexOutOfBoundsException: 1<br/>  at .createPerson(&lt;console&gt;:17)<br/>  ... 24 elided<br/><br/>scala&gt; <strong>createPerson("John -25")</strong><br/>AgeNegativeException: age: -25 should be &gt; 0<br/>  at .createPerson(&lt;console&gt;:19)<br/>  ... 24 elided<br/><br/>scala&gt; <strong>createPerson("John 25.3")</strong><br/>java.lang.NumberFormatException: For input string: "25.3"<br/>  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)<br/>  at java.lang.Integer.parseInt(Integer.java:580)<br/>  at java.lang.Integer.parseInt(Integer.java:615)<br/>  at scala.collection.immutable.StringLike.toInt(StringLike.scala:301)<br/>  at scala.collection.immutable.StringLike.toInt$(StringLike.scala:301)<br/>  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)<br/>  at .createPerson(&lt;console&gt;:17)<br/>  ... 24 elided</pre>
<p>Since the exceptions are not caught by any <kbd>try...catch</kbd> block, the Scala console shows a <strong>stack trace</strong>. The stack trace shows all the nested function calls that led to the point where the exception was thrown. In the last example, the <kbd>val age = split(1).toInt</kbd> line in <kbd>createPerson</kbd> called <kbd>scala.collection.immutable.StringOps.toInt</kbd>, which called <kbd>scala.collection.immutable.StringLike.toInt$</kbd>, and so on, until finally the <kbd>java.lang.Integer.parseInt</kbd> function threw the exception at line 580 in <kbd>Integer.java</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catching exceptions</h1>
                </header>
            
            <article>
                
<p>In order to illustrate how exceptions bubble up the call stack, we are going to create a new <kbd>averageAge </kbd><span>function</span><span>, which calculates the average age of a list of</span> <kbd>Person </kbd><span>instances</span><span>, using their string descriptions, as shown in the following code:</span></p>
<pre><span>def </span><span>averageAge</span>(descriptions: <span>Vector</span>[<span>String</span>]): <span>Double </span>= {<br/>  <span>val </span>total = descriptions.map(createPerson).map(_.age).sum<br/>  total / descriptions.length<br/>}</pre>
<p>This function calls our previously implemented <kbd>createPerson </kbd><span>function</span><span>, and therefore will throw any exception that is thrown by</span> <kbd>createPerson</kbd> <span>because there is no</span> <kbd>try<span>...</span>catch</kbd> <span>block in</span> <kbd>averageAge</kbd><span>.</span></p>
<p>Now, we can implement another function on top that will parse an input containing several <kbd>Person</kbd> descriptions and return a summary in a string. It will print an error message in case the input cannot be parsed, as shown in the following code:</p>
<pre><span>import scala.util.control.NonFatal<br/>def </span><span>personsSummary</span>(personsInput: <span>String</span>): <span>String </span>= {<br/>  <span>val </span>descriptions = personsInput.split(<span>"</span><span>\n</span><span>"</span>).toVector<br/>  <span>val </span>avg = <span>try </span>{<br/>    averageAge(descriptions)<br/>  } <span>catch </span>{<br/>    <span>case </span>e:AgeNegativeException =&gt;<br/>      <span>println</span>(<span>s"one of the persons has a negative age: </span><span>$</span>e<span>"</span>)<br/>      <span>0<br/></span><span>    </span><span>case </span><span>NonFatal</span>(e) =&gt;<br/>      <span>println</span>(<span>s"something was wrong in the input: </span><span>$</span>e<span>"</span>)<br/>      <span>0<br/></span><span>  </span>}<br/>  <span>s"</span><span>$</span>{descriptions.length}<span> persons with an average age of </span><span>$</span>avg<span>"<br/></span>}</pre>
<p>In this function, we declare an <kbd>avg</kbd><span> value</span><span>, which will get the return value of</span> <kbd>averageAge</kbd> <span>if no exception is thrown. If one of the descriptions contains a negative age, our catch block will print an error message, and</span> <kbd>avg</kbd> <span>will be assigned the value of </span><kbd>0</kbd><span>. If another type of exception is thrown, and this exception is</span> <kbd>NonFatal</kbd><span>, then we print another message and</span> <kbd>avg</kbd> <span>will also be assigned the value of </span><kbd>0</kbd><span>. A fatal exception is an exception that cannot be recovered, such as</span> <kbd>OutOfMemoryException</kbd><span>. You can look at the implementation of</span> <kbd>scala.util.control.NonFatal</kbd> <span>for more details.</span></p>
<p>The following code shows a few sample calls to <kbd>personsSummary</kbd>:</p>
<pre>scala&gt; personsSummary(<br/>  """John 25<br/>    |Sharleen 45""".stripMargin)<br/>res1: String = 2 persons with an average age of 35.0<br/><br/>scala&gt; personsSummary(<br/>  """John 25<br/>    |Sharleen45""".stripMargin)<br/>something was wrong in the input: java.lang.ArrayIndexOutOfBoundsException: 1<br/>res2: String = 2 persons with an average age of 0.0<br/><br/>scala&gt; personsSummary(<br/> """John -25<br/> |Sharleen 45""".stripMargin)<br/>one of the persons has a negative age: $line5.$read$$iw$$iw$AgeNegativeException: age should be &gt; 0<br/>res3: String = 2 persons with an average age of 0.0</pre>
<p>As we can see, as soon as any of the descriptions cannot be parsed, an error is printed and the average age is set to <kbd>0</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the finally block</h1>
                </header>
            
            <article>
                
<p>A <kbd>try...catch</kbd> block can optionally be followed by a <kbd>finally {}</kbd> block. The code inside the <kbd>finally</kbd> block is always executed, even if an exception is not matched by any pattern in the <kbd>catch</kbd> block. The <kbd>finally</kbd> block is typically used to close any resource that is accessed inside the <kbd>try</kbd> block, such as a file or a network connection.</p>
<p>The following code shows how to use a URL to read a web page into a string:</p>
<pre><span>import </span>java.io.IOException<br/><span>import </span>java.net.URL<br/><span>import </span>scala.annotation.tailrec<br/><br/><span>val </span>stream = <span>new </span>URL(<span>"https://www.packtpub.com/"</span>).openStream()<br/><span>val </span>htmlPage: <span>String </span>=<br/>  <span>try </span>{<br/>    <span>@tailrec<br/></span><span>    </span><span>def </span><span>loop</span>(builder: <span>StringBuilder</span>): <span>String </span>= {<br/>      <span>val </span>i = stream.read()<br/>      <span>if </span>(i != -<span>1</span>)<br/>        loop(builder.append(i.toChar))<br/>      <span>else<br/></span><span>        </span>builder.toString()<br/>    }<br/>    loop(<span>StringBuilder</span>.<span>newBuilder</span>)<br/>  } <span>catch </span>{<br/>    <span>case </span>e: IOException =&gt; <span>s"cannot read URL: </span><span>$</span>e<span>"<br/></span><span>  </span>}<br/>  <span>finally </span>{<br/>    stream.close()<br/>  }</pre>
<p>The <kbd>finally</kbd> block allows us to close <kbd>InputStream</kbd>, whether the reading of the page succeeded or not. This way, we will not leave a dangling open connection in case there is a network issue or a thread interruption.</p>
<p>Note that the preceding code is for illustrative purposes only. In a real project, you should use the following code format:</p>
<pre><span>val </span>htmlPage2 = scala.io.Source.<span>fromURL</span>(<span>"https://www.packtpub.com/"</span>).mkString</pre>
<p>Now that you know how to use exceptions, we are going to define the concept of referential transparency and show how catching exceptions can break it. We will then explore better data structures that will let us manage errors without breaking referential transparency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring referential transparency</h1>
                </header>
            
            <article>
                
<p> We say that an expression is <strong>referentially transparent</strong> when it can be replaced by its value without changing the program's behavior, in any context. When an expression is a function call, it means that we can always substitute this function call with the return value of the function. A function that guarantees this in any context is called a <strong>pure function</strong>.</p>
<p>A pure function is like a mathematical function—the return value depends only on the arguments passed to the function. You do not have to consider anything else about the context in which it is called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining pure functions</h1>
                </header>
            
            <article>
                
<p>In the following code,  the <kbd>pureSquare</kbd><span> function</span><span> </span><span>is pure:</span></p>
<pre>def pureSquare(x: Int): Int = x * x<br/>val pureExpr = pureSquare(4) + pureSquare(3)<br/>// pureExpr: Int = 25<br/><br/>val pureExpr2 = 16 + 9<br/>// pureExpr2: Int = 25</pre>
<p>The functions called <kbd>pureSquare(4)</kbd> and <kbd>pureSquare(3)</kbd> are referentially transparent—when we replace them with the return value of the function, the program's behavior does not change.</p>
<p>On the other hand, the following function is impure:</p>
<pre><span>var </span>globalState = <span>1<br/></span><span>def </span><span>impure</span>(x: <span>Int</span>): <span>Int </span>= {<br/>  globalState = globalState + x<br/>  globalState<br/>}<br/><span>val </span>impureExpr = impure(<span>3</span>)<br/>// impureExpr: Int = 4<br/><span>val </span>impureExpr2 = <span>4<br/></span></pre>
<p>We cannot replace the call to <kbd>impure(3)</kbd> with its return value because the return value changes depending on the context. In fact, any function that has <strong>side effects</strong> is impure. A side effect can be any of the following constructs:</p>
<ul>
<li>Mutating a global variable</li>
<li>Printing to the console</li>
<li>Opening a network connection</li>
<li>Reading/writing data to/from a file</li>
<li>Reading/writing data to/from a database</li>
<li>More generally, any interaction with the outside world</li>
</ul>
<p>The following is another example of an impure function:</p>
<pre><span>import </span>scala.util.Random<br/><span>def </span><span>impureRand</span>(): <span>Int </span>= Random.nextInt()<br/>impureRand()<br/><span>//res0: Int = -528134321<br/></span><span>val </span>impureExprRand = impureRand() + impureRand()<br/><span>//impureExprRand: Int = 681209667<br/></span><span>val </span>impureExprRand2 = -<span>528134321 </span>+ -<span>528134321</span></pre>
<p class="mce-root">You cannot substitute the result of <kbd>impureRand()</kbd> with its value because the value changes for every call. If you do so, the program's behavior changes. The call to <kbd>impureRand()</kbd> is not referentially transparent, and hence <kbd>impureRand</kbd> is impure. In fact, the <kbd>random()</kbd> <span>function</span><span> </span><span>mutates a global variable to generate a new random number for every call. We can also say that this function is</span> <strong>nondeterministic</strong><span>—we cannot predict its return value just by observing its arguments.</span></p>
<p>We can rewrite our impure function to make it pure, as shown in the following code:</p>
<pre><span>def </span><span>pureRand</span>(seed: <span>Int</span>): <span>Int </span>= <span>new </span>Random(seed).nextInt()<br/>pureRand(<span>10</span>)<br/><span>//res1: Int = -1157793070<br/></span><span>val </span>pureExprRand = pureRand(<span>10</span>) + pureRand(<span>10</span>)<br/><span>//pureExprRand: Int = 1979381156<br/></span><span>val </span>pureExprRand2 = -<span>1157793070 </span>+ -<span>1157793070<br/></span><span>//pureExprRand2: Int = 1979381156</span></pre>
<p>You can substitute the call to <kbd>pureRand(seed)</kbd> with its value; the function will always return the same value given the same seed. The call to <kbd>pureRand</kbd> is referentially transparent, and <kbd>pureRand</kbd> is a pure function.</p>
<p>The following is another example of an impure function:</p>
<pre>def impurePrint(): Unit = println("Hello impure")<br/>val impureExpr1: Unit = impurePrint()<br/>val impureExpr2: Unit = ()</pre>
<p>In the second example, the return value of <kbd>impurePrint</kbd> is of the <kbd>Unit </kbd><span>type</span><span>. There is only one value of this type in the Scala SDK: the</span> <kbd>()</kbd><span>value</span><span>. If we replace the call to</span> <kbd>impurePrint()</kbd> <span>with</span> <kbd>()</kbd><span>, then the program's behavior changes—in the first case, something will be printed on the console, but not in the second case.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices</h1>
                </header>
            
            <article>
                
<p>Referential transparency is a key concept in functional programming. If most of your program uses pure functions, then it becomes much easier to do the following:</p>
<ul>
<li><strong>Understand what a program is doing:</strong> You know that the function's return value only depends on its arguments. You do not have to think about what the state of this or that variable is in this or that context. You just have to look at the arguments.</li>
<li><strong>Test your functions:</strong> I will restate this point—the function's return value only depends on its argument. Testing it is very simple; you can try different argument values and confirm that the return value is what you expect.</li>
<li><strong>Write multithreaded programs:</strong> Since a pure function's behavior does not depend on a global state, you can execute it in parallel on multiple threads or even on different machines. The return values will not change. As our CPUs are built with more and more cores these days, this will help you write faster programs.</li>
</ul>
<p>However, it is not possible to only have pure functions in a program because, in essence, a program must interact with the outside world. It has to print something, read some user input, or save some state in a database. In functional programming, the best practice is to use pure functions in the majority of the code base and to push the impure side-effecting functions to the boundaries of the program.</p>
<p>For instance, in <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml" target="_blank">Chapter 2</a>, <em>Developing a Retirement Calculator</em>, we implemented a retirement calculator that mostly uses pure functions. One side-effecting function was the <kbd>println</kbd> call in the <kbd>SimulatePlanApp</kbd> object, which was at the boundaries of the program. There were other side effects in <kbd>EquityData.fromFile</kbd> and <kbd>InflationData.fromFile</kbd>; these functions are for reading files. However, the resource files can never change for the duration of the program. For a given filename, we would always get the same file content, and we could substitute the return value of <kbd>fromFile</kbd> in all calls without changing the program's behavior. In this case, the side effect of reading a file is not observable, and we can consider theses file-reading functions as being pure. Another side-effecting function was <kbd>strMain</kbd> because it could throw exceptions. I<span>n the rest of this chapter, w</span><span>e will see why throwing exceptions break referential transparency, and we will learn how to replace it with better functional programming structures.</span></p>
<div class="packt_tip">An impure function fulfills the following two criteria:<br/>
<ul>
<li>It returns <kbd>Unit</kbd>.</li>
<li>It does not take any arguments but returns a type. Since it returns something that cannot be obtained by using its arguments, it must be using a global state.</li>
</ul>
</div>
<p>Note that a pure function can use mutable variables or side effects inside the body of the function. As long as these effects are <em>not observable</em> by the caller, we consider the function pure. In the Scala SDK, many pure functions are implemented using mutable variables to improve performance. Look, for the instance, at the following implementation of <kbd>TraversableOnce.foldLeft</kbd>:</p>
<pre><span>def </span><span>foldLeft</span>[<span>B</span>](z: <span>B</span>)(op: (<span>B</span><span>, </span><span>A</span>) =&gt; <span>B</span>): <span>B </span>= {<br/>  <span>var </span>result = z<br/>  <span>this </span>foreach (x =&gt; result = op(result<span>, </span>x))<br/>  result<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Showing how exceptions break referential transparency</h1>
                </header>
            
            <article>
                
<p>This might not seem obvious, but when a function throws an exception, it breaks referential transparency. In this section, I am going to show you why. First, create a new Scala worksheet and type the following definitions:</p>
<pre><span>case class </span>Rectangle(width: <span>Double, </span>height: <span>Double</span>)<br/><br/>def area(r: Rectangle): Double =<br/>  if (r.width &gt; 5 || r.height &gt; 5)<br/>    throw new IllegalArgumentException("too big")<br/>  else<br/>    r.width * r.height</pre>
<p>Then, we will call <kbd>area</kbd> with the following arguments:</p>
<pre>val area1 = area(3, 2)<br/>val area2 = area(4, 2)<br/><br/>val total = try {<br/>  area1 + area2<br/>} catch {<br/>  case e: IllegalArgumentException =&gt; 0<br/>}</pre>
<p><span>We get <kbd>total: Double = 14.0</kbd>. In the preceding code, the <kbd>area1</kbd> and <kbd>area2</kbd> expressions are referentially transparent. We can indeed</span> <em>substitute</em> <span>them with their value without changing the program's behavior. In IntelliJ, select the <kbd>area1</kbd></span><span> variable</span><span> </span><span>inside the <kbd>try</kbd> block and hit</span> <em>Ctrl</em><span> + </span><em>Alt</em><span> + </span><em>N</em> <span>(inline variable), as shown in the following code. Do the same for <kbd>area2</kbd></span><span>:</span></p>
<pre><span>val </span>total = <span>try </span>{<br/>  area(<span>3</span><span>, </span><span>2</span>) + area(<span>4</span><span>, </span><span>2</span>)<br/>} <span>catch </span>{<br/>  <span>case </span>e: <span>IllegalArgumentException </span>=&gt; <span>0<br/></span>}</pre>
<p>The <kbd>total</kbd> is the same as before. The program's behavior did not change, hence <kbd>area1</kbd> and <kbd>area2</kbd> are referentially transparent. However, let's see what happens if we define <kbd>area1</kbd> in the following way:</p>
<pre><span>val </span>area1 = area(<span>6</span><span>, </span><span>2</span>)<br/><span>val </span>area2 = area(<span>4</span><span>, </span><span>2</span>)<br/><br/><span>val </span>total = <span>try </span>{<br/>  area1 + area2<br/>} <span>catch </span>{<br/>  <span>case </span>e: <span>IllegalArgumentException </span>=&gt; <span>0<br/></span>}</pre>
<p>In this case, we get <kbd>java.lang.IllegalArgumentException: too big</kbd>, because our <kbd>area(...)</kbd> <span>function</span><span> </span><span>throws an exception when the width is greater than five. Now let's see what happens if we inline</span> <kbd>area1</kbd> <span>and</span> <kbd>area2</kbd> <span>as before, as shown in the following code:</span></p>
<pre><span>val </span>total = <span>try </span>{<br/>  area(<span>6</span><span>, </span><span>2</span>) + area(<span>4</span><span>, </span><span>2</span>)<br/>} <span>catch </span>{<br/>  <span>case </span>e: <span>IllegalArgumentException </span>=&gt; <span>0<br/></span>}</pre>
<p>In this case, we get <kbd>total: Double = 0.0</kbd>. The program's behavior changed when substituting <kbd>area1</kbd> with its value, hence <kbd>area1</kbd> is <em>not</em> referentially transparent.</p>
<p>We demonstrated that exception handling breaks referential transparency, and hence functions that throw exceptions are impure. It makes a program more difficult to understand because you have to take into account <em>where</em> a variable is defined to understand how the program will behave. The behavior will change depending on whether a variable is defined inside or outside a <kbd>try</kbd> block. This might not seem to be a big deal in a trivial example, but when there are multiple chained function calls with <kbd>try</kbd> blocks along the line, matching different types of exceptions, it can become daunting.</p>
<p>Another disadvantage when you use exceptions is that the <em>signature</em> of the function does not indicate that it can throw an exception. When you call a function that can throw exceptions, you have to look at its implementation to figure out what type of exception it can throw, and under what circumstances. If the function calls other functions, it compounds the problem. You can accommodate this by adding comments or an <kbd>@throws</kbd><span> annotation</span><span> </span><span>to indicate what exception types can be thrown, but these can become outdated when the code is refactored. When we call a function, we should only have to consider its signature. A signature is a bit like a contract—given these arguments, I will return you a result. If you have to look at the implementation to know what exceptions are thrown, it means that the contract is not completed: some information is hidden.</span></p>
<p>We now know how to throw and catch exceptions, and why we should use them with caution. The best practice is to do the following:</p>
<ul>
<li>Catch recoverable exceptions as early as possible, and indicate the possibility of failure with a specific return type.</li>
<li>Not catch exceptions that cannot be recovered, such as disk full, out of memory, or some other catastrophic failure. This will make your program crash whenever such exceptions happen, and you should then have a manual or automatic recovery process outside the program.</li>
</ul>
<p>In the rest of this chapter, I will show you how to use the <kbd>Option</kbd>, <kbd>Either</kbd>, and <kbd>Validated</kbd> classes to model the possibility of a failure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Option</h1>
                </header>
            
            <article>
                
<p>The Scala <kbd>Option</kbd> type is an <strong>algebraic data type</strong> (<strong>ADT</strong>) that represents an optional value. It can also be viewed as <kbd>List</kbd> that can contain either one or no elements. It is a safe replacement for a <kbd>null</kbd> reference that you might have used if you have programmed in Java, C++, or C#.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating instances of Option</h1>
                </header>
            
            <article>
                
<p>The following is a simplified definition of the <kbd>Option</kbd> ADT:</p>
<pre>sealed trait Option[+A]<br/>case class Some[A](value: A) extends Option[A]<br/>case object None extends Option[Nothing]</pre>
<p>The Scala SDK provides a more refined implementation; the preceding definition is just for illustrative purpose. This definition implies that <kbd>Option</kbd> can be either of the following two types:</p>
<ul>
<li><kbd>Some(value)</kbd>, which represents an optional value where the value is present</li>
<li><kbd>None</kbd>, which represents an optional value where the value is not present.</li>
</ul>
<div class="packt_infobox">The <kbd>+</kbd> sign in front of the <kbd>A</kbd> type parameter in the <kbd>Option[+A]</kbd> declaration means that <kbd>Option</kbd> is covariant in <kbd>A</kbd>. We will explore contravariance in more details in <a href="79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml" target="_blank">Chapter 4</a><span>, </span><em>Advanced Features</em>.<br/>
For now, you just have to know that if <kbd>B</kbd> is a subtype of <kbd>A</kbd>, then <kbd>Option[B]</kbd> is a subtype of <kbd>Option[A]</kbd>.<br/>
Furthermore, you might notice that <kbd>None</kbd> actually extends <kbd>Option[Nothing]</kbd> and not <kbd>Option[A]</kbd>. This is because a case object cannot accept a type parameter.<br/>
In Scala, <kbd>Nothing</kbd> is the bottom type, which means that it is a subtype of any other type. <br/>
This implies that <kbd>None</kbd> is a subtype of <kbd>Option[A]</kbd> for any <kbd>A</kbd>.</div>
<p>The following are some examples of the usage of the different types of <kbd>Option</kbd> that you can paste in a Scala worksheet:</p>
<pre><span>val </span>opt0: Option[<span>Int</span>] = None<br/>// opt0: Option[Int] = None<br/><br/><span>val </span>opt1: Option[<span>Int</span>] = <span>Some</span>(<span>1</span>)<br/>// opt1: Option[Int] = Some(1)<br/><br/>val list0 = List.empty[String]<br/>list0.headOption<br/>// res0: Option[String] = None<br/>list0.lastOption<br/>// res1: Option[String] = None<br/><br/>val list3 = List("Hello", "World")<br/>list3.headOption<br/>// res2: Option[String] = Some(Hello)<br/>list3.lastOption<br/>// res3: Option[String] = Some(World)</pre>
<p>Explanation of the preceding code is as follows:</p>
<ul>
<li>The first two examples show how we can define an <kbd>Option</kbd> type that can optionally contain <kbd>Int</kbd>.</li>
<li>The following examples use the <kbd>headOption</kbd> and <kbd>lastOption</kbd> <span>methods</span><span> i</span><span>n</span> <kbd>List</kbd> <span>to show that many safe functions of the SDK return</span> <kbd>Option</kbd><span>. If </span><kbd>List</kbd> <span>is empty, these functions always return</span> <kbd>None</kbd><span>. Note that the SDK also provides</span> <em>unsafe</em> <span>equivalent</span> <kbd>head</kbd> <span>and</span> <kbd>last </kbd><span>methods</span><span>. The unsafe methods throw an exception if we call them with an empty</span> <kbd>List</kbd><span><span>, which might crash our program if we do not catch the exception.</span></span></li>
</ul>
<div class="packt_quote packt_tip">Many functions of the SDK provide equivalent safe (which return <kbd>Option</kbd>) and unsafe functions (which throw an exception). It is a best practice to always use the safe alternative.</div>
<p>Since <kbd>Option</kbd> is an ADT, we can use pattern matching to test whether <kbd>Option</kbd> is <kbd>None</kbd> or <kbd>Some</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>personDescription</span>(name: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): String =<br/>  db.get(name) <span>match </span>{<br/>    <span>case </span><span>Some</span>(age) =&gt; <span>s"</span><span>$</span>name<span> is </span><span>$</span>age<span> years old"<br/></span><span>    </span><span>case </span>None =&gt; <span>s"</span><span>$</span>name<span> is not present in db"<br/></span><span>  </span>}<br/><br/><span>val </span>db = <span>Map</span>(<span>"John" </span>-&gt; <span>25</span><span>, </span><span>"Rob" </span>-&gt; <span>40</span>)<br/>personDescription(<span>"John"</span><span>, </span>db)<br/>// res4: String = John is 25 years old<br/>personDescription(<span>"Michael"</span><span>, </span>db)<br/>// res5: String = Michael is not present in db</pre>
<p>The <kbd>get(key)</kbd><span>method</span><span> i</span><span>n</span> <kbd>Map</kbd> <span>returns</span> <kbd>Option</kbd><span>, containing the value associated with the key. If the key does not exist in</span> <kbd>Map</kbd><span>, it returns</span> <kbd>None</kbd><span>. When you start using</span> <kbd>Option</kbd><span>, pattern matching is the most natural way of triggering different behaviors depending on the content of</span> <kbd>Option</kbd><span>.</span></p>
<p>Another way is to use <kbd>map</kbd> and <kbd>getOrElse</kbd>, as shown in the following code:</p>
<pre>def personDesc(name: String, db: Map[String, Int]): String = {<br/>  val optString: Option[String] = db.get(name).<strong>map</strong>(age =&gt; s"$name is <br/>  $age years old")<br/>  optString.<strong>getOrElse</strong>(s"$name is not present in db")<br/>}</pre>
<p>We saw earlier how to transform the elements of a vector using <kbd>map</kbd>. This works exactly the same for <kbd>Option</kbd>—we pass an anonymous function that will be called with the option's value if <kbd>Option</kbd> is not empty. Since our anonymous function returns a string, we obtain <kbd>Option[String]</kbd>. We then call <kbd>getOrElse</kbd>, which provides a value in case <kbd>Option</kbd> is <kbd>None</kbd>. The <kbd>getOrElse </kbd><span>phrase </span><span>is a good way to safely extract the content of</span> <kbd>Option</kbd><span>.</span></p>
<div class="packt_infobox">
<p>Never use the <kbd>.get</kbd> <span>method</span><span> </span><span>on</span> <kbd>Option</kbd><span>—always use</span> <kbd>.getOrElse</kbd><span>. The</span> <kbd>.get</kbd> <span>method throws an exception if</span> <kbd>Option</kbd> <span>is</span> <kbd>None</kbd><span>, and hence is not safe.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing transformations with for... yield</h1>
                </header>
            
            <article>
                
<p>Using the same <kbd>db: Map[String, Int]</kbd> phrase, containing the ages of different people, the following code is a naive implementation of a function that returns the average age of two people:</p>
<pre><span>def </span><span>averageAgeA</span>(name1: <span>String</span><span>, </span>name2: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): Option[<span>Double</span>] = {<br/>  <span>val </span>optOptAvg: Option[Option[<span>Double</span>]] =<br/>    db.get(name1).map(age1 =&gt;<br/>      db.get(name2).map(age2 =&gt;<br/>        (age1 + age2).toDouble / <span>2</span>))<br/>  optOptAvg.flatten<br/>}<br/>val db = Map("John" -&gt; 25, "Rob" -&gt; 40)<br/>averageAge("John", "Rob", db)<br/>// res6: Option[Double] = Some(32.5)<br/>averageAge("John", "Michael", db)<br/>// res7: Option[Double] = None</pre>
<p>The function returns <kbd>Option[Double]</kbd>. If <kbd>name1</kbd> or <kbd>name2</kbd> cannot be found in the <kbd>db</kbd> map, <kbd>averageAge</kbd> returns <kbd>None</kbd>. If both names are found, it returns <kbd>Some(value)</kbd>. The implementation uses <kbd>map</kbd> to transform the value contained in the option. We end up with a nested <kbd>Option[Option[Double]]</kbd>, but our function must return <kbd>Option[Double]</kbd>. Fortunately, we can use <kbd>flatten</kbd> to remove one level of nesting.</p>
<p>We managed to implement <kbd>averageAge</kbd>, but we can improve it using <kbd>flatMap</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>averageAgeB</span>(name1: <span>String</span><span>, </span>name2: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): Option[<span>Double</span>] =<br/>  db.get(name1).flatMap(age1 =&gt;<br/>    db.get(name2).map(age2 =&gt;<br/>      (age1 + age2).toDouble / <span>2</span>))</pre>
<p>As its name suggests, <kbd>flatMap</kbd> is equivalent to composing <kbd>flatten</kbd> and <kbd>map</kbd>. In our function, we replaced <kbd>map(...).flatten</kbd> with <kbd>flatMap(...)</kbd>.</p>
<p>So far, so good, but what if we want to get the average age of three or four people? We would have to nest several instances of <kbd>flatMap</kbd>, which would not be very pretty or readable. Fortunately, Scala provides a syntactic sugar that allows us to simplify our function further, called the <kbd>for</kbd> comprehension, as shown in the following code:</p>
<pre><span>def </span><span>averageAgeC</span>(name1: <span>String</span><span>, </span>name2: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): Option[<span>Double</span>] =<br/>  <span>for </span>{<br/>    age1 &lt;- db.get(name1)<br/>    age2 &lt;- db.get(name2)<br/>  } <span>yield </span>(age1 + age2).toDouble / <span>2</span></pre>
<p>When you compile a <kbd>for</kbd> comprehension, such as <kbd>for { ... } yield { ... }</kbd>, the Scala compiler transforms it into a composition of <kbd>flatMap</kbd>/<kbd>map</kbd> operations. Here is how it works:</p>
<ul>
<li>Inside the <kbd>for</kbd> block, there can be one or many expressions phrased as <kbd>variable &lt;- context</kbd>, which is called a <strong>generator</strong>. The left side of the arrow is the name of a variable that is bound to the content of the <strong>context</strong> on the right of the arrow.</li>
<li>Every generator except the last one is transformed into a <kbd>flatMap</kbd> expression.</li>
<li>The last generator is transformed into a <kbd>map</kbd> expression.</li>
<li>All context expressions (the right side of the arrow) must have the same context type.</li>
</ul>
<p>In the preceding example, we used <kbd>Option</kbd> for the context type, but <kbd>for yield</kbd> can also be used with any class that has a <kbd>flatMap</kbd> and <kbd>map</kbd> operation. For instance, we can use <kbd>for..yield</kbd> with <kbd>Vector</kbd> to run nested loops, as shown in the following code:</p>
<pre><span>for </span>{<br/>  i &lt;- <span>Vector</span>(<span>"one"</span><span>, </span><span>"two"</span>)<br/>  j &lt;- <span>Vector</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)<br/>} <span>yield </span>(i<span>, </span>j)<br/>// res8: scala.collection.immutable.Vector[(String, Int)] = <br/>// Vector((one,1), (one,2), (one,3), (two,1), (two,2), (two,3))</pre>
<div class="packt_infobox"><strong>Syntactic sugar</strong> is syntax within a programming language that makes it easier to read or write. It makes it sweeter for the programmer.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the retirement calculator to use Option</h1>
                </header>
            
            <article>
                
<p>Now that we know what <kbd>Option</kbd> can do for us, we are going to refactor one of the functions of the retirement calculator that we developed in <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml" target="_blank">Chapter 2</a>, <em>Developing a Retirement Calculator</em>, to improve the handling of some edge-case scenarios. If you have not done it yet, please follow the instructions at the beginning of the <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml" target="_blank">Chapter 2</a>, <em>Developing a Retirement Calculator</em>, to set up the project.</p>
<p>In <kbd>RetCalc.scala</kbd>, we are going to change the return type of <kbd>nbMonthsSaving</kbd>. In <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml" target="_blank">Chapter 2</a>, <em>Developing a Retirement Calculator</em>, we returned <kbd>Int.MaxValue</kbd> if <kbd>netIncome &lt;= currentExpense</kbd> to avoid looping infinitely. This was not very robust, as this infinite result could then be used in another computation, which would lead to bogus results. It would be better to return <kbd>Option[Int]</kbd> to indicate that the function might not be computable and let the caller decide what to do. We would return <kbd>None</kbd> if it was not computable or <kbd>Some(returnValue)</kbd> if it was computable.</p>
<p>The following code is the new implementation for <kbd>nbMonthsSaving</kbd>, with the changed portions highlighted in bold:</p>
<pre><span>def </span><span>nbOfMonthsSaving</span>(params: RetCalcParams<span>, <br/>                     </span>returns: Returns): <strong>Option[Int]</strong> = {<br/>  <span>import </span>params._<br/>  <span>@tailrec<br/></span><span>  </span><span>def </span><span>loop</span>(months: <span>Int</span>): <span>Int </span>= {<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <br/>      <span>simulatePlan</span>(returns<span>, </span>params<span>, </span>months)<br/><br/>    <span>if </span>(capitalAfterDeath &gt; <span>0.0</span>)<br/>      months<br/>    <span>else<br/></span><span>      </span>loop(months + <span>1</span>)<br/>  }<br/><br/>  <span>if </span>(netIncome &gt; currentExpenses)<br/>    <strong>Some(loop(0))</strong><br/>  <span>else<br/></span><span>    </span><strong>None</strong><br/>}</pre>
<p><span>Now</span><span> t</span>ry to compile the project. This change breaks many parts of our project, but the Scala compiler is a terrific assistant. It will help us identify the portions of the code we need to change to make our code more robust.</p>
<p>The first error is in <kbd>RetCalcSpec.scala</kbd>, as shown in the following code:</p>
<pre>Error:(65, 14) types Option[Int] and Int do not adhere to the type constraint selected for the === and !== operators; the missing implicit parameter is of type org.scalactic.CanEqual[Option[Int],Int]<br/>      actual should ===(expected)</pre>
<p>This error means that the types in the <kbd>actual should === (expected)</kbd> expression do not match: <kbd>actual</kbd> is of the <kbd>Option[Int]0</kbd><span> type</span><span>, whereas</span> <kbd>expected</kbd> <span>is of the</span> <kbd>Int</kbd><span> type</span><span>. We need to change the assertion, as follows:</span></p>
<pre>actual should ===(Some(expected))</pre>
<p>You can apply the same fix for the second unit test. For the last unit test, we want to assert that <kbd>None</kbd> is returned instead of <kbd>Int.MaxValue</kbd>, as shown in the following code:</p>
<pre><span>"not loop forever if I enter bad parameters" </span>in {<br/>  <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<span>params</span>.copy(netIncome = <span>1000</span>)<span>, </span><span>FixedReturns</span>(<span>0.04</span>))<br/>  actual should ===(<strong>None</strong>)<br/>}</pre>
<p>You can now compile and run the test. It should pass.</p>
<p>You are now able to model an optional value safely. However, sometimes it is not always obvious to know what <kbd>None</kbd> actually means. Why did this function return <kbd>None</kbd>? Was it because the arguments that were passed were wrong? Which argument was wrong? And what value would be correct? It would indeed be nice to have some explanation that comes along with the <kbd>None</kbd> in order to understand <em>why</em> there was no value. In the next section, we are going to use the <kbd>Either</kbd> type for this purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Either</h1>
                </header>
            
            <article>
                
<p>The <kbd>Either</kbd> type is an ADT that represents a value of either a <kbd>Left</kbd> type or a <kbd>Right</kbd> type. A simplified definition of <kbd>Either</kbd> would be the following:</p>
<pre>sealed trait Either[A, B]<br/>case class Left[A, B](value: A) extends Either[A, B]<br/>case class Right[A, B](value: B) extends Either[A, B]</pre>
<p class="mce-root">When you instantiate a <kbd>Right</kbd> type, you need to provide a value of a <kbd>B</kbd><span> type</span><span>, and when you instantiate a</span> <kbd>Left</kbd><span> type, you need to provide a value of an</span> <kbd>A</kbd><span> type</span><span>. Therefore, </span><kbd>Either[A, B]</kbd> <span>can either hold a value of type</span> <kbd>A</kbd> <span>or a value of type</span> <kbd>B</kbd><span>.</span></p>
<p>The following code shows an example of such a usage that you can type in a new Scala worksheet:</p>
<pre><span>def </span><span>divide</span>(x: <span>Double, </span>y: <span>Double</span>): <span>Either</span>[<span>String</span><span>, Double</span>] =<br/>  <span>if </span>(y == <span>0</span>)<br/>    <span>Left</span>(<span>s"</span><span>$</span>x<span> cannot be divided by zero"</span>)<br/>  <span>else<br/></span><span>    </span><span>Right</span>(x / y)<br/><br/>divide(<span>6</span><span>, </span><span>3</span>)<br/><span>// res0: Either[String,Double] = Right(2.0)<br/></span>divide(<span>6</span><span>, </span><span>0</span>)<br/><span>// res1: Either[String,Double] = Left(6.0 cannot be divided by zero)</span><span> </span></pre>
<p>The <kbd>divide</kbd> <span>function</span><span> </span><span>returns either a string or a double:</span></p>
<ul>
<li>If the function cannot compute a value, it returns an error <kbd>String</kbd> wrapped in a <kbd>Left</kbd> type</li>
<li>If the function can compute a correct value, it returns the <kbd>Double</kbd> value wrapped in a <kbd>Right</kbd> type</li>
</ul>
<p>By convention, we use <kbd>Right</kbd> to represent the correct or right value, and we use <kbd>Left</kbd> to represent an error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulating Either</h1>
                </header>
            
            <article>
                
<p>Since <kbd>Either</kbd> is an ADT, we can use pattern matching to decide what to do when we get a <kbd>Left</kbd> or <kbd>Right</kbd> type.</p>
<p>The following is a modified version of the <kbd>personDescription</kbd> function that we showed earlier in the <em>Using Option</em> section:</p>
<pre><span>def </span><span>getPersonAge</span>(name: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): <span>Either</span>[<span>String</span><span>, Int</span>] =<br/>  db.get(name).toRight(<span>s"</span><span>$</span>name<span> is not present in db"</span>)<br/><br/><span>def </span><span>personDescription</span>(name: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): <span>String </span>=<br/>  getPersonAge(name<span>, </span>db) <span>match </span>{<br/>    <span>case </span><span>Right</span>(age) =&gt; <span>s"</span><span>$</span>name<span> is </span><span>$</span>age<span> years old"<br/></span><span>    </span><span>case </span><span>Left</span>(error) =&gt; error<br/>  }<br/><br/><span>val </span>db = <span>Map</span>(<span>"John" </span>-&gt; <span>25</span><span>, </span><span>"Rob" </span>-&gt; <span>40</span>)<br/>personDescription(<span>"John"</span><span>, </span>db)<br/><span>// res4: String = John is 25 years old<br/></span>personDescription(<span>"Michael"</span><span>, </span>db)<br/><span>// res5: String = Michael is not present in db</span></pre>
<p>The first <kbd>getPersonAge </kbd><span>function </span><span>produces </span><kbd>Right(age)</kbd> <span>if the</span> <kbd>name </kbd><span>argument</span><span> </span><span>is present in </span><kbd>db</kbd><span>. If</span> <kbd>name</kbd> <span>is not present in</span> <kbd>db</kbd><span>, it returns an error message wrapped in a </span><kbd>Left</kbd><span> type. For this purpose, we use the</span> <kbd>Option.toRight </kbd><span>method</span><span>. I encourage you to have a look at the documentation and implementation of this method.</span></p>
<p>The implementation of <kbd>personDescription</kbd> is straightforward—we pattern match using the result of <kbd>getPersonAge</kbd> and return an appropriate <kbd>String</kbd> depending on whether the result is a <kbd>Left</kbd> or <kbd>Right</kbd> type.</p>
<p>As with <kbd>Option</kbd>, we can also use <kbd>map</kbd> and <kbd>flatMap</kbd> to combine several instances of <kbd>Either</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>averageAge</span>(name1: <span>String</span><span>, </span>name2: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): <span>Either</span>[<span>String</span><span>, Double</span>] =<br/>  getPersonAge(name1<span>, </span>db).flatMap(age1 =&gt;<br/>    getPersonAge(name2<span>, </span>db).map(age2 =&gt;<br/>      (age1 + age2).toDouble / <span>2</span>))<br/><br/>averageAge(<span>"John"</span><span>, </span><span>"Rob"</span><span>, </span>db)<br/><span>// res4: Either[String,Double] = Right(32.5)<br/></span>averageAge(<span>"John"</span><span>, </span><span>"Michael"</span><span>, </span>db)<br/><span>// res5: Either[String,Double] = Left(Michael is not present in db)</span></pre>
<p><span>Note how the body of the function is almost the same as <kbd>Option</kbd>. This is because <kbd>Either</kbd> is <strong>right biased</strong>, meaning that <kbd>map</kbd> and <kbd>flatMap</kbd> transform the right side of <kbd>Either</kbd>.<br/></span></p>
<p>If you want to transform the <kbd>Left</kbd> side of <kbd>Either</kbd>, you need to call the <kbd>Either.left </kbd><span>method, as shown in the following code</span><span>:</span></p>
<pre>getPersonAge(<span>"bob"</span><span>, </span>db).left.map(err =&gt; <span>s"The error was: </span><span>$</span>err<span>"</span>)<br/><span>// res6: scala.util.Either[String,Int] = Left(The error was: bob is not present in db)</span></pre>
<p>Since <kbd>Either</kbd> implements <kbd>map</kbd> and <kbd>flatMap</kbd>, we can refactor <kbd>averageAge</kbd> to use a <kbd>for</kbd> comprehension, as shown in the following code:</p>
<pre><span>def </span><span>averageAge2</span>(name1: <span>String</span><span>, </span>name2: <span>String</span><span>, </span>db: <span>Map</span>[<span>String</span><span>, Int</span>]): <span>Either</span>[<span>String</span><span>, Double</span>] =<br/>  <span>for </span>{<br/>    age1 &lt;- getPersonAge(name1<span>, </span>db)<br/>    age2 &lt;- getPersonAge(name2<span>, </span>db)<br/>  } <span>yield </span>(age1 + age2).toDouble / <span>2</span></pre>
<p>Again, the code looks the same as it did with <kbd>Option</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the retirement calculator to use Either</h1>
                </header>
            
            <article>
                
<p>Now that we have a good understanding of how to manipulate <kbd>Either</kbd>, we are going to refactor our retirement calculator to take advantage of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring nbOfMonthsSavings</h1>
                </header>
            
            <article>
                
<p>In the previous section, we changed the return type of <kbd>nbOfMonthsSavings</kbd> to return <kbd>Option[Int]</kbd>. The function returned <kbd>None</kbd> if the <kbd>expenses</kbd> <span>arguments</span><span> </span><span>were</span> <span>greater than</span> <kbd>income</kbd><span>. We are now going to change it to return an error message wrapped in </span><kbd>Left</kbd><span>.</span></p>
<p>We could use a simple string for our error message, but the best practice when using <kbd>Either</kbd> is to create an ADT for all of the possible error messages. Create a new Scala class in <kbd>src/main/scala/retcalc</kbd> called <kbd>RetCalcError</kbd>, as shown in the following code:</p>
<pre><span>package </span>retcalc<br/><br/>sealed abstract class RetCalcError(val message: String)<br/><br/><span>object </span>RetCalcError {<br/>  case class MoreExpensesThanIncome(income: Double, expenses: Double) <br/>  extends RetCalcError(<br/>    s"Expenses: $expenses &gt;=  $income. You will never be able to save <br/>    enough to retire !")<br/>}</pre>
<p>We define a <kbd>RetCalcError</kbd> trait that has only one <kbd>message </kbd><span>method</span><span>. This method will produce the error message whenever we need to return it to the user. Inside the</span> <kbd>RetCalcError </kbd><span>object</span><span>, we define one case class per type of error message. We will then change the functions that need to return an error to return </span><kbd>Either[RetCalcError, A]</kbd><span>.</span></p>
<p>This pattern has many advantages over just using <kbd>String</kbd>, as shown in the following list:</p>
<ul>
<li>All of the error messages are located in one place. It allows you to immediately know what are all the possible error messages that can be returned to the user. You could also add different translations if your application uses multiple languages.</li>
<li>Since <kbd>RetCalcError</kbd> is an ADT, you can use pattern matching to recover from a specific error and take action.</li>
<li>It simplifies testing. You can test whether a function returns a specific type of error without having to assert on the error message itself. This way, you can change your error messages without having to change any test.</li>
</ul>
<p>Now we can refactor our <kbd>RetCalc.nbOfMonthsSavings </kbd><span>function</span><span> </span><span>to return</span> <kbd>Either[RetCalcError, Int]</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>nbOfMonthsSaving</span>(params: RetCalcParams<span>, <br/>                     </span>returns: Returns): <strong>Either[RetCalcError, Int]</strong> = {<br/>  <span>import </span>params._<br/>  <span>@tailrec<br/></span><span>  </span><span>def </span><span>loop</span>(months: <span>Int</span>): <span>Int </span>= {<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <br/>      <span>simulatePlan</span>(returns<span>, </span>params<span>, </span>months)<br/>    <span>if </span>(capitalAfterDeath &gt; <span>0.0</span>)<br/>      months<br/>    <span>else<br/></span><span>      </span>loop(months + <span>1</span>)<br/>  }<br/><br/>  <span>if </span>(netIncome &gt; currentExpenses)<br/>    <strong>Right</strong>(loop(<span>0</span>))<br/>  <span>else<br/></span><span>    </span><strong>Left</strong>(<strong>MoreExpensesThanIncome</strong>(netIncome<span>, </span>currentExpenses))<br/>}</pre>
<p>We also have to change the corresponding unit tests. ScalaTest provides convenient extensions to perform assertions on the <kbd>Either</kbd> type. To bring them in scope, extend <kbd>EitherValues</kbd> in <kbd>RetCalcSpec.scala</kbd>, as shown in the following code:</p>
<pre><span>class </span>RetCalcSpec <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals <br/>  <strong>with EitherValues</strong> {</pre>
<p>If you have a <kbd>myEither </kbd><span>variable</span><span> </span><span>of the</span> <kbd>Either[A, B]</kbd><span> </span><span>type</span><span> </span><span>in your test, then </span><kbd>EitherValues</kbd> <span>will let us use the following methods:</span></p>
<ul>
<li><kbd>myEither.left.value</kbd> returns the left value of type <kbd>A</kbd> or fails the test if <kbd>myEither</kbd> is <kbd>Right</kbd></li>
<li><kbd>myEither.right.value</kbd> returns the right value of type <kbd>B</kbd> or fails the test if <kbd>myEither</kbd> is <kbd>Left</kbd></li>
</ul>
<p>We can now change our unit tests on <kbd>nbOfMonthsSaving</kbd> as follows:</p>
<pre><span>"RetCalc.nbOfMonthsSaving" </span>should {<br/>  <span>"calculate how long I need to save before I can retire" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<span>params</span><span>, <br/>    </span><span>FixedReturns</span>(<span>0.04</span>))<strong>.right.value</strong><br/>    <span>val </span>expected = <span>23 </span>* <span>12 </span>+ <span>1<br/></span><span>    </span>actual should ===(expected)<br/>  }<br/><br/>  <span>"not crash if the resulting nbOfMonths is very high" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<br/>      params = <span>RetCalcParams</span>(<br/>        nbOfMonthsInRetirement = <span>40 </span>* <span>12</span><span>,<br/></span><span>        </span>netIncome = <span>3000</span><span>, </span>currentExpenses = <span>2999</span><span>, </span>initialCapital = <span>0</span>)<span>,<br/></span><span>      </span>returns = <span>FixedReturns</span>(<span>0.01</span>))<strong>.right.value</strong><br/>    <span>val </span>expected = <span>8280<br/></span><span>    </span>actual should ===(expected)<br/>  }<br/><br/>  <span>"not loop forever if I enter bad parameters" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<br/>      <span>params</span>.copy(netIncome = <span>1000</span>)<span>, </span><span>FixedReturns</span>(<span>0.04</span>))<strong>.left.value</strong><br/>    actual should ===<strong>(RetCalcError.MoreExpensesThanIncome</strong>(<span>1000</span><span>, </span><span>2000</span>))<br/>  }<br/>}</pre>
<p>Run the unit test. It should pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring monthlyRate</h1>
                </header>
            
            <article>
                
<p>In <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml" target="_blank">Chapter 2</a>, <em>Developing a Retirement Calculator</em>, we implemented a <kbd>Returns.monthlyRate(returns: Returns, month: Int): Double</kbd> <span>function</span><span> </span><span>that returned the monthly return rate for a given month. When we called it with a month exceeding the size of an instance of </span><kbd>VariableReturns</kbd><span>, we rolled over to the first month using a modulo operation.</span></p>
<p>This was not completely satisfying, as it could compute unrealistic simulations. Say that your <kbd>VariableReturns</kbd> instance contains data for 1950 to 2017. When you ask the monthly returns for 2018, <kbd>monthlyRate</kbd> would give you the returns that we had in 1950. The economic outlook of the fifties was very different compared to the current one, and it is unlikely that the returns in 2018 will mirror those in 1950.</p>
<p>Therefore, we are going to change <kbd>monthlyRate</kbd> to return an error if the <kbd>month</kbd> argument is outside the bounds of <kbd>VariableReturn</kbd>. First, open <kbd>RetCalcError.scala</kbd> and add the following error type:</p>
<pre>case class ReturnMonthOutOfBounds(month: Int, maximum: Int) extends RetCalcError(<br/>  s"Cannot get the return for month $month. Accepted range: 0 to $maximum")</pre>
<p>Next, we are going to change the unit tests to specify the function t<span>hat we expect</span><span> it to return</span><span>. Open</span> <kbd>ReturnsSpec.scala</kbd><span> and change the tests as follows:</span></p>
<pre><span>"Returns.monthlyReturn" </span>should {<br/>  <span>"return a fixed rate for a FixedReturn" </span>in {<br/>    Returns.<span>monthlyRate</span>(<span>FixedReturns</span>(<span>0.04</span>)<span>, </span><span>0</span>)<strong>.right.value</strong> should ===<br/>    (<span>0.04 </span>/ <span>12</span>)<br/>    Returns.<span>monthlyRate</span>(<span>FixedReturns</span>(<span>0.04</span>)<span>, </span><span>10</span>)<strong>.right.value</strong> should ===<br/>    (<span>0.04 </span>/ <span>12</span>)<br/>  }<br/><br/>  <span>val </span>variableReturns = <span>VariableReturns</span>(<br/>    <span>Vector</span>(<span>VariableReturn</span>(<span>"2000.01"</span><span>, </span><span>0.1</span>)<span>, </span><span>VariableReturn</span>(<span>"2000.02"</span><span>, <br/>    </span><span>0.2</span>)))<br/>  <span>"return the nth rate for VariableReturn" </span>in {<br/>    Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>0</span>)<strong>.right.valu</strong>e should ===(<span>0.1</span>)<br/>    Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>1</span>)<strong>.right.value</strong> should ===(<span>0.2</span>)<br/>  }<br/><br/>  <span>"<strong>return None if n &gt; length</strong>" </span>in {<br/>    Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>2</span>)<strong>.left.value</strong> should ===(<br/>      <strong>RetCalcError.ReturnMonthOutOfBounds(2, 1)</strong>)<br/>    Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>3</span>).left.value should ===(<br/>      <strong>RetCalcError.ReturnMonthOutOfBounds(3, 1)</strong>)<br/>  }<br/><br/>  <span>"return the n+offset th rate for OffsetReturn" </span>in {<br/>    <span>val </span>returns = <span>OffsetReturns</span>(variableReturns<span>, </span><span>1</span>)<br/>    Returns.<span>monthlyRate</span>(returns<span>, </span><span>0</span>)<strong>.right.value</strong> should ===(<span>0.2</span>)<br/>  }<br/>}</pre>
<p>Then, open <kbd>Returns.scala</kbd> and change <kbd>monthlyRate</kbd> As follows:</p>
<pre><span>def </span><span>monthlyRate</span>(returns: Returns<span>, </span>month: <span>Int</span>): <strong>Either[RetCalcError, Double]</strong> = returns <span>match </span>{<br/>  <span>case </span><span>FixedReturns</span>(r) =&gt; <strong>Right</strong>(r / <span>12</span>)<br/><br/>  <span>case </span><span>VariableReturns</span>(rs) =&gt;<br/>    <span>if </span>(rs.isDefinedAt(month))<br/>      <strong>Right</strong>(rs(month).monthlyRate)<br/>    <span>else<br/></span><span>      </span><strong>Left(RetCalcError.ReturnMonthOutOfBounds(month, rs.size - 1))</strong><br/><br/>  <span>case </span><span>OffsetReturns</span>(rs<span>, </span>offset) =&gt; <span>monthlyRate</span>(rs<span>, </span>month + offset)<br/>}</pre>
<p>Try to compile the project now. Since <kbd>monthlyRate</kbd> is called by other functions, we will get some compilation errors, which is actually a good thing. We just have to fix the compilation errors to make our code deal with the possibility of an error. Every fix requires some thinking about what to do with that possibility.</p>
<p>On the other hand, if we had thrown an exception instead of returning <kbd>Either</kbd>, everything would have compiled, but the program would have crashed whenever the month was out of bounds. It would have been more difficult to achieve the desired behavior because the compiler would not have helped us.</p>
<p>The first compilation error is in <kbd>RetCalc.scala</kbd> in <kbd>futureCapital</kbd>, as shown in the following code:</p>
<pre>Error:(55, 26) overloaded method value + with alternatives:<br/>(...)<br/> cannot be applied to (Either[retcalc.RetCalcError,Double])<br/>        accumulated * (1 + Returns.monthlyRate(returns, month)) + <br/>        monthlySavings</pre>
<p>This means that we cannot call the <kbd>+</kbd> <span>method</span><span> </span><span>on</span> <kbd>Either[RetCalcError, Double]</kbd><span>. If</span> <kbd>monthlyRate</kbd> <span>returns</span> <kbd>Left</kbd><span>, we cannot calculate the accumulated capital. The best course of action would be to stop here and return the error. For this, we need to change the return type of</span> <kbd>futureCapital</kbd> <span>to</span> <kbd>Either[RetCalcError, Double]</kbd> <span>as well.</span></p>
<p>The following is the corrected version of the function:</p>
<pre><span>def </span><span>futureCapital</span>(returns: Returns<span>, </span>nbOfMonths: <span>Int, </span>netIncome: <span>Int, </span>currentExpenses: <span>Int,<br/></span><span>                  </span>initialCapital: <span>Double</span>): <strong>Either[RetCalcError, Double]</strong> = {<br/>  <span>val </span>monthlySavings = netIncome - currentExpenses<br/>  (<span>0 </span>until nbOfMonths).foldLeft<strong>[Either[RetCalcError, Double]]<br/>  </strong>(<strong>Right(initialCapital)</strong>) {<br/>    <span>case </span>(accumulated<span>, </span>month) =&gt;<br/>      <strong>for </strong>{<br/>        acc &lt;- accumulated<br/>        monthlyRate &lt;- Returns.<span>monthlyRate</span>(returns<span>, </span>month)<br/>      } <strong>yield </strong>acc * (<span>1 </span>+ monthlyRate) + monthlySavings<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p>In the second line, we changed the initial element passed to <kbd>foldLeft</kbd>. We are now accumulating <kbd>Either[RetCalcError, Double]</kbd>. Note that we have to explicitly specify the type parameter for <kbd>foldLeft</kbd>. In the previous version of the function, when we were using <kbd>Double</kbd>, that type was inferred automatically.</p>
<p>If we do not specify the type parameter, the compiler will infer it to be of the type of the initial element. In our case, <kbd>Right(initialCapital)</kbd> is of the <kbd>Right[Nothing, Double] </kbd><span>type</span><span>, which is a subclass of</span> <kbd>Either[RetCalcError, Double]</kbd><span>. The problem is that, inside the anonymous function, we return </span><kbd>Either[RetCalcError, Double]</kbd><span>, not </span><kbd>Right[Nothing, Double]</kbd><span>. The compiler would complain that the types do not match.</span></p>
<p>Inside the anonymous function passed to <kbd>foldLeft</kbd>, we use a <kbd>for</kbd> comprehension to do the following:</p>
<ul>
<li>Return the accumulated result in <kbd>Right</kbd> if both <kbd>acc</kbd> and <kbd>monthlyRate</kbd> are <kbd>Right</kbd></li>
<li>Return <kbd>Left</kbd> if <kbd>acc</kbd> or <kbd>monthlyRate</kbd> is <kbd>Left</kbd></li>
</ul>
<p>Note that our implementation does not stop as soon as <kbd>monthlyRate</kbd> returns <kbd>Left</kbd>, which is a bit inefficient. There is no point in iterating through the other months when we get an error because this function should always return the first error it encounters. In <a href="79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml" target="_blank">Chapter 4</a>, <em>Advanced Features</em>, we will see how we can use lazy evaluation with <kbd>foldr</kbd> to stop the iteration early.</p>
<p>Compile the project again. Now we need to fix a compilation error in <kbd>simulatePlan</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring simulatePlan</h1>
                </header>
            
            <article>
                
<p>Since <kbd>simulatePlan</kbd> calls <kbd>futureCapital</kbd>, we need to change its implementation to take into account the new return type, as shown in the following code:</p>
<pre><span>def </span><span>simulatePlan</span>(returns: Returns<span>, </span>params: RetCalcParams<span>, </span>nbOfMonthsSavings: <span>Int,<br/></span><span>                 </span>monthOffset: <span>Int </span>= <span>0</span>): <strong>Either[RetCalcError, (Double, <br/>Double)]</strong> = {<br/>  <span>import </span>params._<br/><br/>  <strong>for {</strong><br/>    capitalAtRetirement &lt;- <span>futureCapital</span>(<br/>      returns = <span>OffsetReturns</span>(returns<span>, </span>monthOffset)<span>,<br/></span><span>      </span>nbOfMonths = nbOfMonthsSavings<span>, </span>netIncome = netIncome<span>, <br/>      </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = initialCapital)<br/><br/>    capitalAfterDeath &lt;- <span>futureCapital</span>(<br/>      returns = <span>OffsetReturns</span>(returns<span>, </span>monthOffset + <br/>      nbOfMonthsSavings)<span>,<br/></span><span>      </span>nbOfMonths = nbOfMonthsInRetirement<span>,<br/></span><span>      </span>netIncome = <span>0</span><span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = capitalAtRetirement)<br/>  } <strong>yield </strong>(capitalAtRetirement<span>, </span>capitalAfterDeath)<br/>}</pre>
<p>We moved the two calls to <kbd>futureCapital</kbd> inside a <kbd>for</kbd> comprehension. This way, if any of these calls return an error, <kbd>simulatePlan</kbd> will return it. If both calls succeed, <kbd>simulatePlan</kbd> will return the two double values in a tuple.</p>
<p>Compile the project. Now we need to fix a compilation error in <kbd>nbOfMonthsSaving</kbd>, which uses <kbd>simulatePlan</kbd>. The following code is the fixed version:</p>
<pre><span>def </span><span>nbOfMonthsSaving</span>(params: RetCalcParams<span>, </span>returns: Returns): <strong>Either[RetCalcError, Int]</strong> = {<br/>  <span>import </span>params._<br/>  <span>@tailrec<br/></span><span>  </span><span>def </span><span>loop</span>(months: <span>Int</span>): <strong>Either[RetCalcError, Int]</strong> = {<br/>    <span>simulatePlan</span>(returns<span>, </span>params<span>, </span>months) <strong>match </strong>{<br/>      <strong>case Right</strong>((capitalAtRetirement<span>, </span>capitalAfterDeath)) =&gt;<br/>        <span>if </span>(capitalAfterDeath &gt; <span>0.0</span>)<br/>          <strong>Right</strong>(months)<br/>        <span>else<br/></span><span>          </span>loop(months + <span>1</span>)<br/><br/>      <strong>case Left</strong>(err) =&gt; <strong>Left</strong>(err)<br/>    }<br/>  }<br/><br/>  <span>if </span>(netIncome &gt; currentExpenses)<br/>    loop(<span>0</span>)<br/>  <span>else<br/></span><span>    </span><span>Left</span>(<span>MoreExpensesThanIncome</span>(netIncome<span>, </span>currentExpenses))<br/>}</pre>
<p>We had to change our recursive <kbd>loop</kbd> function to return <kbd>Either[RetCalcError, Int]</kbd>. The loop will stop as soon as we get an error or <kbd>if (capitalAfterDeath &gt; 0.0)</kbd>. You might wonder why we did not use <kbd>flatMap</kbd> instead of using pattern matching. It would indeed have been more concise, but the <kbd>loop</kbd> function would not be tail recursive anymore, because the recursive call to loop would be inside an anonymous function. As an exercise, I encourage you to try changing the code so that it uses <kbd>flatMap</kbd> and observe the tail recursion compilation error.</p>
<p>Compile the project. The last compilation error in the production code is in <kbd>SimulatePlanApp.scala</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring SimulatePlanApp</h1>
                </header>
            
            <article>
                
<p>The entry point of our <kbd>SimulatePlanApp </kbd><span>application</span><span> </span><span>calls</span> <kbd>simulatePlan</kbd><span>. We need to change it to return the text of any error that could occur.</span></p>
<p>First, we need to change the integration test to add a new test case. Open  <kbd>SimulatePlanIT.scala</kbd> and add the following test:</p>
<pre>  "SimulatePlanApp.strMain" should {<br/>    "simulate a retirement plan using market returns" in {...}<br/><br/>    "<strong>return an error when the period exceeds the returns bounds</strong>" in {<br/>      val actualResult = SimulatePlanApp.strMain(<br/>        Array("1952.09,2017.09", "25", "60", "3000", "2000", "10000"))<br/>      val expectedResult = "Cannot get the return for month 780. <br/>      Accepted range: 0 to 779"<br/>      actualResult should === (expectedResult)<br/>    }<br/>  }</pre>
<p>Then, open <kbd>SimulatePlanApp.scala</kbd> and change the implementation of <kbd>SimulatePlanApp </kbd>as follows:</p>
<pre><span>object </span>SimulatePlanApp <span>extends </span>App {<br/>  <span>println</span>(<span>strMain</span>(args))<br/><br/>  <span>def </span><span>strMain</span>(args: Array[<span>String</span>]): <span>String </span>= {<br/>    <span>val </span>(from <span>+: </span>until <span>+: </span><span>Nil</span>) = args(<span>0</span>).split(<span>","</span>).toList<br/>    <span>val </span>nbOfYearsSaving = args(<span>1</span>).toInt<br/>    <span>val </span>nbOfYearsRetired = args(<span>2</span>).toInt<br/><br/>    <span>val </span>allReturns = Returns.<span>fromEquityAndInflationData</span>(<br/>      equities = EquityData.<span>fromResource</span>(<span>"sp500.tsv"</span>)<span>,<br/></span><span>      </span>inflations = InflationData.<span>fromResource</span>(<span>"cpi.tsv"</span>))<br/><br/>    RetCalc.<span>simulatePlan</span>(<br/>      returns = allReturns.fromUntil(from<span>, </span>until)<span>,<br/></span><span>      </span>params = <span>RetCalcParams</span>(<br/>        nbOfMonthsInRetirement = nbOfYearsRetired * <span>12</span><span>,<br/></span><span>        </span>netIncome = args(<span>3</span>).toInt<span>,<br/></span><span>        </span>currentExpenses = args(<span>4</span>).toInt<span>,<br/></span><span>        </span>initialCapital = args(<span>5</span>).toInt)<span>,<br/></span><span>      </span>nbOfMonthsSavings = nbOfYearsSaving * <span>12<br/></span><span>    </span>) <strong>match </strong>{<br/>      <strong>case Right</strong>((capitalAtRetirement<span>, </span>capitalAfterDeath)) =&gt;<br/>        <span>s"""<br/></span><span>           |Capital after </span><span>$</span>nbOfYearsSaving<span> years of savings:    <br/>            </span><span>$</span>{capitalAtRetirement.round}<span><br/></span><span>           |Capital after </span><span>$</span>nbOfYearsRetired<span> years in retirement: <br/>            </span><span>$</span>{capitalAfterDeath.round}<br/>        <span>"""</span>.stripMargin<br/><br/>      <strong>case Left(err) =&gt; err.message</strong><br/>    }<br/>  }<br/>}</pre>
<p>We just have to pattern match on the result of <kbd>simulatePlan</kbd>, and return a string explaining the result of the computation if it is a <kbd>Right</kbd> value, or return the error message if it is a <kbd>Left</kbd> value.</p>
<p>Compile the project. Now all the production code should compile, but there are still several compilation errors in the unit tests. As an exercise, I encourage you to try to fix them. In most cases, you have to make the test extend <kbd>EitherValues</kbd>, and call <kbd>.right.value</kbd> on an <kbd>Either</kbd> class to get its right value. Once you have fixed the remaining errors, compile and run all the tests of the project. They should all pass.</p>
<p>Now your code should look like the <kbd>Chapter03</kbd><span> branch </span><span>in the Scala fundamentals GitHub project, apart from the</span> <kbd>SimulatePlanApp</kbd> <span>class, which we will improve in the next section. See <a href="https://github.com/PacktPublishing/Scala-Programming-Projects">https://github.com/PacktPublishing/Scala-Programming-Projects</a></span> for more details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using ValidatedNel</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen how we can model the possibility of an optional value with <kbd>Option</kbd> and the possibility of an error with <kbd>Either</kbd>. We demonstrated how these types can replace exceptions while guaranteeing referential transparency.</p>
<p>We also saw how we can combine several <kbd>Option</kbd> or <kbd>Either</kbd> types using <kbd>flatMap</kbd>. This works well when we have to check for optional values or errors <em>sequentially</em>—call <kbd>function1</kbd>; if there is no error, call <kbd>function2</kbd>; if there is no error, call <kbd>function3</kbd>. If any of these functions return an error, we return that error and stop the call chain, as shown in the following code:</p>
<pre>def sequentialErrorHandling(x: String): Either[MyError, String] =<br/>  for {<br/>    a &lt;- function1(x)<br/>    b &lt;- function2(a)<br/>    c &lt;- function3(b)<br/>  } yield c</pre>
<p>However, in some situations, we would want to call several functions in parallel and return all the errors that might have occurred. For instance, when you enter some personal details to purchase a product from an online shop, you expect the website to highlight all the mistakes in all the fields after you submit the details. It would be a bad user experience to have the website tell you that the last name is mandatory after submitting the details, and subsequently that your password is too short after submitting the details again. All the fields must be validated simultaneously and all errors must be returned to the user in one go.</p>
<p>The data structure that can help us address this use case is <kbd>Validated</kbd>. Unfortunately, it is not part of the Scala SDK, and we have to use an external library called <kbd>cats</kbd> to bring it into our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the cats dependency</h1>
                </header>
            
            <article>
                
<p>The <kbd>cats</kbd> library provides abstractions for functional programming. Its name comes from the shortening of the phrase <em>category theory</em>. It is also a reference to the famous joke that managing developers is like herding cats—the truth is that you don't really have control—cats do whatever they want.</p>
<p>In this chapter, we are going to focus only on <kbd>Validated</kbd> and <kbd>NonEmptyList</kbd>, but <kbd>cats</kbd> offers many more powerful abstractions that we will explore later in this book.</p>
<p>First, edit <kbd>built.sbt</kbd> and add the following lines:</p>
<pre><span>libraryDependencies </span>+= <span>"org.typelevel" </span>%% <span>"cats-core" </span>% <span>"1.0.1"<br/></span><span>scalacOptions </span>+= <span>"-Ypartial-unification"</span></pre>
<p>This brings the <kbd>cats</kbd> dependency to our project and also enables a compiler flag (<kbd>partial unification</kbd>) that is required by the library to infer types correctly.</p>
<p>Save the project with <em>Ctrl</em> + <em>S</em>. IntelliJ should offer to update the project to reflect the changes in the <kbd>build</kbd> file. Click on <span class="packt_screen">Refresh Project</span> on top of <kbd>built.sbt</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing NonEmptyList</h1>
                </header>
            
            <article>
                
<p>As its name implies, the <kbd>cats.data.NonEmptyList</kbd> <span>type</span><span> </span><span>represents a </span><kbd>List</kbd><span> instance that has at least one element. In other words, it is a </span><kbd>List</kbd><span> instance that cannot be empty. The following are some examples of this usage that you can retype in a new Scala worksheet:</span></p>
<pre><span>import </span>cats.data.NonEmptyList<br/><br/>NonEmptyList(<span>1</span><span>, </span><span>List</span>(<span>2</span><span>, </span><span>3</span>))<br/><span>// res0: cats.data.NonEmptyList[Int] = NonEmptyList(1, 2, 3)<br/></span>NonEmptyList.<span>fromList</span>(<span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>))<br/><span>// res3: Option[cats.data.NonEmptyList[Int]] = Some(NonEmptyList(1, 2, 3))<br/></span>NonEmptyList.<span>fromList</span>(<span>List</span>.<span>empty</span>[<span>Int</span>])<br/><span>// res4: Option[cats.data.NonEmptyList[Int]] = None<br/></span><strong>val nel = NonEmptyList.of(1, 2, 3)</strong><br/><span>// nel: cats.data.NonEmptyList[Int] = NonEmptyList(1, 2, 3)<br/></span><span><br/></span>nel.head<br/><span>// res0: Int = 1<br/></span>nel.tail<br/><span>// res1: List[Int] = List(2, 3)<br/></span>nel.map(_ + <span>1</span>)<br/><span>// res2: cats.data.NonEmptyList[Int] = NonEmptyList(2, 3, 4)</span></pre>
<p>You can construct <kbd>NonEmptyList</kbd> with the following:</p>
<ul>
<li><kbd>apply[A]</kbd>: You can pass a <kbd>head</kbd> element and a <kbd>List</kbd> as a tail.</li>
<li><kbd>fromList[A]</kbd>: You can pass <kbd>List</kbd>. You get back <kbd>Option[NonEmptyList[A]]</kbd> that will be <kbd>None</kbd> if the <kbd>List</kbd> argument is empty.</li>
<li><kbd>of[A]</kbd>: You can pass a <kbd>head</kbd> element and variable length <kbd>List </kbd>argument for the tail. This is is the most convenient way of building <kbd>NonEmptyList</kbd> when you know its constituents.</li>
</ul>
<p>Since <kbd>NonEmptyList</kbd> always contains at least one element, we can always call the <kbd>head</kbd> <span>method</span><span> </span><span>without risking getting an exception. As a consequence, there is no</span> <kbd>headOption</kbd> <span>method. You can manipulate </span><kbd>NonEmptyList</kbd> <span>with all the usual methods that you would use on</span> <kbd>List</kbd><span>:</span> <kbd>map</kbd><span>,</span> <kbd>tail</kbd><span>,</span> <kbd>flatMap</kbd><span>,</span> <kbd>filter</kbd><span>, and</span> <kbd>foldLeft</kbd><span>, to name a few.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Validated</h1>
                </header>
            
            <article>
                
<p>The <kbd>cats.data.Validated[E, A]</kbd><span>type</span><span> </span><span>is very similar to</span> <kbd>Either[E, A]</kbd><span>. It is an ADT that represents a value of either an</span> <kbd>Invalid</kbd> <span>type or a</span> <kbd>Valid</kbd> <span>type. A simplified definition would be the following:</span></p>
<pre>sealed trait Validated[+E, +A]<br/>case class Valid[+A](a: A) extends Validated[Nothing, A]<br/>case class Invalid[+E](e: E) extends Validated[E, Nothing]</pre>
<p>We will see <span>what the</span><span> </span><kbd>+</kbd><span> </span><span>sign in front of a type parameter means</span><span> in the section on covariance and contravariance in</span> <a href="79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml" target="_blank">Chapter 4</a><span>, </span><em>Advanced Features</em><span>. For now, though, do not worry about it.</span></p>
<div class="packt_infobox"><span>Similarly to the definition of <kbd>Option</kbd>, the definitions use contravariance and <kbd>Nothing</kbd>. This way, <kbd>Valid[A]</kbd></span> <span>is a subtype of <kbd>Validated[E, A]</kbd> for any <kbd>E</kbd>; and <kbd>Invalid[E]</kbd> is a subtype of <kbd>Validated[E, A]</kbd> for any <kbd>A</kbd>.<br/></span></div>
<p>The main difference with <kbd>Either</kbd> is that we can accumulate the errors produced by several <kbd>Validated</kbd> instances. Here are some examples that you can retype in a new Scala worksheet. I advise you to uncheck the <span class="packt_screen">T</span><span class="packt_screen">ype-aware highlighting</span> box in the bottom-right corner of IntelliJ; otherwise, IntelliJ will underline some expressions in red, even though they compile fine:</p>
<pre><span>import </span>cats.data._<br/><span>import </span>cats.data.Validated._<br/><span>import </span>cats.implicits._<br/><br/><span>val </span>valid1: Validated[NonEmptyList[<span>String</span>]<span>, Int</span>] = <span>Valid</span>(<span>1</span>)<br/><span>// valid1: cats.data.Validated[cats.data.NonEmptyList[String],Int] = Valid(1)<br/><br/></span><span>val </span>valid2 = <span>2</span>.validNel[<span>String</span>]<br/><span>// valid2: cats.data.ValidatedNel[String,Int] = Valid(2)<br/><br/></span>(valid1<span>, </span>valid2).<strong>mapN</strong> { <span>case </span>(i1<span>, </span>i2) =&gt; i1 + i2 }<br/><span>// res1: cats.data.ValidatedNel[String,Int] = <strong>Valid(3)</strong><br/><br/>val invalid3: ValidatedNel[String, Int] = Invalid(NonEmptyList.of("error"))<br/>val invalid4 = "another error".invalidNel[Int]<br/>(valid1, valid2, invalid3, invalid4).<strong>mapN</strong> { case (i1, i2, i3, i4) =&gt; i1 + i2 + i3 + i4 }<br/>// res2: cats.data.ValidatedNel[String,Int] = <strong>Invalid(NonEmptyList(error, another error))</strong><br/></span></pre>
<p>We first define a <kbd>Valid</kbd> value of <kbd>1</kbd>, with a <kbd>Valid</kbd> type <kbd>Int</kbd> parameter, and an <kbd>Invalid</kbd> type <kbd>NonEmptyList[String]</kbd> parameter. Each error will be of a <kbd>String</kbd> type, and the <kbd>NonEmptyList</kbd> instance will force us to have at least one error when we produce an <kbd>Invalid</kbd> value. This usage is so common that <kbd>cats</kbd> provide a type alias called <kbd>ValidatedNel</kbd> in the <kbd>cats.data </kbd><span>package, as shown in the following code</span><span> </span><span>:</span></p>
<pre>type ValidatedNel[+E, +A] = Validated[NonEmptyList[E], A]</pre>
<p>Going back to our example, in the second line, we define a <kbd>Valid</kbd> value of <kbd>2</kbd> using a handy <kbd>cats</kbd> method called <kbd>.validNel</kbd>. When calling <kbd>validNel</kbd>, we have to pass the type of error, because in this case, the compiler does not have any information to infer it. In our case, the error type is <kbd>String</kbd>. The resulting type of <kbd>valid2</kbd> is <kbd>ValidatedNel[String, Int]</kbd>, which is an alias for <kbd>Validated[NonEmptyList[String], Int]</kbd>.</p>
<p>In the third line, we <em>compose</em> the two valid values by putting them in a tuple and call <kbd>mapN</kbd>. The <kbd>mapN</kbd> phrase accepts an <kbd>f </kbd><span>function</span><span> </span><span>that takes as many arguments as there are elements in the tuple. If</span> <em>all</em> of <span>the elements of the tuple are</span> <kbd>Valid</kbd> <span>values,</span> <kbd>f</kbd> <span>is called and its result will be wrapped in a</span> <kbd>Valid</kbd> <span>value. If</span> <em>any</em> <span>of the elements inside the tuple are </span><kbd>Invalid</kbd> <span>values, then all the</span> <kbd>Invalid</kbd> <span>values are</span> <em>combined</em> <span>together and wrapped in an</span> <kbd>Invalid</kbd> <span>value.</span></p>
<p>We can observe that, when we compose <kbd>valid1</kbd> and <kbd>valid2</kbd>, which are all <kbd>Valid</kbd>, <kbd>mapN</kbd> returns a <kbd>Valid</kbd> value. When we compose <kbd>valid1</kbd>, <kbd>valid2</kbd>, <kbd>invalid3</kbd>, and <kbd>invalid4</kbd>, <kbd>mapN</kbd> returns an <kbd>Invalid</kbd> value. This <kbd>Invalid</kbd> value wraps a <kbd>NonEmptyList</kbd> that contains the errors of <kbd>invalid3</kbd> and <kbd>invalid4</kbd>.</p>
<p>We now know two mechanisms to represent the possibility of a failure:</p>
<ul>
<li><kbd>Either</kbd> with <kbd>for...yield</kbd> can be used to validate <em>sequentially</em>,<strong> </strong>stopping at the first error encountered</li>
<li><kbd>Validated</kbd> with <kbd>mapN</kbd> can be used to validate in parallel, accumulating all the errors in <kbd>NonEmptyList</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the retirement calculator to use ValidatedNel</h1>
                </header>
            
            <article>
                
<p>With this new knowledge, we are well equipped to improve our retirement calculator further. We are going to improve <kbd>SimulatePlanApp</kbd> to give the users more information if one or many arguments passed to the program are wrong.</p>
<p>When many arguments are wrong, for instance, if the user passes some random text instead of a parsable number, we want to report one error for every bad argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding unit tests</h1>
                </header>
            
            <article>
                
<p>Firstly, we need to change the test associated with <kbd>SimulatePlanApp</kbd>. Open <kbd>SimulatePlanAppIT.scala</kbd> and change the content as follows:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>cats.data.Validated.{Invalid<span>, </span>Valid}<br/><span>import </span>org.scalactic.TypeCheckedTripleEquals<br/><span>import </span>org.scalatest.{Matchers<span>, </span>WordSpec}<br/><br/><span>class </span>SimulatePlanAppIT <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals {<br/>  <span>"SimulatePlanApp.strMain" </span>should {<br/>    <span>"simulate a retirement plan using market returns" </span>in {<br/>      <span>val </span>actualResult = SimulatePlanApp.<span>strMain</span>(<br/>        <span>Array</span>(<span>"1952.09,2017.09"</span><span>, </span><span>"25"</span><span>, </span><span>"40"</span><span>, </span><span>"3000"</span><span>, </span><span>"2000"</span><span>, </span><span>"10000"</span>))<br/><br/>      <span>val </span>expectedResult =<br/>        <span>s"""<br/></span><span>           |Capital after 25 years of savings:    468925<br/></span><span>           |Capital after 40 years in retirement: 2958842<br/></span><span>           |"""</span>.stripMargin<br/>      actualResult should ===(<strong>Valid</strong>(expectedResult))<br/>    }<br/><br/>    <span>"return an error when the period exceeds the returns bounds" </span>in {<br/>      <span>val </span>actualResult = SimulatePlanApp.<span>strMain</span>(<br/>        <span>Array</span>(<span>"1952.09,2017.09"</span><span>, </span><span>"25"</span><span>, </span><span>"60"</span><span>, </span><span>"3000"</span><span>, </span><span>"2000"</span><span>, </span><span>"10000"</span>))<br/>      <span>val </span>expectedResult = <span>"Cannot get the return for month 780. <br/>      Accepted range: 0 to 779"<br/></span><span>      </span>actualResult should ===(<strong>Invalid</strong>(expectedResult))<br/>    }<br/><br/>    <span>"return an usage example when the number of arguments is incorrect" <br/>      </span>in {<br/>      <span>val </span>result = SimulatePlanApp.<span>strMain</span>(<br/>        <span>Array</span>(<span>"1952.09:2017.09"</span><span>, </span><span>"25.0"</span><span>, </span><span>"60"</span><span>, </span><span>"3'000"</span><span>, </span><span>"2000.0"</span>))<br/>      result should ===(<span>Invalid</span>(<br/>        <span>"""Usage:<br/></span><span>          |simulatePlan from,until nbOfYearsSaving nbOfYearsRetired <br/>          netIncome currentExpenses initialCapital<br/></span><span>          |<br/></span><span>          |Example:<br/></span><span>          |simulatePlan 1952.09,2017.09 25 40 3000 2000 10000<br/></span><span>          |"""</span>.stripMargin))<br/>    }<br/><br/>    <span>"return several errors when several arguments are invalid" </span>in {<br/>      <span>val </span>result = SimulatePlanApp.<span>strMain</span>(<br/>        <span>Array</span>(<span>"1952.09:2017.09"</span><span>, </span><span>"25.0"</span><span>, </span><span>"60"</span><span>, </span><span>"3'000"</span><span>, </span><span>"2000.0"</span><span>, <br/>        </span><span>"10000"</span>))<br/>      result should ===(<span>Invalid</span>(<br/>        <span>"""Invalid format for fromUntil. Expected: from,until, actual: <br/>          1952.09:2017.09<br/></span><span>          |Invalid number for nbOfYearsSaving: 25.0<br/></span><span>          |Invalid number for netIncome: 3'000<br/></span><span>          |Invalid number for currentExpenses: 2000.0"""</span>.stripMargin))<br/>    }<br/>  }<br/>}</pre>
<p>Let's have a look at the preceding code in detail:</p>
<ul>
<li>
<p>The first two tests do not change much—we just changed the expectations to be <kbd class="western">Valid(expectedResult)</kbd>. We are going to change the return type of <kbd class="western">SimulatePlanApp.strMain</kbd>—instead of returning a string, we are going to change it to return <kbd class="western">Validated[String, String]</kbd>. We expect <kbd class="western">strMain</kbd> to return a <kbd class="western">Valid</kbd> value containing the result if all arguments are correct. If some arguments are incorrect, it should return an <kbd class="western">Invalid</kbd> value containing <kbd class="western">String</kbd> explaining what the incorrect arguments <span>are</span>.</p>
</li>
<li>
<p>The third test is a new test. If we do not pass the right number of arguments, we expect <kbd class="western">strMain</kbd> to return an <kbd>Invalid</kbd> value containing a usage example.</p>
</li>
<li>
<p>The fourth test checks that one error for every bad argument is reported.</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing parsing functions</h1>
                </header>
            
            <article>
                
<p>The next step is to add new types of errors that will be returned in <kbd>ValidateNel</kbd> when some arguments are wrong. We need to change <kbd>RetCalcError.scala</kbd> as follows:</p>
<pre><span>object </span>RetCalcError {<br/><strong>  type RetCalcResult[A] = ValidatedNel[RetCalcError, A]</strong><br/><br/>  <span>case class </span>MoreExpensesThanIncome(income: <span>Double, </span>expenses: <span>Double</span>) <br/>    <span>extends </span>RetCalcError(...)<br/><br/>  <span>case class </span>ReturnMonthOutOfBounds(month: <span>Int, </span>maximum: <span>Int</span>) <span>extends <br/>    </span>RetCalcError(...)<br/><br/>  case class <strong>InvalidNumber</strong>(name: String, value: String) extends <br/>  RetCalcError(<br/>    s"Invalid number for $name: $value")<br/><br/>  case class <strong>InvalidArgument</strong>(name: String, <br/>                             value: String, <br/>                             expectedFormat: String) extends <br/>  RetCalcError(<br/>    s"Invalid format for $name. Expected: $expectedFormat, actual: <br/>    $value")<br/>}</pre>
<p>Here, we introduced an <kbd>InvalidNumber</kbd> error that will be returned when a string cannot be parsed into a number. The other error, <kbd>InvalidArgument</kbd>, will be returned when an argument is wrong. We will use it when the <kbd>from</kbd> and <kbd>until</kbd> parameters are wrong (see the preceding unit test). Also, as we are going to use many types of <kbd>ValidatedNel[RetCalcError, A]</kbd> form, we created a type alias, <kbd>RetCalcResult</kbd>. It will also help IntelliJ to autocomplete the functions of the <kbd>cats</kbd> library.</p>
<p>After that, we need to change <kbd class="western">SimulatePlanApp.strMain</kbd> to validate the arguments. For this, we start by writing a small function that parses one string argument to produce <kbd>Validated Int</kbd>.</p>
<div class="packt_infobox">Ideally, all the following parsing functions should be unit tested. We do have indirect test coverage for them in <kbd>SimulatePlanAppIT</kbd>, but it is not sufficient. In test-driven development, whenever you need to write a new function, you should just define its signature and then write a test before implementing it. Unfortunately, we do not have enough space in this book to show all of the unit tests that you would expect to have in a production application. However, as an exercise, I encourage you to write them.</div>
<p class="mce-root">We call this function <kbd>parseInt</kbd>. It takes the name of an argument and its value, and returns <kbd>Validated Int</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>parseInt</span>(name: <span>String</span><span>, </span>value: <span>String</span>): <span>RetCalcResult[</span><span>Int</span>] =<br/>  Validated<br/>    .<span>catchOnly</span>[<span>NumberFormatException</span>](value.toInt)<br/>    .leftMap(_ =&gt; NonEmptyList.<span>of</span>(<span>InvalidNumber</span>(name<span>, </span>value)))</pre>
<p>We first call the <kbd class="western">Validated.catchOnly</kbd><span> method</span><span>, which executes a block of code (in our case, </span><kbd class="western">value.toInt</kbd><span>) and catches a specific type of exception. If the block does not throw any exception,</span> <kbd class="western">catchOnly</kbd> <span>returns a</span> <kbd class="western">Valid</kbd> <span>value with the result. If the block throws the exception type passed as an argument (in our case, </span><kbd class="western">NumberFormatException</kbd><span>), then </span><kbd class="western">catchOnly</kbd> <span>returns an</span> <kbd class="western">Invalid</kbd> <span>value containing the caught exception. The resulting expression type is</span> <kbd class="western">Validated[NumberFormatException, Int]</kbd><span>. However, our</span> <kbd class="western">parseInt</kbd><span> function</span><span> </span><span>must return</span> <kbd>RetCalcResut[Int]</kbd><span>, which is an alias for</span> <kbd class="western">ValidatedNel[RetCalcError, Int]</kbd><span>. In order to transform the error or left type, we call the</span> <kbd class="western">Validated.leftMap</kbd><span> </span><span>method</span><span> </span><span>to produce </span><kbd class="western">NonEmptyList[RetCalcError]</kbd><span>.</span></p>
<p>Then, we write another function, <kbd>parseFromUntil</kbd>—that is in charge of parsing the <kbd>from</kbd> and <kbd>until </kbd><span>arguments</span><span>. These two arguments are separated by a comma, as shown in the following code:</span></p>
<pre><span>import cats.implicits._<br/>def </span><span>parseFromUntil</span>(fromUntil: <span>String</span>): <span>RetCalcResult</span>[(<span>String</span><span>, </span><span>String</span>)] = {<br/>  <span>val </span>array = fromUntil.split(<span>","</span>)<br/>  <span>if </span>(array.length != <span>2</span>)<br/>    <span>InvalidArgument</span>(<br/>      name = <span>"fromUntil"</span><span>, </span>value = fromUntil<span>, <br/>      </span>expectedFormat = <span>"from,until"<br/></span><span>    </span>).invalidNel<br/>  <span>else<br/></span><span>    </span>(array(<span>0</span>)<span>, </span>array(<span>1</span>)).validNel<br/>}</pre>
<p>We create an <kbd>Array[String]</kbd> with the <kbd>String.split </kbd><span>method.</span><span> If the array does not have exactly two elements, we return an</span> <kbd>Invalid</kbd> <span>value containing an</span> <kbd>InvalidArgument</kbd> <span>error. If the array has two elements, then we return them in a tuple inside a</span> <kbd>Valid</kbd> <span>value.</span></p>
<p>Finally, we write a <kbd>parseParams </kbd><span>function</span><span> </span><span>that accepts an array of arguments and produces </span><kbd>RetCalcResult[RetCalcParams]</kbd><span>. The </span><kbd>RetCalcParams</kbd><span> argument is one of the arguments required by</span> <kbd>RetCalc.simulatePlan</kbd>, as shown in the following code:</p>
<pre><span>def </span><span>parseParams</span>(args: Array[<span>String</span>]): <span>RetCalcResult</span>[RetCalcParams] =<br/>  (<br/>    <span>parseInt</span>(<span>"nbOfYearsRetired"</span><span>, </span>args(<span>2</span>))<span>,<br/></span><span>    </span><span>parseInt</span>(<span>"netIncome"</span><span>, </span>args(<span>3</span>))<span>,<br/></span><span>    </span><span>parseInt</span>(<span>"currentExpenses"</span><span>, </span>args(<span>4</span>))<span>,<br/></span><span>    </span><span>parseInt</span>(<span>"initialCapital"</span><span>, </span>args(<span>5</span>))<br/>  ).mapN { <span>case </span>(nbOfYearsRetired<span>, </span>netIncome<span>, </span>currentExpenses<span>, <br/>    </span>initialCapital) =&gt;<br/>    <span>RetCalcParams</span>(<br/>      nbOfMonthsInRetirement = nbOfYearsRetired * <span>12</span><span>,<br/></span><span>      </span>netIncome = netIncome<span>,<br/></span><span>      </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = initialCapital)<br/>  }</pre>
<p>The function assumes that the <kbd>args</kbd> array has at least six elements. We create a tuple of four elements, each element being the result of <kbd>parseInt</kbd>, and hence, it has the <kbd>RetCalcResult[Int]</kbd><span> type</span><span>. Then, we call the</span> <kbd>mapN</kbd><span> method</span><span> </span><span>on our</span> <kbd>Tuple4</kbd><span>, which will accumulate any error produced by the calls to</span> <kbd>parseInt</kbd><span>. If all of the</span> <kbd>parseInt</kbd> <span>calls return a</span> <kbd>Valid</kbd> <span>value, the anonymous function passed to</span> <kbd>mapN</kbd> <span>is called. It takes </span><kbd>Tuple4 (Int, Int, Int, Int)</kbd><span> and returns a</span> <kbd>RetCalcParams</kbd> <span>instance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing SimulatePlanApp.strSimulatePlan</h1>
                </header>
            
            <article>
                
<p>In order to keep <kbd>SimulatePlanApp.strMain</kbd> small and readable, we are going to extract the code that is in charge of calling <kbd>RetCalc.simulatePlan</kbd> and return a human-readable string detailing the result of the simulation. We call this new function <kbd>strSimulatePlan</kbd>, and use it as shown in the following code:</p>
<pre><span>def </span><span>strSimulatePlan</span>(returns: Returns<span>, </span>nbOfYearsSaving: <span>Int, </span>params: RetCalcParams)<br/>: <span>RetCalcResult</span>[<span>String</span>] = {<br/>  RetCalc.<span>simulatePlan</span>(<br/>    returns = returns<span>,<br/></span><span>    </span>params = params<span>,<br/></span><span>    </span>nbOfMonthsSavings = nbOfYearsSaving * <span>12<br/></span><span>  </span>).map {<br/>    <span>case </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) =&gt;<br/>      <span>val </span>nbOfYearsInRetirement = params.nbOfMonthsInRetirement / <span>12<br/></span><span>      </span><span>s"""<br/></span><span>         |Capital after </span><span>$</span>nbOfYearsSaving<span> years of savings:    <br/>        </span><span>$</span>{capitalAtRetirement.round}<span><br/></span><span>         |Capital after </span><span>$</span>nbOfYearsInRetirement<span> years in retirement: <br/>        </span><span>$</span>{capitalAfterDeath.round}<span><br/></span><span>         |"""</span>.stripMargin<br/>  }.toValidatedNel<br/>}</pre>
<p>The function takes the parsed arguments, calls <kbd>simulatePlan</kbd>, and transforms its result into a string. In order to keep the same type as our parsing functions, we declare the return type of the function to be <kbd>RetCalcResult[String]</kbd>. This is an alias for <kbd>ValidatedNel[RetCalcError, String]</kbd>, but <kbd>simulatePlan</kbd> returns <kbd>Either[RetCalcError, String]</kbd>. Fortunately, <kbd>cats</kbd> provide <kbd>.toValidatedNel</kbd><span> method</span><span> </span><span>to easily convert</span> <kbd>Either</kbd> <span>to</span> <kbd>ValidatedNel</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring SimulatePlanApp.strMain</h1>
                </header>
            
            <article>
                
<p>We have implemented some building blocks for parsing the whole arguments array. It is now time to refactor <kbd>SimulatePlanApp.strMain</kbd> to call them. First, we need to check that the arguments array has the right size, as shown in the following code:</p>
<pre><span>def </span><span>strMain</span>(args: Array[<span>String</span>]): <strong>Validated[String, String]</strong> = {<br/>  <span>if </span>(args.length != <span>6</span>)<br/>    <span>"""Usage:<br/></span><span>      |simulatePlan from,until nbOfYearsSaving nbOfYearsRetired <br/>       netIncome currentExpenses initialCapital<br/></span><span>      |<br/></span><span>      |Example:<br/></span><span>      |simulatePlan 1952.09,2017.09 25 40 3000 2000 10000<br/></span><span>      |"""</span>.stripMargin<strong>.invalid</strong><br/>  <span>else </span>{<br/>    <span>val </span>allReturns = Returns.<span>fromEquityAndInflationData</span>(<br/>      equities = EquityData.<span>fromResource</span>(<span>"sp500.tsv"</span>)<span>,<br/></span><span>      </span>inflations = InflationData.<span>fromResource</span>(<span>"cpi.tsv"</span>))<br/><br/>    <span>val </span>vFromUntil = <span>parseFromUntil</span>(args(<span>0</span>))<br/>    <span>val </span>vNbOfYearsSaving = <span>parseInt</span>(<span>"nbOfYearsSaving"</span><span>, </span>args(<span>1</span>))<br/>    <span>val </span>vParams = <span>parseParams</span>(args)<br/><br/>    (vFromUntil<span>, </span>vNbOfYearsSaving<span>, </span>vParams)<br/>      .<strong>tupled</strong><br/>      .<strong>andThen</strong> { <span>case </span>((from<span>, </span>until)<span>, </span>nbOfYearsSaving<span>, </span>params) =&gt;<br/>        <span>strSimulatePlan</span>(allReturns.fromUntil(from<span>, </span>until)<span>, <br/>        </span>nbOfYearsSaving<span>, </span>params)<br/>      }<br/>      .<strong>leftMap</strong>(nel =&gt; nel.map(_.message).toList.mkString(<span>"</span><span>\n</span><span>"</span>))<br/>  }</pre>
<p>In order to match the assertions we made in the <kbd>SimulatePlanAppIT </kbd><span>integration test</span><span>, we change the signature to return </span><kbd>Validated[String, String]</kbd><span>. If the arguments array is of the wrong size, we return an</span> <kbd>Invalid</kbd> <span>value, with a string explaining the correct usage for our program. </span>Otherwise, when the arguments array is of the right size, we first declare the <kbd>allReturns</kbd> <span>variable </span><span>as before.</span></p>
<p>Then, we call the three parsing functions that we implemented earlier and assign them to <kbd>vFromUntil</kbd>, <kbd>vNbOfYearsSaving</kbd>, and <kbd>vParams</kbd>. Their types are <kbd>RetCalcResult[(String, String)]</kbd>, <kbd>RetCalcResult[Int]</kbd>, and <kbd>RetCalcResult[RetCalcParams]</kbd> <span>respectively</span><span>. After that, we put these three values in</span> <kbd>Tuple3</kbd><span>, and call the</span> <kbd>cats</kbd> <kbd>tupled</kbd> <span>function</span><span>, which combines the three elements of the tuple to produce </span><kbd>RetCalcResult[((String, String), Int, RetCalcParams)]</kbd><span>.</span></p>
<p>At this point, we have a <kbd>ValidatedNel</kbd> instance containing all the required parameters to call the <kbd>strSimulatePlan</kbd> <span>function</span><span> </span><span>that we implemented earlier. In this case, we need to check errors sequentially—first, we validate all the arguments,</span> <em>and then</em> <span>we call</span> <kbd>strSimulatePlan</kbd><span>. If we had used</span> <kbd>Either</kbd> <span>instead of</span> <kbd>ValidatedNel</kbd><span>, we would have used</span> <kbd>flatMap</kbd> <span>to do this. Fortunately,</span> <kbd>ValidatedNel</kbd> <span>provides an equivalent method in the form of </span><kbd>andThen</kbd><span>.</span></p>
<div class="packt_infobox">Unlike <kbd>Option</kbd> and <kbd>Either</kbd>, instances of <kbd>ValidatedNel</kbd> do not have a <kbd>flatMap</kbd> method because it is not a monad, it is an applicative functor. We will explain <span>what these terms mean </span><span>in</span> <a href="79c8f01a-6077-4391-9b4d-827f4067cd85.xhtml" target="_blank">Chapter 4,</a><span> <em>Advanced Features</em>. If you want to run validations in sequence, you need to use <kbd>andThen</kbd> or convert in to <kbd>Either</kbd> and use <kbd>flatMap</kbd>.</span></div>
<p>Before the call to <kbd>.leftMap</kbd>, we have an expression of the <kbd>RetCaclResult[String] </kbd><span>type</span><span>, which is an alias for</span> <kbd>Validated[NonEmptyList[RetCalcError], String]</kbd><span>. However, our function must return </span><kbd>Validated[String, String]</kbd><span>. Therefore, we transform the left</span> <kbd>NonEmptyList[RetCalcError]</kbd><span>type</span><span> </span><span>to a string using the anonymous function passed to</span> <kbd>.leftMap</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw how we can handle optional values and how to handle errors in a purely functional way. You are now better equipped to write safer programs that do not throw exceptions and crash unexpectedly.</p>
<p>If you use Java libraries or some non-purely-functional Scala libraries, you will notice that they can throw exceptions. If you do not want your program to crash when exceptions are raised, I advise you to wrap them as early as possible inside <kbd>Either</kbd> or <kbd>Validated</kbd>.</p>
<p>We saw how <kbd>Either</kbd> can be used to handle errors sequentially, and how <kbd>Validated</kbd> can handle errors in parallel. As these two types are very similar, I would advise you to use <kbd>Validated</kbd> most of the time. Instances of <kbd>Validated</kbd> can indeed handle errors in parallel using <kbd>mapN</kbd>, but they can also perform sequential validation using <kbd>andThen</kbd>. </p>
<p>This chapter went a bit further in the way of writing programs in a functional way. In the next chapter we will explore other features of the language that you will necessarily encounter in typical Scala projects: laziness, covariance and contravariance, and implicit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>Here are some questions to test your knowledge:</p>
<ul>
<li>What type can you use to represent an optional value?</li>
<li>What type(s) can you use to represent the possibility of an error?</li>
<li>What is referential transparency?</li>
<li>Is it good practice to throw exceptions?</li>
</ul>
<p>Here are some exercises:</p>
<ul>
<li>Write unit tests for <kbd>SimulatePlanApp</kbd></li>
<li>Use <kbd>RetCalcResult</kbd> instead of <kbd>Either[RetCalcError, X]</kbd> in <kbd>RetCalc.scala</kbd></li>
<li>Change <kbd>VariableReturns.fromUntil</kbd> to return an error if <kbd>monthIdFrom</kbd> or <kbd>monthIdUntil</kbd> cannot be found in the returns <kbd>Vector</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>The <kbd>cats</kbd> documentation on <kbd>Either</kbd> and <kbd>Validated</kbd> at the following links provides other usage examples, as well as more details on their respective topics:</p>
<ul>
<li><a href="https://typelevel.org/cats/datatypes/either.html">https://typelevel.org/cats/datatypes/either.html</a></li>
<li><a href="https://typelevel.org/cats/datatypes/validated.html">https://typelevel.org/cats/datatypes/validated.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>