- en: '*Chapter 8*: Multithreading and Concurrent Processing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss ways to increase Java application performance
    by using workers (threads) that process data concurrently. We will explain the
    concept of Java threads and demonstrate their usage. We will also talk about the
    difference between parallel and concurrent processing and how to avoid unpredictable
    results caused by the concurrent modification of a shared resource.
  prefs: []
  type: TYPE_NORMAL
- en: After finishing this chapter, you will be able to write code for multithreaded
    processing—creating and executing threads and using a pool of threads in parallel
    and concurrent cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread versus process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User thread versus daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `Runnable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `Thread` versus implementing `Runnable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a pool of threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting results from a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel versus concurrent processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent modification of the same resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java **Standard Edition** (**SE**) version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **integrated development environment** (**IDE**) or your preferred code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. Files with code examples for this chapter are available on GitHub in
    the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch08_threads` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Thread versus process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java has two units of execution—a process and a thread. A `java.lang.ProcessBuilder`.
    But since the multi-process case is outside the scope of this book, we will focus
    on the second unit of execution—that is, a **thread**, which is similar to a process
    but less isolated from other threads and requires fewer resources for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A process can have many threads running and at least one thread called the
    **main thread**—the one that starts the application—which we use in every example.
    Threads can share resources, including memory and open files, which allows for
    better efficiency, but this comes at a price: a higher risk of unintended mutual
    interference, and even blocking of the execution. That is where programming skills
    and an understanding of concurrency techniques are required.'
  prefs: []
  type: TYPE_NORMAL
- en: User thread versus daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a particular kind of thread called a daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The word *daemon* has an ancient Greek origin, meaning a divinity or supernatural
    being of nature between gods and humans and an inner or attendant spirit or inspiring
    force.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer science, the term *daemon* has more mundane usage and is applied
    to *a computer program that runs as a background process, rather than being under
    the direct control of an interactive user*. That is why there are the following
    two types of threads in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: User thread (default) initiated by an application (the main thread is one such
    example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daemon thread that works in the background in support of user-thread activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why all daemon threads exit immediately after the last user thread exits
    or are terminated by the JVM after an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to create a thread is to extend the `java.lang.Thread` class and override
    its `run()` method. Here’s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the `run()` method is not overridden, the thread does nothing. In our example,
    the thread prints its name and other properties every second, as long as the parameter
    is not equal to the `"exit"` string; otherwise, it exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pauseOneSecond()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `MyThread` class to run two threads—one user thread and
    one daemon thread, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the main thread creates two other threads, pauses for one second,
    sets the `exit` parameter on the user thread, pauses another second, and finally
    exits (the `main()` method completes its execution).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, we’ll see something like this (the `id` thread
    may be different in different operating systems):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that the daemon thread exits automatically as
    soon as the last user thread (the main thread, in our example) exits.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Runnable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second way to create a thread is to use a class that implements `java.lang.Runnable`.
    Here is an example of such a class that has almost exactly the same functionality
    as the `MyThread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that there is no `isDaemon()`, `getId()`, or any other out-of-the-box
    method. The `MyRunnable` class can be any class that implements the `Runnable`
    interface, so we cannot print whether the thread is a daemon or not. We have added
    the `name` property so that we can identify the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `MyRunnable` class to create threads similar to how we have
    used the `MyThread` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot proves that the behavior of the `MyRunnable` class
    is similar to the behavior of the `MyThread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The daemon thread (named `Two`) exits after the last user thread exits—exactly
    how it happened with the `MyThread` class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Thread versus implementing Runnable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementation of `Runnable` has the advantage (and in some cases, the only
    possible option) of allowing the implementation to extend another class. It is
    particularly helpful when you would like to add thread-like behavior to an existing
    class. Implementing `Runnable` allows more flexibility in usage, but otherwise,
    there is no difference in functionality compared to the extending of the `Thread`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class has several constructors that allow setting the thread name
    and the group it belongs to. Grouping of threads helps to manage them in the case
    of many threads running in parallel. The `Thread` class has also several methods
    that provide information about the thread’s status and its properties and allows
    us to control its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, the thread’s **identifier** (**ID**) is generated automatically.
    It cannot be changed but can be reused after the thread is terminated. Several
    threads, on the other hand, can be set with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The execution priority can also be set programmatically with a value between
    `Thread.MIN_PRIORITY` and `Thread.MAX_PRIORITY`. The smaller the value, the more
    time the thread is allowed to run, which means it has a higher priority. If not
    set, the priority value defaults to `Thread.NORM_PRIORITY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state of a thread can have one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NEW`: When a thread has not yet started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNNABLE`: When a thread is being executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BLOCKED`: When a thread is blocked and is waiting for a monitor lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WAITING`: When a thread is waiting indefinitely for another thread to perform
    a particular action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMED_WAITING`: When a thread is waiting for another thread to perform an
    action for up to a specified waiting time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TERMINATED`: When a thread has exited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads—and any objects, for that matter—can also *talk to each other* using
    the `wait()`, `notify()`, and `notifyAll()` methods of the `java.lang.Object`
    base class, but this aspect of threads’ behavior is outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Using a pool of threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each thread requires resources—the **central processing unit** (**CPU**) and
    **memory**. This means the number of threads must be controlled, and one way to
    do that is to create a fixed number of them—a pool. Besides, creating an object
    incurs an overhead that may be significant for some applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look into the `Executor` interfaces and their implementations
    provided in the `java.util.concurrent` package. They encapsulate thread management
    and minimize the time an application developer spends on writing code related
    to threads’ life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three `Executor` interfaces defined in the `java.util.concurrent`
    package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The base `Executor` interface: This has only one `void execute(Runnable r)`
    method in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ExecutorService` interface: This extends `Executor` and adds four groups
    of methods that manage the life cycle of worker threads and of the executor itself,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit()` methods, which place a `Runnable` or `Callable` object in the queue
    for the execution (`Callable` allows the worker thread to return a value) and
    return an object of the `Future` interface, which can be used to access the value
    returned by the `Callable` object and to manage the status of the worker thread'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAll()` methods, which place a collection of objects of the `Callable` interface in
    a queue for execution, which then returns a `List` interface of `Future` objects
    when all worker threads are complete (there is also an overloaded `invokeAll()` method
    with a timeout)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAny()` methods, which place a collection of interface `Callable` objects in
    the queue for the execution and return one `Future` object of any of the worker
    threads, which has completed (there is also an overloaded `invokeAny()` method
    with a timeout)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that manage worker threads’ status and the service itself, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown()`: Prevents new worker threads from being submitted to the service.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdownNow()`: Interrupts each worker thread that is not completed. A worker
    thread should be written so that it checks its own status periodically (using `Thread.currentThread().isInterrupted()`,
    for example) and gracefully shuts down on its own; otherwise, it will continue
    running even after `shutdownNow()` was called.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isShutdown()`: Checks whether the shutdown of the executor was initiated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitTermination(long timeout, TimeUnit timeUnit)`: Waits until all worker
    threads have completed execution after a shutdown request, or a timeout occurs,
    or the current thread is interrupted, whichever happens first.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: Checks whether all the worker threads have completed after
    the shutdown was initiated. It never returns `true` unless either `shutdown()` or `shutdownNow()` was
    called first.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ScheduledExecutorService` interface: This extends `ExecutorService` and
    adds methods that allow scheduling of the execution (one-time and periodic) of
    worker threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A pool-based implementation of `ExecutorService` can be created using the `java.util.concurrent.ThreadPoolExecutor`
    or `java.util.concurrent.ScheduledThreadPoolExecutor` class. There is also a `java.util.concurrent.Executors`
    factory class that covers most practical cases. So, before writing custom code
    for worker threads’ pool creation, we highly recommend looking into using the
    following factory methods of the `java.util.concurrent.Executors` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`newCachedThreadPool()`: Creates a thread pool that adds a new thread as needed,
    unless there is an idle thread created before; threads that have been idle for
    60 seconds are removed from the pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor()`: Creates an `ExecutorService` (pool) instance that
    executes worker threads sequentially'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newSingleThreadScheduledExecutor()`: Creates a single-threaded executor that
    can be scheduled to run after a given delay, or to execute periodically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newFixedThreadPool(int nThreads)`: Creates a thread pool that reuses a fixed
    number of worker threads; if a new task is submitted when all the worker threads
    are still executing, it will be placed into the queue until a worker thread is
    available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newScheduledThreadPool(int nThreads)`: Creates a thread pool of a fixed size
    that can be scheduled to run after a given delay, or to execute periodically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newWorkStealingThreadPool(int nThreads)`: Creates a thread pool that uses
    the *work-stealing* algorithm used by `ForkJoinPool`, which is particularly useful
    in case the worker threads generate other threads, such as in a recursive algorithm;
    it also adapts to the specified number of CPUs, which you may set higher or lower
    than the actual CPU count on your computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work-Stealing Algorithm
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A work-stealing algorithm allows threads that have finished their assigned tasks
    to help other tasks that are still busy with their assignments. As an example,
    see the description of fork/join implementation in the official Oracle Java documentation ([https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each of these methods has an overloaded version that allows passing in `ThreadFactory`
    that is used to create a new thread when needed. Let’s see how it all works in
    a code sample. First, we run another version of the `MyRunnable` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the `parameter` property anymore to tell the thread to stop executing
    because the thread life cycle is now going to be controlled by the `ExecutorService`
    interface, and the way it does it is by calling the `interrupt()` thread method.
    Also, notice that the thread we created has an infinite loop, so it will never
    stop executing until forced to (by calling the `interrupt()` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write code that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a pool of three threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes sure the pool does not accept more threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waits for a fixed time to let all threads finish what they’re doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stops (interrupts) threads that did not finish what they were doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code performs all the actions described in the preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The attempt to add another thread to the pool after `pool.shutdown()` is called
    generates `java.util.concurrent.RejectedExecutionException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of the preceding code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the `Thread.currentThread().isInterrupted()=false` message in the preceding
    screenshot. The thread was interrupted. We know this because the thread got an
    `InterruptedException` message. Why, then, does the `isInterrupted()` method return
    `false`? This happens because the thread state was cleared immediately after receiving
    the interrupt message. We’re mentioning it now because it is a source of some
    programmer mistakes. For example, if the main thread watches the `MyRunnable`
    thread and calls `isInterrupted()` on it, the return value is going to be `false`,
    which may be misleading after the thread was interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the case where another thread may be monitoring the `MyRunnable` thread,
    the implementation of `MyRunnable` has to be changed to this. Note in the following
    code snippet how the `interrupt()` method is called in the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run this thread using the same `ExecutorService` pool again, this
    will be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the value returned by the `isInterrupted()` method is now `true`
    and corresponds to what has happened. To be fair, in many applications, once a
    thread is interrupted, its status is not checked again. But setting the correct
    state is a good practice, especially in those cases where you are not the author
    of the higher-level code that creates a particular thread.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have used a cached thread pool that creates a new thread
    as needed or, if available, reuses the thread already used, but which completed
    its job and returned to the pool for a new assignment. We did not worry about
    too many threads created because our demonstration application had three worker
    threads at the most and they were quite short-lived.
  prefs: []
  type: TYPE_NORMAL
- en: But in the case where an application does not have a fixed limit of worker threads
    it might need or there is no good way to predict how much memory a thread may
    take or how long it can execute, setting a ceiling on the worker thread count
    prevents an unexpected degradation of the application performance, running out
    of memory, or depletion of any other resources the worker threads use. If the
    thread behavior is extremely unpredictable, a single thread pool might be the
    only solution, with the option of using a custom thread-pool executor. But in
    the majority of cases, a fixed-size thread-pool executor is a good practical compromise
    between the application needs and the code complexity (earlier in this section,
    we listed all possible pool types created by the `Executors` factory class).
  prefs: []
  type: TYPE_NORMAL
- en: Setting the size of the pool too low may deprive the application of the chance
    to utilize the available resources effectively. So, before selecting the pool
    size, it is advisable to spend some time monitoring the application, with the
    goal of identifying the idiosyncrasy of the application behavior. In fact, the
    *deploy-monitor-adjust* cycle has to be repeated throughout the application’s
    life cycle in order to accommodate and take advantage of changes that happened
    in the code or the executing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first characteristic you take into account is the number of CPUs in your
    system, so the thread pool size can be at least as big as the CPU count. Then,
    you can monitor the application and see how much time each thread engages the
    CPU for and how much time it uses other resources (such as **input/output** (**I/O**)
    operations). If the time spent not using the CPU is comparable with the total
    executing time of the thread, then you can increase the pool size by the following
    ratio: the time the CPU was not used divided by the total executing time, but
    that is in the case where another resource (disk or database) is not a subject
    of contention between threads. If the latter is the case, then you can use that
    resource instead of the CPU as the delineating factor.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the worker threads of your application are not too big or take too
    long executing, and belong to the mainstream population of the typical working
    threads that complete their job in a reasonably short period of time, you can
    increase the pool size by adding the (rounded-up) ratio of the desired response
    time and the time a thread uses the CPU or another most contentious resource.
    This means that, with the same desired response time, the less a thread uses the
    CPU or another concurrently accessed resource, the bigger the pool size should
    be. If the contentious resource has its own ability to improve concurrent access
    (such as a connection pool in a database), consider utilizing that feature first.
  prefs: []
  type: TYPE_NORMAL
- en: If the required number of threads running at the same time changes at runtime
    in different circumstances, you can make the pool size dynamic and create a new
    pool with a new size (shutting down the old pool after all its threads have completed).
    The recalculation of the size of a new pool might also be necessary after you
    add or remove the available resources. You can use `Runtime.getRuntime().availableProcessors()`
    to programmatically adjust the pool size based on the current count of the available
    CPUs, for example.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the ready-to-use thread pool executor implementations that come with
    the `java.util.concurrent.ThreadPoolExecutor` class first. It has several overloaded
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea of its capabilities, here is the constructor with the biggest
    number of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the parameters of the preceding constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`corePoolSize` is the number of threads to keep in the pool, even if they are
    idle, unless the `allowCoreThreadTimeOut(boolean value)` method is called with
    a `true` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maximumPoolSize` is the maximum number of threads to allow in the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keepAliveTime`: When the number of threads is greater than the core, this
    is the maximum time that excess idle threads will wait for new tasks before terminating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unit` is the time unit for the `keepAliveTime` argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workQueue` is the queue to use for holding tasks before they are executed;
    this queue will hold only `Runnable` objects submitted by the `execute()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threadFactory` is the factory to use when the executor creates a new thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler` is the handler to use when the execution is blocked because the thread
    bounds and queue capacities are reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the previous constructor parameters except `workQueue` can also be set
    via the corresponding setter after an object of the `ThreadPoolExecutor` class
    has been created, thus allowing more flexibility and dynamic adjustment of existing
    pool characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Getting results from a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our examples so far, we have used the `execute()` method of the `ExecutorService`
    interface to start a thread. In fact, this method comes from the `Executor` base
    interface. Meanwhile, the `ExecutorService` interface has other methods (listed
    in the previous *Using a pool of threads* section) that can start threads and
    get back the results of thread execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object that brings back the result of thread execution is of type `Future`—an
    interface that has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V get()`: Blocks until the thread finishes; returns the result (*if available*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V get(long timeout, TimeUnit unit)`: Blocks until the thread finishes or the
    provided timeout is up; returns the result (if available)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isDone()`: Returns `true` if the thread has finished'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean cancel(boolean mayInterruptIfRunning)`: Tries to cancel the execution
    of the thread; returns `true` if successful; returns `false` also in the case
    the thread had finished normally by the time the method was called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isCancelled()`: Returns `true` if the thread execution was canceled
    before it had finished normally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *if available* remark in the description of the `get()` method means that
    the result is not always available in principle, even when the `get()` method
    without parameters is called. It all depends on the method used to produce the
    `Future` object. Here is a list of all methods of `ExecutorService` that return
    a `Future` object(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Future<?> submit(Runnable task)`: Submits the thread (task) for execution;
    returns a `Future` object representing the task; the `get()` method of the returned
    `Future` object returns `null`. For example, let’s use the `MyRunnable` class
    that works only for 100 milliseconds, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And based on the code examples of the previous section, let’s create a method
    that shuts down the pool and terminates all the threads, if necessary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the preceding `shutdownAndTerminate()` method in a `finally` block
    to make sure no running threads were left behind. Here is the code we are going
    to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the output of this code in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `get()` method of the `Future` object returns `null` because
    the `run()` method of `Runnable` does not return anything. All we can get back
    from the returned `Future` object is the information that the task was completed,
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '`Future<T> submit(Runnable task, T result)`: Submits the thread (task) for
    execution; returns a `Future` object representing the task with the provided `result`
    in it; for example, we will use the following class as the result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code snippet demonstrates how the default result is returned
    by the `Future` object returned by the `submit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the preceding code, the output is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the `get()` method of `Future` returns the object passed in as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`Future<T> submit(Callable<T> task)`: Submits the thread (task) for execution;
    returns a `Future` object representing the task with the result produced and returned
    by the `V call()` method of the `Callable` interface, which is the only `Callable`
    method the interface has. Here’s an example of this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the preceding code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `get()` method of the `Future` object returns the value
    produced by the `call()` method of the `MyCallable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`: Executes all `Callable`
    tasks of the provided collection; returns a list of `Future` objects with the
    results produced by the executed `Callable` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<Future<T>> invokeAll(Collection<Callable<T>>`: Executes all `Callable`
    tasks of the provided collection; returns a list of `Future` objects with the
    results produced by the executed `Callable` objects or the timeout expires, whichever
    happens first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T invokeAny(Collection<Callable<T>> tasks)`: Executes all `Callable` tasks
    of the provided collection; returns the result of one that has completed successfully
    (meaning, without throwing an exception), if any do'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`:
    Executes all `Callable` tasks of the provided collection; returns the result of
    one that has completed successfully (meaning, without throwing an exception),
    if such is available before the provided timeout expires'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are many ways to get results from a thread. The method
    you choose depends on the particular needs of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel versus concurrent processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we hear about working threads executing at the same time, we automatically
    assume that they literally do what they are programmed to do in parallel. Only
    after we look under the hood of such a system do we realize that such parallel
    processing is possible only when the threads are each executed by a different
    CPU; otherwise, they time-share the same processing power. We perceive them working
    at the same time only because the time slots they use are very short—a fraction
    of the time units we use in our everyday life. When threads share the same resource,
    in computer science, we say they do it *concurrently*.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent modification of the same resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two or more threads modifying the same value while other threads read it is
    the most general description of one of the problems of concurrent access. Subtler
    problems include **thread interference** and **memory consistency** errors, both
    of which produce unexpected results in seemingly benign fragments of code. In
    this section, we are going to demonstrate such cases and ways to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, the solution seems quite straightforward: allow only one thread
    at a time to modify/access the resource, and that’s it. But if access takes a
    long time, it creates a bottleneck that might eliminate the advantage of having
    many threads working in parallel. Or, if one thread blocks access to one resource
    while waiting for access to another resource and the second thread blocks access
    to a second resource while waiting for access to the first one, it creates a problem
    called a **deadlock**. These are two very simple examples of possible challenges
    a programmer may encounter while using multiple threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll reproduce a problem caused by the concurrent modification of the
    same value. Let’s create a `Calculator` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `getDescription()` method to capture the description of the
    implementation. Here is the first implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `calculate()` method assigns a new value to the `prop` property,
    then does something else (we simulate it by calling the `sleep()` method), and
    then calculates the square root of the value assigned to the `prop` property.
    The `"Without synchronization"` description depicts the fact that the value of
    the `prop` property is changing every time the `calculate()` method is called—without
    any coordination or **synchronization**, as it is called in the case of coordination
    between threads when they concurrently modify the same resource.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to share this object between two threads, which means that
    the `prop` property is going to be updated and used concurrently. So, some kind
    of thread synchronization around the `prop` property is necessary, but we have
    decided that our first implementation does not do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the method we are going to use while executing every `Calculator` implementation
    we are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prints a description of the passed-in `Calculator` implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a fixed-size pool for two threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a list of two `Callable` tasks—objects of the following `MyCallable`
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A list of tasks is passed into the `invokeAll()` method of the pool, where each
    of the tasks is executed by invoking the `call()` method; each `call()` method
    applies the `calculate()` method of the passed-in `Calculator` object to every
    one of the 19 numbers from 1 to 20 and sums up the results. The resulting sum
    is returned inside the `Result` object, along with the name of the `MyCallable`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `Result` object is eventually returned inside a `Future` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invokeAllCallables()` method then iterates over the list of `Future` objects
    and checks whether each of their tasks has been completed. When a task is completed,
    the result is added to `List<Result> results`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After all tasks are completed, the `invokeAllCallables()` method then prints
    all elements of `List<Result> results` and terminates the pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the result we got from one of our runs of `invokeAllCallables(new CalculatorNoSync())`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The actual numbers are slightly different every time we run the preceding code,
    but the result of the `One` task never equals the result of the `Two` task. That
    is because, in the period between setting the value of the `prop` field and returning
    its square root in the `calculate()` method, the other thread managed to assign
    a different value to `prop`. This is a case of thread interference.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to address this problem. We start with an atomic variable
    as a way to achieve thread-safe concurrent access to a property. Then, we will
    also demonstrate two methods of thread synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `prop` value should not be used if it has been changed by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.util.concurrent.atomic` package has a dozen classes that support
    this logic: `AtomicBoolean`, `AtomicInteger`, `AtomicReference`, and `AtomicIntegerArray`,
    to name a few. Each of these classes has many methods that can be used for different
    synchronization needs. Check the online **application programming interface**
    (**API**) documentation for each of these classes ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html)).
    For the demonstration, we will use only two methods present in all of them, as
    outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V get()`: Returns the current value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean compareAndSet(V expectedValue, V newValue)`: Sets the value to `newValue`
    if the current value equals via the (`==`) operator the `expectedValue` value;
    returns `true` if successful or `false` if the actual value was not equal to the
    expected value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how the `AtomicReference` class can be used to solve the problem of
    thread interference while accessing the `prop` property of the `Calculator` object
    concurrently using these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding code makes sure that the `currentValue` value
    of the `prop` property does not change while the thread was sleeping. Here is
    a screenshot of messages produced when we run `invokeAllCallables(new CalculatorAtomicRef())`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the results produced by the threads are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following classes of the `java.util.concurrent` package provide synchronization
    support too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Semaphore`: Restricts the number of threads that can access a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountDownLatch`: Allows one or more threads to wait until a set of operations
    being performed in other threads are completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CyclicBarrier`: Allows sets of threads to wait for each other to reach a common
    barrier point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Phaser`: Provides a more flexible form of barrier that may be used to control
    phased computation among multiple threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchanger`: Allows two threads to exchange objects at a rendezvous point and
    is useful in several pipeline designs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronized method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to solve the problem is to use a synchronized method. Here is another
    implementation of the `Calculator` interface that uses this method of solving
    thread interference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just added the `synchronized` keyword in front of the `calculate()`
    method. Now, if we run `invokeAllCallables(new CalculatorSyncMethod())`, the results
    of both threads are always going to be the same, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because another thread cannot enter the synchronized method until the
    current thread (the one that has entered the method already) has exited it. This
    is probably the simplest solution, but this approach may cause performance degradation
    if the method takes a long time to execute. In such cases, a synchronized block
    can be used, which only wraps several lines of code in an atomic operation.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of a synchronized block used to solve the problem of thread
    interference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the synchronized block acquires a lock on the `this` object,
    which is shared by both threads, and releases it only after the threads exit the
    block. In our demonstration code, the block covers all the code of the method,
    so there is no difference in performance. But imagine there is more code in the
    method (we commented the location as `there may be some other code here`). If
    that is the case, the synchronized section of the code is smaller, thus having
    fewer chances to become a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run `invokeAllCallables(new CalculatorSyncBlock())`, the results look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the results are exactly the same as in the previous two examples.
    Different types of locks for different needs and with different behavior are assembled
    in the `java.util.concurrent.locks` package.
  prefs: []
  type: TYPE_NORMAL
- en: Each object in Java inherits the `wait()`, `notify()`, and `notifyAll()` methods
    from the base object. These methods can also be used to control threads’ behavior
    and their access to the locks.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to address concurrency is to use a thread-safe collection from
    the `java.util.concurrent` package. Before you select which collection to use,
    read the *Javadoc* documentation ([https://docs.oracle.com/en/java/javase/17/docs/api/index.html](https://docs.oracle.com/en/java/javase/17/docs/api/index.html))
    to see whether the limitations of the collection are acceptable for your application.
    Here is a list of these collections and some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap<K,V>`: Supports full concurrency of retrievals and high-expected
    concurrency for updates; use it when the concurrency requirements are very demanding
    and you need to allow locking on the write operation but do not need to lock the
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentLinkedQueue<E>`: A thread-safe queue based on linked nodes; employs
    an efficient non-blocking algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentLinkedDeque<E>`: A concurrent queue based on linked nodes; both
    `ConcurrentLinkedQueque` and `ConcurrentLinkedDeque` are an appropriate choice
    when many threads share access to a common collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentSkipListMap<K,V>`: A concurrent `ConcurrentNavigableMap` interface
    implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentSkipListSet<E>`: A concurrent `NavigableSet` implementation based
    on the `ConcurrentSkipListMap` class. The `ConcurrentSkipListSet` and `ConcurrentSkipListMap`
    classes, as per the *Javadoc* documentation, “*provide expected average log(n)
    time cost for the contains, add, and remove operations and their variants. Ascending
    ordered views and their iterators are faster than descending ones*.” Use them
    when you need to iterate quickly through elements in a certain order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CopyOnWriteArrayList<E>`: A thread-safe variant of `ArrayList` in which all
    mutative operations (add, set, and so on) are implemented by making a fresh copy
    of the underlying array. As per the *Javadoc* documentation, the `CopyOnWriteArrayList`
    class “*is ordinarily too costly, but may be more efficient than alternatives
    when traversal operations vastly outnumber mutations, and is useful when you cannot
    or don''t want to synchronize traversals, yet need to preclude interference among
    concurrent threads*.” Use it when you do not need to add new elements at different
    positions and do not require sorting; otherwise, use `ConcurrentSkipListSet`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CopyOnWriteArraySet<E>`: A set that uses an internal `CopyOnWriteArrayList`
    class for all of its operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue`: This is a better choice when a natural order is acceptable
    and you need fast adding of elements to the tail and fast removing of elements
    from the head of the queue. **Blocking** means that the queue waits to become
    non-empty when retrieving an element and waits for space to become available in
    the queue when storing an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArrayBlockingQueue`, `LinkedBlockingQueue`, and `LinkedBlockingDeque` have
    a fixed size (bounded); other queues are unbounded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use these and similar characteristics and recommendations as per the guidelines,
    but execute comprehensive testing and performance-measuring before and after implementing
    your functionality. To demonstrate some of these collections’ capabilities, let’s
    use `CopyOnWriteArrayList<E>`. First, let’s look in the following code snippet
    at how `ArrayList` behaves when we try to modify it concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the attempt to modify a list while iterating on it generates an
    exception, and the list remains unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use `CopyOnWriteArrayList<E>` in the same circumstances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'The output this code produces looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_8.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the list was modified without an exception, but not the currently
    iterated copy. That is the behavior you can use if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing memory consistency errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory consistency errors can have many forms and causes in a multithreaded
    environment. They are well discussed in the *Javadoc* documentation of the `java.util.concurrent`
    package. Here, we will mention only the most common case, which is caused by a
    lack of visibility.
  prefs: []
  type: TYPE_NORMAL
- en: When one thread changes a property value, the other might not see the change
    immediately, and you cannot use the `synchronized` keyword for a primitive type.
    In such a situation, consider using the `volatile` keyword for the property, as
    this guarantees its read/write visibility between different threads.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency problems are not easy to solve, which is why it is not surprising
    that more and more developers are now taking a more radical approach. Instead
    of managing an object state, they prefer processing data in a set of stateless
    operations. We will see examples of such code in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281),
    *Functional Programming*, and [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*. It seems that Java and many modern languages and computer
    systems are evolving in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about multithreaded processing, ways to organize
    it, and avoiding unpredictable results caused by concurrent modification of the
    shared resource. We have shown you how to create threads and execute them using
    pools of threads. We have also demonstrated how results can be extracted from
    the threads that have completed successfully and discussed the difference between
    parallel and concurrent processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will provide you with a deeper understanding of JVM
    and its structure and processes, and we’ll discuss in detail the garbage-collection
    process that keeps memory from being overflown. By the end of the chapter, you
    will know what constitutes Java application execution, Java processes inside JVM,
    garbage collection, and how JVM works in general.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A JVM process can have main threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread is the main process.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A process can launch another process.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread may launch another thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A daemon is a user thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A daemon thread exits after the first user thread completes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A daemon thread exits after the last user thread completes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread is a user thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All threads have `java.lang.Thread` as a base class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All threads extend `java.lang.Thread`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All threads implement `java.lang.Thread`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A daemon thread does not extend `java.lang.Thread`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any class can implement the `Runnable` interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Runnable` interface implementation is a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Runnable` interface implementation is used by a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Runnable` interface has only one method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread name has to be unique.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread ID is generated automatically.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread name can be set.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread priority can be set.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread pool executes threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread pool reuses threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Some thread pools can have a fixed count of threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Some thread pools can have an unlimited count of threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Future` object is the only way to get the result from a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Callable` object is the only way to get the result from a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Callable` object allows us to get the result from a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Future` object represents a thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concurrent processing can be done in parallel.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parallel processing is possible only with several CPUs or cores available on
    the computer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Parallel processing is concurrent processing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Without multiple CPUs, concurrent processing is impossible.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concurrent modification always leads to incorrect results.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An atomic variable protects a property from concurrent modification.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An atomic variable protects a property from thread interference.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An atomic variable is the only way to protect a property from concurrent modification.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `synchronized` method is the best way to avoid thread interference.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `synchronized` keyword can be applied to any method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `synchronized` method can create a processing bottleneck.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `synchronized` method is easy to implement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `synchronized` block makes sense only when it is smaller than the method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `synchronized` block requires a shared lock.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every Java object can provide a lock.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `synchronized` block is the best way to avoid thread interference.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a concurrent collection is preferred over using a non-concurrent one.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a concurrent collection incurs some overhead.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Not every concurrent collection fits every concurrent processing scenario.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create a concurrent collection by calling the `Collections.makeConcurrent()`
    method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only way to avoid a memory consistency error is to declare the `volatile`
    variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `volatile` keyword guarantees visibility of the value change across
    all threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One way to avoid concurrency is to avoid any state management.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stateless utility methods cannot have concurrency issues.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
