<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why Dependency Injection?</h1>
                
            
            <article>
                
<p class="calibre2">In software development, very often <span class="calibre11">someone else might already have found effective solutions to </span><span class="calibre11">the problems you are facing.</span></p>
<p class="calibre2">As a developer, you don't need to reinvent the wheel every time. Instead, you need to refer to the well-established practices and methodologies. Have you guessed what we are talking about? That's correct: <em class="calibre13">design</em> <em class="calibre13">p</em><em class="calibre13">atterns</em>.</p>
<p class="calibre2">This chapter is crafted to cover the following interesting topics:</p>
<ul class="calibre9">
<li class="calibre10">What design patterns are and their benefits</li>
<li class="calibre10"><strong class="calibre1">Dependency Injection Principle</strong> (<strong class="calibre1">DIP</strong>)</li>
<li class="calibre10"><strong class="calibre1">Inversion of Control</strong> (<strong class="calibre1">IoC</strong>)—a design methodology to implement DIP</li>
<li class="calibre10">Various design patterns to implement IoC</li>
<li class="calibre10"><strong class="calibre1">Dependency Injection</strong> (<strong class="calibre1">DI</strong>)</li>
<li class="calibre10">Various types to implement DI</li>
<li class="calibre10">How an IoC container is helpful to apply a DI</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Design patterns</h1>
                
            
            <article>
                
<p class="calibre2">By definition, a <strong class="calibre4">design pattern</strong> is a set of proven de facto industry standards and best practices for resolving recurring problems. Design patterns are not ready-made solutions. Rather, they're a way or template to implement and apply the best possible solution for your problem.</p>
<p class="calibre2">It's equally true that if a design pattern is not implemented in the right way, it creates a lot of problems rather than solving the one you expected to solve. So it's very important to know which design pattern, if any, is right for a specific scenario.</p>
<p class="calibre2">Design patterns are a common paradigm to describe the problem and how to solve it. It's usually not language specific. Design patterns can protect you from the design problems that generally occur in the later stages of development.</p>
<p class="calibre2">There are numerous advantages to using design patterns, as follows:</p>
<ul class="calibre9">
<li class="calibre10">Improves software reusability</li>
<li class="calibre10">Development cycle becomes faster</li>
<li class="calibre10">Makes the code more readable and maintainable</li>
<li class="calibre10">Increases the efficiency and enhances the overall software development</li>
<li class="calibre10">Provides common vocabulary to describe problems and best possible solutions in a more abstract way</li>
</ul>
<p class="calibre2">And you can count many more. In the following sections, we will gain a deep understanding of how to make your code modular, loosely coupled, independent, testable, and maintainable, by following certain principles and patterns.</p>
<p class="calibre2"><span class="calibre11">This chapter will cover in-depth ideas about the <strong class="calibre4">Dependency Inversion Principle</strong> (<strong class="calibre4">DIP</strong>)</span>, the <span class="calibre11">Inversion of Control paradigm, and DI design pattern.</span></p>
<div class="packt_infobox"><span class="calibre18">Most developers use the terms </span><em class="calibre19">design principle</em><span class="calibre18"> and </span><em class="calibre19">design pattern</em><span class="calibre18"> interchangeably, even though there is a difference between them.</span></div>
<p class="calibre2"><strong class="calibre4">Design principle</strong>:<span class="calibre11"> G</span><span class="calibre11">enerically, this is a guideline about what is the right way and what is the wrong way to design your application. </span>Design principles always talk about what to do instead of how to do it.</p>
<p class="calibre2"><strong class="calibre4">Design patterns</strong>: A generic and reusable solution for commonly occurring problems. Design patterns talk about how to solve the problems in a<span class="calibre11"> given software design context </span>by providing clear methodologies<span class="calibre11">.</span></p>
<p class="calibre2">The first step towards making your code cleaner, readable, decoupled, maintainable, and modular is to learn the design principle called <strong class="calibre4">DIP</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Inversion Principle</h1>
                
            
            <article>
                
<p class="calibre2">DIP provides high-level guidance to make your code loosely coupled. It says the following:</p>
<ul class="calibre9">
<li class="calibre10">High-level modules should not depend on low-level modules for their responsibilities. Both should depend on abstractions.</li>
<li class="calibre10">Abstractions should not depend on details. Details should depend on abstractions.</li>
</ul>
<p class="calibre2">Changes are always risky when they're made in dependent code. DIP talks about keeping a chunk of code (dependency) away from the main program to which it is not directly related. </p>
<p class="calibre2"><span class="calibre11">To reduce the coupling, DIP suggests eliminating the direct dependency of low-level modules on high-level modules to perform their responsibilities. Instead, make the high-level module rely on abstraction (a contract) that forms the generic low-level behavior. </span></p>
<p class="calibre2">This way, the actual implementation of low-level modules can be changed without making any changes in high-level modules. This produces great flexibility and molecularity in the system. As far as any low-level implementation is bound to abstraction, high-level modules can invoke it.</p>
<p class="calibre2">Let's have a look at a sample suboptimal design where we can apply DIP to improve the structure of the application.</p>
<p class="calibre2">Consider a scenario where you are designing a module that simply generates balance sheets for a local store. You are fetching data from a database, processing it with complex business logic, and exporting it into HTML format. If you design this in a procedural way, then the flow of the system would be something like the following diagram:</p>
<div class="mce-root"><img src="../images/00005.gif" class="calibre20"/></div>
<p class="calibre2">A single module takes care of fetching data, applying business logic to generate balance sheet data, and exporting it into HTML format. This is not the best design. Let's separate the whole functionality into three different modules, as shown in the following diagram:</p>
<div class="mce-root"><img src="../images/00006.jpeg" class="calibre21"/></div>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Fetch Database Module :</strong> This will fetch data from a database</li>
<li class="calibre10"><strong class="calibre1">Export HTML Module: </strong> <span>This</span> will export the data in HTML</li>
<li class="calibre10"><strong class="calibre1">Balance Sheet Module:</strong> <span>This</span> will take data from a database module, process it, and give it to the export module to export it in HTML</li>
</ul>
<p class="calibre2">In this case, the balance sheet module is a high-level module, and fetch database and export HTML are low-level modules.</p>
<p class="calibre2">The code of the <kbd class="calibre12">FetchDatabase</kbd> module<em class="calibre13"> </em>should look something like the following snippet:</p>
<pre class="calibre17">public class FetchDatabase {<br class="title-page-name"/>    public List&lt;Object[]&gt; fetchDataFromDatabase(){<br class="title-page-name"/>         List&lt;Object[]&gt; dataFromDB = new ArrayList&lt;Object[]&gt;();<br class="title-page-name"/>         //Logic to call database, execute a query and fetch the data<br class="title-page-name"/>         return dataFromDB;<br class="title-page-name"/>     }<br class="title-page-name"/>}</pre>
<p class="mce-root1">The <kbd class="calibre12">ExportHTML</kbd> module will take the list of data and export it into HTML file format. The code should look as follows:</p>
<pre class="calibre17">public class ExportHTML {<br class="title-page-name"/>    public File exportToHTML(List&lt;Object[]&gt; dataLst){<br class="title-page-name"/>        File outputHTML = null;<br class="title-page-name"/>        //Logic to iterate the dataLst and generate HTML file.<br class="title-page-name"/>        return outputHTML;<br class="title-page-name"/>     }<br class="title-page-name"/>}</pre>
<p class="mce-root1">The code for our parent module—the <kbd class="calibre12">BalanceSheet</kbd> module that takes the data from the fetch database module and sends to the export HTML module—should look as follows:</p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/>    private ExportHTML exportHTML = new ExportHTML();<br class="title-page-name"/>    private FetchDatabase fetchDatabase = new FetchDatabase();<br class="title-page-name"/>    <br class="title-page-name"/>    public void generateBalanceSheet(){<br class="title-page-name"/>      List&lt;Object[]&gt; dataFromDB =<br class="title-page-name"/>      fetchDatabase.fetchDataFromDatabase();<br class="title-page-name"/>        exportHTML.exportToHTML(dataFromDB);<br class="title-page-name"/>     }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">At first glance, this design looks good, as we separated the responsibilities of fetching and exporting the data into individual child modules. Good design can accommodate any future changes without breaking the system. Will this design make our system fragile in case of any future changes? Let us have a look at that.</span></p>
<p class="calibre2"><span class="calibre11">After some time, you need to fetch the data from external web services along with the database. Also, you need to export the data in PDF format rather than HTML format. </span>To incorporate this change, you will create new classes/modules to fetch data from web services and to export the PDF as per the following snippet:</p>
<pre class="calibre17">// Separate child module for fetch the data from web service.<br class="title-page-name"/>public class FetchWebService {<br class="title-page-name"/>    public List&lt;Object[]&gt; fetchDataFromWebService(){<br class="title-page-name"/>         List&lt;Object[]&gt; dataFromWebService = new ArrayList&lt;Object[]&gt;();<br class="title-page-name"/>        //Logic to call Web Service and fetch the data and return it. <br class="title-page-name"/>        return dataFromWebService;<br class="title-page-name"/>     }<br class="title-page-name"/>}<br class="title-page-name"/>// Separate child module for export in PDF<br class="title-page-name"/>public class ExportPDF {<br class="title-page-name"/>    public File exportToPDF(List&lt;Object[]&gt; dataLst){<br class="title-page-name"/>        File pdfFile = null;<br class="title-page-name"/>        //Logic to iterate the dataLst and generate PDF file<br class="title-page-name"/>        return pdfFile;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">To accommodate the new ways of fetching and exporting data, the balance sheet module needs some sort of flag. Based on the value of this flag, the respective child module will be instantiated in the balance sheet module. The updated code of the <kbd class="calibre12">BalanceSheet</kbd> module would be as follows:</p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/><br class="title-page-name"/>  private ExportHTML exportHTML = null;<br class="title-page-name"/>  private FetchDatabase fetchDatabase = null;<br class="title-page-name"/>  private ExportPDF exportPDF = null;<br class="title-page-name"/>  private FetchWebService fetchWebService = null;<br class="title-page-name"/><br class="title-page-name"/>  public void generateBalanceSheet(int inputMethod, int outputMethod){<br class="title-page-name"/>    <br class="title-page-name"/>    //1. Instantiate the low level module object.<br class="title-page-name"/>    if(inputMethod == 1){<br class="title-page-name"/>      fetchDatabase = new FetchDatabase();<br class="title-page-name"/>    }else if(inputMethod == 2){<br class="title-page-name"/>      fetchWebService = new FetchWebService(); <br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>    //2. fetch and export the data for specific format based on flags. <br class="title-page-name"/>    if(outputMethod == 1){<br class="title-page-name"/>        List&lt;Object[]&gt; dataLst = null;<br class="title-page-name"/>        if(inputMethod == 1){<br class="title-page-name"/>          dataLst = fetchDatabase.fetchDataFromDatabase();<br class="title-page-name"/>        }else{<br class="title-page-name"/>          dataLst = fetchWebService.fetchDataFromWebService();<br class="title-page-name"/>        }<br class="title-page-name"/>      exportHTML.exportToHTML(dataLst);<br class="title-page-name"/>    }else if(outputMethod ==2){<br class="title-page-name"/>        List&lt;Object[]&gt; dataLst = null;<br class="title-page-name"/>        if(inputMethod == 1){<br class="title-page-name"/>          dataLst = fetchDatabase.fetchDataFromDatabase();<br class="title-page-name"/>        }else{<br class="title-page-name"/>          dataLst = fetchWebService.fetchDataFromWebService();<br class="title-page-name"/>        }<br class="title-page-name"/>      exportPDF.exportToPDF(dataLst);<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Great work! Our application is able to handle two different input and output methods to generate balance sheets. But wait a minute; what happens when you need to add more  methods (<span class="calibre11">fetch and export data</span>) in the future? For example, you might need to fetch the data from google drive and export the balance sheet in Excel format.</p>
<p class="calibre2">For every new method of input and output, you need to update your main module, the balance sheet module. When a module is dependent on another concrete implementation, it's said to be tightly coupled on that. This breaks the fundamental principle: open for extension but closed for modification.</p>
<p class="calibre2">Let's recall what DIP talks about: high-level modules should not depend on low-level modules for their responsibilities. Both should depend on abstractions.</p>
<p class="calibre2">This is the fundamental problem in our design. In our case, the balance sheet (<span class="calibre11">h</span>igh-leve<span class="calibre11">l</span>) module tightly depends on f<span class="calibre11">etch database and export HTML data (</span>low-level) modules.</p>
<p class="calibre2">As we have seen, principles always show the solution to design problems. It doesn't talk about how to implement it. In our case, DIP talks about removing the tight dependency of low-level modules on high-level modules.</p>
<p class="calibre2">But how do we do that? This is where IoC comes into the picture. IoC shows a way of defining abstraction between modules. In short, IoC is the way to implement DIP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inversion of Control</h1>
                
            
            <article>
                
<p class="calibre2">IoC is a design methodology used to build a loosely coupled system in software engineering by inverting the control of flow from your main program to some other entity or framework.</p>
<p class="calibre2">Here, the control refers to any additional activities a program is handling other than its main activities, such as creating and maintaining the dependency objects, managing the application flow, and so on.</p>
<p class="calibre2">Unlike procedural programming style, where a program handles multiple unrelated things all together, IoC defines a guideline where you need to break the main program in multiple independent programs <span class="calibre11">(modules) </span>based on responsibility and arrange them in such a way that they are loosely coupled.</p>
<p class="calibre2">In our example, we break the functionality into separate modules. The missing part was how to arrange them to make them decoupled, and we will learn how IoC makes that arrangement. B<span class="calibre11">y inverting (changing) the control, your application becomes decoupled, testable, extensible, and maintainable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing DIP through IoC</h1>
                
            
            <article>
                
<p class="calibre2">DIP suggests that high-level modules should not depend on low-level modules. Both should depend on abstraction. IoC provides a way to achieve the abstraction between high-level and low-level modules.</p>
<p class="calibre2">Let's see how we can apply DIP through IoC on our Balance Sheet example. The fundamental design problem is that high-level modules (balance sheet) tightly depend on low-level (fetch and export data) modules.</p>
<p class="calibre2">Our goal is to break this dependency. To achieve this, IoC suggests inverting the control. In IoC, inverting the control can be achieved in the following ways:</p>
<ul class="calibre9">
<li class="calibre22"><strong class="calibre1">Inverting the interface</strong>: Make sure the high-level module defines the interface, and low-level modules follow it</li>
<li class="calibre22"><strong class="calibre1">Inverting object creation</strong>: Change the creation of dependency from your main modules to some other program or framework</li>
<li class="calibre22"><strong class="calibre1">Inverting flow</strong>:<span> </span>Change the flow of application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inverting the interface</h1>
                
            
            <article>
                
<p class="calibre2">Inverting the interface means inverting the interaction control from low-level modules to high-level modules. Your high-level module should decide which low-level modules can interact with it, rather than keep changing itself to integrate each new low-level module.</p>
<p class="calibre2">After inverting the interface, our design would be as per the following diagram:</p>
<div class="mce-root"><img src="../images/00007.jpeg" class="calibre23"/></div>
<p class="calibre2">In this design, the balance sheet module (high-level) is interacting with fetch data and export data (low-level) modules with common interface. The very clear benefits of this design are that you can add new fetch data and export data (low-level) modules without changing anything on the balance sheet m<span class="calibre11">odule </span>(high-level).</p>
<p class="calibre2">As far as low-level modules are compatible with the interface, the high-level modules will be happy to work with it. With this new design, high-level modules are not dependent on low-level modules, and both are interacting through an abstraction (interface). Separating the interface from the implementation is a prerequisite to achieve DIP.</p>
<p class="calibre2">Let's change our code as per this new design. First, we need to create two interfaces: to fetch the data and export the data as follows:</p>
<pre class="calibre17">public interface IFetchData {<br class="title-page-name"/>    //Common interface method to fetch data. <br class="title-page-name"/>    List&lt;Object[]&gt; fetchData();<br class="title-page-name"/>}<br class="title-page-name"/>public interface IExportData { <br class="title-page-name"/>    //Common interface method to export data. <br class="title-page-name"/>    File exportData(List&lt;Object[]&gt; listData);<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, all low-level modules must implement these interfaces as per the following snippet:</p>
<pre class="calibre17">public class FetchDatabase implements IFetchData {<br class="title-page-name"/>    public List&lt;Object[]&gt; fetchData(){<br class="title-page-name"/>         List&lt;Object[]&gt; dataFromDB = new ArrayList&lt;Object[]&gt;();<br class="title-page-name"/>         //Logic to call database, execute a query and fetch the data<br class="title-page-name"/>         return dataFromDB;<br class="title-page-name"/>     }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class FetchWebService implements IFetchData {<br class="title-page-name"/>    public List&lt;Object[]&gt; fetchData(){<br class="title-page-name"/>         List&lt;Object[]&gt; dataFromWebService = new ArrayList&lt;Object[]&gt;();<br class="title-page-name"/>        //Logic to call Web Service and fetch the data and return it. <br class="title-page-name"/>        return dataFromWebService;<br class="title-page-name"/>     }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ExportHTML implements IExportData{<br class="title-page-name"/>    public File exportData(List&lt;Object[]&gt; listData){<br class="title-page-name"/>        File outputHTML = null;<br class="title-page-name"/>        //Logic to iterate the listData and generate HTML File<br class="title-page-name"/>        return outputHTML;<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>public class ExportPDF implements IExportData{<br class="title-page-name"/>     public File exportData(List&lt;Object[]&gt; dataLst){<br class="title-page-name"/>        File pdfFile = null;<br class="title-page-name"/>        //Logic to iterate the listData and generate PDF file<br class="title-page-name"/>        return pdfFile;<br class="title-page-name"/>     }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">Finally, the balance sheet  module needs to rely on interfaces to interact with low-level modules. So the updated <kbd class="calibre12">BalanceSheet</kbd> module should look like the following snippet:</span></p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/>  private IExportData exportDataObj= null;<br class="title-page-name"/>  private IFetchData fetchDataObj= null;<br class="title-page-name"/> <br class="title-page-name"/>  public Object generateBalanceSheet(){<br class="title-page-name"/>    List&lt;Object[]&gt; dataLst = fetchDataObj.fetchData();<br class="title-page-name"/>    return exportDataObj.exportData(dataLst);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">You may have observed that, the <kbd class="calibre12">generateBalanceSheet()</kbd> method became more straightforward. It allows us to work with additional fetch and export modules without any change. It is thanks to the mechanism of inverting the interface that makes this possible.</p>
<p class="calibre2">This design looks perfect; but still, there is one problem. If you noticed, the balance sheet module is still keeping the responsibility of creating low-level module objects (<kbd class="calibre12">exportDataObj </kbd>and <kbd class="calibre12">fetchDataObj</kbd>). In other words, object creation dependency is still with the high-level modules.</p>
<p class="calibre2">Because of this, the <span class="calibre11">Balance Sheet module is not 100 percent decoupled from the low-level modules, even after implementing interface inversion. You will end up instantiating low-level modules with if/else blocks based on some flag, and the high-level module keeps changing for adding additional low-level modules integration.</span></p>
<p class="calibre2">To overcome this, you need to invert the object creation from your higher-level module to some other entity or framework. This is the second way of implementing IoC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inverting object creation </h1>
                
            
            <article>
                
<p class="calibre2">Once the abstraction between modules is set, there is no need to keep the logic of creating dependency objects in higher-level modules. Let us understand the importance of inversion of object creation design with one more example.</p>
<p class="calibre2">Suppose you are designing a war game. Your player can shoot the enemy with various weapons. You created separate classes (low-level module) for each of the weapons. While playing the game, your player can add the weapon based on points earned.</p>
<p class="calibre2">Also, the player can change the weapon. To implement inversion of interface, we created an interface called <kbd class="calibre12">Weapon</kbd>, which will be implemented by all weapon modules, as per the following diagram:</p>
<div class="mce-root"><img src="../images/00008.gif" class="calibre24"/></div>
<p class="calibre2">Assume that there are three weapons initially that you kept in the game. If you keep weapon creation code in your player module, the logic of choosing a weapon would be as per the following snippet:</p>
<pre class="calibre17">public class Player {<br class="title-page-name"/>  private Weapon weaponInHand;<br class="title-page-name"/>  public void chooseWeapon(int weaponFlag){<br class="title-page-name"/>    if(weaponFlag == 1){<br class="title-page-name"/>      weaponInHand = new SmallGun();<br class="title-page-name"/>    }else if(weaponFlag ==2){<br class="title-page-name"/>      weaponInHand = new Rifle();<br class="title-page-name"/>    }else{<br class="title-page-name"/>      weaponInHand = new MachineGun();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void fireWeapon(){<br class="title-page-name"/>    if(this.weaponInHand !=null){<br class="title-page-name"/>      this.weaponInHand.fire();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Since the player module is taking care of creating the object of weapons, we are passing a flag in the <kbd class="calibre12">chooseWeapon()</kbd> method. Let us assume that, over a period of time, you add a few more weapons to the game. Y<span class="calibre11">ou end up changing the code of the <kbd class="calibre12">Player</kbd> module e</span><span class="calibre11">very time you add a new weapon.</span></p>
<p class="calibre2">The solution to this problem is to invert the object creation process from your main module to another entity or framework.</p>
<p class="calibre2">Let's first apply this solution to our <kbd class="calibre12">Player</kbd> module. The updated code would be as follows:</p>
<pre class="calibre17">public class Player {<br class="title-page-name"/>  private Weapon weaponInHand; <br class="title-page-name"/>  public void chooseWeapon(Weapon setWeapon){<br class="title-page-name"/>    this.weaponInHand = setWeapon;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void fireWeapon(){<br class="title-page-name"/>    if(this.weaponInHand !=null){<br class="title-page-name"/>      this.weaponInHand.fire();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">You can observe the following things:</p>
<ul class="calibre9">
<li class="calibre10">In the <kbd class="calibre12">chooseWeapon()</kbd> method, we are passing the object of weapons through the interface. The <kbd class="calibre12">Player</kbd> module is no longer handling the creation of weapon objects.</li>
<li class="calibre10">This way, the <kbd class="calibre12">Player</kbd> (higher-level) module is completely decoupled from <kbd class="calibre12">Weapon</kbd> (low-level) modules.</li>
<li class="calibre10">Both modules interact through the interface, defined by higher-level modules.</li>
<li class="calibre10">For any new weapon added into the system, you do not need to change anything in the player module.</li>
</ul>
<p class="calibre2">Let's apply this solution (invert creating object) to our balance sheet module. The updated code for the <kbd class="calibre12">BalanceSheet</kbd> module would be as per the following snippet:</p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/><br class="title-page-name"/>  private IExportData exportDataObj= null;<br class="title-page-name"/>  private IFetchData fetchDataObj= null;<br class="title-page-name"/>  <br class="title-page-name"/>  //Set the fetch data object from outside of this class.<br class="title-page-name"/>  public void configureFetchData(IFetchData actualFetchDataObj){<br class="title-page-name"/>    this.fetchDataObj = actualFetchDataObj;<br class="title-page-name"/>  }<br class="title-page-name"/>  //Set the export data object from outside of this class.<br class="title-page-name"/>  public void configureExportData(IExportData actualExportDataObj){<br class="title-page-name"/>    this.exportDataObj = actualExportDataObj;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public Object generateBalanceSheet(){<br class="title-page-name"/>    List&lt;Object[]&gt; dataLst = fetchDataObj.fetchData();<br class="title-page-name"/>    return exportDataObj.exportData(dataLst);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Here are some quick observations:</p>
<ul class="calibre9">
<li class="calibre10">Objects of fetch data and export data modules are created outside the balance sheet module, and passed through <kbd class="calibre12">configureFetchData()</kbd> and <kbd class="calibre12">configureExportData()</kbd> methods</li>
<li class="calibre10">The balance sheet module is now  100 percent decoupled from fetch data and export data modules</li>
<li class="calibre10">For any new type of fetch and export data, no change is required in balance sheet modules</li>
</ul>
<p class="calibre2">At this moment, the relation between DIP and IoC can be described as per the following diagram:</p>
<div class="mce-root"><img src="../images/00009.jpeg" class="calibre25"/></div>
<p class="calibre2">Finally, we implemented <strong class="calibre4">DIP</strong> through <strong class="calibre4">IoC</strong> and solved one of the most fundamental problems of interdependency between modules.</p>
<p class="calibre2">But hold on, something is not complete yet. We have seen that keeping the object creation away from your main module will eliminate the risk of accommodating changes and make your code decoupled. But we haven't explored how to create and pass the dependency object from outside code into your module. There are various ways of inverting object creation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Different ways to invert object creation</h1>
                
            
            <article>
                
<p class="calibre2">We have seen how inversion of object creation helps us to decouple the modules. You can achieve the inversion of object creation with multiple design patterns as follows:</p>
<ul class="calibre9">
<li class="calibre10">Factory pattern</li>
<li class="calibre10">Service locator</li>
<li class="calibre10">Dependency injection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inversion of object creation through the factory pattern</h1>
                
            
            <article>
                
<p class="calibre2">The factory pattern takes the responsibility of creating an object from a client who uses it. It generates the object of classes that are following a common interface. A client has to pass only type of the implementation it wants and the factory will create that object.</p>
<p class="calibre2">If we apply the factory pattern to our balance sheet example, the process of inverting of object creation is depicted as per the following diagram:</p>
<div class="mce-root"><img src="../images/00010.jpeg" class="calibre26"/></div>
<ul class="calibre9">
<li class="calibre10">Client (in our case, it's a balance sheet module) talks to the factory—Hey factory, can you please give me the fetch data object? Here is the type.</li>
<li class="calibre10"><span>The factory takes the type, creates the object, and passes it to the client (the b</span>alance sheet <span>module).</span></li>
<li class="calibre10"><span>The factory can create the object of the same type only.</span></li>
<li class="calibre10"><span>The factory class is a complete black box for its clients. They know it's a static method to get objects.</span></li>
</ul>
<p class="calibre2">The Balance Sheet module can get <kbd class="calibre12">FetchData</kbd> objects from <kbd class="calibre12">FetchDataFactory</kbd>. The code of <kbd class="calibre12">FetchDataFactory</kbd> will be as follows:</p>
<pre class="calibre17">public class FetchDataFactory {<br class="title-page-name"/>  public static IFetchData getFetchData(String type){<br class="title-page-name"/>    IFetchData fetchData = null;<br class="title-page-name"/>    if("FROM_DB".equalsIgnoreCase(type)){<br class="title-page-name"/>      fetchData = new FetchDatabase();<br class="title-page-name"/>    }else if("FROM_WS".equalsIgnoreCase(type)){<br class="title-page-name"/>      fetchData = new FetchWebService();<br class="title-page-name"/>    }else {<br class="title-page-name"/>      return null;<br class="title-page-name"/>    }<br class="title-page-name"/>    return fetchData;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">To use this factory, you need to update the <kbd class="calibre12">configureFetchData()</kbd> method of a balance sheet module as follows:</p>
<pre class="calibre17">//Set the fetch data object from Factory.<br class="title-page-name"/>  public void configureFetchData(String type){<br class="title-page-name"/>    this.fetchDataObj = FetchDataFactory.getFetchData(type);<br class="title-page-name"/>  }</pre>
<p class="calibre2"><span class="calibre11">For export data, you need to create a separate factory as per the following snippet:</span></p>
<pre class="calibre17">public class ExportDataFactory {<br class="title-page-name"/><br class="title-page-name"/>  public static IExportData getExportData(String type){<br class="title-page-name"/>    IExportData exportData = null;<br class="title-page-name"/>    if("TO_HTML".equalsIgnoreCase(type)){<br class="title-page-name"/>      exportData = new ExportHTML();<br class="title-page-name"/>    }else if("TO_PDF".equalsIgnoreCase(type)){<br class="title-page-name"/>      exportData = new ExportPDF();<br class="title-page-name"/>    }else {<br class="title-page-name"/>      return null;<br class="title-page-name"/>    }<br class="title-page-name"/>    return exportData;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">If a new fetch data or export data type is introduced, you need to change it in its respective factory class only.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inversion of object creation through service locator</h1>
                
            
            <article>
                
<p class="calibre2">The service locator pattern works more or less the same as to the factory pattern. The service locator can find the existing object and send it to the client rather than create a new one every time, as with the factory pattern. Instead of getting into detail, we will just look briefly at how the service locator works to create objects. The flow of the service locator can be described as per the following diagram:</p>
<div class="mce-root"><img src="../images/00011.jpeg" class="calibre27"/></div>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Client</strong> is relying on <strong class="calibre1">Service Locator</strong> to find services. Here, <em class="calibre28">service</em> means any kind of dependency</li>
<li class="calibre10"><strong class="calibre1">Service Locator</strong> takes the name of the service, and returns the object of service back to the client</li>
</ul>
<p class="calibre2">If our balance sheet module uses the service locator, the code of the <span class="calibre11"><kbd class="calibre12">configureFetchData()</kbd> method would be like the following snippet:</span></p>
<pre class="calibre17">//Set the fetch data object from ServiceLocator.<br class="title-page-name"/>  public void configureFetchData(String type){<br class="title-page-name"/>    this.fetchDataObj = FetchDataServiceLocator.Instance.getFetchData(type);<br class="title-page-name"/>  }</pre>
<p class="calibre2">Similar to fetch data, you need to design a separate service locator for export data. For any new fetch data or export data type, the changes need to be done in the service locator.</p>
<p class="calibre2">Another way of inverting the object creation is DI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection</h1>
                
            
            <article>
                
<p class="calibre2"> <strong class="calibre4">DI</strong> is one of the ways to invert the object creation process from your module to other code or entity. <span class="calibre11">The term <em class="calibre13">injection</em> refers to the process of passing the dependent object into a software component.</span></p>
<p class="calibre2">Since DI is one of the ways to implement <strong class="calibre4">IoC</strong>, it relies on abstraction to set the dependency. The client object doesn't know which class will be used to provide functionality at compile time. The dependency will be resolved at runtime.</p>
<p class="calibre2">A dependent object does not directly call to the client object; instead, the client object will call a dependent object whenever required. It's similar to the Hollywood principle: Don't call us, we'll call you when we need to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection types</h1>
                
            
            <article>
                
<p class="calibre2">In DI, you need to set the entry point in a client object from which the dependency can be injected. Based on these entry points, DI can be implemented with the following types:</p>
<ul class="calibre9">
<li class="calibre10">Constructor injection</li>
<li class="calibre10">Setter injection</li>
<li class="calibre10">Interface injection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor injection</h1>
                
            
            <article>
                
<p class="calibre2">This is the most common way to inject dependency. In this approach, you need to pass the dependent object through a public constructor of a client object. <span class="calibre11">Please note that in case of construction injection, you need to pass all the dependency objects in the constructor of a client object.</span></p>
<p class="calibre2">Constructor injection can control the order of instantiation and consequently reduce the risk of circular dependency. All mandatory dependencies can be passed through constructor injection.</p>
<p class="calibre2">In our <kbd class="calibre12">BalanceSheet</kbd> example, we need to pass two objects in a constructor, because it has two dependencies: one is for fetch data, and the second is for export data types, as per the following snippet:</p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/><br class="title-page-name"/>  private IExportData exportDataObj= null;<br class="title-page-name"/>  private IFetchData fetchDataObj= null;<br class="title-page-name"/>  <br class="title-page-name"/>  //All dependencies are injected from client's constructor <br class="title-page-name"/>  BalanceSheet(IFetchData fetchData, IExportData exportData){<br class="title-page-name"/>    this.fetchDataObj = fetchData;<br class="title-page-name"/>    this.exportDataObj = exportData;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public Object generateBalanceSheet(){<br class="title-page-name"/>    List&lt;Object[]&gt; dataLst = fetchDataObj.fetchData();<br class="title-page-name"/>    return exportDataObj.exportData(dataLst);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">All dependencies are injected from a constructor of a client object. Since constructors are called only once, it's clear that the dependency object will not be changed until the existence of a client object. If a client uses constructor injection, then extending and overriding it would be difficult sometimes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setter injection</h1>
                
            
            <article>
                
<p class="calibre2">As its name suggests, here dependency injection is done through setter methods exposed publicly. Any dependency not required at the time of client object instantiation is called <strong class="calibre4">optional dependency</strong>. They can be set at a later stage after a client object is created.</p>
<p class="calibre2"><strong class="calibre4">Setter injection</strong> is a perfect fit for optional or conditional dependency. Let's apply a setter injection to the <kbd class="calibre12">BalanceSheet</kbd> module.</p>
<p class="calibre2">The code would look as follows:</p>
<pre class="calibre17">public class BalanceSheet {<br class="title-page-name"/><br class="title-page-name"/>  private IExportData exportDataObj= null;<br class="title-page-name"/>  private IFetchData fetchDataObj= null;<br class="title-page-name"/>  <br class="title-page-name"/>  //Setter injection for Export Data <br class="title-page-name"/>  public void setExportDataObj(IExportData exportDataObj) {<br class="title-page-name"/>    this.exportDataObj = exportDataObj;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  //Setter injection for Fetch Data<br class="title-page-name"/>  public void setFetchDataObj(IFetchData fetchDataObj) {<br class="title-page-name"/>    this.fetchDataObj = fetchDataObj;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public Object generateBalanceSheet(){<br class="title-page-name"/>    <br class="title-page-name"/>    List&lt;Object[]&gt; dataLst = fetchDataObj.fetchData();<br class="title-page-name"/>    return exportDataObj.exportData(dataLst);<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>}</pre>
<p class="calibre2">For each dependency, you need to put separate setter methods. Since the dependencies are set through the setter method, the object or a framework which supplies the dependencies need to call the setter methods at an appropriate time to make sure dependencies are available before a client object starts using it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interface injection</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Interface injection</strong> defines a way by which the dependency provider should talk to a client. It abstracts the process of passing dependency. The dependency provider defines an interface that all clients need to implement. This method is not so frequently used.</p>
<p class="calibre2">Technically, interface injection and setter injection are the same. They both use some sort of method to inject dependency. However, for interface injection, the method is defined by objects which provide the dependency.</p>
<p class="calibre2">Let's apply interface injection to our balance sheet module:</p>
<pre class="calibre17">public interface IFetchAndExport {<br class="title-page-name"/>  void setFetchData(IFetchData fetchData);<br class="title-page-name"/>  void setExportData(IExportData exportData);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Client class implements interface<br class="title-page-name"/>public class BalanceSheet implements IFetchAndExport {<br class="title-page-name"/><br class="title-page-name"/>  private IExportData exportDataObj= null;<br class="title-page-name"/>  private IFetchData fetchDataObj= null;<br class="title-page-name"/>  <br class="title-page-name"/>  //Implements the method of interface injection to set dependency<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void setFetchData(IFetchData fetchData) {<br class="title-page-name"/>    this.fetchDataObj = fetchData;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  //Implements the method of interface injection to set dependency<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void setExportData(IExportData exportData) {<br class="title-page-name"/>    this.exportDataObj = exportData;<br class="title-page-name"/>    <br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public Object generateBalanceSheet(){<br class="title-page-name"/>    List&lt;Object[]&gt; dataLst = fetchDataObj.fetchData();<br class="title-page-name"/>    return exportDataObj.exportData(dataLst);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have created interface <span class="calibre11"><kbd class="calibre12">IFetchAndExport</kbd> </span>and defined methods to inject dependencies. The dependency provider class knows how to pass the dependency through this interface. Our client object (Balance Sheet module) implements this method to set dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">IoC containers</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have talked about the code or framework that plays the role of dependency provider. It can be any custom code or full-fledged <strong class="calibre4">IoC</strong> container. Some developers refer to it as a <em class="calibre13">DI container</em>, but we will simply call it a <em class="calibre13">container</em>.</p>
<p class="calibre2"><span class="calibre11">If we write custom code to supply dependency, things get smoother until we have just a single level of dependency. Take the scenario where our client classes are also dependent of some other modules. This results in chained or nested dependencies.</span></p>
<p class="calibre2"><span class="calibre11">In this situation, implementing dependency injection will become quite complicated through manual code. That is where we need to rely on containers. </span></p>
<p class="calibre2">A container takes care of creating, configuring, and managing objects. You just need to do configuration, and the container will take care of object instantiation and dependency management with ease. You don't need to write any custom code such as <span class="calibre11">that</span> we wrote while implementing <strong class="calibre4">IoC</strong> with factory or service locator patterns.</p>
<p class="calibre2"><span class="calibre11">So, as a developer, your life is cool. You just give a hint about your dependency, and the container will handle the rest and you can focus on implementing business logic.</span></p>
<p class="calibre2">If we choose containers to set dependencies for our Balance Sheet module, the container will create the objects of all dependencies first. Then, it will create an object of the Balance Sheet class and pass the dependencies in it. A container will do all these things silently and give you the object of the Balance Sheet module with all dependencies set in it. This process can be described with the following diagram:</p>
<div class="mce-root"><img src="../images/00012.gif" class="calibre29"/></div>
<p class="calibre2">In conclusion, the following are the advantages of using containers over manual code to manage dependency:</p>
<ul class="calibre9">
<li class="calibre10">Isolating the process of object creation from your code and making your code more clean and readable.</li>
<li class="calibre10">Removing object wiring (setting dependency) code from your client module. The container will take care of object wiring.</li>
<li class="calibre10">Making your modules 100 percent loose coupling.</li>
<li class="calibre10">Managing the entire lifecycle of the modules. This is very helpful when you want to configure the objects for various scopes, such as request, session, and so on in application execution.</li>
<li class="calibre10">Swapping out the dependency is just a matter of configuration—no change is required in the code.</li>
<li class="calibre10">It is a more centralized way to handle object life span and dependency management. This is useful when you want to apply some common logic across the dependencies, for example, AOP in Spring. We will see details about AOP in <a href="part0156.html#4KONO0-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 6</a>, <span><em class="calibre28">Aspect-Oriented Programming and Interceptors</em></span>.</li>
<li class="calibre10">Your module can benefit from advanced features that ship with containers.</li>
</ul>
<p class="calibre2">Spring, Google Guice, and Dagger are some of the IoC containers available today for Java. Starting from Enterprise Edition version 6, Java introduced <strong class="calibre4">Context Dependency Injection</strong> (<span class="calibre11"><strong class="calibre4">CDI</strong>), </span>a dependency injection framework in Enterprise Edition. It's more or less similar to Spring's annotation-based DI implementation. Out of all the preceding containers, Spring is the most popular and widely used IoC container today.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In the software paradigm, it's always recommended to break the whole system down into small modules that can work independently for specific tasks. DIP is one of the important principles to build a modular system. In this chapter, we saw how high-level modules should not depend on low-level modules, and both should depend on abstraction (the concept of DIP).</p>
<p class="calibre2">We learned in detail how we can achieve DIP through IoC. Setting inversion of control makes a system loosely coupled. We also learned various design patterns such as factory, service locator, and dependency injection to implement IoC.</p>
<p class="calibre2">After that, we learned about the various types of the dependency injection pattern. Finally, we discussed <strong class="calibre4">IoC</strong> containers and how they're useful when building modular systems.</p>
<p class="calibre2">In the next chapter, we will talk about modularity concepts and dependency injection in Java 9.</p>


            </article>

            
        </section>
    </body></html>