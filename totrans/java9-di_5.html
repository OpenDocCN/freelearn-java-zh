<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scopes</h1>
                
            
            <article>
                
<p class="calibre2">On this journey, we've learned dependency injection concepts in Java 9, Spring, and Google Guice, with the help of examples.</p>
<p class="calibre2">In <a href="part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 3</a>, <em class="calibre13">Dependency Injection with Spring</em>, and <a href="part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 4</a>, <em class="calibre13">Dependency Injection with Google Guice,</em> we came across the word scope,<strong class="calibre4"> </strong>which is a very important element of Spring beans and Google Guice. So, let's understand what a scope is, and why it is important when talking about dependency injection.</p>
<p class="calibre2">In this chapter, we will first learn about various scopes provided by Spring, and how they can be defined for Spring beans. We will also learn the relation between bean scope and dependency injection. Finally, we will look into the scopes available in Google Guice. The topics we are going to cover are as follows:</p>
<ul class="calibre9">
<li class="calibre10">Introduction to bean scopes in Spring</li>
<li class="calibre10">How to define a bean scope</li>
<li class="calibre10">Dependency injection and bean scopes</li>
<li class="calibre10">How to choose a bean scope</li>
<li class="calibre10">Scopes in Google Guice</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to bean scopes in Spring</h1>
                
            
            <article>
                
<p class="calibre2">In <a href="part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 3</a>, <em class="calibre13">Dependency Injection with Google Guice,</em> we learned about different Spring modules along with dependency injection. In Spring, beans are the backbone of an application, and they are managed by a Spring IOC container. A bean is a class or object that is created using the configuration of metadata that we can pass to an IOC container. Before learning about scope, let's define a bean in Spring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bean definition </h1>
                
            
            <article>
                
<p class="calibre2">The metadata of a <strong class="calibre4">bean</strong> has its own properties with independent bean definitions. Some of these bean definitions are as follows:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Class</strong>: This will be used to create a bean, and it is mandatory to mention a class name for which we are supposed to create a bean.</li>
<li class="calibre10"> <strong class="calibre1">Name</strong>: I<span>f we want to define different aliases for the bean, then we use the </span><kbd class="calibre12">name</kbd> <span>attribute, with the help of a separator, such as a comma (<kbd class="calibre12">,</kbd>) or semicolon (<kbd class="calibre12">;</kbd>). When we have XML-based configuration, we can use the <kbd class="calibre12">name</kbd> and/or</span> <kbd class="calibre12">id</kbd> <span>attribute as an identifier for a bean. A bean with an <kbd class="calibre12">id</kbd> attribute is preferred, because it is mapped with an actual XML ID element. </span></li>
<li class="calibre10"><strong class="calibre1">Constructor-arg</strong>: A constructor argument is used to inject dependencies by passing a parameter as an argument in a constructor, which we<span> saw in <a href="part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 3</a>, <em class="calibre28">Dependency Injection with Spring</em>. </span></li>
<li class="calibre10"><strong class="calibre1">Properties</strong>: We can directly pass properties with key-value pairs in a Spring bean for injecting. This is useful sometimes if we need to pass certain fixed values to a bean.</li>
<li class="calibre10"><strong class="calibre1">Autowiring mode</strong>: Autowiring can be used to reduce the use of properties and constructor arguments. To enable autowiring mode, we need to use the <kbd class="calibre12">autowire</kbd> attribute in a Spring bean. Attributes can have values such as <kbd class="calibre12">byName</kbd>, <kbd class="calibre12">byType</kbd>, and <kbd class="calibre12">constructor</kbd><em class="calibre28">.</em></li>
<li class="calibre10"><strong class="calibre1">Lazy initialization mode</strong>: By default, a Spring bean is created with a singleton scope, which initializes all the properties in eager mode. If a bean is defined with lazy mode, then an IOC container creates a bean instance the first time the request comes, rather than during the startup process.</li>
<li class="calibre10"><strong class="calibre1">Initialization method</strong>: Spring initialization works after all the properties are set by an IOC container. In XML-based configuration, we can define an <kbd class="calibre12">init</kbd> method <span>by defining an </span><kbd class="calibre12">init-method</kbd><span> attribute</span>. The <kbd class="calibre12">init</kbd> method should be void, and without arguments. A <kbd class="calibre12">@PostConstruct</kbd> annotation can be used for initializing methods.</li>
<li class="calibre10"><strong class="calibre1">Destruction method</strong>: On completion of a bean lifecycle, if we have to close resources or want to perform actions before destruction of a bean, we can use the <kbd class="calibre12">destroy-method</kbd> attribute of a bean in XML configuration. The <kbd class="calibre12">@PreDestroy</kbd> annotation is also used instead of the XML attribute.</li>
</ul>
<p class="calibre2">The following configuration file contains different types of bean definition <span class="calibre11">syntax and for that</span>, the <kbd class="calibre12">application-context.xml</kbd> file could be:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>       <br class="title-page-name"/>   &lt;!-- A simple bean definition with ID and Class Name--&gt;<br class="title-page-name"/>   &lt;bean id = "..." class = "..."&gt;<br class="title-page-name"/>      &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/>   <br class="title-page-name"/>   &lt;!-- Bean definition using Name attribute instead of ID attribute --&gt;<br class="title-page-name"/>   &lt;bean name = "..." class = "..."&gt;<br class="title-page-name"/>      &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/>   <br class="title-page-name"/>   &lt;!-- Ban definition with constructor arguments --&gt;<br class="title-page-name"/>   &lt;bean id="..." class="..."&gt;<br class="title-page-name"/>        &lt;constructor-arg ref="..."/&gt;<br class="title-page-name"/>        &lt;constructor-arg ref="..."/&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/>   <br class="title-page-name"/>   &lt;!-- Ban definition for autowiring using byName mode --&gt;<br class="title-page-name"/>   &lt;bean id="..." class="..." autowire="byName"&gt;<br class="title-page-name"/>   &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/>   <br class="title-page-name"/>   &lt;!-- Ban definition for defining scope --&gt;<br class="title-page-name"/>   &lt;bean id="..." class="..." scope="prototype"&gt;<br class="title-page-name"/>   &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt; <br class="title-page-name"/>       <br class="title-page-name"/>   &lt;!-- Ban definition with lazy initialization mode --&gt;<br class="title-page-name"/>   &lt;bean id = "..." class = "..." lazy-init = "true"&gt;<br class="title-page-name"/>      &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/> <br class="title-page-name"/>   &lt;!-- Bean definition which has initialization method --&gt;<br class="title-page-name"/>   &lt;bean id = "..." class = "..." init-method = "init"&gt;<br class="title-page-name"/>       &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/> <br class="title-page-name"/>   &lt;!-- Bean definition which has destruction method --&gt;<br class="title-page-name"/>   &lt;bean id = "..." class = "..." destroy-method = "destroy"&gt;<br class="title-page-name"/>       &lt;!-- Bean configuration and properties like constructor-arg --&gt;<br class="title-page-name"/>   &lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;/beans&gt;</pre>
<div class="packt_tip">Lazy instantiation is most effective when <span class="calibre18">the scope is <strong class="calibre38">singleton</strong>. With the <strong class="calibre38">prototype</strong> scope, a bean initializes with lazy mode by default. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring scopes</h1>
                
            
            <article>
                
<p class="calibre2">We have understood how a bean definition works with different attributes, and <strong class="calibre4">s</strong><span class="calibre11"><strong class="calibre4">cope</strong> is one of the attributes in a bean definition. Before going on to learn about scope types, one question comes to mind: what are scopes?</span></p>
<p class="calibre2"><span class="calibre11">If we look from a Spring perspective, </span><span class="calibre11">the meaning of <strong class="calibre4">scope</strong> is, </span><em class="calibre13">to characterize the life cycle of a bean and define visibility of that bean within a specific context in which the bean is utilized</em><span class="calibre11">. When the scope of the object ends, it will be considered</span> <strong class="calibre4">out of scope</strong> <span class="calibre11">and can no longer be</span><span class="calibre11"> injected </span><span class="calibre11">into different </span><span class="calibre11">instances</span><span class="calibre11">.</span></p>
<div class="packt_tip">From the <strong class="calibre38">The Oxford English Dictionary</strong>, scope means "<em class="calibre19">the extent of the area or subject matter that something deals with or to which it is relevant</em>."</div>
<p class="calibre2">Spring has seven scopes, and out of them, five are used for web application development. The following is a diagram of <strong class="calibre4">Bean Scopes</strong>:</p>
<div class="mce-root"><img src="../images/00031.jpeg" class="calibre48"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton scope</h1>
                
            
            <article>
                
<p class="calibre2">Each bean created by a Spring container has a default <strong class="calibre4">Singleton</strong> scope; S<span class="calibre11">pring treats </span><span class="calibre11">it as </span><span class="calibre11">one </span><span class="calibre11">instance</span><span class="calibre11"> of the bean, and it is served for </span><span class="calibre11">each</span><span class="calibre11"> </span><span class="calibre11">request</span><span class="calibre11"> for that bean from the cache </span><span class="calibre11">inside</span><span class="calibre11"> the </span><span class="calibre11">container</span><span class="calibre11">. In dependency injection, a bean defined as a singleton is injected as a shared bean from the cache. </span></p>
<p class="calibre2">A <strong class="calibre4">Singleton</strong> bean scope is <span class="calibre11">restricted</span><span class="calibre11"> </span>to the Spring container, compared to this Singleton pattern in Java, where only one instance of a specific class will ever be created per <kbd class="calibre12">ClassLoader</kbd>. This scope is <span class="calibre11">useful</span><span class="calibre11"> </span>in web applications as well as standalone applications, and stateless beans can also utilize a <strong class="calibre4">Singleton</strong> scope.</p>
<p class="calibre2">On the off chance that three beans have distinctive IDs but the same class with a <strong class="calibre4">Singleton</strong> scope, at that point, three instances will be made of that class and in terms of bean ID, as only one instance of the singleton bean is made:</p>
<div class="packt_figref"><img src="../images/00032.gif" class="calibre49"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prototype scope</h1>
                
            
            <article>
                
<p class="calibre2">When we need to create multiple instances of a bean, then we use the <span class="calibre11">prototype</span> scope. A <kbd class="calibre12">prototype</kbd> scoped bean is mostly used for stateful beans. So, on each and every request, a new instance of the bean will be created by the IoC container. This bean can be injected into another bean, or used by calling a <kbd class="calibre12">getBean()</kbd> method of a container.</p>
<p class="calibre2">But, a container does not maintain the record of a <kbd class="calibre12">prototype</kbd> bean after initialization. We have to implement a custom <kbd class="calibre12">BeanPostProcessor</kbd> to release the resources occupied by the <span class="calibre11">prototype</span> bean. A <kbd class="calibre12">destroy</kbd> <span class="calibre11">method of the life cycle is not called in the case of a </span><span class="calibre11">prototype</span><span class="calibre11"> scope, only </span>initial <kbd class="calibre12">call-back</kbd> methods are called for all the objects irrespective of scope: </p>
<div class="mce-root"><img src="../images/00033.jpeg" class="calibre50"/></div>
<p class="calibre2"><span class="calibre11">So far, we have seen <strong class="calibre4"><span class="calibre11"><span class="calibre11">S</span><span class="calibre11">ingleton</span></span></strong> and <span class="calibre11">Prototype</span> scopes. Both can be used in standalone and web applications, but there are five more scopes that only work in web applications. If we used these scopes with <kbd class="calibre12">ClassPathXmlApplicationContext</kbd>, then it will throw an <kbd class="calibre12">IllegalStateException</kbd> for an unknown scope.</span></p>
<p class="calibre2">To use the <span class="calibre11">request</span>, <span class="calibre11">session</span>, <span class="calibre11">global session</span>, <span class="calibre11">application</span>, and <span class="calibre11">websocket</span> scopes, we need to use a web-aware application context implementation (<kbd class="calibre12">XmlWebApplicationContext</kbd>). Let's look at all the web scopes in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Request scope</h1>
                
            
            <article>
                
<p class="calibre2">In a web application, every HTTP request from a client gets a new bean instance if the bean is scoped as a <strong class="calibre4">request</strong>. On an HTTP request completion, a bean will immediately be considered out of scope, and memory will be released. If a server has 100 concurrent requests, then there will be 100 <span class="calibre11">distinct instances of a bean class available. If there is any change in one instance, it will not affect other instances. Following is an image of the request scope:</span></p>
<div class="mce-root"><img src="../images/00034.jpeg" class="calibre51"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Session scope</h1>
                
            
            <article>
                
<p class="calibre2">A <strong class="calibre4">session</strong> is a group of <span class="calibre11">interactive </span>information, also known as a <em class="calibre13">conversion</em> between client and server within a specific time frame on a website. In an <strong class="calibre4">Apache Tomcat</strong> server, the default time frame of one session is 30 minutes, which includes all the operations made by a user.</p>
<p class="calibre2">The Spring session bean scope is similar to an HTTP session; an IoC container creates a new instance of a bean for each user session. On user logout, its session bean will be out of scope. Like a request, if 50 users are concurrently using a website, then a server has 50 active sessions, and a Spring container also has 50 different instances of a bean class:</p>
<div class="mce-root"><img src="../images/00035.jpeg" class="calibre52"/></div>
<p class="calibre2">The previous image illustrates that all HTTP requests from the user are included in a single session, and all requests may have lifetime access of a single bean instance in that session scope. Session instances are destroyed, as before long, the session is destroyed/quit on the server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Application scope</h1>
                
            
            <article>
                
<p class="calibre2">The application scope only works on a web application. An IoC container creates single instances of bean definitions per web application during runtime. Following are two ways to define the application scope:</p>
<pre class="calibre17">// 1) XML way to configure define application scope<br class="title-page-name"/>&lt;bean id="..." class="com.packt.scope.applicationBeanTest" scope="application" /&gt;<br class="title-page-name"/><br class="title-page-name"/>// 2) Java config using annotation <br class="title-page-name"/>@Component<br class="title-page-name"/>@Scope("application")<br class="title-page-name"/>public class applicationBeanTest {<br class="title-page-name"/>}<br class="title-page-name"/> <br class="title-page-name"/>//or<br class="title-page-name"/> <br class="title-page-name"/>@Component<br class="title-page-name"/>@ApplicationScope<br class="title-page-name"/>public class applicationBeanTest {<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">This is the same as the Singleton scope, but the main difference is that a Singleton scope bean is worked as a Singleton per</span> <kbd class="calibre12">ApplicationContext</kbd><span class="calibre11">, whereas an application scope bean is worked as Singleton per</span> <kbd class="calibre12">ServletContext</kbd><span class="calibre11">. These beans are stored as attributes in </span><kbd class="calibre12">ServletContext</kbd><span class="calibre11">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Global session scope</h1>
                
            
            <article>
                
<p class="calibre2">A <strong class="calibre4">global session scope</strong> is similar to a session scope. The only difference is that it will be used in a Portlet application. Global sessions can be used when we have an application that is built on the JSR-168, JSR-286, and JSR-362 portal specifications. There will be multiple sites/applications that work under a single portlet container.</p>
<p class="calibre2">Portlet containers have different portlets, and all have their own portlet context, as well as portlet session. Portlet sessions work with the portlet boundary, but when we have to share common information between multiple sites, then we can define beans with a <kbd class="calibre12">globalSession</kbd> scope. Spring has separate portlet MVC modules for portal applications:</p>
<pre class="calibre17">// 1) XML way to configure define application scope<br class="title-page-name"/>&lt;bean id="..." class="com.packt.scope.globalBeanTest" scope="globalSession" /&gt;<br class="title-page-name"/><br class="title-page-name"/>// 2) Java config using annotation <br class="title-page-name"/>@Component<br class="title-page-name"/>@Scope("globalSession")<br class="title-page-name"/>public class globalBeanTest {<br class="title-page-name"/>}<br class="title-page-name"/> <br class="title-page-name"/>//or<br class="title-page-name"/> <br class="title-page-name"/>@Component<br class="title-page-name"/>@GlobalSessionScope<br class="title-page-name"/>public class globalBeanTest {<br class="title-page-name"/>}</pre>
<p class="calibre2">Consider an intranet application that consists of server sites. Users could be members of multiple sites. In such scenarios, user preferences with common information can be stored as global sessions for the logged-in user, and the same will be utilized between multiple sites and portlets. The following image shows how G<strong class="calibre4">lobal Sessions</strong> are shared between portlet containers:</p>
<div class="mce-root"><img src="../images/00036.jpeg" class="calibre53"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">websocket scope</h1>
                
            
            <article>
                
<p class="calibre2">This scope is used when two-way communication between a customer and remote site is enabled using the <strong class="calibre4">websocket</strong> protocol. It is mainly useful when applications are used by multiple users with <span class="calibre11">simultaneous</span> actions.</p>
<p class="calibre2">Here, an HTTP request is used to do an initial handshake, and once it is established, the TCP port remains open for a client and server for communication. The websocket bean is similar to a singleton, and injected into Spring controllers. The life of a websocket bean is longer compared to a typical websocket session. The following example shows how a websocket is declared using Scope annotation and traditional XML configuration:</p>
<pre class="calibre17">//Using @Scope annotation<br class="title-page-name"/>@Scope(scopeName = "websocket")<br class="title-page-name"/><br class="title-page-name"/>//Using XML configuration <br class="title-page-name"/>&lt;bean id="..." class="com.packt.scope.WebsocketExampleTest" scope="websocket" /&gt;<br class="title-page-name"/><br class="title-page-name"/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to define a bean scope</h1>
                
            
            <article>
                
<p class="calibre2">So, we understand the different scopes and their usage. Now it is time to see how we can use them in coding. We will mainly look at singleton and prototype bean scopes with examples. </p>
<p class="calibre2">Spring provides two different ways to write an application: one is traditional XML metadata configuration, and the second is Java configuration using annotations. Let's look at how XML configuration is used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">XML metadata configuration</h1>
                
            
            <article>
                
<p class="calibre2">In Spring, bean configuration is declared in an XML file of our choice. This file is used by an IoC container to initialize the application context, and at the same time, all bean definitions are initialized based on the provided attribute. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the singleton scope</h1>
                
            
            <article>
                
<p class="calibre2">The singleton scope is a very common scope used in major applications. Here, we will start to use the singleton scope. First, we will create a bean class named <kbd class="calibre12">EmailService</kbd>, which consists of a simple <kbd class="calibre12">getter/setter</kbd> method and <kbd class="calibre12">Constructor</kbd> method with a <kbd class="calibre12">print</kbd> statement:</p>
<pre class="calibre17">package com.packt.springbean;<br class="title-page-name"/><br class="title-page-name"/>public class EmailService {<br class="title-page-name"/>  <br class="title-page-name"/>  private String emailContent;<br class="title-page-name"/>  private String toAddress;<br class="title-page-name"/>  <br class="title-page-name"/>  public EmailService() {<br class="title-page-name"/>    System.out.print(" \n Object of EmailService is Created !!! ");<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public String getEmailContent() {<br class="title-page-name"/>    return emailContent;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void setEmailContent(String emailContent) {<br class="title-page-name"/>    this.emailContent = emailContent;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public String getToAddress() {<br class="title-page-name"/>    return toAddress;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void setToAddress(String toAddress) {<br class="title-page-name"/>    this.toAddress = toAddress;<br class="title-page-name"/>  }<br class="title-page-name"/>   <br class="title-page-name"/>}</pre>
<p class="calibre2">Every Spring application requires a context file that describes the configuration of the beans. <span class="calibre11">Configuration of the previously mentioned bean class can be written as follows in </span><kbd class="calibre12">application-context.xml</kbd>:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>  <br class="title-page-name"/>  xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>  &lt;bean id="emailService" class="com.packt.springbean.EmailService"<br class="title-page-name"/>    scope="singleton" /&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">Here, in the bean definition, we have mentioned <kbd class="calibre12">emailService</kbd> as an ID attribute, and a class name provided as <kbd class="calibre12">com.packt.springbean.EmailService</kbd> to point our bean class to the package path. For learning purposes, we have used a <kbd class="calibre12">scope</kbd> attribute with a <kbd class="calibre12">singleton</kbd> value.</p>
<p class="calibre2">If the <kbd class="calibre12">scope</kbd> attribute is not defined in the bean definition, then by default, a Spring IoC container creates an instance of the bean with a singleton scope. Now, let's check what will happen if we try to access the <kbd class="calibre12">EmailService</kbd> bean two times. For that, let's use the <kbd class="calibre12">SpringBeanApplication.java</kbd> class:</p>
<pre class="calibre17"><span>//SpringBeanApplication.java</span><br class="title-page-name"/><br class="title-page-name"/>package com.packt.springbean;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.context.ApplicationContext;<br class="title-page-name"/>import org.springframework.context.support.ClassPathXmlApplicationContext;<br class="title-page-name"/><br class="title-page-name"/>public class SpringBeanApplication {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    <br class="title-page-name"/>    ApplicationContext context = new ClassPathXmlApplicationContext(new String[] { "application-context.xml" });<br class="title-page-name"/>    <br class="title-page-name"/>    // Retrieve emailService bean first time.<br class="title-page-name"/>    EmailService emailServiceInstanceA = (EmailService) context.getBean("emailService");<br class="title-page-name"/>    emailServiceInstanceA.setEmailContent("Hello, How are you?");<br class="title-page-name"/>    emailServiceInstanceA.setToAddress("krunalpatel1410@yahoo.com");<br class="title-page-name"/>    <br class="title-page-name"/>    System.out.println("\n Email Content : " + emailServiceInstanceA.getEmailContent() + " sent to "+ emailServiceInstanceA.getToAddress() );<br class="title-page-name"/><br class="title-page-name"/>    // Retrieve emailService bean second time. <br class="title-page-name"/>    EmailService emailServiceInstanceB = (EmailService) context.getBean("emailService");<br class="title-page-name"/>    System.out.println("\n Email Content : " + emailServiceInstanceB.getEmailContent() + " sent to "+ emailServiceInstanceB.getToAddress() );<br class="title-page-name"/><br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In a standalone application, the Spring context is acquired using <kbd class="calibre12">ClassPathXMLApplicationContext</kbd> by passing a context file as a parameter in a String array. A Spring IoC container initializes the application context, and returns an object of it.</p>
<p class="calibre2">A bean is retrieved by passing a bean <kbd class="calibre12">name</kbd> in the form of an argument in the <kbd class="calibre12">getBean()</kbd> method. In the preceding example, we get two instances of the <kbd class="calibre12">EmailService</kbd> bean using the <kbd class="calibre12">getBean()</kbd> method. But, the first time we are only setting the value into a bean and we are getting the <span class="calibre11">same </span>by writing <kbd class="calibre12">printing message</kbd>. Even a constructor creates an object of bean only once.</p>
<p class="calibre2">So, when we run <kbd class="calibre12">SpringBeanApplication</kbd>, the output would be as follows:</p>
<pre class="calibre17">Feb 09, 2018 6:45:15 AM org.springframework.context.support.AbstractApplicationContext prepareRefresh<br class="title-page-name"/>INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@6fc6f14e: startup date [Fri Feb 09 06:45:15 IST 2018]; root of context hierarchy<br class="title-page-name"/>Feb 09, 2018 6:45:15 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br class="title-page-name"/>INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/> <br class="title-page-name"/> Object of EmailService is Created !!! <br class="title-page-name"/> Email Content : Hello, How are you? sent to krunalpatel1410@yahoo.com<br class="title-page-name"/><br class="title-page-name"/> Email Content : Hello, How are you? sent to krunalpatel1410@yahoo.com</pre>
<p class="calibre2"><span class="calibre11">Since the </span><kbd class="calibre12">EmailService</kbd><span class="calibre11"> bean has the Singleton scope, the second instance of <kbd class="calibre12">emailServiceInstanceB</kbd> prints the message with a value set by <kbd class="calibre12">emailServiceInstanceA</kbd> as well, even though it is <kbd class="calibre12">get</kbd> by a new <kbd class="calibre12">getBean()</kbd> method. The Spring IoC container creates and maintains only a single instance of a bean per container; </span><span class="calibre11">no matter how many times you reclaim it with <kbd class="calibre12">getBean()</kbd>, it will continuously return the same instance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the prototype scope</h1>
                
            
            <article>
                
<p class="calibre2">As we have seen, the <strong class="calibre4">prototype scope</strong> is used to get a new instance of a bean every time when requested. To understand prototype, we will take the same bean class, <kbd class="calibre12">EmailService</kbd>, and we just need to change the value of the scope attribute for the <kbd class="calibre12">emailService</kbd> bean in <kbd class="calibre12">application-context.xml</kbd>: </p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>  <br class="title-page-name"/>  xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>  &lt;bean id="emailService" class="com.packt.springbean.EmailService"<br class="title-page-name"/>    scope="prototype" /&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">The code used for the singleton scope will the same as before, while the output of the preceding code will be as follows:</p>
<pre class="calibre17">Feb 09, 2018 7:03:20 AM org.springframework.context.support.AbstractApplicationContext prepareRefresh<br class="title-page-name"/>INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@6fc6f14e: startup date [Fri Feb 09 07:03:20 IST 2018]; root of context hierarchy<br class="title-page-name"/>Feb 09, 2018 7:03:20 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br class="title-page-name"/>INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/> <br class="title-page-name"/> Object of EmailService is Created !!! <br class="title-page-name"/> Email Content : Hello, How are you? sent to krunalpatel1410@yahoo.com<br class="title-page-name"/> <br class="title-page-name"/> Object of EmailService is Created !!! <br class="title-page-name"/> Email Content : null sent to null</pre>
<p class="calibre2">From output, the <kbd class="calibre12">EmailService</kbd> constructor is called two times, and gets a new instance for each <kbd class="calibre12">getBean()</kbd> method called. For the second instance, <kbd class="calibre12">emailServiceInstanceB</kbd>, we get a <kbd class="calibre12">null</kbd> value, because we haven't set any value for that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java configuration using annotations</h1>
                
            
            <article>
                
<p class="calibre2">Once annotation was introduced in <kbd class="calibre12">Java 1.5</kbd>, Spring Framework also added support for annotations in version 2.5.</p>
<p class="calibre2"><span class="calibre11">Spring provides several standard</span><span class="calibre11"> </span><span class="calibre11">annotations, which are used on stereotype classes in the application. By using such a</span>nnotations, we don't need to maintain bean definitions in XML files. We just need to write one line, <span class="calibre11"><kbd class="calibre12">&lt;context:component-scan&gt;</kbd>, in the Spring XML configuration </span>for a scanning component, and the Spring IoC container scans the defined package to register all the annotated classes and their bean definitions in the application context.</p>
<p class="calibre2">Specifically,<span class="calibre11"> <kbd class="calibre12">@Component</kbd> and <kbd class="calibre12">@Service</kbd> are used to scan beans in the provided package. Here, we will use <kbd class="calibre12">@Service</kbd> annotation, because the <kbd class="calibre12">@Service</kbd> annotation is too specialized for the <kbd class="calibre12">@Component</kbd> annotation. It doesn’t give us any extra behavior than the <kbd class="calibre12">@Component</kbd> explanation, but it’s better to choose <kbd class="calibre12">@Service</kbd> over <kbd class="calibre12">@Component</kbd> in service-layer classes, since it indicates expectations way better.</span></p>
<p class="calibre2">For singleton and prototype beans, our <kbd class="calibre12">application-context.xml</kbd> file will be the same, and looks as follows:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/>        http://www.springframework.org/schema/context<br class="title-page-name"/>        http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>  &lt;!-- &lt;context:annotation-config /&gt; --&gt;<br class="title-page-name"/>  &lt;context:component-scan base-package="com.packt.springbeanannotation" /&gt;<br class="title-page-name"/>      <br class="title-page-name"/>&lt;/beans&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton scope with annotation</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">@Scopes</kbd> annotation is used to i<span class="calibre11">ndicate</span><span class="calibre11"> the scope of a bean, either singleton, </span><span class="calibre11">prototype</span><span class="calibre11">, </span><span class="calibre11">request</span><span class="calibre11">, session, or </span><span class="calibre11">a few</span><span class="calibre11"> custom scopes.</span></p>
<p class="calibre2"><span class="calibre11">To make the <kbd class="calibre12">EmailService</kbd> bean class a singleton, we need to annotate the class with <kbd class="calibre12">@Scope</kbd> and <kbd class="calibre12">@Service</kbd>. </span>So, our <kbd class="calibre12">EmailService</kbd> class will look as follows: </p>
<pre class="calibre17">package com.packt.springbeanannotation;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.context.annotation.Scope;<br class="title-page-name"/>import org.springframework.stereotype.Service;<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>@Scope("singleton")<br class="title-page-name"/>public class EmailService {<br class="title-page-name"/>  <br class="title-page-name"/>  private String emailContent;<br class="title-page-name"/>  private String toAddress;<br class="title-page-name"/>  <br class="title-page-name"/>  public EmailService() {<br class="title-page-name"/>    System.out.print(" \n Object of EmailService is Created !!! ");<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public String getEmailContent() {<br class="title-page-name"/>    return emailContent;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void setEmailContent(String emailContent) {<br class="title-page-name"/>    this.emailContent = emailContent;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public String getToAddress() {<br class="title-page-name"/>    return toAddress;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void setToAddress(String toAddress) {<br class="title-page-name"/>    this.toAddress = toAddress;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>}</pre>
<p class="calibre2">We will use the same <kbd class="calibre12">SpringBeanApplication.java</kbd> class to test our annotation changes, and the output will also be the same as the XML configuration example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prototype scope with annotation</h1>
                
            
            <article>
                
<p class="calibre2">To use prototype scope with annotations, we only need to mention <kbd class="calibre12">prototype</kbd> in the <kbd class="calibre12">@Scope</kbd> annotation instead of <kbd class="calibre12">singleton</kbd>. So, our <kbd class="calibre12">EmailService.java</kbd> class will be the same, except we change the annotation value, and it will look as follows:</p>
<pre class="calibre17">@Service<br class="title-page-name"/>@Scope("prototype")<br class="title-page-name"/>public class EmailService {<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre2">As like the XML example output, this will also create a new instance each time it is called. In a similar way, we can use other scopes, such as request, session, application, and global session, using XML metadata or annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection and the bean scope</h1>
                
            
            <article>
                
<p class="calibre2">We understand each scope has a different boundary. Now, we will write one REST controller to understand how different scope beans are injected to other reference beans by writing simple Spring boot applications. </p>
<p class="calibre2">In the following diagram, the <strong class="calibre4">StudentController</strong> has injected the reference to all other classes. The <kbd class="calibre12">ClassDetail</kbd> class with the <kbd class="calibre12">session</kbd> scope has two references to singleton and prototype, and the student application contains a few other associations between classes as well. <strong class="calibre4">Autowired</strong> annotation is utilized to fulfill dependency between beans. Just to clarify, Spring controllers are always created with the singleton scope:</p>
<div class="mce-root"><img src="../images/00037.jpeg" class="calibre54"/></div>
<p class="calibre2">As we are writing a Spring boot application with REST. Will will have to create a maven project and the configuration of <kbd class="calibre12">pom.xml</kbd> file would be:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;project  <br class="title-page-name"/>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br class="title-page-name"/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;groupId&gt;com.packt.java9.beanscope&lt;/groupId&gt;<br class="title-page-name"/>    &lt;artifactId&gt;spring-beanscope-test&lt;/artifactId&gt;<br class="title-page-name"/>    &lt;version&gt;0.1.0&lt;/version&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;parent&gt;<br class="title-page-name"/>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br class="title-page-name"/>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br class="title-page-name"/>        &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;<br class="title-page-name"/>    &lt;/parent&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;dependencies&gt;<br class="title-page-name"/>        &lt;dependency&gt;<br class="title-page-name"/>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br class="title-page-name"/>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br class="title-page-name"/>        &lt;/dependency&gt;<br class="title-page-name"/>    &lt;/dependencies&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;properties&gt;<br class="title-page-name"/>        &lt;java.version&gt;9&lt;/java.version&gt;<br class="title-page-name"/>    &lt;/properties&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;build&gt;<br class="title-page-name"/>        &lt;plugins&gt;<br class="title-page-name"/>            &lt;plugin&gt;<br class="title-page-name"/>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br class="title-page-name"/>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br class="title-page-name"/>            &lt;/plugin&gt;<br class="title-page-name"/>        &lt;/plugins&gt;<br class="title-page-name"/>    &lt;/build&gt;<br class="title-page-name"/><br class="title-page-name"/>&lt;/project&gt;</pre>
<p class="calibre2">We start with the <kbd class="calibre12">StudentController</kbd> class, injected with four beans that have different scopes defined:</p>
<pre class="calibre17">package com.packt.java9.beanscope.controller;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.beans.factory.annotation.Autowired;<br class="title-page-name"/>import org.springframework.web.bind.annotation.RequestMapping;<br class="title-page-name"/>import org.springframework.web.bind.annotation.RestController;<br class="title-page-name"/><br class="title-page-name"/>import com.packt.java9.beanscope.beans.PrototypeBeanScope;<br class="title-page-name"/>import com.packt.java9.beanscope.beans.RequestBeanScope;<br class="title-page-name"/>import com.packt.java9.beanscope.beans.SessionBeanScope;<br class="title-page-name"/>import com.packt.java9.beanscope.beans.SingletonBeanScope;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>@RestController<br class="title-page-name"/>public class StudentController {<br class="title-page-name"/><br class="title-page-name"/>  public StudentController() {<br class="title-page-name"/>    System.out.println(" ::::::::::::::::::::: StudentController Initialized :::::::::::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  PrototypeBeanScope prototypeBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  SessionBeanScope sessionBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  RequestBeanScope requestBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  SingletonBeanScope singletonBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  @RequestMapping("/")<br class="title-page-name"/>  public String index() {<br class="title-page-name"/>    sessionBeanScope.printClassDetail();<br class="title-page-name"/>    requestBeanScope.printAddress();<br class="title-page-name"/>    <br class="title-page-name"/>    return " Greetings from Student Department !!";<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">To understand each scope, I have created simple interfaces with scope names for better visualization, and this will also help when we add the dependency of one bean into another bean. <kbd class="calibre12">@Scope</kbd> annotation is utilized to mention the <kbd class="calibre12">StudentDetail</kbd> bean as a singleton and it is implementing the <kbd class="calibre12">SingletonBeanScope</kbd> interface. This class has been injected with a <kbd class="calibre12">PrototypeBeanScope</kbd> bean. <span class="calibre11">Moreover</span>, we are printing incremental values of the static integer <span class="calibre11">variable</span><kbd class="calibre12"> increment</kbd>  to track how many times the singleton bean is initialized in the constructor. The same is written for all other bean classes. <kbd class="calibre12">StudentDetail.java</kbd> will be as follows:</p>
<pre class="calibre17">package com.packt.java9.beanscope.beans;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.beans.factory.annotation.Autowired;<br class="title-page-name"/>import org.springframework.context.annotation.Scope;<br class="title-page-name"/>import org.springframework.stereotype.Service;<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>@Scope("singleton")<br class="title-page-name"/>public class StudentDetail implements SingletonBeanScope {<br class="title-page-name"/><br class="title-page-name"/>  /* Inject PrototypeBeanScope to observer prototype scope behaviour */<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  PrototypeBeanScope prototypeBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  private static int increment = 0;<br class="title-page-name"/><br class="title-page-name"/>  /**<br class="title-page-name"/>   * Every time this bean is initialized, created variable will be increases by<br class="title-page-name"/>   * one.<br class="title-page-name"/>   */<br class="title-page-name"/>  public StudentDetail() {<br class="title-page-name"/>    super();<br class="title-page-name"/>    System.out.println(" \n ::::::: Object of StudentDetail bean is created " + (++increment) + " times ::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre12">SubjectPreference.java</kbd> is defined with a prototype bean scope as follows:</p>
<pre class="calibre17">package com.packt.java9.beanscope.beans;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.context.annotation.Scope;<br class="title-page-name"/>import org.springframework.stereotype.Component;<br class="title-page-name"/><br class="title-page-name"/>@Component<br class="title-page-name"/>@Scope("prototype")<br class="title-page-name"/>public class SubjectPreference implements PrototypeBeanScope {<br class="title-page-name"/><br class="title-page-name"/>  private static int increment = 0;<br class="title-page-name"/><br class="title-page-name"/>  /**<br class="title-page-name"/>   * Every time this bean is initialized, created variable will be increases by<br class="title-page-name"/>   * one.<br class="title-page-name"/>   */<br class="title-page-name"/>  public SubjectPreference() {<br class="title-page-name"/>    System.out.println(" \n ::::::: Object of SubjectPreference with Prototype scope is created " + (++increment)<br class="title-page-name"/>        + " Times ::::::: \n ");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">The request scope and session scope are only worked in a web-aware application context. <kbd class="calibre12">Address.java</kbd> is annotated with the request scope:</p>
<pre class="calibre17">package com.packt.java9.beanscope.beans;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.beans.factory.annotation.Autowired;<br class="title-page-name"/>import org.springframework.context.annotation.Scope;<br class="title-page-name"/>import org.springframework.context.annotation.ScopedProxyMode;<br class="title-page-name"/>import org.springframework.stereotype.Component;<br class="title-page-name"/><br class="title-page-name"/>@Component<br class="title-page-name"/>@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)<br class="title-page-name"/>public class Address implements RequestBeanScope {<br class="title-page-name"/><br class="title-page-name"/>  private static int increment = 0;<br class="title-page-name"/><br class="title-page-name"/>  /* Inject PrototypeBeanScope to observer prototype scope behaviour */<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  PrototypeBeanScope prototypeBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  /**<br class="title-page-name"/>   * Every time this bean is initialized, created variable will be increases by<br class="title-page-name"/>   * one.<br class="title-page-name"/>   */<br class="title-page-name"/>  public Address() {<br class="title-page-name"/>    System.out.println(<br class="title-page-name"/>        " \n ::::::: Object of Address bean with Request scope created " + (++increment) + " Times ::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public void printAddress() {<br class="title-page-name"/>    System.out.println("\n :::::::::::::: RequestbeanScope :: printAddress() Called :::::::::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the same way, the <kbd class="calibre12">session</kbd> scope is used in the <kbd class="calibre12">ClassDetail.java</kbd> class:</p>
<pre class="calibre17">package com.packt.java9.beanscope.beans;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.beans.factory.annotation.Autowired;<br class="title-page-name"/>import org.springframework.context.annotation.Scope;<br class="title-page-name"/>import org.springframework.context.annotation.ScopedProxyMode;<br class="title-page-name"/>import org.springframework.stereotype.Repository;<br class="title-page-name"/><br class="title-page-name"/>@Repository<br class="title-page-name"/>@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)<br class="title-page-name"/>public class ClassDetail implements SessionBeanScope {<br class="title-page-name"/><br class="title-page-name"/>  /* Inject SingletonBeanScope to observer session scope behaviour */<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  SingletonBeanScope singletonBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  /* Inject PrototypeBeanScope to observer prototype scope behaviour */<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  PrototypeBeanScope prototypeBeanScope;<br class="title-page-name"/><br class="title-page-name"/>  private static int increment = 0;<br class="title-page-name"/><br class="title-page-name"/>  /**<br class="title-page-name"/>   * Every time this bean is initialized, created variable will be increases by<br class="title-page-name"/>   * one.<br class="title-page-name"/>   */<br class="title-page-name"/>  public ClassDetail() {<br class="title-page-name"/>    System.out.println(" \n ::::::: Object of ClassDetail bean with session scope created " + (++increment)<br class="title-page-name"/>        + " Times ::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public void printClassDetail() {<br class="title-page-name"/>    System.out.println("\n ::::::::: Session Bean - PrintMessage Method Called ::::::::::::::::::: ");<br class="title-page-name"/>    System.out.println("\n ::::::::: SessionBeanScope :: printClassDetail() Called ::::::::::::::: ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">An extra <kbd class="calibre12">proxyMode</kbd> attribute is <span class="calibre11">utilized</span> to <span class="calibre11">make</span> an <span class="calibre11">intermediary,</span> which will be injected as a dependency by Spring, and Spring <span class="calibre11">starts</span> the <kbd class="calibre12">target</kbd> bean when it's required. Note that there is no <span class="calibre11">dynamic</span> request when the web application <span class="calibre11">setting is</span> initialized.</span></p>
<p class="calibre2">On a successful run, we will see the following console log:</p>
<div class="mce-root"><img src="../images/00038.gif" class="calibre41"/></div>
<p class="calibre2">Following is the analysis of the output:</p>
<ul class="calibre9">
<li class="calibre10">The <kbd class="calibre12">StudentDetail</kbd> bean is created only once, which is, at most, a singleton class, and it loads during application startup.</li>
<li class="calibre10"><span>Subsequently, the <kbd class="calibre12">SubjectPreference</kbd> bean is created with the prototype scope. It is injected into the <kbd class="calibre12">StudentDetail</kbd> singleton bean and, because of that, it also initializes with it. Here, we all know that the prototype scope bean is created each time it is called. </span></li>
<li class="calibre10">Here, the <kbd class="calibre12">StudentDetail</kbd> singleton bean depends on <kbd class="calibre12">PrototypeBeanScope</kbd>, which is implemented by the <span><kbd class="calibre12">SubjectPreference</kbd> class, and </span><span>dependencies are resolved at </span><span><span>instantiation time. So, the first instance of <kbd class="calibre12">SubjectPreference</kbd> is created, and then it will be injected into the <kbd class="calibre12">StudentDetail</kbd> singleton bean. </span></span></li>
<li class="calibre10">The Spring container is initializing the <kbd class="calibre12">StudentController</kbd> class only one time because <kbd class="calibre12">controller</kbd> is, by default, a singleton.</li>
<li class="calibre10"><span>As <kbd class="calibre12">StudentController</kbd>  has injected a reference of the <kbd class="calibre12">PrototypeBeanScope</kbd>, once again an instance of the <kbd class="calibre12">SubjectPreference</kbd> bean is created. Controllers also have a reference of the <kbd class="calibre12">SingletonbeanScope</kbd> bean, but an instance of that is not created again, because it is already loaded.</span></li>
<li class="calibre10">An instance of <kbd class="calibre12">SessionScopeBean</kbd> and <kbd class="calibre12">RequestScopeBean</kbd> is not created, because there is no HTTP request or HTTP session at this instant.</li>
</ul>
<p class="calibre2">To check the <kbd class="calibre12">request</kbd> and <kbd class="calibre12">session</kbd> scope, go to <kbd class="calibre12">http://localhost:8080</kbd> in a browser and observe the console log:</p>
<div class="mce-root"><img src="../images/00039.gif" class="calibre41"/></div>
<p class="calibre2">The log shows that one instance each for the <kbd class="calibre12">ClassDetail</kbd> and <kbd class="calibre12">Address</kbd> classes are created because they define with the session and request scope respectively. Both the <kbd class="calibre12">ClassDetail</kbd> and <kbd class="calibre12">Address</kbd> classes also injected <kbd class="calibre12">PrototypeBeanScope</kbd>, and because of that, the <kbd class="calibre12">SubjectPreference</kbd> instance has been created two more times—a <span class="calibre11">total of four</span> times.</p>
<p class="calibre2">Enter <kbd class="calibre12">http://localhost:8080 URL again</kbd>:</p>
<div class="mce-root"><img src="../images/00040.gif" class="calibre41"/></div>
<p class="calibre2">It will create one more instance of the <kbd class="calibre12">Address</kbd> class, which is marked as a request scope, and a new instance of <kbd class="calibre12">SubjectPreference</kbd> class <span class="calibre11">with </span>prototype scope<span class="calibre11"> </span>will be created. It will not create an instance of the <kbd class="calibre12">ClassDetail</kbd> class because we have not created a new session, our session is still going.</p>
<p class="calibre2">To initiate a new session, we need to close the browser and go to the URL. Open another browser, and go to the URL:</p>
<div class="mce-root"><img src="../images/00041.gif" class="calibre41"/></div>
<p class="calibre2">By doing this, two new sessions will be created, and a total of three instances are created for the  <kbd class="calibre12">ClassDetail</kbd> class, along with two instances of the <kbd class="calibre12">Address</kbd> class, and two instances of the <kbd class="calibre12">SubjectPreference</kbd> class.</p>
<p class="calibre2">In the event that we need to inject a request scope bean into another bean of a longer-lived scope, you may select to inject an AOP proxy in the scoped bean. We require to injecting an intermediary object that exposes the same public interface as the scoped object. But that can recover the target object from the applicable scope and provide method calls onto the genuine object.</p>
<p class="calibre2"><span class="calibre11">Furthermore</span>, the bean is going through an intermediate proxy that is serializable. The same bean subsequently can re-obtain the <kbd class="calibre12">target</kbd> singleton bean by doing deserialization. <kbd class="calibre12"><span>&lt;aop:scoped-proxy/&gt;</span></kbd> is used by the beans that are marked as a singleton.</p>
<p class="calibre2">In the same way, when using the prototype bean scope, each method calls on the shared proxy will lead to the creation of a new target instance which the call is, at that point, being sent to.</p>
<div class="packt_infobox"><span class="calibre18">By default, a CGLIB-based <span class="calibre18">class</span> <span class="calibre18">proxy</span> is <span class="calibre18">made </span>when the Spring </span><span class="calibre18">holder</span><span class="calibre18"> </span><span class="calibre18">makes</span><span class="calibre18"> a </span><span class="calibre18">proxy</span><span class="calibre18"> for a bean that is </span><span class="calibre18">checked</span><span class="calibre18"> up with the <kbd class="calibre37">&lt;aop:scoped-proxy/&gt;</kbd></span> <span class="calibre18">component</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to choose a bean scope</h1>
                
            
            <article>
                
<p class="calibre2">Each scope in Spring has a different feature, and it falls to us as programmers to know how to utilize those scopes.</p>
<p class="calibre2">In an application, if we have a stateless object and there is no impact on the object creation process then the use of a scope is unnecessary. In contrast, if an object has state then it is advisable to use a scope such as singleton.</p>
<p class="calibre2">When dependency injection is in business, then the singleton scope is not adding much value. In spite of the fact that singletons spare object creation (and afterward garbage collection), <span class="calibre11">synchronization</span> <span class="calibre11">requires us to </span>initialize a singleton bean. Singletons are most valuable for:</p>
<ul class="calibre9">
<li class="calibre10">Configuration of stateful beans</li>
<li class="calibre10">Lookup of objects that are costly to build</li>
<li class="calibre10">A database association pool object that is associated with resources</li>
</ul>
<p class="calibre2">If we consider concurrency, classes defined with a singleton or session scope must be thread-safe, and anything injected in these classes should be thread-safe. On the other hand, the request scope cannot be thread-safe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scopes in Google Guice</h1>
                
            
            <article>
                
<p class="calibre2">Most of the scopes we have seen for the Spring Framework similarly exist in Google Guice. Scope defines that code should work in a specific context, and in Guice, the Injector manages the scope context. <strong class="calibre4">Default scope</strong> (No Scope), <strong class="calibre4">singleton</strong>, <strong class="calibre4">session</strong>, and <strong class="calibre4">request</strong> are the main <span class="calibre11">scopes in Guice</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Default scope</h1>
                
            
            <article>
                
<p class="calibre2">By default, Guice injects a new and separate instance of an object for each dependency (similar to the prototype scope in Spring), <span class="calibre11">whereas Spring provides singletons by default. </span></p>
<p class="calibre2">Let us consider an example of a house that has a family with three people, all with their own personal car. Every time they call the <kbd class="calibre12">injector.getInstance()</kbd> method, a new instance of a car object is available for each family member:</p>
<pre class="calibre17">home.give("Krunal", injector.getInstance(Car.class));<br class="title-page-name"/><br class="title-page-name"/>home.give("Jigna", injector.getInstance(Car.class));<br class="title-page-name"/><br class="title-page-name"/>home.give("Dirgh", injector.getInstance(Car.class));</pre>
<div class="mce-root"><img src="../images/00042.jpeg" class="calibre55"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton scope</h1>
                
            
            <article>
                
<p class="calibre2">If we want to create only one instance of the class, then the <kbd class="calibre12">@Singleton</kbd> annotation can be used to mark the implementation class. As long as a the singleton object lives, the injector lives in context, but in the same application, it is possible to have multiple injectors, and in that case, each injector is associated with a different instance of a singleton-scoped object:</p>
<pre class="calibre17">@Singleton<br class="title-page-name"/>public class DatabaseConnection{<br class="title-page-name"/><br class="title-page-name"/>    public void connectDatabase(){<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public void disconnectDatabase(){<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">Another way to configure a scope is by using a bind statement in the module:</p>
<pre class="calibre17">public class ApplicationModule extends AbstractModule{<br class="title-page-name"/><br class="title-page-name"/>  @Override<br class="title-page-name"/>  protected void configure() {<br class="title-page-name"/>    //bind service to implementation class<br class="title-page-name"/>    bind(NotificationService.class).to(SMSService.class).in(Singleton.class);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">When we use linked binding in a module, then the scope only applies to binding the source, not to the <kbd class="calibre12">target</kbd>. For example, we have a class <kbd class="calibre12">UserPref</kbd> that implements both <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Student</kbd> interfaces. This will create two instance of type: one for <kbd class="calibre12">Professor</kbd> and another one for <kbd class="calibre12">Student</kbd>:</p>
<pre class="calibre17"><span>bind(Professor.class).to(UserPref.class).in(Singleton.class);</span><br class="title-page-name"/><span>bind(</span><span>Student</span><span>.class).to(UserPref.class).in(Singleton.class);</span></pre>
<p class="calibre2">This is because the singleton scope applies at the binding type level, which is <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Student</kbd>, not at the target type, <kbd class="calibre12">UserPref</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Eager singletons</h1>
                
            
            <article>
                
<p class="calibre2">Guice provides special syntax for making an object that has the singleton scope, and is initialized to eager mode rather than lazy mode. Following is the syntax:</p>
<pre class="calibre17">bind(NotificationService.class).to(SMSService.class).asEagerSingleton();</pre>
<p class="calibre2">Eager singletons uncover initialization issues sooner, and guarantee end users get a reliable, smart encounter. Lazy singletons empower a quicker edit-compile-run development cycle. We can utilize the stage enum to indicate which procedure ought to be utilized.</p>
<p class="calibre2">The following table defines stage-wise use of syntax of the singleton and supported object initialize mode:</p>
<table class="calibre56">
<tbody class="calibre57">
<tr class="calibre58">
<td class="calibre59"><strong class="calibre1">Syntax</strong></td>
<td class="calibre59"><strong class="calibre1">PRODUCTION</strong></td>
<td class="calibre59"><strong class="calibre1">DEVELOPMENT</strong></td>
</tr>
<tr class="calibre58">
<td class="calibre59"><span>@Singleton</span></td>
<td class="calibre59"><span>eager*</span></td>
<td class="calibre59"><span>lazy</span></td>
</tr>
<tr class="calibre58">
<td class="calibre59"><span>.asEagerSingleton()</span></td>
<td class="calibre59"><span>eager</span></td>
<td class="calibre59"><span>eager</span></td>
</tr>
<tr class="calibre58">
<td class="calibre59"><span>.in(Singleton.class)</span></td>
<td class="calibre59"><span>eager</span></td>
<td class="calibre59"><span>lazy</span></td>
</tr>
<tr class="calibre58">
<td class="calibre59"><span>.in(Scopes.SINGLETON)</span></td>
<td class="calibre59"><span>eager</span></td>
<td class="calibre59"><span>lazy</span></td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Guice eagerly creates singleton instances o<span class="calibre11">nly for the modules that are defined as singleton</span>.</p>
<p class="calibre2"><span class="calibre11"><kbd class="calibre12">@SessionScoped</kbd>  and <kbd class="calibre12">@RequestedScoped</kbd> </span>scope functionality and behavior is the same as Spring in Guice, and it will only be applicable when used in a web application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We started the chapter with a Spring bean definition attribute, which is important to learn as the whole IoC container is a relay on bean initialization. After that we learned the classification of scope with syntax. </p>
<p class="calibre2">On our journey, we learned how scope is configured using XML metadata and Java configuration in Spring. Without dependency injection, we cannot complete the chapter. That's why, by writing a <strong class="calibre4">Spring Boot</strong> application, we try to understand how the main scopes work in standalone as well as in web applications.</p>
<p class="calibre2">We intentionally skipped the scope topic in <a href="part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 4</a>, <em class="calibre13">Dependency Injection with Google Guice</em>. So, we have covered the Google Guice scope in this chapter with basic scopes. Spring and Google Guice have almost the same scope, but the default behavior of object initialization is different. Spring creates instances with the singleton, whereas Guice creates with the prototype scope. </p>
<p class="calibre2">In the next chapter, we will look at an important feature called <strong class="calibre4">aspect-oriented programming</strong> in Spring.</p>


            </article>

            
        </section>
    </body></html>