<html><head></head><body>
		<div id="_idContainer034">
			<h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor076"/>4</h1>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor077"/>Design Patterns for Data Management in Cloud-Native Applications</h1>
			<p>Regardless of whether the principles of monolithic or microservices architecture are chosen, we should certainly expect to enhance each service’s quality by incorporating yet another software design pattern – the <strong class="bold">layered architecture</strong> software design pattern. Recently, the term cloud-native has become quite popular and much discussed, describing a set of best practices for optimizing an application in the cloud through the use of containers, orchestration, <span class="No-Break">and automation.</span></p>
			<p>This approach recommends service design and organization in distinct layers, each owning specific responsibilities and well-defined interfaces. The potential guarantee of better abstraction and isolation characteristics is the payoff for the required extra source code and its aggregated code <span class="No-Break">design complexity.</span></p>
			<p>In exploring the reasons why a layered architecture pattern is crucial to healthy applications, particularly concerning persistence integration and data manipulation, this chapter will prepare and guide you throughout a service’s design transformation journey. You’ll start off by getting familiar with a set of key application-layer design strategies, which will technically explain and demonstrate how an unstructured application, without any level of abstraction, can be transformed into an elegantly designed service, composed of an appropriate set of layers able to provide decent separation and segregation between the persistence implementation technicalities and <span class="No-Break">business context.</span></p>
			<p>Throughout a comparative analysis of each layer design strategy, we will discuss the gains and losses of mistakenly bringing the core ideals to an extreme. On top of the aforementioned solid background, you’ll learn through detailed code samples the <em class="italic">reason</em> for each layer’s existence and be able to determine <em class="italic">when</em> the circumstances present you with an excellent opportunity to <span class="No-Break">use them.</span></p>
			<p>The quality of persistence solutions is right at the core of this chapter’s motivation. As previous chapters focused on the broader solution’s architecture, integration, and deployment models, we should take a closer look into implementing individual services. We need to take into consideration the powerful outcomes of combining data-related patterns with other popular practices such as <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>). And finally, but no less importantly, we <em class="italic">must </em>discuss a framework’s quality; after all, most Java solutions strongly depend on frameworks. We must, and in this chapter will, shed light on actual framework implementation strategies, to the point of evaluating the impacts of certain frameworks’ characteristics such as being built as a reflection or <span class="No-Break">reflectionless technology.</span></p>
			<p>The content is broken down and discussed throughout the <span class="No-Break">following sections:</span></p>
			<ul>
				<li>Design patterns applied to the Java <span class="No-Break">persistence layer</span></li>
				<li>Navigating the Java mapping landscape – evaluating <span class="No-Break">framework trade-offs</span></li>
				<li>Data transfer between the view and <span class="No-Break">underlying layers</span></li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li>A <span class="No-Break">Git client</span></li>
				<li>A <span class="No-Break">GitHub account</span></li>
			</ul>
			<p>The code samples demonstrated are available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor079"/>Design patterns applied to the Java persistence layer</h1>
			<p>We, as software engineers, often discuss and adopt layered architectural solutions, but why? Why should we consider using this code style? What are its surrounding trade-offs? In order to provide a better understanding of code design patterns, we’ll illustrate a scenario around accomplishing a simple mission: storing and retrieving data from a database – more specifically, a library system that manages books and their respective data. At first glance, our task looks quite straightforward, right? Let’s <span class="No-Break">get started.</span></p>
			<p>First, we see the need to create an entity, a <strong class="source-inline">Book</strong> class, which we can use to handle the library’s domain – our business domain. The first characteristic we can assume is that our <strong class="source-inline">Book</strong> entity should be <strong class="bold">immutable</strong>. In this domain, the <strong class="source-inline">Book</strong> entity attributes should be <strong class="source-inline">title</strong>, <strong class="source-inline">author</strong>, <strong class="source-inline">publisher</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">genre</strong></span><span class="No-Break">.</span></p>
			<p>The following code sample represents the described <strong class="source-inline">Book</strong> class. Notice all fields are set as <strong class="source-inline">final</strong> to implement the immutability assumption. To enable developers to create instances of this class, the <strong class="source-inline">Book</strong> class brings a <strong class="source-inline">constructor</strong> method and a <strong class="source-inline">builder</strong> class (<em class="italic">removed </em><span class="No-Break"><em class="italic">for brevity</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public class Book {    private final String title;
    private final String author;
    private final String publisher;
    private final String genre;
    // constructor method
    // builder inner class
}</pre>
			<p>The first entity, <strong class="source-inline">Book</strong>, is implemented as an <span class="No-Break">immutable class.</span></p>
			<p>The instance variables are set as <strong class="source-inline">final</strong>. Therefore, it is not possible to change the value of them after the object is initialized. Notice as well that there are no setter methods. If you are interested in the detailed implementation of the inner class, refer to the <strong class="source-inline">Book</strong> class (<a href="https://github.com/architects4j/mastering-java-persistence-book-samples/blob/e594bb17eab3dc97665b495b4245312bfd0f421b/chapter-04/src/main/java/dev/a4j/mastering/data/Book.java#L14-L66"><span class="No-Break">https://github.com/architects4j/mastering-java-persistence-book-samples/blob/e594bb17eab3dc97665b495b4245312bfd0f421b/chapter-04/src/main/java/dev/a4j/mastering/data/Book.java#L14-L66</span></a><span class="No-Break">) implementation.</span></p>
			<p>To simulate the serialization from and to the database, we’ll use the <strong class="source-inline">db</strong> in-memory object of type <strong class="source-inline">Map</strong> of <strong class="source-inline">Map</strong>: <strong class="source-inline">Map&lt;String, Map&lt;String, </strong><span class="No-Break"><strong class="source-inline">Object&gt;&gt; db</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.util.HashMap;import java.util.Map;
import java.util.Objects;
import java.util.Optional;
public enum Database {
    INSTANCE;
    private Map&lt;String, Map&lt;String, Object&gt;&gt; db = new
      HashMap&lt;&gt;();
    public Optional&lt;Map&lt;String, Object&gt;&gt; findById(String id) {
        Objects.requireNonNull(id, "id is required");
        return Optional.ofNullable(db.get(id));
    }
    public Map&lt;String, Object&gt; insert(String id,
      Map&lt;String, Object&gt; entry) {
        Objects.requireNonNull(id, "id is required");
        Objects.requireNonNull(entry, "entry is required");
        db.put(id, entry);
        return entry;
    }
    public void delete(String id) {
        Objects.requireNonNull(id, "id is required");
        db.remove(id);
    }
    public Map&lt;String, Object&gt; update(String id,
      Map&lt;String, Object&gt; entry) {
        Objects.requireNonNull(id, "id is required");
        Objects.requireNonNull(entry, "entry is required");
        if (findById(id).isEmpty()) {
            throw new IllegalArgumentException("The
              database cannot be updated");
        }
        return entry;
    }
}</pre>
			<p>The memory database is not fancy and does not cover any concurrency cases, but it is simple to put more focus on <span class="No-Break">the layers.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The core example’s goal is to assess a database layer, such as JDBC, so we won’t cover race conditions and other <span class="No-Break"><em class="italic">real-life</em></span><span class="No-Break"> challenges.</span></p>
			<p>To keep our focus on entity mapping and code design, our simulated in-memory <em class="italic">database</em> exclusively addresses the four <strong class="bold">create, read, update, and delete</strong> (<span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">) operations.</span></p>
			<p>Moving forward with the implementation, the next action would be to implement every CRUD database operation. Remember that at our scenario’s starting point, we currently <em class="italic">live a life with no layers</em>; therefore, all our methods should reside in the <span class="No-Break">same class.</span></p>
			<p>Next, we will take a look at the unstructured approach we’ve mentioned, followed by how it compares to the same solution implemented using the <strong class="bold">data mapper</strong>, <strong class="bold">data access object</strong> (<strong class="bold">DAO</strong>), <strong class="bold">repository</strong>, and <strong class="bold">active </strong><span class="No-Break"><strong class="bold">record</strong></span><span class="No-Break"> patterns.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor080"/>Unstructured code</h2>
			<p>Our scenario’s journey started off with the design of an application with a single layer. This layer is the one the application will rely on for its book data manipulation using operations for inserting a book, converting the underlying representation of a book as a database model from/into a Java domain object, and enabling the querying of a book instance. Well, there <em class="italic">is</em> good news: we have all we need in a centralized place/file. There should be no surprises or pain when, eventually, there’s a maintenance request that requires locating and modifying a database model’s field or updating the logic of the entity’s method – they reside in the <span class="No-Break">same place.</span></p>
			<p>As this application’s capabilities grow and the class gets lengthier, it becomes harder and harder to spot which code is doing what. As we repeatedly noticed happening in real-world applications, unfortunately, such complication eventually and <em class="italic">most certainly</em> ends up in unnecessary code duplication. This is especially the case for applications with numerous <span class="No-Break">entity classes.</span></p>
			<p>Going back to the code, what follows is a code implementation that instances a new book, and uses our homemade database client to manipulate the <span class="No-Break">book data:</span></p>
			<ol>
				<li><strong class="source-inline">Book</strong>, Java’s domain object, is instanced using CDI mechanisms and its <span class="No-Break">constructor method.</span></li>
				<li>The object’s attributes are mapped to their respective database <span class="No-Break">model attributes.</span></li>
				<li>The <strong class="source-inline">database</strong> client instance, using CDI, is created <span class="No-Break">or retrieved.</span></li>
				<li>The book is saved using the <strong class="source-inline">database</strong> client’s API; the persisted information is composed of the actual Java’s model attribute reference plus the manually set database <span class="No-Break">representation, </span><span class="No-Break"><strong class="source-inline">entry</strong></span><span class="No-Break">.</span></li>
				<li>A book’s information is retrieved from the database by its ID – <strong class="source-inline">title</strong> – and stored in the database model representation of type <strong class="source-inline">Map</strong> – <em class="italic">not the class </em><span class="No-Break"><em class="italic">type</em></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">Book</strong></span><span class="No-Break">.</span></li>
				<li>Using a builder, a <strong class="source-inline">Book</strong> object instance is created from the <span class="No-Break">retrieved data:</span></li>
			</ol>
			<pre class="source-code">
Book book = BookSupplier.INSTANCE.get(); // <strong class="bold">1</strong>// – - <strong class="bold">2</strong> – -
Map&lt;String, Object&gt; entry = new HashMap&lt;&gt;();
entry.put("title", book.getTitle());
entry.put("author", book.getAuthor());
entry.put("publisher", book.getPublisher());
entry.put("genre", book.getGenre());
// - - - -
Database database = Database.INSTANCE; // <strong class="bold">3</strong>
database.insert(book.getTitle(), entry); //<strong class="bold">4</strong>
Map&lt;String, Object&gt; map = database.findById(book.getTitle())
                .orElseThrow(); // <strong class="bold">5</strong>
Book entity = Book.builder()
        .title((String) map.get("title"))
        .author((String) map.get("author"))
        .publisher((String) map.get("publisher"))
        .genre((String) map.get("genre"))
        .build(); // <strong class="bold">6</strong>
System.out.println("the entity result: " + entity);</pre>
			<p>Some might get the impression that this code is simple to handle. However, it is also easy to predict the upcoming impact on long-term support. More code makes maintenance more error-prone, and the result is an application that now represents <em class="italic">risk</em> to the proper functioning of the <em class="italic">organization</em> and <em class="italic">business</em>, not to mention the multiple <span class="No-Break">technical implications.</span></p>
			<p>As software developers, we have likely all encountered (or even designed ourselves) systems that have become increasingly difficult to maintain and modify due to poor design choices. Robert Martin (a.k.a. Uncle Bob), in one of his presentations, named the four signs of a “rotting design” in software: rigidity, fragility, immobility, and viscosity. These four signs are explained <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Rigidity</strong>: The tendency for software <span class="No-Break">to change</span></li>
				<li><strong class="bold">Fragility</strong>: The trend of software breaking in many places every time it <span class="No-Break">is changed</span></li>
				<li><strong class="bold">Immobility</strong>: The inability to reuse software from <span class="No-Break">other projects</span></li>
				<li><strong class="bold">Viscosity</strong>: The API making the code harder to hack when we need to <span class="No-Break">change it</span></li>
			</ul>
			<p>Remember we mentioned that duplicates could likely show up in our previous library example? The reason for this is that it’s harder to change the code than it is to duplicate it. Predictable results are a breach of the <strong class="bold">single responsibility</strong> principle (of the <strong class="bold">SOLID</strong> design principles) and a complex testing scenario. After all, how can you stick to the test practices of a test pyramid (see <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">)?</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 4.1 – Test pyramid" src="image/Figure_4.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Test pyramid</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We can draft a comparison line between the code design under discussion and the unstructured monolith (see <em class="italic">Building Evolutionary Architecture</em>); both have a tendency toward increased complexity and hard-to-move architecture – just like a “big ball <span class="No-Break">of mud”.</span></p>
			<p>When it comes to persistence, there are a couple more things to consider that we want <span class="No-Break">to highlight:</span></p>
			<ul>
				<li>The design you choose will impact how much effort will be required when changing between database paradigms. For instance, changing a persistence provider (such as switching from SQL to NoSQL) can be a <span class="No-Break">tough task.</span></li>
				<li>If you seek to adopt the good practices of the pyramid testing method, having a high coupling between layers makes it hard to accurately write a proper amount of unit tests if compared to integration tests. Have in mind that using a script or a small tool for persistence can be worthwhile in the short term; the problem is that it can also turn into a nightmare in the <span class="No-Break">long run.</span></li>
				<li>Using more layers can be advantageous. For example, you will be able to abstract away the business logic from the technology specificities. Other than the common <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) basic layers, you can also consider adding an additional layer of abstraction between the model and the database, particularly when working with a <span class="No-Break">three-tier architecture.</span></li>
			</ul>
			<p>Unlike the MVC, which has three distinct layers, in an unstructured code design, the client has direct access to the database. It’s not about whether this is a good or bad solution, but rather about highlighting the trade-offs. This approach may be useful when creating a simple/fast migration script or any other piece of code that won’t be around for long or isn’t expected to grow. The following diagram illustrates <span class="No-Break">this design:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 4.2 – Clien﻿t-database integration in unstructured code design" src="image/Figure_4.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Client-database integration in unstructured code design</p>
			<p>As previously mentioned, this model is simple, but as the solution grows in size, we may encounter duplicate code including boilerplate code for converting between the database and the business entity. To address these issues, we will create a first layer to centralize the mapping translation in one place and establish boundaries between the client and <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor081"/>The data mapper pattern</h2>
			<p>The next step is to create the first layer between the client application and the database. This layer is a great opportunity to reduce the boilerplate and thus minimize bugs – less code, fewer bugs. In the previous example application, you may have noticed that the whole operation of mapping domains and manipulating data is part of a single block, which can make it difficult to read, maintain, <span class="No-Break">and test.</span></p>
			<p>In the book <em class="italic">Just Enough Software Architecture: A Risk-Driven Approach</em>, we learn about the importance of considering these threats to competent design and using three weapons to combat complexity and risk: partition, knowledge, <span class="No-Break">and </span><span class="No-Break"><em class="italic">abstraction</em></span><span class="No-Break">.</span></p>
			<p>In this case, we’ll use abstraction to hide the technical details and concentrate them in a single place. Here’s how we can do that: let’s introduce our <em class="italic">treacherous</em> layer. While a layer can help isolate and abstract a functionality, it also adds more code. This is <span class="No-Break">our trade-off.</span></p>
			<p>The conversion between the database and the Java domain models should also happen, and with more entities, it’s going to be even more recurring. In this first step, let’s abstract this conversion process in an abstraction layer using the data <span class="No-Break">mapper pattern.</span></p>
			<p>The <strong class="source-inline">BookMapper</strong> class will centralize the conversion behavior in a single place: the layer. From now on, if there is a bug in the conversion, this is the class to check out for any changes in either entity- or <span class="No-Break">database-related code:</span></p>
			<pre class="source-code">
class BookMapper {    private Database database = Database.INSTANCE;
    public Optional&lt;Book&gt; findById(String id) {
        Objects.requireNonNull(id, "id is required");
        return database.findById(id)
                .map(entity());
    }
    private Function&lt;Map&lt;String, Object&gt;, Book&gt; entity() {
        return (map) -&gt;
            Book.builder()
                    .title((String) map.get("title"))
                    .author((String) map.get("author"))
                    .publisher((String)
                      map.get("publisher"))
                    .genre((String) map.get("genre"))
                    .build();
    }
    private Function&lt;Book, Map&lt;String, Object&gt;&gt; database() {
        return (book) -&gt; {
            Map&lt;String, Object&gt; entry = new HashMap&lt;&gt;();
            entry.put("title", book.getTitle());
            entry.put("author", book.getAuthor());
            entry.put("publisher", book.getPublisher());
            entry.put("genre", book.getGenre());
            return entry;
        };
    }
}</pre>
			<p>As we can observe in the preceding code, <strong class="source-inline">BookMapper</strong> centralizes the mapping operations of a database model and the application entity model. There are several effective frameworks on the market that can do this type of mapping task, such as the popular option <strong class="bold">Hibernate</strong>. These types of frameworks rely on annotations to reduce boilerplate code. Instead of relying on annotations, our mapper class, <strong class="source-inline">BookMapper</strong>, has a more direct approach: it uses Java functions to encapsulate and execute <span class="No-Break">these conversions.</span></p>
			<p class="callout-heading">Info – Java functions</p>
			<p class="callout">Java functions are a way to encapsulate a piece of code that can be reused throughout your application. They are defined with the <strong class="source-inline">public static</strong> keyword, followed by the return type, the function name, and a list of parameters within parentheses. Functions can make your code more organized and easier to read, as well as saving time by eliminating the need to write the same code <span class="No-Break">multiple times.</span></p>
			<p>Take a look at how we can use the <span class="No-Break"><strong class="source-inline">BookMapper</strong></span><span class="No-Break"> operations:</span></p>
			<pre class="source-code">
Book book = BookSupplier.INSTANCE.get();BookMapper mapper = new BookMapper();
mapper.insert(book);
Book entity =
  mapper.findById(book.getTitle()).orElseThrow();
System.out.println("the entity result: " + entity);</pre>
			<p>The preceding sample code introduces the conversion process by using the <strong class="source-inline">Mapper</strong> class. By doing that, we are abstracting away the conversion operations from this method by moving them to the <strong class="source-inline">BookMapper</strong> class. Due to the encapsulation, <em class="italic">the client does not know the details of how the translation process is done</em> – <span class="No-Break">great!</span></p>
			<p>While this is a positive step, there are still improvements to be made as the client is still responsible for invoking the conversion operation. While we can test the conversion process, the high coupling between the client and the technology is still <span class="No-Break">a concern.</span></p>
			<p>To address these issues, our next design includes the addition of a <em class="italic">mapper layer</em>, which will reduce the friction between the client and the database. This mapper will be used repeatedly, making it a good candidate for a framework such as JPA or Hibernate to <span class="No-Break">operate on.</span></p>
			<p>Overall, introducing this mapper layer will help us improve the flexibility and maintainability of our solution, while also reducing complexity (see <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 4.3 – Mapper layer﻿ – code design now has an extra abstraction layer" src="image/Figure_4.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Mapper layer – code design now has an extra abstraction layer</p>
			<p>While the mapper layer does make things simpler for the client, it still requires the client to have some knowledge of the database details. This can be problematic as it opens up possibilities for errors when implementing the mapper and its operations. What if we could find a way to reduce this risk? What about creating a new layer, but this time, having it act on the entire <span class="No-Break">database operation?</span></p>
			<p>Let’s introduce the DAO pattern! It will allow us to reduce the burden on the client and minimize the chances of <span class="No-Break">implementation errors.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor082"/>The DAO pattern</h2>
			<p>The DAO pattern is a way to structure the separation of the application/business layer from the persistence layer. Its main goal is to abstract the whole database operation from <span class="No-Break">the API.</span></p>
			<p>By encapsulating all the operations in a class or interface, the API can be updated whenever needed without affecting the persistence data implementation. This is especially useful in long-term systems, where the DAO implementation may need to <span class="No-Break">be changed.</span></p>
			<p><strong class="source-inline">BookDAO</strong> introduces the contracts for inserting and retrieving a <strong class="source-inline">Book</strong>. As a client of this interface, you don’t need to know how it works internally. This makes the code safer by centralizing the database process in a single place. Now <strong class="source-inline">BookDAO</strong> will be the one working with the <span class="No-Break">database mapper:</span></p>
			<pre class="source-code">
public interface BookDAO {    Optional&lt;Book&gt; findById(String id);
    void insert(Book book);
    void update(Book book);
    void deleteByTitle(String title);
}</pre>
			<p>The DAO has an imperative style, which means it’s up to the client to define the specific operation. For example, if you are using the API and want to update a book, you must make sure the book exists first; otherwise, you’ll get an exception being thrown. If you are familiar with JPA from previous Java EE, you might consider abstracting <strong class="source-inline">EntityManager</strong> in a project such as this. In this example, we’ll use the mapper operations in the <span class="No-Break">DAO layer:</span></p>
			<pre class="source-code">
public class BookMemory implements BookDAO {//..
    @Override
    public void update(Book book) {
     mapper.update(book);
    }
//…
}</pre>
			<p>The DAO pattern was made popular by Microsoft in Visual Basic, and later Java through the Sun organization. It was also stated in the early days in the <em class="italic">Core J2EE Patterns</em> book. It includes the names of the methods, but the goal is to isolate the database with an abstraction, so it doesn’t matter whether you are using SQL, NoSQL, or <span class="No-Break">any service.</span></p>
			<p>From a trade-off perspective, we get isolation and better maintainability, and we can test a service unit by mocking the DAO if needed. However, keep in mind that because it’s generally an imperative API, it’s up to the client to make sure it’s using the right method (update or insert, for instance) in the <span class="No-Break">right situations:</span></p>
			<pre class="source-code">
Book book = BookSupplier.INSTANCE.get();BookDAO dao = new BookMemory();
dao.insert(book);
Book entity = dao.findById(book.getTitle()) .orElseThrow();
System.out.println("the entity result: " + entity);</pre>
			<p>Using the DAO pattern, from now on, a book client consuming <strong class="source-inline">BookDAO</strong> interacts with books without awareness of the database <span class="No-Break">conversion processes.</span></p>
			<p>By abstracting away the database operations, our client doesn’t even need to know about mapping operations, and we can isolate a few things on the persistence side. However, the client still needs to be aware of the data operation. <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.4</em> shows the new layer where the client is moved, or abstracted, a bit further away from <span class="No-Break">the database:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 4.4 – U﻿pfront design using DAO pattern brings even more abstraction to the database integration" src="image/Figure_4.04_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Upfront design using DAO pattern brings even more abstraction to the database integration</p>
			<p>From the client’s perspective, it’s an improvement compared to the beginning when the client had to handle the whole process, including the database and entity model conversions, plus the data manipulation operations themselves. But if the client tries to insert twice or update inexistent information, again, we’ll get exceptions being thrown. This is a database detail that might not make sense in some cases. So, how can we remove this and focus more on the business? That’s what we’ll explore in the next section with the repository pattern and the <strong class="bold">domain-driven design</strong> (<span class="No-Break"><strong class="bold">DDD</strong></span><span class="No-Break">) practices.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor083"/>Repository pattern boosted by DDD</h2>
			<p>The repository is a pattern from DDD that focuses on a business perspective and abstracts away storage and infrastructure details. As a client using this API, we don’t need to worry about any implementation details. The main focus is on the <span class="No-Break"><strong class="bold">ubiquitous language</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">DDD and the universal language</p>
			<p class="callout">In DDD, the concept of a‘‘ubiquitous language’’refers to a shared language that is used by all members of a development team to communicate about the domain model. This language helps to improve communication and reduce misunderstandings by ensuring that everyone is using the same terms to refer to the same concepts. It is an important part of the DDD process and should be fostered and refined throughout the development of a <span class="No-Break">software project.</span></p>
			<p>Going back to our book example, let’s start by creating an interface to handle a <strong class="source-inline">Library</strong> book collection. <strong class="source-inline">Library</strong> should be able to save books, find books by title, and when appropriate, <span class="No-Break">unregister books.</span></p>
			<p>The <strong class="source-inline">Library</strong> contracts are going to do the job, and the client won’t even know whether the implementation is going to actually insert or update a book. The client’s need is to save a book; from the technical perspective, if it’s a new book, it’s inserted, and if it already exists, it’s then updated. The <strong class="source-inline">Library</strong> interface will look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public interface Library {    Book register(Book book);
    Optional&lt;Book&gt; findByTitle(String title);
    void unregister(Book book);
}</pre>
			<p>The interface contract uses a ubiquitous language that is closer to the business language and hosts the methods related to its operations. As a client, I don’t want to have to care about how the data is stored or where it comes from. If you’re a Java developer, you may be familiar with frameworks that implement repository patterns such as <strong class="bold">Spring Data</strong>, which uses the <strong class="source-inline">save</strong> method to put away the <span class="No-Break">database operation.</span></p>
			<p class="callout-heading">Does this framework allow the use of DDD practices?</p>
			<p class="callout">Some frameworks use a repository interface methodology, but not all of them follow the DDD practices. You can easily check whether a framework follows DDD practices: look for insert and update methods, such as in the Quarkus framework and JPA <span class="No-Break">with PanacheRepository.</span></p>
			<p>The main difference between a DAO and a repository pattern implementation is the distance, often called the proximity, between the client and the database. While a DAO exposes the behavior of the persistence layer, a repository tends to have a <span class="No-Break">business-oriented exposure.</span></p>
			<p>Our <strong class="source-inline">Library</strong> implementation will use the DAO layer, implemented on the <strong class="source-inline">BookDAO</strong> class. Our <strong class="source-inline">DAO</strong> already has the mapper conversion operations and database operations ready to go. The following code shows, through the <strong class="source-inline">register</strong> method, how to use the DAO <strong class="source-inline">insert</strong> and <span class="No-Break"><strong class="source-inline">update</strong></span><span class="No-Break"> methods:</span></p>
			<pre class="source-code">
public class LibraryMemory implements Library {    private final BookDAO dao;
    public LibraryMemory(BookDAO dao) {
        this.dao = dao;
    }
    @Override
    public Book register(Book book) {
        Objects.requireNonNull(book, "book is required");
        if(dao.findByTitle(book.getTitle()).isPresent()) {
            dao.update(book);
        } else {
            dao.insert(book);
        }
        return book;
    }
    @Override
    public Book unregister(Book book) {
        Objects.requireNonNull(book, "book is required");
        dao.deleteByTitle(book.getTitle());
        return book;
    }
    @Override
    public Optional&lt;Book&gt; findByTitle(String title) {
        Objects.requireNonNull(title, "title is required");
        return dao.findByTitle(title);
    }
}</pre>
			<p>Now, let’s take a look at the client code. From the client’s perspective, we can notice the abstraction primarily when registering a book – the business-oriented operation named <strong class="source-inline">register</strong> is simplified by delegating the technical decision of updating or inserting to the <span class="No-Break">underlying implementation.</span></p>
			<p class="callout-heading">Fameworks and the mapper pattern</p>
			<p class="callout">There are several frameworks available to help simplify the work of Java developers when it comes to implementing a mapper layer. Some examples include Spring Data, Micronaut, Quarkus, and the Jakarta <span class="No-Break">Data specification.</span></p>
			<p>The following shows the repository client implementation registering <span class="No-Break">a book:</span></p>
			<pre class="source-code">
Book book = BookSupplier.INSTANCE.get();Library library = new LibraryMemory(new BookMemory());
library.register(book);
Optional&lt;Book&gt; entity =
  library.findByTitle(book.getTitle());
System.out.println("the entity result: " + entity);</pre>
			<p>By having the preceding repository as the client, there’s no need to implement any kind of details on where to obtain this data from. It simplifies and focuses on the business need – registering a book and finding it by its title. However, there’s a cost to this. Even when using frameworks, adding more layers also has its trade-offs, such as increased CPU consumption and more locations, which can be potential root causes to be checked in case of eventual bugs. The following figure shows that we’ve added another layer between the database and the <span class="No-Break">business domain:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 4.5 – Up-front design using repository pattern" src="image/Figure_4.05_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Up-front design using repository pattern</p>
			<p>Yet again, we have to face the dilemma of software design – where there is no right or wrong answer, just trade-offs. On the one hand, we can move the database as far away as possible and <a id="_idIndexMarker123"/>simplify <a id="_idIndexMarker124"/>the client implementation. On the other hand, we might go too far and end up tightly integrating the entity and database operations while trying to <span class="No-Break">simplify things.</span></p>
			<p>Our next and final stop on this journey will be the active <span class="No-Break">record pattern<a id="_idTextAnchor084"/>.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor085"/>The active record pattern</h2>
			<p>The <a id="_idIndexMarker125"/>active record is a way to <a id="_idIndexMarker126"/>reduce the complexity of using database operations in a model. Martin Fowler defined it in his 2003 book <em class="italic">Patterns of Enterprise Application Architecture</em>. And here’s our next stop – we’ll combine the entity with its <span class="No-Break">database operations.</span></p>
			<p>The idea behind this pattern is to use inheritance in Java by having an entity that extends a <strong class="source-inline">Model</strong> class. This gives the entity database capabilities like that of a model <span class="No-Break">with superpowers:</span></p>
			<pre class="source-code">
public class Book extends Model {    private final String title;
    private final String author;
    private final String publisher;
    private final String genre;
}</pre>
			<p>But with great power comes great responsibility. One of the main benefits of this pattern is simplicity. If you look at it from an MVC perspective, the model will then hold both business-related logic and data manipulation logic. In our code sample, the <strong class="source-inline">Book</strong> class is able to do several database operations such as inserting, updating, deleting, and finding by ID. The following code shows the client’s implementation code, which can create the book and then use the <span class="No-Break"><strong class="source-inline">insert</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
Book book = ...;book.insert();
Book model = Book.findById(book.getId());</pre>
			<p>This pattern makes sense in certain situations, especially in simple applications. But just as with every other solution, this is not a silver bullet. This pattern has its own concerns, such as breaching the single responsibility principle of SOLID. Some Java frameworks rely on this pattern, such as Panache with Quarkus, ActiveJDBC, <span class="No-Break">and ActiveJPA.</span></p>
			<p>Discussing <a id="_idIndexMarker127"/>layers and <a id="_idIndexMarker128"/>abstractions can be quite a big topic because the decision you made can have positive and <span class="No-Break">negative consequences.</span></p>
			<p>Now that we’ve seen different ways to design a persistence integration layer, we will move on to analyzing how frameworks work under the covers and learn which of their characteristics can be weighted when choosing a persistence <span class="No-Break">framework techno<a id="_idTextAnchor086"/>logy.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor087"/>Navigating the Java mapping landscape – evaluating framework trade-offs</h1>
			<p>You can <a id="_idIndexMarker129"/>now understand the motivations for using layers. It’s great <a id="_idIndexMarker130"/>that we have a mature Java ecosystem and don’t have to do everything manually – <em class="italic">thanks to the frameworks</em>. Since there are so many of them, we can categorize them based on API usability, proximity, <span class="No-Break">and runtime.</span></p>
			<ul>
				<li><strong class="bold">Usability:</strong> One <a id="_idIndexMarker131"/>of the items to evaluate when looking at a framework is the usability of its API. For instance, you can ask a question such as “<em class="italic">How many times can we use the same API with different databases? Is it </em><span class="No-Break"><em class="italic">even possible?</em></span><span class="No-Break">”</span><ul><li><strong class="bold">Agnostic API</strong>: A <a id="_idIndexMarker132"/>single API can be used with multiple database vendors, types, or paradigms. The positive aspect of this is that an agnostic API reduces the cognitive load since you don’t need to learn about a new API for every different database integration. However, you might lose particular database behaviors or have to wait longer to receive feature updates and <span class="No-Break">bug fixes.</span></li><li><strong class="bold">Specific API</strong>: The opposite <a id="_idIndexMarker133"/>of the agnostic API would be each database requiring a dedicated API – in other words, one API per database. Constantly updated versions are offered to support users to integrate with the latest version of the target database provider. Fortunately, it might have fewer layers and more performance; unfortunately, the cognitive load can be harder to manage when handling <span class="No-Break">polyglot persistence.</span></li></ul></li>
				<li><strong class="bold">Proximity</strong>: How<a id="_idIndexMarker134"/> close is the framework to the database <span class="No-Break">storage engine?</span><ul><li><strong class="bold">Communication</strong>: Closer<a id="_idIndexMarker135"/> to the database and farther from the domain model; this enables data-driven design, but there might be more <span class="No-Break">boilerplate code.</span></li><li><strong class="bold">Mapping</strong>: Closer <a id="_idIndexMarker136"/>to the model and farther from the database; this enables DDD and reduces boilerplate code, but being farther from the database can result in ignoring the best practices on the <span class="No-Break">database side.</span></li></ul></li>
				<li><strong class="bold">Runtime</strong>: This <a id="_idIndexMarker137"/>mainly affects mapping frameworks that rely on <span class="No-Break">annotations usage.</span><ul><li><strong class="bold">Reflection</strong>: This <a id="_idIndexMarker138"/>framework explores the reflection in Java, which allows for more flexibility and variety of runtime plugins. However, the startup time is slower and the application consumes a large amount of memory to execute processes for reading <span class="No-Break">the metadata.</span></li><li><strong class="bold">Reflectionless</strong>: This<a id="_idIndexMarker139"/> type of framework avoids reflections, making startup faster and more economical. However, metadata processing happens at build time instead of runtime, resulting in longer build and packaging processes, and there is less flexibility for the framework to explore in <span class="No-Break">real time.</span></li></ul></li>
			</ul>
			<p>In conclusion, there are a variety of Java mapping frameworks to choose from, each with its own trade-offs in terms of API usability, proximity to database implementation details, and runtime capabilities. It’s important to consider the specific needs of your project and choose the framework that best fits <span class="No-Break">those needs.</span></p>
			<p>And now that we’ve split our <em class="italic">all-in-one</em> class, simplified the client implementation, reduced chances of development errors, and acknowledged the types of frameworks we can pick from the many options available on the market, we can’t go forward without discussing the view and controller layers (of MVC) from a data perspective. In the next section, we’ll explore how to handle data that travels between the view layer and the underlying layers when <a id="_idIndexMarker140"/>using <strong class="bold">data transfe<a id="_idTextAnchor088"/>r </strong><span class="No-Break"><strong class="bold">objects</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DTOs</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor089"/>Data transfer between the view and underlying layers</h1>
			<p>In this <a id="_idIndexMarker141"/>chapter, we’ve discussed the importance of application layers for development and how they can impact the maintainability and complexity of a project. We’ve also looked at the application’s model and its relation to the database in an MVC architecture. But wait a moment… when it comes to the view and controller (of MVC), are there any potential impacts on the database integration and <span class="No-Break">its performance?</span></p>
			<p>The answer is <em class="italic">yes</em>. Let’s take a better look at how data transfer from the presentation layer to the underlying layers can benefit or impact <span class="No-Break">your solution.</span></p>
			<p>Most of the time, when developers decide to use the data model on the client side, challenges such as the following can <span class="No-Break">show up:</span></p>
			<ul>
				<li><strong class="bold">Change-related impacts</strong>: Changes to the model – <strong class="source-inline">Book</strong>, for example – can directly impact the view layer and require changes to it <span class="No-Break">as well.</span></li>
				<li><strong class="bold">Security and visibility</strong>: Every aspect of the model will be accessible on the presentation layer. In our <strong class="source-inline">Library</strong> example, it wouldn’t be a good thing to expose sensitive data such as a book’s<em class="italic"> price</em>. In a more concrete scenario, suppose you’re developing a client consumer of a social media API – it would be unacceptable to find a user by ID, for instance, and expose all non-sensitive and sensitive information, including things such as the user’s password! It’s strongly recommended to <em class="italic">share only what’s necessary – not all information should be visible to </em><span class="No-Break"><em class="italic">the client</em></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Code evolution and versioning</strong>: In typical scenarios, part of the code is constantly evolving while another part, the <em class="italic">legacy</em> side, must be maintained. In this case, if a new capability requires changes to the model that is used inside the view layer, it may break the legacy model side of <span class="No-Break">this integration.</span></li>
				<li>To<a id="_idIndexMarker142"/> handle model differences between the old and current code, one approach is to use <strong class="bold">versioning</strong>. By <a id="_idIndexMarker143"/>versioning the model class used in the view (which is the client), it becomes possible to have the same model offered through different classes and enable the creation of different views, each with their <span class="No-Break">respective adapters.</span></li>
			</ul>
			<p>Given the set of problems in this approach, the conclusion is that the solution to transferring information through presentation layers is to separate the model from the view and controller. That’s when the DTO pattern comes <span class="No-Break">into play.</span></p>
			<p class="callout-heading">A look back at DTOs</p>
			<p class="callout">A DTO is a <a id="_idIndexMarker144"/>design pattern that facilitates transferring data between a system’s layers or components. It can be used to decouple the presentation layer from the business logic, increasing the application’s flexibility and maintainability. These simple objects contain data but no associated business logic – they’re simple representations of data to be displayed in <span class="No-Break">a view.</span></p>
			<p>The DTOs represent different views from the actual domain models. A DTO could hold, for instance, just the necessary subset of books of information that needs to be presented. In summary, the DTO pattern has benefits such as <em class="italic">model simplification</em> due to the separation between business and database logic, <em class="italic">performance improvement</em> since fewer database calls are made, and <em class="italic">enhanced security</em> by preventing data leaks through the exposure of <span class="No-Break">sensitive attributes.</span></p>
			<p>However, potential<a id="_idIndexMarker145"/> drawbacks can also be seen, such as the <em class="italic">higher complexity</em> caused by an increasing number of layers and classes, the <em class="italic">reduced flexibility</em> resulting from restricted access to the model’s information, which may be needed but not exposed, and the <em class="italic">decreased performance</em> caused by additional processing on the mapping between DTOs <span class="No-Break">and models.</span></p>
			<p>It’s crucial to keep in mind that isolation is key, and too much code can increase complexity and <span class="No-Break">impact performance.</span></p>
			<p>Creating DTOs <a id="_idIndexMarker146"/>can denote a lot of work, especially when manually implemented. Fortunately, if you consider the DTO pattern a good fit for your project, there are frameworks available on the market that can make your life easier. Frameworks such as <a id="_idIndexMarker147"/>model mapper (<a href="http://modelmapper.org/">http://modelmapper.org/</a>) and <a id="_idIndexMarker148"/>MapStruct (<a href="https://mapstruct.org/">https://mapstruct.org/</a>) can facilitate and speed up <span class="No-Break">the implementation.</span></p>
			<p>We won’t go too deep into the presentation layer and the DTO pattern. We want to remind you, though, to be cautious about the view space as well since there are more attention points than simply <em class="italic">persistence</em> – one exam<a id="_idTextAnchor090"/>ple <span class="No-Break">being visualization.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor091"/>Summary</h1>
			<p>Layers, layers, and more layers – sometimes, they’re excellent allies helping split responsibility, reducing and centralizing the development error risks, and facilitating the adoption of the single responsibility principle from SOLID. Eventually, too many layers can become counterproductive and increase the code design’s complexity. When should a new layer be added or removed? The answer will be hidden under each individual application’s contextual challenges, technical needs, and <span class="No-Break">business needs.</span></p>
			<p>Through a journey highlighted with code demonstrations, we explored several patterns, from the unstructured and zero-layer application design to the multiple types of multi-tier design adoption and business-oriented simplification techniques. On this journey, we learned about the benefits and drawbacks of using layers to abstract the database from the client in a <span class="No-Break">software application.</span></p>
			<p>Furthermore, we explicitly stated that there is more to the persistence layer for us developers and architects to care about, and that the way we’ll visualize and interact with the data on the layer view should also be taken into consideration as a layer that can be impacted by how we design our <span class="No-Break">persistence solutions.</span></p>
			<p>Understanding the application’s requirements and context is the key to determining the best patterns to apply to your database integration, and the best cost-benefit level of abstraction and isolation. With that, we’re ready to understand and explore the enterprise Java standards made available through Jakarta EE and MicroProfile specifications. In the next chapter, we’ll introduce you to two persistence-related specifications that can address multiple challenges mentioned so far, and delve into the power of exploring the spaces of enterprise and microservices <span class="No-Break">Java applications.</span></p>
		</div>
	

		<div class="Content" id="_idContainer035">
			<h1 id="_idParaDest-59"><a id="_idTextAnchor092"/>Part 2: Jakarta EE, MicroProfile, Modern Persistence Technologies, and Their Trade-Offs</h1>
		</div>
		<div id="_idContainer036">
			<p>In this section of the book, we explore the intersection of Jakarta EE, MicroProfile, and modern persistence technologies. We dive into the trade-offs associated with different approaches to persistence, providing valuable insights and practical guidance for developers navigating the dynamic landscape of <span class="No-Break">Java persistence.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19375_05.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a><em class="italic">, Jakarta EE and JPA: State of Affairs</em></li>
				<li><a href="B19375_06.xhtml#_idTextAnchor122"><em class="italic">Chapter 6</em></a><em class="italic">, NoSQL in Java Demystified: One API to Rule Them All</em></li>
				<li><a href="B19375_07.xhtml#_idTextAnchor138"><em class="italic">Chapter 7</em></a><em class="italic">, The Missing Guide for jOOQ Adoption</em></li>
				<li><a href="B19375_08.xhtml#_idTextAnchor151"><em class="italic">Chapter 8</em></a><em class="italic">, Ultra-Fast In-Memory Persistence with Eclipse Store</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer037">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer038">
			</div>
		</div>
		<div>
			<div id="_idContainer039">
			</div>
		</div>
	</body></html>