<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Chapter 7: Exploring Middleware and Frameworks</h1>
			<p>In this chapter, we will start talking about the concept of middleware and how it has evolved over time. In particular, we will focus on the <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">JEE</strong>) standard, including the <strong class="bold">Jakarta EE</strong> transition. We will see a notable open source implementation, which is <strong class="bold">WildFly</strong> (formerly known as <strong class="bold">JBoss Application Server</strong>), and we will start exploring how the concept of middleware is evolving into cloud-native frameworks – in our case, <strong class="bold">Quarkus</strong>.</p>
			<p>You will learn the following topics in this chapter:</p>
			<ul>
				<li>The JEE standard</li>
				<li>The WildFly application server</li>
				<li>The most common JEE APIs</li>
				<li>Beyond JEE</li>
				<li>Quarkus</li>
			</ul>
			<p>Our picture of middleware will be completed in the next chapter, in which we will see the approach to integration, which is another cornerstone of what's traditionally called middleware.</p>
			<p>After reading this chapter, you will know the differences and similarities between the JEE standard and its cloud-native alternative, MicroProfile. Moreover, we will have seen the most common and useful APIs provided by both standards.</p>
			<p>But first of all, let's start with the most popular middleware standard for Java developers, which is, of course, JEE.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Technical requirements</h1>
			<p>Please make sure that you have a supported <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) installed on your machine.</p>
			<p>You can find the source code used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7</a>.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Introducing the JEE standard</h1>
			<p>We (as programmers, who are well versed with the digital world) know that Java is a powerful and expressive language. It is a widely used tool for building applications, both in a traditional way (as it is already done in a majority of enterprise contexts) and more and more in a cloud-native way too (as we will see in this chapter).</p>
			<p>According<a id="_idIndexMarker702"/> to the JVM Ecosystem Report 2021 by Snyk, roughly 37% of production applications use JEE (with Java EE, referring to the older version, still being used by a majority compared to newer JakartaEE implementations). Spring Boot counts for 57%, while Quarkus, which we are going to see in this chapter, is growing and is currently at 10%.</p>
			<p>So, Java doesn't need an introduction per se. Everybody (at least, everybody who is reading this book) knows that it's a powerful and expressive language that aims to be available across platforms (write once, run everywhere – I love it!) and that it is based on the compilation of bytecode, which can then be executed by the virtual machine.</p>
			<p>It's a technology platform that includes a programming language, specifications, documentation, and a set of supporting tools, including runtimes (the JVM), a compiler, and so on. The tools are provided by different vendors (with the major ones being Oracle, IBM, and Red Hat) and comply with the standards. The language is currently owned by Oracle. So far, so good.</p>
			<p>Then, we have<a id="_idIndexMarker703"/> the <strong class="bold">Enterprise Edition</strong>. There are a number of standards that are not really needed in the <em class="italic">plain</em> version of the Java technology. Features such as transactions and messaging are specifically targeted at server-side enterprise scenarios, such as banking applications, CRMs, and ERPs. For this reason, such features are standardized as an extension of the Java platform, namely the Enterprise Edition. </p>
			<p>However, in 2017, Oracle decided to donate the rights of the Enterprise Edition to the Eclipse open source community while holding the rights to the Java language (and brand). For this reason, the Enterprise Edition has been renamed Jakarta EE after a community vote.</p>
			<p>This transition caused some slight changes in the specification process, basically making it more open to<a id="_idIndexMarker704"/> cooperation and less linked to just one vendor. The old process was named the <strong class="bold">Java Community Process</strong> (<strong class="bold">JCP</strong>), while the new one is called<a id="_idIndexMarker705"/> the <strong class="bold">Eclipse Foundation Specification Process</strong> (<strong class="bold">EFSP</strong>). The most important concepts stay the same, such as<a id="_idIndexMarker706"/> the <strong class="bold">Java Specification Request</strong> (<strong class="bold">JSR</strong>), which is a way of specifying the new features, and the <strong class="bold">Technology Compatibility Kits</strong> (<strong class="bold">TCKs</strong>), which <a id="_idIndexMarker707"/>are used to certify adherence to the standard. Jakarta starts from version <strong class="bold">8</strong>, based on <strong class="bold">Java EE 8</strong>. At the time of writing, <strong class="bold">Jakarta EE 9</strong> is<a id="_idIndexMarker708"/> available. The examples in this chapter are tested<a id="_idIndexMarker709"/> against <strong class="bold">JEE 8</strong> (because it's the most widely used version right now) but should work properly <a id="_idIndexMarker710"/>in <strong class="bold">JEE 9</strong> too.</p>
			<p>It's worth noting that in this section, we will install the WildFly application server in order to start playing with JEE (and later on, we will start working with Quarkus to learn about MicroProfile). In both cases, the only requirement on your machine is a compatible version<a id="_idIndexMarker711"/> of the JVM. If you are in doubt, you can download the version you need for free from the OpenJDK website (<a href="http://openjdk.java.net/">http://openjdk.java.net/</a>). </p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>Diving into JEE implementations</h2>
			<p>As we said, the <a id="_idIndexMarker712"/>JEE specification (before and after the transition to Jakarta) provides TCKs. TCKs are suites of tests to certify compliance with the JEE standards. JEE currently provides a full profile and a web profile. The web profile is basically a subset of the specifications included in the full profile, aiming at a lighter implementation for some scenarios.</p>
			<p>There are a number of application servers that are JEE compliant. In my personal experience, the most widely adopted servers are as follows:</p>
			<ul>
				<li><strong class="bold">WildFly</strong> is a<a id="_idIndexMarker713"/> fully open source JEE application server, and it has a commercially supported version named JBoss Enterprise Application Platform (by Red Hat).</li>
				<li><strong class="bold">WebSphere Application Server</strong>, developed <a id="_idIndexMarker714"/>by IBM, is distributed in many different versions, including the open source Open Liberty.</li>
				<li><strong class="bold">Oracle WebLogic Server</strong> is <a id="_idIndexMarker715"/>developed and distributed by Oracle (the full profile only).</li>
			</ul>
			<p>Among the <a id="_idIndexMarker716"/>other servers fully implementing JEE specifications, Payara and GlassFish are worth mentioning. There are also a number of other interesting projects (such as Tomcat and Jetty) that are not fully JEE certified, but they implement most of the APIs and can plug into some of the others via external dependencies. In this chapter, we will work with WildFly, but thanks to the JEE standard, if we change some dependencies, everything should work in the other servers too.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Introducing the WildFly application server</h1>
			<p>WildFly is by far<a id="_idIndexMarker717"/> the application server that I've come across most often in my daily job. It's probably the most widespread Java application server. It <a id="_idIndexMarker718"/>was renamed from JBoss, as a contraction of <strong class="bold">Enterprise Java Beans</strong> (<strong class="bold">EJB</strong>) and <strong class="bold">Open-Source Software</strong> (<strong class="bold">OSS</strong>), EJBoss<a id="_idIndexMarker719"/> then becoming JBoss for copyright reasons relating to the EJB trademark. Since 2014, after a community vote, JBoss was renamed WildFly in its upstream distribution. This was to reduce the confusion in names between the project (WildFly), the<a id="_idIndexMarker720"/> community (<strong class="source-inline">JBoss.org</strong>), and the product family commercially supported by Red Hat (including <strong class="bold">JBoss EAP</strong>).</p>
			<p>It is worth mentioning that JBoss EAP is made of the same components as WildFly. There are no hidden features available in the commercial distribution. JBoss EAP is simply a frozen distribution of the WildFly components at a certain version, which is used to provide stability, certifications, and commercial support for enterprise environments. WildFly is developed in Java.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Exploring the WildFly architecture</h2>
			<p>If you have <a id="_idIndexMarker721"/>had a decent experience with WildFly, you may remember that JBoss used to be huge and sometimes slow. For this reason, a long time ago (around 2011), the server, then named <strong class="bold">JBoss AS 7</strong>, was <a id="_idIndexMarker722"/>rearchitected from the ground up. The resulting version was a modular and fast application server, which provided the basis for all the later releases (including the current one).</p>
			<p>Major <a id="_idIndexMarker723"/>changes were about class loading (made more granular), core feature implementation (moved to a modular, lazy-loading system), management, and configuration (unified into one single file). The result of this rearchitecting was then used for <a id="_idIndexMarker724"/>the <strong class="bold">JBoss EAP 6</strong> (and the following versions) commercial distribution. The latest version of WildFly (<strong class="bold">22.0</strong>) starts on my laptop in around 1 second. WildFly can be started in standalone mode (everything running in one Java process) or in domain mode, which is a way to centrally manage a fleet of instances from a single point. </p>
			<p class="callout-heading">Important Note:</p>
			<p class="callout">A very common misconception is the overlapping of the concept of domain with the concepts of clustering and high availability. They are actually orthogonal concepts.</p>
			<p>We can have an arbitrary number of standalone servers, individually managed and configured to be clustered in a highly available fashion, or a domain managing a fleet of non-clustered instances. Also, it's worth noting that we can have multiple server instances on a single machine (whether a physical or virtual host) by operating different port offsets (to avoid TCP port clashing) and different subdirectories.</p>
			<p>The server is distributed as a <strong class="source-inline">.zip</strong> file and<a id="_idIndexMarker725"/> the most significant folders are as follows:</p>
			<ul>
				<li><strong class="source-inline">bin</strong> directory: This<a id="_idIndexMarker726"/> contains the executable<a id="_idIndexMarker727"/> scripts (both for <strong class="bold">Linux</strong> and <strong class="bold">Windows</strong>, so <strong class="source-inline">.sh</strong> and <strong class="source-inline">.bat</strong>) for<a id="_idIndexMarker728"/> starting the server, along with some other utilities, such as for adding users and configuring vaults.</li>
				<li><strong class="source-inline">modules</strong> directory: This <a id="_idIndexMarker729"/>contains the system dependencies of the application server, which implement the core JEE features (and other supporting subsystems).</li>
				<li><strong class="source-inline">standalone</strong> directory: This<a id="_idIndexMarker730"/> is used as a root directory when the server is started in standalone mode. It includes subdirectories such as <strong class="source-inline">configuration</strong> (used for storing configuration files), <strong class="source-inline">data</strong> (where the persistent data from the deployed applications is stored), <strong class="source-inline">tmp</strong> (used to store temporary files used by applications), <strong class="source-inline">log</strong> (the default location for the server and applications logfiles), and <strong class="source-inline">deployments</strong> (which can be used to deploy applications by dropping deployable files and is used for development purposes).</li>
				<li><strong class="source-inline">domain</strong> directory: This<a id="_idIndexMarker731"/> is similar to <strong class="source-inline">standalone</strong>, but it doesn't contain the <strong class="source-inline">deployments</strong> folder (which is used for drop-in deployment, which is when we deploy <a id="_idIndexMarker732"/>new applications by copying the artifact in the directory and expect the application server to pick it and deploy it. This is not supported in domain mode). It contains a <strong class="source-inline">content</strong> directory (supporting some system functionalities, specific to the domain operating mode) and a <strong class="source-inline">server</strong> directory, which contains a subdirectory for each server instance hosted in the current machine, in turn containing <strong class="source-inline">tmp</strong>, <strong class="source-inline">data</strong>, and <strong class="source-inline">log</strong> folders used by that particular server.</li>
			</ul>
			<p>So far, we've been introduced to the WildFly architecture; now let's see how to run a WildFly server.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Running the WildFly server</h2>
			<p>For the sake <a id="_idIndexMarker733"/>of this chapter, we will be running the WildFly server in standalone mode. Before we get started, please make sure that you have a supported JVM installed on your machine. We will need to download the latest server <a id="_idIndexMarker734"/>distribution from <a href="https://www.wildfly.org/downloads/">https://www.wildfly.org/downloads/</a>.</p>
			<p>We'll use the following steps to install the WildFly server runtime:</p>
			<ol>
				<li>After downloading the required suitable files, we'll unzip them and run the following command on the terminal:<p class="source-code"><strong class="bold">/bin/standalone.sh</strong></p></li>
			</ol>
			<p>We can also use the <strong class="source-inline">.bat</strong> script (if you are on Windows) to run the server. We get the following output:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_7.1_B16354.jpg" alt="Figure 7.1 – Initializing WildFly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Initializing WildFly</p>
			<ol>
				<li value="2">Once <a id="_idIndexMarker735"/>the server is started, we can deploy our application by dropping our artifact (<strong class="source-inline">.jar</strong> / <strong class="source-inline">.war</strong> / <strong class="source-inline">.ear</strong>) into the <strong class="source-inline">deployments</strong> folder (which is not advised for production purposes) or, better yet, we can deploy by using the <a id="_idIndexMarker736"/>JBoss <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>).</li>
				<li>The JBoss CLI can be executed by running the <strong class="source-inline">jboss-cli.sh</strong> (or <strong class="source-inline">.bat</strong>) script from the <strong class="source-inline">bin</strong> directory. The CLI can be used to connect, configure, and manage WildFly setups (both locally and over the network). In order to use it to connect to a local standalone WildFly instance, we can simply use this command:<p class="source-code"><strong class="bold">./jboss-cli.sh --connect</strong></p></li>
				<li>We will then enter the interactive WildFly CLI. To deploy our application, we can use this command:<p class="source-code"><strong class="bold">deploy /pathToArtifact/myArtifact.war</strong></p></li>
				<li>We can then exit the WildFly CLI with the <strong class="source-inline">exit</strong> command:<p class="source-code"><strong class="bold">exit</strong></p></li>
			</ol>
			<p>Now that we know the basics of configuring and operating the WildFly server, we can start playing with simple JEE examples.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor171"/>Understanding the most common JEE APIs</h1>
			<p>Now that we have seen an overview of the JEE technology and implemented it with application servers, we will learn about the most common <a id="_idIndexMarker737"/>JEE APIs that are used in enterprise projects. We will have a look at some examples of those APIs at the end of this chapter, in the <em class="italic">Case studies and examples</em> section.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Dependency injection</h2>
			<p>I remember the<a id="_idIndexMarker738"/> times when dependency injection was simply not available in JEE, and we had to rely <a id="_idIndexMarker739"/>exclusively on <strong class="bold">EJB version 2</strong> (unfortunately) to wire our dependencies. This was probably one of the reasons behind the growth in popularity of the Spring Framework, which became widespread by offering a lightweight alternative to wiring, based on dependency injection, and avoiding verbose and error-prone configuration files. But that's another story that is out of the scope of this book. </p>
			<p><strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) or <strong class="bold">Contexts and Dependency Injection</strong> (<strong class="bold">CDI</strong>) is a concept that <a id="_idIndexMarker740"/>extends <a id="_idIndexMarker741"/>and<a id="_idIndexMarker742"/> implements the <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) principle. The idea here is that instead of letting each class instantiate the required classes, we can let an external entity (sometimes referred to as an IoC container) do that. This allows us to just use Java interfaces at design time and lets the container pick the right implementations, thus boosting flexibility and decoupling. Moreover, the CDI concept rationalizes the application structure by making the wiring points of one class with the others explicit.</p>
			<p>In the current implementations of the CDI standard (<strong class="bold">version 3.0</strong> in <strong class="bold">JEE 9</strong>), CDI is so easy to use that we can start developing with it without knowing much about it. The implementation is designed around annotations that decorate the classes identifying the contact points between each other. The most popular one is the <strong class="source-inline">@Inject</strong> annotation.</p>
			<p>By marking a field (or a setter method, or a constructor) of our class with this annotation, we are basically telling the framework that we want that field instantiated and provided for us. The <a id="_idIndexMarker743"/>container tries to identify a class in the application that may satisfy that dependency. The objects that can be injected are almost any kind of Java class, including special things that provide access to JEE services, such as persistence context, data sources, and messaging.</p>
			<p><em class="italic">But how does the container identify the class to use?</em> Skipping the trivial case in which just one possible implementation is provided, of course, there are ways to define which compatible class to inject. One way is to use qualifiers.</p>
			<p><strong class="bold">Qualifiers</strong> are <a id="_idIndexMarker744"/>custom annotations that can be created to specify which class to use from a list of compatible ones. Another widely used technique is to use the <strong class="source-inline">@Named</strong> annotation. With this annotation, we can provide each compatible class with a name and then specify which one to use in the injection.</p>
			<p>Last, but not least, it's possible to mark a class with <strong class="source-inline">@Default</strong> and the other implementations with <strong class="source-inline">@Alternatives</strong> to identify which one we want to be selected. <strong class="source-inline">@Alternatives</strong> can then be given an order of priority. </p>
			<p>CDI also provides the management of the life cycle of the objects, which means when the objects<a id="_idIndexMarker745"/> should be created and when they should be destroyed. The CDI scopes are configured by using annotations, as per the injection that we have just seen. The most commonly used scopes are as follows:</p>
			<ul>
				<li><strong class="bold">@ApplicationScoped</strong>: This<a id="_idIndexMarker746"/> binds the creation and destruction of the objects with the life cycle of the whole application. This means that one instance is created at application startup and destroyed at shutdown. Only one instance will be managed by the container and shared by all the clients. In this sense, this annotation is an implementation of the singleton pattern.</li>
				<li><strong class="bold">@Dependent</strong>: This <a id="_idIndexMarker747"/>is the default scope that creates a class, which is linked to the life cycle of the object using it, and so it's created and destroyed concurrently with the object in which it is injected.</li>
				<li><strong class="bold">@SessionScoped</strong>: This<a id="_idIndexMarker748"/> links the life cycle of the object with the HTTP session in which it is referenced (and so makes it a good tool for storing user and session information).</li>
				<li><strong class="bold">@RequestScoped</strong>: This <a id="_idIndexMarker749"/>binds the object life cycle to the life cycle of the HTTP request where it is referenced.</li>
				<li><strong class="bold">@TransactionScoped</strong>: This<a id="_idIndexMarker750"/> associates the life cycle of the object with the duration of the transactional boundary in which it is utilized.</li>
			</ul>
			<p>Here is the diagram for CDI scopes:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_7.2_B16354.jpg" alt="Figure 7.2 – CDI scopes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – CDI scopes</p>
			<p>CDI specifications also <a id="_idIndexMarker751"/>provide hooks to specific life cycle events. The most commonly used are <strong class="source-inline">@PostConstruct</strong> and <strong class="source-inline">@PreDestroy</strong>, which are called immediately after object creation and before destruction, respectively.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Jakarta RESTful Web Services</h2>
			<p>Another<a id="_idIndexMarker752"/> essential <a id="_idIndexMarker753"/>piece of Java applications nowadays is RESTful Web Services. The Jakarta EE standard for RESTful Web Services (<strong class="bold">JAX-RS</strong>) provides <a id="_idIndexMarker754"/>a nice and declarative way to implement the classic JSON over HTTP web service communication. Once we enable our application to use this specification (a common way is to add a class that extends the <strong class="source-inline">JAXRSApplication</strong> class to the class path), all we have to do is create a bean for mapping the resource that we want to expose and annotate it accordingly. </p>
			<p>In the <a id="_idIndexMarker755"/>most common use case, we will have to map the whole class to the path we want to expose by annotating the class with the <strong class="source-inline">@Path</strong> annotation. We may then want to specify the media types that the class produces and consumes (usually JSON) by using the <strong class="source-inline">@Produces</strong> and <strong class="source-inline">@Consumes</strong> annotations.</p>
			<p>Each method of the class can be mapped to HTTP methods by using annotations such as <strong class="source-inline">@Get</strong>, <strong class="source-inline">@Post</strong>, <strong class="source-inline">@Delete</strong>, <strong class="source-inline">@Put</strong>, and <strong class="source-inline">@Head</strong>, and we can bind these methods to sub-paths by using the same <strong class="source-inline">@Path</strong> annotation. As an example, we can have the whole class bound to <strong class="source-inline">/myPath</strong> (with <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and other HTTP methods referring to that path) and then have the specific methods annotated to refer to <strong class="source-inline">/myPath/mySubPath</strong>.</p>
			<p>Another very common scenario is the binding of method parameters with HTTP path parameters (<strong class="source-inline">@PathParam</strong>), parameters on the query string (<strong class="source-inline">@QueryParam</strong>), and HTTP headers (<strong class="source-inline">@HeaderParam</strong>). We <a id="_idIndexMarker756"/>should make a special mention of the <strong class="bold">Jakarta JSON Binding</strong> (<strong class="bold">JSON-B</strong>) specification, which, acting behind the scenes, can provide the JSON to <strong class="bold">Plain Old Java Objects</strong> (<strong class="bold">POJOs</strong>) (and vice versa) mapping<a id="_idIndexMarker757"/> for our beans, provided that they have a simple structure (and without needing any complex configuration). This is true for the most common use cases, meaning the Java classes with simple type fields with getters and setters. But of course, it's possible to provide customizations and implement special cases, if we need to.</p>
			<p>As part of the JAX-RS specification, we can create REST clients too (to query REST services). In order to do that, a common way is to use the <strong class="source-inline">ClientBuilder</strong> class, which provides a fluent API to specify the usual parameters of an HTTP client (such as timeouts, filters, and similar settings). We can then create a so-called <strong class="source-inline">WebTarget</strong> object, which is an object that allows us to specify the path to invoke using the client. Acting on <strong class="source-inline">WebTarget</strong>, it is possible to send requests by passing parameters and getting results (usually in form of JSON objects).</p>
			<p>An interesting twist of the JAX-RS specification is the possibility to manage <strong class="bold">Server Sent Events</strong> (<strong class="bold">SSEs</strong>). SSEs <a id="_idIndexMarker758"/>were introduced with the <strong class="bold">HTML5</strong> standardization<a id="_idIndexMarker759"/> and are a way to provide data from a server to a client in the form of events by using an open connection.</p>
			<p>What<a id="_idIndexMarker760"/> happens is that the client initiates the request to the server, but instead of getting all the data in one shot and closing the connection, it will keep the connection open and fetch the data as it comes from the client (eventually closing it at some point, or being disconnected by the server). The advantage here is that we can reuse the same connection to reduce the overhead, and we can get (and visualize) the data in real time without needing to poll the server for updates. The <a id="_idIndexMarker761"/>client could be a Java client or a web page in a browser.</p>
			<p>In order to implement this behavior, JAX-RS provides <strong class="source-inline">Sse</strong> and <strong class="source-inline">SseEventSink</strong> resources that can be injected into our method with the <strong class="source-inline">@Context</strong> annotation, as follows:</p>
			<p class="source-code">@GET</p>
			<p class="source-code">@Path("/serverSentExample ")</p>
			<p class="source-code">@Produces(MediaType.SERVER_SENT_EVENTS)</p>
			<p class="source-code">public void serverSentExample(@Context SseEventSink </p>
			<p class="source-code">  sseEventSink, @Context Sse sse)</p>
			<p>Once we have those two resources, we can use <strong class="source-inline">sse</strong> to build new events and <strong class="source-inline">sseEventSink</strong> to send such events. Once we've completed our interactions with the client, we can use <strong class="source-inline">sseEventSink</strong> to close the connection:</p>
			<p class="source-code">OutboundSseEvent event = sse.newEventBuilder()</p>
			<p class="source-code">.mediaType(MediaType.APPLICATION_JSON_TYPE)</p>
			<p class="source-code">.data(MyEventData.class, myEventData)</p>
			<p class="source-code">.build();</p>
			<p class="source-code">eventSink.send(event);</p>
			<p class="source-code">...</p>
			<p class="source-code">eventSink.close();</p>
			<p>So, let's summarize:</p>
			<ul>
				<li>We create an <strong class="source-inline">event</strong> object by invoking <strong class="source-inline">newEventBuilder</strong> on the <strong class="source-inline">sse</strong> object injected in our class.</li>
				<li>We set <strong class="source-inline">mediaType</strong> to JSON.</li>
				<li>We add the data we want to send, specifying the class type and the object instance containing the data.</li>
				<li>We call the <strong class="source-inline">build</strong> method to create the <strong class="source-inline">event</strong> instance.</li>
				<li>We invoke the <strong class="source-inline">send</strong> method on the <strong class="source-inline">eventSink</strong> object, passing the event instance we just created.</li>
				<li>Eventually, we can close the connection by calling <strong class="source-inline">close</strong> on the <strong class="source-inline">eventSink</strong> object. Of course, in a real-world scenario, we may want to send a number of events (such as a consequence of something happening) before closing the connection. It doesn't make much sense to have <strong class="source-inline">sse</strong> just to send one event. </li>
			</ul>
			<p>One<a id="_idIndexMarker762"/> interesting scenario generated by SSE is the possibility to implement broadcast scenarios. In such scenarios, instead of having each client <a id="_idIndexMarker763"/>connected to a different thread (and receiving different messages), we can have clients all receiving the same message. In this way, we will have clients subscribing (usually calling a specific REST service) and then getting the data (calling another one). Here is a code example (simplified):</p>
			<p class="source-code">     @GET</p>
			<p class="source-code">  @Path("broadcast")</p>
			<p class="source-code">  public Response broadcast(@Context Sse sse) {</p>
			<p class="source-code">    SseBroadcaster sseb = sse.newBroadcaster();</p>
			<p class="source-code">    OutboundSseEvent event = sse.newEventBuilder()</p>
			<p class="source-code">    .mediaType(MediaType.APPLICATION_JSON_TYPE)</p>
			<p class="source-code">    .data(MyEventData.class, myEventData)</p>
			<p class="source-code">    .build();</p>
			<p class="source-code">    sseb.broadcast(event);  </p>
			<p class="source-code">    ... </p>
			<p class="source-code">}</p>
			<p class="source-code">@GET</p>
			<p class="source-code">    @Path("subscribe")</p>
			<p class="source-code">    @Produces(MediaType.SERVER_SENT_EVENTS)</p>
			<p class="source-code">    public void subscribe(@Context SseEventSink </p>
			<p class="source-code">      sseEventSink){</p>
			<p class="source-code">         broadcaster = sse.newBroadcaster();</p>
			<p class="source-code">    broadcaster.register(sseEventSink);</p>
			<p class="source-code">    }</p>
			<p>Let's <a id="_idIndexMarker764"/>summarize <a id="_idIndexMarker765"/>what this code does:</p>
			<ul>
				<li>We create a <strong class="source-inline">broadcast</strong> method and annotate it to indicate that it will be associated with an HTTP <strong class="source-inline">GET</strong> method that is exposed on the <strong class="source-inline">broadcast</strong> path.</li>
				<li>This <strong class="source-inline">broadcast</strong> method will be injected with an <strong class="source-inline">sse</strong> object instance present in the context.</li>
				<li>We create a <strong class="source-inline">broadcaster</strong> object by invoking the <strong class="source-inline">newBroadcaster</strong> method on the <strong class="source-inline">sse</strong> object.</li>
				<li>We create an <strong class="source-inline">OutboundSseEvent</strong> object by invoking the <strong class="source-inline">newEventBuilder</strong> method on the <strong class="source-inline">sse</strong> object.</li>
				<li>We set <strong class="source-inline">mediaType</strong> to JSON.</li>
				<li>We add the data we want to send, specifying the class type and the object instance containing the data.</li>
				<li>We call the <strong class="source-inline">build</strong> method to create the <strong class="source-inline">event</strong> instance. We invoke the <strong class="source-inline">broadcast</strong> method on the <strong class="source-inline">broadcaster</strong> object, passing the <strong class="source-inline">event</strong> instance we just created.</li>
				<li>We <a id="_idIndexMarker766"/>create a <strong class="source-inline">subscribe</strong> method and annotate it to indicate that it will be associated with an HTTP <strong class="source-inline">GET</strong> method that is exposed on the <strong class="source-inline">subscribe</strong> path and that will produce answers with the <strong class="source-inline">SERVER_SENT_EVENTS</strong> media type.</li>
				<li>The <strong class="source-inline">subscribe</strong> method will be injected with an <strong class="source-inline">SseEventSink</strong> object instance present in the context.</li>
				<li>We <a id="_idIndexMarker767"/>create an instance of a <strong class="source-inline">broadcaster</strong> object by invoking the <strong class="source-inline">newBroadcaster</strong> method on the <strong class="source-inline">sse</strong> instance.</li>
				<li>We register <strong class="source-inline">sseEventSink</strong> by passing it to the <strong class="source-inline">register</strong> method on the <strong class="source-inline">broadcaster</strong> object.</li>
			</ul>
			<p>On the client side, we will most likely interact with SSE by using a framework such as Vue or Angular. But in any case, under the hood it will use the JavaScript <strong class="source-inline">EventSource</strong> object:</p>
			<p class="source-code">var source = new EventSource('mySSEEndpoint');</p>
			<p class="source-code">source.onmessage = function(e) { ... do something...}</p>
			<p>As mentioned, we can also interact with SSE by using a Java client. Similar to the JavaScript version, the SSE implementation in Java provides an <strong class="source-inline">EventSource</strong> object too:</p>
			<p class="source-code">Client client = ClientBuilder.newBuilder().build();</p>
			<p class="source-code">WebTarget target = client.target("mySSEBroadcastEndpoint");</p>
			<p class="source-code">SseEventSource source = </p>
			<p class="source-code">  SseEventSource.target(target).build();</p>
			<p class="source-code">source.register(event -&gt; { ... do something ... });</p>
			<p class="source-code">sseEventSource.open();</p>
			<p>A personal consideration here is to thoroughly test this kind of implementation in real production scenarios and manage and monitor exceptions. We must also consider some alternatives in <a id="_idIndexMarker768"/>case of unexpected disconnects that may be due to clients with unstable connections (such as mobile clients) or <a id="_idIndexMarker769"/>network devices misbehaving in the overall infrastructure. Frameworks usually also provide some resiliency features, such as connection retries (in case the backend is momentarily unavailable). Resiliency must be also considered from a backend perspective, hence if a failure occurs while sending a message (and an exception is thrown), you should consider handling (including retries). But since this is basically non-transactional (because of network connections being potentially unreliable), you should consider edge cases including duplicate events or message loss.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>WebSocket</h2>
			<p>Jakarta EE includes <a id="_idIndexMarker770"/>support for WebSocket technology. Using this<a id="_idIndexMarker771"/> technology, we can implement full-duplex communication between client and server, supporting the development of a rich user experience in web applications. WebSocket sits directly on top of TCP, so it doesn't rely on HTTP. However, it is compatible with HTTP, meaning that, from a connection point of view, it uses a compatible handshake and may be transported over HTTP and HTTPS standard ports (<strong class="source-inline">80</strong> and <strong class="source-inline">443</strong>), so it is compatible with most network infrastructures.</p>
			<p>In order to implement the WebSocket capabilities on the backend, you need to annotate a class with <strong class="source-inline">@ServerEndpoint</strong>, specifying the path on which the capabilities will be published. With this class, we can then annotate methods with <strong class="source-inline">@OnMessage</strong>, <strong class="source-inline">@OnOpen</strong>, <strong class="source-inline">@OnClose</strong>, and <strong class="source-inline">@OnError</strong> to intercept the message received, the client connected, the client disconnected, and error events, respectively. After the connection of a client, in the method annotated with <strong class="source-inline">@OnOpen</strong>, it's possible to retrieve and store a session object. This object can then be used to send messages to the clients, hence implementing full-duplex communication, as shown here:</p>
			<p class="source-code">@ServerEndpoint("/myWebSocket")</p>
			<p class="source-code">public class WebSocketEndpoint {</p>
			<p class="source-code">    @OnMessage</p>
			<p class="source-code">    public String onMessage(String message) {</p>
			<p class="source-code">        System.out.println("Message received: "+ message);</p>
			<p class="source-code">        return message;</p>
			<p class="source-code">    }</p>
			<p class="source-code">     @OnOpen</p>
			<p class="source-code">  public void onOpen(Session session) {</p>
			<p class="source-code">    System.out.println("Client connected");</p>
			<p class="source-code">//Session object can be stored and used to send messages </p>
			<p class="source-code">  back</p>
			<p class="source-code">  }</p>
			<p class="source-code"> </p>
			<p class="source-code">  @OnClose</p>
			<p class="source-code">  public void onClose() {</p>
			<p class="source-code">    System.out.println("Connection closed");</p>
			<p class="source-code">  }</p>
			<p class="source-code">    @OnError</p>
			<p class="source-code">    public void onError(Session session, Throwable </p>
			<p class="source-code">      throwable)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        System.out.println("Error in session " + </p>
			<p class="source-code">          session.getId() + " " + throwable.getMessage());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As we saw when<a id="_idIndexMarker772"/> discussing server-sent events, WebSocket's applications are <a id="_idIndexMarker773"/>usually implemented on the client side using frameworks. However, JavaScript exposes a WebSocket object that can be used to mirror the server-side life cycle (<strong class="source-inline">OnOpen</strong>, <strong class="source-inline">OnMessage</strong>, and <strong class="source-inline">OnError</strong>) and the message-sending capabilities. As with SSE, my suggestion is to test this kind of interaction <a id="_idIndexMarker774"/>on an infrastructure that's comparable to<a id="_idIndexMarker775"/> the production one and be ready with alternatives in case something goes wrong with network connectivity, such as having graceful fallbacks. A nice implementation of this could<a id="_idIndexMarker776"/> be the <strong class="bold">circuit breaker</strong> pattern, as we are going to see in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Messaging</h2>
			<p><strong class="bold">Messaging</strong> is <a id="_idIndexMarker777"/>another key component in modern applications. In the cloud-native microservices world, the <strong class="bold">Java Message Service</strong> (<strong class="bold">JMS</strong>) is <a id="_idIndexMarker778"/>considered to be an <em class="italic">enterprise-y</em>, complex manner of communication, often used together with other technologies, such as Kafka and AMQP. However, for many years, from <strong class="bold">version 2.0</strong> onward (<strong class="bold">3.0</strong> was just released at the time of writing), JMS has become very easy to use (at least in basic use cases).</p>
			<p>The idea behind the <a id="_idIndexMarker779"/>messaging standard in JEE (which is one of the things I like about the application servers in general) is that we can keep the code simple and compact and offload the configurations to the application server. This also has the advantage of separating the code from the configuration. This also has advantages in terms of clarity, portability, and testability.</p>
			<p>In order to send messages, we can use the injection of JEE resources – in this case, <strong class="source-inline">JMSContext</strong>. With the same approach, we can inject an object representing our target queue. The API then allows us to create a producer from the <strong class="source-inline">JMSContext</strong> object and use it to send a message against the queue, such as in the following code snippet:</p>
			<p class="source-code">@Resource(mappedName = "java:jboss/jms/queue/testQueue")</p>
			<p class="source-code">private Queue testQueue;</p>
			<p class="source-code">@Inject</p>
			<p class="source-code">JMSContext context;</p>
			<p class="source-code">...</p>
			<p class="source-code">context.createProducer().send(testQueue,msg);     </p>
			<p class="source-code">...</p>
			<p>With a similar kind of API, we can consume messages by creating a consumer and invoking the receive method against it. But this is not how it is done commonly. </p>
			<p>The most widely used way is to <a id="_idIndexMarker780"/>use a <strong class="bold">Message Driven Bean</strong> (<strong class="bold">MDB</strong>), which is natively designed to be triggered asynchronously when a message is received. The code to use an MDB involves the implementation of the <strong class="source-inline">MessageListener</strong> interface and the use of some annotations to configure the queue to attach to. The code is quite self-explanatory:</p>
			<p class="source-code">@MessageDriven(name = "TestMDB", activationConfig = {</p>
			<p class="source-code">  @ActivationConfigProperty(propertyName = </p>
			<p class="source-code">   "destinationLookup", propertyValue = "queue/TestQueue"),</p>
			<p class="source-code">  @ActivationConfigProperty(propertyName = </p>
			<p class="source-code">    "destinationType", propertyValue = "javax.jms.Queue")})</p>
			<p class="source-code">public class TestMDB implements MessageListener {</p>
			<p class="source-code">    public void onMessage(Message msg) {</p>
			<p class="source-code">        TextMessage myMsg =(TextMessage) rcvMessage;</p>
			<p class="source-code">          LOGGER.info("Received Message " + myMsg</p>
			<p class="source-code">            .getText());</p>
			<p>In both the consumer (MDB) and the producer example, the code looks for the default JMS connection factory, which is supposed to be bound to <strong class="source-inline">java:/ConnectionFactory</strong>. It is possible to explicitly state an alternative connection factory if we want to (such as when our application server must be connected to different brokers).</p>
			<p>In order to<a id="_idIndexMarker781"/> set the properties to connect to a broker, such as a host, port, username, and password (and associate it with a <strong class="bold">Java Naming and Directory Interface</strong> (<strong class="bold">JNDI</strong>) name, such as the default <strong class="source-inline">java:/ConnectionFactory</strong>), we will have to configure the application server. This is, of course, specific to the server we choose. In WildFly, we commonly do that by using a CLI (as we have seen when deploying applications) or by directly editing the configuration file.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Persistence</h2>
			<p><strong class="bold">Persistence</strong> is <a id="_idIndexMarker782"/>often<a id="_idIndexMarker783"/> one of the must-have properties for Java EE applications. While other persistence alternatives are now widely used, such as NoSQL stores<a id="_idIndexMarker784"/> and <strong class="bold">InMemory</strong> caches, database persistence is unlikely to disappear anytime soon.</p>
			<p>Persistence in JEE is regulated by <a id="_idIndexMarker785"/>the <strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>) specification. In the earlier versions, JPA was clumsy and painful to use (as was the EJB specification). This is not true anymore, and JPA is now very easy to use. As you may probably know, JPA is built around the <strong class="bold">Object-Relational Mapping</strong> (<strong class="bold">ORM</strong>) idea, which <a id="_idIndexMarker786"/>aims for relational database tables to be mapped to objects (in our case, Java objects). </p>
			<p>So, the first thing to do to use JPA is to define our objects and how they map to database tables. As you can imagine, this is easily done by using annotations. The relevant annotations here are <strong class="source-inline">@Entity</strong> to identify the class and map it to the database, <strong class="source-inline">@ID</strong> to mark the field linked to the primary key, <strong class="source-inline">@GeneratedValue</strong> to define the strategy for the key generation, <strong class="source-inline">@Table</strong> to configure the table name (which defaults to the class name), and <strong class="source-inline">@Column</strong> to configure the column name for each class field (also, in this case, it defaults to the field name). This is what the code looks like:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">@Table(name="MyTableName")</p>
			<p class="source-code">public class MyPojo {</p>
			<p class="source-code">@Id</p>
			<p class="source-code">@GeneratedValue(strategy = GenerationType.IDENTITY)</p>
			<p class="source-code">private int id;</p>
			<p class="source-code">@Column(name="myColumn")</p>
			<p class="source-code">private String myField;</p>
			<p class="source-code">...</p>
			<p>After we have our classes linked to our database tables, it's time to interact with the database itself. You can easily do that by injecting the so-called <strong class="source-inline">EntityManager</strong> where it's needed. The entity manager is associated with a persistence context, which is essentially the set of configurations that you set into the application and the application server to make it aware of where the database should connect to, such as the <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) string <a id="_idIndexMarker787"/>and other properties.</p>
			<p>You can <a id="_idIndexMarker788"/>use the entity manager to retrieve objects from the database by using the JPA query language (which is similar to SQL) to create new objects, delete them, and so on. Here is a code example:</p>
			<p class="source-code">@PersistenceContext(unitName="userDatabase")</p>
			<p class="source-code">private EntityManager em;</p>
			<p class="source-code">Query query = em.createQuery("Select p from MyPojo p");</p>
			<p class="source-code">(List&lt;MyPojo&gt;) query.getResultList();</p>
			<p class="source-code">em.getTransaction().begin();</p>
			<p class="source-code">        MyPojo pojo = new MyPojo();</p>
			<p class="source-code">        pojo.setMyField ("This is a test");</p>
			<p class="source-code">        em.persist(pojo);</p>
			<p class="source-code">em.getTransaction().commit();</p>
			<p class="source-code">em.close();</p>
			<p class="source-code">...</p>
			<p>As you can see, consistent with the other APIs that we have seen so far, JPA is pretty easy to use. It will nicely decouple business logic (in your Java code) from configuration (in the application server) and standardize the implementation of common aspects such as table-to-POJO mapping and transaction usage.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>What's missing in Java EE</h2>
			<p>One of the<a id="_idIndexMarker789"/> reasons why some developers are moving away from the JEE specification is <a id="_idIndexMarker790"/>that the evolution of the standard is a bit slow. One goal of the platform is to include a big list of vendors providing reference implementations and to give long-term stability to the standard users, so it will take time to evolve JEE. At the time of writing, a number of things were missing from JEE that need to be overcome by using third-party libraries.</p>
			<p>We will try to summarize the most common criticisms in this area:</p>
			<ul>
				<li><strong class="bold">Observability</strong>: Since the <a id="_idIndexMarker791"/>beginning, some advanced monitoring capabilities have been missing from the JEE specification. <strong class="bold">Java Management Extension</strong> (<strong class="bold">JMX</strong>) was provided in the Java platform as a first <a id="_idIndexMarker792"/>attempt to provide some metrics and monitoring, and JDK Mission Control was donated to open source communities, providing some more advanced capabilities in terms of profiling.</li>
			</ul>
			<p>However, enterprises commonly complement such technologies with third-party software, sometimes proprietary software. As of today, more advanced monitoring capabilities, such as tracing, are commonly required for fully controlling the application behavior in production. Moreover, metric collections and display technologies based on stacks such as Prometheus and Grafana have become a de facto standard. Observability also includes things such as health and readiness probes, which are special services exposed by the application that can be useful for checking for application availability (and send an alert or implement some kind of workaround if the application is not available). </p>
			<ul>
				<li><strong class="bold">Security</strong>: While JEE <a id="_idIndexMarker793"/>and Java, in general, are pretty rich in terms of security, including role-based access control at different architectural levels, support for encryption, multi-factor authentication, and authorization facilities is missing. There are some other features, such as OpenID Connect and JSON Web Token, that are still missing from the core specification.</li>
				<li><strong class="bold">Fault tolerance</strong>: In<a id="_idIndexMarker794"/> heavily decentralized environments, such as microservices and cloud-native, it's crucial to defend the application from issues in external components, such as endpoints failing or responding slowly. In JEE, there is no standardized way to manage those events (other than normal exception handling).</li>
				<li><strong class="bold">OpenAPI</strong>: REST<a id="_idIndexMarker795"/> services are widespread in the JEE world. However, JEE does not specify a way to define API contracts for REST services, as it's done by the OpenAPI standard.</li>
			</ul>
			<p>Other features less likely to be standardized, such as alternative datastores (think about NoSQL databases) and alternative messaging (such as streaming platforms or AMQP), are also missing. All those functionalities are normally added by third-party libraries and connectors. As we will see in the upcoming<a id="_idIndexMarker796"/> sections, <strong class="bold">MicroProfile</strong> provides a way to overcome those limitations in a standard way.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>What's great about Java EE</h2>
			<p>While some useful and modern technology is missing in the vanilla specification of JEE, as we have just said (but can be easily added via third-party libraries most of the time, such as what's provided by the <a href="http://smallrye.io">smallrye.io</a> project), I still think that JEE technology is just great and is here to<a id="_idIndexMarker797"/> stay. Some reasons are as follows:</p>
			<ul>
				<li><strong class="bold">Vendor ecosystem</strong>: As <a id="_idIndexMarker798"/>we saw at the beginning of this chapter, there are a number of alternative implementations, both paid and free, providing JEE compatibility. This will ensure long-term stability and (where needed) commercial support, which can be crucial in some environments.</li>
				<li><strong class="bold">Operations</strong>: While<a id="_idIndexMarker799"/> there is no fixed standard, as each vendor implements it in their own way, JEE enforces some configurability points on an application. This means that a JEE application can be easily fine-tuned for things such as thread pool size, timeouts, and authentication providers. While this is, of course, possible even while using other approaches, JEE tends to be more operation-friendly. Once the system administrators know about the specifics of the application server in use, they can easily change those aspects, regardless of the kind of application deployed.</li>
				<li><strong class="bold">Battle-tested for enterprise needs</strong>: JEE <a id="_idIndexMarker800"/>still provides things that are very useful (sometimes essential) in the enterprise world. We are talking about distributed transactions, connectors for legacy or enterprise systems, robust deployment standards, and so on. You are likely to find some of those features in alternative stacks, but they will often be fragmentary and less robust.</li>
			</ul>
			<p>This completes our quick overview of JEE's pros and cons. As you may know, a detailed explanation of JEE may take a whole (huge) book. However, in these sections, we have seen a simple selection of some basic APIs that are useful for building modern applications, including RESTful Web Services, JPA persistence, and messaging. We have also seen the pros and cons of the JEE framework.</p>
			<p>In the next section, we will start talking about alternatives to application servers.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor179"/>Going beyond Java Enterprise Edition</h1>
			<p>In <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>, we had a very quick look at containerizing Java applications.</p>
			<p>We will now look into alternatives and extensions to Java Enterprise, including lightweight Java servers<a id="_idIndexMarker801"/> and <strong class="bold">fat JAR</strong> applications. Here, we will see a quick overview of why and how to implement fat JAR applications.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Packaging microservices applications</h2>
			<p>A <strong class="bold">fat JAR</strong> (also known as an <strong class="bold">Uber JAR</strong>) is likely<a id="_idIndexMarker802"/> to be one of the starting <a id="_idIndexMarker803"/>points in the inception of application service alternatives (and microservices runtimes). Frameworks such as Dropwizard, Spring Boot, and, more recently, Quarkus have been using this approach.</p>
			<p>The idea of fat JAR is that you package all you need into a single <strong class="source-inline">.jar</strong> file so that we have a self-contained and immutable way to deploy your applications.</p>
			<p>The advantages are<a id="_idIndexMarker804"/> easy to imagine:</p>
			<ul>
				<li><strong class="bold">Deployment is simplified</strong>: Just copy the <strong class="source-inline">.jar</strong> file.</li>
				<li><strong class="bold">Behavior is consistent between different environments</strong>: You can test the application on a laptop without needing a full-fledged app server.</li>
				<li><strong class="bold">Full control of the dependencies</strong>: Versions and implementation of the supporting libraries <a id="_idIndexMarker805"/>are fixed at build time, so you will have fewer variables in production (and you are not forced to stick with what the app server provides).</li>
			</ul>
			<p>Of course, all of this comes at a cost. Here <a id="_idIndexMarker806"/>are some not-so-obvious disadvantages of this approach:</p>
			<ul>
				<li>It's less standard (think about configurations). There are some de facto standards, such as <strong class="source-inline">.yaml</strong>, application properties files, or system properties. But this usually varies from app to app, even when using the same technology stack. Conversely, app servers tend to be more prescriptive in terms of what can be configured and where to put such configurations.</li>
				<li>While you can pick and choose the dependencies you need, you have to carry over such dependencies with each deployment (or scale). And if you use many dependencies, this will be impactful in terms of network usage and time lost (and compiling time too). With the application servers, you take for granted that such dependencies are already waiting for you in the application server.</li>
				<li>When it comes to supportability, either you get support services from a vendor or simply adhere to internal standards. You are normally bound to a fixed set of libraries and versions that have probably been tested to be compatible with your environment and to adhere to security and performances standards. With a fat JAR, you have less control over this at runtime and deployment time. You will have to move such controls at build time, and maybe double-check that the content of the fat JAR adheres to standards before putting it into your production environment.</li>
			</ul>
			<p>As we discussed in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>, containers changed the rules of the game a bit.</p>
			<p>With <a id="_idIndexMarker807"/>container technology, you can create a full portable environment, including a base operating system (sort of) with a filesystem in which you can place dependencies and resources together with your application. This means that you don't need a self-consistent application to deploy, as these features are provided by container technology. And, as already discussed, this may also be harmful when used together with containers, as they are designed to work in a layered way. So, you can use this feature to package and deploy only the upper level (containing your application code) instead of carrying over the whole dependency set.</p>
			<p>So, while still convenient in some cases (such as local testing), fat JAR is not necessary right now.</p>
			<p>But as we have seen, other than a different packaging approach, there are some features <a id="_idIndexMarker808"/>that may be very useful in the cloud-native and microservices world. These features are missing in JEE, such as observability and support for alternative technologies. It used to be common for microservices runtimes to define custom solutions to fill those gaps.</p>
			<p>But as previously mentioned, lack of standards is a known issue with microservices. This used to be a minor issue because early adopters were usually deeply technically skilled teams relying on self-support and that didn't need support from a third-party vendor.</p>
			<p>However, nowadays, the adoption of microservices, cloud-native, and general extensions to JEE is growing a lot. And factors such as long-term stability, enterprise support, and an open ecosystem are becoming more and more essential. That's one of the reasons behind MicroProfile.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Introducing MicroProfile</h2>
			<p><strong class="bold">MicroProfile</strong> started<a id="_idIndexMarker809"/> with a focus on extending the JEE specification with features offered by microservices. The development is backed by a consortium of industry players, such as IBM, Red Hat, Oracle, and Microsoft. The specification lives in parallel to Jakarta EE, sharing some functionality, evolving some others, and adding some more that are not part of JEE.</p>
			<p>This works because<a id="_idIndexMarker810"/> the MicroProfile consortium, part of the Eclipse Foundation, has chosen a less bureaucratic and more frequent release model.</p>
			<p>This means that modern Java development can now basically take two parallel roads:</p>
			<ul>
				<li><strong class="bold">Jakarta EE</strong>: We can choose this if long-term stability and enterprise features are more important (or if you want to maintain and modernize existing code bases).</li>
				<li><strong class="bold">MicroProfile</strong>: We can choose this if cloud-native features and a frequent release cycle are priorities.</li>
			</ul>
			<p><em class="italic">But what are the features added by MicroProfile?</em></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>MicroProfile specifications</h2>
			<p>It's really <a id="_idIndexMarker811"/>challenging to print a snapshot of something (that is changing very frequently) on paper. At the time of writing, MicroProfile releases a new version every 3 to 6 months. The most important features to highlight are the following:</p>
			<ul>
				<li><strong class="bold">Configuration</strong>: This is a <a id="_idIndexMarker812"/>practical approach to separate the configuration repository (such as <strong class="source-inline">.xml</strong> files, system environments, and properties files) from the application itself. This provides the facilities for accessing the configuration values and checking for changes without needing to restart the application (in supported implementations).</li>
				<li><strong class="bold">Fault tolerance</strong>: This<a id="_idIndexMarker813"/> is a way to choreograph the reaction to failures (such as failing to call an external service) by using patterns such as circuit breaker, retry, and fallback.</li>
				<li><strong class="bold">OpenAPI</strong>: This<a id="_idIndexMarker814"/> provides support for the OpenAPI standard, which is a way to define contracts for REST services, similar to what a WSDL schema provides to SOAP web services.</li>
				<li><strong class="bold">OpenTracing</strong>: This<a id="_idIndexMarker815"/> is a modern approach to monitoring and managing chains of calls in a distributed environment by passing an ID and introducing concepts such as spans and traces.</li>
				<li><strong class="bold">Health</strong>: This<a id="_idIndexMarker816"/> is a standardized way to create liveness and readiness probes in order to instrument an application for checking the correct behavior of an application (when it's live, that is, to verify whether it is up or down) and its readiness (when it's ready to take requests).</li>
				<li><strong class="bold">Metrics</strong>: This <a id="_idIndexMarker817"/>is an API for providing facilities for exporting monitorable values from your applications. This is usually used for things such as capacity planning and overall understanding of the application performances (such as the number of current transactions).</li>
			</ul>
			<p>As you may have noticed, most of the preceding features exactly match what we highlighted in the <em class="italic">What's missing in Java EE</em> section.</p>
			<p>We will explore some of those techniques in more detail in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>.</p>
			<p>It's also important to highlight that MicroProfile encompasses specifications included in JEE (such as JAX-RS, JSON-B, and CDI, as we saw in the <em class="italic">Introducing the JEE standard</em> section). While MicroProfile tends to align the version of such shared libraries with one target JEE version, it may be that some of those versions are out of sync (being probably more up to date in the MicroProfile edition).</p>
			<p>It's also worth noticing that MicroProfile does not imply any specific packaging model for applications. Some implementations, such <a id="_idIndexMarker818"/>as <strong class="bold">Helidon</strong> (backed by Oracle) and Quarkus (backed by Red Hat) tend to use fat JARs and similar, while others, such as <strong class="bold">OpenLiberty</strong> (provided by IBM) and<a id="_idIndexMarker819"/> WildFly (provided by Red Hat) run in a more traditional way (deployed into a lightweight running server).</p>
			<p>For the upcoming sections, we will start seeing more about Quarkus, which is an implementation of the MicroProfile standard and is becoming more and more popular and widely used.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>Exploring Quarkus</h1>
			<p><strong class="bold">Quarkus</strong> is an<a id="_idIndexMarker820"/> open source Java framework that aims to be optimized for cloud-native and microservices. It was born in the container and <strong class="bold">Kubernetes</strong> world, and<a id="_idIndexMarker821"/> for this reason, it's been optimized by design for container and Kubernetes-based cloud-native applications.</p>
			<p>Quarkus comes from an engineering team with experience in many interesting projects, such as <strong class="bold">Hibernate</strong>, <strong class="bold">Vert.X</strong>, and <strong class="bold">RESTEasy</strong>, and <a id="_idIndexMarker822"/>so reuses a lot of good ideas and best practices<a id="_idIndexMarker823"/> from these<a id="_idIndexMarker824"/> famous communities.</p>
			<p>This is what a Quarkus application looks like when started from a terminal console:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_7.3_B16354.jpg" alt="Figure 7.3 – Quarkus starting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Quarkus starting</p>
			<p>As you can see, some<a id="_idIndexMarker825"/> spectacular ASCII art is shown and some interesting information, including the lightning-fast startup time of fewer than 1.5 seconds.</p>
			<p><em class="italic">But what are the most important benefits of Quarkus?</em></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>Better performances</h2>
			<p>One of the most famous <a id="_idIndexMarker826"/>benefits of Quarkus is its optimization. The framework was created with a <em class="italic">container-first</em> philosophy, and for this reason, it is heavily optimized both for startup time and memory usage. In order to achieve these objectives, Quarkus uses various techniques:</p>
			<ul>
				<li><strong class="bold">Less usage of reflection</strong>: Reflection can be impactful in terms of performance. Quarkus reduces the use of reflection as much as possible.</li>
				<li><strong class="bold">Move as much as possible to build time</strong>: Quarkus does as much work as possible at build time. This means that all the things that can be done in advance, such as class path scanning and configuration loading, are done at build time and persisted as bytecode. In this way, not only will the application boot faster (because it has fewer things to do), but it will also be smaller in terms of memory footprint because of all the infrastructure that is not needed at runtime; that is, the ones <em class="italic">precompiled</em> at build time are not part of the final artifact.</li>
				<li><strong class="bold">Native executables</strong>: Optionally, Quarkus applications can be directly compiled as Linux executables thanks to support <a id="_idIndexMarker827"/>from <strong class="bold">GraalVM</strong> (and the <strong class="source-inline">Substrate</strong> module). This allows further optimizations, further reducing the startup time and<a id="_idIndexMarker828"/> memory footprint.</li>
			</ul>
			<p>But better performance is not the only benefit of Quarkus.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>Developer joy</h2>
			<p>The thing that I like the most about Quarkus is its ergonomics. As is common to hear from people working with it, Quarkus feels new and familiar at the same time. The language is extremely friendly if you come from a JEE background. It offers a ton of tools and facilities, not to mention all the <em class="italic">syntactic sugar</em> that makes even the most advanced features easy to use. In the Quarkus world, this is<a id="_idIndexMarker829"/> referred to as <strong class="bold">developer joy</strong>.</p>
			<p>One of such facilities is<a id="_idIndexMarker830"/> the <strong class="bold">developer mode</strong>, which allows you to immediately see the changes in your application without needing a full recompile/repackage. It works like a charm when you change something (such as the source code, configuration file, and resources) and can immediately see the effect of such changes (such as simply refreshing the browser or recalling the API). I know this feature was already provided by other frameworks and<a id="_idIndexMarker831"/> libraries (with <strong class="bold">JRebel</strong> being one of the most famous), but the way it works out of the box is just magic for me, and, honestly, it's a great boost in terms of developer productivity.</p>
			<p>But that's not the only <em class="italic">developer joy</em> feature. Each dependency added to Quarkus (which are more properly called <strong class="bold">extensions</strong>) is <a id="_idIndexMarker832"/>crafted to nicely fit the Quarkus world and use the framework's capabilities, first of all in terms of performances.</p>
			<p>You will find a lot of facilities and conventions over configuration and <em class="italic">intelligent defaults</em>, such as the way the configuration is treated (including environment management), a simple way to use both the imperative and reactive paradigms (and make them coexist), and the way it interacts with databases (by using the <strong class="source-inline">Panache</strong> extension). <em class="italic">But where to start?</em></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/>Quarkus – hello world</h2>
			<p>Quarkus<a id="_idIndexMarker833"/> has a wizard<a id="_idIndexMarker834"/> for <a id="_idIndexMarker835"/>generating applications (both with <strong class="bold">Maven</strong> and <strong class="bold">Gradle</strong> support) located at <a href="http://code.quarkus.io">code.quarkus.io</a>. Follow these steps to create a new application:</p>
			<ol>
				<li value="1">You can create a new application with the command line by using the Maven Quarkus plugin. In the current version, this means using the following command:<p class="source-code"><strong class="bold">mvn io.quarkus:quarkus-maven plugin:1.12.2.Final</strong></p><p class="source-code"><strong class="bold">:create</strong></p></li>
				<li>The<a id="_idIndexMarker836"/> plugin will then ask for all the required information, such as the artifact name and the dependency to start with. The following screenshot illustrates this (please note the cool emoticons too):</li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_7.4_B16354.jpg" alt="Figure 7.4 – The Quarkus Maven plugin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – The Quarkus Maven plugin</p>
			<ol>
				<li value="3">After the <a id="_idIndexMarker837"/>plugin execution, you will have an application scaffold that you can use as a starting point (in this example, containing <strong class="source-inline">resteasy</strong> and <strong class="source-inline">hibernate</strong> dependencies). In order to run it and experiment with the developer mode, you can use the following command:<p class="source-code"><strong class="bold">./mvnw compile quarkus:dev</strong></p></li>
			</ol>
			<p>This command uses a Maven wrapper script (in this case, <strong class="source-inline">mvnw</strong>, because I'm running on a Linux box, but a <strong class="source-inline">mvnw.cmd</strong> file is provided for Windows environments) to run the application in <a id="_idIndexMarker838"/>development mode. Since you are using RESTEasy, by default the application will answer with a <strong class="source-inline">Hello RESTEasy</strong> string on the following endpoint: <strong class="source-inline">http://localhost:8080/hello-resteasy</strong>.</p>
			<p>In order to try the developer mode, you can change the source code (in this case, the <strong class="source-inline">GreetingResource</strong> class) to change the response. After you do that, you can refresh your browser and see the result without needing to recompile or repackage the code.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Building techniques with Quarkus</h2>
			<p>The<a id="_idIndexMarker839"/> development mode, needless to say, supports the development phase. In order to build and distribute Quarkus applications, you have other options.</p>
			<p>Quarkus is currently <a id="_idIndexMarker840"/>supported to run on OpenJDK (see the official website at <strong class="source-inline">quarkus.io/get-started</strong> for more information about the supported versions). In order to package your application, you can run the usual Maven command:</p>
			<p class="source-code">mvn clean package</p>
			<p>By default, Quarkus will build a so-called fast-jar. This is basically a package optimized for boot time performance and a small memory footprint. In order to execute an application packaged in this way, you will need to copy the whole <strong class="source-inline">quarkus-app</strong> folder (in the <strong class="source-inline">target</strong> folder), which contains all the libraries and resources needed to run the application. You can then run it with a similar command to this:</p>
			<p class="source-code">java -jar ./quarkus-app/quarkus-run.jar</p>
			<p>You can also package the application in an UberJar form (be conscious of all the limitations of this approach, as discussed in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>). To do so, one easy way is to pass the <strong class="source-inline">quarkus.package.uber-jar=true</strong> property to the Maven command:</p>
			<p class="source-code">mvn clean package -Dquarkus.package.uber-jar=true</p>
			<p>This property can also be set in the <strong class="source-inline">pom.xml</strong> file or in the configuration file of Quarkus (the <strong class="source-inline">application.properties</strong> file, by default).</p>
			<p>Last, but not least, as mentioned at the beginning of this section, Quarkus can be compiled <a id="_idIndexMarker841"/>into a native Linux executable without the JVM needing to be executed. To do so, you can simply use the following command:</p>
			<p class="source-code">./mvnw package –Pnative</p>
			<p>What Quarkus does under the hood is look for a GraalVM installation that is used for native compilation. The following screenshot shows what happens if we start Quarkus when the <strong class="source-inline">GRAALVM_HOME</strong> variable is not configured:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_7.5_B16354.jpg" alt="Figure 7.5 – Quarkus building a native executable through Podman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Quarkus building a native executable through Podman</p>
			<p>The <strong class="source-inline">GRAALVM_HOME</strong> variable is used to look up the install path of GraalVM. If not present, Quarkus will try a container build. This basically means that, if a container runtime (Podman or Docker) is installed on the local machine, Quarkus will download a container image to use for native building, so you can create a native executable without needing a local GraalVM installation.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>Configuration management in Quarkus</h2>
			<p>One lovely <a id="_idIndexMarker842"/>characteristic of Quarkus, in line with the <a id="_idIndexMarker843"/>developer joy idea, is the way it manages configurations.</p>
			<p>Quarkus implements the MicroProfile <strong class="source-inline">config</strong> specification. We will see more about the MicroProfile functionalities in Quarkus, but since <strong class="source-inline">config</strong> is central to all the other extensions, it's worth having a look at it now.</p>
			<p>In order to get and use a configurable value, you can use the following annotation:</p>
			<p class="source-code">@ConfigProperty(name = "test.myProperty", </p>
			<p class="source-code">  defaultValue="myDefault") </p>
			<p class="source-code">String myProperty;</p>
			<p>As you <a id="_idIndexMarker844"/>can see, you can provide a default value directly into the annotation.</p>
			<p>The configuration <a id="_idIndexMarker845"/>can be loaded by a number of different sources. Quarkus looks into the following sources (listed according to decreasing priority):</p>
			<ul>
				<li>System properties (as in passing a command-line argument to the Java process, such as <strong class="source-inline">–DmyProperty="myValue"</strong>) </li>
				<li>Environment variables</li>
				<li><strong class="source-inline">.env</strong> files (files containing a set of environment variables) in the working directory</li>
				<li>An <strong class="source-inline">application.properties</strong> file (with the usual properties syntax, as in <strong class="source-inline">key=value</strong>) placed in a <strong class="source-inline">config</strong> subdirectory in the working directory</li>
				<li>An <strong class="source-inline">application.properties</strong> file placed in <strong class="source-inline">src/main/resources</strong></li>
			</ul>
			<p>Quarkus supports the use of profiles in the configuration properties. This allows us to have different environments (or simply different sets of configurations) in the same configuration repository (such as in the same <strong class="source-inline">application.properties</strong> file). In order to do so, you can use a prefix in the configuration key, such as this:</p>
			<p class="source-code">%{profile}.mykey=value</p>
			<p>By default, Quarkus provides <strong class="source-inline">dev</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">prod</strong> profiles. <strong class="source-inline">dev</strong> is activated when running in developer mode (<strong class="source-inline">./mvnw compile quarkus:dev</strong>, as seen in the previous section), <strong class="source-inline">test</strong> is activated when running tests, and <strong class="source-inline">prod</strong> is activated in all other scenarios.</p>
			<p>You can define as many configuration profiles as you need and activate them by using the <strong class="source-inline">quarkus.profile</strong> system property or the <strong class="source-inline">QUARKUS_PROFILE</strong> environment variable.</p>
			<p>So far, we have seen the basics of Quarkus, the most relevant benefits (including performances and language goodies), and how to build a basic <strong class="source-inline">hello world</strong> example. In the next section, we will have a look at the most common Quarkus extensions that are useful for building cloud-native applications.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>Most common Quarkus extensions</h1>
			<p>Quarkus is<a id="_idIndexMarker846"/> aiming at cloud-native applications and microservices but shares some features and functionalities with the JEE world. This is thanks to its adherence to the MicroProfile specification.</p>
			<p>Such features are implementing common use cases and are very handy, as they allow you to use existing skills and, in some cases, existing JEE code.</p>
			<p>In this section, we will go through a quick overview of the Quarkus extensions shared with the JEE specification.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Content Dependency Injection</h2>
			<p><strong class="bold">CDI</strong> is a<a id="_idIndexMarker847"/> structured <a id="_idIndexMarker848"/>way to wire and compose the objects of your application. CDI in Quarkus<a id="_idIndexMarker849"/> is based on the Contexts and Dependency Injection for <strong class="bold">Java 2.0</strong> specification, which defines CDI for both Java SE and Java EE.</p>
			<p>The Quarkus CDI implementation leverages the ArC framework and is not fully compliant with the CDI specification, even if it provides support for the most common CDI use cases such as DI (of course), qualifiers, life cycle callbacks, and interceptors. There are some known limitations, on some specific use cases (such as the use of decorators, and the conversation scope). Following the Quarkus optimization mantra, ArC moves the discovery and injection operations at build time to achieve better performances.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>REST services with JAX-RS</h2>
			<p>In<a id="_idIndexMarker850"/> order to develop REST services, Quarkus<a id="_idIndexMarker851"/> provides a <strong class="bold">JAX-RS</strong> extension that mimics the Jakarta EE implementation almost completely. RESTEasy is commonly added by default in new Quarkus projects. However, in order to add these features to an existing Quarkus project, you can simply use this command:</p>
			<p class="source-code">./mvnw quarkus:add-extension -</p>
			<p class="source-code">  Dextensions="io.quarkus:quarkus-resteasy"</p>
			<p>As said, the <a id="_idIndexMarker852"/>JAX-RS implementation looks almost like the Jakarta EE implementation, so all the concepts we have seen in <a id="_idIndexMarker853"/>the previous section are still relevant (as previously mentioned, this will allow you to recycle skills and even existing code).</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>WebSockets</h2>
			<p>Quarkus <a id="_idIndexMarker854"/>includes the <strong class="bold">WebSocket</strong> support (as we have seen<a id="_idIndexMarker855"/> in the <em class="italic">Understanding the most common JEE APIs</em> section, under the <em class="italic">WebSockets</em> section). In detail, the WebSocket functionality is provided by the <strong class="source-inline">undertow-websockets</strong> extension. </p>
			<p><strong class="bold">Undertow</strong> is a <a id="_idIndexMarker856"/>highly performant web server technology written in Java. It can use both blocking and non-blocking APIs. Other than the WebSocket functionality (used by Quarkus), it provides other interesting web functionalities, such as full servlet API support. For this reason, Undertow is embedded into WildFly to provide web functionalities in full compliance with the JEE specification. Undertow has replaced Tomcat as the embedded web container in WildFly since <strong class="bold">version 8</strong>.</p>
			<p>In order to add the WebSocket functionality to an existing Quarkus project, you can use the following command:</p>
			<p class="source-code">./mvnw quarkus:add-extension -Dextensions="undertow-</p>
			<p class="source-code">  websockets"</p>
			<p>With this extension, you can use the WebSocket technology in the same way we saw in the <em class="italic">Understanding the most common JEE APIs</em> section, in the <em class="italic">WebSockets</em> section.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Messaging</h2>
			<p><strong class="bold">JMS messaging</strong> is<a id="_idIndexMarker857"/> currently a preview technology in the <a id="_idIndexMarker858"/>Quarkus world. It is currently provided by two extensions, <strong class="source-inline">quarkus-artemis-jms</strong> and <strong class="source-inline">quarkus-qpid-jms</strong>. </p>
			<p>The two dependencies are mostly equivalent from a functional point of view. Technically speaking, the <strong class="source-inline">quarkus-artemis-jms</strong> extensions use the <strong class="source-inline">artemis jms</strong> client to connect to the JMS broker, while <strong class="source-inline">quarkus-qpid-jms</strong> uses the AMQP standard as its wire protocol to connect to AMQP-compatible brokers.</p>
			<p>Unlike the JEE version, the Quarkus framework does not provide an injectable <strong class="source-inline">JMSContext</strong> object. But it does provide a JMS <strong class="source-inline">ConnectionFactory</strong> object, so you can easily get a producer from it, such as the following: </p>
			<p class="source-code">@Inject</p>
			<p class="source-code">ConnectionFactory connectionFactory;</p>
			<p class="source-code">...</p>
			<p class="source-code">JMSContext context = connectionFactory.</p>
			<p class="source-code">  createContext(Session.AUTO_ACKNOWLEDGE)</p>
			<p class="source-code">context.createProducer().send(context.createQueue("test"),"</p>
			<p class="source-code">  myTestMessage");</p>
			<p>Moreover, Quarkus does not provide the EJB subsystem, as it's provided in the JEE specification, so you cannot use MDBs, the classic way provided by JEE to consume messages. A quick and easy way to do so is to create a consumer (against a <strong class="source-inline">JMSContext</strong> object, as per the producer) and use the <strong class="source-inline">receive()</strong> method. Since it's a blocking call, you will have to create a new thread to encapsulate the receive logic without blocking the entire application. You'll need something like this:</p>
			<p class="source-code">JMSContext context = connectionFactory.</p>
			<p class="source-code">  createContext(Session.AUTO_ACKNOWLEDGE)) {</p>
			<p class="source-code">JMSConsumer consumer = context.createConsumer</p>
			<p class="source-code">  (context.createQueue("test"));</p>
			<p class="source-code">while (true) {</p>
			<p class="source-code">      Message message = consumer.receive();</p>
			<p class="source-code">      message.getBody(String.class);</p>
			<p class="source-code">}</p>
			<p>The <a id="_idIndexMarker859"/>basic configurations for getting a producer and <a id="_idIndexMarker860"/>consumer to work are the server endpoint, user, and password. Those configs are stored in <strong class="source-inline">quarkus.qpid-jms.url</strong>, <strong class="source-inline">quarkus.qpid-jms.username</strong>, and <strong class="source-inline">quarkus.qpid-jms.password</strong> when using <strong class="source-inline">quarkus-qpid</strong>, and in <strong class="source-inline">quarkus.artemis.url</strong>, <strong class="source-inline">quarkus.artemis.username</strong>, and <strong class="source-inline">quarkus.artemis.password</strong> when using <strong class="source-inline">quarkus-artemis</strong>.</p>
			<p>That's it! Now you can send and receive JMS messages with Quarkus.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Persistence</h2>
			<p><strong class="bold">Persistence</strong> and <a id="_idIndexMarker861"/>ORM in Quarkus are provided by Hibernate, making it basically JPA compliant. This means that you can then use the same <a id="_idIndexMarker862"/>syntax that we saw in the <em class="italic">Understanding the most common JEE APIs</em> section, in the <em class="italic">Persistence</em> section. You can annotate your Java objects (commonly referred to as POJOs) with <strong class="source-inline">@Entity</strong> and the other annotations that we have seen in order to specify mappings with database tables, and you can inject the <strong class="source-inline">EntityManager</strong> object in order to retrieve and persist objects to the database.</p>
			<p>To use Hibernate with Quarkus, you have to add the <strong class="source-inline">quarkus-hibernate-orm</strong> extension and a JDBC driver extension. The supported JDBC drivers are currently db2, Derby, H2, MariaDB, Microsoft SQL Server, MySQL, and PostgreSQL.</p>
			<p>The basic properties to configure the database connection are <strong class="source-inline">quarkus.datasource.db-kind</strong> (configuring the type of database used), <strong class="source-inline">quarkus.datasource.username</strong>, <strong class="source-inline">quarkus.datasource.password</strong>, and <strong class="source-inline">quarkus.datasource.jdbc.url</strong>.</p>
			<p>Although you can directly use Hibernate's <strong class="source-inline">EntityManager</strong>, Quarkus provides you with a more productive abstraction on top of it. This abstraction is Panache.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Accelerated ORM development with Panache</h2>
			<p><strong class="bold">Panache</strong> is <a id="_idIndexMarker863"/>an amazing<a id="_idIndexMarker864"/> technology provided with Quarkus. It allows us to build ORM applications without redundant boilerplate code. It's a boost for creating <strong class="bold">Create Read Update Delete</strong> (<strong class="bold">CRUD</strong>)-like<a id="_idIndexMarker865"/> applications in no time.</p>
			<p>In order to develop CRUD applications using Panache on top of Hibernate, you need to add the <strong class="source-inline">quarkus-hibernate-orm-panache</strong> extension.</p>
			<p>Once you have this functionality enabled, you can use it in two main patterns, <strong class="bold">Active Record</strong> and the <strong class="bold">repository</strong>.</p>
			<h3>Panache Active Record</h3>
			<p>Active Record is <a id="_idIndexMarker866"/>an architectural pattern. It was described by Martin Fowler in his <em class="italic">Patterns of Enterprise Application Architecture</em> book.</p>
			<p>In this pattern, one class completely represents a database table. An object created from this class represents a row (with fields mapping columns), while methods of the class map the interaction with the database, such as <strong class="source-inline">persist</strong>, <strong class="source-inline">delete</strong>, and <strong class="source-inline">find</strong>.</p>
			<p>In Quarkus, to implement this pattern, you must make your JPA entity (annotated with <strong class="source-inline">@Entity</strong>) extend the <strong class="source-inline">PanacheEntity</strong> class. You can then use all the methods inherited from this class in order to interact with the database, including features such as <strong class="source-inline">persist</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">find</strong> and <strong class="source-inline">list</strong>:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">public class MyPojo extends PanacheEntity {</p>
			<p class="source-code">@Id</p>
			<p class="source-code">private int id;</p>
			<p class="source-code">private String myField;</p>
			<p class="source-code">...</p>
			<p class="source-code">MyPojo pojo = new MyPojo(); </p>
			<p class="source-code">        pojo.setMyField ("This is a test"); </p>
			<p class="source-code">        pojo.persist();</p>
			<p class="source-code">MyPojo anotherPojo = MyPojo.findById(someId);</p>
			<p>The obvious advantage <a id="_idIndexMarker867"/>here is that you don't have to directly interact with the <strong class="source-inline">EntityManager</strong> class anymore, and you have a number of methods ready to use for common use cases. But if you don't like the Active Record pattern, you can achieve pretty similar results with the repository approach.</p>
			<h3>Panache repository</h3>
			<p>The repository<a id="_idIndexMarker868"/> pattern is an alternative to the Active Record one. Basically, instead of having both the entities and the methods (to find, update, delete, and persist objects) implemented in the same class, you split such responsibilities and have entities with no behavior and dedicated repository classes to implement database interactions.</p>
			<p>In the Quarkus world, this means that your entities are standard JPA entities (with no need to extend the <strong class="source-inline">PanacheEntity</strong> class), while your designated repository will need to implement the <strong class="source-inline">PanacheRepository</strong> interface. You can then use the same methods that we have seen before (<strong class="source-inline">persist</strong>, <strong class="source-inline">delete</strong>, <strong class="source-inline">find</strong>, and <strong class="source-inline">list</strong>) against the repository class:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">public class MyPojo{</p>
			<p class="source-code">@Id</p>
			<p class="source-code">private int id;</p>
			<p class="source-code">private String myField;</p>
			<p class="source-code">...</p>
			<p class="source-code">public class MyPojoRepository implements </p>
			<p class="source-code">  PanacheRepository&lt;MyPojo&gt; {</p>
			<p class="source-code">   public Person findByMyField(String myField){</p>
			<p class="source-code">       return find("myField", myField).firstResult();</p>
			<p class="source-code">   }</p>
			<p class="source-code">...</p>
			<p class="source-code">@Inject</p>
			<p class="source-code">MyPojoRepository myPojoRepository;</p>
			<p class="source-code">MyPojo pojo = new MyPojo(); </p>
			<p class="source-code">        pojo.setMyField ("This is a test"); </p>
			<p class="source-code">        myPojoRepository.persist(pojo);</p>
			<p class="source-code">MyPojo anotherPojo = myPojoRepository.findById(someId);</p>
			<p>As you can see, the <a id="_idIndexMarker869"/>repository pattern is analogous to the Active Record one.</p>
			<p>More complex relationships, such as one-to-many and many-to-many, can be modeled on an entity with the relevant annotations (in a similar way to what is doable with JPA), and can be retrieved and persisted with both the Active Record and Repository approaches. Moreover, Panache provides support<a id="_idIndexMarker870"/> for <strong class="bold">Hibernate Query Language</strong> (<strong class="bold">HQL</strong>) for complex queries. So far, we have learned about some of the Quarkus extensions and implemented basic APIs, similar to what we saw in the <em class="italic">Understanding the most common JEE APIs</em> section. Let's now see how Quarkus adds more features to those APIs by implementing the MicroProfile standard.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Quarkus and the MicroProfile standard</h1>
			<p>In this section, we<a id="_idIndexMarker871"/> are going to look at the MicroProfile standard and how Quarkus implements it. MicroProfile, as previously mentioned many times during this chapter (and in particular in the <em class="italic">Introducing MicroProfile</em> section), is a nice way to implement cloud-native microservices applications while adhering to a standard and hence avoiding vendor lock-in.</p>
			<p>Quarkus, in the current version, is<a id="_idIndexMarker872"/> compatible with the <strong class="bold">3.2 version</strong> of the MicroProfile specification. As we have seen, MicroProfile embraces and extends the JEE specification while providing features that are useful for cloud-native and microservices development.</p>
			<p>In the <strong class="bold">3.2 version</strong>, the most notable APIs in MicroProfile are as follows:</p>
			<ul>
				<li><strong class="bold">MicroProfile Config</strong>, which is implemented by the Quarkus configuration, which we saw a couple of sections ago</li>
				<li>CDI and JAX-RS, which we saw in the <em class="italic">The most common Quarkus extensions</em> and <em class="italic">Understanding the most common JEE APIs</em> sections</li>
				<li>MicroProfile Fault Tolerance, OpenAPI, Health, OpenTracing, and Metrics, which we will see in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em></li>
				<li>Other APIs, such<a id="_idIndexMarker873"/> as JWT authentication, Common Annotations, JSON-B, and JSON-P, which we will not cover</li>
			</ul>
			<p>This has completed our overview on traditional JEE middleware, such as WildFly, and cloud-native alternatives, such as Quarkus. Let's have a look at some examples now.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Case studies and examples</h2>
			<p>In this section, we <a id="_idIndexMarker874"/>will model a very small subset of our mobile payment application. To follow up on the concepts we have seen, we will see some examples created for WildFly and Quarkus. For both technologies, since we will be interacting with a database, we will use H2, which is an easy-to-use open source database. You will find all the code in the GitHub repository located at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java</a>.</p>
			<h3>Setting up the database</h3>
			<p>As we've said, the<a id="_idIndexMarker875"/> prerequisite for our application is to have a database up and running. To set it up, execute the following steps:</p>
			<ol>
				<li value="1">First, download the latest version of H2 from the <a href="http://www.h2database.com">www.h2database.com</a> website.</li>
				<li>You can then simply run the executable script for your platform, located under the <strong class="source-inline">bin</strong> directory. In my case, it was <strong class="source-inline">h2.sh</strong>. It will require a correctly installed JVM.</li>
				<li>After the database starts, the default browser will be opened, and the embedded H2 web console will be available. If you're using H2 for the first time, it will, by default, try to connect in the embedded mode and create a test database<a id="_idIndexMarker876"/> in your <strong class="source-inline">home</strong> directory. You can log in with the default login credentials (which are <strong class="source-inline">sa</strong> as the username, with no password). The following screenshot shows the web console login screen, with all the needed configurations:</li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_7.6_B16354.jpg" alt="Figure 7.6 – The H2 login form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – The H2 login form</p>
			<p>After you log in, you will be presented with a form to manipulate your newly created database. In order to create the <strong class="source-inline">payment</strong> table, you can copy and paste this SQL code into the SQL input form:</p>
			<p class="source-code">CREATE TABLE payment ( </p>
			<p class="source-code">   id  uuid default random_uuid() primary key,</p>
			<p class="source-code">   date DATE  NOT NULL, </p>
			<p class="source-code">   currency VARCHAR(20) NOT NULL, </p>
			<p class="source-code">   sender  uuid NOT NULL, </p>
			<p class="source-code">   recipient  uuid NOT NULL, </p>
			<p class="source-code">   signature VARCHAR(50) NOT NULL, </p>
			<p class="source-code">   amount DECIMAL  NOT NULL</p>
			<p class="source-code">);</p>
			<p>In this<a id="_idIndexMarker877"/> example, we are using H2 in embedded mode. This means that only one connection at a time will be allowed. So, before continuing with our examples, we will need to stop the <strong class="source-inline">H2</strong> Java process to allow WildFly to connect to the database. You can then reconnect with the web console by simply relaunching <strong class="source-inline">H2</strong> and using a different JDBC URL to connect in server mode. In my case, the string is as follows, and this allows more than one concurrent connection:</p>
			<p class="source-code">jdbc:h2:tcp://localhost/~/test</p>
			<p>Also, another option is to completely skip this part and leave the table creation to Hibernate by leveraging the <strong class="source-inline">hbm2ddl</strong> configuration. I don't love this option, but it's still a viable alternative.</p>
			<p>Moreover, consider that this is, of course, a simple example. In a real-world application, we would need some more tables (such as a <strong class="source-inline">user</strong> table). We would probably need to double-check our SQL statements with a DBA to check our data types against potential performance issues, depending on the expected volumes, or, most likely, we would have to interact with a database that's already been created for us. Now that we have a simple database, let's see how to interact with it by using WildFly. </p>
			<h3>JPA and REST with JEE and WildFly</h3>
			<p>In order to start <a id="_idIndexMarker878"/>developing our JEE application, you will need to start from an empty project (in our case, with Maven support). There are many ways to do that. The easiest one is to clone the project related to this chapter on GitHub and reuse the <strong class="source-inline">pom.xml</strong> and the project structure.</p>
			<p>As an alternative, you can install and use (see the <strong class="source-inline">Readme</strong> file from GitHub) the WildFly Maven archetype located at <a href="https://github.com/wildfly/quickstart">https://github.com/wildfly/quickstart</a>.</p>
			<p>The first step of our example is accessing the table we just created via JPA. To do so, you will have to create an entity mapping to the table. As we saw in previous sections, the syntax is pretty easy:</p>
			<p class="source-code">@Entity</p>
			<p class="source-code">public class Payment {</p>
			<p class="source-code">   @Id</p>
			<p class="source-code">  private String id; </p>
			<p class="source-code">  private Date date;</p>
			<p class="source-code">  private String currency;</p>
			<p class="source-code">  private String sender;</p>
			<p class="source-code">  private String recipient;</p>
			<p class="source-code">  private String signature;</p>
			<p class="source-code">  private float amount;</p>
			<p class="source-code">...</p>
			<p>As you see, we are using the same names defined in the database (both for identifying the table name, which <a id="_idIndexMarker879"/>corresponds to the class name, and the column names, which are linked to the class field names). Different mapping is possible with the proper annotations.</p>
			<p>In order to manipulate our entity, we are going to use the repository pattern. Hence, we will create a <strong class="source-inline">PaymentRepository</strong> class, inject <strong class="source-inline">EntityManager</strong>, and use it for JPA operations. For the sake of simplicity, we will simply implement the <strong class="source-inline">create</strong> and <strong class="source-inline">find</strong> functionalities, but of course, these can be extended to cover all other possible requirements, such as finding by column:</p>
			<p class="source-code">@PersistenceContext(unitName = "hosawjPersistenceUnit")</p>
			<p class="source-code">    private EntityManager em;</p>
			<p class="source-code">     public Payment create(Payment payment)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        em.persist(payment);</p>
			<p class="source-code">        return payment;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public Payment find(String id)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        Payment payment=em.find(Payment.class, id);</p>
			<p class="source-code">        return payment;</p>
			<p class="source-code">    }</p>
			<p>The last <a id="_idIndexMarker880"/>piece in this basic example is exposing the application using RESTful Web Services. To do so, we will need to create our <strong class="source-inline">PaymentResource</strong> class and annotate it accordingly, as we saw in the <em class="italic">REST services with JAX-RS</em> section:</p>
			<p class="source-code">@Path("/payments")</p>
			<p class="source-code">@Consumes(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">@Produces(MediaType.APPLICATION_JSON)</p>
			<p class="source-code">public class PaymentResource {</p>
			<p class="source-code">   @Inject</p>
			<p class="source-code">    PaymentRepository repository;</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    @Path("/find/{id}")</p>
			<p class="source-code">    public Response find(@PathParam("id") String id) {</p>
			<p class="source-code">        Payment payment=repository.find(id);</p>
			<p class="source-code">        if(payment==null)</p>
			<p class="source-code">            throw new WebApplicationException</p>
			<p class="source-code">              (Response.Status.NOT_FOUND);</p>
			<p class="source-code">        else    </p>
			<p class="source-code">         return Response.ok(payment).build();</p>
			<p class="source-code">    }</p>
			<p class="source-code">@POST</p>
			<p class="source-code">    @Path("/create")</p>
			<p class="source-code">    public Response create(Payment payment) {</p>
			<p class="source-code">        return Response.ok(repository.create(payment))</p>
			<p class="source-code">          .build();</p>
			<p class="source-code">    }</p>
			<p>The <a id="_idIndexMarker881"/>notable thing here is that the <strong class="source-inline">PaymentRepository</strong> class, which we created previously, is injected using CDI and used from within the other methods. The two other methods, implementing REST capabilities (<strong class="source-inline">find</strong> and <strong class="source-inline">create</strong>), are annotated with <strong class="source-inline">@GET</strong> and <strong class="source-inline">@POST</strong>. The parameters for the <strong class="source-inline">find</strong> method are passed as <strong class="source-inline">@PathParam("id")</strong>, using the relevant annotation. The parameter for the <strong class="source-inline">create</strong> method is passed as a <strong class="source-inline">Payment</strong> object. The JSON serialization and deserialization are handled out of the box. </p>
			<p>In order to activate the REST subsystem, as mentioned, the simplest way is to create a class that extends <strong class="source-inline">javax.ws.rs.core.Application</strong> and annotate it by defining the root application path, as follows:</p>
			<p class="source-code">@ApplicationPath("rest")</p>
			<p class="source-code">public class RestApplication extends Application</p>
			<p class="source-code">...</p>
			<p>Finally, we need to configure the connection between the application server and the database.</p>
			<p>WildFly ships with<a id="_idIndexMarker882"/> an example data source on H2, which is already configured in the default <strong class="source-inline">standalone.xml</strong> file. In order to configure the WildFly server to use the H2 database that we created in the previous section, we will have to change the <strong class="source-inline">jdbc</strong> connection string from <strong class="source-inline">jdbc:h2:mem:test</strong> to <strong class="source-inline">jdbc:h2:tcp://localhost/~/test</strong>.</p>
			<p>Moreover, we didn't set a password in the H2 server for the database connection, so you will need to remove it.</p>
			<p>To make our example application use such data source, you will need to change the <strong class="source-inline">persistence.xml</strong> JNDI name to the following:</p>
			<p class="source-code">java:jboss/datasources/ExampleDS</p>
			<p>In the same file, you will also need to set the <strong class="source-inline">hibernate</strong> dialect to H2:</p>
			<p class="source-code">&lt;property name="hibernate.dialect" </p>
			<p class="source-code">  value="org.hibernate.dialect.H2Dialect" /&gt;</p>
			<p>Now<a id="_idIndexMarker883"/> everything is ready for deployment. First of all, we will start WildFly (in this case, by simply running <strong class="source-inline">/bin/standalone.sh</strong>). Then, we will package the application using a simple <strong class="source-inline">mvn clean package</strong> command. For development purposes, we can then deploy the compiled <strong class="source-inline">.war</strong> file to WildFly by copying it into the <strong class="source-inline">/standalone/deployments</strong> directory in the WildFly installation folder.</p>
			<p>If everything worked correctly, you can then interact with REST services with this sample application. As an example, by using <strong class="source-inline">curl</strong> at the command line, you can create a payment like this:</p>
			<p class="source-code">curl -X POST -H 'Content-Type:application/json' </p>
			<p class="source-code">-d '{"id":"1ef43029-f1eb-4dd8-85c4-1c332b69173c", </p>
			<p class="source-code">"date":1616504158091, "currency":"EUR", "sender":"giuseppe@</p>
			<p class="source-code">test.it", "recipient":"stefano@domain.com", </p>
			<p class="source-code">"signature":"169e8dbf-90b0-4b45-b0f9-97789d66dee7", </p>
			<p class="source-code">"amount":100.0}'  http://127.0.0.1:8080/hosawj/rest/payments/</p>
			<p class="source-code">create</p>
			<p>You can retrieve it like this:</p>
			<p class="source-code">curl -H 'Content-Type:application/json' http://127.0.0.1:8080/</p>
			<p class="source-code">hosawj/rest/payments/find/1ef43029-f1eb-4dd8-85c4-1c332b69173c</p>
			<p>We have now created a simple but complete JEE example of a REST application interacting with a database using JPA. We will use the same application and see what will change when we use Quarkus.</p>
			<h3>JPA and REST (and more) with Quarkus</h3>
			<p>To create a <a id="_idIndexMarker884"/>skeleton application with Quarkus, using all the technology that we need, we can simply go to <strong class="source-inline">code.quarkus.io</strong> and select the technology that we need, which in our case is JAX-RS, <strong class="bold">Jackson</strong> (for JSON binding), and<a id="_idIndexMarker885"/> Hibernate (we will pick the version powered by Panache). Then, we can enter the group and artifact IDs, and click to download a <strong class="source-inline">.zip</strong> file with the right scaffold to start from.</p>
			<p>Another alternative is to use the Maven command line, as follows:</p>
			<p class="source-code">mvn io.quarkus:quarkus-maven-plugin:1.12.2.Final:create </p>
			<p class="source-code">-DprojectGroupId=it.test -DprojectArtifactId=hosawj </p>
			<p class="source-code">-DclassName="it.test.rest.PaymentResource.java" -Dpath="/</p>
			<p class="source-code">payments" -Dextensions="io.quarkus:quarkus-resteasy","io.</p>
			<p class="source-code">quarkus:quarkus-resteasy-jackson","io.quarkus:quarkus-</p>
			<p class="source-code">hibernate-orm-panache","io.quarkus:quarkus-jdbc-h2"</p>
			<p>This <a id="_idIndexMarker886"/>command is invoking the Quarkus Maven plugin, asking to create a new project, and defining the group ID and artifact ID to use. It specifies the name of a class exposing REST services and the path under which the services will be published. It also defines a number of extensions to be included, such as RESTEasy and Hibernate.</p>
			<p>Once the new project is created, you can copy and paste the code developed for JEE into this project. In particular, you can override the content of <strong class="source-inline">/src/main/java</strong>.</p>
			<p>For the CDI to work, we need to configure the database connection. You have to add the following properties in <strong class="source-inline">application.properties</strong>:</p>
			<p class="source-code">quarkus.datasource.db-kind=h2 </p>
			<p class="source-code">quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/~/test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</p>
			<p class="source-code">quarkus.datasource.username=sa</p>
			<p class="source-code">quarkus.hibernate-orm.database.generation=drop-and-create </p>
			<p class="source-code">quarkus.hibernate-orm.packages=it.test.model</p>
			<p>That's it! This is the bare-minimum change required to make the application work in Quarkus. You can launch it with this:</p>
			<p class="source-code">./mvnw clean compile quarkus:dev</p>
			<p>These are the test methods that are exposed as a REST service (take into account that the Quarkus application is deployed as the root context, so you will have to remove the name of the application – in our case, <strong class="source-inline">hosawj</strong> – from the REST endpoints). Of course, you can also package the application in any other way that we have seen (for example, in a native executable or as a fat JAR).</p>
			<p>But that's the<a id="_idIndexMarker887"/> simplest way to move a simple application from JEE to Quarkus. You are not using any advanced feature of Quarkus.</p>
			<p>A simple enhancement is to expose the OpenAPI and Swagger UI. It's trivial to enable these features. You just need to add the relevant extension:</p>
			<p class="source-code">./mvnw quarkus:add-extension -Dextensions="quarkus-smallrye-</p>
			<p class="source-code">openapi"</p>
			<p>The OpenAPI for your application will now be exposed here:</p>
			<p class="source-code">127.0.0.1:8080/q/openapi</p>
			<p>Swagger UI will now be exposed here:</p>
			<p class="source-code">127.0.0.1:8080/q/swagger-ui/</p>
			<p>Last, but not least, it's advisable to simplify the ORM part by using Panache. To do so, you can use the existing repository and simply make it extend <strong class="source-inline">PanacheRepository&lt;Payment&gt;</strong>. Then, you will automatically have a lot of convenient ORM methods available, and you don't have to explicitly manage <strong class="source-inline">EntityManager</strong>. Your repository will look like this:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">public class PaymentRepository implements </p>
			<p class="source-code">  PanacheRepository&lt;Payment&gt;{</p>
			<p class="source-code">    private Logger log =</p>
			<p class="source-code">      Logger.getLogger(this.getClass().getName());</p>
			<p class="source-code">     @Transactional</p>
			<p class="source-code">    public Payment create(Payment payment)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        log.info("Persisting " + payment );</p>
			<p class="source-code">        persist(payment);</p>
			<p class="source-code">        return payment;</p>
			<p class="source-code">    }</p>
			<p class="source-code">        public Payment find(String id)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        log.info("Looking for " + id );</p>
			<p class="source-code">        Payment payment=find("id", id).firstResult();</p>
			<p class="source-code">        log.info("Found " + payment );</p>
			<p class="source-code">        return payment;</p>
			<p class="source-code">    }</p>
			<p>It will be very<a id="_idIndexMarker888"/> easy to simply extend using methods provided by Panache. If you prefer, it will be also very easy to get rid of the repository and implement an Active Record pattern, as discussed in the <em class="italic">Accelerated ORM development with Panache</em> section.</p>
			<p>This will close our example section.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Summary</h1>
			<p>In this chapter, we have seen a very quick overview of the JEE specification and some very interesting alternatives, such as MicroProfile and Quarkus, which are certified MicroProfile implementations.</p>
			<p>We have learned about the JEE standard and why it's so popular. We also learned about the basic usage of the WildFly application server, along with some widely used JEE APIs, including RESTful Web Services, JMS messaging, and JPA persistence. We also learned about the MicroProfile standard, a modern alternative to JEE, and the Quarkus framework, which implements the MicroProfile standard. We also learned about some Quarkus extensions, including RESTful Web Services, JMS messaging, and persistence with Panache.</p>
			<p>We will see more Quarkus cloud-native features in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>.</p>
			<p>In the next chapter, instead, we will continue our discussion on the concept of middleware by having a look at the world of application integration.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Further reading</h1>
			<ul>
				<li>Snyk, <em class="italic">JVM Ecosystem Report</em> (<a href="http://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf">res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf</a>)</li>
				<li>David Delabassee, <em class="italic">Opening Up Java EE</em> (<a href="http://blogs.oracle.com/theaquarium/opening-up-ee-update">blogs.oracle.com/theaquarium/opening-up-ee-update</a>)</li>
				<li>Dimitris Andreadis, <em class="italic">JBoss AS7 Reloaded</em> (<a href="http://www.slideshare.net/dandreadis/jboss-as7-reloaded">www.slideshare.net/dandreadis/jboss-as7-reloaded</a>)</li>
				<li>Red Hat, <em class="italic">The WildFly Community Official Documentation</em> (<a href="http://docs.wildfly.org">docs.wildfly.org</a>)</li>
				<li>Eclipse Foundation, <em class="italic">The Jakarta EE Tutorial</em>, (<a href="http://eclipse-ee4j.github.io/jakartaee-tutorial">eclipse-ee4j.github.io/jakartaee-tutorial</a>)</li>
				<li>Red Hat, <em class="italic">Undertow</em> (<a href="http://undertow.io">undertow.io</a>)</li>
				<li>Martin Fowler, <em class="italic">Patterns of Enterprise Application Architecture</em></li>
				<li>The Linux Foundation, <em class="italic">OpenApi</em> (<a href="http://openapis.org">openapis.org</a>)</li>
				<li>SmartBear, <em class="italic">Swagger</em> (<a href="http://swagger.io">swagger.io</a>)</li>
			</ul>
		</div>
	</body></html>