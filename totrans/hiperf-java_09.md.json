["```java\npublic class MyCounter {\n  private int count = 0;\n  public synchronized void increment() {\n    count++;\n  }\n  public int getCount() {\n    return count;\n  }\n```", "```java\n  public static void main(String[] args) throws InterruptedException {\n    MyCounter counter = new MyCounter();\n    Thread t1 = new Thread(() -> {\n      for(int i = 0; i < 1000; i++) {\n        counter.increment();\n      }\n    });\n    Thread t2 = new Thread(() -> {\n      for(int i = 0; i < 1000; i++) {\n        counter.increment();\n      }\n    });\n```", "```java\n    t1.start();\n    t2.start();\n```", "```java\n    t1.join();\n    t2.join();\n```", "```java\n    System.out.println(\"Final counter value: \" + counter.getCount());\n  }\n}\n```", "```java\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\npublic class MessagePassingExample {\n  static class Message {\n    private final String content;\n    public Message(String content) {\n      this.content = content;\n    }\n    public String getContent() {\n      return content;\n    }\n  }\n```", "```java\nstatic class Sender implements Runnable {\n  private final BlockingQueue<Message> queue;\n  public Sender(BlockingQueue<Message> q) {\n    this.queue = q;\n  }\n  @Override\n  public void run() {\n    // Sending messages\n    String[] messages = {\"First message\", \"Second message\", \"Third \n    message\", \"Done\"};\n    for (String m : messages) {\n      try {\n        Thread.sleep(1000); // Simulating work\n        queue.put(new Message(m));\n        System.out.println(\"Sent: \" + m);\n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n      }\n    }\n  }\n}\n```", "```java\nstatic class Receiver implements Runnable {\n  private final BlockingQueue<Message> queue;\n  public Receiver(BlockingQueue<Message> q) {\n    this.queue = q;\n  }\n  @Override\n  public void run() {\n    try {\n      Message msg;\n      // Receiving messages\n      while (!((msg = queue.take()).getContent().equals(\"Done\"))) {\n        System.out.println(\"Received: \" + msg.getContent());\n        Thread.sleep(400); // Simulating work\n      }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    }\n  }\n}\n```", "```java\n  public static void main(String[] args) {\n    BlockingQueue<Message> queue = new ArrayBlockingQueue<>(10);\n    Thread senderThread = new Thread(new Sender(queue));\n    Thread receiverThread = new Thread(new Receiver(queue));\n    senderThread.start();\n    receiverThread.start();\n  }\n}\n```", "```java\n<dependency>\n    <groupId>io.projectreactor</groupId>\n    <artifactId>reactor-core</artifactId>\n    <version>3.4.0</version>\n</dependency>\n```", "```java\nimport reactor.core.publisher.Flux;\npublic class ReactiveExample {\n    public static void main(String[] args) {\n        Flux<String> messageFlux = Flux.just(\"Hello\", \"Reactive\", \n        \"World\", \"with\", \"Java\")\n                .map(String::toUpperCase)\n                .filter(s -> s.length() > 4);\n        messageFlux.subscribe(System.out::println);\n    }\n}\n```", "```java\nclass MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Thread executed by extending Thread \n        class.\");\n    }\n}\n// This is how we create and start a thread.\nMyThread thread = new MyThread();\nthread.start();\n```", "```java\nclass MyRunnable implements Runnable {\n    public void run() {\n        System.out.println(\"Thread executed by implementing Runnable \n        interface.\");\n    }\n}\n// Here, we create and start a thread.\nThread thread = new Thread(new MyRunnable());\nthread.start();\n```", "```java\nPublic class WaitNotifyExample {\n  private static class SharedResource {\n    private String message;\n    private boolean empty = true;\n    public synchronized String take() {\n      // Wait until the message is available.\n      while (empty) {\n        try {\n          wait();\n        } catch (InterruptedException e) {}\n      }\n      // Toggle status to true.\n      empty = true;\n      // Notify producer that status has changed.\n      notifyAll();\n      return message;\n    }\n    public synchronized void put(String message) {\n      // Wait until the message has been retrieved.\n      while (!empty) {\n        try {\n          wait();\n        } catch (InterruptedException e) {}\n      }\n      // Toggle the status to false.\n      empty = false;\n      // Store the message.\n      this.message = message;\n      // Notify that consumer that the status has changed.\n      notifyAll();\n    }\n  }\n  private static class Producer implements Runnable {\n    private SharedResource resource;\n    public Producer(SharedResource resource) {\n      this.resource = resource;\n    }\n    public void run() {\n      String[] messages = {\"Hello\", \"World\", \"Java\", \"Concurrency\"};\n      for (String message : messages) {\n        resource.put(message);\n        System.out.println(\"Produced: \" + message);\n        try {\n          Thread.sleep(1000); // Simulate time passing\n        } catch (InterruptedException e) {}\n      }\n      resource.put(\"DONE\");\n    }\n  }\n```", "```java\n  private static class Consumer implements Runnable {\n    private SharedResource resource;\n    public Consumer(SharedResource resource) {\n      this.resource = resource;\n    }\n    public void run() {\n      for (String message = resource.take(); !message.equals(\"DONE\"); \n      message = resource.take()) {\n        System.out.println(\"Consumed: \" + message);\n        try {\n          Thread.sleep(1000); // Simulate time passing\n        } catch (InterruptedException e) {}\n      }\n    }\n  }\n```", "```java\n  public static void main(String[] args) {\n    SharedResource resource = new SharedResource();\n    Thread producerThread = new Thread(new Producer(resource));\n    Thread consumerThread = new Thread(new Consumer(resource));\n    producerThread.start();\n    consumerThread.start();\n  }\n}\n```", "```java\nProduced: Hello\nConsumed: Hello\nProduced: World\nConsumed: World\nProduced: Java\nConsumed: Java\nProduced: Concurrency\nConsumed: Concurrency\n```", "```java\npublic class Counter {\n    private int count = 0;\n     public synchronized void increment() {\n        count++;\n    }\n     public synchronized int getCount() {\n        return count;\n    }\n}\n```", "```java\npublic void increment() {\n    synchronized(this) {\n        count++;\n    }\n}\n```", "```java\nimport java.util.concurrent.locks.ReentrantLock;\npublic class Counter {\n    private final ReentrantLock lock = new ReentrantLock();\n    private int count = 0;\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```", "```java\npublic class Flag {\n    private volatile boolean flag = true;\n    public boolean isFlag() {\n        return flag;\n    }\n    public void setFlag(boolean flag) {\n        this.flag = flag;\n    }\n}\n```", "```java\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class Counter {\n    private AtomicInteger count = new AtomicInteger(0);\n    public void increment() {\n        count.incrementAndGet();\n    }\n    public int getCount() {\n        return count.get();\n    }\n}\n```", "```java\nimport java.util.concurrent.atomic.AtomicReference;\nclass Node<T> {\n    final T item;\n    Node<T> next;\n    Node(T item) {\n        this.item = item;\n    }\n}\npublic class ConcurrentStack<T> {\n    AtomicReference<Node<T>> top = new AtomicReference<>();\n    public void push(T item) {\n        Node<T> newHead = new Node<>(item);\n        Node<T> oldHead;\n        do {\n            oldHead = top.get();\n            newHead.next = oldHead;\n        } while (!top.compareAndSet(oldHead, newHead));\n    }\n    public T pop() {\n        Node<T> oldHead;\n        Node<T> newHead;\n        do {\n            oldHead = top.get();\n            if (oldHead == null) {\n                return null;\n            }\n            newHead = oldHead.next;\n        } while (!top.compareAndSet(oldHead, newHead));\n        return oldHead.item;\n    }\n}\n```"]