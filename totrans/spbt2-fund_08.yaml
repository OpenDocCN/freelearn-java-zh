- en: Web Application Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序安全
- en: In this chapter, you will learn about the importance of security in web apps.
    We will investigate the responsibility of a programmer when adding security measures.
    Lastly, we will extend the functionality of the blogmania app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Web应用程序中安全性的重要性。我们将调查程序员在添加安全措施时的责任。最后，我们将扩展blogmania应用程序的功能。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Recognize the value of security in web applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到Web应用程序中安全性的价值
- en: Identify a programmer's role in web app security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定程序员在Web应用程序安全中的作用
- en: Assess in which areas Spring offers security solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估Spring在哪些领域提供安全解决方案
- en: Extend the blogmania app with access control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过访问控制扩展blogmania应用程序
- en: Securing Your Web Application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的Web应用程序
- en: Security is of the utmost importance in software development. This does not
    just apply to online banking or your personal health data – it even applies for
    very simple applications. Why is that so?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，安全性至关重要。这不仅适用于在线银行或你的个人健康数据——甚至适用于非常简单的应用程序。为什么会这样呢？
- en: 'Imagine that your web application has been a great success so far. Many people
    are using it, some may store their data in it. Then, disaster strikes: through
    a flaw in your software, an attacker is able to hijack the machine that your app
    is running on and abuse the machine for some evil purpose. Or, it turns out that
    people can read the diary entries of all users. It could become expensive for
    you; it could destroy customers'' trust in your software!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的Web应用程序迄今为止取得了巨大的成功。许多人正在使用它，有些人可能在其中存储他们的数据。然后，灾难降临：通过你软件中的一个漏洞，攻击者能够劫持运行你应用程序的机器，并滥用该机器进行一些邪恶的目的。或者，结果发现人们可以阅读所有用户的日记条目。这可能会给你带来高昂的费用；这可能会破坏客户对你软件的信任！
- en: Additionally, other security-related issues, such as the exposure of customer
    data from Ashley Madison dating website, credit card data theft in the millions,
    or even computer viruses, may come up as relevant sections worth talking about.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他与安全相关的问题，如Ashley Madison约会网站客户数据的泄露、数百万信用卡数据的盗窃，甚至计算机病毒，可能成为值得讨论的相关章节。
- en: Designing and operating secure software has to be a major aim from the very
    beginning. There are many aspects of security that are difficult to add later.
    Let's take a look at some of the possible threats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和操作安全的软件必须从一开始就是一个主要目标。有许多安全方面很难在之后添加。让我们看看一些可能的威胁。
- en: Threats to Software Security
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件安全威胁
- en: 'There are many threats to software security. The full section could easily
    fill a book of its own. In this chapter, we can only hope to gain a broad overview.
    The threats that we will look at can be coarsely categorized as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全面临着许多威胁。整个部分很容易填满一本书。在本章中，我们只能希望获得一个广泛的概述。我们将探讨的威胁可以粗略地分为以下几类：
- en: Interpret untrusted data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释不受信任的数据
- en: Allow access from foreign clients
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许外国客户端访问
- en: Allow access to resources not owned
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许访问非自身拥有的资源
- en: Insufficient logging and monitoring
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录和监控不足
- en: 'A great source for information on security for web applications is **OWASP**
    (**Open Web Application Security Project**). Pay particular attention to their
    list of *Top 10 Most Critical Web Application Security Risks*: [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序安全信息的一个很好的来源是**OWASP**（**开放Web应用程序安全项目**）。请特别注意他们列出的**“十大最关键Web应用程序安全风险”**：[https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
- en: Interpreting Untrusted Data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释不受信任的数据
- en: Whenever an application receives data from another application, there is the
    question of whether to trust that data or not. Sometimes, in a closed system,
    trusting others is the correct way to handle data, but in the majority of circumstances,
    some
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序从另一个应用程序接收数据时，都会有一个问题，即是否信任这些数据。有时，在一个封闭系统中，信任他人是处理数据的正确方式，但在大多数情况下，需要谨慎行事。
- en: caution is in order.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎行事。
- en: This is intentionally a wide category. OWASP lists multiple problems that can
    be subsumed in it. The general advice here is to check data carefully. There is
    no single way that any library could help with that. To make you aware of some
    of the possible issues, let's look at a non-exhaustive list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个故意很宽泛的分类。OWASP列出了许多可以包含在内的子问题。在这里的一般建议是仔细检查数据。没有任何一种库能够帮助解决这个问题。为了让你了解一些可能的问题，让我们看看一个非详尽的列表。
- en: Injection
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入
- en: '**Injection** means to allow a user to inject some of their code into your
    code. This is very rarely a good idea, and it is usually not on purpose. Two very
    prominent representatives of this are **XSS** (**Cross-Site Scripting using JavaScript**)
    and SQL injection. Usually, some text from a client is accepted for instance,
    in a simple text field in a form on a web page and is subsequently used without
    further processing. Now, imagine that the text entered into the form was as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If this text was then simply embedded into your web page, the text would not
    be displayed, but instead, this JavaScript would be executed! To avoid this, you
    can either be very conservative in what you accept, or you can escape the text
    in every output. The former is simpler, but may be a problem for the user; if
    you do not allow the less-than sign (<), then the user cannot use it, even for
    legitimate text. The latter requires you to escape the text everywhere; for instance,
    by using `<th:text>` in Thymeleaf, as we learned in *[Chapter 5](ae829ce0-b16f-454e-84c9-37eb73bc9de5.xhtml):
    Displaying Information Using Web Pages*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL injection is another problematic attack, particularly for old code that
    used to create SQL by string concatenation. The remedy is quite simple: use placeholders
    for your queries. We will see more of this in *[Chapter 9](7ca1da3d-1799-4c1a-b9cd-4456d2810267.xhtml):
    Persisting Data Using a Database*, when we discuss databases.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Insecure Deserialization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Insecure deserialization** has recently become a real problem. The scenario
    is that some data is meant to be passed between services (that are non-human clients).
    There are many formats to put this on the wire. In the previous chapter, you have
    learned about JSON as one such format, but two others which are widespread are
    XML and Java binary serialization.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Now, XML is a very versatile format. However, with great power comes great responsibility.
    The **entity** feature is most troublesome in untrusted contexts, and the recommendation
    is to use libraries that do not expand entities at the loss of functionality,
    or somehow sanitize the XML before parsing it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Java serialization is susceptible to bugs in the deserialization routines when
    the incoming data is manipulated. Many popular libraries contain fixes for this
    attack. All we can do is to make sure to always use up-to-date software.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Java serialization and deserialization is used widely in JMS and RMI. They work
    using a built-in mechanism; you have probably seen the serializable interface
    before. This is a fine method to convert an object in memory into a binary representation,
    transfer it over the wire, and convert the binary representation back to an object
    on the other side. However, if the sender creates a manipulated stream of bytes,
    the deserialization routine on the other side may be tricked into doing something
    unexpected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Access from Foreign Clients
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow access means to grant access to every client in a web application.
    It is a consequence of the way HTTP works, and is generally required for operation.
    One consequence is that the JavaScript that runs from a foreign site may be able
    to access the resources on our server. This usually is not what we want.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 允许访问意味着授予Web应用程序中每个客户端的访问权限。这是HTTP工作方式的结果，通常对于操作是必需的。一个后果是，来自外部站点的JavaScript可能能够访问我们服务器上的资源。这通常不是我们想要的。
- en: One possible attack is called **CSRF**, or **Cross-Site Request Forgery**. In
    its simplest form, imagine a malicious site posing as your banking site, even
    imitating the layout. After you have entered your credentials, the malicious site
    can save them for later mayhem, and, in the meantime log you into your real banking
    site. You will not even notice! Spring Security offers help to avoid CSRF attacks,
    and we will see how to do this later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的攻击被称为**CSRF**，或**跨站请求伪造**。在其最简单的形式中，想象一个恶意网站伪装成你的银行网站，甚至模仿布局。在你输入凭证后，恶意网站可以保存它们以备后用，同时登录你的真实银行网站。你甚至都不会注意到！Spring
    Security提供帮助以避免CSRF攻击，我们将在稍后看到如何做到这一点。
- en: Browsers implement the **Same-Origin-Policy** (**SOP**) to avoid many of these
    problems. It is, however, a quite rigid policy that may prohibit the legitimate
    sharing of resources between servers that you control yourself. **Cross-Origin
    Resource Sharing** (**CORS**) is a way to circumvent the SOP for your purposes.
    We will work with Spring Security's support to configure CORS later on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过实现**同源策略**（**SOP**）来避免许多这些问题。然而，这是一个相当严格的政策，可能会阻止您自己控制的多个服务器之间合法的资源共享。**跨源资源共享**（**CORS**）是为了绕过SOP而采取的一种方法。我们将在稍后与Spring
    Security的支持一起配置CORS。
- en: 'As so often with things relating to HTTP and the web, the Mozilla Developer
    Network is an excellent resource to get more information about SOP, CORS, and
    CRSF: [https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像与HTTP和网页相关的事情一样，Mozilla开发者网络是获取更多关于SOP、CORS和CRSF信息的优秀资源：[https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)。
- en: Allowing Access to Resources Not Owned
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许访问非自己拥有的资源
- en: 'A user may have access to things that he not have access to. For instance,
    a normal user should only see his own private information, not that of others,
    and he should not be able to access the administration interface. The key to accessing
    control is by using either **authentication** and **authorization**. These are
    supported very well by Spring security and are actually the bulk of this chapter.
    Take a look at the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能能够访问他不应该访问的东西。例如，普通用户应该只能看到他自己的私人信息，而不是他人的，而且他不应该能够访问管理界面。访问控制的关键是通过使用**认证**和**授权**。Spring安全提供了很好的支持，实际上这是本章的主要内容。请看以下表格：
- en: '![](img/8a3d1be3-572a-4745-8638-cf2ba1ec0726.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a3d1be3-572a-4745-8638-cf2ba1ec0726.png)'
- en: Insufficient Logging and Monitoring
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和监控不足
- en: This is not a threat in itself, but rather it's the failure to detect problems
    at runtime. Setting up firewalls; is more of a task for the operations department
    than for the software developer. Proper logging and monitoring can detect the
    beginning of an attack and allow for quick countermeasures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身不是一种威胁，而是未能检测到运行时的问题。设置防火墙；这更多的是操作部门的任务，而不是软件开发者的任务。适当的日志和监控可以检测攻击的开始，并允许快速采取对策。
- en: Authentication and Authorization
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: The terms authentication and authorization are frequently mixed up, but it is
    very helpful to know their exact meanings – and their differences.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权这两个术语经常被混淆，但了解它们的准确含义及其区别非常有帮助。
- en: The ultimate goal here is to find out whether the person sitting in front of
    the monitor is allowed to perform a certain task. First, we have to confirm the
    identity of the person, and after that, we can check whether this person has the
    necessary permissions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最终目标是确定坐在显示器前的人是否被允许执行某个任务。首先，我们必须确认这个人的身份，然后我们才能检查这个人是否有必要的权限。
- en: Authentication
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Authentication is the process of confirming a client's identity. There are a
    number of possible ways for a user to authenticate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是确认客户端身份的过程。用户有多种可能的认证方式。
- en: Spring Security will manage the classic login variants for us, and we will turn
    to that in the next section. It also has support for a number of different distributed
    logins, for example, `OAuth` and `OAuth2`, but that is out of the scope of this
    book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security将为我们管理经典的登录变体，我们将在下一节中转向这一点。它还支持许多不同的分布式登录，例如`OAuth`和`OAuth2`，但这本书的范围之外。
- en: 'Username-password authentication needs to address the following challenges:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名密码认证需要解决以下挑战：
- en: We need a user database of some sort. This can be an in-memory, hardcoded list,
    or it can come from an external database system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要某种类型的用户数据库。这可以是一个内存中的硬编码列表，或者它可以从外部数据库系统中获取。
- en: Besides the username, we need to store the password, but in a safe way. The
    general consensus is to not save the password at all, but a non-reversible hash
    instead. In the unfortunate event of a leakage in our database, it would then
    not be possible for the attacker to obtain the passwords; this is important because
    users tend to use the same (or a similar) passwords in different places.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了用户名外，我们还需要存储密码，但要以安全的方式。普遍的观点是根本不保存密码，而是保存一个不可逆的哈希值。在我们数据库不幸泄露的情况下，攻击者将无法获取密码；这很重要，因为用户往往在不同的地方使用相同的（或类似的）密码。
- en: In a web application, we must also think about how the authentication is sent
    from the browser to the server. One very important aspect is that the original
    password must travel over the wire (at least once), so we have to ensure that
    we are using a secure channel (communicating via HTTPS).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中，我们还需要考虑认证是如何从浏览器发送到服务器的。一个非常重要的方面是原始密码必须通过网络（至少一次）传输，因此我们必须确保我们正在使用一个安全的通道（通过HTTPS进行通信）。
- en: Authorization
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: After we have ascertained the identity of the user, we must check what he is
    allowed to do. This is called authorization, meaning that the user is authorized
    to do something.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确认了用户的身份之后，我们必须检查他允许做什么。这被称为授权，意味着用户被授权做某事。
- en: In a web application, it is important to handle two different aspects. Imagine
    a web application that has a private area for each user and an administration
    interface. It is quite obvious that we must prevent access to the administration
    interface for non-privileged users. This can be done by restricting the accessible
    paths in an application and **granting access** to only relevant paths. You will
    see how to do that with Spring Security's `WebSecurityConfigurerAdapter`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中，处理两个不同的方面很重要。想象一个为每个用户都有一个私有区域和行政界面的Web应用。很明显，我们必须防止非特权用户访问行政界面。这可以通过限制应用程序中可访问的路径并**授予访问权限**到相关路径来实现。你将看到如何使用Spring
    Security的`WebSecurityConfigurerAdapter`来完成这一点。
- en: 'Some URLs, however, are accessible to all users, but need to display different
    content. You would not want other people to see your private data! Some resources
    may react differently, depending on the user: an article may be limited to 1,000
    characters for normal users, but to 4,000 characters for premium users.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些URL对所有用户都是可访问的，但需要显示不同的内容。你不想让其他人看到你的私人数据！某些资源可能会根据用户的不同而有所不同：一篇文章可能对普通用户限制为1,000个字符，但对高级用户限制为4,000个字符。
- en: To handle this, you need to assign access rights to users, in other words, **grant
    permission**. One such model is to assign roles to users (such as `USER` or `ADMIN`)
    and restrict access to resources to certain roles. If you need very fine-grained
    control, you can also use the more powerful (but, alas, more difficult to handle)
    **Access Control Lists** (**ACLs**). Only in the most complicated scenarios would
    you need to check this by hand, though. Spring Security offers you some simple
    annotations to limit access to methods within Spring Beans.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，你需要为用户分配访问权限，换句话说，**授予权限**。一个这样的模型是为用户分配角色（例如`USER`或`ADMIN`）并限制对某些角色的资源访问。如果你需要非常细粒度的控制，你也可以使用更强大（但遗憾的是，更难处理）的**访问控制列表**（**ACLs**）。然而，只有在最复杂的场景中，你才需要手动检查这一点。Spring
    Security为你提供了一些简单的注解来限制Spring Bean中的方法访问。
- en: Examining Baby-step Security (1)
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查婴儿步安全（1）
- en: The aim is to analyze the difference between an unsecured and a secured web
    app. Let's say you want to see an app in an unsecured and a secured version, side
    by side, to compare them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是分析未加密和加密的Web应用之间的差异。假设你想看到应用在未加密和加密版本中并排展示，以便进行比较。
- en: 'Before beginning, you will need to load and start the Security-Intro app found
    at [https://bit.ly/2REovBW](https://bit.ly/2REovBW). Start the app. Fire up the
    homepage in the browser and make a REST call to `/api/messages.json` in Postman,
    to see that both are easily accessible. (You can find the Postman configuration
    in the chapter''s folder, as well, if you need it). The steps for completion are
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要加载并启动位于 [https://bit.ly/2REovBW](https://bit.ly/2REovBW) 的 Security-Intro
    应用程序。启动应用程序。在浏览器中打开主页，并在 Postman 中对 `/api/messages.json` 进行 REST 调用，以查看它们都很容易访问。（如果你需要，你还可以在章节文件夹中找到
    Postman 的配置）。完成步骤如下：
- en: 'Locate the POM and add the following dependency to its `<dependencies>` section:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 POM 并在其 `<dependencies>` 部分添加以下依赖项：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let IntelliJ re-import the POM and restart the application.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 IntelliJ 重新导入 POM 并重新启动应用程序。
- en: Navigate to the web version and make the REST call again.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到网页版本并再次进行 REST 调用。
- en: 'You will make the following two observations:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你将观察到以下两点：
- en: The web version now shows a login page.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页版本现在显示登录页面。
- en: 'Take a look at the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图：
- en: '![](img/593aa361-40e3-4eaf-93fe-a5591e76f0e3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/593aa361-40e3-4eaf-93fe-a5591e76f0e3.png)'
- en: The REST call resulted in **401 Unauthorized**.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 调用导致 **401 未授权**。
- en: Go to [https://bit.ly/2ylvMzt](https://bit.ly/2ylvMzt) to access the complete
    code for the `SecurityIntroApplicationTests.java` file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2ylvMzt](https://bit.ly/2ylvMzt) 访问 `SecurityIntroApplicationTests.java`
    文件的完整代码。
- en: Spring Security
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: After a short overview of the different aspects of security, let's turn to Spring
    again, and the way that it addresses some of the issues mentioned previously.
    Note that many security problems actually stem from the erroneous behavior of
    the application and cannot be solved by just using a library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要概述了安全的不同方面之后，让我们再次转向 Spring，并看看它是如何解决之前提到的一些问题的。请注意，许多安全问题实际上源于应用程序的错误行为，而不仅仅是使用库就能解决的。
- en: The last two will only be covered quite briefly, as there is not much to say
    about them. The bulk of this section will, therefore, be about authentication
    and authorization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点将只简要介绍，因为关于它们没有太多可说的。因此，本节的大部分内容将关于身份验证和授权。
- en: Even if we meticulously took care to differentiate the two words, the concepts
    could not be demonstrated in isolation, as the effects of the one only become
    apparent through the other. Let's start by adding Spring Security to the project
    and look at the effects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们小心翼翼地区分这两个词，由于一个的效果只有通过另一个才能显现，因此这些概念无法孤立地展示。让我们首先将 Spring Security 添加到项目中，并观察其效果。
- en: 'Spring Security is a sub-project of the Spring platform, just like Spring Web
    MVC, which was introduced in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)*:
    *The MVC Pattern*. It has a release cycle of its own. When using Spring Boot,
    you do not have to care about that, as the Spring Boot dependency management will
    resolve to a tried and tested version. Only in rare cases should you have the
    need to manually include the required dependencies and specify their version numbers.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 是 Spring 平台的一个子项目，就像 Spring Web MVC 一样，它在*[第 4 章](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)*：*MVC
    模式*中介绍过。它有自己的发布周期。当使用 Spring Boot 时，你不必关心这一点，因为 Spring Boot 依赖关系管理将解析为经过测试和验证的版本。只有在极少数情况下，你可能需要手动包含所需的依赖关系并指定它们的版本号。
- en: The Magic of Auto-Configured Spring Security
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置 Spring Security 的魔法
- en: 'Adding Spring Security to a Spring Boot project is very simple. It comes with
    a default configuration that is very secure and is most definitely unsuitable
    for any real purpose. All you have to do is add the respective starter POM:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Security 添加到 Spring Boot 项目中非常简单。它附带一个默认配置，非常安全，绝对不适合任何实际用途。你所要做的就是添加相应的启动
    POM：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The starter POM has transitive dependencies on all necessary artifacts. Now,
    upon starting, a Spring Boot application will print out a line like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 POM 对所有必要的工件有传递依赖。现在，在启动时，Spring Boot 应用程序将打印出如下一行：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Access to any resource, whether with a web browser or a REST client, will be
    secured.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何资源，无论是通过网页浏览器还是 REST 客户端访问，都将受到保护。
- en: Tight Spring Security Defaults
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密的安全默认设置
- en: 'A lot is happening behind the scenes here. The following list is not quite
    exhaustive, but it contains all of the information that you normally need to know:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后发生了很多事情。以下列表并不完全详尽，但它包含了你通常需要知道的所有信息：
- en: Installed a security filter chain
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了安全过滤器链
- en: Handling all requests
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理所有请求
- en: Some fallback user repositories and a login page
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些回退用户存储库和登录页面
- en: The magic is part of Spring Boot here, which will create all the necessary Beans
    for using Spring Security. This is the auto-configuration feature that you already
    know about, which can create Beans as soon as the necessary classes are found
    on the classpath and, launch post-construct setup routines to wire it all in.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法是Spring Boot的一部分，它将为使用Spring Security创建所有必要的Beans。这就是您已经了解的自动配置功能，它可以在类路径上找到必要的类时立即创建Beans，并启动构造后设置例程来连接它们。
- en: 'First, it installs a servlet filter (as introduced in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml):
    The MVC Pattern*). This filter intercepts each request and adds the necessary
    security. This is a Spring Bean with the type `DelegatingFilterProxyRegistrationBean`
    and the name `springSecurityFilterChain`. As the names already suggest, these
    are not simple filters, but are chains of filters, with each adding a bit of functionality.
    These chains are constructed automatically.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它安装了一个servlet过滤器（如*[第4章](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)：MVC模式*）中所述）。这个过滤器拦截每个请求并添加必要的安全性。这是一个类型为`DelegatingFilterProxyRegistrationBean`、名称为`springSecurityFilterChain`的Spring
    Bean。正如名称所暗示的，这些不是简单的过滤器，而是过滤器链，每个过滤器都增加了一部分功能。这些链是自动构建的。
- en: 'The filter is configured to secure all requests by default, and all with the
    same level of security. There is one notable exception: the login page that you
    are confronted with when you try to access the web part of the application.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，过滤器被配置为通过相同的级别保护所有请求。有一个值得注意的例外：当你尝试访问应用程序的Web部分时，你会遇到的登录页面。
- en: The repository of users for the application is kept in-memory, and there is,
    in fact, only one user in the system. Its name is **user**, and its password is
    chosen at random upon the start of the application; it is in the form of a UUID.
    This is secure, but it is a bit unwieldy in practice. This default was chosen
    so that adding the dependency would actually make a difference and force users
    to choose their own configurations, instead of leaving the system as insecure
    as before.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的用户存储库保存在内存中，实际上系统中只有一个用户。它的名字是**user**，密码在应用程序启动时随机选择；它以UUID的形式存在。这是安全的，但在实践中有点难以操作。选择这个默认设置是为了确保添加依赖项实际上会有所不同，并迫使用户选择自己的配置，而不是让系统像以前一样不安全。
- en: The results of these measures are quite different for the REST and the web versions,
    so we will look at them one by one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些措施的结果对于REST和Web版本相当不同，所以我们将逐一查看。
- en: Securing REST with Basic Auth
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本认证保护REST
- en: After introducing Spring Security to the project, accessing a REST resource
    started to result in **401 Unauthorized**. This is what the security filter will
    produce when no means of authentication is provided. In case you are wondering,
    yes, you are **not authorized** to access this resource, but it is primarily because
    you could not **authenticate** yourself to the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Spring Security引入项目后，访问REST资源开始导致**401未授权**。这是当没有提供身份验证手段时安全过滤器将产生的结果。如果您在疑惑，是的，您**没有权限**访问此资源，但这主要是因为您无法**认证**自己到系统中。
- en: 'Along with the response, the server also sent a header, `WWW-Authenticate:
    Basic realm="Realm"`, to tell the client what to do about the situation. The answer
    tells us that we should use a procedure called **Basic Auth** and use the **Realm**
    realm for it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '除了响应之外，服务器还发送了一个头信息，`WWW-Authenticate: Basic realm="Realm"`，以告诉客户端如何处理这种情况。答案告诉我们应该使用一个称为**基本认证**的程序，并使用**域**域进行认证。'
- en: The Basic Auth scheme is the simplest form of authentication. It does not require
    cookies or storage on the server. The client sends the credential with every request
    in the authorization header. The password is not hashed or encrypted, but only
    Base64 encoded; therefore, a secure connection is advisable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证方案是认证的最简单形式。它不需要cookies或服务器上的存储。客户端在每次请求的授权头中发送凭据。密码没有被散列或加密，只是Base64编码；因此，建议使用安全连接。
- en: A realm can be used to access different areas of a server with different credentials.
    It is rarely used; most servers have only one realm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个域来使用不同的凭据访问服务器的不同区域。这很少使用；大多数服务器只有一个域。
- en: For **REST clients**, this is a simple yet effective way to authenticate. Postman
    allows you to set the credentials easily, as do command-line tools, such as **cURL**.
    Neither client nor server needs to store any tokens, so the process is completely
    stateless.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: For **web browsers**, this scheme works, but not comfortably. Browsers will
    present the user with a dialog box to input the credentials, but this belongs
    to the browser, and does not share the look and feel of the web page. Also, there
    is no way to log out again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Basic Auth requires validation of the password for every request. Modern password
    hashing is intentionally slow, to improve security. It is therefore recommended
    to exchange the password for some shorttime credentials, such as the session,
    even for REST calls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Securing Web Browsing in the Session
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing Spring Security to the project, accessing a secured web page
    started to issue a **302 Found** with a location header, and the browser redirected
    us to the given page. The very basic login form that we see there is a built-in
    fallback from Spring Security. Entering credentials there will POST them to another
    built-in endpoint that will then check the credentials and add them to the session.
    To identify this session in subsequent requests, a cookie, called JSESSIONID,
    is set.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Sessions are supported by all servlet containers, such as Tomcat, and are a
    place to store some ephemeral data for a returning user. In today's environments,
    sessions are used mostly to identify the user, and nothing more. Storing real
    data may bring problems to scalability if there is no central session store.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme is more versatile: a web page can use a login form of its own or
    embed the login form into a landing page. Also, the user can log out. However,
    it requires some storage of the session and its identifier in both the server
    and client, and is thus not 100% stateless.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Examining Baby-step Security (2)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize the secured web app. Let's say you have a secured app
    and want to log in. Before beginning, start (or restart) the application from
    the previous sub-section and navigate to `http://localhost:8080/`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Copy the password, which is in a UUID format.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the log view in IntelliJ, there is a line (that stands out because there
    are empty lines around) that starts with Using generated security password.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, enter `user` as the username and the copied `password` as the
    password.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now logged in and can view the homepage. (If you forgot to reload the
    form in between, the first login may fail. Just do it again, in this case.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In Postman, in the **Authorization** pane, choose Basic Auth from the drop-down
    menu, or load the authenticated version from the Postman collection.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, enter the credentials as before.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on Preview Request, you can show the header in the **Headers**
    pane.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you send the request, the data is again returned as shown in the following
    screenshot:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/92c60b12-4af0-436c-84d1-22272ee8bc16.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92c60b12-4af0-436c-84d1-22272ee8bc16.png)'
- en: You can see that the data is returned because the authorization header was set
    correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到数据被返回，因为已正确设置了授权头。
- en: Explicit Configuration
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确配置
- en: 'That was quite a lot at once. To customize the behavior, let''s first reproduce
    the default configuration of Spring Security by hand. It will then be obvious
    what to change if we have different needs. To do that, we will need the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次内容很多。为了自定义行为，让我们首先手动重现Spring Security的默认配置。如果我们的需求不同，那么将很明显需要更改什么。为此，我们需要以下内容：
- en: A configuration class to handle security aspects
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理安全方面的配置类
- en: Code containing the HTTP security
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含HTTP安全的代码
- en: A login form and a mapping function to display it
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个登录表单和一个映射函数来显示它
- en: A user repository with a dummy user
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有虚拟用户的用户仓库
- en: Security Configuration Entry Point
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全配置入口点
- en: 'The recommended way to configure Spring Security in Spring Boot is to extend
    the `WebSecurityConfigurerAdapter` class, which offers plugin points to access
    various aspects. Let''s take a look:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot中配置Spring Security的推荐方法是扩展`WebSecurityConfigurerAdapter`类，它提供了插件点以访问各种方面。让我们看看：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see that we also mark this class as a Spring Boot `@Configuration`
    class and enable the security scheme by using `@EnableWebSecurity`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还将此类标记为Spring Boot的`@Configuration`类，并通过使用`@EnableWebSecurity`启用安全方案。
- en: You may wonder why `@EnableWebSecurity` is necessary at all, if enabled security
    is the default. You are right – it isn't. Still, it is customary to make it explicit.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，如果启用安全是默认的，为什么`@EnableWebSecurity`是必要的。您是对的——它不是。尽管如此，通常还是要明确指出。
- en: If, for some reason, you want to disable all of Spring Boot's automatic security
    configuration, even though you have Spring Security included in your project,
    you have to disable it explicitly in your main application class, using `@SpringBootApplication(exclude
    = SecurityAutoConfiguration.class)`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您想禁用Spring Boot的所有自动安全配置，即使您的项目中包含了Spring Security，您也必须在主应用程序类中显式禁用它，使用`@SpringBootApplication(exclude
    = SecurityAutoConfiguration.class)`。
- en: Adding Hardcoded Users
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加硬编码的用户
- en: 'To manage the authentication source, we use the `AuthenticationManagerBuilder`,
    which we get as an argument to the `configure()` method. We will start with **in-memory**
    authentication, that is, the user list does not come from external sources, but
    is pre-loaded. Take a look at the following code example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理认证源，我们使用`AuthenticationManagerBuilder`，它是`configure()`方法的一个参数。我们将从**内存**认证开始，也就是说，用户列表不是来自外部源，而是预先加载的。请看以下代码示例：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The injection builder auth gives us functions that harmonize with autocompletion
    in the IDE. The `inMemoryAuthentication()` creates the **in-memory** store, and
    `withUser()` adds a user to the system, using the same name as before, but with
    a slightly easier password for playing around.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注入构建器auth为我们提供了与IDE中的自动补全功能相协调的函数。`inMemoryAuthentication()`创建**内存**存储，而`withUser()`则将一个用户添加到系统中，使用与之前相同的名称，但密码稍容易一些，以便进行试验。
- en: The password is given explicitly. Therefore, it is present in the code in plain
    text. This is not a secure configuration and is only used to get us started in
    the absence of a database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 密码是明确给出的。因此，它在代码中以明文形式存在。这不是一个安全的配置，并且仅在数据库不存在的情况下用于启动。
- en: The password is now set to something more memorable than the ever-changing UUID.
    This user has the USER role; this is used to authorize resources, as we will see
    shortly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在密码被设置为比不断变化的UUID更容易记住的东西。此用户具有USER角色；这用于授权资源，正如我们很快将看到的。
- en: When you start the application now, it will still print out a generated password.
    This is **not** the user and password that are used now. It just means that `UserDetailsServiceAutoConfiguration`
    still creates a `UserDetailsService` Bean, which is, however, unused. We will
    replace that Bean with our own implementation later on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在启动应用程序时，它仍然会打印出一个生成的密码。这**不是**现在使用的用户和密码。这仅仅意味着`UserDetailsServiceAutoConfiguration`仍然创建了一个`UserDetailsService`
    Bean，然而这个Bean却是未使用的。稍后我们将用我们自己的实现替换这个Bean。
- en: Locking Paths with Basic Auth
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本认证锁定路径
- en: 'To lock and allow access to HTTP resources (web pages or API endpoints), we
    use an `HttpSecurity` object, which we get as an argument to another `configure()`
    method (it is overloaded with some other, less frequently used configuration objects).
    First, we want to lock all URLs to users that have the `USER` role, just like
    our predefined user:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With `authorizeRequests()`, we introduce the path matchers section. The `antMatchers()`
    is a function that takes any number of paths in Ant-style, and finally, `hasRole()`
    specifies the condition of the user. In this case, the paths have a certain role.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Apache Ant ([https://ant.apache.org/](https://ant.apache.org/)) was a widely
    popular Java build system, a predecessor to both Maven and Gradle. It introduced
    a style of specifying paths, sub-paths, and files that is different from the usage
    of the asterisk in the shell. It is easy, yet very versatile; the pattern "/**"
    here means "starting from the root, match everything."
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The roles in Spring Security are simple Java strings. This may cause trouble
    if you misspell them, so, for real-life applications, you should create an enumeration
    and use its string value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We have now locked everything, but do not have a means to actually authenticate.
    This is added with the simple `httpBasic()` invocation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now secured and accessible using Basic Auth.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Login
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic auth that secures the app now works fine, but the user experience
    is poor. The user expects a **login form** that is part of the application, and
    probably a means to log out again. We will now add the following details:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Login form
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default: GET /login'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can have as many as needed
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username & password
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mysterious `_csrf` field
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send to login controller
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default: `POST /login`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minimum login form that Spring requires is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apart from the mysterious `_csrf` field, which will be explained in the next
    section, this is a very basic form with just two parameters (username and password),
    which will be `POSTed` to the `/login` URL.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We can have as many of these forms as we like, (to embed them into other pages,
    for example), as long as they POST their input to the right receiver. Many applications,
    however, feature an additional separate login page. This will be the page that
    the users are redirected to if they try to view a page that they cannot access.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'This might be because their session is expired, or they may have entered an
    incorrect password on the first try. The page will then be called with an added
    `?error` parameter. In a Thymeleaf template, we can evaluate that. Consider the
    following Thymeleaf HTML:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first `<div>` containing the error message will only be shown when `loginError`
    is set. The full file (including more markup to improve the representation) can
    be found in the `login.html` file, alongside all of the other code for this chapter,
    in [https://bit.ly/2DGVgvE](https://bit.ly/2DGVgvE).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The login page that we just created is not yet mapped, so we need to add this
    method in some controller class as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, this method would be trivial if we did not add a little error
    handling. By default, Spring will call the login page with `/login?error` if an
    error occurred, so we evaluate this optional parameter and put an attribute into
    the model; this attribute is used to display the error message in the form. You
    can find the source code for this in the class `HomePageController`, in the source
    code distribution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains is to tell Spring Security to actually use our login page. For
    this, we need to add form-based authentication to the HTTP security. Another thing
    to consider is that access to the login form itself must be granted to everyone,
    or it will not be possible to log in at all. The complete configuration method
    will then look like as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Failure to allow unauthenticated access to the login page itself and all of
    the resources it needs, be it CSS, JavaScript, or images, will result in a non-functional
    application. There will be an infinite number of redirects, which the browser
    will hopefully interrupt at some point.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The first new line permits access for all clients, for a number of new Ant patterns.
    In addition to the login page itself, we also grant access to the static resources
    needed for a nicer display.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The other new line configures a form login, in addition to the existing basic
    auth login, and specifies the login page with the path we used. (It is actually
    the default, but it is better to be explicit here.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Logout
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users need to log out of the application, either for security reasons or to
    log in as another user. This can be easily accomplished, for instance, with the
    following snippet from the security introduction app (`index.html`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The gist of this code is that we need to issue a POST request to the `/logout`
    URL, which is the configurable default for this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Web Security
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider that you have a web app that has web security configured. You want
    to change which pages you can access freely, and which you can only access with
    authentication. You should try to avoid the traps. The aim here is to explore
    the effects of using the `HttpSecurity` object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Before beginning, load and start the Blogmania app from the folder [https://bit.ly/2PmyyPF](https://bit.ly/2PmyyPF).
    Note that you cannot access it without logging in, as you are redirected to the
    login page immediately. After logging in, you can enter the start page. You can
    log out again.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the `SecurityConfiguration` class, find the `configure(HttpSecurity http)`
    method.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, try to tighten the security by removing the call that (suspiciously)has
    an entry that looks as if it will allow anyone in! The body should now look as
    follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Start the application and reload.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That didn't work at all. If you have the browser's developer tools open, you
    will see that it was redirecting until it decided to break the cycle. What happened?
    Oh, we disallowed access to the login page itself!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c1c072f-e6d4-4bc0-ab49-4dc927158daf.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Try the opposite. Re-add the line (use `undo`), and instead, remove the requirement
    for a specific role.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By pressing *Ctrl + spacebar*, IntelliJ will show you the full list of possibilities.
    Simply choose to permit all, and the result will be as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Start the application and reload.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that now, you can view all pages without being logged in. You can still
    navigate to `/login` and perform the login. However, there will be no visible
    difference. (There is only a difference behind the scenes.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Method-Level Security
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous configuration, we used web security; that is, we applied the
    security configuration to URLs. Since Spring Security''s pluggable architecture
    is not limited to web applications, there must be another way to control access:
    **method-level security**.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Even though method-level security can be configured in XML, it is better known
    under the name of annotation-based security. This is, of course, because its widespread
    use came with Spring's `@Secured` annotation. These days, there are three different
    sets of annotations, and first we'll look at the annotation that is easiest to
    use.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Roles Allowed
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first annotation comes from JSR-250 ([https://jcp.org/en/jsr/detail?id=250](https://jcp.org/en/jsr/detail?id=250))
    and is called `@RolesAllowed`. It is very easy to use as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The annotation takes the name of a role (or a list, thereof) and limits calls
    to `performSecure` to authenticated users that also have the USER role. If the
    method is called and the constraint for the USER role is not satisfied, a runtime
    exception, `AccessDeniedException`, will be thrown instead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Enable @RolesAllowed
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method-level security is not enabled in Spring Security by default. You have
    to modify it in a configuration class, preferably your security configuration
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This annotation is the simplest, but it is also the most limited form of access
    control with annotations. If your needs surpass the capabilities of `@RolesAllowed`,
    Spring Security offers some more security features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Securing Controllers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can secure all public methods in Spring Beans with annotations. So, assuming
    that we control access to mapping methods in Spring MVC controllers, how is that
    different from using the `HttpSecurity` configuration?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it isn''t. It is mainly a matter of style. Take a look at the following
    table:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e30aaab-1845-4d9c-a00e-26ad7589e18f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: The Original @Secured Method
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security''s original annotation for method-level security is called
    `@Secured`. It has to be enabled with `@EnableGlobalMethodSecurity (securedEnabled
    = true)`, to be used. The argument to the annotation is passed to an `AccessDecisionManager`
    to make the final decision. You can allow access to all authenticated authorities,
    or just to those who have the authority, via a given role as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may encounter this annotation, but you should avoid it in new code, as it
    is less simple to use than `@RolesAllowed`, and less powerful than `@PreAuthorize`
    and others, which we will see in the next section.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You may find discussions about the differences between roles and authorities
    in Spring security in some materials. You may find the rule that all role names
    should start with the prefix `ROLE_` (which can be configured).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly, you will not have to worry about this these days, until you have the
    need for fine-grained access control in your application. If Spring Security finds
    role names without the prefix, it will add them in all contexts on the fly – completely
    in the background. If a user has the role USER, then all of the following roles
    will allow access:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The two exceptions here are `@Secured("USER")` because that annotation uses
    a very special syntax and `@PreAuthorize("hasAuthority('USER')")` because the
    authorities that Spring automatically creates from roles all have the prefix.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Expression-Based Security
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most powerful approach to method level security is in the pre- and post-annotations
    that allow `SpEL`-based access. To enable this set of annotations, the `prePostEnabled`
    option must be set as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will enable four annotations at once as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These really are aptly named. Each of them takes a `SpEL` expression. This can
    be arbitrarily complex. Therein lies a certain danger—you must ensure that you
    actually unit test the effect of the annotations, just as you would with normal
    Java code. Experience shows that this is often forgotten since testing the annotations
    is a bit more complicated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Simple Expressions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first annotation is `@PreAuthorize`, and it has very simple semantics:
    if the `SpEL` expression evaluates to true, access to the method is granted, and
    it is denied otherwise. It can be taken as a more powerful version of `@RolesAllowed`,
    as in the following example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Uptil this point, it is only more verbose; let''s look at a slightly better
    example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Powerful Expressions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The real power begins to show when the expressions access the arguments of
    the method they secure. For instance, imagine that we have fetched a record from
    the database, and then, further down the processing chain, we want to delete it
    in a service as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a new, and very powerful, tool that Spring Security has given us.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that when you do permission checks based on data that is provided
    by the user, your code cannot be tricked. In this example, it is crucial that
    the author's name is read from the database before it is compared to the name
    of the user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Far less common is the case where you want to authorize after the fact, possibly
    depending on the return values. Using the built-in `returnObject` expression,
    we can access the return value in the `SpEL` expression in a `@PostAuthorize`
    annotation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Expression-based access control can also be used with `HttpSecurity`, instead
    of this annotation. You really should use the
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: autocompletion of your favorite IDE to explore all the different ways to specify
    restrictions, but as a starter, this chained method is called `access()`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: We can only scratch the surface here. Please refer to the documentation on expression-based
    security is in [https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Access – Filtering
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@PreFilter` and `@PostFilter` annotations enable Spring to filter the
    input arguments and the return value, respectively. Filtering is performed with
    the help of `SpEL`. Consider the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method is supposed to take a list of blog posts, save them, and then return
    all of the blog posts, both new and old. However, the annotation has put two limits
    on this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Only blog posts that are shorter than 240 characters are allowed, except when
    you have admin privileges.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only your own blog posts are returned, except for admins, who get all posts.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering only works over collections. The collections must be mutable. During
    an evaluation, the expression `filterObject` refers to the list element under
    scrutiny. This feature goes beyond access control, and we should carefully consider
    whether this part of the business logic is not in better hands within the Java
    code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum this up, take a look at the following table:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8ef128c-c4d8-4fdc-bd0e-a5c872d6e38d.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Testing Security Aspects
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the `performForRole()` method from the previous chapter? How can we
    make sure that the annotation will limit the access the way we want it to?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'To test Spring Security, we need one more dependency in our POM as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As usual, the version is already pinned by Spring Boot. Now, the test is quite
    simple (assuming that the service that contains the method to test is called `SecuredService`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only new things in the whole test are the Spring Security test annotations
    `@WithMockUser` and `@WithAnonymousUser`. The latter can test for unauthorized
    access; the former gives us a configurable user who has, by default, the name
    `user`, and the `USER` role.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: For many setups, this is enough. For more involved access schemes, there are
    also advanced test annotations, such as `@WithUserDetails`, and even `@WithSecurityContext`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The Security Context
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need information about the currently logged in user, beyond just
    allowing or denying access. This information is stored in the security context
    (the class is really a `SecurityContext`). The question, now, is how to obtain
    this context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The security context is maintained by Spring Security in a thread-local variable,
    by default. To access it, we call a static method on a holder object as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These lines try to find the name of the currently logged in user. The code may
    require some explanation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityContextHolder.getContext()` will return the currently active security
    context.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This context really contains only one thing: the current authentication, which
    we retrieve with `getAuthentication()`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This authentication object contains some details, such as the credentials and
    the granted authorities, and also the principal, which is a representation of
    the user.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next lines are very defensive—the principal has Object type only, as Spring
    Security is very flexible here. Most of the time, however, the principal is an
    implementation of `UserDetails`, and we can extract the username from it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: You can find an application of the security context in the example application
    in the `homePage()` method of `HomePageController`. We will take a closer look
    at `UserDetails` and granted authorities in the next section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: A Real User Repository
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The in-memory authentication that we have used up to this point is actually
    quite a workable implementation. The key point is how to initially load the users
    because hardcoding them as we did is insecure.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in many cases, we will want to use another implementation. All we
    have to do is provide an implementation of Spring Security''s `UserDetailsService`
    interface. It is quite simple on the surface, but a bit involved to actually implant
    into the application. Let''s take a look at an implementation that accepts all
    users whose names are in lowercase:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The main thing to note is that we need to implement only one method: `loadByUsername()`.
    It is important to note that this routine does not actually perform the authentication,
    but is a DAO that looks up a user and returns the corresponding details, including
    the encoded password. The actual checking is done elsewhere. As noted in the corresponding
    JavaDoc, this method must not return null, and is expected to throw a `UsernameNotFoundException`
    when the user does not exist at all.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Spring makes no assumptions about the whereabouts of the users. In our play
    example, we generate users on the fly, to show that there are no restrictions
    at all. In the real world, we would rather query our database to populate the
    `UserDetails` object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The `UserDetails` object that is returned here is what we saw earlier, as the
    principal in the security context. If we only have one source of `UserDetails`
    objects, which is quite normal, then we can cast the principal to it blindly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we are moving through code unauthenticated, the principal is
    not one of our `UserDetails`. It is a string with the value `anonymousUser`. Let''s
    skip the password line for the time being as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `loadByUsername()` method is supposed to return `UserDetails`, which is
    an interface, and that interface needs to supply the Spring Security system with
    a list of `GrantedAuthority`, another interface. This is very flexible, but to
    help us, there are two standard implementations of these two interfaces that are
    adequate for many purposes: `User` and `SimpleGrantedAuthority`. We make use of
    these two implementations to construct a new user with the username that was given
    earlier and a single role for each `USER`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Yes, this is the place where you need to differentiate between roles and authorities.
    Authorities are a more general concept, and roles are a simple sub-case of those.
    An authority that is called `ROLE_USER` will be interpreted as the USER role.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Password Encoders
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passwords must not be stored in plain text. Instead, you need to store them
    in your database in a non-reversible format, usually called a **hash**. In a normal
    `UserDetailsService`, we would not need to worry about this, and would just pass
    the hashed password from the database on to Spring Security, to check against
    the password that the user gave.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, however, we need to hash the plain-text password `password`
    with the same hash function that Spring Security will use to check against as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`String password = passwordEncoder.encode("password");`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We use the global password encoder that was autowired into our service to encode
    the password. In a more sophisticated application, a line like this would appear
    in a different place—right after the user entered a new password, and right before
    we put that into the database.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it Together
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in our `SecurityConfiguration` class, we will now replace the authentication
    manager builder configuration method with these three code snippets as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code is now almost self-explanatory. We exchanged the in-memory authentication
    with our own implementation. One thing to note is that we should use a `@Bean`
    method to create the service, instead of annotating it with `@Service`; this is
    so we can override the already existing method in `WebSecurityConfigurerAdapter`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We can choose from a wide range of password encoders, but the most flexible
    is the delegating password encoder that comes as a default. It will always use
    a very strong, standard algorithm to encode the password (by default, it is `BCrypt`
    these days), but it can check many other, older algorithms. This will be of tremendous
    help when you want to migrate to a new algorithm.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The encoded password will have the algorithm embedded, and will look like `{bcrypt}$2a$10$2.eeR1LFYuJjicT.SyTEpEgX7mgJvH902rS`,
    to allow Spring Security to delegate to the appropriate password encoder. An ancient
    entry in your database might be `{MD5}{3A1yJJ/pQ5zMYv77050bccaccda0e573339a` and
    requires that the user change the password in order to migrate to `BCrypt`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Real Repositories
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real applications, where do the users come from? Very often, there is already
    a user database, and one easy way to follow is to have our users implement the
    `UserDetails` interface. In the security introduction application, this is the
    `Author` class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security comes with two implementations of `UserDetailsService`, out
    of the box. These two even implement `UserDetailsManager`, to allow for creating
    new and changing existing users. You have already seen one of these two: `InMemoryUserDetailsManager`
    stores all possible users in the memory. For a limited number of users, this is
    efficient. To fill in the users, we may read them from a file upon startup.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The other implementation is `JdbcUserDetailsManager` and it comes with database
    access via JDBC. Database access will be handled in the next chapter, but to use
    this class, the only prerequisite is to create the required tables in the database.
    The users provided by this implementation are of the class `User`, mentioned earlier.
    That class contains neither the full name nor the email address, which may make
    it less suitable for many applications.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (CSRF)
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To round off this chapter, let's briefly discuss about two important four-letter
    acronyms, CSRF and CORS.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** is when a site A creates a request to a site
    B but lets the user think something else is happening. The stateless nature of
    HTTP means that site B cannot determine where the call originated from. The browser
    will add all of the necessary cookies to the request, so if the user is currently
    logged in site B, perhaps in another tab, then site A can manipulate data.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The key to preventing this kind of attack is to require a synchronizer token
    to be sent alongside all requests that manipulate data; that is, `POST`, `PUT`,
    and `DELETE`. This token is sent to the browser in each form, usually as a hidden
    field, and must be present in the request. The attacking site will not normally
    have access to that token.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection can be disabled if you only accept calls from trusted sources.
    This decision should not be taken lightly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: What do we have to do to use this feature? Almost nothing, if we rely on forms
    and Spring Security's support for Thymeleaf (and also for JSPs and other templating
    engines). Each form that we create in a Thymeleaf template will have an additional
    hidden field, called `_csrf`, that will be checked upon accepting the call. If
    you go back to the explanation of the login form, you will see this field. A form
    is extended by Thymeleaf when the `th:action` attribute is used on the `<form>`
    tag.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use REST calls, you cannot pass another parameter in your JSON, and
    you will not have a form that gives the client to the CSRF token to begin with.
    In this case, we need another configuration, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, Spring Security will send along an **XSRF-TOKEN** cookie, and we can use
    this to send an **X-XSRF-TOKEN** header with the request. We will not look into
    this slightly advanced technique in this book.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**) is a way to work with today''s
    browsers'' **SOP** (**Same-Origin Policy**). Spring offers two different ways
    to achieve the same goal. We will not go into too much detail, but we will look
    at two example configurations straight from the Spring documentation.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The first comes from Spring MVC support as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will relax the SOP to allow access to `/greeting-javaconfig` from `localhost:port
    9000`. There is also annotation-based configuration support for this. This is
    the way to configure CORS when you do not have Spring Security.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you have Spring Security, then security and CORS must work hand
    in hand, and it is necessary to extend the security configuration, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if Spring MVC is on the `classpath` and no `CorsConfigurationSource` is
    provided, Spring Security will use the CORS configuration provided to Spring MVC,
    as defined previously. Instead, you can decide to configure CORS using the code
    as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Activity: Exploring Security Annotations'
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Load and start the security introduction application from the source archive.
    It is a short message service that sports some features that may be a little far-fetched,
    but which make it easier to demonstrate some of the features of Spring Security
    without the overhead of a real application. You can view `all` pages even as an
    anonymous user.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: To explore the effects of security annotations on the methods.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: You have a web app that has web security configured. However, you do not want
    to rely only on URLs but directly secure the code with annotations.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the HomePageController to find the `homePage()` method and add an
    annotation to limit access to users who have the role `USER`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the application and open the page in the browser.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we are immediately redirected to the login page. Log in with any of
    the predefined users; for instance, `peter/quinn` or `cate/sakai`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the index page changed to reflect your user:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshots showing the name and role assigned:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/4bfb69ac-cb90-47ec-ac1a-77c9bdcab48e.png)![](img/9c664049-c38a-42dd-83d4-738ca706ae88.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: Try to log out.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `ShortMessageService` and its `findAll()` method. Add an annotation
    that limits the display to the articles.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the application and open the page in the browser.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, you will only see your own articles. Remove the `@RolesAllowed`
    annotation from *step 1* again, and restart. You will then be able to view your
    own articles.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now see the full annotation in action: when logged out (in Spring Security,
    this is called an anonymous authentication), you can see all of the articles,
    but when logged in, you can only see your own. (Admittedly, it''s not the most
    straightforward behavior.)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice how annotating the mapping function had the same effect as our
    previous configurations on the `HttpSecurity` object? You can even try to lock
    down the path there, instead of using the annotation. (It is already in the code,
    commented out.) Go to [https://bit.ly/2x8Fyoa](https://bit.ly/2x8Fyoa) to access
    the complete code for the `HomePageController.java` file.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 261.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at many aspects of security, particularly those
    that you, as a software developer, should have on your agenda. The Spring Security
    project offers a tight integration in both the Spring MVC part, which allows you
    to lock down URLs and Spring Beans, which limits access to certain methods. You
    learned how to wire the different pieces together; how to configure authentication
    (for instance in a form) load users into the system (including their access permissions
    and their passwords); and how to give them access to parts of the system.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Our blogmania app now limits writing new articles to only known users. However,
    the blog posts are still in the memory only. We need a way to persist them, and
    so we will turn our attention towards databases in the next (and final) chapter
    in this book.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
