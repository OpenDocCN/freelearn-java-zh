- en: Web Application Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the importance of security in web apps.
    We will investigate the responsibility of a programmer when adding security measures.
    Lastly, we will extend the functionality of the blogmania app.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Recognize the value of security in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify a programmer's role in web app security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assess in which areas Spring offers security solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the blogmania app with access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Your Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is of the utmost importance in software development. This does not
    just apply to online banking or your personal health data – it even applies for
    very simple applications. Why is that so?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that your web application has been a great success so far. Many people
    are using it, some may store their data in it. Then, disaster strikes: through
    a flaw in your software, an attacker is able to hijack the machine that your app
    is running on and abuse the machine for some evil purpose. Or, it turns out that
    people can read the diary entries of all users. It could become expensive for
    you; it could destroy customers'' trust in your software!'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, other security-related issues, such as the exposure of customer
    data from Ashley Madison dating website, credit card data theft in the millions,
    or even computer viruses, may come up as relevant sections worth talking about.
  prefs: []
  type: TYPE_NORMAL
- en: Designing and operating secure software has to be a major aim from the very
    beginning. There are many aspects of security that are difficult to add later.
    Let's take a look at some of the possible threats.
  prefs: []
  type: TYPE_NORMAL
- en: Threats to Software Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many threats to software security. The full section could easily
    fill a book of its own. In this chapter, we can only hope to gain a broad overview.
    The threats that we will look at can be coarsely categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpret untrusted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow access from foreign clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow access to resources not owned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insufficient logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great source for information on security for web applications is **OWASP**
    (**Open Web Application Security Project**). Pay particular attention to their
    list of *Top 10 Most Critical Web Application Security Risks*: [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting Untrusted Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever an application receives data from another application, there is the
    question of whether to trust that data or not. Sometimes, in a closed system,
    trusting others is the correct way to handle data, but in the majority of circumstances,
    some
  prefs: []
  type: TYPE_NORMAL
- en: caution is in order.
  prefs: []
  type: TYPE_NORMAL
- en: This is intentionally a wide category. OWASP lists multiple problems that can
    be subsumed in it. The general advice here is to check data carefully. There is
    no single way that any library could help with that. To make you aware of some
    of the possible issues, let's look at a non-exhaustive list.
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Injection** means to allow a user to inject some of their code into your
    code. This is very rarely a good idea, and it is usually not on purpose. Two very
    prominent representatives of this are **XSS** (**Cross-Site Scripting using JavaScript**)
    and SQL injection. Usually, some text from a client is accepted for instance,
    in a simple text field in a form on a web page and is subsequently used without
    further processing. Now, imagine that the text entered into the form was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If this text was then simply embedded into your web page, the text would not
    be displayed, but instead, this JavaScript would be executed! To avoid this, you
    can either be very conservative in what you accept, or you can escape the text
    in every output. The former is simpler, but may be a problem for the user; if
    you do not allow the less-than sign (<), then the user cannot use it, even for
    legitimate text. The latter requires you to escape the text everywhere; for instance,
    by using `<th:text>` in Thymeleaf, as we learned in *[Chapter 5](ae829ce0-b16f-454e-84c9-37eb73bc9de5.xhtml):
    Displaying Information Using Web Pages*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL injection is another problematic attack, particularly for old code that
    used to create SQL by string concatenation. The remedy is quite simple: use placeholders
    for your queries. We will see more of this in *[Chapter 9](7ca1da3d-1799-4c1a-b9cd-4456d2810267.xhtml):
    Persisting Data Using a Database*, when we discuss databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Insecure Deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Insecure deserialization** has recently become a real problem. The scenario
    is that some data is meant to be passed between services (that are non-human clients).
    There are many formats to put this on the wire. In the previous chapter, you have
    learned about JSON as one such format, but two others which are widespread are
    XML and Java binary serialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, XML is a very versatile format. However, with great power comes great responsibility.
    The **entity** feature is most troublesome in untrusted contexts, and the recommendation
    is to use libraries that do not expand entities at the loss of functionality,
    or somehow sanitize the XML before parsing it.
  prefs: []
  type: TYPE_NORMAL
- en: Java serialization is susceptible to bugs in the deserialization routines when
    the incoming data is manipulated. Many popular libraries contain fixes for this
    attack. All we can do is to make sure to always use up-to-date software.
  prefs: []
  type: TYPE_NORMAL
- en: Java serialization and deserialization is used widely in JMS and RMI. They work
    using a built-in mechanism; you have probably seen the serializable interface
    before. This is a fine method to convert an object in memory into a binary representation,
    transfer it over the wire, and convert the binary representation back to an object
    on the other side. However, if the sender creates a manipulated stream of bytes,
    the deserialization routine on the other side may be tricked into doing something
    unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Access from Foreign Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow access means to grant access to every client in a web application.
    It is a consequence of the way HTTP works, and is generally required for operation.
    One consequence is that the JavaScript that runs from a foreign site may be able
    to access the resources on our server. This usually is not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: One possible attack is called **CSRF**, or **Cross-Site Request Forgery**. In
    its simplest form, imagine a malicious site posing as your banking site, even
    imitating the layout. After you have entered your credentials, the malicious site
    can save them for later mayhem, and, in the meantime log you into your real banking
    site. You will not even notice! Spring Security offers help to avoid CSRF attacks,
    and we will see how to do this later.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers implement the **Same-Origin-Policy** (**SOP**) to avoid many of these
    problems. It is, however, a quite rigid policy that may prohibit the legitimate
    sharing of resources between servers that you control yourself. **Cross-Origin
    Resource Sharing** (**CORS**) is a way to circumvent the SOP for your purposes.
    We will work with Spring Security's support to configure CORS later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As so often with things relating to HTTP and the web, the Mozilla Developer
    Network is an excellent resource to get more information about SOP, CORS, and
    CRSF: [https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Access to Resources Not Owned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A user may have access to things that he not have access to. For instance,
    a normal user should only see his own private information, not that of others,
    and he should not be able to access the administration interface. The key to accessing
    control is by using either **authentication** and **authorization**. These are
    supported very well by Spring security and are actually the bulk of this chapter.
    Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a3d1be3-572a-4745-8638-cf2ba1ec0726.png)'
  prefs: []
  type: TYPE_IMG
- en: Insufficient Logging and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a threat in itself, but rather it's the failure to detect problems
    at runtime. Setting up firewalls; is more of a task for the operations department
    than for the software developer. Proper logging and monitoring can detect the
    beginning of an attack and allow for quick countermeasures.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terms authentication and authorization are frequently mixed up, but it is
    very helpful to know their exact meanings – and their differences.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate goal here is to find out whether the person sitting in front of
    the monitor is allowed to perform a certain task. First, we have to confirm the
    identity of the person, and after that, we can check whether this person has the
    necessary permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process of confirming a client's identity. There are a
    number of possible ways for a user to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security will manage the classic login variants for us, and we will turn
    to that in the next section. It also has support for a number of different distributed
    logins, for example, `OAuth` and `OAuth2`, but that is out of the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Username-password authentication needs to address the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a user database of some sort. This can be an in-memory, hardcoded list,
    or it can come from an external database system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the username, we need to store the password, but in a safe way. The
    general consensus is to not save the password at all, but a non-reversible hash
    instead. In the unfortunate event of a leakage in our database, it would then
    not be possible for the attacker to obtain the passwords; this is important because
    users tend to use the same (or a similar) passwords in different places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a web application, we must also think about how the authentication is sent
    from the browser to the server. One very important aspect is that the original
    password must travel over the wire (at least once), so we have to ensure that
    we are using a secure channel (communicating via HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have ascertained the identity of the user, we must check what he is
    allowed to do. This is called authorization, meaning that the user is authorized
    to do something.
  prefs: []
  type: TYPE_NORMAL
- en: In a web application, it is important to handle two different aspects. Imagine
    a web application that has a private area for each user and an administration
    interface. It is quite obvious that we must prevent access to the administration
    interface for non-privileged users. This can be done by restricting the accessible
    paths in an application and **granting access** to only relevant paths. You will
    see how to do that with Spring Security's `WebSecurityConfigurerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some URLs, however, are accessible to all users, but need to display different
    content. You would not want other people to see your private data! Some resources
    may react differently, depending on the user: an article may be limited to 1,000
    characters for normal users, but to 4,000 characters for premium users.'
  prefs: []
  type: TYPE_NORMAL
- en: To handle this, you need to assign access rights to users, in other words, **grant
    permission**. One such model is to assign roles to users (such as `USER` or `ADMIN`)
    and restrict access to resources to certain roles. If you need very fine-grained
    control, you can also use the more powerful (but, alas, more difficult to handle)
    **Access Control Lists** (**ACLs**). Only in the most complicated scenarios would
    you need to check this by hand, though. Spring Security offers you some simple
    annotations to limit access to methods within Spring Beans.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Baby-step Security (1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to analyze the difference between an unsecured and a secured web
    app. Let's say you want to see an app in an unsecured and a secured version, side
    by side, to compare them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before beginning, you will need to load and start the Security-Intro app found
    at [https://bit.ly/2REovBW](https://bit.ly/2REovBW). Start the app. Fire up the
    homepage in the browser and make a REST call to `/api/messages.json` in Postman,
    to see that both are easily accessible. (You can find the Postman configuration
    in the chapter''s folder, as well, if you need it). The steps for completion are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the POM and add the following dependency to its `<dependencies>` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let IntelliJ re-import the POM and restart the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the web version and make the REST call again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will make the following two observations:'
  prefs: []
  type: TYPE_NORMAL
- en: The web version now shows a login page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/593aa361-40e3-4eaf-93fe-a5591e76f0e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The REST call resulted in **401 Unauthorized**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2ylvMzt](https://bit.ly/2ylvMzt) to access the complete
    code for the `SecurityIntroApplicationTests.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a short overview of the different aspects of security, let's turn to Spring
    again, and the way that it addresses some of the issues mentioned previously.
    Note that many security problems actually stem from the erroneous behavior of
    the application and cannot be solved by just using a library.
  prefs: []
  type: TYPE_NORMAL
- en: The last two will only be covered quite briefly, as there is not much to say
    about them. The bulk of this section will, therefore, be about authentication
    and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we meticulously took care to differentiate the two words, the concepts
    could not be demonstrated in isolation, as the effects of the one only become
    apparent through the other. Let's start by adding Spring Security to the project
    and look at the effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security is a sub-project of the Spring platform, just like Spring Web
    MVC, which was introduced in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml)*:
    *The MVC Pattern*. It has a release cycle of its own. When using Spring Boot,
    you do not have to care about that, as the Spring Boot dependency management will
    resolve to a tried and tested version. Only in rare cases should you have the
    need to manually include the required dependencies and specify their version numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: The Magic of Auto-Configured Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding Spring Security to a Spring Boot project is very simple. It comes with
    a default configuration that is very secure and is most definitely unsuitable
    for any real purpose. All you have to do is add the respective starter POM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The starter POM has transitive dependencies on all necessary artifacts. Now,
    upon starting, a Spring Boot application will print out a line like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Access to any resource, whether with a web browser or a REST client, will be
    secured.
  prefs: []
  type: TYPE_NORMAL
- en: Tight Spring Security Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot is happening behind the scenes here. The following list is not quite
    exhaustive, but it contains all of the information that you normally need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: Installed a security filter chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling all requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some fallback user repositories and a login page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magic is part of Spring Boot here, which will create all the necessary Beans
    for using Spring Security. This is the auto-configuration feature that you already
    know about, which can create Beans as soon as the necessary classes are found
    on the classpath and, launch post-construct setup routines to wire it all in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it installs a servlet filter (as introduced in *[Chapter 4](6c057031-8824-460d-bad6-abd27cbb3b21.xhtml):
    The MVC Pattern*). This filter intercepts each request and adds the necessary
    security. This is a Spring Bean with the type `DelegatingFilterProxyRegistrationBean`
    and the name `springSecurityFilterChain`. As the names already suggest, these
    are not simple filters, but are chains of filters, with each adding a bit of functionality.
    These chains are constructed automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter is configured to secure all requests by default, and all with the
    same level of security. There is one notable exception: the login page that you
    are confronted with when you try to access the web part of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: The repository of users for the application is kept in-memory, and there is,
    in fact, only one user in the system. Its name is **user**, and its password is
    chosen at random upon the start of the application; it is in the form of a UUID.
    This is secure, but it is a bit unwieldy in practice. This default was chosen
    so that adding the dependency would actually make a difference and force users
    to choose their own configurations, instead of leaving the system as insecure
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: The results of these measures are quite different for the REST and the web versions,
    so we will look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Securing REST with Basic Auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing Spring Security to the project, accessing a REST resource
    started to result in **401 Unauthorized**. This is what the security filter will
    produce when no means of authentication is provided. In case you are wondering,
    yes, you are **not authorized** to access this resource, but it is primarily because
    you could not **authenticate** yourself to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the response, the server also sent a header, `WWW-Authenticate:
    Basic realm="Realm"`, to tell the client what to do about the situation. The answer
    tells us that we should use a procedure called **Basic Auth** and use the **Realm**
    realm for it.'
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Auth scheme is the simplest form of authentication. It does not require
    cookies or storage on the server. The client sends the credential with every request
    in the authorization header. The password is not hashed or encrypted, but only
    Base64 encoded; therefore, a secure connection is advisable.
  prefs: []
  type: TYPE_NORMAL
- en: A realm can be used to access different areas of a server with different credentials.
    It is rarely used; most servers have only one realm.
  prefs: []
  type: TYPE_NORMAL
- en: For **REST clients**, this is a simple yet effective way to authenticate. Postman
    allows you to set the credentials easily, as do command-line tools, such as **cURL**.
    Neither client nor server needs to store any tokens, so the process is completely
    stateless.
  prefs: []
  type: TYPE_NORMAL
- en: For **web browsers**, this scheme works, but not comfortably. Browsers will
    present the user with a dialog box to input the credentials, but this belongs
    to the browser, and does not share the look and feel of the web page. Also, there
    is no way to log out again.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Auth requires validation of the password for every request. Modern password
    hashing is intentionally slow, to improve security. It is therefore recommended
    to exchange the password for some shorttime credentials, such as the session,
    even for REST calls.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Web Browsing in the Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing Spring Security to the project, accessing a secured web page
    started to issue a **302 Found** with a location header, and the browser redirected
    us to the given page. The very basic login form that we see there is a built-in
    fallback from Spring Security. Entering credentials there will POST them to another
    built-in endpoint that will then check the credentials and add them to the session.
    To identify this session in subsequent requests, a cookie, called JSESSIONID,
    is set.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions are supported by all servlet containers, such as Tomcat, and are a
    place to store some ephemeral data for a returning user. In today's environments,
    sessions are used mostly to identify the user, and nothing more. Storing real
    data may bring problems to scalability if there is no central session store.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scheme is more versatile: a web page can use a login form of its own or
    embed the login form into a landing page. Also, the user can log out. However,
    it requires some storage of the session and its identifier in both the server
    and client, and is thus not 100% stateless.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining Baby-step Security (2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize the secured web app. Let's say you have a secured app
    and want to log in. Before beginning, start (or restart) the application from
    the previous sub-section and navigate to `http://localhost:8080/`.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the password, which is in a UUID format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the log view in IntelliJ, there is a line (that stands out because there
    are empty lines around) that starts with Using generated security password.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, enter `user` as the username and the copied `password` as the
    password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now logged in and can view the homepage. (If you forgot to reload the
    form in between, the first login may fail. Just do it again, in this case.)
  prefs: []
  type: TYPE_NORMAL
- en: In Postman, in the **Authorization** pane, choose Basic Auth from the drop-down
    menu, or load the authenticated version from the Postman collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, enter the credentials as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on Preview Request, you can show the header in the **Headers**
    pane.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you send the request, the data is again returned as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/92c60b12-4af0-436c-84d1-22272ee8bc16.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the data is returned because the authorization header was set
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That was quite a lot at once. To customize the behavior, let''s first reproduce
    the default configuration of Spring Security by hand. It will then be obvious
    what to change if we have different needs. To do that, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration class to handle security aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code containing the HTTP security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login form and a mapping function to display it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user repository with a dummy user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security Configuration Entry Point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recommended way to configure Spring Security in Spring Boot is to extend
    the `WebSecurityConfigurerAdapter` class, which offers plugin points to access
    various aspects. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see that we also mark this class as a Spring Boot `@Configuration`
    class and enable the security scheme by using `@EnableWebSecurity`.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why `@EnableWebSecurity` is necessary at all, if enabled security
    is the default. You are right – it isn't. Still, it is customary to make it explicit.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you want to disable all of Spring Boot's automatic security
    configuration, even though you have Spring Security included in your project,
    you have to disable it explicitly in your main application class, using `@SpringBootApplication(exclude
    = SecurityAutoConfiguration.class)`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Hardcoded Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage the authentication source, we use the `AuthenticationManagerBuilder`,
    which we get as an argument to the `configure()` method. We will start with **in-memory**
    authentication, that is, the user list does not come from external sources, but
    is pre-loaded. Take a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The injection builder auth gives us functions that harmonize with autocompletion
    in the IDE. The `inMemoryAuthentication()` creates the **in-memory** store, and
    `withUser()` adds a user to the system, using the same name as before, but with
    a slightly easier password for playing around.
  prefs: []
  type: TYPE_NORMAL
- en: The password is given explicitly. Therefore, it is present in the code in plain
    text. This is not a secure configuration and is only used to get us started in
    the absence of a database.
  prefs: []
  type: TYPE_NORMAL
- en: The password is now set to something more memorable than the ever-changing UUID.
    This user has the USER role; this is used to authorize resources, as we will see
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the application now, it will still print out a generated password.
    This is **not** the user and password that are used now. It just means that `UserDetailsServiceAutoConfiguration`
    still creates a `UserDetailsService` Bean, which is, however, unused. We will
    replace that Bean with our own implementation later on.
  prefs: []
  type: TYPE_NORMAL
- en: Locking Paths with Basic Auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To lock and allow access to HTTP resources (web pages or API endpoints), we
    use an `HttpSecurity` object, which we get as an argument to another `configure()`
    method (it is overloaded with some other, less frequently used configuration objects).
    First, we want to lock all URLs to users that have the `USER` role, just like
    our predefined user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With `authorizeRequests()`, we introduce the path matchers section. The `antMatchers()`
    is a function that takes any number of paths in Ant-style, and finally, `hasRole()`
    specifies the condition of the user. In this case, the paths have a certain role.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Ant ([https://ant.apache.org/](https://ant.apache.org/)) was a widely
    popular Java build system, a predecessor to both Maven and Gradle. It introduced
    a style of specifying paths, sub-paths, and files that is different from the usage
    of the asterisk in the shell. It is easy, yet very versatile; the pattern "/**"
    here means "starting from the root, match everything."
  prefs: []
  type: TYPE_NORMAL
- en: The roles in Spring Security are simple Java strings. This may cause trouble
    if you misspell them, so, for real-life applications, you should create an enumeration
    and use its string value.
  prefs: []
  type: TYPE_NORMAL
- en: We have now locked everything, but do not have a means to actually authenticate.
    This is added with the simple `httpBasic()` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now secured and accessible using Basic Auth.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic auth that secures the app now works fine, but the user experience
    is poor. The user expects a **login form** that is part of the application, and
    probably a means to log out again. We will now add the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: Login form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default: GET /login'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can have as many as needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username & password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mysterious `_csrf` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send to login controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Default: `POST /login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minimum login form that Spring requires is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the mysterious `_csrf` field, which will be explained in the next
    section, this is a very basic form with just two parameters (username and password),
    which will be `POSTed` to the `/login` URL.
  prefs: []
  type: TYPE_NORMAL
- en: We can have as many of these forms as we like, (to embed them into other pages,
    for example), as long as they POST their input to the right receiver. Many applications,
    however, feature an additional separate login page. This will be the page that
    the users are redirected to if they try to view a page that they cannot access.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might be because their session is expired, or they may have entered an
    incorrect password on the first try. The page will then be called with an added
    `?error` parameter. In a Thymeleaf template, we can evaluate that. Consider the
    following Thymeleaf HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first `<div>` containing the error message will only be shown when `loginError`
    is set. The full file (including more markup to improve the representation) can
    be found in the `login.html` file, alongside all of the other code for this chapter,
    in [https://bit.ly/2DGVgvE](https://bit.ly/2DGVgvE).
  prefs: []
  type: TYPE_NORMAL
- en: 'The login page that we just created is not yet mapped, so we need to add this
    method in some controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method would be trivial if we did not add a little error
    handling. By default, Spring will call the login page with `/login?error` if an
    error occurred, so we evaluate this optional parameter and put an attribute into
    the model; this attribute is used to display the error message in the form. You
    can find the source code for this in the class `HomePageController`, in the source
    code distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains is to tell Spring Security to actually use our login page. For
    this, we need to add form-based authentication to the HTTP security. Another thing
    to consider is that access to the login form itself must be granted to everyone,
    or it will not be possible to log in at all. The complete configuration method
    will then look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Failure to allow unauthenticated access to the login page itself and all of
    the resources it needs, be it CSS, JavaScript, or images, will result in a non-functional
    application. There will be an infinite number of redirects, which the browser
    will hopefully interrupt at some point.
  prefs: []
  type: TYPE_NORMAL
- en: The first new line permits access for all clients, for a number of new Ant patterns.
    In addition to the login page itself, we also grant access to the static resources
    needed for a nicer display.
  prefs: []
  type: TYPE_NORMAL
- en: The other new line configures a form login, in addition to the existing basic
    auth login, and specifies the login page with the path we used. (It is actually
    the default, but it is better to be explicit here.)
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users need to log out of the application, either for security reasons or to
    log in as another user. This can be easily accomplished, for instance, with the
    following snippet from the security introduction app (`index.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The gist of this code is that we need to issue a POST request to the `/logout`
    URL, which is the configurable default for this.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Web Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider that you have a web app that has web security configured. You want
    to change which pages you can access freely, and which you can only access with
    authentication. You should try to avoid the traps. The aim here is to explore
    the effects of using the `HttpSecurity` object.
  prefs: []
  type: TYPE_NORMAL
- en: Before beginning, load and start the Blogmania app from the folder [https://bit.ly/2PmyyPF](https://bit.ly/2PmyyPF).
    Note that you cannot access it without logging in, as you are redirected to the
    login page immediately. After logging in, you can enter the start page. You can
    log out again.
  prefs: []
  type: TYPE_NORMAL
- en: In the `SecurityConfiguration` class, find the `configure(HttpSecurity http)`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, try to tighten the security by removing the call that (suspiciously)has
    an entry that looks as if it will allow anyone in! The body should now look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Start the application and reload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That didn't work at all. If you have the browser's developer tools open, you
    will see that it was redirecting until it decided to break the cycle. What happened?
    Oh, we disallowed access to the login page itself!
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c1c072f-e6d4-4bc0-ab49-4dc927158daf.png)'
  prefs: []
  type: TYPE_IMG
- en: Try the opposite. Re-add the line (use `undo`), and instead, remove the requirement
    for a specific role.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By pressing *Ctrl + spacebar*, IntelliJ will show you the full list of possibilities.
    Simply choose to permit all, and the result will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Start the application and reload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that now, you can view all pages without being logged in. You can still
    navigate to `/login` and perform the login. However, there will be no visible
    difference. (There is only a difference behind the scenes.)
  prefs: []
  type: TYPE_NORMAL
- en: Method-Level Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous configuration, we used web security; that is, we applied the
    security configuration to URLs. Since Spring Security''s pluggable architecture
    is not limited to web applications, there must be another way to control access:
    **method-level security**.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though method-level security can be configured in XML, it is better known
    under the name of annotation-based security. This is, of course, because its widespread
    use came with Spring's `@Secured` annotation. These days, there are three different
    sets of annotations, and first we'll look at the annotation that is easiest to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Roles Allowed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first annotation comes from JSR-250 ([https://jcp.org/en/jsr/detail?id=250](https://jcp.org/en/jsr/detail?id=250))
    and is called `@RolesAllowed`. It is very easy to use as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The annotation takes the name of a role (or a list, thereof) and limits calls
    to `performSecure` to authenticated users that also have the USER role. If the
    method is called and the constraint for the USER role is not satisfied, a runtime
    exception, `AccessDeniedException`, will be thrown instead.
  prefs: []
  type: TYPE_NORMAL
- en: Enable @RolesAllowed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method-level security is not enabled in Spring Security by default. You have
    to modify it in a configuration class, preferably your security configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This annotation is the simplest, but it is also the most limited form of access
    control with annotations. If your needs surpass the capabilities of `@RolesAllowed`,
    Spring Security offers some more security features.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can secure all public methods in Spring Beans with annotations. So, assuming
    that we control access to mapping methods in Spring MVC controllers, how is that
    different from using the `HttpSecurity` configuration?
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it isn''t. It is mainly a matter of style. Take a look at the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e30aaab-1845-4d9c-a00e-26ad7589e18f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Original @Secured Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security''s original annotation for method-level security is called
    `@Secured`. It has to be enabled with `@EnableGlobalMethodSecurity (securedEnabled
    = true)`, to be used. The argument to the annotation is passed to an `AccessDecisionManager`
    to make the final decision. You can allow access to all authenticated authorities,
    or just to those who have the authority, via a given role as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may encounter this annotation, but you should avoid it in new code, as it
    is less simple to use than `@RolesAllowed`, and less powerful than `@PreAuthorize`
    and others, which we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You may find discussions about the differences between roles and authorities
    in Spring security in some materials. You may find the rule that all role names
    should start with the prefix `ROLE_` (which can be configured).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly, you will not have to worry about this these days, until you have the
    need for fine-grained access control in your application. If Spring Security finds
    role names without the prefix, it will add them in all contexts on the fly – completely
    in the background. If a user has the role USER, then all of the following roles
    will allow access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The two exceptions here are `@Secured("USER")` because that annotation uses
    a very special syntax and `@PreAuthorize("hasAuthority('USER')")` because the
    authorities that Spring automatically creates from roles all have the prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-Based Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most powerful approach to method level security is in the pre- and post-annotations
    that allow `SpEL`-based access. To enable this set of annotations, the `prePostEnabled`
    option must be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will enable four annotations at once as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These really are aptly named. Each of them takes a `SpEL` expression. This can
    be arbitrarily complex. Therein lies a certain danger—you must ensure that you
    actually unit test the effect of the annotations, just as you would with normal
    Java code. Experience shows that this is often forgotten since testing the annotations
    is a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first annotation is `@PreAuthorize`, and it has very simple semantics:
    if the `SpEL` expression evaluates to true, access to the method is granted, and
    it is denied otherwise. It can be taken as a more powerful version of `@RolesAllowed`,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Uptil this point, it is only more verbose; let''s look at a slightly better
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Powerful Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The real power begins to show when the expressions access the arguments of
    the method they secure. For instance, imagine that we have fetched a record from
    the database, and then, further down the processing chain, we want to delete it
    in a service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a new, and very powerful, tool that Spring Security has given us.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that when you do permission checks based on data that is provided
    by the user, your code cannot be tricked. In this example, it is crucial that
    the author's name is read from the database before it is compared to the name
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Far less common is the case where you want to authorize after the fact, possibly
    depending on the return values. Using the built-in `returnObject` expression,
    we can access the return value in the `SpEL` expression in a `@PostAuthorize`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-based access control can also be used with `HttpSecurity`, instead
    of this annotation. You really should use the
  prefs: []
  type: TYPE_NORMAL
- en: autocompletion of your favorite IDE to explore all the different ways to specify
    restrictions, but as a starter, this chained method is called `access()`.
  prefs: []
  type: TYPE_NORMAL
- en: We can only scratch the surface here. Please refer to the documentation on expression-based
    security is in [https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access).
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Access – Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@PreFilter` and `@PostFilter` annotations enable Spring to filter the
    input arguments and the return value, respectively. Filtering is performed with
    the help of `SpEL`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method is supposed to take a list of blog posts, save them, and then return
    all of the blog posts, both new and old. However, the annotation has put two limits
    on this.
  prefs: []
  type: TYPE_NORMAL
- en: Only blog posts that are shorter than 240 characters are allowed, except when
    you have admin privileges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only your own blog posts are returned, except for admins, who get all posts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering only works over collections. The collections must be mutable. During
    an evaluation, the expression `filterObject` refers to the list element under
    scrutiny. This feature goes beyond access control, and we should carefully consider
    whether this part of the business logic is not in better hands within the Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum this up, take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8ef128c-c4d8-4fdc-bd0e-a5c872d6e38d.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing Security Aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the `performForRole()` method from the previous chapter? How can we
    make sure that the annotation will limit the access the way we want it to?
  prefs: []
  type: TYPE_NORMAL
- en: 'To test Spring Security, we need one more dependency in our POM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the version is already pinned by Spring Boot. Now, the test is quite
    simple (assuming that the service that contains the method to test is called `SecuredService`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The only new things in the whole test are the Spring Security test annotations
    `@WithMockUser` and `@WithAnonymousUser`. The latter can test for unauthorized
    access; the former gives us a configurable user who has, by default, the name
    `user`, and the `USER` role.
  prefs: []
  type: TYPE_NORMAL
- en: For many setups, this is enough. For more involved access schemes, there are
    also advanced test annotations, such as `@WithUserDetails`, and even `@WithSecurityContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The Security Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need information about the currently logged in user, beyond just
    allowing or denying access. This information is stored in the security context
    (the class is really a `SecurityContext`). The question, now, is how to obtain
    this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security context is maintained by Spring Security in a thread-local variable,
    by default. To access it, we call a static method on a holder object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These lines try to find the name of the currently logged in user. The code may
    require some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityContextHolder.getContext()` will return the currently active security
    context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This context really contains only one thing: the current authentication, which
    we retrieve with `getAuthentication()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This authentication object contains some details, such as the credentials and
    the granted authorities, and also the principal, which is a representation of
    the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next lines are very defensive—the principal has Object type only, as Spring
    Security is very flexible here. Most of the time, however, the principal is an
    implementation of `UserDetails`, and we can extract the username from it.
  prefs: []
  type: TYPE_NORMAL
- en: You can find an application of the security context in the example application
    in the `homePage()` method of `HomePageController`. We will take a closer look
    at `UserDetails` and granted authorities in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A Real User Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The in-memory authentication that we have used up to this point is actually
    quite a workable implementation. The key point is how to initially load the users
    because hardcoding them as we did is insecure.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in many cases, we will want to use another implementation. All we
    have to do is provide an implementation of Spring Security''s `UserDetailsService`
    interface. It is quite simple on the surface, but a bit involved to actually implant
    into the application. Let''s take a look at an implementation that accepts all
    users whose names are in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The main thing to note is that we need to implement only one method: `loadByUsername()`.
    It is important to note that this routine does not actually perform the authentication,
    but is a DAO that looks up a user and returns the corresponding details, including
    the encoded password. The actual checking is done elsewhere. As noted in the corresponding
    JavaDoc, this method must not return null, and is expected to throw a `UsernameNotFoundException`
    when the user does not exist at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring makes no assumptions about the whereabouts of the users. In our play
    example, we generate users on the fly, to show that there are no restrictions
    at all. In the real world, we would rather query our database to populate the
    `UserDetails` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `UserDetails` object that is returned here is what we saw earlier, as the
    principal in the security context. If we only have one source of `UserDetails`
    objects, which is quite normal, then we can cast the principal to it blindly.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when we are moving through code unauthenticated, the principal is
    not one of our `UserDetails`. It is a string with the value `anonymousUser`. Let''s
    skip the password line for the time being as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadByUsername()` method is supposed to return `UserDetails`, which is
    an interface, and that interface needs to supply the Spring Security system with
    a list of `GrantedAuthority`, another interface. This is very flexible, but to
    help us, there are two standard implementations of these two interfaces that are
    adequate for many purposes: `User` and `SimpleGrantedAuthority`. We make use of
    these two implementations to construct a new user with the username that was given
    earlier and a single role for each `USER`.'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, this is the place where you need to differentiate between roles and authorities.
    Authorities are a more general concept, and roles are a simple sub-case of those.
    An authority that is called `ROLE_USER` will be interpreted as the USER role.
  prefs: []
  type: TYPE_NORMAL
- en: Password Encoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passwords must not be stored in plain text. Instead, you need to store them
    in your database in a non-reversible format, usually called a **hash**. In a normal
    `UserDetailsService`, we would not need to worry about this, and would just pass
    the hashed password from the database on to Spring Security, to check against
    the password that the user gave.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, however, we need to hash the plain-text password `password`
    with the same hash function that Spring Security will use to check against as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String password = passwordEncoder.encode("password");`'
  prefs: []
  type: TYPE_NORMAL
- en: We use the global password encoder that was autowired into our service to encode
    the password. In a more sophisticated application, a line like this would appear
    in a different place—right after the user entered a new password, and right before
    we put that into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in our `SecurityConfiguration` class, we will now replace the authentication
    manager builder configuration method with these three code snippets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code is now almost self-explanatory. We exchanged the in-memory authentication
    with our own implementation. One thing to note is that we should use a `@Bean`
    method to create the service, instead of annotating it with `@Service`; this is
    so we can override the already existing method in `WebSecurityConfigurerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose from a wide range of password encoders, but the most flexible
    is the delegating password encoder that comes as a default. It will always use
    a very strong, standard algorithm to encode the password (by default, it is `BCrypt`
    these days), but it can check many other, older algorithms. This will be of tremendous
    help when you want to migrate to a new algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The encoded password will have the algorithm embedded, and will look like `{bcrypt}$2a$10$2.eeR1LFYuJjicT.SyTEpEgX7mgJvH902rS`,
    to allow Spring Security to delegate to the appropriate password encoder. An ancient
    entry in your database might be `{MD5}{3A1yJJ/pQ5zMYv77050bccaccda0e573339a` and
    requires that the user change the password in order to migrate to `BCrypt`.
  prefs: []
  type: TYPE_NORMAL
- en: Real Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real applications, where do the users come from? Very often, there is already
    a user database, and one easy way to follow is to have our users implement the
    `UserDetails` interface. In the security introduction application, this is the
    `Author` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security comes with two implementations of `UserDetailsService`, out
    of the box. These two even implement `UserDetailsManager`, to allow for creating
    new and changing existing users. You have already seen one of these two: `InMemoryUserDetailsManager`
    stores all possible users in the memory. For a limited number of users, this is
    efficient. To fill in the users, we may read them from a file upon startup.'
  prefs: []
  type: TYPE_NORMAL
- en: The other implementation is `JdbcUserDetailsManager` and it comes with database
    access via JDBC. Database access will be handled in the next chapter, but to use
    this class, the only prerequisite is to create the required tables in the database.
    The users provided by this implementation are of the class `User`, mentioned earlier.
    That class contains neither the full name nor the email address, which may make
    it less suitable for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To round off this chapter, let's briefly discuss about two important four-letter
    acronyms, CSRF and CORS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** is when a site A creates a request to a site
    B but lets the user think something else is happening. The stateless nature of
    HTTP means that site B cannot determine where the call originated from. The browser
    will add all of the necessary cookies to the request, so if the user is currently
    logged in site B, perhaps in another tab, then site A can manipulate data.'
  prefs: []
  type: TYPE_NORMAL
- en: The key to preventing this kind of attack is to require a synchronizer token
    to be sent alongside all requests that manipulate data; that is, `POST`, `PUT`,
    and `DELETE`. This token is sent to the browser in each form, usually as a hidden
    field, and must be present in the request. The attacking site will not normally
    have access to that token.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection can be disabled if you only accept calls from trusted sources.
    This decision should not be taken lightly.
  prefs: []
  type: TYPE_NORMAL
- en: What do we have to do to use this feature? Almost nothing, if we rely on forms
    and Spring Security's support for Thymeleaf (and also for JSPs and other templating
    engines). Each form that we create in a Thymeleaf template will have an additional
    hidden field, called `_csrf`, that will be checked upon accepting the call. If
    you go back to the explanation of the login form, you will see this field. A form
    is extended by Thymeleaf when the `th:action` attribute is used on the `<form>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use REST calls, you cannot pass another parameter in your JSON, and
    you will not have a form that gives the client to the CSRF token to begin with.
    In this case, we need another configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, Spring Security will send along an **XSRF-TOKEN** cookie, and we can use
    this to send an **X-XSRF-TOKEN** header with the request. We will not look into
    this slightly advanced technique in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**) is a way to work with today''s
    browsers'' **SOP** (**Same-Origin Policy**). Spring offers two different ways
    to achieve the same goal. We will not go into too much detail, but we will look
    at two example configurations straight from the Spring documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first comes from Spring MVC support as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will relax the SOP to allow access to `/greeting-javaconfig` from `localhost:port
    9000`. There is also annotation-based configuration support for this. This is
    the way to configure CORS when you do not have Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, you have Spring Security, then security and CORS must work hand
    in hand, and it is necessary to extend the security configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if Spring MVC is on the `classpath` and no `CorsConfigurationSource` is
    provided, Spring Security will use the CORS configuration provided to Spring MVC,
    as defined previously. Instead, you can decide to configure CORS using the code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Exploring Security Annotations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: Load and start the security introduction application from the source archive.
    It is a short message service that sports some features that may be a little far-fetched,
    but which make it easier to demonstrate some of the features of Spring Security
    without the overhead of a real application. You can view `all` pages even as an
    anonymous user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To explore the effects of security annotations on the methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You have a web app that has web security configured. However, you do not want
    to rely only on URLs but directly secure the code with annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the HomePageController to find the `homePage()` method and add an
    annotation to limit access to users who have the role `USER`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the application and open the page in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we are immediately redirected to the login page. Log in with any of
    the predefined users; for instance, `peter/quinn` or `cate/sakai`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the index page changed to reflect your user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshots showing the name and role assigned:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/4bfb69ac-cb90-47ec-ac1a-77c9bdcab48e.png)![](img/9c664049-c38a-42dd-83d4-738ca706ae88.png)'
  prefs: []
  type: TYPE_IMG
- en: Try to log out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `ShortMessageService` and its `findAll()` method. Add an annotation
    that limits the display to the articles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the application and open the page in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: After logging in, you will only see your own articles. Remove the `@RolesAllowed`
    annotation from *step 1* again, and restart. You will then be able to view your
    own articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now see the full annotation in action: when logged out (in Spring Security,
    this is called an anonymous authentication), you can see all of the articles,
    but when logged in, you can only see your own. (Admittedly, it''s not the most
    straightforward behavior.)'
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice how annotating the mapping function had the same effect as our
    previous configurations on the `HttpSecurity` object? You can even try to lock
    down the path there, instead of using the annotation. (It is already in the code,
    commented out.) Go to [https://bit.ly/2x8Fyoa](https://bit.ly/2x8Fyoa) to access
    the complete code for the `HomePageController.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 261.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at many aspects of security, particularly those
    that you, as a software developer, should have on your agenda. The Spring Security
    project offers a tight integration in both the Spring MVC part, which allows you
    to lock down URLs and Spring Beans, which limits access to certain methods. You
    learned how to wire the different pieces together; how to configure authentication
    (for instance in a form) load users into the system (including their access permissions
    and their passwords); and how to give them access to parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Our blogmania app now limits writing new articles to only known users. However,
    the blog posts are still in the memory only. We need a way to persist them, and
    so we will turn our attention towards databases in the next (and final) chapter
    in this book.
  prefs: []
  type: TYPE_NORMAL
