- en: Developing a Retirement Calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will put into practice the features of the Scala language
    seen in the first chapter. We will also introduce other elements of the Scala
    language and SDK to develop the model and logic for a retirement calculator. This
    calculator will help people work out how long and how much to save to have a comfortable
    retirement.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the **test-driven development** (**TDD**) technique to develop the
    different functions. I encourage you to try writing the body of the functions
    yourself before looking at the solution. Also, it would be better to retype the
    code rather than copy/pasting it. You will remember it more and will have a sense
    of what it feels like to use IntelliJ's completion and editor. Do abuse the autocompletion
    with *Ctrl* + spacebar. You will not only type faster, but you will also discover
    what functions are available in a given class.
  prefs: []
  type: TYPE_NORMAL
- en: You are going to get a strong foundation for building more complex applications
    using the Scala language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the future capital
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating when you can retire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using market rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using some parameters such as your net income, your expenses, your initial
    capital, and so on, we will create functions to calculate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Your future capital at retirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your capital after a number of years in retirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long you need to save to be able to retire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first use a fixed interest rate for these calculations. After that,
    we will load market data from `.tsv` files, then refactor the previous functions
    to simulate what could happen during the investment period.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the future capital
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you need to know when planning for retirement is how much capital
    you can get at your chosen retirement date. For now, we will assume that you invest
    your savings every month at a constant rate. To simplify things, we will ignore
    the effects of inflation, hence the capital calculated will be in today's money
    and the interest rate will be calculated as* real rate* = *nominal interest rate*
    - *inflation rate*.
  prefs: []
  type: TYPE_NORMAL
- en: We intentionally do not mention any currency in the rest of this chapter. You
    can consider that the amounts are in USD, EUR, or any other currency. It will
    not change the results as long as all the amounts are expressed in the same currency.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test for the accumulation phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want a function that behaves similarly to the `FV` function in Excel: it
    calculates the future value of an investment based on a constant interest rate.
    As we follow a TDD approach, the first thing to do is create a failing test:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Scala project called `retirement_calculator`. Follow the same instructions
    as in [Chapter 1](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml), *Writing Your First
    Program*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the directory `src/main/scala` and select New | Package. Name
    it `retcalc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the new package and select New | Scala class. Name it `RetCalcSpec`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As seen in [Chapter 1](db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml), *Writing
    Your First Program*, in the section *Creating my first project*, we used the `WordSpec`
    ScalaTest style. We also used a handy feature called `TypeCheckedTripleEquals`.
    It provides a powerful assertion, `should ===`, that ensures at compile time that
    both sides of the equality have the same type. The default ScalaTest assertion
    `should` verifies the type equality at runtime. We encourage you to always use
    `should ===`, as it will save a lot of time when refactoring code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, it lets us use a certain amount of tolerance when comparing double
    values. Consider the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It will let a `double1 should === (double2)` assertion pass if the absolute
    difference between `double1` and `double2` is lower than `0.0001`. This allows
    us to specify expected values to only the fourth digit after the decimal point.
    It also avoids hitting floating point calculation issues. For instance, enter
    the following code in the Scala Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It can be a bit surprising, but this is a well-known problem in any language
    that encodes floating point numbers in binary. We could have used `BigDecimal`
    instead of `Double` to avoid this kind of issue, but for our purposes, we do not
    need the additional precision offered by `BigDecimal`, and `BigDecimal` computations
    are much slower.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the test is quite straightforward; we call a function and expect
    a value. As we wrote the test first, we had to work out what would be the expected
    result before writing the production code. For non-trivial calculations, I generally
    use Excel or LibreOffice. For this function, the expected value can be obtained
    by using the formula `=-FV(0.04/12,25*12,1000,10000,0)`. We assume that the user
    saves the full difference between his or her income and his/her expenses every
    month. Hence, the PMT parameter in the `FV` function is `1,000 = netIncome - currentExpenses`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a failing test, but it does not compile, as the `RetCalc` object
    and its `futureCapital` function do not exist yet. Create a `RetCalc` object in
    a new package `retcalc` in `src/main/scala`, then select the red `futureCapital`
    call in the unit test and hit *Alt* + *Enter* to generate the function body. Fill
    in the names and types of the parameters. You should end up with the following
    code in `RetCalc.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open `RetCalcSpec`, and type *Ctrl* + *Shift* + *R* to compile and run it. Everything
    should compile and the test should fail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing futureCapital
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a failing test, so it is time to make it pass by writing the production
    code. If we use `initialCapital = 10,000` and `monthlySavings = 1,000`, the computation
    we need to perform can be decomposed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For month `0`, before any savings, we have `capital0 = initialCapital = 10,000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For month `1`, our initial capital generated some interest. We also saved 1,000
    more. We therefore have `capital1 = capital0 *(1 + monthlyInterestRate) + 1,000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For month `2`, we have `capital2 = capital1 *(1 + monthlyInterestRate) + 1,000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a mathematical formula to compute `capitalN` from the parameters, but
    we will not use it here. This formula works well for fixed interest rates, but
    we will use variable interest rates later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We first generate a collection of integers using `0 to nbOfMonths`, and we then
    iterate through it using `foldLeft`. `foldLeft` is one of the most powerful functions
    in the Scala collection library. Many other functions in the `collections` library
    could be implemented just by using `foldLeft`, such as `reverse`, `last`, `contains`,
    `sum`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Scala SDK, the signature of `foldLeft` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see its definition in IntelliJ by pointing at it with the mouse and
    using cmd + left-click. This introduces some new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[B]` means that the function has a **type parameter** named `B`. When we call
    the function, the compiler automatically infers what `B` is, depending on the
    type of the `z: B` argument. In our code, the `z` argument is `initialCapital`,
    of type `Double`. Therefore, our call to `foldLeft` in `futureCapital` will behave
    as if the function was defined with `B = Double`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def foldLeft(z: Double)(op: (Double, A) => Double): Double`.'
  prefs: []
  type: TYPE_NORMAL
- en: The function has two parameter lists. Scala allows you to have many parameter
    lists. Each list can have one or many parameters. This does not change the behavior
    of the function; it is just a way of separating the concerns of each parameter
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`op: (B, A) => B` means that `op` must be a function that has two parameters
    of type `B` and `A` and returns a value of type `B`. Since `foldLeft` is a function
    that takes another function as an argument, we say that `foldLeft` is a **higher
    order function**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we consider a `coll` collection, `foldLeft` works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It creates a `var acc = z` accumulator then calls the `op` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`acc = op(acc, coll(0))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It carries on calling `op` with each element of the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`acc = op(acc, coll(i))`'
  prefs: []
  type: TYPE_NORMAL
- en: It returns `acc` once it has iterated through all elements of the collection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `futureCapital` function, we pass `op = nextCapital`. The `foldLeft`
    will iterate through all `Int` between `1` and `nbOfMonths`, each time computing
    the capital using the previous capital. Note that, for now, we do not use the
    `month` parameter in `nextCapital`. We must declare it, though, because the `op` function
    in `foldLeft` must have two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the `RetCalcSpec` unit test again. It should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the production code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the TDD approach, it is common to refactor the code once we have passing
    tests. If our test coverage is good, we should not have any fear of changing the
    code, because any mishap should be flagged by a failing test. This is known as
    a **Red-Green-Refactor** cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the body of `futureCapital` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have inlined the `nextCapital` function in the `foldLeft` call. In
    Scala, we can define an **anonymous function** using the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We saw earlier that the `month` parameter in `nextCapital` was not used. In
    an anonymous function, it is a good practice to name any unused parameter with
    `_`. A parameter named `_` cannot be used in the function body. If you try to
    replace the `_` character with a name, IntelliJ will underline it. If you hover
    the mouse over it, you will see a popup stating `Declaration is never used`. You
    can then hit *Alt* + *Enter* and choose to remove the unused element to automatically
    change it back to `_`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test for the decumulation phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how much capital you can expect at your retirement date. It turns
    out you can reuse the same `futureCapital` function, to work out how much capital
    will be left for your heirs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test in `RetCalcSpec`, underneath the previous unit test,
    and run it. It should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, if you live for 40 years after your retirement date, spend the same amount
    every month, and don't have any other income, you will still have a significant
    capital left for your heirs. If the remaining capital was negative, that would
    have meant that you would have run out of money at some point during your retirement
    and it is an outcome we want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to call the function from the Scala Console and try different values
    that would match more closely to your personal situation. Try different values
    for the interest rate and observe how you can end up with a negative capital if
    the rate is low.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in a production system, you would certainly add more unit tests to
    cover some other edge cases and make sure that the function will not crash. As
    we will cover error handling in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*, we can assume that the test coverage of `futureCapital` is good enough
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a retirement plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to calculate the capital at retirement and after death,
    it would be useful to combine the two calls in a single function. This function
    will simulate a retirement plan in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a failing unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the unit test you need to add to `RetCalcSpec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the call to `simulatePlan`, and hit *Alt* + *Enter* to let IntelliJ
    create the function for you in `RetCalc`. It should have the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now compile the project with cmd + *F9*, and run `RetCalcSpec`. It should fail
    since the `simulatePlan` function must return two values. The simplest way of
    modeling the return type is to use `Tuple2`. In Scala, a tuple is an immutable
    data structure which holds several objects of different types. The number of objects
    contained in a tuple is fixed. It is akin to a case class, which does not have
    specific names for its attributes. In type theory, we say that a tuple or a case
    class is a **product type**.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type the following in the Scala Console to get more familiar with tuples. Feel
    free to experiment with different types and sizes of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can create tuples of any length up to 22, and access their elements using
    `_1`, `_2`, and so on. You can also declare several variables in one go for each
    element of the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing simulatePlan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation for `simulatePlan` is straightforward; we call `futureCapital`
    twice with different arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run `RetCalcSpec` again, and it should pass now. Feel free to experiment calling
    `simulatePlan` from the Scala Console with different values.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating when you can retire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have tried to call `simulatePlan` from the Scala Console, you probably
    tried different values for `nbOfMonths` and observed the resulting capital at
    retirement and after death. It would be useful to have a function that finds the
    optimal `nbOfMonths` so that you have enough capital to never run out of money
    during your retirement.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a failing test for nbOfMonthsSaving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, let''s start with a new unit test to clarify what we expect from
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this test, the expected value can be a bit difficult to figure out. One way
    would be to use the `NPM` function in Excel. Alternatively, you could call `simulatePlan`
    many times in the Scala Console, and increase `nbOfMonthsSaving` to gradually
    find out what the optimal value is.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the function body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, we avoid mutating variables. In an imperative language,
    you would typically implement `nbOfMonthsSaving` by using a `while` loop. It is
    also possible to do so in Scala, but it is a better practice to only use immutable
    variables. One way of solving this problem is to use recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We declare the recursive function inside the body of the function, as it is
    not meant to be used anywhere else. The `loop` function increments `months` by
    `1` until the calculated `capitalAfterDeath` is positive. The `loop` function
    is initiated in the body of `nbMonthsSaving` with `months = 0`. Note that IntelliJ
    highlights the fact that the `loop` function is recursive with a kind of `@` sign.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can run our unit test again, and it should pass. However, we are not
    quite done yet. What happens if you can never reach a month that would satisfy
    the condition `capitalAfterDeath > 0.0`? Let's find out by writing another test.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding tail-recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following tests underneath the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will implement the `not loop forever` later on. It is a good practice to
    write pending tests as soon as you think about new edge cases or other use cases
    for your function. It helps to keep a direction toward the end goal, and gives
    some momentum—as soon as you have made the previous test pass, you know exactly
    what test you need to write next.
  prefs: []
  type: TYPE_NORMAL
- en: Run the test, and it will fail with `StackOverflowError`. This is because each
    time `loop` is called recursively, local variables are saved onto the JVM stack.
    The size of the stack is quite small, and as we can see, it is quite easy to fill
    it up. Fortunately, there is a mechanism in the Scala compiler to automatically
    transform tail-recursive calls into a `while` loop. We say that a recursive call
    (the call to the `loop` function inside the `loop` function) is tail-recursive
    when it is the last instruction of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily change our previous code to make it tail-recursive. Select `returnValue`,
    and hit cmd + *O* to inline the variable. The body of the `loop` function should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: IntelliJ changed the small symbol in the editor's margin to highlight the fact
    that our function is now tail-recursive. Run the test again and it should pass.
    It is a good practice to also put an annotation `@tailrec` before the function
    definition. This tells the compiler that it must verify that the function is indeed
    tail-recursive. If you annotate a `@tailrec` function that is not tail-recursive,
    the compiler will raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: When you know that the depth of a recursive call can be high (more than 100),
    always make sure it is tail-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a tail-recursive function, always annotate it with `@tailrec`
    to let the compiler verify it.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not quite done yet because our function might loop indefinitely. Imagine
    that you always spend more than what you earn. You will never be able to save
    enough to retire, even if you live a million years! Here is a unit test highlighting
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We decided to use a special value `Int.MaxValue` to indicate that `nbOfMonths`
    is infinite. This is not very pretty, but we will see in the next chapter how
    we can model this better with `Option` or `Either`. This is good enough for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, we just need to add an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using market rates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our calculations, we have always assumed that the interest rate of return
    was constant, but the reality is more complex. It would be more accurate to use
    real rates from market data to gain more confidence with our retirement plan.
    For this, we first need to change our code to be able to perform the same calculations
    using variable interest rates. Then, we will load real market data to simulate
    regular investments in a fund by tracking the S & P 500 index.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an algebraic data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to support variable rates, we need to change the signature of all
    functions that accept `interestRate: Double`. Instead of a double, we need a type
    that can represent either a constant rate or a sequence of rates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering two types `A` and `B`, we previously saw how to define a type that
    can hold a value of type `A` and a value of type `B`. This is a product type,
    and we can define it using a tuple, such as `ab: (A, B)`, or a case class, such
    as `case class MyProduct(a: A, b: B)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a type that can hold either `A` **or** `B` is a sum type,
    and in Scala, we declare it using a `sealed` trait inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An **Algebraic Data Type** (**ADT**) is a type that composes sum types and product
    types to define a data structure. In the preceding code, we defined a `Shape`
    ADT, which composes a sum type (a `Shape` can be a `Circle` or a `Rectangle`),
    with a product type `Rectangle` (a `Rectangle` holds a width and a height).
  prefs: []
  type: TYPE_NORMAL
- en: The `sealed` keyword indicates that all subclasses of the trait must be declared
    in the same `.scala` file. If you attempt to declare a class that extends a `sealed`
    trait in another file, the compiler will reject it. This is used to guarantee
    that our inheritance tree is complete, and as we will see later on, it has interesting
    benefits when it comes to using pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our problem, we can define a `Returns` ADT as follows. Create
    a new Scala class in the `retcalc` package in `src/main/scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For `VariableReturn`, we keep the monthly interest rate and an identifier `monthId`
    that will have the form *2017.02*, for February 2017\. I recommend that you use
    `Vector` whenever you need to model a sequence of elements. `Vector` is faster
    than `List` for appending/inserting elements or accessing an element by index.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering returns for a specific period
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have `VariableReturns` over a long period, for instance, 1900 to 2017,
    it can be interesting to use a smaller period to simulate what would happen if
    the historical returns in a smaller period, say 50 years, would be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a method in the `VariableReturns` class that will keep
    only the returns contained in a specific period. Here is the unit test in `ReturnsSpec.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we generate a sequence of returns and assign them to `variableReturns` using
    the function `Vector.tabulate`. It generates 12 elements, and each element is
    produced by an anonymous function, taking a parameter `i` that will go from `0`
    to `11`. In the call to the `VariableReturn` constructor, for the `monthId` argument,
    we use the `f` interpolator to generate a string in the form `2017.01` when `d
    = 1`, `2017.02` when `d = 2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The function `fromUntil` that we are specifying will return a `VariableReturns`
    type that contains a specific window inside the original returns. For now, we
    assume that the arguments passed to `fromUntil` are valid months that are present
    in `variableReturns`. Ideally, we should add unit tests to specify what should
    happen if they are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation in `Returns.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We use the higher order function `dropWhile` to drop elements until we reach
    the condition `monthId == monthIdFrom`. Then, we call `takeWhile` on the resulting
    collection to keep all elements until `monthId == monthIdUntil`. This will return
    a collection that keeps only the elements in a window that starts at `monthIdFrom`
    and ends just before `monthIdUntil`.
  prefs: []
  type: TYPE_NORMAL
- en: Run `ReturnsSpec`, and it should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a way of expressing variable returns, we need to change our `futureCapital` function
    to accept a `Returns` type instead of a monthly interest rate of type `Double`.
    Change the tests first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the `futureCapital` function in `RetCalc` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of just using the `interestRate` in the formula, we introduced
    a new function called `Returns.monthlyRate` which we must now create. As we follow
    a rather strict TDD approach, we will only create its signature first, then write
    the unit test, and finally implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the function signature in `Returns.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new unit test `ReturnsSpec` in the `retcalc` package in `src/test/scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These tests act as a specification for our `monthlyRate` function. For `VariableRate`,
    the `monthlyRate` must return the *n^(th)* rate stored in the returned `Vector`.
    If *n* is greater than the number of rates, we decide that `monthlyRate` should
    go back to the beginning of `Vector`, as if the history of our variable returns
    would repeat itself infinitely. We could have made a different choice here, for
    instance, we could have taken a mirror of the returns, or we could have just returned
    some error if we reached the end. To implement this rotation, we are taking the
    month value and applying the modulo ( `*%*` in Scala ) of the length of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation introduces a new element of syntax, called **pattern matching**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can now run `ReturnsSpec`, and all tests should pass. Pattern matching allows
    you to deconstruct an ADT and evaluate some expression when it matches one of
    the patterns. You can also assign variables along the way and use them in the
    expression. In the preceding example, `case FixedReturns(r) => r/12` can be interpreted
    as "if the variable `returns` is of type `FixedReturns`, assign `r = returns.annualRate`,
    and return the result of the expression `r/12`".
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example, but you can use much more complicated patterns. This
    feature is very powerful, and can often replace lots of `if`/`else` expressions.
    You can try some more complex patterns in the Scala Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is a good practice to exhaustively match all possible patterns for your value.
    Otherwise, if no pattern matches the value, Scala will raise a runtime exception,
    and it might crash your program. However, when you use `sealed` traits, the compiler
    is aware of all the possible classes for a trait and will issue a warning if you
    do not match all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Returns.scala`, try to comment out this line with cmd + */*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Recompile the project with cmd + *F9*. The compiler will warn you that you
    are doing something wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you then try to remove the `sealed` keyword and recompile, the compiler will
    not issue any warning.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good grasp of how to use pattern matching. Keep the `sealed` keyword,
    revert the comment in `monthlyRate`, and run `ReturnsSpec` to make sure everything
    is green again.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from an object-oriented language, you might wonder why we
    did not implement `monthlyRate` using an abstract method with implementations
    in `FixedRate` and `VariableRate`. This is perfectly feasible in Scala, and some
    people might prefer this design choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as I am an advocate of a functional programming style, I prefer using
    pure functions in objects:'
  prefs: []
  type: TYPE_NORMAL
- en: They are easier to reason about, as the whole dispatching logic is in one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be moved to other objects easily, which facilitates refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a more limited scope. In class methods, you always have all the attributes
    of the class in scope. In a function, you only have the parameters of the function.
    This helps unit testing and readability, as you know that the function cannot
    use anything else but its parameters. Also, it can avoid side effects when the
    class has mutable attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes in object-oriented design, when a method manipulates two objects,
    `A` and `B`, it is not clear if the method should be in class `A` or class `B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring simulatePlan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we changed the signature of `futureCapital`, we also need to change the
    callers of that function. The only caller is `simulatePlan`. Before introducing
    variable rates, the implementation was straightforward: we just had to call `futureCapital`
    for the accumulation and decumulation phases with the same fixed rate argument.
    However, with variable rate, we must make sure that the decumulation phase uses
    the rates that follow the rates of the accumulation phase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider that you started saving in 1950, and retired in 1975\.
    For the accumulation phase, you need to use the returns from 1950 to 1975, and
    for the decumulation, you must use the returns from 1975\. We created a new unit
    test to make sure that we are using different returns for the two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since `simulatePlan` has quite a lot of parameters apart from the `returns` parameter,
    we decided to put them in a case class called `RetCalcParams`. This way, we are
    able to reuse the same parameters for different unit tests. We will also be able
    to reuse it in `nbMonthsSaving`. As seen previously, we use the function `tabulate`
    to generate values for our variable returns.
  prefs: []
  type: TYPE_NORMAL
- en: The expected value for `capitalAtRetirement` can be obtained with Excel by using
    `-FV(0.04/12, 25*12, 1000, 10000)`. The expected value for `capitalAfterDeath`
    can be obtained by using `-FV(0.03/12, 40*12, -2000, 541267.20)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation in `RetCalc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `import params._`, brings all the parameters of `RetCalcParams`
    into scope. This way, you can directly use, for instance, `netIncome` without
    having to prefix it with `params.netIncome` . In Scala, you can not only import
    classes from a package, but also functions or values from an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second call to `futureCapital`, we introduce a new subclass called `OffsetReturns`,
    which will shift the starting month. We need to write a new unit test for it in
    `ReturnsSpec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding implementation in `Returns.scala` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For an offset return, we call `monthlyRate` recursively and add the offset to
    the requested month.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can compile everything with cmd + *F9* and rerun the unit tests. They
    should all pass.
  prefs: []
  type: TYPE_NORMAL
- en: Loading market data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to calculate the real monthly returns of our investments in a fund
    tracking the S & P 500, we are going to load a tab-separated file containing the
    S & P 500 prices and dividends, and another file containing the consumer price
    index. This will let us calculate a real rate of return, stripped out of inflation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the unit test using the column selection mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, copy `sp500_2017.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    to `src/test/resources`. Then, create a new unit test called `EquityDataSpec` in
    the `retcalc` package. If you retype this example, try the column selection mode
    (*Alt* + *Shift* + *Insert*). Copy the content of the `.tsv` file in the test,
    then select the first column with *Shift* + *Down* 13 times, and then type `EquityData("`.
    Finally, edit the rest of the lines using the arrow keys, delete, comma, and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first lines of `sp500_2017.tsv` look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Loading the file with Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our implementation must drop the first line which contains the headers, then
    for each line, split and create a new instance of `EquityData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code is quite compact, and you might lose a sense of what types are returned
    by intermediate calls. In IntelliJ, you can select a portion of code and hit *Alt*
    + *=* to show the inferred type of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: We first load the `.tsv` file using `scala.io.Source.fromResource`. This takes
    the name of a file located in a `resource` folder and returns a `Source` object.
    It can be in `src/test/resources` or `src/main/resources`. When you run a test,
    both folders will be searched. If you run the production code, only the files
    in `src/main/resources` will be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '`getLines` returns `Iterator[String]`. An **iterator** is a **mutable** data
    structure that allows you to iterate over a sequence of elements. It provides
    many functions that are common to other collections. Here, we drop the first line,
    which contains the header, and transforms each line using an anonymous function
    passed to `map`.'
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous function takes `line` of type string, transforms it into `Array[String]`
    using `split`, and instantiates a new `EquityData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we convert the resulting `Iterator[EquityData]` into `Vector[EquityData]` using
    `.toVector`. This step is very important: we convert the mutable, unsafe, iterator
    into an immutable, safe `Vector`. Public functions should, in general, not accept
    or return mutable data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes the code harder to reason about, as you have to remember the state
    the mutable structure is in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program will behave differently depending on the order/repetition of the
    function calls. In the case of an iterator, it can be iterated only once. If you
    need to iterate again, you won''t get any data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Loading inflation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can load some equity data, we need to load inflation data so that
    we're able to compute inflation-adjusted returns. It is very similar to the loading
    of equity data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy `cpi_2017.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    to `src/test/resources`. Then, create a new unit test called `InflationDataSpec`
    in the `retcalc` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the corresponding `InflationData` class and companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Computing real returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a given month, *n*, the real return is *return*[n] *- inflationRate*[n],
    hence the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0504af4-084c-4252-b1b8-74ab19365329.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to create a new function in `Returns` that creates `VariableReturns`
    using `Vector[EquityData]` and `Vector[InflationData]`. Add the following unit
    test to `ReturnsSpec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We create two small `Vector` instances of `EquityData` and `InflationData`,
    and calculate the expected value using the preceding formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of `fromEquityAndInflationData` in `Returns.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we `zip` the two `Vectors` to create a collection of tuples, `(EquityData,
    InflationData)`. This operation brings our two collections together as if we were
    zipping a jacket. It is a good habit to play around with the Scala Console to
    get a sense of what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that the resulting `Vector` has a size that is the minimum size of the
    two arguments. The last element, `"c"`, is lost, because there is nothing to zip
    it with!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good start, as we could now iterate through a collection that can
    give us *price^n*, *dividends^n*, and *inflation^n*. But in order to calculate
    our formula, we also need the previous data on *n-1*. For this, we use `sliding(2)`.
    I encourage you to read the documentation on sliding. Let''s try it in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`sliding(p)` creates an `Iterator` which will produce collections of size `p`.
    Each collection will have a new iterated element plus all the previous `p-1` elements.
    Notice that if the collection size *n* is lower than `p`, the produced collection
    will have a size of *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we iterate through the sliding collections using `collect`. `collect`
    is similar to `map`: it allows you to transform the elements of a collection,
    but with the added capability of filtering them. Basically, whenever you want
    to `filter` and `map` a collection, you can use `collect` instead. The filtering
    is performed using pattern matching. Anything that does not match any pattern
    is filtered out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in the preceding code, we used `map(_ + 1)` instead of `map(i =>
    i + 1)`. This is a shorthand notation for an anonymous function. Whenever you
    use a parameter once in your anonymous function, you can replace it with `_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we pattern match on our zipped and sliding elements using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This has the benefit of filtering out sliding elements of size `0` or `1`, if
    we were passing equities or inflation arguments of size `0` or `1`. We will not
    write a unit test for this edge case in this book, but I encourage you to do so
    as an excercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the function is straightforward: we use the matched variables to
    compute the formula and create a new `VariableReturn` instance. The resulting
    iterator is converted to `Vector`, and we instantiate a `VariableReturns` case
    class using it.'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now implemented some useful building blocks, and it is time to create
    an executable so that end users can use our calculator with their own parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the App object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a simple executable around `RetCalc.simulatePlan`. It
    will take a list of parameters separated by spaces, and print the results on the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: The test we are going to write integrates several components together and will
    use a full market data set. As such, it is not really a unit test anymore; it
    is an integration test. For this reason, we suffixed it with IT instead of Spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy `sp500.tsv` and `cpi.tsv` from [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv)
    and [https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv](https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv)
    to `src/main/resources`, then create a new unit test called `SimulatePlanIT` in
    `src/test/scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We call a function called `strMain` which will return a string instead of printing
    it to the console. This way, we can assert on the content printed to the console.
    To keep things simple, we assume that the arguments are passed in a specific order.
    We will develop a more user-friendly interface in the next chapter. The arguments
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A period that we will use in the variables returns, separated by a comma
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of years of savings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of years in retirement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Income
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expenses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initial capital
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The expected value is a string that we define using triple quotes. In Scala,
    a string enclosed in triple quotes lets you enter special characters such as a
    quote or newline. It is very convenient to enter multiline strings while keeping
    a good indentation. The `|` characters allow you to mark the beginning of each
    line, and the `.stripMargin` function removes the white spaces before the `|`,
    as well as the `|` itself in order. In IntelliJ, when you type `"""` and then
    hit *Enter*, it automatically adds the `|` and `.stripMargin` after the closing
    triple quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation calls the different functions we implemented earlier. Notice
    that IntelliJ can autocomplete the name of the files using *Ctrl* + spacebar,
    for instance, after `EquityData.fromResource("Create a new object SimulatePlanApp
    in the package retcalc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The only code executed when we run our executable will be `println(strMain(args))`.
    It is a good practice to keep this code as short as possible because it is not
    covered by any test. Our function `strMain` is covered, so we are fairly sure
    there won't be any unexpected behavior from a single `println`. `args` is an `Array[String]`
    containing all the arguments passed to the executable.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of `strMain` uses a pattern matching on `List` to assign `from`
    and `until`. The variables will be assigned only if the split first argument,
    in our test `"1997.09,2017.09"`, is a `List` of two elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we load the equity and inflation data from our `.tsv` files. They contain
    data from 1900.01 until 2017.09\. We then call `Returns.fromEquityAndInflationData`
    to compute the real returns.
  prefs: []
  type: TYPE_NORMAL
- en: After having assigned the returns to `allReturns`, we call `simulatePlan` with
    the right arguments. The returns are filtered for a specific period using `from`
    and `until`. Finally, we return `String` using a string interpolation and triple
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is the first draft and is quite brittle. It will indeed
    crash with a horrible `ArrayIndexOutOfBoundsException` if we do not pass enough
    parameters to our executable, or with a `NumberFormatException` if some strings
    cannot be converted to `Int` or `Double`. We will see in the next chapter how
    we can handle these error cases gracefully, but for now, our calculator does the
    job as long as we feed it with the right arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run `SimulatePlanIT`, and it should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we built an application, we can also run it as such. Move your cursor
    to `SimulatePlanApp`, and hit *Ctrl* + *Shift* + *R*. The app should run and crash
    with an exception because we did not pass any arguments. Click on the launcher
    for `SimulatePlanApp` (underneath the Build menu), then click Edit Configurations.
    Put the following in program arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, click OK, and run `SimulatePlanApp` again. It should print the same content
    as what we had in our unit test. You can try calling the application with different
    parameters and observe the resulting calculated capitals.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far so good, but what if we want to send this application to uncle Bob so
    that he can plan for his retirement too? It would not be very convenient to ask
    him to download IntelliJ or SBT. We are going to package our application in a
    `.jar` file so that we can run it with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'SBT provides a package task that can create a `.jar` file, but this file will
    not contain the dependencies. In order to package our own classes as well as the
    classes coming from the dependent libraries, we are going to use the `sbt-assembly`
    plugin. Create a new file called `project/assembly.sbt` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit `build.sbt` to define the name of our main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the SBT tab on the top-right and then on the Refresh button. Then,
    expand the project and double-click on the assembly task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/536aabaa-077d-46d6-af9c-bbd39c9d0cc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The assembly task will compile all the classes, run all the tests, and if they
    all pass, package a fat JAR. You should see an output similar to this at the bottom
    of the SBT console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the location of the `.jar` file in your clipboard. Now, you can use a
    Unix terminal or a Windows command prompt and run the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now easier to try different parameters. It is interesting to see that
    some periods are much more lucrative than others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered how to create a small project in Scala from scratch to packaging.
    We used TDD along the way so that it is guaranteed that our code was well-designed
    and robust. It gives us confidence when we refactor code: as long as all tests
    pass, we know that our code stills works. We modeled our domain with immutable
    data structures and processed them using pure functions that have no side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: We used some basic features of the language that are used in most projects,
    and you should now be familiar with enough building blocks to implement a wide
    variety of projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a further exercise, you could enhance this calculator with one or many of
    these features:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an app for the function `RetCalc.nbOfMonthsSaving`, which calculates
    how long you need to save before you can retire.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function called `RetCalc.annualizedTotalReturn`, which calculates the
    geometric average of a sequence of returns. See [https://www.investopedia.com/terms/a/annualized-total-return.asp](https://www.investopedia.com/terms/a/annualized-total-return.asp)[ ](https://www.investopedia.com/terms/a/annualized-total-return.asp)for
    more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a function called `monthlyPension`, which calculates how much you will
    get in retirement if you save a given amount every month for a given number of
    months.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate other streams of income. Maybe you will get a state pension after
    a number of years, or you might get an inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load a different index, such as STOXX Europe 600, MSCI World Index, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most people do not invest all their savings in the stock market, but wisely
    diversify with bonds, that is, typically 60% stocks, 40% bonds. You could add
    a new function in `Returns.scala` to calculate the returns of a mixed portfolio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We observed that some periods have much higher returns than others. As it is
    difficult to predict the future, you could run multiple simulations using different
    periods, and calculate a probability of success.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will improve our calculator further by handling errors
    in a functional way.
  prefs: []
  type: TYPE_NORMAL
