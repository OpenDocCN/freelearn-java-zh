- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with Spring
    Security*, we demonstrated how to use an in-memory datastore to authenticate the
    user. In this chapter, we’ll explore how to solve some common, real-world problems
    by extending Spring Security’s authentication support to use our existing set
    of APIs. Through this exploration, we’ll get an understanding of each of the building
    blocks that Spring Security uses in order to authenticate users.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Spring Security’s annotations and Java-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering how to obtain the details of the currently logged-in user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the ability to log in after creating a new account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the simplest method for indicating to Spring Security that a user is
    authenticated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom `UserDetailsService` and `AuthenticationProvider` implementations
    that properly decouple the rest of the application from Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding domain-based authentication to demonstrate how to authenticate with more
    than just a username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/5tPFD](https://packt.link/5tPFD).'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication architecture in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The realm of application security essentially involves addressing two largely
    independent issues: authentication (identifying *who you are*) and authorization
    (determining *what you are allowed* *to do*).'
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, individuals may use the term *access control* interchangeably
    with *authorization*, adding a layer of potential confusion.
  prefs: []
  type: TYPE_NORMAL
- en: However, framing it as *access control* can offer clarity, considering the multifaceted
    use of the term *authorization* elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security adopts an architecture deliberately crafted to segregate authentication
    from authorization, providing distinct strategies and extension points for each.
    We will uncover in this section the main architectural components of Spring Security
    used for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The SecurityContextHolder class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of Spring Security’s authentication model is the `SecurityContextHolder`.
    It contains the `SecurityContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Spring Security’s SecurityContextHolder](img/B21757_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Spring Security’s SecurityContextHolder
  prefs: []
  type: TYPE_NORMAL
- en: The SecurityContext interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SecurityContextHolder` is where Spring Security stores the details of who
    is authenticated. Spring Security does not care how `SecurityContextHolder` is
    populated. If it contains a value, it is used as the currently authenticated user.'
  prefs: []
  type: TYPE_NORMAL
- en: The Authentication interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Authentication** interface in Spring Security serves dual purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It acts as input for `AuthenticationManager`, supplying the user’s provided
    credentials for authentication. In this context, the method `isAuthenticated()`
    returns false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as a representation of the presently authenticated user, retrievable
    from the `SecurityContext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key components within the **Authentication** interface include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserDetails`, especially in username/password authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Credentials**: This typically encompasses a password. In many instances,
    this information is cleared post-authentication to prevent inadvertent leakage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GrantedAuthority` instances denoting high-level permissions granted to the
    user. Examples include roles and scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AuthenticationManager interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AuthenticationManager` serves as the API specifying how authentication is
    conducted by Spring Security’s Filters. The resulting authentication is subsequently
    established on `SecurityContextHolder` by the invoking controller (i.e., Spring
    Security’s `Filters` instances).'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not integrating with Spring Security’s `Filters` instances, you have
    the option to directly set `SecurityContextHolder` without the need for `AuthenticationManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `AuthenticationManager`’s implementation can vary, the prevalent
    choice is often `ProviderManager`.
  prefs: []
  type: TYPE_NORMAL
- en: The ProviderManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ProviderManager` stands out as the frequently employed realization of `AuthenticationManager`.
    It delegates responsibilities to a list of `AuthenticationProvider` instances.
    Each `AuthenticationProvider` possesses the capability to express whether authentication
    should succeed, fail, or delegate the decision-making to a subsequent `AuthenticationProvider`.
    In the event that none of the configured `AuthenticationProvider` instances can
    authenticate, the authentication process results in a `ProviderNotFoundException`.
    This particular `AuthenticationException` signifies that the `ProviderManager`
    lacked configuration to support the specific **authentication** type provided
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Spring Security SecurityContextHolder](img/B21757_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Spring Security SecurityContextHolder
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, every `AuthenticationProvider` is equipped to carry out
    a distinct authentication method. For instance, one `AuthenticationProvider` may
    validate a username/password, while another is capable of authenticating a `SAML
    Assertion`. This setup empowers each `AuthenticationProvider` to handle a specialized
    form of authentication, accommodating various authentication types and presenting
    only a singular `AuthenticationManager` bean.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Spring Security SecurityContextHolder](img/B21757_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Spring Security SecurityContextHolder
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `ProviderManager` enables the configuration of an optional parent
    `AuthenticationManager`. This parent `AuthenticationManager` is consulted when
    no `AuthenticationProvider` is able to execute authentication. The parent can
    take on any form of `AuthenticationManager`, with `ProviderManager` frequently
    being the chosen type.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple instances of `ProviderManager` can have a shared parent `AuthenticationManager`.
    This occurrence is quite typical in situations where multiple `SecurityFilterChain`
    instances share a common authentication process (represented by the shared parent
    `AuthenticationManager`). However, these instances may also employ different authentication
    mechanisms, each managed by distinct `ProviderManager` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Spring Security’s SecurityContextHolder](img/B21757_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Spring Security’s SecurityContextHolder
  prefs: []
  type: TYPE_NORMAL
- en: By default, `ProviderManager` attempts to remove any sensitive credential information
    from the `Authentication` object returned upon a successful authentication request.
    This precautionary measure ensures that sensitive details, such as passwords,
    are not stored in the `HttpSession` for longer than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The AuthenticationProvider interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to inject multiple instances of `AuthenticationProviders` into
    `ProviderManager`. Each `AuthenticationProvider` is responsible for a specific
    form of authentication. For instance, `DaoAuthenticationProvider` is designed
    for username/password-based authentication, while `JwtAuthenticationProvider`
    specializes in authenticating JSON Web Tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the JBCP calendar architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this chapter by analyzing the domain model within the **JBPC**
    **Calendar** architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of an Unsafe Application*,
    and [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with Spring
    Security*, we used the Spring **Bill Of Materials** (**BOM**) to assist in dependency
    management, but the rest of the code in the projects used the core Spring Framework
    and required manual configuration. Starting with this chapter, we will be using
    Spring Boot for the rest of the applications, to simplify the application configuration
    process. The Spring Security configuration we will be creating will be the same
    for both a Spring Boot and a non-Boot application. We will cover more details
    on Spring IO and Spring Boot in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will delve into the domain model of the JBCP calendar
    application. We aim to gain insights into the process of incorporating Spring
    Security with personalized user configurations and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarUser object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our calendar application uses a domain object named `CalendarUser`, which contains
    information about our users, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Event object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application has an `Event` object that contains information about each
    event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The CalendarService interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application contains a `CalendarService` interface that can be used to
    access and store our domain objects. The code for `CalendarService` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We won’t go over the methods used in `CalendarService`, but they should be fairly
    straightforward. If you would like details about what each method does, please
    consult the Javadoc in the sample code.
  prefs: []
  type: TYPE_NORMAL
- en: The UserContext interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like most applications, our application requires us to interact with the currently
    logged-in user. We have created a very simple interface called `UserContext` to
    manage the currently logged-in user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that our application can call `UserContext.getCurrentUser()` to obtain
    the details of the currently logged-in user. It can also call `UserContext.setCurrentUser(CalendarUser)`
    to specify which user is logged in. Later in this chapter, we will explore how
    we can write an implementation of this interface that uses Spring Security to
    access our current user and obtain their details using `SecurityContextHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides quite a few different methods for authenticating a
    user. However, the net result is that Spring Security will populate `o.s.s.core.context.SecurityContext
    with o.s.s.core.Authentication`. The `Authentication` object represents all the
    information we gathered at the time of authentication (username, password, roles,
    and so on). The `SecurityContext` interface is then set on the `o.s.s.core.context.SecurityContextHolder`
    interface. This means that Spring Security and developers can use `SecurityContextHolder`
    to obtain information about the currently logged-in user. An example of obtaining
    the current username is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that `null` checks should always be done on the `Authentication`
    object, as this could be `null` if the user is not logged in.
  prefs: []
  type: TYPE_NORMAL
- en: The SpringSecurityUserContext interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current `UserContext` implementation, `UserContextStub`, is a stub that
    always returns the same user. This means that the **My Events** page will always
    display the same user no matter who is logged in. Let’s update our application
    to utilize the current Spring Security user’s username, to determine which events
    to display on the **My** **Events** page.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should be starting with the sample code in `chapter03.00- calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to comment out the `@Component` attribute on `UserContextStub`,
    so that our application no longer uses our scanned results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `@Component` annotation is used in conjunction with the `@Configuration`
    annotation found in `com/packtpub/springsecurity/web/configuration/WebMvcConfi
    g.java,` to automatically create a Spring bean rather than creating an explicit
    XML or Java configuration for each bean. You can learn more about the classpath
    of Spring scanning at [https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml](https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to utilize `SecurityContext` to obtain the currently logged-in
    user. We have included `SpringSecurityUserContext` within this chapter’s code,
    which is wired up with the necessary dependencies but contains no actual functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `SpringSecurityUserContext.java` file and add the `@Component` annotation.
    Next, replace the `getCurrentUser` implementation, as illustrated in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our code obtains the username from the current Spring Security `Authentication`
    object and utilizes that to look up the current `CalendarUser` object by email
    address. Since our Spring Security username is an email address, we can use the
    email address to link `CalendarUser` with the Spring Security user. Note that
    if we were to link accounts, we would normally want to do this with a key that
    we generated rather than something that may change (that is, an email address).
    We follow the good practice of returning only our domain object to the application.
    This ensures that our application is only aware of our `CalendarUser` object and
    thus is not coupled to Spring Security.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code may seem eerily similar to when we used the `sec:authorize=` **"isAuthenticated()"**
    tag attribute in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*, to display the current user’s username. In fact, the Spring
    Security tag library uses `SecurityContextHolder` in the same manner as we have
    done here. We could use our `UserContext` interface to place the current user
    on `HttpServletRequest` and thus remove our dependency on the Spring Security
    tag library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start up the application, visit `http://localhost:8080/`, and log in with `admin1@example.com`
    as the username and `admin1` as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the **My Events** page and you will see that only the events for that
    current user, who is the owner or the attendee, are displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try creating a new event; you will observe that the owner of the event is now
    associated with the logged-in user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out of the application and repeat these steps with `user1@example.com` as
    the username and `user1` as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the JBCP calendar architecture. In the next
    session, we will see how to manage new users using `SecurityContextHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in new users using SecurityContextHolder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement is to allow users to create a new account and then automatically
    log them into the application. In this section, we’ll describe the simplest method
    for indicating that a user is authenticated, by utilizing `SecurityContextHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users in Spring Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application provided in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, provides a mechanism for creating a new `CalendarUser`
    object, so it should be fairly easy to create our `CalendarUser` object after
    a user signs up. However, Spring Security has no knowledge of `CalendarUser`.
    This means that we will need to add a new user in Spring Security, too. Don’t
    worry, we will remove the need for the dual maintenance of users later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security provides an `o.s.s.provisioning.UserDetailsManager` interface
    for managing users. Remember our in-memory Spring Security configuration?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `SecurityConfig.userDetailsService()` method creates an in-memory implementation
    of `UserDetailsManager`, named `o.s.s.provisioning.InMemoryUserDetailsManager`,
    which can be used to create a new Spring Security user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can manage users in Spring Security by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To expose `UserDetailsManager` using a Java-based configuration, we need to
    create `InMemoryUserDetailsManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have an exposed `UserDetailsManager` interface in our Spring configuration,
    all we need to do is update our existing `CalendarService` implementation, `DefaultCalendarService`,
    to add a user in Spring Security. Make the following updates to the `DefaultCalendarService.java`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To leverage `UserDetailsManager`, we first convert `CalendarUser` into the `UserDetails`
    object of Spring Security.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Later, we use `UserDetailsManager` to save the `UserDetails` object. The conversion
    is necessary because Spring Security has no understanding of how to save our custom
    `CalendarUser` object, so we must map `CalendarUser` to an object Spring Security
    understands. You will notice that the `GrantedAuthority` object corresponds to
    the `authorities` attribute of our `SecurityConfig` file. We hardcode this for
    simplicity and because there is no concept of roles in our existing system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging in a new user to an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can add new users to the system, we need to indicate that the user
    is authenticated. Update `SpringSecurityUserContext` to set the current user on
    the `SecurityContextHolder` object of Spring Security, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first step we perform is to convert our `CalendarUser` object into the `UserDetails`
    object of Spring Security. This is necessary because, just as Spring Security
    didn’t know how to save our custom `CalendarUser` object, Spring Security also
    does not understand how to make security decisions with our custom `CalendarUser`
    object. We use Spring Security’s `o.s.s.core.userdetails.UserDetailsService` interface
    to obtain the same `UserDetails` object we saved with `UserDetailsManager`. The
    `UserDetailsService` interface provides a subset of the functionality provided
    by Spring Security’s `UserDetailsManager` object that we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `UsernamePasswordAuthenticationToken` object and place `UserDetails`,
    the password, and `GrantedAuthority` in it. Lastly, we set the authentication
    on `SecurityContextHolder`. In a web application, Spring Security will automatically
    associate the `SecurityContext` object in `SecurityContextHolder` to our HTTP
    session for us.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is important that Spring Security must not be instructed to ignore a URL
    (that is, using the `permitAll()` method), as discussed in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*, in which `SecurityContextHolder` is accessed
    or set. This is because Spring Security will ignore the request and thus not persist
    `SecurityContext` for subsequent requests. The session management support is composed
    of a few components that work together to provide the functionality, so we used
    `securityContext.requireExplicitSave(false)` to persist the session.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is that there is no need to hit the datastore
    again. In our case, the datastore is an in-memory datastore, but this could be
    backed by a database, which could have some security implications. The disadvantage
    of this approach is that we do not get to reuse the code much. Since this method
    is invoked infrequently, we opt for reusing the code. In general, it is best to
    evaluate each situation separately to determine which approach makes the most
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Updating SignupController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application has a `SignupController` object, which is what processes the
    HTTP request to create a new `CalendarUser` object. The last step is to update
    `SignupController` to create our user and then indicate that they are logged in.
    Make the following updates to `SignupController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you have not done so already, restart the application, visit `http://localhost:8080/`,
    create a new user, and you can see that the new user is automatically logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the new user signup workflow. In the next section,
    we will create a custom `UserDetailsService` object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom UserDetailsService object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can link our domain model (`CalendarUser`) with Spring Security’s domain
    model (`UserDetails`), we have to maintain multiple representations of the user.
    To resolve this dual maintenance, we can implement a custom `UserDetailsService`
    object to translate our existing `CalendarUser` domain model into an implementation
    of Spring Security’s `UserDetails` interface. By translating our `CalendarUser`
    object into `UserDetails`, Spring Security can make security decisions using our
    custom domain model. This means that we will no longer need to manage two different
    representations of a user.
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarUserDetailsService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we have needed two different representations of users: one
    for Spring Security to make security decisions, and one for our application to
    associate our domain objects to. Create a new class named `CalendarUserDetailsService`
    that will make Spring Security aware of our `CalendarUser` object. This will ensure
    that Spring Security can make decisions based on our domain model. Create a new
    file named `CalendarUserDetailsService.java`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we utilize `CalendarUserDao` to obtain `CalendarUser` by using the email
    address. We take care not to return a null value; instead, a `UsernameNotFoundException`
    exception should be thrown, as returning `null` breaks the `UserDetailsService`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: We then convert `CalendarUser` into `UserDetails`, implemented by the user,
    as we did in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: We now utilize a utility class named `CalendarUserAuthorityUtils` that we provided
    in the sample code. This will create `GrantedAuthority` based on the email address
    so that we can support users and administrators. If the email starts with `admin`,
    the user is treated as `ROLE_ADMIN` and `ROLE_USER`. Otherwise, the user is treated
    as `ROLE_USER`. Of course, we would not do this in a real application, but it’s
    this simplicity that allows us to focus on this lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring UserDetailsService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a new `UserDetailsService` object, let’s update the Spring
    Security configuration to utilize it. Our `CalendarUserDetailsService` class is
    added to our Spring configuration automatically since we leverage `classpath`
    scanning and the `@Component` annotation. This means we only need to update Spring
    Security to refer to the `CalendarUserDetailsService` class we just created. `userDetailsService()`
    methods, Spring Security’s in-memory implementation of `UserDetailsService` since
    we are now providing our own `UserDetailsService` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SecurityConfig.java` file, as follows to declare a `DelegatingPasswordEncoder`
    with default mappings. Additional mappings may be added and the encoding will
    be updated to conform with best practices. However, due to the nature of `DelegatingPasswordEncoder`,
    the updates should not impact users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Removing references to UserDetailsManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to remove the code we added in `DefaultCalendarService` that used `UserDetailsManager`
    to synchronize the Spring Security `o.s.s.core.userdetails.User` interface and
    `CalendarUser`. First, the code is not necessary since Spring Security now refers
    to `CalendarUserDetailsService`. Second, since we removed the `inMemoryAuthentication()`
    method, there is no `UserDetailsManager` object defined in our Spring configuration.
    Go ahead and remove all references to `UserDetailsManager` found in `DefaultCalendarService`.
    The updates will look similar to the following sample snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up the application and see that Spring Security’s in-memory `UserDetailsManager`
    object is no longer necessary (we removed it from our `SecurityConfig.java` file).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarUserDetails object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have successfully eliminated the need to manage both Spring Security users
    and our `CalendarUser` objects. However, it is still cumbersome for us to continually
    need to translate between the two objects. Instead, we will create a `CalendarUserDetails`
    object, which can be referred to as both `UserDetails` and `CalendarUser`. Update
    `CalendarUserDetailsService` to use `CalendarUserDetails`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see that our application can now refer to the principal
    authentication on the current `CalendarUser` object. However, Spring Security
    can continue to treat `CalendarUserDetails` as a `UserDetails` object.
  prefs: []
  type: TYPE_NORMAL
- en: The SpringSecurityUserContext simplifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have updated `CalendarUserDetailsService` to return a `UserDetails` object
    that extends `CalendarUser` and implements `UserDetails`. This means that, rather
    than having to translate between the two objects, we can simply refer to a `CalendarUser`
    object. Update `SpringSecurityUserContext` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The updates no longer require the use of `CalendarUserDao` or Spring Security’s
    `UserDetailsService` interface. Remember our `loadUserByUsername` method from
    the previous section? The result of this method call becomes the principal of
    the authentication. Since our updated `loadUserByUsername` method returns an object
    that extends `CalendarUser`, we can safely cast the principal of the `Authentication`
    object to `CalendarUser`. We can pass a `CalendarUser` object as the principal
    into the constructor for `UsernamePasswordAuthenticationToken` when invoking the
    `setCurrentUser` method. This allows us to still cast the principal to a `CalendarUser`
    object when invoking the `getCurrentUser` method.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying custom user attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `CalendarUser` is populated into Spring Security’s authentication,
    we can update our UI to display the name of the current user rather than the email
    address. Update the `header.xhtml` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, the `"${#authentication.getPrincipal().getName()}"` tag attribute
    executes the following code. Observe that the highlighted values correlate to
    the `property` attribute of the `authentication` tag we specified in the `header.xhtml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application, visit `http://localhost:8080/`, and log in to view
    the updates. Instead of seeing the current user’s email, you should now see their
    first and last names.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the `CalendarUserDetailsService` and `UserDetailsService`
    in the section and simplifying `SpringSecurityUserContext` to display custom user
    attributes, in the next section, we will explore how to create a custom `AuthenticationProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom AuthenticationProvider object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security delegates to an `AuthenticationProvider` object to determine
    whether a user is authenticated or not. This means we can write custom `AuthenticationProvider`
    implementations to inform Spring Security how to authenticate in different ways.
    The good news is that Spring Security provides quite a few `AuthenticationProvider`
    objects, so more often than not you will not need to create one. In fact, up until
    this point, we have been utilizing Spring Security’s `o.s.s.authentication.dao.DaoAuthenticationProvider`
    object, which compares the username and password returned by `UserDetailsService`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CalendarUserAuthenticationProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the rest of this section, we are going to create a custom `AuthenticationProvider`
    object named `CalendarUserAuthenticationProvider` that will replace `CalendarUserDetailsService`.
    Then, we will use `CalendarUserAuthenticationProvider` to consider an additional
    parameter to support authenticating users from multiple domains.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We must use an `AuthenticationProvider` object rather than `UserDetailsService`
    because the `UserDetails` interface has no concept of a domain parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class named `CalendarUserAuthenticationProvider`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can use your `chapter03.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Before Spring Security can invoke the `authenticate` method, the `supports`
    method must return `true` for the `Authentication` class that will be passed in.
    In this case, `AuthenticationProvider` can authenticate a username and password.
    We do not accept subclasses of `UsernamePasswordAuthenticationToken` since there
    may be additional fields that we do not know how to validate.
  prefs: []
  type: TYPE_NORMAL
- en: The `authenticate` method accepts an `Authentication` object as an argument
    that represents an authentication request. In practical terms, it is the input
    from the user that we need to attempt to validate. If authentication fails, the
    method should throw an `o.s.s.core.AuthenticationException` exception. If authentication
    succeeds, it should return an `Authentication` object that contains the proper
    `GrantedAuthority` objects for the user. The returned `Authentication` object
    will be set on `SecurityContextHolder`. If authentication cannot be determined,
    the method should return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in authenticating the request is to extract the information from
    the `Authentication` object that we need to authenticate the user. In our case,
    we extract the username and lookup `CalendarUser` by email address, just as `CalendarUserDetailsService`
    did. If the provided username and password match `CalendarUser`, we will return
    a `UsernamePasswordAuthenticationToken` object with proper `GrantedAuthority`.
    Otherwise, we will throw an `AuthenticationException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how the login page leveraged `SPRING_SECURITY_LAST_EXCEPTION` to explain
    why the login failed? The message for the `AuthenticationException` exception
    thrown in `AuthenticationProvider` is the last `AuthenticationException` exception
    and will be displayed on our login page in the event of a failed login.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CalendarUserAuthenticationProvider object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s perform the following steps to configure `CalendarUserAuthenticationProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SecurityConfig.java` file to refer to our newly created `CalendarUserAuthenticationProvider`
    object, and remove the reference to `CalendarUserDetailsService`, as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `SecurityConfig.java` file, as follows, by removing the `PasswordEncoder`
    bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart the application and ensure everything is still working. As a user, we
    do not notice anything different. However, as a developer, we know that `CalendarUserDetails`
    is no longer required; we are still able to display the current user’s first and
    last names, and Spring Security is still able to leverage `CalendarUser` for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with different parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the strengths of `AuthenticationProvider` is that it can authenticate
    with any parameters you wish. For example, maybe your application uses a random
    identifier for authentication, or perhaps it is a multitenant application and
    requires a username, password, and domain. In the following section, we will update
    `CalendarUserAuthenticationProvider` to support multiple domains.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A domain is a way to scope our users. For example, if we deploy our application
    once but have multiple clients using the same deployment, each client may want
    a user with the username `admin`. By adding a domain to our user object, we can
    ensure that each user is distinct and still supports this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The DomainUsernamePasswordAuthenticationToken class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a user authenticates, Spring Security submits an `Authentication` object
    to `AuthenticationProvider` with the information provided by the user. The current
    `UsernamePasswordAuthentication` object only contains a username and password
    field. Create a `DomainUsernamePasswordAuthenticationToken` object that contains
    a `domain` field, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Updating CalendarUserAuthenticationProvider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps for updating the `CalendarUserAuthenticationProvider.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update `CalendarUserAuthenticationProvider` to utilize the
    domain field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first update the support method so that Spring Security will pass `DomainUsername`
    **PasswordAuthenticationToken** into our `authenticate` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use the domain information to create our email address and authenticate,
    as we had previously done. Admittedly, this example is contrived. However, the
    example can illustrate how to authenticate with an additional parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `CalendarUserAuthenticationProvider` interface can now use the new domain
    field. However, there is no way for a user to specify the domain. For this, we
    must update our `login.xhtml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding domain to the login page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open up the `login.xhtml` file and add a new input named `domain`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, a domain will be submitted when users attempt to log in. However, Spring
    Security is unaware of how to use that domain to create a `DomainUsernamePasswordAuthenticationToken`
    object and pass it into `AuthenticationProvider`. To fix this, we will need to
    create `DomainUsernamePasswordAuthenticationFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: The DomainUsernamePasswordAuthenticationFilter class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Security provides a number of `Servlet Filters` that act as controllers
    for authenticating users. The filters are invoked as one of the delegates of the
    `FilterChainProxy` object that we discussed in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. Previously, the `formLogin()` method instructed
    Spring Security to use `o.s.s.web.authentication.UsernamePasswordAuthenticationFilter`
    to act as a login controller. The filter’s job is to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a username and password from the HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `UsernamePasswordAuthenticationToken` object with the information obtained
    from the HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request that Spring Security validates `UsernamePasswordAuthenticationToken`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the token is validated, it will set the authentication returned to it on
    `SecurityContext` **Holder**, just as we did when a new user signed up for an
    account. We will need to extend `UsernamePasswordAuthenticationFilter` to leverage
    our newly created `DoainUsernamePasswordAuthenticationToken` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a `DomainUsernamePasswordAuthenticationFilter` object, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The new `DomainUsernamePasswordAuthenticationFilter` object will perform the
    following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a username, password, and domain from the `HttpServletRequest` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our `DomainUsernamePasswordAuthenticationToken` object with information
    obtained from the HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request that Spring Security validates `DomainUsernamePasswordAuthenticationToken`.
    The work is delegated to `CalendarUserAuthenticationProvider`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the token is validated, its superclass will set the authentication returned
    by `CalendarUserAuthenticationProvider` on `SecurityContextHolder`, just as we
    did to authenticate a user after they created a new account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating our configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have created all the code required for an additional parameter,
    we need to configure Spring Security to be aware of it. The following code snippet
    includes the required updates to our `SecurityConfig.java` file to support our
    additional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few highlights from the configuration updates:'
  prefs: []
  type: TYPE_NORMAL
- en: We overrode `defaultAuthenticationEntryPoint` and added a reference to `o.s.s.web.authentication.LoginUrlAuthenticationEntryPoint`,
    which determines what happens when a request for a protected resource occurs and
    the user is not authenticated. In our case, we are redirected to a login page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We removed the `formLogin()` method and used a `.addFilterAt()` method to insert
    our custom filter into `FilterChainProxy`. The position indicates the order in
    which the delegates of `FilterChain` are considered and cannot overlap with another
    filter, but can replace the filter at the current position. We replaced `UsernamePasswordAuthenticationFilter`
    with our custom filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram for your reference:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Custom Authentication implementation](img/B21757_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Custom Authentication implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now restart the application and try the following steps, depicted in
    the preceding diagram, to understand how all the pieces fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit `http://localhost:8080/events`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security will intercept the secured URL and use the `LoginUrlAuthentication`
    **EntryPoint** object to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `LoginUrlAuthenticationEntryPoint` object will send the user to the login
    page. Enter `admin1` as the username, `example.com` as the domain, and `admin1`
    as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DomainUsernamePasswordAuthenticationFilter` object will intercept the process
    of the login request. It will then obtain the username, domain, and password from
    the HTTP request and create a `DomainUsernamePasswordAuthenticationToken` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DomainUsernamePasswordAuthenticationFilter` object submits `DomainUsernamePasswordAuthenticationToken`
    to `CalendarUser``AuthenticationProvider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `CalendarUserAuthenticationProvider` interface validates `DomainUsername`
    **PasswordAuthenticationToken** and then returns an authenticated `DomainUsername`
    **PasswordAuthenticationToken** object (that is, `isAuthenticated()` returns `true`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DomainUserPasswordAuthenticationFilter` object updates `SecurityContext`
    with `DomainUsernamePasswordAuthenticationToken` and places it on `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter03.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the users sign-up workflow and how to create custom
    `UserDetailsService` and `AuthenticationProvider` objects, we will discuss in
    the next section which authentication method should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Which authentication method should you use?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered the three main methods of authenticating, so, which one is
    the best? Like all solutions, each comes with its pros and cons. You can find
    a summary of when to use a specific type of authentication by referring to the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SecurityContextHolder`: Interacting directly with `SecurityContextHolder`
    is certainly the easiest way of authenticating a user. It works well when you
    are authenticating a newly created user or authenticating unconventionally. By
    using `SecurityContextHolder` directly, we do not have to interact with so many
    Spring Security layers. The downside is that we do not get some of the more advanced
    features that Spring Security provides automatically. For example, if we want
    to send the user to the previously requested page after logging in, we will have
    to manually integrate that into our controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserDetailsService`: Creating a custom `UserDetailsService` object is an easy
    mechanism that allows Spring Security to make security decisions based on our
    custom domain model. It also provides a mechanism to hook into other Spring Security
    features. For example, Spring Security requires `UserDetailsService` to use the
    built-in remember-me support covered in [*Chapter 7*](B21757_07.xhtml#_idTextAnchor220),
    *Remember-me Services*. The `UserDetailsService` object does not work when authentication
    is not based on a username and password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationProvider`: This is the most flexible method for extending Spring
    Security. It allows a user to authenticate with any parameters that they wish.
    However, if we wish to leverage features such as Spring Security’s remember-me,
    we will still need `UserDetailsService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has used real-world problems to introduce the basic building blocks
    used in Spring Security. It also demonstrates to us how we can make Spring Security
    authenticate against our custom domain objects by extending those basic building
    blocks. In short, we have learned that the `SecurityContextHolder` interface is
    the central location for determining the current user. Not only can it be used
    by developers to access the current user, but also to set the currently logged-in
    user.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored how to create custom `UserDetailsService` and `AuthenticationProvider`
    objects and how to perform authentication with more than just a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore some of the built-in support for **Java
    Database Connectivity** (**JDBC**)-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Authentication Techniques'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we explore various authentication methods and services provided
    by Spring Security. First, we delve into authenticating users against a database
    using Spring Security’s JDBC support. Additionally, we discuss securing passwords
    with Spring Security’s cryptography module to enhance security.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we will explore the integration of Spring Data with Spring Security,
    utilizing JPA to authenticate against relational databases and MongoDB for document
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will introduce the **Lightweight Directory Access Protocol** (**LDAP**)
    and its integration with Spring Security. We explore how LDAP can provide authentication,
    authorization, and user information services within a Spring Security-enabled
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we uncover the functionality of the remember-me feature in Spring Security
    and its configuration. Additionally, we address considerations when implementing
    the remember-me functionality, enabling applications to remember users even after
    session expiration and browser closure.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will explore alternative authentication methods that are available
    to accommodate various credential types. We transcend traditional form-based authentication
    to delve into the realm of authentication using trusted client-side certificates.
    Spring Security provides robust support for these diverse authentication requirements,
    offering a framework to implement and manage authentication using client-side
    certificates, thus enhancing security measures within applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21757_04.xhtml#_idTextAnchor106), *JDBC-**based* *Authentication*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21757_05.xhtml#_idTextAnchor150), *Authentication with Spring
    Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21757_07.xhtml#_idTextAnchor220), *Remember-**me* *Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21757_08.xhtml#_idTextAnchor261), *Client Certificate Authentication
    with TLS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
