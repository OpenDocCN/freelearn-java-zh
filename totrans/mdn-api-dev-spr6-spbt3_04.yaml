- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Business Logic for APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You defined API specs using OpenAPI in the previous chapter. API Java interfaces
    and models were generated by the OpenAPI (Swagger Codegen). In this chapter, you
    will implement the API’s code in terms of both business logic and data persistence.
    Here, business logic refers to the actual code you are writing for domain functionalities,
    which in our case comprise operations performed for e-commerce, such as checking
    out the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: You will write services and repositories for implementation and add hypermedia
    and `"_links"` field. It is worth noting that the code provided only consists
    of the important lines and not the whole file in the interest of brevity. You
    can always access the links given after the code to view the complete file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the service design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a repository component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding service components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing hypermedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the controller with a service and HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding ETags to API responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute the instructions in this and the following chapters, you will need
    any REST API client, such as *Insomnia* or *Postman*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the service design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a multi-layered architecture that comprises four
    layers – the presentation layer, application layer, domain layer, and infrastructure
    layer. Multi-layered architecture is a fundamental building block in the architecture
    style known as **domain-driven design** (**DDD**). Let’s have a brief look at
    each of these layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: This layer represents the **user interface** (**UI**).
    In [*Chapter 7*](B19349_07.xhtml#_idTextAnchor169), *Designing a User Interface*,
    you’ll develop the UI for a sample e-commerce app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: The application layer contains the application logic
    and maintains and coordinates the overall flow of the application. Just to remind
    you, it only contains the application logic and *not* the business logic. RESTful
    web services, async APIs, gRPC APIs, and GraphQL APIs are a part of this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already covered REST APIs and controllers in [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080),
    *API Specifications and Implementation*, which are part of the application layer.
    We implemented the controllers for demonstration purposes in the previous chapter.
    In this chapter, we’ll implement a controller extensively to serve real data.
  prefs: []
  type: TYPE_NORMAL
- en: '`Order` or `Product`. It is responsible for reading/persisting these objects
    to the infrastructure layer. The domain layer consists of services and repositories
    too. We’ll also be covering these in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure layer**: The infrastructure layer provides support to all
    other layers. It is responsible for communication, such as interaction with the
    database, message brokers, and filesystems. Spring Boot works as an infrastructure
    layer and provides support for communication and interaction with both external
    and internal systems, such as databases and message brokers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use the bottom-to-top approach. Let’s start implementing the domain layer
    with the `@``Repository` component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Repository component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll use the bottom-to-top approach to add a `@Repository` component. Let’s
    start implementing the domain layer with a `@Repository` component. We’ll implement
    the service and enhance the `@Controller` component in subsequent sections accordingly.
    We will code the `@Repository` component first, then use it in the `@Service`
    component using constructor injection. The `@Controller` component will be enhanced
    using the `@Service` component, which will also be injected into the Controller
    using constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: The @Repository annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Repository components are Java classes marked with the `@Repository` annotation.
    This is a special Spring component that is used for interacting with databases.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Repository` is a general-purpose stereotype that represents both DDD’s Repository
    and the `@Repository`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the following libraries as database dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**H2 database for persisting data**: We are going to use H2’s memory instance;
    however, you can also use a file-based instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hibernate object relational mapping (ORM)**: For database object mapping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flyway for database migration**: This helps maintain the database and maintains
    a database changes history that allows rollbacks, version upgrades, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s add these dependencies to the `build.gradle` file. `org.springframework.boot:spring-boot-starter-data-jpa`
    adds all the required JPA dependencies, including Hibernate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: After adding the dependencies, we can add the configuration related to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database and JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also need to modify the `application.properties` file with the following
    configuration. The configuration file is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/resources/application.properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Datasource configuration**: The following are the Spring datasource configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to add H2-specific properties to the data source. The URL value suggests
    that a memory-based H2 database instance will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**H2 database configuration**: The following are the two H2 database configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the H2 console is the H2 web client that allows you to perform different
    operations on H2, such as viewing tables and executing queries. The H2 console
    is enabled for local access only; this means you can access the H2 console only
    on localhost. Also, remote access is disabled by setting `web-allow-others` to
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**JPA configuration**: The following are the JPA/Hibernate configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don’t want to generate the DDL or process the SQL file, because we want to
    use Flyway for database migrations. Therefore, `generate-ddl` is marked with `false`
    and `ddl-auto` is set to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flyway configuration**: The following are the Flyway configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, properties that are required for Flyway to connect to the database have
    been set.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the H2 database
  prefs: []
  type: TYPE_NORMAL
- en: You can access the H2 database console using `/h2-console`. For example, if
    your server is running on localhost and port `8080`, then you can access it using
    [http://localhost:8080/h2-console/](http://localhost:8080/h2-console/).
  prefs: []
  type: TYPE_NORMAL
- en: You are done with setting up the database configuration. Let’s create the database
    schema and seed data script in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The database and seed data script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are done configuring the `build.gradle` and `application.properties`
    files and we can start writing the code. First, we’ll add the Flyway database
    migration script. This script can be written in SQL only. You can place this file
    in the `db/migration` directory inside the `src/main/resources` directory. We’ll
    follow the Flyway naming convention (`V<version>.<name>.sql`) and create the `V1.0.0__Init.sql`
    file inside the `db/migration` directory. You can then add the following script
    to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/resources/db/migration/V1.0.0__Init.sql](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/resources/db/migration/V1.0.0__Init.sql)'
  prefs: []
  type: TYPE_NORMAL
- en: This script creates the `ecomm` schema and adds all the tables required for
    our sample e-commerce app. It also adds `insert` statements for the seed data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can add the entities. An entity is a special object marked with the
    `@Entity` annotation that maps directly to the database table using an ORM implementation
    such as *Hibernate*. Another popular ORM is *EclipseLink*. You can place all entity
    objects in the `com.packt.modern.api.entity` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `CartEntity.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/java/com/packt/modern/api/entity/CartEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter04/src/main/java/com/packt/modern/api/entity/CartEntity.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `@Entity` annotation is part of the `jakarta.persistence` package,
    which denotes that it is an entity and should be mapped to the database table.
    By default, it takes the entity name; however, we are using the `@Table` annotation
    to map to the database table. Earlier, the `javax.persistence` package was part
    of Oracle. Once Oracle open sourced JEE and handed it over to the Eclipse Foundation,
    it was legally required to change the name of the package from `javax.persistence`
    to `jakarta.persistence`.
  prefs: []
  type: TYPE_NORMAL
- en: We are also using one-to-one and many-to-many annotations to map the `Cart`
    entity to the `User` entity and `Item` entity, respectively. The `ItemEntity`
    list is also associated with `@JoinTable`, because we are using the `CART_ITEM`
    join table to map the cart and product items based on the `CART_ID` and `ITEM_ID`
    columns in their respective tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `UserEntity`, the `Cart` entity has also been added to maintain the relationship,
    as shown in the following code block. `FetchType` is marked as `LAZY`, which means
    the user’s cart will be loaded only when explicitly asked. Also, you want to remove
    the cart if it is not referenced by the user, which can be done by configuring
    `orphanRemoval` to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/entity/UserEntity.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/entity/UserEntity.java)'
  prefs: []
  type: TYPE_NORMAL
- en: All other entities are being added to the entity package located at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/entity](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/entity).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can add the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Adding repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the repositories have been added to [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository).
  prefs: []
  type: TYPE_NORMAL
- en: Repositories are simplest to add for CRUD operations, thanks to Spring Data
    JPA. You just must extend the interfaces with default implementations, such as
    `CrudRepository`, which provides all the CRUD operation implementations, such
    as `save`, `saveAll`, `findById`, `findAll`, `findAllById`, `delete`, and `deleteById`.
    The `save(Entity e)` method is used for both create and update entity operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create `CartRepository.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/CartRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/CartRepository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The `CartRepository` interface extends the `CrudRepository` part of the `org.
    springframework.data.repository` package. You can also add methods supported by
    the JPA query language marked with the `@Query` annotation (part of the `org.springframework.data.jpa.repository`
    package). The query inside the `@Query` annotation is written in `CartEntity`
    as the table name instead of `Cart`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting columns in JPQL
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for columns, you should use the variable names given in the class
    for the fields, instead of using the database table fields. In any case, if you
    use the database table name or field name and it does not match the class and
    class members mapped to the actual table, you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must be wondering, *“What if I want to add my own custom method with JPQL
    or native SQL?”* Well, let me tell you, you can do this too. For orders, we have
    added a custom interface for this very purpose. First, let’s have a look at `OrderRepository`,
    which is very similar to `CartRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely, we have extended an extra interface – `OrderRepositoryExt`.
    This is our extra interface for the `Order` repository and consists of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java)'
  prefs: []
  type: TYPE_NORMAL
- en: We already have a `save()` method for this purpose in `CrudRepository`; however,
    we want to use a different implementation. For this purpose, and to demonstrate
    how you can create your own repository method implementation, we are adding this
    extra repository interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `OrderRepositoryExt` interface implementation, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepositoryImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository/OrderRepositoryImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can also have our own implementation in JPQL/`@Repository` annotation
    tells the Spring container that this special component is a repository and should
    be used to interact with the database using the underlying JPA.
  prefs: []
  type: TYPE_NORMAL
- en: It is also marked as `@Transactional`, which is a special annotation that means
    that transactions performed by methods in this class will be managed by Spring.
    It removes all the manual work of adding commits and rollbacks. You can also add
    this annotation to a specific method inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also using `@PersistenceContext` for the `EntityManager` class, which
    allows us to create and execute the query manually, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method basically first fetches the items in the customer’s cart. Then,
    it calculates the order total, creates a new order, and saves it in the database.
    Next, it removes the items from the cart by removing the mapping because cart
    items are now part of the order. After that, it saves the mapping of the order
    and cart items.
  prefs: []
  type: TYPE_NORMAL
- en: Order creation is done using the native SQL query with the prepared statement.
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, you’ll also find that we have used the official *Java 15*
    feature, **text** **blocks** ([https://docs.oracle.com/en/java/javase/15/text-blocks/index.html](https://docs.oracle.com/en/java/javase/15/text-blocks/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can create a repository for all other entities. All the repositories
    are available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/repository).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the repositories, we can move on to adding services.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Service component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Service` component is an interface that works between controllers and
    repositories and is where we’ll add the business logic. Though you can directly
    call repositories from controllers, it is not a good practice as repositories
    should only be part of the data retrieval and persistence functionalities. Service
    components also help in sourcing data from various sources, such as databases
    and other external applications.
  prefs: []
  type: TYPE_NORMAL
- en: Service components are marked with the `@Service` annotation, which is a specialized
    Spring `@Component` that allows implemented classes to be auto-detected using
    class-path scanning. Service classes are used to add business logic. Like `Repository`,
    the `Service` object also represents both DDD’s Service and JEE’s Business Service
    Façade patterns. Like `Repository`, it is also a general-purpose stereotype and
    can be used according to the underlying approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the service interface, which is a normal Java interface
    with all the desired method signatures. This interface will expose all the operations
    that can be performed by `CartService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/service/CartService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/service/CartService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The `CartServiceImpl` class is annotated with `@Service`, therefore it would
    be auto-detected and available for injection. The `CartRepository`, `UserRepository`,
    and `ItemService` class dependencies are injected using constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at one more method implementation of the `CartService` interface.
    Check the following code. It adds an item, or updates the price and quantity if
    the item already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are not managing the application state, but are instead
    writing the sort of business logic that queries the database, sets the entity
    object, persists the object, and then returns the model class. Let’s have a look
    at the statement blocks as numbered in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: The method only has `customerId` as a parameter and there is no `Cart` parameter.
    Therefore, first we get `CartEntity` from the database based on the given `customerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program control iterates through the items retrieved from the `CartEntity`
    object. If the given item already exists, then the quantity and price are changed.
    Else, it creates a new `Item` entity from the given `Item` model and then saves
    it to the `CartEntity` object. The `itemExists` flag is used to find out whether
    we need to update the existing `Item` or add a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the updated `CartEntity` object is saved in the database. The latest
    `Item` entity is retrieved from the database, and then gets converted into a model
    collection and returned to the calling program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, you can write `Service` components for others the way you have implemented
    them for `Cart`. Before we start enhancing the `Controller` classes, we need to
    add a final frontier to our overall feature.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing hypermedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about hypermedia and HATEOAS in [*Chapter 1*](B19349_01.xhtml#_idTextAnchor014),
    *RESTful Web Service Fundamentals*. Spring provides state-of-the-art support to
    HATEOAS using the `org.springframework.boot:` `spring-boot-starter-hateoas` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure that all models returned as part of the API response
    contain the link field. There are different ways to associate links (that is,
    the `org.springframework.hateoas.Link` class) with models, either manually or
    via auto-generation. Spring HATEOAS’s links and attributes are implemented according
    to *RFC-8288* ([https://tools.ietf.org/html/rfc8288](https://tools.ietf.org/html/rfc8288)).
    For example, you can create a self-link manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `responseModel` is a model object that is returned by the API. It has
    a field called `_self` that is set using the `linkTo` and `methodOn` static methods.
    The `linkTo` and `methodOn` methods are provided by the Spring HATEOAS library
    and allow us to generate a self-link for a given controller method.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be done automatically by using Spring HATEOAS’s `RepresentationModelAssembler`
    interface. This interface mainly exposes two methods – `toModel(T model)` and
    `toCollectionModel(Iterable<? extends T> entities)` – that convert the given entity/entities
    into Model and `CollectionModel`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring HATEOAS provides the following classes to enrich the user-defined models
    with hypermedia. It basically provides a class that contains links and methods
    to add those to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RepresentationModel`: Models/DTOs can extend this to collect the links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntityModel`: This extends `RepresentationModel` and wraps the domain object
    (that is, the model) inside it with the content private field. Therefore, it contains
    the domain model/DTO and the links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollectionModel`: `CollectionModel` also extends `RepresentationModel`. It
    wraps the collection of models and provides a way to maintain and store the links.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PageModel`: `PageModel` extends `CollectionModel` and provides ways to iterate
    through the pages, such as `getNextLink()` and `getPreviousLink()`, and through
    page metadata with `getTotalPages()`, among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default way to work with Spring HATEOAS is to extend `RepresentationModel`
    with domain models, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Extending `RepresentationModel` enhances the model with additional methods,
    including `getLink()`, `hasLink()`, and `add()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You know that all these models are being generated by the OpenAPI Codegen;
    therefore, we need to configure the OpenAPI Codegen to generate new models that
    support hypermedia, which is done using the following `config.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/resources/api/config.json](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/resources/api/config.json)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `hateoas` property and setting it to `true` would automatically generate
    models that would extend the `RepresentationModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are halfway there to implement the API business logic. Now, we need to make
    sure that links will be populated with the appropriate URL automatically. For
    that purpose, we’ll extend the `RepresentationModelAssemblerSupport` abstract
    class, which internally implements `RepresentationModelAssembler`. Let’s write
    the assembler for `Cart`, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/hateoas/CartRepresentationModelAssembler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/hateoas/CartRepresentationModelAssembler.java)'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, the important part in the `Cart` assembler is extending
    `RepresentationModelAssemblerSupport` and overriding the `toModel()` method. If
    you look closely, you’ll see that `CartController.class`, along with the `Cart`
    model, is also passed to `Rep` using the `super()` call. This allows the assembler
    to generate the links appropriately as is required for the `methodOn` method shared
    earlier. This way, you can generate the link automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also need to add additional links to other resource controllers. You
    can achieve this by writing a bean that implements `RepresentationModelProcessor`
    and then override the `process()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can always refer to [https://docs.spring.io/spring-hateoas/docs/current/reference/html/](https://docs.spring.io/spring-hateoas/docs/current/reference/html/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make use of the services and HATEOAS enablers you created in the controller
    classes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the controller with a service and HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API Specifications and
    Implementation*, we created the `Controller` class for the Cart API – `CartController`
    – which just implements the OpenAPI Codegen-generated API specification interface
    – `CartApi`. It was just a mere block of code without any business logic or data
    persistence calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, since we have written the repositories, services, and HATEOAS assemblers,
    we can enhance the API controller class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/controller/CartsController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/controller/CartsController.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that `CartService` and `CartRepresentationModelAssembler` are injected
    using the constructor. The Spring container injects these dependencies at runtime.
    Then, these can be used as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/controller/CartsController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/controller/CartsController.java)'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, you can see that the service retrieves the `Cart` entity
    based on `customerId` (which internally retrieves it from the repository). This
    `Cart` entity then gets converted into a model that also contains the hypermedia
    links made available by Spring HATEOAS’s `RepresentationModelAssemblerSupport`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ok()` static method of `ResponseEntity` is used to wrap the returned model
    that also contains the `200` `OK` status.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can also enhance and implement the other controllers. Now, we
    can also add an ETag to our API responses.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ETags to API responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ETag is an HTTP response header that contains a computed hash or equivalent
    value of the response entity, and a minor change in the entity must change its
    value. HTTP request objects can then contain the `If-None-Match` and `If-Match`
    headers to receive the conditional responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call an API to retrieve the response with an ETag, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can copy the value from the ETag header to the `If-None-Match` header
    and send the same request again with the `If-None-Match` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see that since there is no change to the entity in the database, and
    it contains the same entity, it sends a `304` (`NOT MODIFIED`) response instead
    of sending the proper response with `200 OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to implement ETags is using Spring’s `ShallowEtagHeaderFilter`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/AppConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/src/main/java/com/packt/modern/api/AppConfig.java)'
  prefs: []
  type: TYPE_NORMAL
- en: For this implementation, Spring calculates the MD5 hash from the cached content
    written to the response. Next time, when it receives a request with the `If-None-Match`
    header, it again creates the MD5 hash from the cached content written to the response
    and then compares these two hashes. If both are the same, it sends the `304 NOT
    MODIFIED` response. This way, it will save bandwidth, but the same CPU computation
    will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the HTTP cache control (`org.springframework.http.CacheControl`)
    class and use the version or a similar attribute that gets updated with each change,
    if available, to avoid unnecessary CPU computation and for better ETag handling,
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Adding an ETag to the response also allows UI apps to determine whether a page/object
    refresh is required, or an event needs to be triggered, especially where data
    changes frequently in applications, such as providing live scores or stock quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have implemented fully functional APIs. Let’s test them next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you must be looking forward to testing. You can find the API client collection
    at the following location, which is an HTTP Archive file and can be used by Insomnia
    or Postman API clients. You can import it and then test the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/Chapter04-API-Collection.har](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter04/Chapter04-API-Collection.har)'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the Chapter 4 code
  prefs: []
  type: TYPE_NORMAL
- en: You can build the code by running `gradlew clean build` from the root of the
    project and run the service using `java -jar build/libs/Chapter04-0.0.1-SNAPSHOT.jar`.
    Make sure to use Java 17 in the path.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about database migration using Flyway, maintaining
    and persisting data using repositories, and writing business logic to services.
    We have also learned how hypermedia can automatically be added to API responses
    using Spring HATEOAS assemblers. You have now learned about all the RESTful API
    development practices, which allows you to use this skill in your day-to-day work
    involving RESTful API development.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have written synchronous APIs. In the next chapter, you will learn
    about async APIs and how to implement them using Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is the `@Repository` class used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to add extra imports or annotations to Swagger-generated classes
    or models?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are ETags useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repository classes are marked with `@Repository`, which is a specialized `@Component`
    that makes these classes auto-detectable by package-level auto-scanning and makes
    them available for injection. Spring provides these classes especially for DDD
    repositories and the JEE DAO pattern. This is the layer used by the application
    for interacting with the database – retrieval and persistence as a central repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is possible to change the way models and APIs are generated. You must copy
    the template that you want to modify and then place it in the resources folder.
    Then, you have to modify the `swaggerSources` block in the `build.gradle` file
    by adding an extra configuration parameter to point to the template source, such
    as `templateDir = file("${rootDir}/src/main/resources/ templates")`. This is the
    place where you keep modified templates such as `api. mustache`. This will extend
    the OpenAPI Codegen templates. You can find all the templates inside the OpenAPI
    generator JAR file, such as `openapi-generator-cli-4.3.1.jar` in the `\JavaSpring`
    directory. You can copy the one you want to modify in the `src/main/resource/templates`
    directory and then play with it. You can make use of the following resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JavaSpring** **templates**: [https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen/src/main/resources/JavaSpring](https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen/src/main/resources/JavaSpring)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mustache template** **variables**: [https://github.com/swagger-api/swagger-codegen/wiki/Mustache-Template-Variables](https://github.com/swagger-api/swagger-codegen/wiki/Mustache-Template-Variables)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An article explaining implementing a similar** **approach**: [https://arnoldgalovics.com/swagger-codegen-custom-template/](https://arnoldgalovics.com/swagger-codegen-custom-template/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ETags help to improve the REST/HTTP client performance and user experience by
    only re-rendering the page/section when the underlying API response is updated.
    They also save bandwidth by carrying the response body only when required. CPU
    utilization can be optimized if the ETag is generated based on values retrieved
    from the database, for example, the version or date last modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring HATEOAS: [https://docs.spring.io/spring-hateoas/docs/current/reference/html/](https://docs.spring.io/spring-hateoas/docs/current/reference/html/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC-8288: [https://tools.ietf.org/html/rfc8288](https://tools.ietf.org/html/rfc8288)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
