<html><head></head><body><div class="book" title="Chapter&#xA0;3.&#xA0;Building JSF Forms"><div class="book" id="aid-11C3M2"><div class="book"><div class="book"><h1 class="title"><a id="ch03" class="calibre1"/>Chapter 3. Building JSF Forms</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre12"><td valign="top" class="calibre13"> </td><td valign="top" class="calibre13"><p class="calibre14"><span><em class="calibre15">"It's the whole thing. The way something actually works on so many different levels. Ultimately, of course, design defines so much of our experiences."</em></span></p></td><td valign="top" class="calibre13"> </td></tr><tr class="calibre12"><td valign="top" class="calibre13"> </td><td colspan="2" valign="top" class="calibre16">--<span><span><em class="calibre15">Sir Jony Ive, Senior Vice President of Design, Apple USA</em></span></span></td></tr></table></div><p class="calibre7">JavaServer Faces is an example of a component-oriented web application framework, as opposed to Java EE 8 MVC (See <a class="calibre1" title="Chapter 9. Java EE MVC Framework" href="part0087.xhtml#aid-2IV0U1">Chapter 9</a>, <span class="strong"><em class="calibre9">Java EE MVC Framework</em></span>), WebWork, or Apache Struts, which are known as request-oriented web application frameworks.</p><p class="calibre7">A <a id="id233" class="calibre1"/>request-oriented framework is one where the information flow is from the web request to the response. Such frameworks provide you with an ability and structure above the <code class="email">javax.servlet.http.HttpServletRequest</code> and <code class="email">javax.servlet.http.HttpServletResponse</code> objects, but there are no special user interface components. With additional help, the application user must program the mapping of the parameters and attributes to the data entity models. The developer, therefore, has to write parsing logic.</p><p class="calibre7">It is important to <a id="id234" class="calibre1"/>understand that component-oriented frameworks, such as JSF, have their detractors. The quick inspection of the code resembles the components found in a standalone client such as Java Swing or even JavaFX, but the very same <code class="email">HttpServletRequest</code> and <code class="email">HttpServletResponse</code> lurk behind the scenes. Hence, a competent JSF developer has to be aware of the Servlet API and underlying servlet scopes. This was a valid criticism in 2004, and in the digital marketing age, a digital developer has to know not only Servlet, but also we can presume that they would be open to learning other technologies such as JavaScript. Based on the knowledge obtained from <a class="calibre1" title="Chapter 2. JavaServer Faces Lifecycle" href="part0025.xhtml#aid-NQU22">Chapter 2</a>, <span class="strong"><em class="calibre9">JavaServer Faces Lifecycle</em></span>, we will learn about building the JSF forms.</p><div class="book" title="Create, Retrieve, Update, and Delete"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec28" class="calibre1"/>Create, Retrieve, Update, and Delete</h1></div></div></div><p class="calibre7">In this <a id="id235" class="calibre1"/>chapter, we will solve an everyday problem with JSF. The Java EE framework and enterprise application are about solving data entry issues. Unlike social networking software that is built with a different architecture and non-functional requirements such as scalability, performance, statelessness, and eventual consistency, Java EE applications are designed for stateful work flows, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00379.jpeg" alt="Create, Retrieve, Update, and Delete" class="calibre10"/><div class="caption"><p class="calibre24">Screenshot of the page view to create contact details</p></div></div><p class="calibre11"> </p><p class="calibre7">The preceding screenshot is the JSF application, <code class="email">jsf-crud</code>, which shows the create contact details form.</p><p class="calibre7">As a reminder, you can find the entire code for this application with the book's source code.</p><p class="calibre7">Typically, an <a id="id236" class="calibre1"/>enterprise application captures the information from a web user, stores it in a data store, and allows this information to be retrieved and edited. There is usually an option to delete the user's information. In software engineering, we call this idiom Create, Retrieve, Update, and Delete (CRUD).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre7">What constitutes the actual deletion of the user and customer data is a matter that ultimately affects the business owners who are under the pressure to conform to the local and international laws that define privacy and data protection.</p></div><div class="book" title="A basic create entity JSF form"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec26" class="calibre1"/>A basic create entity JSF form</h2></div></div></div><p class="calibre7">Let's create <a id="id237" class="calibre1"/>a basic<a id="id238" class="calibre1"/> form that captures the user's name, e-mail address, and date of birth. We will write this code using HTML5 and take advantage<a id="id239" class="calibre1"/> of Bootstrap for the modern day CSS and JavaScript. Refer to <a class="calibre1" href="http://getbootstrap.com/getting-started/">http://getbootstrap.com/getting-started/</a>.</p><p class="calibre7">The following is the JSF Facelet view, <code class="email">createContact.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      
      
      &gt;
    &lt;h:head&gt;
        &lt;meta charset="utf-8"/&gt;
        &lt;title&gt;Demonstration Application &lt;/title&gt;
        &lt;link href="#{request.contextPath}/resources/styles/bootstrap.css" rel="stylesheet"/&gt;
        &lt;link href="#{request.contextPath}/resources/styles/main.css" rel="stylesheet"/&gt;
    &lt;/h:head&gt;

    &lt;h:body&gt;
        &lt;div class="main-container"&gt;
            &lt;div class="header-content"&gt;
                &lt;div class="navbar navbar-inverse"
                role="navigation"&gt;
                  ...
                &lt;/div&gt;
            &lt;/div&gt;&lt;!-- headerContent --&gt;

            &lt;div class="mainContent"&gt;
                &lt;h1&gt; Enter New Contact Details &lt;/h1&gt;

                &lt;h:form id="createContactDetail"
                    styleClass="form-horizontal"
                    p:role="form"&gt;
                    ...
                &lt;/h:form&gt;

            &lt;/div&gt;&lt;!-- main-content --&gt;

            &lt;div class="footer-content"&gt;

            &lt;/div&gt; &lt;!-- footer-content --&gt;
        &lt;/div&gt; &lt;!-- main-container --&gt;
    &lt;/h:body&gt;
    &lt;script src="#{request.contextPath}/resources/javascripts/jquery-1.11.0.js"&gt;&lt;/script&gt;
    &lt;script src="#{request.contextPath}/resources/javascripts/bootstrap.js"&gt;&lt;/script&gt;
    &lt;script src="#{request.contextPath}/resources/app/main.js"&gt;
    &lt;/script&gt;
&lt;/html&gt;</pre></div><p class="calibre7">You <a id="id240" class="calibre1"/>should already <a id="id241" class="calibre1"/>recognize the <code class="email">&lt;h:head&gt;</code> and <code class="email">&lt;h:body&gt;</code> JSF custom tags. As the type is a Facelet view, (<code class="email">*.xhtml</code>), the document must actually be well-formed like an XML document. You should have noticed that certain HTML5 element tags such as <code class="email">&lt;meta&gt;</code> are closed and completed; the XHTML document must be well-formed in JSF.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Always close the XHTML elements</strong></span>
</p><p class="calibre7">The typical e-commerce application has web pages with standard HTML with the <code class="email">&lt;meta&gt;</code>, <code class="email">&lt;link&gt;</code>, and <code class="email">&lt;br&gt;</code> tags. In the XHTML and Facelet views, these tags, which web <a id="id242" class="calibre1"/>designers normally leave open and hanging, must be closed. <span class="strong"><strong class="calibre8">Extensible Mark-up Language</strong></span> (<span class="strong"><strong class="calibre8">XML</strong></span>) is less forgiving and XHTML, which is derived from XML, must be well-formed.</p></div><p class="calibre7">The new <code class="email">&lt;h:form&gt;</code> tag is a JSF custom tag that corresponds to the HTML form element. A JSF form element shares many of the attributes of the HTML partner. You can see that the <code class="email">id</code> attribute is just the same. However, instead of the <code class="email">class</code> attribute, we have the <code class="email">styleClass</code> attribute in JSF, because in Java, the <code class="email">java.lang.Object.getClass()</code> method is reserved and therefore, cannot be overridden.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">What is the JSF request context path expression?</strong></span>
</p><p class="calibre7">The curious<a id="id243" class="calibre1"/> markup around the links to the style sheets, JavaScript, and other resources is the expression language: <code class="email">#{request.contextPath}</code>. The expression reference ensures that the web application path is added to the URL of the JSF resources. Bootstrap CSS itself relies on the font glyph icons in a particular folder. The JSF images, JavaScript module files, and CSS files should be placed in the resources folder of the web root.</p></div><p class="calibre7">The <code class="email">p:role</code> attribute <a id="id244" class="calibre1"/>is <a id="id245" class="calibre1"/>an example of the JSF <code class="email">passthrough</code> attribute, which informs the JSF render kit to send through the key and value to the rendered output. The <code class="email">passthrough</code> attributes are key additions in JSF 2.2, which is a part of Java EE 7. They allow JSF to play well with the recent HTML5 frameworks such as Bootstrap and Foundation (<a class="calibre1" href="http://foundation.zurb.com/">http://foundation.zurb.com/</a>).</p><p class="calibre7">Here is an extract of the<a id="id246" class="calibre1"/> rendered HTML source output:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt; Enter New Contact Details &lt;/h1&gt;
&lt;form id="createContactDetail" name="createContactDetail" method="post" action="/jsf-crud-1.0-SNAPSHOT/createContactDetail.xhtml" class="form-horizontal" enctype="application/x-www-form-urlencoded" role="form"&gt;
&lt;input type="hidden" name="createContactDetail" value="createContactDetail" /&gt;</pre></div><p class="calibre7">JSF was implemented before Bootstrap was created in Twitter. How could the JSF designer retrofit the framework in order to be compatible with the recent HTML5, CSS3, and JavaScript innovations? This is where the <code class="email">passthrough</code> attribute helps. By declaring the XML namespace in XHTML with the URI <a class="calibre1" href="http://xmlns.jcp.org/jsf/passthrough">http://xmlns.jcp.org/jsf/passthrough</a>. We can enable the feature for the page view. As you can see, the attribute name and value, <code class="email">role="form"</code>, is simply passed through to the output. The <code class="email">passthrough</code> attributes allow JSF to easily handle the HTML5 features such as placeholders in the text input fields, which we will exploit from now onwards.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">If you are brand new to web development, you might be scared of markup that appears to be overcomplicated. There are lots and lots of DIV HTML elements, which are often created by page designers and Interface Developers. This is the historical effect and just the way that HTML and the web has evolved over time. The practices of 2002 have no bearing on 2016. I recommend that you read the <a class="calibre1" title="Appendix C. Agile Performance – Working inside Digital Teams" href="part0104.xhtml#aid-335QG1">Appendix C</a>, <span class="strong"><em class="calibre9">Agile Performance – Working inside Digital Teams</em></span>.</p></div><p class="calibre7">Let's take <a id="id247" class="calibre1"/>a <a id="id248" class="calibre1"/>deeper look at <code class="email">&lt;h:form&gt;</code> and fill in the missing details. Here is the extracted code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="createContactDetail"
  styleClass="form-horizontal"
  p:role="form"&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="title" class="col-sm-3 control-label"&gt;
        Title&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:selectOneMenu class="form-control"
         id="title"
         value="#{contactDetailController.contactDetail.title}"&gt;
        &lt;f:selectItem itemLabel="--" itemValue="" /&gt;
        &lt;f:selectItem itemValue="Mr" /&gt;
        &lt;f:selectItem itemValue="Mrs" /&gt;
        &lt;f:selectItem itemValue="Miss" /&gt;
        &lt;f:selectItem itemValue="Ms" /&gt;
        &lt;f:selectItem itemValue="Dr" /&gt;
      &lt;/h:selectOneMenu&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="firstName" class="col-sm-3 control-label"&gt;
      First name&lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText class="form-control"
       value="#{contactDetailController.contactDetail.firstName}"
       id="firstName" placeholder="First name"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  ... Rinse and Repeat for middleName and lastName ...
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel for="email" class="col-sm-3 control-label"&gt;
    Email address &lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9"&gt;
      &lt;h:inputText type="email"
       class="form-control" id="email"
       value="#{contactDetailController.contactDetail.email}"
       placeholder="Enter email"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;h:outputLabel class="col-sm-3 control-label"&gt;
       Newsletter
    &lt;/h:outputLabel&gt;
    &lt;div class="col-sm-9 checkbox"&gt;
      &lt;h:selectBooleanCheckbox id="allowEmails"
    value="#{contactDetailController.contactDetail.allowEmails}"&gt;
          Send me email promotions
      &lt;/h:selectBooleanCheckbox&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;h:commandButton styleClass="btn btn-primary"
    action="#{contactDetailController.createContact()}"
    value="Submit" /&gt;
&lt;/h:form&gt;</pre></div><p class="calibre7">This<a id="id249" class="calibre1"/> form is built<a id="id250" class="calibre1"/> using the Bootstrap CSS style, but we will ignore the extraneous details and concentrate purely on the JSF custom tags.</p><p class="calibre7">The <code class="email">&lt;h:selectOneMenu&gt;</code> tag is a JSF custom tag that corresponds to the HTML form select element. The <code class="email">&lt;f:selectItem&gt;</code> tag corresponds to the HTML form select option element. The <code class="email">&lt;h:inputText&gt;</code> tag corresponds to the HTML form input element. The <code class="email">&lt;h:selectBooleanCheckbox&gt;</code> tag is a special custom tag to represent the HTML select with only one checkbox element. Finally, <code class="email">&lt;h:commandButton&gt;</code> represents the HTML form submit element.</p><div class="book" title="The JSF HTML output label"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec12" class="calibre1"/>The JSF HTML output label</h3></div></div></div><p class="calibre7">The <code class="email">&lt;h:outputLabel&gt;</code> tag <a id="id251" class="calibre1"/>renders the HTML form label element in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputLabel for="firstName" class="col-sm-3 control-label"&gt; First name&lt;/h:outputLabel&gt;</pre></div><p class="calibre7">The developers should prefer this tag in conjunction with the other associated JSF form input tags because the special <code class="email">for</code> attribute targets the correct sugared identifier for the element.</p><p class="calibre7">Here is the rendered output:</p><div class="informalexample"><pre class="programlisting">&lt;label for="createContactDetail:firstName" class="col-sm-3 control-label"&gt; First name&lt;/label&gt;</pre></div><p class="calibre7">We could have<a id="id252" class="calibre1"/> written the tag using the value attribute, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputLabel for="firstName" class="col-sm-3 control-label" value="firstName" /&gt;</pre></div><p class="calibre7">It is also possible to take advantage of internationalization at this point; so just for illustration, we could rewrite the page content as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputLabel for="firstName" class="col-sm-3 control-label" value="${myapplication.contactForm.firstName}" /&gt;</pre></div><p class="calibre7">For more information about internationalization and resource bundles in JSF, please see the <a class="calibre1" title="Appendix A. JSF with HTML5, Resources, and Faces Flows" href="part0093.xhtml#aid-2OM4A1">Appendix A</a>, <span class="strong"><em class="calibre9">JSF with HTML5, Resources, and Faces Flows</em></span>. Let's move on to the input fields.</p></div><div class="book" title="The JSF HTML input text"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec13" class="calibre1"/>The JSF HTML input text</h3></div></div></div><p class="calibre7">The <code class="email">&lt;h:inputText&gt;</code> tag<a id="id253" class="calibre1"/> allows data to be entered in the form like text, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText class="form-control" value="#{contactDetailController.contactDetail.firstName}" id="firstName" placeholder="First name"/&gt;</pre></div><p class="calibre7">The value attribute represents a JSF expression language, and the clue is that the evaluation string starts with a hash character. The Expression Language value references a scoped backing bean <code class="email">ContactDetailController.java</code> with the name of <code class="email">contactDetailController</code>. In JSF 2.2, there are now convenience attributes to support the HTML5 support so that the standard <code class="email">id</code>, <code class="email">class</code>, and <code class="email">placeholder</code> attributes work as expected.</p><p class="calibre7">The rendered output is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input id="createContactDetail:firstName" type="text" name="createContactDetail:firstName" class="form-control" /&gt;</pre></div><p class="calibre7">Note that the sugared <code class="email">createContactDetails:firstName</code> identifier matches the output of the <code class="email">&lt;h:outputLabel&gt;</code> tag.</p></div><div class="book" title="The JSF HTML select one menu"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec14" class="calibre1"/>The JSF HTML select one menu</h3></div></div></div><p class="calibre7">The <code class="email">&lt;h:selectOneMenu&gt;</code> tag generates a single select drop-down list. In fact, it is a part of a family<a id="id254" class="calibre1"/> of selection type custom tags. See <span class="strong"><em class="calibre9">JSF HTML select Boolean checkbox</em></span> in the next section.</p><p class="calibre7">In the code, we have the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:selectOneMenu class="form-control"
         id="title"
         value="#{contactDetailController.contactDetail.title}"&gt;
     &lt;f:selectItem itemLabel="--" itemValue="" /&gt;
     &lt;f:selectItem itemValue="Mr" /&gt;
     &lt;f:selectItem itemValue="Mrs" /&gt;
     &lt;f:selectItem itemValue="Miss" /&gt;
     &lt;f:selectItem itemValue="Ms" /&gt;
     &lt;f:selectItem itemValue="Dr" /&gt;
&lt;/h:selectOneMenu&gt;</pre></div><p class="calibre7">The <code class="email">&lt;h:selectOneMenu&gt;</code> tag corresponds to an HTML Form select tag The <code class="email">value</code> attribute is again a JSF expression language string.</p><p class="calibre7">In JSF, we <a id="id255" class="calibre1"/>can use another new custom tag, <code class="email">&lt;f:selectItem&gt;</code>, which adds a child javax.faces.component.UISelectItem to the nearest parent UI component. The <code class="email">&lt;f:selectItem&gt;</code> tag accepts an <code class="email">itemLabel</code> and <code class="email">itemValue</code> attribute. If you set the <code class="email">itemValue</code> and do not specify the <code class="email">itemLabel</code>, then the value becomes the label. So, for the first item, the option is set to <code class="email">--</code> but the value submitted to the form is a blank string because we want to hint to the user that there is a value that ought be chosen.</p><p class="calibre7">The rendered HTML output is instructive, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;select id="createContactDetail:title" size="1"
  name="createContactDetail:title" class="form-control"&gt;  
  &lt;option value="" selected="selected"&gt;--&lt;/option&gt;
  &lt;option value="Mr"&gt;Mr&lt;/option&gt;
  &lt;option value="Mrs"&gt;Mrs&lt;/option&gt;
  &lt;option value="Miss"&gt;Miss&lt;/option&gt;
  &lt;option value="Ms"&gt;Ms&lt;/option&gt;
  &lt;option value="Dr"&gt;Dr&lt;/option&gt;
&lt;/select&gt;</pre></div></div><div class="book" title="The JSF HTML select Boolean checkbox"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec15" class="calibre1"/>The JSF HTML select Boolean checkbox</h3></div></div></div><p class="calibre7">The <code class="email">&lt;h:selectBooleanCheckbox&gt;</code> custom tag is a special case of selection where there is only one <a id="id256" class="calibre1"/>item that the user can choose. Typically, in a web application, you will find such an element in the final terms and conditions form or usually in the marketing e-mail section in an e-commerce application.</p><p class="calibre7">In the targeted managed bean, the only value must be a Boolean type, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:selectBooleanCheckbox for="allowEmails" value="#{contactDetailController.contactDetail.allowEmails}"&gt; Send me email promotions
&lt;/h:selectBooleanCheckbox&gt;</pre></div><p class="calibre7">The rendered output for this custom tag looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input id="createContactDetail:allowEmails" type="checkbox" name="createContactDetail:allowEmails" /&gt;</pre></div></div><div class="book" title="The JSF HTML command button"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec16" class="calibre1"/>The JSF HTML command button</h3></div></div></div><p class="calibre7">The <code class="email">&lt;h:commandButton&gt;</code> custom tags correspond to the HTML form submit element. They accept <a id="id257" class="calibre1"/>an action attribute in JSF that refers to a method in a backing bean. The syntax is again in the JSF expression language:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton styleClass="btn btn-primary" action="#{contactDetailController.createContact()}" value="Submit" /&gt;</pre></div><p class="calibre7">When the user presses this <span class="strong"><strong class="calibre8">Submit</strong></span> button, the JSF framework will find the named managed bean corresponding to <code class="email">contactDetailController</code> and then invoke the no-arguments method: <code class="email">createContact()</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre7">In the expression language, it is important to note that the parentheses are not required because the interpreter or Facelet automatically introspects whether the meaning is an action (<code class="email">MethodExpression</code>) or a value definition (<code class="email">ValueExpression</code>). Be aware that most of the examples in the real world do not add the parentheses as a short hand.</p></div><p class="calibre7">The <code class="email">value</code> attribute denotes the text for the form <span class="strong"><strong class="calibre8">Submit</strong></span> button. We can write the tag in an alternative way and achieve the same result, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:commandButton styleClass="btn btn-primary"
    action="#{contactDetailController.createContact()}" &gt;
    Submit
&lt;/h:commandButton&gt;</pre></div><p class="calibre7">The value is taken from the body content of the custom tag. The rendered output of the tag looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input type="submit" name="createContactDetail:j_idt45" value="Submit" class="btn btn-primary" /&gt;
&lt;input type="hidden" name="javax.faces.ViewState" id="j_id1:javax.faces.ViewState:0" value="-3512045671223885154:3950316419280637340" autocomplete="off" /&gt;</pre></div><p class="calibre7">The preceding code illustrates the output from the JSF renderer in the Mojarra implementation (<a class="calibre1" href="https://javaserverfaces.java.net/">https://javaserverfaces.java.net/</a>), which is the reference implementation. You can clearly see that the renderer writes an HTML submit and hidden element in the output. The hidden element captures information about the view state that is posted back to the JSF framework (postback), which allows it to restore the view.</p><p class="calibre7">Finally, here is a screenshot of the contact details form:</p><div class="mediaobject"><img src="../Images/image00380.jpeg" alt="The JSF HTML command button" class="calibre10"/><div class="caption"><p class="calibre24">The contact details input JSF form with additional DOB fields</p></div></div><p class="calibre11"> </p><p class="calibre7">There are<a id="id258" class="calibre1"/> many more JSF custom tags to consider, and you will find a full table list of all the tags later in the chapter. Now, let's examine the backing bean that is also known as the controller.</p></div></div><div class="book" title="The backing bean controller"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec27" class="calibre1"/>The backing bean controller</h2></div></div></div><p class="calibre7">For our<a id="id259" class="calibre1"/> simple POJO form, we need a backing <a id="id260" class="calibre1"/>bean or, in modern day JSF developer parlance, a managed bean controller.</p><p class="calibre7">The following is the entire code for <code class="email">ContactDetailController</code>:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.ejb.EJB;
import javax.inject.Named;
import javax.faces.view.ViewScoped;
import java.util.List;

@Named("contactDetailController")
@ViewScoped
public class ContactDetailController {
  @EJB ContactDetailService contactDetailService;

  private ContactDetail contactDetail =
    new ContactDetail();

  public ContactDetail getContactDetail() {
      return contactDetail;
  }

  public void setContactDetail(
    ContactDetail contactDetail) {
      this.contactDetail = contactDetail;
  }

  public String createContact() {
      contactDetailService.add(contactDetail);
      contactDetail = new ContactDetail();
      return "index.xhtml";
  }

  public List&lt;ContactDetail&gt; retrieveAllContacts() {
      return contactDetailService.findAll();
  }
}</pre></div><p class="calibre7">For this <a id="id261" class="calibre1"/>managed bean, let's introduce you <a id="id262" class="calibre1"/>to a couple of new annotations. The first annotation is called <code class="email">@javax.inject.Named</code> and it declares this POJO to be a CDI-managed bean, which also simultaneously declares a JSF controller. Here, we will explicitly declare the value of the name of the managed bean as <code class="email">contactDetailController</code>. This is actually the default name of the managed bean, so we could have left it out.</p><p class="calibre7">We can also write an alternative name, as follows:</p><div class="informalexample"><pre class="programlisting">@Named("wizard")
@ViewScoped
public class ContactDetailController { /* .. . */ }</pre></div><p class="calibre7">Then, JSF would give us a bean with the name <code class="email">wizard</code>. The name of the managed bean helps in the expression language syntax.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7">When we are talking about JSF, we can interchange the term backing bean with managed bean freely. Many professional Java web developers understand that both the terms mean the same thing!</p></div><p class="calibre7">The <code class="email">@javax.faces.view.ViewScoped</code> annotation denotes that the controller has scoped the lifecycle of the view. The scoped view is designed for a situation where the application <a id="id263" class="calibre1"/>data is preserved just for one <a id="id264" class="calibre1"/>page until the user navigates to another page. As soon as the user navigates to another page, JSF destroys the bean. JSF removes the reference to the view-scoped bean from its internal data structure and the object is left for the garbage collector.</p><p class="calibre7">The <code class="email">@ViewScoped</code> annotation is new in Java EE 7 and JSF 2.2 and fixes a bug between the Faces and CDI specifications. This is because CDI and JSF were developed independently. By looking at the Javadoc, you will find an older annotation: <code class="email">@javax.faces.bean.ViewScoped</code>, which comes from JSF 2.0 and was not part of the CDI specification.</p><p class="calibre7">For now, if you choose to write the <code class="email">@ViewScoped</code> annotated controllers, you probably should use <code class="email">@ManagedBean</code>. We will explain <code class="email">@ViewScoped</code> beans later in this chapter.</p><p class="calibre7">
<code class="email">ContactDetailController</code> also has a dependency on an <span class="strong"><strong class="calibre8">Enterprise Java Bean</strong></span> (<span class="strong"><strong class="calibre8">EJB</strong></span>) service endpoint: <code class="email">ContactDetailService</code> and most importantly, has a bean property: <code class="email">ContactDetail</code>. Note the <code class="email">getter</code> and <code class="email">setter</code> methods and we will also ensure that the property is <a id="id265" class="calibre1"/>instantiated during the construction time.</p><p class="calibre7">We will now turn our attention to the methods, as follows:</p><div class="informalexample"><pre class="programlisting">  public String createContact() {
    contactDetailService.add(contactDetail);
    contactDetail = new ContactDetail();
    return "index.xhtml";
  }

  public List&lt;ContactDetail&gt; retrieveAllContacts() {
    return contactDetailService.findAll();
  }</pre></div><p class="calibre7">The <code class="email">createContact()</code> method uses EJB to create a new contact detail. It returns a string, which is the next Facelet view: <code class="email">index.xhtml</code>. This method is referenced by <code class="email">&lt;h:commandButton&gt;</code>.</p><p class="calibre7">The <code class="email">retrieveAllContacts()</code> method invokes the data service to fetch the list collection <a id="id266" class="calibre1"/>of the entities. This method will<a id="id267" class="calibre1"/> be referenced by another page.</p></div><div class="book" title="Data service"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec28" class="calibre1"/>Data service</h2></div></div></div><p class="calibre7">The controller relies on an entity bean: <code class="email">ContactDetail</code>. Here is the code for this bean, which has <a id="id268" class="calibre1"/>been simplified:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name="CONTACT")
@NamedQueries({
  @NamedQuery(name="ContactDetail.findAll",
    query = "select c from ContactDetail c " +
            "order by c.lastName, c.middleName, c.firstName")
})
public class ContactDetail {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  @Column(name="CONTACT_ID", nullable = false,
          insertable = true, updatable = true,
          table = "CONTACT")
  private long id;

  private String title="";
  private String firstName;
  private String middleName;
  private String lastName;
  private String email;

  @Temporal(TemporalType.DATE)
  private Date dob;

  private Boolean allowEmails;

  public long getId() { return id; }
  public void setId(long id) { this.id = id; }

  public String getTitle() { return title; }
  public void setTitle(String title) { this.title = title; }

  // Other getters and setters omitted

  // equals, hashCode, toString omitted
}</pre></div><p class="calibre7">It uses the <span class="strong"><strong class="calibre8">Java Persistence API</strong></span> (<span class="strong"><strong class="calibre8">JPA</strong></span>) annotation to map the Java properties to a relational<a id="id269" class="calibre1"/> database.</p><p class="calibre7">There are a set of annotations that <a id="id270" class="calibre1"/>declare against the entity itself. The <code class="email">@Entity</code> annotation marks this POJO as a persistence capable object. The <code class="email">@Table</code> annotation overrides the default database table name for the entity—instead of <code class="email">CONTACT_DETAIL</code>, it becomes <code class="email">CONTACT</code>. The <code class="email">@NameQueries</code> and <code class="email">@NameQuery</code> annotations<a id="id271" class="calibre1"/> define the name queries in the <span class="strong"><strong class="calibre8">Java Persistence Query Language</strong></span> (<span class="strong"><strong class="calibre8">JPQL</strong></span>).</p><p class="calibre7">The remaining annotations declare the metadata that is associated with the database table columns. The <code class="email">@Id</code> annotation specifies the property that will be the primary key, which is the <code class="email">id</code> field. The <code class="email">@GenerationValue</code> annotation declares that the primary key is automatically generated. The JPA provider generates a unique value if there is a <code class="email">0</code> or null value. The other annotation on this property—<code class="email">@Column</code>—renames the default database table column name from <code class="email">ID</code> to <code class="email">CONTACT_ID</code> and sets certain constraints.</p><p class="calibre7">Finally, JPA must specify the date time type for a field with the <code class="email">@Temporal</code> annotation. The annotation value can be <code class="email">Temporal.DATE</code>, <code class="email">Temporal.TIME</code>, or <code class="email">Temporal.TIMESTAMP</code>.</p><p class="calibre7">You will learn about the JPA in my book, Java EE 7 Developer Handbook, where there are several concise and devoted chapters on the subject. However, this book concerns the web application development.</p><p class="calibre7">It should be apparent now that the entity bean can be directly used in a JSF form. Do you remember the JSF expression language for the form properties? Look at the following first name field:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText class="form-control" value="#{contactDetailController.contactDetail.firstName}" id="firstName" placeholder="First name"/&gt;</pre></div><p class="calibre7">As the JSF framework knows about <code class="email">contactDetailController</code> by name, which has a class type of <code class="email">ContactDetailController</code>, it can move through the object graph and determine the property. The controller has a property called <code class="email">contactDetail</code> of the <code class="email">ContactDetail</code> type, which has a <code class="email">firstName</code> property of the String type.</p><p class="calibre7">The key requirement for a controller is that the entity should be instantiated by the time the form is submitted and when the data is retrieved from the form for the <code class="email">remembered</code> values. Let's have a look at the following code:</p><div class="informalexample"><pre class="programlisting">private ContactDetail contactDetail = new ContactDetail();</pre></div><p class="calibre7">There are a number of possibilities that the developer can make use of for a large object hierarchy. Lazy loading and lazy creation of the data structure can help in these situations.</p><p class="calibre7">Let's look now <a id="id272" class="calibre1"/>at the enterprise service bean, <code class="email">ContactDataService</code>:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.digital;
import javax.ejb.Stateful;
import javax.persistence.*;
import java.util.List;

@Stateful
public class ContactDetailService {
  @PersistenceContext(unitName = "applicationDB",
      type = PersistenceContextType.EXTENDED)
  private EntityManager entityManager;

  public void add(ContactDetail contactDetail) {
    entityManager.persist(contactDetail);
  }

  public void update(ContactDetail contactDetail) {
    ContactDetail contactDetailUpdated
         = entityManager.merge(contactDetail);
    entityManager.persist(contactDetailUpdated);
  }

  public void delete(ContactDetail contactDetail) {
    entityManager.remove(contactDetail);
  }

  public List&lt;ContactDetail&gt; findAll() {
    Query query = entityManager.createNamedQuery(
            "ContactDetail.findAll");
    return query.getResultList();
  }
}</pre></div><p class="calibre7">This class is an example of a stateful session EJB, which is essentially a poolable remote service endpoint in an application server with a conversational state. A stateful session bean is associated with a calling client.</p><p class="calibre7">
<code class="email">ContactDetailService</code> has a dependency on a JPA provider, as we can see with the injection of the entity manager through the <code class="email">@PersistenceContext</code> annotation. Note that we are using the extended variety of the persistence context because the conversation can live for more than one request-response cycle.</p><p class="calibre7">In a non-extended persistence conversation, EntityManager will live only as long as there is a JTA transaction. Once the transaction is finished in the Java EE model, all of the persistence<a id="id273" class="calibre1"/> objects are detached from <code class="email">EntityManager</code> and they become unmanaged.</p><p class="calibre7">An extended persistence conversation is one where EntityManager can outlive the scope of a <span class="strong"><strong class="calibre8">Java Transaction API</strong></span> (<span class="strong"><strong class="calibre8">JTA</strong></span>) transaction. In fact, it can survive over several transactions. The <a id="id274" class="calibre1"/>persistence objects do not become detached from EntityManager in this case; the data is only saved to the database when it is flushed explicitly or through the special demarcation of states that the application server provides around the stateful session beans. For this reason, the extended persistence contexts can be used only in the stateful session beans.</p><p class="calibre7">For more information about the permission and stateful session beans, see my sister book, <span class="strong"><em class="calibre9">Java EE 7 Developer Handbook</em></span>.</p><p class="calibre7">For now, we should only concern ourselves with the methods in <code class="email">ContactDataService</code>. The <code class="email">add()</code> method inserts a new record in the database. The <code class="email">update()</code> method amends an existing record and <code class="email">delete()</code> removes the record. The <code class="email">findAll()</code> method retrieves all of the <code class="email">ContactDetail</code> records from the underlying database. It uses the named JPQL query: <code class="email">Contact.findAll</code>.</p><p class="calibre7">You might be wondering where in the user interface is the JSF field that sets up the <code class="email">Date of Birth (DOB)</code> property, as seen in the <code class="email">ContactDetail</code> entity bean. We will add these fields later on.</p></div></div></div>
<div class="book" title="JSF custom tags"><div class="book" id="aid-12AK82"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec29" class="calibre1"/>JSF custom tags</h1></div></div></div><p class="calibre7">As you have <a id="id275" class="calibre1"/>seen, JSF comes with a wealth of custom tag libraries. In order to get the best out of the framework, a digital developer should learn about them and their abilities. The tags can be divided into namespaces as we have previously seen.</p><div class="book" title="The HTML render kit custom tags"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec29" class="calibre1"/>The HTML render kit custom tags</h2></div></div></div><p class="calibre7">The first <a id="id276" class="calibre1"/>set of tags in JSF 2.2 relate to the rendering of the <a id="id277" class="calibre1"/>HTML elements. They are in the name space: <a class="calibre1" href="http://xmlns.jcp.org/jsf/html">http://xmlns.jcp.org/jsf/html</a>. The default implementation<a id="id278" class="calibre1"/> of the render kit in the JSF framework contains component tags for <code class="email">javax.faces.component.UIComponent</code>.</p><p class="calibre7">Here is a table of the HTML render kit tags:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">JSF custom tag</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:column&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<a id="id279" class="indexterm"/>
<p class="calibre14">This renders an instance of <code class="literal">javax.faces.component.UIColumn</code> that represents a single column of data in a parent UIData component. This custom tag is used in <code class="literal">&lt;h:dataTable&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:commandButton&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id280" class="indexterm"/> renders an HTML input element with the submit or rest type.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:commandLink&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id281" class="indexterm"/> renders an HTML anchor element that performs like a submit button, and therefore, the tag must be added in an <code class="literal">&lt;h:form&gt;</code> tag.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:dataTable&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id282" class="indexterm"/> renders an HTML table with rows and columns including the table headers and table column cells.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:form&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id283" class="indexterm"/> renders an HTML form element.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:graphicImage&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id284" class="indexterm"/> renders an HTML image element.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:inputFile&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id285" class="indexterm"/>renders an HTML form input element with a file type and allows an application to upload a file from the client's operating system.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:inputHidden&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id286" class="indexterm"/>renders an HTML form input element with a hidden type.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:inputSecret&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id287" class="indexterm"/>renders an HTML form input element with a password type.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:inputText&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id288" class="indexterm"/>renders an HTML form input element with a text type.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:inputTextarea&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id289" class="indexterm"/> renders an HTML form text area element.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:link&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id290" class="indexterm"/> renders an HTML anchor element that performs an HTTP GET request to the application.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:outputFormat&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id291" class="indexterm"/>tag renders the parameterized text with formatted parameters.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:outputLabel&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id292" class="indexterm"/>renders an HTML label element.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:outputLink&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id293" class="indexterm"/> renders an HTML anchor element that is typically used for non-JSF application links.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:outputText&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id294" class="indexterm"/> tag renders the output to the view.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:message&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id295" class="indexterm"/>renders a single message to a page for a specific component. The tag allows internationalization through a resource bundle.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:messages&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id296" class="indexterm"/>renders a series of messages to a page from the Faces Context.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:panelGrid&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id297" class="indexterm"/> custom tag renders components into a grid. The default JSF implementation uses the HTML table element.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:panelGroup&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id298" class="indexterm"/> custom tag organizes the nested JSF tags into defined groups where the layout produces and generates a single entity.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectBooleanCheckbox&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id299" class="indexterm"/> renders an HTML input element with a checkbox type and is designed for Boolean properties.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectManyCheckbox&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id300" class="indexterm"/> renders a list of the HTML input elements with the type as checkbox.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectManyListbox&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id301" class="indexterm"/>renders a list of the HTML select option elements.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectManyMenu&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id302" class="indexterm"/>renders a list of the HTML select option elements.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectOneListbox&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id303" class="indexterm"/> renders a list of the HTML select option elements.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectOneMenu&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id304" class="indexterm"/>renders a list of the HTML select option elements.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;h:selectOneRadio&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id305" class="indexterm"/>renders a list of the HTML input elements with the type as radio.</p>
</td></tr></tbody></table></div><p class="calibre7">The JSF HTML tags <a id="id306" class="calibre1"/>are divided into different kinds, such as commands, inputs, outputs, and types in order to handle the selection of items. There are also additional tags to handle special cases such as <code class="email">&lt;h:graphicImage&gt;</code> to render the <code class="email">&lt;img&gt;</code> tags and <code class="email">&lt;h:dataTable&gt;</code> to render the <code class="email">&lt;table&gt;</code> information.</p></div><div class="book" title="The core JSF custom tags"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec30" class="calibre1"/>The core JSF custom tags</h2></div></div></div><p class="calibre7">The core JSF custom tags add the features that are independent to the HTML render kit tags. The <a id="id307" class="calibre1"/>namespace for these tags is <a class="calibre1" href="http://xmlns.jcp.org/jsf/core">http://xmlns.jcp.org/jsf/core</a>. The JSF framework is extendable. If you want an alternative <a id="id308" class="calibre1"/>render kit, then all you have to do is add it. The <a id="id309" class="calibre1"/>core JSF custom tags will still work.</p><p class="calibre7">Here is a table of the JSF Core tags:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">JSF custom tag</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:actionListener&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id310" class="indexterm"/> registers an <code class="literal">ActionListener</code> instance.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:attribute&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id311" class="indexterm"/> adds an attribute to <code class="literal">UIComponent</code> with the closest parent <code class="literal">UIComponent</code> action.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:convertDateTime&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id312" class="indexterm"/> registers <code class="literal">DateTimeConverter</code> to <code class="literal">UIComponent</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:convertNumber&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id313" class="indexterm"/>registers <code class="literal">NumberConverter</code> to <code class="literal">UIComponent</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:converter&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id314" class="indexterm"/>renders an HTML anchor element that performs like a submit button, and therefore, the tag must be added in <code class="literal">&lt;h:form&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:facet&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id315" class="indexterm"/> adds a facet to a component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:loadBundle&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id316" class="indexterm"/> loads a resource bundle that is localized for Locale of the current view and stores the properties as <code class="literal">java.util.Map</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:metadata&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id317" class="indexterm"/> declares the metadata facet for this view.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:param&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id318" class="indexterm"/> adds a parameter to <code class="literal">UIComponent</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:phaseListener&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id319" class="indexterm"/>registers a <code class="literal">PhaseListener</code> instance to the page.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:selectItem&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id320" class="indexterm"/>specifies an item for a select one or select many component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:selectItems&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id321" class="indexterm"/>specifies items for a select one or select many component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:setProperty-ActionListener&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id322" class="indexterm"/> registers <code class="literal">ActionListener</code> to the component for a particular property.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:subview&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id323" class="indexterm"/> creates another JSF naming context (See <code class="literal">&lt;f:view&gt;</code>).</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validateDoubleRange&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id324" class="indexterm"/> registers <code class="literal">DoubleRangeValidator</code> to the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validateLength&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id325" class="indexterm"/>registers <code class="literal">LengthValidator</code> to the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validateLongRange&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id326" class="indexterm"/>registers <code class="literal">LongRangeValidator</code> to the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validateRegex&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id327" class="indexterm"/>registers a regular expression validator to the component. If the entire pattern matches, then it is valid.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validateRequired&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id328" class="indexterm"/>ensures that a value in a component is present when a form is submitted.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:validator&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id329" class="indexterm"/>registers a named Validator instance to the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:valueChangeListener&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id330" class="indexterm"/>registers <code class="literal">ValueChangeListener</code> to the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:verbatim&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id331" class="indexterm"/>adds a markup to a JSF page and allows the body content to pass directly to the rendered output.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:view&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id332" class="indexterm"/>sets parameters on the JSF current naming context for the page. Use this tag to override the locale, encoding, or content type.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;f:viewParam&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id333" class="indexterm"/> adds a view parameter to the metadata of a facet so that the page has access to query the parameters in a GET request. This tag can be used only in <code class="literal">&lt;f:metadata&gt;</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">The purpose <a id="id334" class="calibre1"/>of many core JSF tags is to enhance and configure an <code class="email">UIComponent</code> instance. You have already seen this example used with the <code class="email">&lt;f:selectItem&gt;</code> tag in <code class="email">&lt;h:selectOneMenu&gt;</code> in the previous code example, <code class="email">createContact.xhtml</code>. (See the section <span class="strong"><em class="calibre9">Basic JSF form</em></span>).</p><p class="calibre7">For most circumstances, the developer can add attributes, listeners, converters, facets, parameters, and selections to the components using the core JSF tag.</p></div><div class="book" title="The template composition custom tags"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec31" class="calibre1"/>The template composition custom tags</h2></div></div></div><p class="calibre7">The library <a id="id335" class="calibre1"/>of the template JSF custom tags<a id="id336" class="calibre1"/> provides you with the ability to compose pages with content from the other pages. Templating allows the content to reused and shared across an entire JSF application. Best of all, the templates can be adapted by<a id="id337" class="calibre1"/> specifying the parameters so that there is adaptability and flexibility in the mix. The namespace for these tags is <a class="calibre1" href="http://xmlns.jcp.org/jsf/facelets">http://xmlns.jcp.org/jsf/facelets</a>, which underlines the technology of the Facelet view behind the scenes.</p><p class="calibre7">Here is a list of the template tags in JSF 2.2:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">JSF custom tag</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:component&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id338" class="indexterm"/>defines a template component and specifies the filename for the component.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:composition&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id339" class="indexterm"/> defines a page composition, which encapsulates the JSF content that optionally uses a template.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:debug&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id340" class="indexterm"/> creates and adds a special component to the current page that allows the debugging output to be shown.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:define&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id341" class="indexterm"/> defines the JSF content that is inserted into a page by a composition template.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:decorate&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id342" class="indexterm"/> defines the content that decorates specific regions of a JSF page.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:fragment&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id343" class="indexterm"/> defines a template fragment in a way that is similar to the <code class="literal">&lt;ui:composition&gt;</code> tag, except that this tag preserves the content outside the body instead of discarding it.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:include&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id344" class="indexterm"/> includes inserting another JSF page into the current page.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:insert&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id345" class="indexterm"/> inserts a named content definition into the current page. This tag is used in conjunction with <code class="literal">&lt;ui:define&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:param&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id346" class="indexterm"/>passes parameters to an included file that is specified with <code class="literal">&lt;ui:include&gt;</code> or a template reference such as <code class="literal">&lt;ui:composition&gt;</code> or <code class="literal">&lt;ui:include&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:repeat&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id347" class="indexterm"/> iterates over a list collection from the bean property or method. This tag is an alternative way to loop through a collection similar to <code class="literal">&lt;h:dataTable&gt;</code> or <code class="literal">&lt;c:forEach&gt;</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">&lt;ui:remove&gt;</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id348" class="indexterm"/> removes specific marked content from a page.</p>
</td></tr></tbody></table></div><p class="calibre7">We have<a id="id349" class="calibre1"/> seen the operation of <code class="email">&lt;ui:composition&gt;</code>, <code class="email">&lt;ui:define&gt;</code>, and <code class="email">&lt;ui:insert&gt;</code> in <a class="calibre1" title="Chapter 2. JavaServer Faces Lifecycle" href="part0025.xhtml#aid-NQU22">Chapter 2</a>, <span class="strong"><em class="calibre9">JavaServer Faces Lifecycle</em></span>. We will definitely be using the template JSF tags for the remainder of the book concerning JSF.</p></div><div class="book" title="Common attributes"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec32" class="calibre1"/>Common attributes</h2></div></div></div><p class="calibre7">The JSF<a id="id350" class="calibre1"/> standard tags share many common attributes. The following table is a reference and some of these attributes are available for most of the HTML render kit tags:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Attribute Name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">id</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id351" class="indexterm"/> specifies the HTML element identifier. JSF developers should use this attribute every time.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">binding</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id352" class="indexterm"/> binds a tag to a component instance in a managed bean. The JSF framework binds a component's reference in the component tree to a scoped variable.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">Immedate</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id353" class="indexterm"/>specifies to a Boolean value, if set <code class="literal">true</code>, it causes the JSF framework to skip the processing of validations, conversions, and events after the Apply Request Value stage in the JSF lifecycle.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">rendered</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id354" class="indexterm"/>specifies to a Boolean value, which usually defaults to true, whether the component should be rendered.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">required</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id355" class="indexterm"/> specifies to a Boolean value whether this input element is required for input validation.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">styleClass</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id356" class="indexterm"/> specifies the HTML class attribute for a rendered tag.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">stylestyle</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This <a id="id357" class="indexterm"/>specifies the HTML style attribute for the rendered tag.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">
<code class="literal">valuevalue</code>
</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This<a id="id358" class="indexterm"/> specifies a String value or expression language reference.</p>
</td></tr></tbody></table></div><p class="calibre7">Now that we have seen the JSF tags, we will move back to our CRUD example.</p></div></div>
<div class="book" title="Displaying a list collection of objects"><div class="book" id="aid-1394Q2"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec30" class="calibre1"/>Displaying a list collection of objects</h1></div></div></div><p class="calibre7">For CRUD examples, we are often faced with the practical problem of displaying the data in the application in a meaningful context that the user can understand. One of the easiest ways is to just print out a list of items for the fairly simple data. Another way is to display a tabular view of the data. There are other solutions worthy of consideration if your data is a tree structure or a graph.</p><p class="calibre7">For our case, we<a id="id359" class="calibre1"/> will choose the second path and display the list of contact details in a table. In JSF, we can use the <code class="email">&lt;h:dataTable&gt;</code> HTML component. This custom tag iterates over each object in the list and displays the specified values. The <code class="email">&lt;h:dataTable&gt;</code> component is a very powerful and flexible tag because the Java web engineer can configure it in order to render the custom styles in a variety of layouts.</p><p class="calibre7">Let's take a look at another JSF Facelet view, <code class="email">index.html</code>, in the <code class="email">jsf-crud</code> project. As a reminder, we are using Bootstrap CSS to style. Now, here is the extracted code, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="main-content"&gt;
  ...
  &lt;h2&gt; List of Contact Details &lt;/h2&gt;

  &lt;h:dataTable id="contactTable"
    value="#{contactDetailController.retrieveAllContacts()}"
    styleClass="table-striped table-bordered user-table"
    var="contact"&gt;
    &lt;h:column&gt;
      &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Title" /&gt;
      &lt;/f:facet&gt;
        &lt;h:outputText value="#{contact.title}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;
            &lt;h:outputText value="First name" /&gt;
        &lt;/f:facet&gt;
        &lt;h:outputText value="#{contact.firstName}"/&gt;
    &lt;/h:column&gt;

    ... (repeat for Middle name and Last Name) ...

    &lt;h:column&gt;
      &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Email" /&gt;
      &lt;/f:facet&gt;
        &lt;h:outputText value="#{contact.email}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
      &lt;f:facet name="header"&gt;
        &lt;h:outputText value="D.O.B" /&gt;
      &lt;/f:facet&gt;
        &lt;h:outputText value="#{contact.dob}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
      &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Allow emails?" /&gt;
      &lt;/f:facet&gt;
        &lt;h:outputText value="#{contact.allowEmails}"/&gt;
    &lt;/h:column&gt;
  &lt;/h:dataTable&gt;

  &lt;hr class="subfeaturette-divider" /&gt;
&lt;/div&gt;&lt;!-- main-content --&gt;</pre></div><p class="calibre7">The first <a id="id360" class="calibre1"/>thing that you will notice is that the <code class="email">&lt;h:dataTable&gt;</code> tag accepts a value attribute, which is the JSF expression language reference to the controller's <code class="email">retrieveAllContacts()</code> method. <code class="email">ContactDetailController</code> delegates this request to <code class="email">ContactDetailService</code>, the stateful session EJB that we saw earlier.</p><p class="calibre7">The <code class="email">var</code> attribute specifies the name of the JSF scope variable, which is the element that is created each time a component iterates through the list collection. The type of the element in the view is the entity bean: <code class="email">ContactDetail</code>.</p><p class="calibre7">The <code class="email">styleClass</code> attributes add specific CSS styles from the Bootstrap framework, and of course, every component can have an <code class="email">id</code> attribute.</p><p class="calibre7">The <code class="email">&lt;h:dataTable&gt;</code> component requires the nested delineated <code class="email">&lt;h:column&gt;</code> tags that describe the <a id="id361" class="calibre1"/>column data for the table.</p><p class="calibre7">If you want header rows for the table, then you must place and add a core JSF tag called <code class="email">&lt;f:facet&gt;</code> in the <code class="email">&lt;h:column&gt;</code> tag. This tag name must be given a special name attribute with the <code class="email">header</code> value. If you were to ask me: why must I write tags using different XML namespaces? Then my answer would be that this was the way the JSF designers foresaw that the core tags could be reusable to the other rendering kits. Hence, the tag name is <code class="email">&lt;f:facet&gt;</code> and not something like <code class="email">&lt;h:headerColumn&gt;</code>.</p><p class="calibre7">In order to show the user the information for each row, we use the <code class="email">&lt;h:outputText&gt;</code> element. This tag accepts another expression language statement, namely, the reference to the property in the entity bean such as <code class="email">#{contact.firstName}</code>.</p><p class="calibre7">Here is a screenshot of the <code class="email">index.html</code> list view:</p><div class="mediaobject"><img src="../Images/image00381.jpeg" alt="Displaying a list collection of objects" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the list view for the CRUD application</p></div></div><p class="calibre11"> </p><div class="book" title="Enhanced date time entry"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec33" class="calibre1"/>Enhanced date time entry</h2></div></div></div><p class="calibre7">If you notice, we neglected to add the JSF controls so that a user can add his or her date of birth to the<a id="id362" class="calibre1"/> contact details form. Let us presume that we have a directive from the UX person in our agile team and that the input has to be in two drop-down lists. The business wants two drop-down elements for the days of the month and months of the year respectfully. They also want a text entry for the year.</p><p class="calibre7">We have already covered some of the HTML selection custom tags so far in our JSF journey, such as <code class="email">&lt;h:selectOneMenu&gt;</code> and <code class="email">&lt;h:selectBooleanCheckbox&gt;</code>. Now, we will learn how to generate data for these tags programmatically from our managed bean. If we can help it—and we surely can—we truly don't want to repeat writing <code class="email">&lt;f:selectItem&gt;</code> 31 times in a JSF view.</p><p class="calibre7">We will need to <a id="id363" class="calibre1"/>add extra logic to <code class="email">ContactDetailController</code>. These are the enhancements for the JSF managed bean, which provide the methods accessible to the page view through the expression language, which is mentioned as follows:</p><div class="informalexample"><pre class="programlisting">@ManagedBean(name = "contactDetailController")
@ViewScoped
public class ContactDetailController {
  // ... same as before

  public String createContact() {
      Calendar cal = Calendar.getInstance();
      cal.set(Calendar.DAY_OF_MONTH, dobDay);
      cal.set(Calendar.MONTH, dobMonth-1 );
      int year = Integer.parseInt(dobYear);
      cal.set(Calendar.YEAR, year);
      contactDetail.setDob(cal.getTime());
      contactDetailService.add(contactDetail);  
      contactDetail = new ContactDetail();
      return "index.xhtml";
  }

  // ...

  private int dobDay;
  private int dobMonth;
  private String dobYear;

  public int getDobDay() { return dobDay; }
  public void setDobDay(int dobDay) {
      this.dobDay = dobDay; }
  // ... getter and setter for dobMonth and dobYear

  private static List&lt;Integer&gt; daysOfTheMonth
    = new ArrayList&lt;&gt;();
  private static Map&lt;String,Integer&gt; monthsOfTheYear
    = new LinkedHashMap&lt;&gt;();

  static {
    for (int d=1; d&lt;=31; ++d) {
        daysOfTheMonth.add(d);
    }

    DateFormatSymbols symbols =
            new DateFormatSymbols(Locale.getDefault());
    for (int m=1; m&lt;=12; ++m) {
        monthsOfTheYear.put(symbols.getMonths()[m-1], m );
    }
  }

  public List&lt;Integer&gt; getDaysOfTheMonth() {
      return daysOfTheMonth;
  }
  public Map&lt;String,Integer&gt; getMonthsOfTheYear() {
      return monthsOfTheYear;
  }
}</pre></div><p class="calibre7">We will add <a id="id364" class="calibre1"/>three new bean properties: <code class="email">dobDay</code>, <code class="email">dobMonth</code>, and <code class="email">dobYear</code> to the controller. Note that <code class="email">dobYear</code> is a string, whereas the other two are integers because the year field is a text field. When an integer is used, the default value shown in the front end is <code class="email">0</code>, which detracts and confuses the user. We want the user to see an empty text field. There are getters and setters for these new properties.</p><p class="calibre7">We enhance the <code class="email">createContact()</code> method to take into account the date of birth from the three separate fields and convert them to a DOB value using a <code class="email">java.util.Calendar</code> instance. Before the entity bean is saved to the database, we will set a property on the entity with the computed value of a <code class="email">java.util.Date</code> type.</p><p class="calibre7">There are two bean property methods, <code class="email">getDaysOfTheMonth()</code> and <code class="email">getMonthsOfTheYear()</code>, which will return the static collections that are built in the static initializer of the class. The <code class="email">daysOfTheMonth</code> field is a list collection of integers from 1 to 31, and the <code class="email">monthsOfTheYear</code> field is a map collection of the entries and strings associated with integers, which represent the months of the year.</p><p class="calibre7">We use JDK's <code class="email">DateFormatSymbols</code> class to retrieve the long names of the months that are set to the application's default locale.</p><p class="calibre7">With these backend changes, we can adapt the JSF view in order to add the ability to set the applicant's date of birth.</p><p class="calibre7">Here are the updated changes in the JSF view, <code class="email">createContactDetails.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;label class="control-label"&gt; Your Date of Birth&lt;/label&gt;
&lt;div class="row  my-group-border"&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;label class="control-label" for="dobDay"&gt;Day&lt;/label&gt;
    &lt;div class="controls"&gt;
      &lt;h:selectOneMenu id="dobDay"
          value="#{contactDetailController.dobDay}"
          label="Registration Day"&gt;
        &lt;f:selectItem itemLabel="----"  itemValue=""/&gt;
        &lt;f:selectItems
           value="#{contactDetailController.daysOfTheMonth}"
           var="day"
            itemLabel="#{day}" itemValue="#{day}" /&gt;
        &lt;f:validateRequired/&gt;
      &lt;/h:selectOneMenu&gt;
      &lt;h:message for="dobDay" styleClass="form-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;label class="control-label" for="dobMonth"&gt;Month&lt;/label&gt;
    &lt;div class="controls"&gt;
      &lt;h:selectOneMenu id="dobMonth"
          value="#{contactDetailController.dobMonth}"
          label="Registration Month"&gt;
        &lt;f:selectItem itemLabel="----"  itemValue=""/&gt;
        &lt;f:selectItems
          value="#{contactDetailController.monthsOfTheYear}" /&gt;
        &lt;f:validateRequired/&gt;
      &lt;/h:selectOneMenu&gt;
      &lt;h:message for="dobMonth" styleClass="form-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="col-sm-3"&gt;
    &lt;label class="control-label" for="dobYear"&gt;Year&lt;/label&gt;
    &lt;div class="controls"&gt;
      &lt;h:inputText id="dobYear"
          value="#{contactDetailController.dobYear}"
          label="Registration Year"&gt;
        &lt;f:validateRequired/&gt;
      &lt;/h:inputText&gt;
      &lt;h:message for="dobYear" styleClass="form-error"/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h:commandButton styleClass="btn btn-primary" action="#{contactDetailController.createContact()}" value="Submit" /&gt;</pre></div><p class="calibre7">Well, hopefully I did not scare you off and have you running up the hill! We are using Bootstrap CSS v3.11 here, so this is the reason you see a lot of the <code class="email">&lt;div&gt;</code> elements in HTML <a id="id365" class="calibre1"/>with the specifically named CSS selectors such as <code class="email">control-label</code>, <code class="email">col-sm-6</code> and <code class="email">row</code>. Bootstrap is popular framework for HTML5, CSS and JavaScript that helps designers and developers build responsive web sites.</p><p class="calibre7">As a component framework, JSF provides the basis to encapsulate the <code class="email">&lt;div&gt;</code> layer, CSS, and JavaScript. There are a few approaches that can help. First, the teams can develop their custom components; second, they can leverage a third-party component system that has the features and customization that is required, and finally, the team can act as a library writer and therefore, create their own bespoke HTML render kit. The custom components are a lot easier to program, which we will talk about in <a class="calibre1" title="Chapter 5. Conversations and Journeys" href="part0050.xhtml#aid-1FLS41">Chapter 5</a>, <span class="strong"><em class="calibre9">Conversations and Journeys</em></span>.</p><p class="calibre7">If your team is interested in the component libraries, then you may want to look at vendor<a id="id366" class="calibre1"/> solutions such as Rich Faces (<a class="calibre1" href="http://richfaces.jboss.org/">http://richfaces.jboss.org/</a>) and <a id="id367" class="calibre1"/>particularly, Prime Faces (<a class="calibre1" href="http://primefaces.org/">http://primefaces.org/</a>).</p><p class="calibre7">Let's concentrate on the <code class="email">&lt;h:selectOneMenu&gt;</code> tags. This HTML custom tag from the JSF namespaces specifies a drop-down selection list where the user can choose only one item. The <code class="email">value</code> attribute references a property in the controller bean. So, the expression language for the first field is <code class="email">#{contactDetailController.dobDay}</code>.</p><p class="calibre7">In the parent tag, you see the <code class="email">&lt;f:selectItem&gt;</code> and <code class="email">&lt;f:selectItems&gt;</code> custom tags. The <code class="email">&lt;f:selectItem&gt;</code> tag defines one menu item. It accepts an <code class="email">itemLabel</code> and <code class="email">itemValue</code> attribute. We can use it to define a default empty option.</p><p class="calibre7">The <code class="email">&lt;f:selectItems&gt;</code> tag defines many menu items and accepts another value attribute, which is the expression language <code class="email">#{contactDetailController.daysOfTheMonth}</code>. This expression refers to the controller getter method, <code class="email">getDaysOfTheMonth()</code>, which returns <code class="email">List&lt;Integer&gt;</code>. We will use <code class="email">var</code>, <code class="email">itemLabel</code>, and <code class="email">itemValue</code> to configure how this collection renders each menu option, as follows.</p><div class="informalexample"><pre class="programlisting">&lt;f:selectItems  value="#{contactDetailController.daysOfTheMonth}" var="day" itemLabel="#{day}" itemValue="#{day}" /&gt;</pre></div><p class="calibre7">Just as with the <code class="email">&lt;h:dataTable&gt;</code> tag, we can define a JSF scope variable using the <code class="email">var</code> attribute and iterate effectively through the collection.</p><p class="calibre7">The markup for the months of the year dropdown is slightly different in <code class="email">&lt;f:selectMenu&gt;</code>. As <code class="email">getMonthsOfTheYear()</code> already returns a <code class="email">Map&lt;String,Integer&gt;</code> collection, there is no need to provide the configuration of the labels and values. The custom tag already knows that it has to render the map collections.</p><p class="calibre7">The last field for the DOB year is <code class="email">&lt;h:inputText&gt;</code>, and by now, you already know how these tags <a id="id368" class="calibre1"/>work. There are a couple of surprises that you may have noticed.</p><p class="calibre7">The <code class="email">&lt;f:validateRequired&gt;</code> tag is a validation custom tag, which specifies that the bean properties must be defined by the time the form is submitted. The <code class="email">&lt;h:message&gt;</code> tag specifies an area in the HTML where we want a specific validation error to appear, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:message for="dobYear" styleClass="form-error"/&gt;</pre></div><p class="calibre7">The <code class="email">&lt;h:message&gt;</code> tag accepts a compulsory for attribute that refers to the JSF HTML form property. We can set the CSS style with the <code class="email">styleClass</code> attribute, which is a form error from Bootstrap. In the next chapter, we will look at the validation properly.</p><p class="calibre7">Here is a screenshot of the new form:</p><div class="mediaobject"><img src="../Images/image00382.jpeg" alt="Enhanced date time entry" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the create page view for the contact data application</p></div></div><p class="calibre11"> </p></div></div>
<div class="book" title="Editing data"><div class="book" id="aid-147LC2"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec31" class="calibre1"/>Editing data</h1></div></div></div><p class="calibre7">Now, let's add one more JSF <code class="email">index.xhtml</code> to allow the users to edit and delete the contact details. Before we can edit a contact detail, we must add some JSF links to the list view so that the<a id="id369" class="calibre1"/> user can navigate to the edit and remove pages.</p><p class="calibre7">Let's modify the <code class="email">&lt;h:dataTable&gt;</code> section in the <code class="email">index.xhtml</code> view and add an additional column. The code looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable id="contactTable"
  ... other columns as before ...
  &lt;h:column&gt;
    &lt;f:facet name="header"&gt;
      &lt;h:outputText value="Action" /&gt;
    &lt;/f:facet&gt;
    &lt;h:link styleClass="btn"
      outcome="editContactDetail.xhtml?id=#{contact.id}"&gt;
      &lt;f:param name="id" value="#{contact.id}" /&gt;
      &lt;span class="glyphicon glyphicon-edit"&gt;&lt;/span&gt;
    &lt;/h:link&gt;
    &lt;h:link styleClass="btn"
      outcome="removeContactDetail.xhtml?id=#{contact.id}"&gt;
      &lt;f:param name="id" value="#{contact.id}" /&gt;
      &lt;span class="glyphicon glyphicon-trash"&gt;&lt;/span&gt;
    &lt;/h:link&gt;
  &lt;/h:column&gt;

&lt;/h:dataTable&gt;</pre></div><p class="calibre7">We have two <code class="email">&lt;h:link&gt;</code> tags that generate two HTML anchor element links to two new pages: <code class="email">editContactDetail.xhtml</code> and <code class="email">removeContactDetail.xhtml</code>.</p><p class="calibre7">The <code class="email">&lt;h:link&gt;</code> custom tag has an outcome attribute to generate the URL using the JSF navigation rules. The <code class="email">value</code> attribute specifies the text on the link or you may specify the body text. The tag is clever enough that if the link does not exist, then it will generate a <code class="email">&lt;span&gt;</code> element instead. This is a useful feature for prototyping.</p><p class="calibre7">Here is some of the rendered output for <code class="email">&lt;h:link&gt;</code>:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;
  &lt;a href="/jsf-crud-1.0-SNAPSHOT/editContactDetail.xhtml?id=5" class="btn"&gt;
    &lt;span class="glyphicon glyphicon-edit"&gt;&lt;/span&gt;&lt;/a&gt;
  &lt;a href="/jsf-crud-1.0-SNAPSHOT/deleteContactDetail.xhtml?id=5" class="btn"&gt;
    &lt;span class="glyphicon glyphicon-trash"&gt;&lt;/span&gt;&lt;/a&gt;
&lt;/td&gt;</pre></div><p class="calibre7">The <code class="email">glyphicon</code>, <code class="email">glyphicon-edit</code>, and <code class="email">glyph-trash</code> class are markups from Bootstrap to show the <a id="id370" class="calibre1"/>icon buttons.</p><p class="calibre7">With the links in place, we must now allow the editing of the contract details on the server side. We will adapt <code class="email">ContactDetailController</code> with new properties and methods. The first property that we will introduce is <code class="email">id</code> so that we can track the primary key of the contact ID in the database. We will also require a getter and setter for the JSF framework.</p><p class="calibre7">On second thoughts, it would be nice to allow the user to cancel the task. So, we will introduce a <code class="email">cancel()</code> method in the controller. We will also add a couple of methods: <code class="email">findByContactId()</code> and <code class="email">editContact()</code>.</p><p class="calibre7">This is the following code of <code class="email">ContactDetailController</code> as it now stands:</p><div class="informalexample"><pre class="programlisting">import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;

public class ContactDetailController {
  // ... as before ...
  private int id;

  public int getId() { return id; }
  public void setId(int id) { this.id = id; }

  public String cancel() {
      return "index.xhtml";
  }

  public void findContactById() {
    if (id &lt;= 0) {
      String message =
        "Bad request. Please use a link from within the system.";
      FacesContext.getCurrentInstance().addMessage(null,
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR, message, null));
      return;
    }

    ContactDetail item = contactDetailService.findById(id).get(0);
    if (item == null) {
      String message =
        "Bad request. Unknown contact detail id.";
      FacesContext.getCurrentInstance().addMessage(null,
        new FacesMessage(
          FacesMessage.SEVERITY_ERROR, message, null));
    }
    contactDetail = item;
    Calendar cal = Calendar.getInstance();
    cal.setTime(contactDetail.getDob());
    dobDay = cal.get(Calendar.DAY_OF_MONTH);
    dobMonth = cal.get(Calendar.MONTH)+1;
    dobYear = Integer.toString(cal.get(Calendar.YEAR));
  }

  public String editContact() {
      Calendar cal = Calendar.getInstance();
      cal.set(Calendar.DAY_OF_MONTH, dobDay);
      cal.set(Calendar.MONTH, dobMonth-1);
      int year = Integer.parseInt(dobYear);
      cal.set(Calendar.YEAR, year);
      contactDetail.setDob(cal.getTime());
      contactDetail.setId(id)
      contactDetailService.update(contactDetail);
      contactDetail = new ContactDetail();
      return "index.xhtml";
  }

  // ...
}</pre></div><p class="calibre7">The <code class="email">cancel()</code> method simply returns the next view: <code class="email">index.xhtml</code>. It does nothing, which is not an <a id="id371" class="calibre1"/>error in the code, but is in fact the purpose: to go back to the start.</p><p class="calibre7">The <code class="email">findContactById()</code> method uses the <code class="email">id</code> property to look up the contact details using the <code class="email">ContactDataService</code> EJB. This method makes use of the <code class="email">Calendar</code> instance in order to pull apart the <code class="email">dob</code> property from the <code class="email">ContactDetail</code> entity in the constituent <code class="email">dobDay</code>, <code class="email">dobMonth</code>, and <code class="email">dobYear</code> properties.</p><p class="calibre7">The <code class="email">javax.faces.context.FacesContext</code> type is an aggregate object that stores the current request and response information. <code class="email">FacesContext</code> can be retrieved using the factory method only. In the example, we will add an error message to the Faces response, which can be displayed in the view. The <code class="email">javax.faces.application.FacesMessage</code> type is a representation of the error validation or it can be defined as a message resource from a external resource bundle. See <a class="calibre1" title="Appendix A. JSF with HTML5, Resources, and Faces Flows" href="part0093.xhtml#aid-2OM4A1">Appendix A</a>, <span class="strong"><em class="calibre9">JSF with HTML5, Resources, and Faces Flows</em></span>.</p><p class="calibre7">The <code class="email">editContact()</code> method is almost the same as <code class="email">createContect()</code> because it reconstructs the <code class="email">dob</code> property in the entity. The difference is that the <code class="email">id</code> property in the entity is set from the controller property: <code class="email">id</code>. Setting the correct primary key is extremely important because the user does not want to see duplicate entries. The <code class="email">editContect()</code> method now invokes the database using <code class="email">update()</code> instead of <code class="email">create()</code>.</p><p class="calibre7">We will now <a id="id372" class="calibre1"/>adapt the <code class="email">ContactDetail</code> entity with a new named query. The following is the modification:</p><div class="informalexample"><pre class="programlisting">@Entity
@Table(name="CONTACT")
@NamedQueries({
  @NamedQuery(name="ContactDetail.findAll", query = "select c from ContactDetail c " + "order by c.lastName, c.middleName, c.firstName"), @NamedQuery(name="ContactDetail.findById", query = "select c from ContactDetail c where c.id = :id"),
})
public class ContactDetail { /* ... as before ... */ }</pre></div><p class="calibre7">The named <code class="email">ContactDetail.findById</code> query uses a JPQL statement with a key parameter, which is denoted in the string as <code class="email">:id</code>. We will now add an extra method to the EJB.</p><p class="calibre7">Here is the additional <code class="email">ContactDetailService</code> method with the following code:</p><div class="informalexample"><pre class="programlisting">@Stateful
public class ContactDetailService {
  // ... as before ...
  
  public List&lt;ContactDetail&gt; findById(Integer id) {
    Query query = entityManager.createNamedQuery("ContactDetail.findById").setParameter("id", id);
    return query.getResultList();
  }
}</pre></div><p class="calibre7">The <code class="email">findById()</code> method makes use of the named query and invokes the JPA query in order to retrieve a list collection of the <code class="email">ContactDetail</code> elements. There should only be one element in the collection by definition as we are querying by a primary key.</p><p class="calibre7">With these change in the backend, all we need are a few changes in the page view, which is almost the same as <code class="email">createContactDetail.xhtml</code>.</p><p class="calibre7">Here is an extract of the Facelet view, <code class="email">editContactDetail.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
  &lt;f:metadata&gt;
    &lt;f:viewParam name="id" value="#{contactDetailController.id}" /&gt;
    &lt;f:event type="preRenderView" listener="#{contactDetailController.findContactById()}"/&gt;
  &lt;/f:metadata&gt;

  ...

  &lt;div class="main-content"&gt;
    &lt;h1&gt; Edit Contact Details &lt;/h1&gt;
    &lt;h:form id="editContactDetail"
      styleClass="form-horizontal"
      p:role="form"&gt;
        &lt;h:inputHidden value="${contactDetailController.id}" /&gt;

        &lt;div class="form-group"&gt;
          ...
        &lt;/div&gt;

        &lt;h:commandButton styleClass="btn btn-primary"
          action="#{contactDetailController.editContact()}"
          value="Submit" /&gt;
        &amp;#160;
        &amp;#160;
        &lt;h:commandButton styleClass="btn btn-default"
          action="#{contactDetailController.cancel()}"
          immediate="true" value="Cancel"/&gt;
    &lt;/h:form&gt;

    &lt;hr class="subfeaturette-divider" /&gt;

  &lt;/div&gt;&lt;!--  "main-content" --&gt;
  ...
&lt;/h:body&gt;</pre></div><p class="calibre7">There are <a id="id373" class="calibre1"/>JSF custom tags used here. The <code class="email">&lt;f:metadata&gt;</code> tag is a container tag that declares a metadata facet for the current page.</p><p class="calibre7">The <code class="email">&lt;f:viewParam&gt;</code> tag attaches a GET request parameter for the page as metadata for the current view. We will use it to attach the query parameter to the controller property. The name attribute specifies the query parameter name. The <code class="email">value</code> attribute specifies the JSF expression language reference. Giving a URL request such as <code class="email">/jsf-crud-1.0-SNAPSHOT/editContactDetail.xhtml?id=4</code> will cause the framework to populate the <code class="email">id</code> property in <code class="email">ContactDetailController</code> with the value of <code class="email">4</code>. This call happens in the Restore View phase of the JSF lifecycle.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre7">As the <code class="email">&lt;f:metadata&gt;</code> tag declares the metadata for a single page view, it must be placed near the root element view of the page. The <code class="email">&lt;f:metadata&gt;</code> tag must be placed in <code class="email">&lt;ui:define&gt;</code> if it is used in a JSF template composition. In the example, the tag is just after <code class="email">&lt;h:body&gt;</code>.</p></div><p class="calibre7">The <code class="email">&lt;f:event&gt;</code> custom tag associates a JSF Faces event with a component. The official documentation describing this tag says that it installs a <code class="email">ComponentSystemEventListener</code> instance on a target component in a page. Here, we can simply say <a id="id374" class="calibre1"/>that the tag associates a prerendering event with the <code class="email">findByContactId()</code> method in the controller. In other words, <code class="email">&lt;f:event&gt;</code> prepopulates the form with the data from the underlying database.</p><p class="calibre7">In the <code class="email">&lt;h:form&gt;</code> content, we will use the <code class="email">&lt;h:hidden&gt;</code> custom tag so as to store the current ID of the contact details. The value attribute is an expression reference. In this way, the identifier is propagated back to the controller when the user submits the form.</p><p class="calibre7">Finally, there are two <code class="email">&lt;h:submit&gt;</code> buttons and they reference the <code class="email">editContact()</code> and <code class="email">cancel()</code> methods in the controller respectively. The intermediate attribute in the second <code class="email">&lt;h:submit&gt;</code> button specifies that the JSF life cycle should skip the Process Validation state. JSF then does not apply the validation when the form is submitted. Instead, the life cycle moves from Apply Request Values directly to the Render Response state.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Adding HTML entity characters to XHTML</strong></span>
</p><p class="calibre7">Facelets only support five predefined XML entity characters: <code class="email">&amp;lt</code>, <code class="email">&amp;gt</code>, <code class="email">&amp;amp</code>, <code class="email">&amp;quot</code>, and <code class="email">&amp;apos</code>. The only way to add an HTML element is through the hexadecimal or octal notation. The <code class="email">&amp;#160</code> entity represents the Unicode character <code class="email">&amp;nbsp</code> for break space.</p></div><p class="calibre7">Here is a screenshot of the <code class="email">editContactDetail.xhtml</code> view:</p><div class="mediaobject"><img src="../Images/image00383.jpeg" alt="Editing data" class="calibre10"/><div class="caption"><p class="calibre24">A screenshot of the edit page view for the contact details application</p></div></div><p class="calibre11"> </p></div>
<div class="book" title="Removing data" id="aid-1565U1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec32" class="calibre1"/>Removing data</h1></div></div></div><p class="calibre7">Our user is <a id="id375" class="calibre1"/>able to create the contact details and she can now update the entries. To complete our customer's journey, we should allow her to remove the entries as a good Net citizen. Why there are so many companies out there that want to block the access to delete the user's data by putting in hazards or extra hassles to make such a simple task so difficult is beyond me! However, we can do this for our contact detail application and it is now straightforward as we have the building blocks in place.</p><p class="calibre7">We will add a <code class="email">removeDetail()</code> method to <code class="email">ContactDetailController</code>. Here is the extra method:</p><div class="informalexample"><pre class="programlisting">public class ContactDetailController {
  // ... as before ...
  public String removeContact() {
    contactDetail = contactDetailService.findById(id).get(0);
    contactDetailService.delete(contactDetail);
    contactDetail = new ContactDetail();
    return "index.xhtml";
  }
}</pre></div><p class="calibre7">This method <a id="id376" class="calibre1"/>searches for <code class="email">contactDetail</code> by a fresh <code class="email">id</code>. The <code class="email">id</code> field is the controller's property, which is set in a hidden form field. By invoking the data services <code class="email">findById()</code> method at the form submission, we will ensure that we retrieve the latest information from the persistence context. Maybe the user went off to lunch and came back and then submitted the form. With the entity found, we can then call the data service to remove it.</p><p class="calibre7">Here is an extract of the <code class="email">removeContactDetail.xhtml</code> view:</p><div class="informalexample"><pre class="programlisting">&lt;div class="main-content"&gt;
  &lt;h1&gt; Delete Contact Details &lt;/h1&gt;
  &lt;table class="table table-striped table-bordered"&gt;
    &lt;tr&gt;
      &lt;th&gt; Item&lt;/th&gt; &lt;th&gt; Value&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Title &lt;/td&gt;
      &lt;td&gt;
      #{contactDetailController.contactDetail.title} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; First Name &lt;/td&gt;
      &lt;td&gt;
      #{contactDetailController.contactDetail.firstName} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Middle Name &lt;/td&gt;
      &lt;td&gt;
      #{contactDetailController.contactDetail.middleName} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Last Name &lt;/td&gt;
      &lt;td&gt;
      #{contactDetailController.contactDetail.lastName} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Allows Email? &lt;/td&gt;
      &lt;td&gt;
      #{contactDetailController.contactDetail.allowEmails} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Email &lt;/td&gt;
      &lt;td&gt; #{contactDetailController.contactDetail.email} &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; Date of Birth &lt;/td&gt;
      &lt;td&gt;
        &lt;h:outputText
          value="#{contactDetailController.contactDetail.dob}" &gt;
          &lt;f:convertDateTime type="date" pattern="dd-MMM-yyyy"/&gt;
        &lt;/h:outputText&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;

  &lt;h:form id="editContactDetail"
    styleClass="form-horizontal"
    p:role="form"&gt;
    &lt;h:inputHidden value="${contactDetailController.id}" /&gt;

      &lt;h:commandButton styleClass="btn btn-primary"
        action="#{contactDetailController.removeContact()}"
        value="Submit" /&gt;
      &amp;#160;
      &amp;#160;
      &lt;h:commandButton styleClass="btn btn-default"
        action="#{contactDetailController.cancel()}"
        immediate="true" value="Cancel"/&gt;
  &lt;/h:form&gt;
&lt;/div&gt;</pre></div><p class="calibre7">If you look at<a id="id377" class="calibre1"/> this carefully, then you will see the <code class="email">&lt;table&gt;</code> element that displays the properties of the <code class="email">ContactDetail</code> entity; but wait a minute, where have the <code class="email">&lt;h:outputText&gt;</code> elements gone? Well, in JSF 2, you no longer have to write <code class="email">&lt;h:outputText&gt;</code>, just output the authoring content for the JSF managed bean and you can immediately write the expression directly in place.</p><p class="calibre7">Hence, one simply writes as follows:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt; #{contactDetailController.contactDetail.title} &lt;/td&gt;</pre></div><p class="calibre7">Instead of:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;
  &lt;h:outputText
    value="#{contactDetailController.contactDetail.title}"/&gt;
&lt;/td&gt;</pre></div><p class="calibre7">Which of the<a id="id378" class="calibre1"/> preceding authoring contents would you prefer to program with?</p><p class="calibre7">However, the DOB is a field where we will use the <code class="email">&lt;h:outputText&gt;</code> element. The <code class="email">&lt;f:convertDateTime&gt;</code> tag formats a <code class="email">java.util.Date</code> type to a readable format. The pattern attribute specifies the date format pattern. This tags relies on the <code class="email">java.text.SimpleDateFormat</code> class.</p><p class="calibre7">The <code class="email">&lt;h:form&gt;</code> tag is still required in order to allow the user to submit the form. It encloses the two <code class="email">&lt;h:commandButton&gt;</code> tags. When the form is submitted, JSF invokes the <code class="email">removeContact()</code> method in the controller.</p><p class="calibre7">Finally, the page also requires the <code class="email">&lt;f:metadata&gt;</code> stanza that was mentioned earlier in the <span class="strong"><em class="calibre9">Editing data</em></span> section of this chapter in order to fetch the contact details before the page is rendered.</p><p class="calibre7">We have come to the end of our customer's journey with this basic digital-by-default JSF example. We can create, retrieve, update, and delete a contact detail from a database using a web form. It is really so straightforward. We have also taken advantage of the HTML5 framework like Bootstrap, and therefore, we can quickly adapt our application to a responsive web design.</p><p class="calibre7">Here is the screenshot for the <code class="email">deleteContent.xhtml</code> view:</p><div class="mediaobject"><img src="../Images/image00384.jpeg" alt="Removing data" class="calibre10"/><div class="caption"><p class="calibre24">The delete page view for the contact details application</p></div></div><p class="calibre11"> </p><p class="calibre7">Before we<a id="id379" class="calibre1"/> close this chapter, we will have a short interlude on the JSF and CDI scopes.</p></div>
<div class="book" title="JSF and CDI scopes" id="aid-164MG1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec33" class="calibre1"/>JSF and CDI scopes</h1></div></div></div><p class="calibre7">There has been some confusion before Java EE 7 about which annotations are correct to declare the managed<a id="id380" class="calibre1"/> beans. The issues are that the JavaServer Faces specification predates <a id="id381" class="calibre1"/>the later standard from the CDI and the fact that the scoping <a id="id382" class="calibre1"/>overlaps. The history of scopes comes from the original design <a id="id383" class="calibre1"/>and definition of the servlet container and providing convenience to the application developer. A scope is simply a map collection of name/value pairs. It helps to think of them as <code class="email">java.util.Map</code> type hash map collections. The scopes differ in their life span.</p><p class="calibre7">For CDI, the<a id="id384" class="calibre1"/> package <a id="id385" class="calibre1"/>name is <code class="email">javax.enterprise.context</code>, and<a id="id386" class="calibre1"/> for <a id="id387" class="calibre1"/>JSF managed beans, the package is <code class="email">javax.faces.bean</code>.</p><div class="book" title="Bean scopes"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch03lvl2sec34" class="calibre1"/>Bean scopes</h2></div></div></div><p class="calibre7">An <code class="email">@RequestScoped</code> annotation denotes a controller with a lifecycle that has the duration for the Faces request and response. The request-scope is short-lived. It begins when the <a id="id388" class="calibre1"/>web client submits an HTTP request and is then processed by the <a id="id389" class="calibre1"/>servlet container. The scope ends when the response is sent <a id="id390" class="calibre1"/>back to the client.</p><p class="calibre7">The <code class="email">@SessionScoped</code> annotation denotes a lifecycle of many requests and responses. The session scope is designed to get around the stateless protocol of HTTP. The servlet containers enhance the HTTP protocol with the ability to store and retrieve the objects that live longer than one request and response cycle. For this reason, the session scope long-lived. A session scope can expire after a time-out or may become invalid if the service is restarted.</p><p class="calibre7">The <code class="email">@ApplicationScoped</code> annotation denotes a life cycle that exists for as long as the web application is running and available. The application scope, more importantly, is shared across all the requests, sessions, and conversation and custom scopes. This scope begins as soon as the web application starts up. It ends when the web application is shut down.</p><p class="calibre7">The request, session, and application scopes are classic versions of the scope model. JSF and CDI also have additional scopes.</p><p class="calibre7">The <code class="email">@javax.enterprise.context.ConversationScoped</code> annotation denotes a lifecycle that has a duration greater than one or more request and response cycles and yet is shorter than the session scope. CDI defines a scope called a conversation scope. It is a scope between the request and session scopes but also has a contextual association to the beans that it encapsulates. We will discuss the conversation scope in a later chapter.</p><p class="calibre7">JSF 2.0 has defined a scope called <code class="email">@javax.faces.bean.ViewScoped</code> that is similar to the conversation scope because it also has a longer life span than the request scope. The view scope begins when the client submits an HTTP request. It stays around until the user navigates to another page. This makes the <code class="email">@ViewScoped</code> bean a broader and more reasonable choice for the managed bean controller than the <code class="email">@RequestScoped</code> variety. A <code class="email">@ViewScoped</code> annotation is appropriate to manage a one-user story, as we have seen with the CRUD example.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre7">The <code class="email">@ViewScoped</code> annotation is not available for the CDI beans. If you are using a version of JSF before 2.2 and Java EE 7, then this annotation will not work with the <code class="email">@javax.inject.Named</code> annotated beans. You have to use <code class="email">@javax.faces.bean.ManagedBean</code> instead.</p></div><p class="calibre7">In JSF 2.2, there is the <code class="email">@javax.faces.flow.FlowScoped</code> annotation, which is a CDI sanctioned extension. The flow scope is also similar to the conversation scope with a life span that is greater <a id="id391" class="calibre1"/>than the request-scope but shorter than the session scope; however, it<a id="id392" class="calibre1"/> is designed for workflow management operations. The flow<a id="id393" class="calibre1"/> scope allows the developer to create a set of pages with a well-defined entry and an exit point. One can think of this scope as being appropriate to the Wizard data-entry applications.</p><p class="calibre7">Finally, let's learn about the two remaining scopes. There is the POJO annotation, <code class="email">@javax.faces.beanCustomScoped</code>, which allows the managed bean to evaluate the values at the runtime. For a custom scope, the JSF implementation will defer to the implementation, and so, any EL expression may be customized depending on the code-based values. The <code class="email">@javax.faces.bean.NoneScoped</code> annotation is a special scope that implies that a managed bean has no scope at all. JSF will instantiate these types of none scope managed beans every time they are referenced. You might wonder why JSF should sanction such types of beans? A none scope bean might be useful in a security context or in situations where you do not want a bean to maintain a state.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip19" class="calibre1"/>Tip</h3><p class="calibre7">
<span class="strong"><strong class="calibre8">Where are the other HTML tags?</strong></span>
</p><p class="calibre7">There are many <a id="id394" class="calibre1"/>examples of an older version of JSF on the Internet. You might wonder why we have not seen tags such as <code class="email">h:panel</code> and <code class="email">h:panelGrid</code>. These tags are used to lay out the content, especially in JSF 1.<span class="strong"><em class="calibre9">x</em></span>. The default HTML implementation of these tags generates the content with the HTML table elements. The modern digital engineer knows that building sites with the ubiquitous table elements are not recommended. For this reason, I chose not to build my examples with these tags.</p></div></div></div>
<div class="book" title="Summary" id="aid-173721"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec34" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter about JSF forms, we explored the HTML and core JSF custom tags to build the answer to one of the most sought-after questions on the Internet: how on earth do I—as a digital developer—write a CRUD application? It is surprising that this simple idea is considered difficult to program.</p><p class="calibre7">We built a digital JSF form that initially created a contact detail. We saw the Facelet view, the managed bean controller, the stateful session EJB, and the entity. We are modern because we took advantage of the recent HTML5 advances such as the Bootstrap CSS framework. We displayed a list collection of objects with a <code class="email">&lt;h:dataTable&gt;</code> tag, which is a powerful and flexible component. We then added the ability to edit and remove the contact details from the application.</p><p class="calibre7">In the next chapter, we will look at form validation extensively and throw in a mix of an AJAX communication in JSF. We have already—sort of—looked in the territory of validation with <code class="email">&lt;f:validateRequired&gt;</code>, <code class="email">&lt;h:messages&gt;</code>, and <code class="email">&lt;h:message&gt;</code>.</p></div>
<div class="book" title="Exercises" id="aid-181NK1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch03lvl1sec35" class="calibre1"/>Exercises</h1></div></div></div><p class="calibre7">These are the questions for Chapter 3:</p><div class="book"><ol class="orderedlist"><li class="listitem">What are the differences between the HTML5 render kit and core custom tags in JSF?</li><li class="listitem">What are the common attributes that are shared among the JSF custom tags?</li><li class="listitem">The web applications for a business tend to be of two types: data submission and case working. Data submissions simply capture the data and have some limited validation. The other mode provides you with full control to enter new records, amend them, and often delete data. What do you think are the reasons for these two types?</li><li class="listitem">The idiom <span class="strong"><strong class="calibre8">Create Read Update Delete</strong></span> (<span class="strong"><strong class="calibre8">CRUD</strong></span>) is de rigueur for a business facing an e-commerce application. Where have you encountered these applications? Are these applications exclusive to the web? Given a second chance, what can be done to improve the state of art of these applications? How can better digital transformations help these businesses and more importantly, their customers?</li><li class="listitem">Write a simple JSF application that basically uses an HTML form element, <code class="email">&lt;h:form&gt;</code>, with a command button, <code class="email">&lt;h:commandButton&gt;</code>. Your task is to write a registration application for a local Hobby Book Club of avid readers of fiction. Your participants have to register online before they can attend. Start with the backing bean (managed controller). Think of the properties that you need to record. (Your <code class="email">Registration.java</code> POJO will need contact details such as names, age, and e-mail.) At this stage, you do not have to persist any information to a database but it would be helpful if you create a book data record (<code class="email">Book.java</code>), which contains the properties <code class="email">title</code> (String), <code class="email">author</code> (String), <code class="email">genre</code> (String), <code class="email">publisher</code> (String), and <code class="email">publication year</code> (Integer). Write a design specification using the MVC design pattern.</li><li class="listitem">In the first iteration with an imaginary stakeholder, you are required to only write a simple JSF form. Create a backing bean that captures the book title and author. You will need to <code class="email">&lt;h:outputLabel&gt;</code> and <code class="email">&lt;h:inputText&gt;</code>. In the book's source site, you will find an empty project directory with empty JSF placeholder pages and Bootstrap CSS and JavaScript libraries such as jQuery already set up. You can copy and rename this folder to get started quicker.</li><li class="listitem">In order to use Bootstrap CSS in JSF, we can apply almost all of the JSF HTML components to the <code class="email">styleClass</code> attribute. What are the other common attributes?</li><li class="listitem">Take the Hobby Book Club application and add some other components such as a drop-down list: <code class="email">&lt;h:selectManyMenu&gt;</code>. You will need to add properties to the backing bean. (This could be the genre of the book such as crime, science fiction, thriller, or romantic). You will need a POJO to serve as a data record for the registrants (perhaps a class name of <code class="email">Registrant.java</code> will serve us well).</li><li class="listitem">What happens if you find a rare book that defies a genre? How would you model this property bean and which JSF HTML custom tags would you use?</li><li class="listitem">Adapt your hobby application in order to use the other elements of the JSF HTML custom tags such as <code class="email">&lt;h:selectBooleanCheckbox&gt;</code>. You might add a Boolean value to a property to capture the state when somebody in the group has reviewed the book.</li><li class="listitem">What is the difference between <code class="email">&lt;h:selectOneMenu&gt;</code> and <code class="email">&lt;h:selectManyCheckbox&gt;</code>? Explain what the customer will see when confronted with <code class="email">&lt;h:selectOneListbox&gt;</code> and <code class="email">&lt;h:selectManyListbox&gt;</code>?</li><li class="listitem">In a modern digital web design, why should we avoid composing a web user interface with the <code class="email">&lt;h:panelGroup&gt;</code> elements?</li><li class="listitem">To finish the hobby book application, we might allow a registered user to add a comment to their application form. They want to say what their particular specialty is, and it could be anything from futuristic cyberpunk Doctor Who to historical marine warfare around ancient Greece and Rome. What is the difference between <code class="email">&lt;h:inputText&gt;</code> and <code class="email">&lt;h:inputTextArea&gt;</code>? Can you optimize this control with the modern CSS frameworks?</li><li class="listitem">What happens when two customers want to edit the same contact detail record in the web database? How do think the application should behave? What features would you add? How do you think the customer will feel about your ideas?</li></ol><div class="calibre25"/></div></div></body></html>