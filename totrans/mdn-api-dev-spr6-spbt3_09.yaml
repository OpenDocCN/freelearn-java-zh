- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment of Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the fundamentals of containerization,
    Docker, and Kubernetes. You will then use these concepts to containerize a sample
    e-commerce app using Docker. This container will then be deployed aws a Kubernetes
    cluster. You will use Minikube for Kubernetes, which makes learning and Kubernetes-based
    development easier.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will be able to perform containerization
    and container deployment in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the fundamentals of containerization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following to develop and execute the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker (the container engine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes (Minikube)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection to clone the code ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09))
    and download the dependencies and Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insomnia/cURL or any API client for API testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: What is containerization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem that’s encountered frequently by teams while developing large, complex
    systems is that the code that works on one machine doesn’t work on another. The
    main reason behind these kinds of scenarios is a mismatch of dependencies (such
    as different versions of Java, a certain web server, or OS), configurations, or
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Also, setting up a new environment to deploy new products sometimes takes a
    day or more. This is unacceptable in today’s environment and slows down your development
    turnaround. These kinds of issues can be solved by containerizing the application.
  prefs: []
  type: TYPE_NORMAL
- en: In containerization, an application is bundled, configured, and wrapped with
    all the required dependencies and files. This bundle can then be run on any machine
    that supports the containerization process. This bundling ensures that the application
    displays the exact same behavior in all environments. As a result, bugs related
    to misconfigurations or dependencies can be resolved, and the deployment time
    can be reduced to a few minutes or less.
  prefs: []
  type: TYPE_NORMAL
- en: This bundle, which sits on top of a physical machine and its OS, is called a
    container. This container shares the kernel, as well as the libraries and binaries
    of its host OS, in read-only mode. Therefore, the container is lightweight. In
    this chapter, you will use Docker and Kubernetes for containerization and container
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related concept is virtualization – the process of creating a virtual environment
    using the existing hardware system by splitting it into different parts. Each
    part acts as a separate, distinct, individual system. These systems are called
    **virtual machines** (**VMs**). Each VM runs on its own unique OS with its own
    binaries, libraries, and apps. VMs are heavyweight and can be many **gigabytes**
    (**GB**) in size. A hardware system can have VMs with different OSes, such as
    Unix, Linux, and Windows. The following diagram depicts the difference between
    VMs and containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – VMs versus containers](img/Figure_09.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – VMs versus containers
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, people think that virtualization and containerization are the same
    thing, but they are not. VMs are created on top of the host system, which shares
    its hardware with the VMs, whereas containers are executed as isolated processes
    on top of the hardware and its OS. Containers are lightweight and are only a few
    MB, sometimes GB, whereas VMs are heavyweight and many GB in size. Containers
    run faster than VMs, and they are also more portable.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore containers in more detail by building a Docker image in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you know the benefit of containerization and why it is becoming
    popular – you create an application, product, or service, bundle it using containerization,
    and give it to the QA team, customer, or DevOps team to run without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to use Docker as a containerization platform.
    Let’s learn about it before creating a Docker image of a sample e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launched in 2013, Docker is a leading container platform and an open source
    project. Ten thousand developers tried it after its interactive tutorial was launched
    in August 2013\. It was downloaded 2.75 million times by the time of its 1.0 release
    in June 2013\. Many large corporations have signed a partnership agreement with
    Docker Inc., including Microsoft, Red Hat, HP, and OpenStack, as well as service
    providers such as AWS, IBM, and Google.
  prefs: []
  type: TYPE_NORMAL
- en: Docker makes use of Linux kernel features to ensure resource isolation and the
    packaging of an application, along with its dependencies, such as `cgroups` and
    `namespaces`. Everything in a Docker container executes natively on the host and
    uses the host kernel directly. Each container has its own user namespace – a **process
    identifier** (**PID**) for process isolation, a **network** (**NET**) to manage
    network interfaces, **inter-process communication** (**IPC**) to manage access
    to IPC resources, a **mount point** (**MNT**) to manage filesystem mount points,
    and **Unix Time Sharing** (**UTS**) namespaces to isolate kernel and version identifiers.
    This packaging of dependencies enables an application to run as expected across
    different Linux OSes and distributions by supporting a level of portability.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, this portability allows developers to develop an application in
    any language and then easily deploy it from any computer, such as a laptop, to
    different environments, such as test, stage, or production. Docker runs natively
    on Linux. However, you can also run Docker on Windows and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are comprised of just an application and its dependencies, including
    the basic OS. This makes the application lightweight and efficient in terms of
    resource utilization. Developers and system administrators are interested in a
    container’s portability and efficient resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore Docker’s architecture in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker’s architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As specified in its documentation, Docker uses a client-server architecture.
    The Docker client (**Docker**) is basically a **command-line interface** (**CLI**)
    that is used by an end user; clients communicate back and forth with the Docker
    server (read as a Docker daemon). The Docker daemon does the heavy lifting, in
    that it builds, runs, and distributes your Docker containers. The Docker client
    and the daemon can run on the same system or different machines.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client and daemon communicate via sockets or through a RESTful API.
    Docker registers are public or private Docker image repositories that you can
    upload or download images from – for example, Docker Hub ([hub.docker.com](http://hub.docker.com))
    is a public Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary components of Docker are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker image**: A Docker image is a read-only template. For example, an image
    can contain an Ubuntu OS with an Apache web server and your web application installed
    on it. Docker images are the building components of Docker, and images are used
    to create Docker containers. Docker provides a simple way to build new images
    or update existing images. You can also use images created by others and/or extend
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker stats` and `docker events` for container usage statics, such as CPU
    and memory usage, and for activities that are performed by the Docker daemons,
    respectively. These commands help you monitor Docker in a deployed environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You also need to be aware of Docker’s container life cycle, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker` `create` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `run` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `pause` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `unpause` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `start` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `stop` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `restart` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker` `kill` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`docker rm` command. Therefore, this should only be performed for the containers
    in a stopped state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you might be eager to use the Docker container life cycle, but
    first, you’ll need to install Docker by going to [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed Docker, go to [https://docs.docker.com/get-started/#start-the-tutorial](https://docs.docker.com/get-started/#start-the-tutorial)
    to execute the first Docker command. You can refer to [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
    to learn more about Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, you can look at the overview of Docker that is provided
    by Docker ([https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make the necessary code changes so that we can create a Docker image for
    a sample e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: Coding to build an image by adding the Actuator dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I advise you to refer back to [*Chapter 8*](B19349_08.xhtml#_idTextAnchor201),
    *Testing APIs*, as a basis for this chapter’s code. You don’t need any additional
    libraries to create a Docker image. However, you do need to add the Spring Boot
    Actuator dependency, which provides production-ready features for the sample e-commerce
    app we’ll create.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency’s features help you to monitor and manage applications using
    HTTP REST APIs and `/actuator/health` endpoint, which tells us about the application’s
    health status. For the purpose of this exercise, It is sufficient to find out
    the health of the services/applications running inside the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add Actuator by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Actuator dependency to `build.gradle` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SecurityConfig.java (https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java),
    as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, you have added a matcher with Actuator endpoints. This allows all
    Actuator endpoints to be accessed with and without authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can configure the Spring Boot plugin’s task, called `bootBuildImage`,
    to customize the name of the Docker image. We will do this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Spring Boot plugin task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Spring Boot Gradle plugin already provides a command (`bootBuildImage`)
    to build Docker images. It becomes available when the Java plugin is applied in
    the `plugins` section. The `bootBuildImage` task is only available for building
    a `.jar` file and is not available for building a `.``war` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize an image’s name by adding the following code block to the
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, change the IP address and port of the local Docker registry. The configuration
    of the Docker registry is explained in the next section. A Docker image will be
    built based on your project’s name and version. The project version is already
    defined in the `build.gradle` file’s top section. The project name, on the other
    hand, is picked from the `settings.gradle` file ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle)).
    Let’s rename it, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In [*Chapter 8*](B19349_08.xhtml#_idTextAnchor201), *Testing APIs*, the value
    of `rootProject.name` contains a capital letter, so the Docker image build failed.
    This is because the plugin has a validation check for capital letters. Therefore,
    Docker image names should only be in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and customization options, please refer to the plugin documentation
    ([https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have configured the code, you can use this to build an image after
    configuring the Docker registry. You will do this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Docker registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have Docker Desktop installed, by default, when you build an image (`gradlew
    bootBuildImage`), it will be called `docker.io/library/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT`.
    Here, the name refers to `docker.io/library/packt-modern-api-development-chapter09`
    and the version refers to `0.0.1-SNAPSHOT`. You may be wondering why the name
    is prefixed with `docker.io/library`. This is because if you don’t specify the
    Docker registry, it takes the `docker.io` registry by default. You need a Docker
    registry where you can pull and push images from. It is like an artifact repository,
    where you push and pull artifacts such as Spring libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Once the image has been built, you can push it to Docker Hub by applying your
    Docker Hub login credentials. Then, you can fetch the image from Docker Hub for
    deployment in your Kubernetes environment. For development purposes, this is not
    an ideal scenario. The best option is to configure the local Docker registry and
    then use it for Kubernetes deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git Bash on Windows
  prefs: []
  type: TYPE_NORMAL
- en: You can use Git Bash on Windows to run these commands; it emulates Linux commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute the following commands to check whether Docker is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, Docker is installed. Therefore, when you run `docker version`, it displays
    the output. A version output without any error confirms Docker is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can pull and start the Docker registry by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, when you run the Docker registry for the first time, it downloads the
    Docker registry image before running it. The execution of the Docker registry
    creates the container, called `registry`, on port `5000`. If port `5000` is used
    by other services in your machine, then you can use a different port such as `5001`.
    There are two port entries – one internal container port and another exposed external
    port. Both are set to `5000`. The `–restart=always` flag tells Docker to start
    the registry container every time Docker is restarted. The `REGISTRY_STORAGE_DELETE_ENABLED`
    flag, as its name suggests, is used to remove any images from `registry`, as it
    is set to `true`. The default value of this flag is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s check the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the Docker container registry is up and running and was created
    using the `registry:2` image.
  prefs: []
  type: TYPE_NORMAL
- en: The host’s name is necessary when you’re using the containers. Therefore, you’ll
    use the IP number instead of the local hostname for the registry. This is because
    the container will refer to its localhost, rather than the localhost of your system
    when you use `localhost` as the hostname. In a Kubernetes environment, you need
    to provide a registry host, so you will need to use the IP or a proper hostname
    in place of `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find out what IP we can use by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can find your system’s IP address in the row highlighted in the preceding
    output. You can use a similar command on Linux to find out the IP address of your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t yet configured the **Transport Layer Security** (**TLS**) for our
    system host, so this registry is an insecure registry. Docker only supports secure
    registries by default. We must configure Docker so that it can use insecure registries.
    Refer to the Docker documentation to learn how to configure an insecure registry
    ([https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry](https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry)).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an insecure registry to daemon.json
  prefs: []
  type: TYPE_NORMAL
- en: '`daemon.json` can be found in `/etc/docker/daemon.json` on Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. For Docker Desktop on Mac/Windows, navigate to **Docker app** | **Settings**
    | **Docker Engine**.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add the `insecure-registries` entry to the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“``features”: {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“``buildkit”: true`'
  prefs: []
  type: TYPE_NORMAL
- en: '`},`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“``insecure-registries”: [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`“``192.168.1.2:5000”`'
  prefs: []
  type: TYPE_NORMAL
- en: '`],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`…`'
  prefs: []
  type: TYPE_NORMAL
- en: '`…`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Restart Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to build and publish the image successfully, the Docker configuration
    must be performed with a local registry, as explained previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use an insecure registry in any environment other than a local or development
    one for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a Docker image for a sample e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Gradle task to build an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to make a change to the `bootBuildImage` task so that the image’s
    name contains the local Docker registry’s prefix. Spring Boot’s `bootBuildImage`
    uses Paketo Buildpacks to build the Docker image. It supports **long-term support**
    (**LTS**) Java releases and only current non-LTS Java releases. This means, when
    non-LTS Java 20 is released, then it will remove support for Java 19\. Similarly,
    when Java 21 gets released, it will remove the Java 20 support. However, it won’t
    remove Java 17 support because Java 17 is an LTS release. We can make this change
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have customized the name of the Docker image according to the local
    Docker registry. You should change the IP address and port as per your system
    and configuration. You have also used the environment property to set the Paketo
    Buildpacks variables. You have set the JVM version to 17\. It is recommended to
    use Java 17 (or any future LTS release). You can find all the supported Paketo
    Buildpacks environment variables at [https://github.com/paketo-buildpacks/bellsoft-liberica#configuration](https://github.com/paketo-buildpacks/bellsoft-liberica#configuration).
    At the time of writing, Paketo Buildpacks does not provide official support to
    build images for ARM. However, there are alternative builders available such as
    [https://github.com/dashaun/paketo-arm64](https://github.com/dashaun/paketo-arm64),
    which supports building on ARM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can build the image by executing the following commands from your
    project’s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring Boot Gradle plugin uses the *Paketo BellSoft Liberica Buildpack*
    (`docker. io/paketobuildpacks`) to build an application image. First, it pulls
    the image from Docker Hub and then runs its container, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the Spring Boot plugin uses Bellsoft’s JRE 17.0.6 with Linux as a base
    image to build images. It uses finely grained filesystem layers inside the container
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin continues to add the layers and then the labels. Finally, it creates
    the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about Spring Boot, Docker, and Kubernetes and their configuration
    at [https://github.com/dsyer/kubernetes-intro](https://github.com/dsyer/kubernetes-intro).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Docker image has been built, you can use this image to run the
    sample e-commerce app locally using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will run the application on port `8080` inside the container.
    Because it has been exposed on port `8080`, you can access the sample e-commerce
    app on `8080` outside the container too, once the app is up and running. You can
    test the application by running the following command in a separate terminal tab/window
    once the application container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `curl localhost:8080/actuator` command returns the available Actuator endpoints,
    such as `health` and `health-path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also list the containers and their statuses by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s find out the available Docker images by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can tag and push the application image using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can also query the local Docker registry container. First, let’s
    run the following command to find all the published images in the registry (the
    default value is 100):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can find out what all the available tags are for any specific
    image by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For these commands, you can also use `localhost` instead of the IP, if you run
    a local registry container.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll deploy this image to Kubernetes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker containers are run in isolation. You need a platform that can execute
    multiple Docker containers and manage or scale them. Docker Compose does this
    for us. However, this is where Kubernetes helps. It not only manages the container
    but also helps you scale the deployed containers dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: You will use Minikube to run Kubernetes locally. You can use it on Linux, macOS,
    and Windows. It runs a single-node Kubernetes cluster, which is used for learning
    or development purposes. You can install it by referring to the respective guide
    ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Minikube is installed, you need to update Minikube’s local insecure registry
    because, by default, Minikube’s registry uses Docker Hub. Adding an image to Docker
    Hub and then fetching it for local usage is cumbersome for development. You can
    add a local insecure registry to your Minikube environment by adding your host
    IP and local Docker registry port to Minikube’s config at *HostOptions* | *EngineOptions*
    | *InsecureRegistry* in `~/.minikube/machines/minikube/config.json` (note that
    this file is only generated after Minikube has been started once; therefore, start
    Minikube before modifying `config.json`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the insecure registry has been updated, you can start Minikube using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `--insecure-registry` flag while starting Minikube. This
    is important, as it makes the insecure registry work. The Kubernetes cluster uses
    the default namespace by default.
  prefs: []
  type: TYPE_NORMAL
- en: A **namespace** is a Kubernetes special object that allows you to divide the
    Kubernetes cluster resources among users or projects. However, you can’t have
    nested namespaces. Kubernetes resources can only belong to single namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether Kubernetes works or not by executing the following command
    once Minikube is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl` command is a command-line tool that’s used to control a Kubernetes
    cluster, like the `docker` command for Docker. It is a Kubernetes client that
    uses Kubernetes REST APIs to perform various Kubernetes operations, such as deploying
    applications, viewing logs, and inspecting and managing cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `get po` and `get pod` parameters allow you to retrieve pods from your Kubernetes
    cluster. The `-A` flag instructs `kubectl` to retrieve objects from across namespaces.
    Here, you can see that all the pods are from the `kube-system` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: These pods are created by Kubernetes and are part of its internal system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube bundles the Kubernetes dashboard as a UI for additional insight into
    your cluster’s state. You can start it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the dashboard allows you to manage the Kubernetes cluster from the
    UI and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The Kubernetes dashboard](img/Figure_09.2_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The Kubernetes dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses YAML configuration to create objects. For example, you need
    a deployment and service object to deploy and access the sample e-commerce application.
    The deployment will create a pod in the Kubernetes cluster that will run the application
    container, and the service will allow it to access it. You can create these YAML
    files either manually or generate them using `kubectl`. You should typically use
    `kubectl`, which generates the files for you. If you need to, you can modify the
    content of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new directory (`k8s`) in the project’s home directory so that
    we can store the Kubernetes deployment configuration. We can generate the deployment
    Kubernetes configuration file by using the following commands from the newly created
    `k8s` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first command generates the deployment configuration in the `deployment.yaml`
    file using the `create deployment` command. A Kubernetes deployment defines the
    scale at which you want to run your application. You can see that the replica
    is defined as `1`. Therefore, Kubernetes will run a single replica of this deployment.
    Here, you pass the name (`chapter09`) of the deployment, the image name of the
    application to deploy, the `--dry-run=client` flag to preview the object that
    will be sent to the cluster, and the `-o=yaml` flag to generate the YAML output.
  prefs: []
  type: TYPE_NORMAL
- en: The second command appends `---` to the end of the `deployment.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third command creates the service configuration in `deployment.yaml`,
    with a value of `8080` for both internal and external ports.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have used the same file for both deployment and service objects. However,
    you can create two separate files for these – `deployment.yaml` and `service.yaml`.
    In this case, you need to apply these objects separately in your Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the content of the `deployment.yaml` file, which was generated
    by the previous code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can deploy the sample e-commerce application using the file created
    previously in the `deployment.yaml` file, with the following command running from
    the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will deploy a sample e-commerce app ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09))
    in Kubernetes on successful creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can perform the following steps to publish the Docker image
    to Minikube. Start a new terminal and execute the following commands (the same
    terminal window should be used here, since the `eval` commands are only valid
    in an active terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `eval $(minikube docker-env)` to align the Minikube environment with
    your Docker configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `gradle bootBuildImage` to generate an image based on the Minikube environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can start the Minikube logs by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will initiate the application deployment of `chapter09`. You can then either
    use the Kubernetes dashboard or the `kubectl get all` command to check the status
    of your pod and service. **Pods** are Kubernetes’ smallest and most deployable
    objects. They contain one or more containers and represent a single instance of
    a running process in a Kubernetes cluster. A pod’s IP address and other configuration
    details may change because Kubernetes keep track of these, and it may replace
    them if a pod goes down. Therefore, a **Kubernetes service** adds an abstraction
    layer over the pods it exposes the IP addresses of and manages mapping to internal
    pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the following command to find out the status of the pod and service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This returns all the Kubernetes resources in the default namespace. Here, you
    can see that it returns a running pod, a service, a deployment resource, and a
    ReplicaSet for `chapter09`. You need to run this command multiple times until
    you find a successful or erroneous response (such as “`image is` `not pullable`”).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t access the application running inside Kubernetes directly, as you
    can see from the reponse of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You must either use some kind of proxy or SSH tunneling to access the application
    running inside the Kubernetes cluster. Let’s quickly create an SSH tunnel using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The application now runs on port `8080` inside the Kubernete’s cluster. It is
    also mapped to the local machine’s port`8080`. Due to this port mapping, you can
    access the application outside the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try again accessing the application after opening a new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With that, the application has been successfully deployed on our Kubernetes
    cluster. Now, you can use the Postman collection and run all the available `REST`
    endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about containerization and how it is different
    from virtualization. You also learned about the Docker containerization platform
    and how to use the Spring Boot plugin to generate a Docker image for a sample
    e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about the Docker registry and how to configure a local insecure
    registry so that you can use it to push and pull images locally. The same commands
    can be used to push and pull images from a remote Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about Kubernetes and its cluster operations by using Minikube.
    You configured it so that you can pull Docker images from insecure local Docker
    registries.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have the necessary skills to build a Docker image of a Spring Boot
    application and deploy it to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the fundamentals of the gRPC APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between virtualization and containerization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Kubernetes used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `kubectl`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtualization is used to create VMs on top of the host system, which shares
    its hardware with the VMs, whereas containerization creates containers that are
    executed as an isolated process on top of the hardware and its OS. Containers
    are lightweight and need only a few MB (occasionally, GB). VMs are heavyweight
    and need many GB. Containers run faster and are more portable than VMs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestration system and is used to manage application
    containers. It keeps track of running containers. It shuts down containers when
    they are not used and restarts orphaned containers. A Kubernetes cluster is also
    used for scale. It can provision resources such as CPU, memory, and storage automatically
    when required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubectl` is a Kubernetes `kubectl`. You used `kubectl`’s `apply` and `create`
    commands in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes – Fourth* *Edition*: [https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395](https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker documentation: [https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minikube documentation: [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3 – gRPC, Logging, and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn about gRPC-based API development. On the completion
    of this part, you will be able to differentiate between REST and reactive APIs
    with gRPC-based APIs. You will be able to build a server and client using the
    Protobuf schema. Finally, you will be able to facilitate distributed logging and
    tracing, collecting the logs as an Elasticsearch index that will be used for debugging
    and analysis on the Kibana app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19349_10.xhtml#_idTextAnchor233), *Getting Started with gRPC*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19349_11.xhtml#_idTextAnchor250), *gRPC API Development and
    Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19349_12.xhtml#_idTextAnchor272), *Adding Logging and Tracing
    to Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
