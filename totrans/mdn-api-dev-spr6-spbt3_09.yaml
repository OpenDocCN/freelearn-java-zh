- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Deployment of Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务的部署
- en: In this chapter, you will learn about the fundamentals of containerization,
    Docker, and Kubernetes. You will then use these concepts to containerize a sample
    e-commerce app using Docker. This container will then be deployed aws a Kubernetes
    cluster. You will use Minikube for Kubernetes, which makes learning and Kubernetes-based
    development easier.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将了解容器化、Docker和Kubernetes的基础知识。然后，你将使用这些概念使用Docker容器化一个示例电子商务应用程序。然后，这个容器将被部署到Kubernetes集群中。你将使用Minikube进行Kubernetes，这使得学习和基于Kubernetes的开发变得更加容易。
- en: After completing this chapter, you will be able to perform containerization
    and container deployment in a Kubernetes cluster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你将能够在一个Kubernetes集群中执行容器化和容器部署。
- en: 'In this chapter, you’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将探索以下主题：
- en: Exploring the fundamentals of containerization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索容器化的基础知识
- en: Building a Docker image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: Deploying an application in Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中部署应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to develop and execute the code in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下内容来开发和执行本章中的代码：
- en: Docker (the container engine)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker（容器引擎）
- en: Kubernetes (Minikube)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes (Minikube)
- en: An internet connection to clone the code ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09))
    and download the dependencies and Gradle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个互联网连接来克隆代码 ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09))
    并下载依赖项和Gradle
- en: Insomnia/cURL or any API client for API testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失眠/cURL或任何API客户端用于API测试
- en: Let’s begin!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: What is containerization?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器化？
- en: One problem that’s encountered frequently by teams while developing large, complex
    systems is that the code that works on one machine doesn’t work on another. The
    main reason behind these kinds of scenarios is a mismatch of dependencies (such
    as different versions of Java, a certain web server, or OS), configurations, or
    files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型、复杂系统时，团队经常遇到的一个问题是，在一台机器上运行正常的代码在另一台机器上却无法工作。这类情况的主要原因是不匹配的依赖项（如不同版本的Java、特定的Web服务器或操作系统）、配置或文件。
- en: Also, setting up a new environment to deploy new products sometimes takes a
    day or more. This is unacceptable in today’s environment and slows down your development
    turnaround. These kinds of issues can be solved by containerizing the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，设置新的环境以部署新产品有时需要一天或更长时间。在当今的环境下这是不可接受的，并且会减慢你的开发周期。这些问题可以通过容器化应用程序来解决。
- en: In containerization, an application is bundled, configured, and wrapped with
    all the required dependencies and files. This bundle can then be run on any machine
    that supports the containerization process. This bundling ensures that the application
    displays the exact same behavior in all environments. As a result, bugs related
    to misconfigurations or dependencies can be resolved, and the deployment time
    can be reduced to a few minutes or less.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化中，应用程序被捆绑、配置，并包装了所有必需的依赖项和文件。这个捆绑包可以在支持容器化过程的任何机器上运行。这种捆绑确保了应用程序在所有环境中表现出完全相同的行为。因此，与配置或依赖项相关的错误可以得到解决，部署时间可以缩短到几分钟或更少。
- en: This bundle, which sits on top of a physical machine and its OS, is called a
    container. This container shares the kernel, as well as the libraries and binaries
    of its host OS, in read-only mode. Therefore, the container is lightweight. In
    this chapter, you will use Docker and Kubernetes for containerization and container
    deployment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个位于物理机器及其操作系统之上的捆绑包被称为容器。这个容器以只读模式共享宿主机的内核以及其宿主操作系统的库和二进制文件。因此，容器是轻量级的。在这一章中，你将使用Docker和Kubernetes进行容器化和容器部署。
- en: 'A related concept is virtualization – the process of creating a virtual environment
    using the existing hardware system by splitting it into different parts. Each
    part acts as a separate, distinct, individual system. These systems are called
    **virtual machines** (**VMs**). Each VM runs on its own unique OS with its own
    binaries, libraries, and apps. VMs are heavyweight and can be many **gigabytes**
    (**GB**) in size. A hardware system can have VMs with different OSes, such as
    Unix, Linux, and Windows. The following diagram depicts the difference between
    VMs and containers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的概念是虚拟化——通过将现有硬件系统分割成不同的部分来创建虚拟环境的过程。每个部分都作为一个独立的、独特的、个体系统运行。这些系统被称为**虚拟机**（**VM**）。每个虚拟机都运行在其自己的独特操作系统上，拥有自己的二进制文件、库和应用程序。虚拟机是重量级的，大小可达多个**千兆字节**（**GB**）。一个硬件系统可以拥有运行不同操作系统（如Unix、Linux和Windows）的虚拟机。以下图表描述了虚拟机和容器之间的区别：
- en: '![Figure 9.1 – VMs versus containers](img/Figure_09.1_B19349.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 虚拟机与容器](img/Figure_09.1_B19349.jpg)'
- en: Figure 9.1 – VMs versus containers
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 虚拟机与容器
- en: Sometimes, people think that virtualization and containerization are the same
    thing, but they are not. VMs are created on top of the host system, which shares
    its hardware with the VMs, whereas containers are executed as isolated processes
    on top of the hardware and its OS. Containers are lightweight and are only a few
    MB, sometimes GB, whereas VMs are heavyweight and many GB in size. Containers
    run faster than VMs, and they are also more portable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们认为虚拟化和容器化是同一件事，但实际上并非如此。虚拟机是在宿主系统之上创建的，它与虚拟机共享硬件，而容器是在硬件及其操作系统之上作为隔离进程执行的。容器轻量级，大小只有几MB，有时是GB，而虚拟机则是重量级的，大小可达多个GB。容器比虚拟机运行得更快，而且它们也更加便携。
- en: We’ll explore containers in more detail by building a Docker image in the next
    section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一节中，我们将通过构建Docker镜像来更详细地探讨容器。 '
- en: Building a Docker image
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: At this point, you know the benefit of containerization and why it is becoming
    popular – you create an application, product, or service, bundle it using containerization,
    and give it to the QA team, customer, or DevOps team to run without any issues.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道了容器化的好处以及为什么它越来越受欢迎——你创建一个应用程序、产品或服务，使用容器化将其打包，然后交给QA团队、客户或DevOps团队运行，而不会出现任何问题。
- en: In this section, you’ll learn how to use Docker as a containerization platform.
    Let’s learn about it before creating a Docker image of a sample e-commerce app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将Docker用作容器化平台。在创建示例电子商务应用程序的Docker镜像之前，让我们先了解一下它。
- en: What is Docker?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker是什么？
- en: Launched in 2013, Docker is a leading container platform and an open source
    project. Ten thousand developers tried it after its interactive tutorial was launched
    in August 2013\. It was downloaded 2.75 million times by the time of its 1.0 release
    in June 2013\. Many large corporations have signed a partnership agreement with
    Docker Inc., including Microsoft, Red Hat, HP, and OpenStack, as well as service
    providers such as AWS, IBM, and Google.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker于2013年推出，是领先的容器平台和开源项目。2013年8月推出交互式教程后，有1万名开发者尝试了它。到2013年6月1.0版本发布时，它已被下载了275万次。许多大型公司与Docker
    Inc.签订了合作协议，包括微软、红帽、惠普和OpenStack，以及服务提供商如AWS、IBM和谷歌。
- en: Docker makes use of Linux kernel features to ensure resource isolation and the
    packaging of an application, along with its dependencies, such as `cgroups` and
    `namespaces`. Everything in a Docker container executes natively on the host and
    uses the host kernel directly. Each container has its own user namespace – a **process
    identifier** (**PID**) for process isolation, a **network** (**NET**) to manage
    network interfaces, **inter-process communication** (**IPC**) to manage access
    to IPC resources, a **mount point** (**MNT**) to manage filesystem mount points,
    and **Unix Time Sharing** (**UTS**) namespaces to isolate kernel and version identifiers.
    This packaging of dependencies enables an application to run as expected across
    different Linux OSes and distributions by supporting a level of portability.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker利用Linux内核特性来确保资源隔离和应用程序及其依赖项（如`cgroups`和`namespaces`）的打包。Docker容器中的所有内容都在宿主机上原生执行，并直接使用宿主机内核。每个容器都有自己的用户命名空间——一个用于进程隔离的**进程标识符**（**PID**），一个用于管理网络接口的**网络**（**NET**），用于管理对IPC资源访问的**进程间通信**（**IPC**），用于管理文件系统挂载点的**挂载点**（**MNT**），以及用于隔离内核和版本标识符的**Unix时间共享**（**UTS**）命名空间。这种依赖项的打包使得应用程序能够在不同的Linux操作系统和发行版上按预期运行，从而支持一定程度的可移植性。
- en: Furthermore, this portability allows developers to develop an application in
    any language and then easily deploy it from any computer, such as a laptop, to
    different environments, such as test, stage, or production. Docker runs natively
    on Linux. However, you can also run Docker on Windows and macOS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种可移植性允许开发人员在任何语言中开发应用程序，然后轻松地从任何计算机（如笔记本电脑）部署到不同的环境，如测试、预发布或生产。Docker在Linux上原生运行。然而，你还可以在Windows和macOS上运行Docker。
- en: Containers are comprised of just an application and its dependencies, including
    the basic OS. This makes the application lightweight and efficient in terms of
    resource utilization. Developers and system administrators are interested in a
    container’s portability and efficient resource utilization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 容器仅由一个应用程序及其依赖项组成，包括基本的操作系统。这使得应用程序在资源利用方面轻量级且高效。开发人员和系统管理员对容器的可移植性和高效资源利用感兴趣。
- en: We’ll explore Docker’s architecture in the next subsection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中探讨Docker的架构。
- en: Understanding Docker’s architecture
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Docker的架构
- en: As specified in its documentation, Docker uses a client-server architecture.
    The Docker client (**Docker**) is basically a **command-line interface** (**CLI**)
    that is used by an end user; clients communicate back and forth with the Docker
    server (read as a Docker daemon). The Docker daemon does the heavy lifting, in
    that it builds, runs, and distributes your Docker containers. The Docker client
    and the daemon can run on the same system or different machines.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如其文档所述，Docker使用客户端-服务器架构。Docker客户端（**Docker**）基本上是一个**命令行界面**（**CLI**），由最终用户使用；客户端与Docker服务器（读作Docker守护进程）进行双向通信。Docker守护进程承担了繁重的工作，即构建、运行和分发你的Docker容器。Docker客户端和守护进程可以运行在同一系统上或不同的机器上。
- en: The Docker client and daemon communicate via sockets or through a RESTful API.
    Docker registers are public or private Docker image repositories that you can
    upload or download images from – for example, Docker Hub ([hub.docker.com](http://hub.docker.com))
    is a public Docker registry.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端和守护进程通过套接字或通过RESTful API进行通信。Docker注册是公共或私有Docker镜像仓库，你可以从中上传或下载镜像——例如，Docker
    Hub ([hub.docker.com](http://hub.docker.com)) 是一个公共Docker注册库。
- en: 'The primary components of Docker are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的主要组件如下：
- en: '**Docker image**: A Docker image is a read-only template. For example, an image
    can contain an Ubuntu OS with an Apache web server and your web application installed
    on it. Docker images are the building components of Docker, and images are used
    to create Docker containers. Docker provides a simple way to build new images
    or update existing images. You can also use images created by others and/or extend
    them.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像是一个只读模板。例如，一个镜像可以包含安装有Apache网络服务器和你的Web应用程序的Ubuntu操作系统。Docker镜像是Docker的构建组件，镜像用于创建Docker容器。Docker提供了一种简单的方法来构建新镜像或更新现有镜像。你也可以使用其他人创建的镜像，或者扩展它们。'
- en: '`docker stats` and `docker events` for container usage statics, such as CPU
    and memory usage, and for activities that are performed by the Docker daemons,
    respectively. These commands help you monitor Docker in a deployed environment.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stats` 和 `docker events` 用于容器使用统计，如CPU和内存使用，以及Docker守护进程执行的活动。这些命令有助于你在部署环境中监控Docker。'
- en: Docker container life cycle
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker容器生命周期
- en: 'You also need to be aware of Docker’s container life cycle, which is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解Docker的容器生命周期，如下所示：
- en: '`docker` `create` command.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `create` 命令。'
- en: '`docker` `run` command.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `run` 命令。'
- en: '`docker` `pause` command.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `pause` 命令。'
- en: '`docker` `unpause` command.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `unpause` 命令。'
- en: '`docker` `start` command.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `start` 命令。'
- en: '`docker` `stop` command.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `stop` 命令。'
- en: '`docker` `restart` command.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `restart` 命令。'
- en: '`docker` `kill` command.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker` `kill` 命令。'
- en: '`docker rm` command. Therefore, this should only be performed for the containers
    in a stopped state.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker rm` 命令。因此，这仅应针对已停止状态的容器执行。'
- en: At this point, you might be eager to use the Docker container life cycle, but
    first, you’ll need to install Docker by going to [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能急于使用Docker容器生命周期，但首先，你需要通过访问[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)来安装Docker。
- en: Once you’ve installed Docker, go to [https://docs.docker.com/get-started/#start-the-tutorial](https://docs.docker.com/get-started/#start-the-tutorial)
    to execute the first Docker command. You can refer to [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)
    to learn more about Docker commands.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了Docker，请转到[https://docs.docker.com/get-started/#start-the-tutorial](https://docs.docker.com/get-started/#start-the-tutorial)以执行第一个Docker命令。您可以参考[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)来了解更多关于Docker命令的信息。
- en: For more information, you can look at the overview of Docker that is provided
    by Docker ([https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以查看Docker提供的Docker概述（[https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/))。
- en: Let’s make the necessary code changes so that we can create a Docker image for
    a sample e-commerce app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行必要的代码更改，以便我们可以为示例电子商务应用程序创建一个Docker镜像。
- en: Coding to build an image by adding the Actuator dependency
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过添加Actuator依赖项来构建镜像的编码
- en: I advise you to refer back to [*Chapter 8*](B19349_08.xhtml#_idTextAnchor201),
    *Testing APIs*, as a basis for this chapter’s code. You don’t need any additional
    libraries to create a Docker image. However, you do need to add the Spring Boot
    Actuator dependency, which provides production-ready features for the sample e-commerce
    app we’ll create.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您参考[*第8章*](B19349_08.xhtml#_idTextAnchor201)，*测试API*，作为本章代码的基础。您不需要任何额外的库来创建Docker镜像。然而，您确实需要添加Spring
    Boot Actuator依赖项，它为我们将要创建的示例电子商务应用程序提供生产就绪功能。
- en: The dependency’s features help you to monitor and manage applications using
    HTTP REST APIs and `/actuator/health` endpoint, which tells us about the application’s
    health status. For the purpose of this exercise, It is sufficient to find out
    the health of the services/applications running inside the Docker container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的功能可以帮助您使用HTTP REST API和`/actuator/health`端点来监控和管理应用程序，该端点告诉我们应用程序的健康状态。为了本练习的目的，仅找出运行在Docker容器内的服务/应用程序的健康状况就足够了。
- en: 'You can add Actuator by performing the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤添加Actuator：
- en: 'Add the Actuator dependency to `build.gradle` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle)):'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Actuator依赖项添加到`build.gradle`（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/build.gradle)）：
- en: '[PRE0]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'SecurityConfig.java (https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java),
    as shown here:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SecurityConfig.java（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/src/main/java/com/packt/modern/api/security/SecurityConfig.java)），如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With that, you have added a matcher with Actuator endpoints. This allows all
    Actuator endpoints to be accessed with and without authentication and authorization.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您已经添加了一个带有Actuator端点的匹配器。这允许所有Actuator端点都可以带或不带身份验证和授权进行访问。
- en: Now, you can configure the Spring Boot plugin’s task, called `bootBuildImage`,
    to customize the name of the Docker image. We will do this in the next subsection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以为名为`bootBuildImage`的Spring Boot插件任务配置，以自定义Docker镜像的名称。我们将在下一小节中这样做。
- en: Configuring the Spring Boot plugin task
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Spring Boot插件任务
- en: The Spring Boot Gradle plugin already provides a command (`bootBuildImage`)
    to build Docker images. It becomes available when the Java plugin is applied in
    the `plugins` section. The `bootBuildImage` task is only available for building
    a `.jar` file and is not available for building a `.``war` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Gradle插件已经提供了一个命令（`bootBuildImage`）来构建Docker镜像。当在`plugins`部分应用Java插件时，它就可用。`bootBuildImage`任务仅适用于构建`.jar`文件，不适用于构建`.war`文件。
- en: 'You can customize an image’s name by adding the following code block to the
    `build.gradle` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`build.gradle`文件中添加以下代码块来自定义镜像的名称：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, change the IP address and port of the local Docker registry. The configuration
    of the Docker registry is explained in the next section. A Docker image will be
    built based on your project’s name and version. The project version is already
    defined in the `build.gradle` file’s top section. The project name, on the other
    hand, is picked from the `settings.gradle` file ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle)).
    Let’s rename it, as shown in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，更改本地 Docker 仓库的 IP 地址和端口号。Docker 仓库的配置将在下一节中解释。将基于您的项目名称和版本构建 Docker 镜像。项目版本已在
    `build.gradle` 文件的顶部定义。另一方面，项目名称是从 `settings.gradle` 文件中选择的 ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/settings.gradle))。让我们将其重命名，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [*Chapter 8*](B19349_08.xhtml#_idTextAnchor201), *Testing APIs*, the value
    of `rootProject.name` contains a capital letter, so the Docker image build failed.
    This is because the plugin has a validation check for capital letters. Therefore,
    Docker image names should only be in lowercase.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B19349_08.xhtml#_idTextAnchor201) 中，*测试 API*，`rootProject.name`
    的值包含一个字母大写，因此 Docker 镜像构建失败。这是因为插件有一个针对大写字母的验证检查。因此，Docker 镜像名称应仅使用小写字母。
- en: For more information and customization options, please refer to the plugin documentation
    ([https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和自定义选项，请参阅插件文档 ([https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image](https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image))。
- en: Now that you have configured the code, you can use this to build an image after
    configuring the Docker registry. You will do this in the next subsection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经配置了代码，您可以在配置 Docker 仓库后使用它来构建镜像。您将在下一小节中这样做。
- en: Configuring the Docker registry
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Docker 仓库
- en: If you have Docker Desktop installed, by default, when you build an image (`gradlew
    bootBuildImage`), it will be called `docker.io/library/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT`.
    Here, the name refers to `docker.io/library/packt-modern-api-development-chapter09`
    and the version refers to `0.0.1-SNAPSHOT`. You may be wondering why the name
    is prefixed with `docker.io/library`. This is because if you don’t specify the
    Docker registry, it takes the `docker.io` registry by default. You need a Docker
    registry where you can pull and push images from. It is like an artifact repository,
    where you push and pull artifacts such as Spring libraries.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装 Docker Desktop，默认情况下，当您构建镜像（`gradlew bootBuildImage`）时，它将被命名为 `docker.io/library/packt-modern-api-development-chapter09:0.0.1-SNAPSHOT`。在这里，名称指的是
    `docker.io/library/packt-modern-api-development-chapter09`，版本指的是 `0.0.1-SNAPSHOT`。您可能想知道为什么名称前面有
    `docker.io/library` 前缀。这是因为如果您没有指定 Docker 仓库，它将默认使用 `docker.io` 仓库。您需要一个可以从中拉取和推送镜像的
    Docker 仓库。它就像一个工件仓库，您可以在其中推送和拉取工件，例如 Spring 库。
- en: Once the image has been built, you can push it to Docker Hub by applying your
    Docker Hub login credentials. Then, you can fetch the image from Docker Hub for
    deployment in your Kubernetes environment. For development purposes, this is not
    an ideal scenario. The best option is to configure the local Docker registry and
    then use it for Kubernetes deployment.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了镜像，您可以通过应用您的 Docker Hub 登录凭证将其推送到 Docker Hub。然后，您可以从 Docker Hub 获取镜像以部署到您的
    Kubernetes 环境。出于开发目的，这并不是一个理想的情况。最佳选项是配置本地 Docker 仓库，然后将其用于 Kubernetes 部署。
- en: Using Git Bash on Windows
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git Bash 在 Windows 上
- en: You can use Git Bash on Windows to run these commands; it emulates Linux commands.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Windows 上使用 Git Bash 运行这些命令；它模拟 Linux 命令。
- en: 'Let’s execute the following commands to check whether Docker is up and running:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下命令来检查 Docker 是否正在运行：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, Docker is installed. Therefore, when you run `docker version`, it displays
    the output. A version output without any error confirms Docker is up and running.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已安装 Docker。因此，当您运行 `docker version` 时，它会显示输出。没有错误输出的版本输出确认 Docker 正在运行。
- en: 'Now, you can pull and start the Docker registry by using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令拉取并启动 Docker 仓库：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, when you run the Docker registry for the first time, it downloads the
    Docker registry image before running it. The execution of the Docker registry
    creates the container, called `registry`, on port `5000`. If port `5000` is used
    by other services in your machine, then you can use a different port such as `5001`.
    There are two port entries – one internal container port and another exposed external
    port. Both are set to `5000`. The `–restart=always` flag tells Docker to start
    the registry container every time Docker is restarted. The `REGISTRY_STORAGE_DELETE_ENABLED`
    flag, as its name suggests, is used to remove any images from `registry`, as it
    is set to `true`. The default value of this flag is `false`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当您第一次运行 Docker 仓库时，它会先下载 Docker 仓库镜像然后再运行。Docker 仓库的执行会在端口 `5000` 上创建一个名为
    `registry` 的容器。如果端口 `5000` 被您的机器上的其他服务使用，那么您可以使用不同的端口，例如 `5001`。有两个端口条目——一个是内部容器端口，另一个是公开的外部端口。两者都设置为
    `5000`。`–restart=always` 标志告诉 Docker 每次重启 Docker 时都启动仓库容器。`REGISTRY_STORAGE_DELETE_ENABLED`
    标志，正如其名称所暗示的，用于从 `registry` 中删除任何镜像，因为它被设置为 `true`。此标志的默认值是 `false`。
- en: 'Now, let’s check the containers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查容器：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This shows that the Docker container registry is up and running and was created
    using the `registry:2` image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 Docker 容器仓库正在运行，并且是使用 `registry:2` 镜像创建的。
- en: The host’s name is necessary when you’re using the containers. Therefore, you’ll
    use the IP number instead of the local hostname for the registry. This is because
    the container will refer to its localhost, rather than the localhost of your system
    when you use `localhost` as the hostname. In a Kubernetes environment, you need
    to provide a registry host, so you will need to use the IP or a proper hostname
    in place of `localhost`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用容器时，主机名是必要的。因此，您将使用 IP 地址而不是本地主机名来指定仓库。这是因为当您使用 `localhost` 作为主机名时，容器将引用其自身的
    localhost，而不是您系统的 localhost。在 Kubernetes 环境中，您需要提供一个仓库主机，因此您需要使用 IP 或适当的域名来代替
    `localhost`。
- en: 'Let’s find out what IP we can use by running the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来找出我们可以使用的 IP：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can find your system’s IP address in the row highlighted in the preceding
    output. You can use a similar command on Linux to find out the IP address of your
    system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的输出中高亮显示的行中找到您系统的 IP 地址。您可以在 Linux 上使用类似的命令来查找您系统的 IP 地址。
- en: We haven’t yet configured the **Transport Layer Security** (**TLS**) for our
    system host, so this registry is an insecure registry. Docker only supports secure
    registries by default. We must configure Docker so that it can use insecure registries.
    Refer to the Docker documentation to learn how to configure an insecure registry
    ([https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry](https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未为系统主机配置**传输层安全性**（**TLS**），因此这个仓库是不安全的。Docker 默认只支持安全的仓库。我们必须配置 Docker 以使其能够使用不安全的仓库。请参考
    Docker 文档了解如何配置不安全的仓库（[https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry](https://docs.docker.com/registry/insecure/-deploy-a-plain-http-registry)）。
- en: Adding an insecure registry to daemon.json
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 daemon.json 中添加不安全的仓库
- en: '`daemon.json` can be found in `/etc/docker/daemon.json` on Linux.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`daemon.json` 在 Linux 上位于 `/etc/docker/daemon.json`。'
- en: 1\. For Docker Desktop on Mac/Windows, navigate to **Docker app** | **Settings**
    | **Docker Engine**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 对于 Mac/Windows 上的 Docker Desktop，导航到 **Docker 应用** | **设置** | **Docker 引擎**。
- en: '2\. Add the `insecure-registries` entry to the JSON:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将 `insecure-registries` 条目添加到 JSON 中：
- en: '`{`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`“``features”: {`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`“``features”: {`'
- en: '`“``buildkit”: true`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`“``buildkit”: true`'
- en: '`},`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`},`'
- en: '`“``insecure-registries”: [`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`“``insecure-registries”: [`'
- en: '`“``192.168.1.2:5000”`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`“``192.168.1.2:5000”`'
- en: '`],`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`],`'
- en: '`…`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`'
- en: '`…`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`…`'
- en: '`}`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 3\. Restart Docker.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 重启 Docker。
- en: Note that to build and publish the image successfully, the Docker configuration
    must be performed with a local registry, as explained previously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了成功构建和发布镜像，Docker 配置必须使用本地仓库进行，如前所述。
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t use an insecure registry in any environment other than a local or development
    one for security purposes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，不要在任何非本地或开发环境中使用不安全的仓库。
- en: Now, let’s create a Docker image for a sample e-commerce app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为示例电子商务应用创建一个 Docker 镜像。
- en: Executing a Gradle task to build an image
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Gradle 任务来构建镜像
- en: 'You need to make a change to the `bootBuildImage` task so that the image’s
    name contains the local Docker registry’s prefix. Spring Boot’s `bootBuildImage`
    uses Paketo Buildpacks to build the Docker image. It supports **long-term support**
    (**LTS**) Java releases and only current non-LTS Java releases. This means, when
    non-LTS Java 20 is released, then it will remove support for Java 19\. Similarly,
    when Java 21 gets released, it will remove the Java 20 support. However, it won’t
    remove Java 17 support because Java 17 is an LTS release. We can make this change
    like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要修改`bootBuildImage`任务，以便镜像的名称包含本地Docker仓库的前缀。Spring Boot的`bootBuildImage`使用Paketo
    Buildpacks构建Docker镜像。它支持**长期支持**（**LTS**）Java版本和仅当前的非LTS Java版本。这意味着，当非LTS Java
    20发布时，它将移除对Java 19的支持。同样，当Java 21发布时，它将移除对Java 20的支持。但是，它不会移除对Java 17的支持，因为Java
    17是一个LTS版本。我们可以这样进行更改：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you have customized the name of the Docker image according to the local
    Docker registry. You should change the IP address and port as per your system
    and configuration. You have also used the environment property to set the Paketo
    Buildpacks variables. You have set the JVM version to 17\. It is recommended to
    use Java 17 (or any future LTS release). You can find all the supported Paketo
    Buildpacks environment variables at [https://github.com/paketo-buildpacks/bellsoft-liberica#configuration](https://github.com/paketo-buildpacks/bellsoft-liberica#configuration).
    At the time of writing, Paketo Buildpacks does not provide official support to
    build images for ARM. However, there are alternative builders available such as
    [https://github.com/dashaun/paketo-arm64](https://github.com/dashaun/paketo-arm64),
    which supports building on ARM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您根据本地Docker仓库已自定义Docker镜像的名称。您应根据您的系统和配置更改IP地址和端口。您还使用了环境属性来设置Paketo Buildpacks变量。您已将JVM版本设置为17。建议使用Java
    17（或任何未来的LTS版本）。您可以在[https://github.com/paketo-buildpacks/bellsoft-liberica#configuration](https://github.com/paketo-buildpacks/bellsoft-liberica#configuration)找到所有受支持的Paketo
    Buildpacks环境变量。在撰写本文时，Paketo Buildpacks不提供官方支持为ARM构建镜像。然而，有可用的替代构建器，如[https://github.com/dashaun/paketo-arm64](https://github.com/dashaun/paketo-arm64)，它支持在ARM上构建。
- en: 'Now, you can build the image by executing the following commands from your
    project’s home directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从项目的根目录执行以下命令来构建镜像：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Spring Boot Gradle plugin uses the *Paketo BellSoft Liberica Buildpack*
    (`docker. io/paketobuildpacks`) to build an application image. First, it pulls
    the image from Docker Hub and then runs its container, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Gradle插件使用*Paketo BellSoft Liberica Buildpack*（`docker.io/paketobuildpacks`）来构建应用程序镜像。首先，它从Docker
    Hub拉取镜像，然后运行其容器，如下所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, the Spring Boot plugin uses Bellsoft’s JRE 17.0.6 with Linux as a base
    image to build images. It uses finely grained filesystem layers inside the container
    to do so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Spring Boot插件使用Bellsoft的JRE 17.0.6和Linux作为基础镜像来构建镜像。它使用容器内部的细粒度文件系统层来完成此操作：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The plugin continues to add the layers and then the labels. Finally, it creates
    the Docker image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 插件继续添加层和标签，最后创建Docker镜像：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can learn more about Spring Boot, Docker, and Kubernetes and their configuration
    at [https://github.com/dsyer/kubernetes-intro](https://github.com/dsyer/kubernetes-intro).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/dsyer/kubernetes-intro](https://github.com/dsyer/kubernetes-intro)了解更多关于Spring
    Boot、Docker和Kubernetes及其配置的信息。
- en: 'Now that the Docker image has been built, you can use this image to run the
    sample e-commerce app locally using the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Docker镜像已经构建完成，您可以使用以下命令使用此镜像在本地运行示例电子商务应用：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command will run the application on port `8080` inside the container.
    Because it has been exposed on port `8080`, you can access the sample e-commerce
    app on `8080` outside the container too, once the app is up and running. You can
    test the application by running the following command in a separate terminal tab/window
    once the application container is up and running:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在容器内部运行端口`8080`上的应用程序。因为它已经在端口`8080`上暴露，所以一旦应用程序启动并运行，您也可以在容器外部通过`8080`访问示例电子商务应用。您可以在应用程序容器启动并运行后，在另一个终端标签页/窗口中运行以下命令来测试应用程序：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `curl localhost:8080/actuator` command returns the available Actuator endpoints,
    such as `health` and `health-path`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl localhost:8080/actuator`命令返回可用的Actuator端点，例如`health`和`health-path`。'
- en: 'You can also list the containers and their statuses by using the following
    command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令列出容器及其状态：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let’s find out the available Docker images by running the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行以下命令来查找可用的Docker镜像：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, you can tag and push the application image using the following commands:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令标记并推送应用程序镜像：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, you can also query the local Docker registry container. First, let’s
    run the following command to find all the published images in the registry (the
    default value is 100):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以查询本地 Docker 注册表容器。首先，让我们运行以下命令以找到注册表中所有已发布的镜像（默认值为 100）：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, you can find out what all the available tags are for any specific
    image by using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用以下命令找出任何特定镜像的所有可用标签：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For these commands, you can also use `localhost` instead of the IP, if you run
    a local registry container.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些命令，如果您运行的是本地注册表容器，您也可以使用 `localhost` 而不是 IP。
- en: We’ll deploy this image to Kubernetes in the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将部署此镜像到 Kubernetes。
- en: Deploying an application in Kubernetes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署应用程序
- en: Docker containers are run in isolation. You need a platform that can execute
    multiple Docker containers and manage or scale them. Docker Compose does this
    for us. However, this is where Kubernetes helps. It not only manages the container
    but also helps you scale the deployed containers dynamically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器在隔离状态下运行。您需要一个可以执行多个 Docker 容器并管理或扩展它们的平台。Docker Compose 为我们做了这件事。然而，这正是
    Kubernetes 发挥作用的地方。它不仅管理容器，还帮助您动态地扩展已部署的容器。
- en: You will use Minikube to run Kubernetes locally. You can use it on Linux, macOS,
    and Windows. It runs a single-node Kubernetes cluster, which is used for learning
    or development purposes. You can install it by referring to the respective guide
    ([https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 Minikube 在本地运行 Kubernetes。您可以在 Linux、macOS 和 Windows 上使用它。它运行一个单节点 Kubernetes
    集群，用于学习和开发目的。您可以通过参考相应的指南（[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)）来安装它。
- en: 'Once Minikube is installed, you need to update Minikube’s local insecure registry
    because, by default, Minikube’s registry uses Docker Hub. Adding an image to Docker
    Hub and then fetching it for local usage is cumbersome for development. You can
    add a local insecure registry to your Minikube environment by adding your host
    IP and local Docker registry port to Minikube’s config at *HostOptions* | *EngineOptions*
    | *InsecureRegistry* in `~/.minikube/machines/minikube/config.json` (note that
    this file is only generated after Minikube has been started once; therefore, start
    Minikube before modifying `config.json`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Minikube 安装完毕，您需要更新 Minikube 的本地不安全注册表，因为默认情况下，Minikube 的注册表使用 Docker Hub。将镜像添加到
    Docker Hub 然后为本地使用获取它是开发中的繁琐工作。您可以通过将您的宿主 IP 和本地 Docker 注册表端口添加到 Minikube 的配置文件
    `~/.minikube/machines/minikube/config.json` 中的 *HostOptions* | *EngineOptions*
    | *InsecureRegistry* 来将本地不安全注册表添加到您的 Minikube 环境中（请注意，此文件仅在 Minikube 启动一次后生成；因此，在修改
    `config.json` 之前启动 Minikube）：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the insecure registry has been updated, you can start Minikube using the
    following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦不安全的注册表已更新，您可以使用以下命令启动 Minikube：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have used the `--insecure-registry` flag while starting Minikube. This
    is important, as it makes the insecure registry work. The Kubernetes cluster uses
    the default namespace by default.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在启动 Minikube 时使用了 `--insecure-registry` 标志。这是很重要的，因为它使不安全注册表工作。Kubernetes
    集群默认使用默认命名空间。
- en: A **namespace** is a Kubernetes special object that allows you to divide the
    Kubernetes cluster resources among users or projects. However, you can’t have
    nested namespaces. Kubernetes resources can only belong to single namespaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间** 是 Kubernetes 特殊对象，允许您将 Kubernetes 集群资源在用户或项目之间划分。然而，您不能有嵌套的命名空间。Kubernetes
    资源只能属于单个命名空间。'
- en: 'You can check whether Kubernetes works or not by executing the following command
    once Minikube is up and running:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Minikube 启动并运行，您可以通过执行以下命令来检查 Kubernetes 是否工作：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `kubectl` command is a command-line tool that’s used to control a Kubernetes
    cluster, like the `docker` command for Docker. It is a Kubernetes client that
    uses Kubernetes REST APIs to perform various Kubernetes operations, such as deploying
    applications, viewing logs, and inspecting and managing cluster resources.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令是一个用于控制 Kubernetes 集群的命令行工具，类似于 Docker 的 `docker` 命令。它是一个 Kubernetes
    客户端，使用 Kubernetes REST API 执行各种 Kubernetes 操作，例如部署应用程序、查看日志以及检查和管理集群资源。'
- en: The `get po` and `get pod` parameters allow you to retrieve pods from your Kubernetes
    cluster. The `-A` flag instructs `kubectl` to retrieve objects from across namespaces.
    Here, you can see that all the pods are from the `kube-system` namespace.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`get po`和`get pod`参数允许您从您的Kubernetes集群中检索Pod。`-A`标志指示`kubectl`从所有命名空间检索对象。在这里，您可以看到所有Pod都来自`kube-system`命名空间。'
- en: These pods are created by Kubernetes and are part of its internal system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Pod是由Kubernetes创建的，是它内部系统的一部分。
- en: 'Minikube bundles the Kubernetes dashboard as a UI for additional insight into
    your cluster’s state. You can start it by using the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube将Kubernetes仪表板捆绑为UI，以便对集群的状态有更深入的洞察。您可以通过以下命令启动它：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the dashboard allows you to manage the Kubernetes cluster from the
    UI and looks as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行仪表板允许您通过UI管理Kubernetes集群，其外观如下：
- en: '![Figure 9.2 – The Kubernetes dashboard](img/Figure_09.2_B19349.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – Kubernetes仪表板](img/Figure_09.2_B19349.jpg)'
- en: Figure 9.2 – The Kubernetes dashboard
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – Kubernetes仪表板
- en: Kubernetes uses YAML configuration to create objects. For example, you need
    a deployment and service object to deploy and access the sample e-commerce application.
    The deployment will create a pod in the Kubernetes cluster that will run the application
    container, and the service will allow it to access it. You can create these YAML
    files either manually or generate them using `kubectl`. You should typically use
    `kubectl`, which generates the files for you. If you need to, you can modify the
    content of the file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用YAML配置来创建对象。例如，您需要一个部署和服务对象来部署和访问示例电子商务应用程序。部署将在Kubernetes集群中创建一个Pod，该Pod将运行应用程序容器，服务将允许访问它。您可以手动创建这些YAML文件，或者使用`kubectl`生成它们。通常，您应该使用`kubectl`，它会为您生成文件。如果需要，您可以修改文件的内容。
- en: 'Let’s create a new directory (`k8s`) in the project’s home directory so that
    we can store the Kubernetes deployment configuration. We can generate the deployment
    Kubernetes configuration file by using the following commands from the newly created
    `k8s` directory:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根目录中创建一个新的目录（`k8s`），这样我们就可以存储Kubernetes部署配置。我们可以通过在新建的`k8s`目录中使用以下命令来生成部署Kubernetes配置文件：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the first command generates the deployment configuration in the `deployment.yaml`
    file using the `create deployment` command. A Kubernetes deployment defines the
    scale at which you want to run your application. You can see that the replica
    is defined as `1`. Therefore, Kubernetes will run a single replica of this deployment.
    Here, you pass the name (`chapter09`) of the deployment, the image name of the
    application to deploy, the `--dry-run=client` flag to preview the object that
    will be sent to the cluster, and the `-o=yaml` flag to generate the YAML output.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个命令使用`create deployment`命令在`deployment.yaml`文件中生成部署配置。Kubernetes部署定义了您希望运行应用程序的规模。您可以看到副本被定义为`1`。因此，Kubernetes将运行该部署的单个副本。在这里，您传递了部署的名称（`chapter09`）、要部署的应用程序的镜像名称、`--dry-run=client`标志以预览将发送到集群的对象，以及`-o=yaml`标志以生成YAML输出。
- en: The second command appends `---` to the end of the `deployment.yaml` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令将`---`追加到`deployment.yaml`文件的末尾。
- en: Finally, the third command creates the service configuration in `deployment.yaml`,
    with a value of `8080` for both internal and external ports.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个命令在`deployment.yaml`中创建了服务配置，内部和外部端口都设置为`8080`。
- en: Here, you have used the same file for both deployment and service objects. However,
    you can create two separate files for these – `deployment.yaml` and `service.yaml`.
    In this case, you need to apply these objects separately in your Kubernetes cluster.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用了相同的文件来部署和服务对象。然而，您可以创建两个单独的文件——`deployment.yaml`和`service.yaml`。在这种情况下，您需要单独在您的Kubernetes集群中应用这些对象。
- en: 'Let’s have a look at the content of the `deployment.yaml` file, which was generated
    by the previous code block:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`deployment.yaml`文件的内容，该文件是由前面的代码块生成的：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09/k8s/deployment.yaml)'
- en: 'Now, you can deploy the sample e-commerce application using the file created
    previously in the `deployment.yaml` file, with the following command running from
    the project root directory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用之前创建的`deployment.yaml`文件，从项目根目录运行以下命令来部署示例电子商务应用程序：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will deploy a sample e-commerce app ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09))
    in Kubernetes on successful creation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在成功创建后，在Kubernetes上部署一个示例电子商务应用程序（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter09)）。
- en: 'Alternatively, you can perform the following steps to publish the Docker image
    to Minikube. Start a new terminal and execute the following commands (the same
    terminal window should be used here, since the `eval` commands are only valid
    in an active terminal):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以执行以下步骤将Docker镜像发布到Minikube。启动一个新的终端并执行以下命令（这里应使用相同的终端窗口，因为`eval`命令仅在活动终端中有效）：
- en: Execute `eval $(minikube docker-env)` to align the Minikube environment with
    your Docker configuration.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`eval $(minikube docker-env)`以将Minikube环境与您的Docker配置对齐。
- en: Execute `gradle bootBuildImage` to generate an image based on the Minikube environment.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`gradle bootBuildImage`以基于Minikube环境生成镜像。
- en: 'Execute the following commands:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can start the Minikube logs by using the following commands:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令启动Minikube日志：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will initiate the application deployment of `chapter09`. You can then either
    use the Kubernetes dashboard or the `kubectl get all` command to check the status
    of your pod and service. **Pods** are Kubernetes’ smallest and most deployable
    objects. They contain one or more containers and represent a single instance of
    a running process in a Kubernetes cluster. A pod’s IP address and other configuration
    details may change because Kubernetes keep track of these, and it may replace
    them if a pod goes down. Therefore, a **Kubernetes service** adds an abstraction
    layer over the pods it exposes the IP addresses of and manages mapping to internal
    pods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`chapter09`的应用程序部署。然后，您可以使用Kubernetes仪表板或`kubectl get all`命令来检查Pod和服务的状态。**Pods**是Kubernetes中最小且最可部署的对象。它们包含一个或多个容器，并代表Kubernetes集群中运行进程的单个实例。Pod的IP地址和其他配置细节可能会更改，因为Kubernetes跟踪这些信息，如果Pod崩溃，它可能会替换它们。因此，**Kubernetes服务**在其暴露的Pod的IP地址上添加了一个抽象层，并管理映射到内部Pod。
- en: 'Let’s run the following command to find out the status of the pod and service:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令以找出Pod和服务的状态：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This returns all the Kubernetes resources in the default namespace. Here, you
    can see that it returns a running pod, a service, a deployment resource, and a
    ReplicaSet for `chapter09`. You need to run this command multiple times until
    you find a successful or erroneous response (such as “`image is` `not pullable`”).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回默认命名空间中的所有Kubernetes资源。在这里，您可以看到它返回了一个正在运行的Pod、一个服务、一个部署资源以及`chapter09`的ReplicaSet。您需要多次运行此命令，直到找到成功或错误的响应（例如“`image
    is` `not pullable`”）。
- en: 'You can’t access the application running inside Kubernetes directly, as you
    can see from the reponse of the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法直接访问运行在Kubernetes内部的程序，正如您可以从以下命令的响应中看到：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You must either use some kind of proxy or SSH tunneling to access the application
    running inside the Kubernetes cluster. Let’s quickly create an SSH tunnel using
    the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用某种类型的代理或SSH隧道来访问运行在Kubernetes集群内部的程序。让我们快速使用以下命令创建一个SSH隧道：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The application now runs on port `8080` inside the Kubernete’s cluster. It is
    also mapped to the local machine’s port`8080`. Due to this port mapping, you can
    access the application outside the Kubernetes cluster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在在Kubernetes集群内部运行于端口`8080`。它也被映射到本地机器的端口`8080`。由于这种端口映射，您可以在Kubernetes集群外部访问应用程序。
- en: 'Let’s try again accessing the application after opening a new terminal window:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在打开一个新的终端窗口后再次尝试访问应用程序：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With that, the application has been successfully deployed on our Kubernetes
    cluster. Now, you can use the Postman collection and run all the available `REST`
    endpoints.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，应用程序已成功部署到我们的Kubernetes集群。现在，您可以使用Postman集合并运行所有可用的`REST`端点。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about containerization and how it is different
    from virtualization. You also learned about the Docker containerization platform
    and how to use the Spring Boot plugin to generate a Docker image for a sample
    e-commerce app.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了容器化及其与虚拟化的不同之处。你还学习了 Docker 容器化平台以及如何使用 Spring Boot 插件为示例电子商务应用程序生成
    Docker 镜像。
- en: Then, you learned about the Docker registry and how to configure a local insecure
    registry so that you can use it to push and pull images locally. The same commands
    can be used to push and pull images from a remote Docker registry.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了 Docker 仓库以及如何配置本地不安全的仓库，以便你可以用它来本地推送和拉取镜像。相同的命令也可以用来从远程 Docker 仓库推送和拉取镜像。
- en: You also learned about Kubernetes and its cluster operations by using Minikube.
    You configured it so that you can pull Docker images from insecure local Docker
    registries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还通过使用 Minikube 学习了 Kubernetes 及其集群操作。你配置了它，以便可以从不安全的本地 Docker 仓库拉取 Docker 镜像。
- en: Now, you have the necessary skills to build a Docker image of a Spring Boot
    application and deploy it to a Kubernetes cluster.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你拥有了构建 Spring Boot 应用程序的 Docker 镜像并将其部署到 Kubernetes 集群所必需的技能。
- en: In the next chapter, you’ll learn about the fundamentals of the gRPC APIs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习 gRPC API 的基础知识。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between virtualization and containerization?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化和容器化之间有什么区别？
- en: What is Kubernetes used for?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Kubernetes 的用途？
- en: What is `kubectl`?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `kubectl`？
- en: Answers
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Virtualization is used to create VMs on top of the host system, which shares
    its hardware with the VMs, whereas containerization creates containers that are
    executed as an isolated process on top of the hardware and its OS. Containers
    are lightweight and need only a few MB (occasionally, GB). VMs are heavyweight
    and need many GB. Containers run faster and are more portable than VMs.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化用于在宿主系统之上创建虚拟机，虚拟机共享其硬件，而容器化则创建在硬件及其操作系统之上执行的容器。容器轻量级，只需要几个 MB（偶尔需要 GB）。虚拟机重量级，需要多个
    GB。容器运行速度更快，比虚拟机更易于携带。
- en: Kubernetes is a container orchestration system and is used to manage application
    containers. It keeps track of running containers. It shuts down containers when
    they are not used and restarts orphaned containers. A Kubernetes cluster is also
    used for scale. It can provision resources such as CPU, memory, and storage automatically
    when required.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 是一个容器编排系统，用于管理应用程序容器。它跟踪运行中的容器。当容器未被使用时，它会关闭容器，并重启孤儿容器。Kubernetes
    集群也用于扩展。当需要时，它可以自动配置资源，如 CPU、内存和存储。
- en: '`kubectl` is a Kubernetes `kubectl`. You used `kubectl`’s `apply` and `create`
    commands in this chapter.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl` 是 Kubernetes 的 `kubectl`。在本章中，你使用了 `kubectl` 的 `apply` 和 `create`
    命令。'
- en: Further reading
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Kubernetes – Fourth* *Edition*: [https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395](https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通 Kubernetes – 第四版*》: [https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395](https://www.packtpub.com/product/kubernetes-basics-and-beyond-fourth-edition/9781804611395)'
- en: 'Docker documentation: [https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 文档：[https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)
- en: 'Minikube documentation: [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube 文档：[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
- en: Part 3 – gRPC, Logging, and Monitoring
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 – gRPC、日志记录和监控
- en: In this part, you will learn about gRPC-based API development. On the completion
    of this part, you will be able to differentiate between REST and reactive APIs
    with gRPC-based APIs. You will be able to build a server and client using the
    Protobuf schema. Finally, you will be able to facilitate distributed logging and
    tracing, collecting the logs as an Elasticsearch index that will be used for debugging
    and analysis on the Kibana app.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将学习基于 gRPC 的 API 开发。完成本部分后，你将能够区分基于 gRPC 的 API 与 REST 和反应式 API。你将能够使用
    Protobuf 架构构建服务器和客户端。最后，你将能够促进分布式日志记录和跟踪，将日志收集为 Elasticsearch 索引，该索引将用于在 Kibana
    应用程序上进行调试和分析。
- en: 'This part contains the following chapters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19349_10.xhtml#_idTextAnchor233), *Getting Started with gRPC*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 10 章*](B19349_10.xhtml#_idTextAnchor233)，*开始使用 gRPC*'
- en: '[*Chapter 11*](B19349_11.xhtml#_idTextAnchor250), *gRPC API Development and
    Testing*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 11 章*](B19349_11.xhtml#_idTextAnchor250)，*gRPC API 开发和测试*'
- en: '[*Chapter 12*](B19349_12.xhtml#_idTextAnchor272), *Adding Logging and Tracing
    to Services*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19349_12.xhtml#_idTextAnchor272)，*为服务添加日志和跟踪*'
