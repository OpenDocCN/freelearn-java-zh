- en: 'Chapter 7: Exploring Middleware and Frameworks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start talking about the concept of middleware and how
    it has evolved over time. In particular, we will focus on the **Java Enterprise
    Edition** (**JEE**) standard, including the **Jakarta EE** transition. We will
    see a notable open source implementation, which is **WildFly** (formerly known
    as **JBoss Application Server**), and we will start exploring how the concept
    of middleware is evolving into cloud-native frameworks – in our case, **Quarkus**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The JEE standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WildFly application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common JEE APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond JEE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our picture of middleware will be completed in the next chapter, in which we
    will see the approach to integration, which is another cornerstone of what's traditionally
    called middleware.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will know the differences and similarities between
    the JEE standard and its cloud-native alternative, MicroProfile. Moreover, we
    will have seen the most common and useful APIs provided by both standards.
  prefs: []
  type: TYPE_NORMAL
- en: But first of all, let's start with the most popular middleware standard for
    Java developers, which is, of course, JEE.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please make sure that you have a supported **Java Virtual Machine** (**JVM**)
    installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code used in this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the JEE standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We (as programmers, who are well versed with the digital world) know that Java
    is a powerful and expressive language. It is a widely used tool for building applications,
    both in a traditional way (as it is already done in a majority of enterprise contexts)
    and more and more in a cloud-native way too (as we will see in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: According to the JVM Ecosystem Report 2021 by Snyk, roughly 37% of production
    applications use JEE (with Java EE, referring to the older version, still being
    used by a majority compared to newer JakartaEE implementations). Spring Boot counts
    for 57%, while Quarkus, which we are going to see in this chapter, is growing
    and is currently at 10%.
  prefs: []
  type: TYPE_NORMAL
- en: So, Java doesn't need an introduction per se. Everybody (at least, everybody
    who is reading this book) knows that it's a powerful and expressive language that
    aims to be available across platforms (write once, run everywhere – I love it!)
    and that it is based on the compilation of bytecode, which can then be executed
    by the virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: It's a technology platform that includes a programming language, specifications,
    documentation, and a set of supporting tools, including runtimes (the JVM), a
    compiler, and so on. The tools are provided by different vendors (with the major
    ones being Oracle, IBM, and Red Hat) and comply with the standards. The language
    is currently owned by Oracle. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the **Enterprise Edition**. There are a number of standards that
    are not really needed in the *plain* version of the Java technology. Features
    such as transactions and messaging are specifically targeted at server-side enterprise
    scenarios, such as banking applications, CRMs, and ERPs. For this reason, such
    features are standardized as an extension of the Java platform, namely the Enterprise
    Edition.
  prefs: []
  type: TYPE_NORMAL
- en: However, in 2017, Oracle decided to donate the rights of the Enterprise Edition
    to the Eclipse open source community while holding the rights to the Java language
    (and brand). For this reason, the Enterprise Edition has been renamed Jakarta
    EE after a community vote.
  prefs: []
  type: TYPE_NORMAL
- en: This transition caused some slight changes in the specification process, basically
    making it more open to cooperation and less linked to just one vendor. The old
    process was named the **Java Community Process** (**JCP**), while the new one
    is called the **Eclipse Foundation Specification Process** (**EFSP**). The most
    important concepts stay the same, such as the **Java Specification Request** (**JSR**),
    which is a way of specifying the new features, and the **Technology Compatibility
    Kits** (**TCKs**), which are used to certify adherence to the standard. Jakarta
    starts from version **8**, based on **Java EE 8**. At the time of writing, **Jakarta
    EE 9** is available. The examples in this chapter are tested against **JEE 8**
    (because it's the most widely used version right now) but should work properly
    in **JEE 9** too.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that in this section, we will install the WildFly application
    server in order to start playing with JEE (and later on, we will start working
    with Quarkus to learn about MicroProfile). In both cases, the only requirement
    on your machine is a compatible version of the JVM. If you are in doubt, you can
    download the version you need for free from the OpenJDK website ([http://openjdk.java.net/](http://openjdk.java.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Diving into JEE implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said, the JEE specification (before and after the transition to Jakarta)
    provides TCKs. TCKs are suites of tests to certify compliance with the JEE standards.
    JEE currently provides a full profile and a web profile. The web profile is basically
    a subset of the specifications included in the full profile, aiming at a lighter
    implementation for some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of application servers that are JEE compliant. In my personal
    experience, the most widely adopted servers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WildFly** is a fully open source JEE application server, and it has a commercially
    supported version named JBoss Enterprise Application Platform (by Red Hat).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSphere Application Server**, developed by IBM, is distributed in many
    different versions, including the open source Open Liberty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle WebLogic Server** is developed and distributed by Oracle (the full
    profile only).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the other servers fully implementing JEE specifications, Payara and GlassFish
    are worth mentioning. There are also a number of other interesting projects (such
    as Tomcat and Jetty) that are not fully JEE certified, but they implement most
    of the APIs and can plug into some of the others via external dependencies. In
    this chapter, we will work with WildFly, but thanks to the JEE standard, if we
    change some dependencies, everything should work in the other servers too.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the WildFly application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WildFly is by far the application server that I've come across most often in
    my daily job. It's probably the most widespread Java application server. It was
    renamed from JBoss, as a contraction of `JBoss.org`), and the product family commercially
    supported by Red Hat (including **JBoss EAP**).
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that JBoss EAP is made of the same components as WildFly.
    There are no hidden features available in the commercial distribution. JBoss EAP
    is simply a frozen distribution of the WildFly components at a certain version,
    which is used to provide stability, certifications, and commercial support for
    enterprise environments. WildFly is developed in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the WildFly architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have had a decent experience with WildFly, you may remember that JBoss
    used to be huge and sometimes slow. For this reason, a long time ago (around 2011),
    the server, then named **JBoss AS 7**, was rearchitected from the ground up. The
    resulting version was a modular and fast application server, which provided the
    basis for all the later releases (including the current one).
  prefs: []
  type: TYPE_NORMAL
- en: Major changes were about class loading (made more granular), core feature implementation
    (moved to a modular, lazy-loading system), management, and configuration (unified
    into one single file). The result of this rearchitecting was then used for the
    **JBoss EAP 6** (and the following versions) commercial distribution. The latest
    version of WildFly (**22.0**) starts on my laptop in around 1 second. WildFly
    can be started in standalone mode (everything running in one Java process) or
    in domain mode, which is a way to centrally manage a fleet of instances from a
    single point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: A very common misconception is the overlapping of the concept of domain with
    the concepts of clustering and high availability. They are actually orthogonal
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We can have an arbitrary number of standalone servers, individually managed
    and configured to be clustered in a highly available fashion, or a domain managing
    a fleet of non-clustered instances. Also, it's worth noting that we can have multiple
    server instances on a single machine (whether a physical or virtual host) by operating
    different port offsets (to avoid TCP port clashing) and different subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is distributed as a `.zip` file and the most significant folders
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bin` directory: This contains the executable scripts (both for `.sh` and `.bat`)
    for starting the server, along with some other utilities, such as for adding users
    and configuring vaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modules` directory: This contains the system dependencies of the application
    server, which implement the core JEE features (and other supporting subsystems).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standalone` directory: This is used as a root directory when the server is
    started in standalone mode. It includes subdirectories such as `configuration`
    (used for storing configuration files), `data` (where the persistent data from
    the deployed applications is stored), `tmp` (used to store temporary files used
    by applications), `log` (the default location for the server and applications
    logfiles), and `deployments` (which can be used to deploy applications by dropping
    deployable files and is used for development purposes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` directory: This is similar to `standalone`, but it doesn''t contain
    the `deployments` folder (which is used for drop-in deployment, which is when
    we deploy new applications by copying the artifact in the directory and expect
    the application server to pick it and deploy it. This is not supported in domain
    mode). It contains a `content` directory (supporting some system functionalities,
    specific to the domain operating mode) and a `server` directory, which contains
    a subdirectory for each server instance hosted in the current machine, in turn
    containing `tmp`, `data`, and `log` folders used by that particular server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we've been introduced to the WildFly architecture; now let's see how
    to run a WildFly server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the WildFly server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of this chapter, we will be running the WildFly server in standalone
    mode. Before we get started, please make sure that you have a supported JVM installed
    on your machine. We will need to download the latest server distribution from
    [https://www.wildfly.org/downloads/](https://www.wildfly.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the following steps to install the WildFly server runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After downloading the required suitable files, we''ll unzip them and run the
    following command on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use the `.bat` script (if you are on Windows) to run the server.
    We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Initializing WildFly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Initializing WildFly
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is started, we can deploy our application by dropping our artifact
    (`.jar` / `.war` / `.ear`) into the `deployments` folder (which is not advised
    for production purposes) or, better yet, we can deploy by using the JBoss **Command-Line
    Interface** (**CLI**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The JBoss CLI can be executed by running the `jboss-cli.sh` (or `.bat`) script
    from the `bin` directory. The CLI can be used to connect, configure, and manage
    WildFly setups (both locally and over the network). In order to use it to connect
    to a local standalone WildFly instance, we can simply use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then enter the interactive WildFly CLI. To deploy our application,
    we can use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then exit the WildFly CLI with the `exit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know the basics of configuring and operating the WildFly server,
    we can start playing with simple JEE examples.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the most common JEE APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen an overview of the JEE technology and implemented it with
    application servers, we will learn about the most common JEE APIs that are used
    in enterprise projects. We will have a look at some examples of those APIs at
    the end of this chapter, in the *Case studies and examples* section.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I remember the times when dependency injection was simply not available in JEE,
    and we had to rely exclusively on **EJB version 2** (unfortunately) to wire our
    dependencies. This was probably one of the reasons behind the growth in popularity
    of the Spring Framework, which became widespread by offering a lightweight alternative
    to wiring, based on dependency injection, and avoiding verbose and error-prone
    configuration files. But that's another story that is out of the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency Injection** (**DI**) or **Contexts and Dependency Injection**
    (**CDI**) is a concept that extends and implements the **Inversion of Control**
    (**IoC**) principle. The idea here is that instead of letting each class instantiate
    the required classes, we can let an external entity (sometimes referred to as
    an IoC container) do that. This allows us to just use Java interfaces at design
    time and lets the container pick the right implementations, thus boosting flexibility
    and decoupling. Moreover, the CDI concept rationalizes the application structure
    by making the wiring points of one class with the others explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: In the current implementations of the CDI standard (`@Inject` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: By marking a field (or a setter method, or a constructor) of our class with
    this annotation, we are basically telling the framework that we want that field
    instantiated and provided for us. The container tries to identify a class in the
    application that may satisfy that dependency. The objects that can be injected
    are almost any kind of Java class, including special things that provide access
    to JEE services, such as persistence context, data sources, and messaging.
  prefs: []
  type: TYPE_NORMAL
- en: '*But how does the container identify the class to use?* Skipping the trivial
    case in which just one possible implementation is provided, of course, there are
    ways to define which compatible class to inject. One way is to use qualifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Named` annotation. With this annotation, we can provide each compatible class
    with a name and then specify which one to use in the injection.'
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, it's possible to mark a class with `@Default` and the other
    implementations with `@Alternatives` to identify which one we want to be selected.
    `@Alternatives` can then be given an order of priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI also provides the management of the life cycle of the objects, which means
    when the objects should be created and when they should be destroyed. The CDI
    scopes are configured by using annotations, as per the injection that we have
    just seen. The most commonly used scopes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@ApplicationScoped**: This binds the creation and destruction of the objects
    with the life cycle of the whole application. This means that one instance is
    created at application startup and destroyed at shutdown. Only one instance will
    be managed by the container and shared by all the clients. In this sense, this
    annotation is an implementation of the singleton pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Dependent**: This is the default scope that creates a class, which is linked
    to the life cycle of the object using it, and so it''s created and destroyed concurrently
    with the object in which it is injected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@SessionScoped**: This links the life cycle of the object with the HTTP session
    in which it is referenced (and so makes it a good tool for storing user and session
    information).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@RequestScoped**: This binds the object life cycle to the life cycle of the
    HTTP request where it is referenced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@TransactionScoped**: This associates the life cycle of the object with the
    duration of the transactional boundary in which it is utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the diagram for CDI scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – CDI scopes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – CDI scopes
  prefs: []
  type: TYPE_NORMAL
- en: CDI specifications also provide hooks to specific life cycle events. The most
    commonly used are `@PostConstruct` and `@PreDestroy`, which are called immediately
    after object creation and before destruction, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta RESTful Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another essential piece of Java applications nowadays is RESTful Web Services.
    The Jakarta EE standard for RESTful Web Services (`JAXRSApplication` class to
    the class path), all we have to do is create a bean for mapping the resource that
    we want to expose and annotate it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the most common use case, we will have to map the whole class to the path
    we want to expose by annotating the class with the `@Path` annotation. We may
    then want to specify the media types that the class produces and consumes (usually
    JSON) by using the `@Produces` and `@Consumes` annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Each method of the class can be mapped to HTTP methods by using annotations
    such as `@Get`, `@Post`, `@Delete`, `@Put`, and `@Head`, and we can bind these
    methods to sub-paths by using the same `@Path` annotation. As an example, we can
    have the whole class bound to `/myPath` (with `GET`, `POST`, and other HTTP methods
    referring to that path) and then have the specific methods annotated to refer
    to `/myPath/mySubPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Another very common scenario is the binding of method parameters with HTTP path
    parameters (`@PathParam`), parameters on the query string (`@QueryParam`), and
    HTTP headers (`@HeaderParam`). We should make a special mention of the **Jakarta
    JSON Binding** (**JSON-B**) specification, which, acting behind the scenes, can
    provide the JSON to **Plain Old Java Objects** (**POJOs**) (and vice versa) mapping
    for our beans, provided that they have a simple structure (and without needing
    any complex configuration). This is true for the most common use cases, meaning
    the Java classes with simple type fields with getters and setters. But of course,
    it's possible to provide customizations and implement special cases, if we need
    to.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the JAX-RS specification, we can create REST clients too (to query
    REST services). In order to do that, a common way is to use the `ClientBuilder`
    class, which provides a fluent API to specify the usual parameters of an HTTP
    client (such as timeouts, filters, and similar settings). We can then create a
    so-called `WebTarget` object, which is an object that allows us to specify the
    path to invoke using the client. Acting on `WebTarget`, it is possible to send
    requests by passing parameters and getting results (usually in form of JSON objects).
  prefs: []
  type: TYPE_NORMAL
- en: An interesting twist of the JAX-RS specification is the possibility to manage
    **Server Sent Events** (**SSEs**). SSEs were introduced with the **HTML5** standardization
    and are a way to provide data from a server to a client in the form of events
    by using an open connection.
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that the client initiates the request to the server, but instead
    of getting all the data in one shot and closing the connection, it will keep the
    connection open and fetch the data as it comes from the client (eventually closing
    it at some point, or being disconnected by the server). The advantage here is
    that we can reuse the same connection to reduce the overhead, and we can get (and
    visualize) the data in real time without needing to poll the server for updates.
    The client could be a Java client or a web page in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this behavior, JAX-RS provides `Sse` and `SseEventSink`
    resources that can be injected into our method with the `@Context` annotation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have those two resources, we can use `sse` to build new events and
    `sseEventSink` to send such events. Once we''ve completed our interactions with
    the client, we can use `sseEventSink` to close the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an `event` object by invoking `newEventBuilder` on the `sse` object
    injected in our class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `mediaType` to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the data we want to send, specifying the class type and the object instance
    containing the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call the `build` method to create the `event` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We invoke the `send` method on the `eventSink` object, passing the event instance
    we just created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventually, we can close the connection by calling `close` on the `eventSink`
    object. Of course, in a real-world scenario, we may want to send a number of events
    (such as a consequence of something happening) before closing the connection.
    It doesn't make much sense to have `sse` just to send one event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One interesting scenario generated by SSE is the possibility to implement broadcast
    scenarios. In such scenarios, instead of having each client connected to a different
    thread (and receiving different messages), we can have clients all receiving the
    same message. In this way, we will have clients subscribing (usually calling a
    specific REST service) and then getting the data (calling another one). Here is
    a code example (simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `broadcast` method and annotate it to indicate that it will be associated
    with an HTTP `GET` method that is exposed on the `broadcast` path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This `broadcast` method will be injected with an `sse` object instance present
    in the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `broadcaster` object by invoking the `newBroadcaster` method on
    the `sse` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an `OutboundSseEvent` object by invoking the `newEventBuilder` method
    on the `sse` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `mediaType` to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the data we want to send, specifying the class type and the object instance
    containing the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call the `build` method to create the `event` instance. We invoke the `broadcast`
    method on the `broadcaster` object, passing the `event` instance we just created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `subscribe` method and annotate it to indicate that it will be associated
    with an HTTP `GET` method that is exposed on the `subscribe` path and that will
    produce answers with the `SERVER_SENT_EVENTS` media type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subscribe` method will be injected with an `SseEventSink` object instance
    present in the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of a `broadcaster` object by invoking the `newBroadcaster`
    method on the `sse` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We register `sseEventSink` by passing it to the `register` method on the `broadcaster`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the client side, we will most likely interact with SSE by using a framework
    such as Vue or Angular. But in any case, under the hood it will use the JavaScript
    `EventSource` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, we can also interact with SSE by using a Java client. Similar
    to the JavaScript version, the SSE implementation in Java provides an `EventSource`
    object too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A personal consideration here is to thoroughly test this kind of implementation
    in real production scenarios and manage and monitor exceptions. We must also consider
    some alternatives in case of unexpected disconnects that may be due to clients
    with unstable connections (such as mobile clients) or network devices misbehaving
    in the overall infrastructure. Frameworks usually also provide some resiliency
    features, such as connection retries (in case the backend is momentarily unavailable).
    Resiliency must be also considered from a backend perspective, hence if a failure
    occurs while sending a message (and an exception is thrown), you should consider
    handling (including retries). But since this is basically non-transactional (because
    of network connections being potentially unreliable), you should consider edge
    cases including duplicate events or message loss.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jakarta EE includes support for WebSocket technology. Using this technology,
    we can implement full-duplex communication between client and server, supporting
    the development of a rich user experience in web applications. WebSocket sits
    directly on top of TCP, so it doesn't rely on HTTP. However, it is compatible
    with HTTP, meaning that, from a connection point of view, it uses a compatible
    handshake and may be transported over HTTP and HTTPS standard ports (`80` and
    `443`), so it is compatible with most network infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the WebSocket capabilities on the backend, you need to
    annotate a class with `@ServerEndpoint`, specifying the path on which the capabilities
    will be published. With this class, we can then annotate methods with `@OnMessage`,
    `@OnOpen`, `@OnClose`, and `@OnError` to intercept the message received, the client
    connected, the client disconnected, and error events, respectively. After the
    connection of a client, in the method annotated with `@OnOpen`, it''s possible
    to retrieve and store a session object. This object can then be used to send messages
    to the clients, hence implementing full-duplex communication, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we saw when discussing server-sent events, WebSocket's applications are usually
    implemented on the client side using frameworks. However, JavaScript exposes a
    WebSocket object that can be used to mirror the server-side life cycle (`OnOpen`,
    `OnMessage`, and `OnError`) and the message-sending capabilities. As with SSE,
    my suggestion is to test this kind of interaction on an infrastructure that's
    comparable to the production one and be ready with alternatives in case something
    goes wrong with network connectivity, such as having graceful fallbacks. A nice
    implementation of this could be the **circuit breaker** pattern, as we are going
    to see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing
    Cloud-Native Architectures*.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Messaging** is another key component in modern applications. In the cloud-native
    microservices world, the **Java Message Service** (**JMS**) is considered to be
    an *enterprise-y*, complex manner of communication, often used together with other
    technologies, such as Kafka and AMQP. However, for many years, from **version
    2.0** onward (**3.0** was just released at the time of writing), JMS has become
    very easy to use (at least in basic use cases).'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the messaging standard in JEE (which is one of the things I
    like about the application servers in general) is that we can keep the code simple
    and compact and offload the configurations to the application server. This also
    has the advantage of separating the code from the configuration. This also has
    advantages in terms of clarity, portability, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to send messages, we can use the injection of JEE resources – in this
    case, `JMSContext`. With the same approach, we can inject an object representing
    our target queue. The API then allows us to create a producer from the `JMSContext`
    object and use it to send a message against the queue, such as in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With a similar kind of API, we can consume messages by creating a consumer and
    invoking the receive method against it. But this is not how it is done commonly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most widely used way is to use a `MessageListener` interface and the use
    of some annotations to configure the queue to attach to. The code is quite self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In both the consumer (MDB) and the producer example, the code looks for the
    default JMS connection factory, which is supposed to be bound to `java:/ConnectionFactory`.
    It is possible to explicitly state an alternative connection factory if we want
    to (such as when our application server must be connected to different brokers).
  prefs: []
  type: TYPE_NORMAL
- en: In order to set the properties to connect to a broker, such as a host, port,
    username, and password (and associate it with a `java:/ConnectionFactory`), we
    will have to configure the application server. This is, of course, specific to
    the server we choose. In WildFly, we commonly do that by using a CLI (as we have
    seen when deploying applications) or by directly editing the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Persistence** is often one of the must-have properties for Java EE applications.
    While other persistence alternatives are now widely used, such as NoSQL stores
    and **InMemory** caches, database persistence is unlikely to disappear anytime
    soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Persistence in JEE is regulated by the **Java Persistence API** (**JPA**) specification.
    In the earlier versions, JPA was clumsy and painful to use (as was the EJB specification).
    This is not true anymore, and JPA is now very easy to use. As you may probably
    know, JPA is built around the **Object-Relational Mapping** (**ORM**) idea, which
    aims for relational database tables to be mapped to objects (in our case, Java
    objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing to do to use JPA is to define our objects and how they
    map to database tables. As you can imagine, this is easily done by using annotations.
    The relevant annotations here are `@Entity` to identify the class and map it to
    the database, `@ID` to mark the field linked to the primary key, `@GeneratedValue`
    to define the strategy for the key generation, `@Table` to configure the table
    name (which defaults to the class name), and `@Column` to configure the column
    name for each class field (also, in this case, it defaults to the field name).
    This is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After we have our classes linked to our database tables, it's time to interact
    with the database itself. You can easily do that by injecting the so-called `EntityManager`
    where it's needed. The entity manager is associated with a persistence context,
    which is essentially the set of configurations that you set into the application
    and the application server to make it aware of where the database should connect
    to, such as the **Java Database Connectivity** (**JDBC**) string and other properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the entity manager to retrieve objects from the database by using
    the JPA query language (which is similar to SQL) to create new objects, delete
    them, and so on. Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, consistent with the other APIs that we have seen so far, JPA
    is pretty easy to use. It will nicely decouple business logic (in your Java code)
    from configuration (in the application server) and standardize the implementation
    of common aspects such as table-to-POJO mapping and transaction usage.
  prefs: []
  type: TYPE_NORMAL
- en: What's missing in Java EE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons why some developers are moving away from the JEE specification
    is that the evolution of the standard is a bit slow. One goal of the platform
    is to include a big list of vendors providing reference implementations and to
    give long-term stability to the standard users, so it will take time to evolve
    JEE. At the time of writing, a number of things were missing from JEE that need
    to be overcome by using third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try to summarize the most common criticisms in this area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observability**: Since the beginning, some advanced monitoring capabilities
    have been missing from the JEE specification. **Java Management Extension** (**JMX**)
    was provided in the Java platform as a first attempt to provide some metrics and
    monitoring, and JDK Mission Control was donated to open source communities, providing
    some more advanced capabilities in terms of profiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, enterprises commonly complement such technologies with third-party
    software, sometimes proprietary software. As of today, more advanced monitoring
    capabilities, such as tracing, are commonly required for fully controlling the
    application behavior in production. Moreover, metric collections and display technologies
    based on stacks such as Prometheus and Grafana have become a de facto standard.
    Observability also includes things such as health and readiness probes, which
    are special services exposed by the application that can be useful for checking
    for application availability (and send an alert or implement some kind of workaround
    if the application is not available).
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: While JEE and Java, in general, are pretty rich in terms of security,
    including role-based access control at different architectural levels, support
    for encryption, multi-factor authentication, and authorization facilities is missing.
    There are some other features, such as OpenID Connect and JSON Web Token, that
    are still missing from the core specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: In heavily decentralized environments, such as microservices
    and cloud-native, it''s crucial to defend the application from issues in external
    components, such as endpoints failing or responding slowly. In JEE, there is no
    standardized way to manage those events (other than normal exception handling).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenAPI**: REST services are widespread in the JEE world. However, JEE does
    not specify a way to define API contracts for REST services, as it''s done by
    the OpenAPI standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other features less likely to be standardized, such as alternative datastores
    (think about NoSQL databases) and alternative messaging (such as streaming platforms
    or AMQP), are also missing. All those functionalities are normally added by third-party
    libraries and connectors. As we will see in the upcoming sections, **MicroProfile**
    provides a way to overcome those limitations in a standard way.
  prefs: []
  type: TYPE_NORMAL
- en: What's great about Java EE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While some useful and modern technology is missing in the vanilla specification
    of JEE, as we have just said (but can be easily added via third-party libraries
    most of the time, such as what''s provided by the [smallrye.io](http://smallrye.io)
    project), I still think that JEE technology is just great and is here to stay.
    Some reasons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor ecosystem**: As we saw at the beginning of this chapter, there are
    a number of alternative implementations, both paid and free, providing JEE compatibility.
    This will ensure long-term stability and (where needed) commercial support, which
    can be crucial in some environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**: While there is no fixed standard, as each vendor implements
    it in their own way, JEE enforces some configurability points on an application.
    This means that a JEE application can be easily fine-tuned for things such as
    thread pool size, timeouts, and authentication providers. While this is, of course,
    possible even while using other approaches, JEE tends to be more operation-friendly.
    Once the system administrators know about the specifics of the application server
    in use, they can easily change those aspects, regardless of the kind of application
    deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battle-tested for enterprise needs**: JEE still provides things that are
    very useful (sometimes essential) in the enterprise world. We are talking about
    distributed transactions, connectors for legacy or enterprise systems, robust
    deployment standards, and so on. You are likely to find some of those features
    in alternative stacks, but they will often be fragmentary and less robust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes our quick overview of JEE's pros and cons. As you may know, a
    detailed explanation of JEE may take a whole (huge) book. However, in these sections,
    we have seen a simple selection of some basic APIs that are useful for building
    modern applications, including RESTful Web Services, JPA persistence, and messaging.
    We have also seen the pros and cons of the JEE framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start talking about alternatives to application
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond Java Enterprise Edition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013), *Designing
    Software Architectures in Java – Methods and Styles*, we had a very quick look
    at containerizing Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look into alternatives and extensions to Java Enterprise, including
    lightweight Java servers and **fat JAR** applications. Here, we will see a quick
    overview of why and how to implement fat JAR applications.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging microservices applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **fat JAR** (also known as an **Uber JAR**) is likely to be one of the starting
    points in the inception of application service alternatives (and microservices
    runtimes). Frameworks such as Dropwizard, Spring Boot, and, more recently, Quarkus
    have been using this approach.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of fat JAR is that you package all you need into a single `.jar` file
    so that we have a self-contained and immutable way to deploy your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages are easy to imagine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.jar` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior is consistent between different environments**: You can test the
    application on a laptop without needing a full-fledged app server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full control of the dependencies**: Versions and implementation of the supporting
    libraries are fixed at build time, so you will have fewer variables in production
    (and you are not forced to stick with what the app server provides).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, all of this comes at a cost. Here are some not-so-obvious disadvantages
    of this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It's less standard (think about configurations). There are some de facto standards,
    such as `.yaml`, application properties files, or system properties. But this
    usually varies from app to app, even when using the same technology stack. Conversely,
    app servers tend to be more prescriptive in terms of what can be configured and
    where to put such configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you can pick and choose the dependencies you need, you have to carry over
    such dependencies with each deployment (or scale). And if you use many dependencies,
    this will be impactful in terms of network usage and time lost (and compiling
    time too). With the application servers, you take for granted that such dependencies
    are already waiting for you in the application server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to supportability, either you get support services from a vendor
    or simply adhere to internal standards. You are normally bound to a fixed set
    of libraries and versions that have probably been tested to be compatible with
    your environment and to adhere to security and performances standards. With a
    fat JAR, you have less control over this at runtime and deployment time. You will
    have to move such controls at build time, and maybe double-check that the content
    of the fat JAR adheres to standards before putting it into your production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*, containers changed
    the rules of the game a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With container technology, you can create a full portable environment, including
    a base operating system (sort of) with a filesystem in which you can place dependencies
    and resources together with your application. This means that you don't need a
    self-consistent application to deploy, as these features are provided by container
    technology. And, as already discussed, this may also be harmful when used together
    with containers, as they are designed to work in a layered way. So, you can use
    this feature to package and deploy only the upper level (containing your application
    code) instead of carrying over the whole dependency set.
  prefs: []
  type: TYPE_NORMAL
- en: So, while still convenient in some cases (such as local testing), fat JAR is
    not necessary right now.
  prefs: []
  type: TYPE_NORMAL
- en: But as we have seen, other than a different packaging approach, there are some
    features that may be very useful in the cloud-native and microservices world.
    These features are missing in JEE, such as observability and support for alternative
    technologies. It used to be common for microservices runtimes to define custom
    solutions to fill those gaps.
  prefs: []
  type: TYPE_NORMAL
- en: But as previously mentioned, lack of standards is a known issue with microservices.
    This used to be a minor issue because early adopters were usually deeply technically
    skilled teams relying on self-support and that didn't need support from a third-party
    vendor.
  prefs: []
  type: TYPE_NORMAL
- en: However, nowadays, the adoption of microservices, cloud-native, and general
    extensions to JEE is growing a lot. And factors such as long-term stability, enterprise
    support, and an open ecosystem are becoming more and more essential. That's one
    of the reasons behind MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MicroProfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MicroProfile** started with a focus on extending the JEE specification with
    features offered by microservices. The development is backed by a consortium of
    industry players, such as IBM, Red Hat, Oracle, and Microsoft. The specification
    lives in parallel to Jakarta EE, sharing some functionality, evolving some others,
    and adding some more that are not part of JEE.'
  prefs: []
  type: TYPE_NORMAL
- en: This works because the MicroProfile consortium, part of the Eclipse Foundation,
    has chosen a less bureaucratic and more frequent release model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that modern Java development can now basically take two parallel
    roads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jakarta EE**: We can choose this if long-term stability and enterprise features
    are more important (or if you want to maintain and modernize existing code bases).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroProfile**: We can choose this if cloud-native features and a frequent
    release cycle are priorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*But what are the features added by MicroProfile?*'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s really challenging to print a snapshot of something (that is changing
    very frequently) on paper. At the time of writing, MicroProfile releases a new
    version every 3 to 6 months. The most important features to highlight are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.xml` files, system environments, and properties files) from the application
    itself. This provides the facilities for accessing the configuration values and
    checking for changes without needing to restart the application (in supported
    implementations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: This is a way to choreograph the reaction to failures
    (such as failing to call an external service) by using patterns such as circuit
    breaker, retry, and fallback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenAPI**: This provides support for the OpenAPI standard, which is a way
    to define contracts for REST services, similar to what a WSDL schema provides
    to SOAP web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenTracing**: This is a modern approach to monitoring and managing chains
    of calls in a distributed environment by passing an ID and introducing concepts
    such as spans and traces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health**: This is a standardized way to create liveness and readiness probes
    in order to instrument an application for checking the correct behavior of an
    application (when it''s live, that is, to verify whether it is up or down) and
    its readiness (when it''s ready to take requests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics**: This is an API for providing facilities for exporting monitorable
    values from your applications. This is usually used for things such as capacity
    planning and overall understanding of the application performances (such as the
    number of current transactions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed, most of the preceding features exactly match what we
    highlighted in the *What's missing in Java EE* section.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore some of those techniques in more detail in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to highlight that MicroProfile encompasses specifications
    included in JEE (such as JAX-RS, JSON-B, and CDI, as we saw in the *Introducing
    the JEE standard* section). While MicroProfile tends to align the version of such
    shared libraries with one target JEE version, it may be that some of those versions
    are out of sync (being probably more up to date in the MicroProfile edition).
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noticing that MicroProfile does not imply any specific packaging
    model for applications. Some implementations, such as **Helidon** (backed by Oracle)
    and Quarkus (backed by Red Hat) tend to use fat JARs and similar, while others,
    such as **OpenLiberty** (provided by IBM) and WildFly (provided by Red Hat) run
    in a more traditional way (deployed into a lightweight running server).
  prefs: []
  type: TYPE_NORMAL
- en: For the upcoming sections, we will start seeing more about Quarkus, which is
    an implementation of the MicroProfile standard and is becoming more and more popular
    and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quarkus** is an open source Java framework that aims to be optimized for
    cloud-native and microservices. It was born in the container and **Kubernetes**
    world, and for this reason, it''s been optimized by design for container and Kubernetes-based
    cloud-native applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus comes from an engineering team with experience in many interesting projects,
    such as **Hibernate**, **Vert.X**, and **RESTEasy**, and so reuses a lot of good
    ideas and best practices from these famous communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a Quarkus application looks like when started from a terminal
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Quarkus starting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Quarkus starting
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, some spectacular ASCII art is shown and some interesting information,
    including the lightning-fast startup time of fewer than 1.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*But what are the most important benefits of Quarkus?*'
  prefs: []
  type: TYPE_NORMAL
- en: Better performances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most famous benefits of Quarkus is its optimization. The framework
    was created with a *container-first* philosophy, and for this reason, it is heavily
    optimized both for startup time and memory usage. In order to achieve these objectives,
    Quarkus uses various techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Less usage of reflection**: Reflection can be impactful in terms of performance.
    Quarkus reduces the use of reflection as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move as much as possible to build time**: Quarkus does as much work as possible
    at build time. This means that all the things that can be done in advance, such
    as class path scanning and configuration loading, are done at build time and persisted
    as bytecode. In this way, not only will the application boot faster (because it
    has fewer things to do), but it will also be smaller in terms of memory footprint
    because of all the infrastructure that is not needed at runtime; that is, the
    ones *precompiled* at build time are not part of the final artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Substrate` module). This allows further optimizations, further reducing the
    startup time and memory footprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But better performance is not the only benefit of Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: Developer joy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thing that I like the most about Quarkus is its ergonomics. As is common
    to hear from people working with it, Quarkus feels new and familiar at the same
    time. The language is extremely friendly if you come from a JEE background. It
    offers a ton of tools and facilities, not to mention all the *syntactic sugar*
    that makes even the most advanced features easy to use. In the Quarkus world,
    this is referred to as **developer joy**.
  prefs: []
  type: TYPE_NORMAL
- en: One of such facilities is the **developer mode**, which allows you to immediately
    see the changes in your application without needing a full recompile/repackage.
    It works like a charm when you change something (such as the source code, configuration
    file, and resources) and can immediately see the effect of such changes (such
    as simply refreshing the browser or recalling the API). I know this feature was
    already provided by other frameworks and libraries (with **JRebel** being one
    of the most famous), but the way it works out of the box is just magic for me,
    and, honestly, it's a great boost in terms of developer productivity.
  prefs: []
  type: TYPE_NORMAL
- en: But that's not the only *developer joy* feature. Each dependency added to Quarkus
    (which are more properly called **extensions**) is crafted to nicely fit the Quarkus
    world and use the framework's capabilities, first of all in terms of performances.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a lot of facilities and conventions over configuration and *intelligent
    defaults*, such as the way the configuration is treated (including environment
    management), a simple way to use both the imperative and reactive paradigms (and
    make them coexist), and the way it interacts with databases (by using the `Panache`
    extension). *But where to start?*
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus – hello world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus has a wizard for generating applications (both with **Maven** and **Gradle**
    support) located at [code.quarkus.io](http://code.quarkus.io). Follow these steps
    to create a new application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new application with the command line by using the Maven Quarkus
    plugin. In the current version, this means using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The plugin will then ask for all the required information, such as the artifact
    name and the dependency to start with. The following screenshot illustrates this
    (please note the cool emoticons too):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Quarkus Maven plugin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – The Quarkus Maven plugin
  prefs: []
  type: TYPE_NORMAL
- en: 'After the plugin execution, you will have an application scaffold that you
    can use as a starting point (in this example, containing `resteasy` and `hibernate`
    dependencies). In order to run it and experiment with the developer mode, you
    can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command uses a Maven wrapper script (in this case, `mvnw`, because I''m
    running on a Linux box, but a `mvnw.cmd` file is provided for Windows environments)
    to run the application in development mode. Since you are using RESTEasy, by default
    the application will answer with a `Hello RESTEasy` string on the following endpoint:
    `http://localhost:8080/hello-resteasy`.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to try the developer mode, you can change the source code (in this
    case, the `GreetingResource` class) to change the response. After you do that,
    you can refresh your browser and see the result without needing to recompile or
    repackage the code.
  prefs: []
  type: TYPE_NORMAL
- en: Building techniques with Quarkus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The development mode, needless to say, supports the development phase. In order
    to build and distribute Quarkus applications, you have other options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus is currently supported to run on OpenJDK (see the official website
    at `quarkus.io/get-started` for more information about the supported versions).
    In order to package your application, you can run the usual Maven command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Quarkus will build a so-called fast-jar. This is basically a package
    optimized for boot time performance and a small memory footprint. In order to
    execute an application packaged in this way, you will need to copy the whole `quarkus-app`
    folder (in the `target` folder), which contains all the libraries and resources
    needed to run the application. You can then run it with a similar command to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also package the application in an UberJar form (be conscious of all
    the limitations of this approach, as discussed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*). To do so, one
    easy way is to pass the `quarkus.package.uber-jar=true` property to the Maven
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This property can also be set in the `pom.xml` file or in the configuration
    file of Quarkus (the `application.properties` file, by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not least, as mentioned at the beginning of this section, Quarkus
    can be compiled into a native Linux executable without the JVM needing to be executed.
    To do so, you can simply use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What Quarkus does under the hood is look for a GraalVM installation that is
    used for native compilation. The following screenshot shows what happens if we
    start Quarkus when the `GRAALVM_HOME` variable is not configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Quarkus building a native executable through Podman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Quarkus building a native executable through Podman
  prefs: []
  type: TYPE_NORMAL
- en: The `GRAALVM_HOME` variable is used to look up the install path of GraalVM.
    If not present, Quarkus will try a container build. This basically means that,
    if a container runtime (Podman or Docker) is installed on the local machine, Quarkus
    will download a container image to use for native building, so you can create
    a native executable without needing a local GraalVM installation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management in Quarkus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One lovely characteristic of Quarkus, in line with the developer joy idea, is
    the way it manages configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus implements the MicroProfile `config` specification. We will see more
    about the MicroProfile functionalities in Quarkus, but since `config` is central
    to all the other extensions, it's worth having a look at it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get and use a configurable value, you can use the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can provide a default value directly into the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration can be loaded by a number of different sources. Quarkus looks
    into the following sources (listed according to decreasing priority):'
  prefs: []
  type: TYPE_NORMAL
- en: System properties (as in passing a command-line argument to the Java process,
    such as `–DmyProperty="myValue"`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.env` files (files containing a set of environment variables) in the working
    directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `application.properties` file (with the usual properties syntax, as in `key=value`)
    placed in a `config` subdirectory in the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `application.properties` file placed in `src/main/resources`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quarkus supports the use of profiles in the configuration properties. This
    allows us to have different environments (or simply different sets of configurations)
    in the same configuration repository (such as in the same `application.properties`
    file). In order to do so, you can use a prefix in the configuration key, such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, Quarkus provides `dev`, `test`, and `prod` profiles. `dev` is activated
    when running in developer mode (`./mvnw compile quarkus:dev`, as seen in the previous
    section), `test` is activated when running tests, and `prod` is activated in all
    other scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: You can define as many configuration profiles as you need and activate them
    by using the `quarkus.profile` system property or the `QUARKUS_PROFILE` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen the basics of Quarkus, the most relevant benefits (including
    performances and language goodies), and how to build a basic `hello world` example.
    In the next section, we will have a look at the most common Quarkus extensions
    that are useful for building cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Most common Quarkus extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus is aiming at cloud-native applications and microservices but shares
    some features and functionalities with the JEE world. This is thanks to its adherence
    to the MicroProfile specification.
  prefs: []
  type: TYPE_NORMAL
- en: Such features are implementing common use cases and are very handy, as they
    allow you to use existing skills and, in some cases, existing JEE code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through a quick overview of the Quarkus extensions
    shared with the JEE specification.
  prefs: []
  type: TYPE_NORMAL
- en: Content Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CDI** is a structured way to wire and compose the objects of your application.
    CDI in Quarkus is based on the Contexts and Dependency Injection for **Java 2.0**
    specification, which defines CDI for both Java SE and Java EE.'
  prefs: []
  type: TYPE_NORMAL
- en: The Quarkus CDI implementation leverages the ArC framework and is not fully
    compliant with the CDI specification, even if it provides support for the most
    common CDI use cases such as DI (of course), qualifiers, life cycle callbacks,
    and interceptors. There are some known limitations, on some specific use cases
    (such as the use of decorators, and the conversation scope). Following the Quarkus
    optimization mantra, ArC moves the discovery and injection operations at build
    time to achieve better performances.
  prefs: []
  type: TYPE_NORMAL
- en: REST services with JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to develop REST services, Quarkus provides a **JAX-RS** extension
    that mimics the Jakarta EE implementation almost completely. RESTEasy is commonly
    added by default in new Quarkus projects. However, in order to add these features
    to an existing Quarkus project, you can simply use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As said, the JAX-RS implementation looks almost like the Jakarta EE implementation,
    so all the concepts we have seen in the previous section are still relevant (as
    previously mentioned, this will allow you to recycle skills and even existing
    code).
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus includes the `undertow-websockets` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Undertow** is a highly performant web server technology written in Java.
    It can use both blocking and non-blocking APIs. Other than the WebSocket functionality
    (used by Quarkus), it provides other interesting web functionalities, such as
    full servlet API support. For this reason, Undertow is embedded into WildFly to
    provide web functionalities in full compliance with the JEE specification. Undertow
    has replaced Tomcat as the embedded web container in WildFly since **version 8**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add the WebSocket functionality to an existing Quarkus project,
    you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this extension, you can use the WebSocket technology in the same way we
    saw in the *Understanding the most common JEE APIs* section, in the *WebSockets*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`quarkus-artemis-jms` and `quarkus-qpid-jms`.'
  prefs: []
  type: TYPE_NORMAL
- en: The two dependencies are mostly equivalent from a functional point of view.
    Technically speaking, the `quarkus-artemis-jms` extensions use the `artemis jms`
    client to connect to the JMS broker, while `quarkus-qpid-jms` uses the AMQP standard
    as its wire protocol to connect to AMQP-compatible brokers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the JEE version, the Quarkus framework does not provide an injectable
    `JMSContext` object. But it does provide a JMS `ConnectionFactory` object, so
    you can easily get a producer from it, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, Quarkus does not provide the EJB subsystem, as it''s provided in
    the JEE specification, so you cannot use MDBs, the classic way provided by JEE
    to consume messages. A quick and easy way to do so is to create a consumer (against
    a `JMSContext` object, as per the producer) and use the `receive()` method. Since
    it''s a blocking call, you will have to create a new thread to encapsulate the
    receive logic without blocking the entire application. You''ll need something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The basic configurations for getting a producer and consumer to work are the
    server endpoint, user, and password. Those configs are stored in `quarkus.qpid-jms.url`,
    `quarkus.qpid-jms.username`, and `quarkus.qpid-jms.password` when using `quarkus-qpid`,
    and in `quarkus.artemis.url`, `quarkus.artemis.username`, and `quarkus.artemis.password`
    when using `quarkus-artemis`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Now you can send and receive JMS messages with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`@Entity` and the other annotations that we have seen in order to specify mappings
    with database tables, and you can inject the `EntityManager` object in order to
    retrieve and persist objects to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: To use Hibernate with Quarkus, you have to add the `quarkus-hibernate-orm` extension
    and a JDBC driver extension. The supported JDBC drivers are currently db2, Derby,
    H2, MariaDB, Microsoft SQL Server, MySQL, and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: The basic properties to configure the database connection are `quarkus.datasource.db-kind`
    (configuring the type of database used), `quarkus.datasource.username`, `quarkus.datasource.password`,
    and `quarkus.datasource.jdbc.url`.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can directly use Hibernate's `EntityManager`, Quarkus provides
    you with a more productive abstraction on top of it. This abstraction is Panache.
  prefs: []
  type: TYPE_NORMAL
- en: Accelerated ORM development with Panache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Panache** is an amazing technology provided with Quarkus. It allows us to
    build ORM applications without redundant boilerplate code. It''s a boost for creating
    **Create Read Update Delete** (**CRUD**)-like applications in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to develop CRUD applications using Panache on top of Hibernate, you
    need to add the `quarkus-hibernate-orm-panache` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this functionality enabled, you can use it in two main patterns,
    **Active Record** and the **repository**.
  prefs: []
  type: TYPE_NORMAL
- en: Panache Active Record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active Record is an architectural pattern. It was described by Martin Fowler
    in his *Patterns of Enterprise Application Architecture* book.
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, one class completely represents a database table. An object
    created from this class represents a row (with fields mapping columns), while
    methods of the class map the interaction with the database, such as `persist`,
    `delete`, and `find`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Quarkus, to implement this pattern, you must make your JPA entity (annotated
    with `@Entity`) extend the `PanacheEntity` class. You can then use all the methods
    inherited from this class in order to interact with the database, including features
    such as `persist`, `delete`, `find` and `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The obvious advantage here is that you don't have to directly interact with
    the `EntityManager` class anymore, and you have a number of methods ready to use
    for common use cases. But if you don't like the Active Record pattern, you can
    achieve pretty similar results with the repository approach.
  prefs: []
  type: TYPE_NORMAL
- en: Panache repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The repository pattern is an alternative to the Active Record one. Basically,
    instead of having both the entities and the methods (to find, update, delete,
    and persist objects) implemented in the same class, you split such responsibilities
    and have entities with no behavior and dedicated repository classes to implement
    database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Quarkus world, this means that your entities are standard JPA entities
    (with no need to extend the `PanacheEntity` class), while your designated repository
    will need to implement the `PanacheRepository` interface. You can then use the
    same methods that we have seen before (`persist`, `delete`, `find`, and `list`)
    against the repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the repository pattern is analogous to the Active Record one.
  prefs: []
  type: TYPE_NORMAL
- en: More complex relationships, such as one-to-many and many-to-many, can be modeled
    on an entity with the relevant annotations (in a similar way to what is doable
    with JPA), and can be retrieved and persisted with both the Active Record and
    Repository approaches. Moreover, Panache provides support for **Hibernate Query
    Language** (**HQL**) for complex queries. So far, we have learned about some of
    the Quarkus extensions and implemented basic APIs, similar to what we saw in the
    *Understanding the most common JEE APIs* section. Let's now see how Quarkus adds
    more features to those APIs by implementing the MicroProfile standard.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus and the MicroProfile standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at the MicroProfile standard and how Quarkus
    implements it. MicroProfile, as previously mentioned many times during this chapter
    (and in particular in the *Introducing MicroProfile* section), is a nice way to
    implement cloud-native microservices applications while adhering to a standard
    and hence avoiding vendor lock-in.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus, in the current version, is compatible with the **3.2 version** of the
    MicroProfile specification. As we have seen, MicroProfile embraces and extends
    the JEE specification while providing features that are useful for cloud-native
    and microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **3.2 version**, the most notable APIs in MicroProfile are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroProfile Config**, which is implemented by the Quarkus configuration,
    which we saw a couple of sections ago'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI and JAX-RS, which we saw in the *The most common Quarkus extensions* and
    *Understanding the most common JEE APIs* sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Fault Tolerance, OpenAPI, Health, OpenTracing, and Metrics, which
    we will see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other APIs, such as JWT authentication, Common Annotations, JSON-B, and JSON-P,
    which we will not cover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has completed our overview on traditional JEE middleware, such as WildFly,
    and cloud-native alternatives, such as Quarkus. Let's have a look at some examples
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will model a very small subset of our mobile payment application.
    To follow up on the concepts we have seen, we will see some examples created for
    WildFly and Quarkus. For both technologies, since we will be interacting with
    a database, we will use H2, which is an easy-to-use open source database. You
    will find all the code in the GitHub repository located at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we''ve said, the prerequisite for our application is to have a database
    up and running. To set it up, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, download the latest version of H2 from the [www.h2database.com](http://www.h2database.com)
    website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then simply run the executable script for your platform, located under
    the `bin` directory. In my case, it was `h2.sh`. It will require a correctly installed
    JVM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the database starts, the default browser will be opened, and the embedded
    H2 web console will be available. If you''re using H2 for the first time, it will,
    by default, try to connect in the embedded mode and create a test database in
    your `home` directory. You can log in with the default login credentials (which
    are `sa` as the username, with no password). The following screenshot shows the
    web console login screen, with all the needed configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The H2 login form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The H2 login form
  prefs: []
  type: TYPE_NORMAL
- en: 'After you log in, you will be presented with a form to manipulate your newly
    created database. In order to create the `payment` table, you can copy and paste
    this SQL code into the SQL input form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using H2 in embedded mode. This means that only one
    connection at a time will be allowed. So, before continuing with our examples,
    we will need to stop the `H2` Java process to allow WildFly to connect to the
    database. You can then reconnect with the web console by simply relaunching `H2`
    and using a different JDBC URL to connect in server mode. In my case, the string
    is as follows, and this allows more than one concurrent connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Also, another option is to completely skip this part and leave the table creation
    to Hibernate by leveraging the `hbm2ddl` configuration. I don't love this option,
    but it's still a viable alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, consider that this is, of course, a simple example. In a real-world
    application, we would need some more tables (such as a `user` table). We would
    probably need to double-check our SQL statements with a DBA to check our data
    types against potential performance issues, depending on the expected volumes,
    or, most likely, we would have to interact with a database that's already been
    created for us. Now that we have a simple database, let's see how to interact
    with it by using WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: JPA and REST with JEE and WildFly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to start developing our JEE application, you will need to start from
    an empty project (in our case, with Maven support). There are many ways to do
    that. The easiest one is to clone the project related to this chapter on GitHub
    and reuse the `pom.xml` and the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you can install and use (see the `Readme` file from GitHub)
    the WildFly Maven archetype located at [https://github.com/wildfly/quickstart](https://github.com/wildfly/quickstart).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step of our example is accessing the table we just created via JPA.
    To do so, you will have to create an entity mapping to the table. As we saw in
    previous sections, the syntax is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you see, we are using the same names defined in the database (both for identifying
    the table name, which corresponds to the class name, and the column names, which
    are linked to the class field names). Different mapping is possible with the proper
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to manipulate our entity, we are going to use the repository pattern.
    Hence, we will create a `PaymentRepository` class, inject `EntityManager`, and
    use it for JPA operations. For the sake of simplicity, we will simply implement
    the `create` and `find` functionalities, but of course, these can be extended
    to cover all other possible requirements, such as finding by column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece in this basic example is exposing the application using RESTful
    Web Services. To do so, we will need to create our `PaymentResource` class and
    annotate it accordingly, as we saw in the *REST services with JAX-RS* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The notable thing here is that the `PaymentRepository` class, which we created
    previously, is injected using CDI and used from within the other methods. The
    two other methods, implementing REST capabilities (`find` and `create`), are annotated
    with `@GET` and `@POST`. The parameters for the `find` method are passed as `@PathParam("id")`,
    using the relevant annotation. The parameter for the `create` method is passed
    as a `Payment` object. The JSON serialization and deserialization are handled
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to activate the REST subsystem, as mentioned, the simplest way is
    to create a class that extends `javax.ws.rs.core.Application` and annotate it
    by defining the root application path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to configure the connection between the application server
    and the database.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly ships with an example data source on H2, which is already configured
    in the default `standalone.xml` file. In order to configure the WildFly server
    to use the H2 database that we created in the previous section, we will have to
    change the `jdbc` connection string from `jdbc:h2:mem:test` to `jdbc:h2:tcp://localhost/~/test`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we didn't set a password in the H2 server for the database connection,
    so you will need to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our example application use such data source, you will need to change
    the `persistence.xml` JNDI name to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, you will also need to set the `hibernate` dialect to H2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now everything is ready for deployment. First of all, we will start WildFly
    (in this case, by simply running `/bin/standalone.sh`). Then, we will package
    the application using a simple `mvn clean package` command. For development purposes,
    we can then deploy the compiled `.war` file to WildFly by copying it into the
    `/standalone/deployments` directory in the WildFly installation folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, you can then interact with REST services with
    this sample application. As an example, by using `curl` at the command line, you
    can create a payment like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have now created a simple but complete JEE example of a REST application
    interacting with a database using JPA. We will use the same application and see
    what will change when we use Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: JPA and REST (and more) with Quarkus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a skeleton application with Quarkus, using all the technology that
    we need, we can simply go to `code.quarkus.io` and select the technology that
    we need, which in our case is JAX-RS, `.zip` file with the right scaffold to start
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative is to use the Maven command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This command is invoking the Quarkus Maven plugin, asking to create a new project,
    and defining the group ID and artifact ID to use. It specifies the name of a class
    exposing REST services and the path under which the services will be published.
    It also defines a number of extensions to be included, such as RESTEasy and Hibernate.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new project is created, you can copy and paste the code developed for
    JEE into this project. In particular, you can override the content of `/src/main/java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the CDI to work, we need to configure the database connection. You have
    to add the following properties in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! This is the bare-minimum change required to make the application
    work in Quarkus. You can launch it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These are the test methods that are exposed as a REST service (take into account
    that the Quarkus application is deployed as the root context, so you will have
    to remove the name of the application – in our case, `hosawj` – from the REST
    endpoints). Of course, you can also package the application in any other way that
    we have seen (for example, in a native executable or as a fat JAR).
  prefs: []
  type: TYPE_NORMAL
- en: But that's the simplest way to move a simple application from JEE to Quarkus.
    You are not using any advanced feature of Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple enhancement is to expose the OpenAPI and Swagger UI. It''s trivial
    to enable these features. You just need to add the relevant extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The OpenAPI for your application will now be exposed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Swagger UI will now be exposed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, but not least, it''s advisable to simplify the ORM part by using Panache.
    To do so, you can use the existing repository and simply make it extend `PanacheRepository<Payment>`.
    Then, you will automatically have a lot of convenient ORM methods available, and
    you don''t have to explicitly manage `EntityManager`. Your repository will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It will be very easy to simply extend using methods provided by Panache. If
    you prefer, it will be also very easy to get rid of the repository and implement
    an Active Record pattern, as discussed in the *Accelerated ORM development with
    Panache* section.
  prefs: []
  type: TYPE_NORMAL
- en: This will close our example section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen a very quick overview of the JEE specification
    and some very interesting alternatives, such as MicroProfile and Quarkus, which
    are certified MicroProfile implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the JEE standard and why it's so popular. We also learned
    about the basic usage of the WildFly application server, along with some widely
    used JEE APIs, including RESTful Web Services, JMS messaging, and JPA persistence.
    We also learned about the MicroProfile standard, a modern alternative to JEE,
    and the Quarkus framework, which implements the MicroProfile standard. We also
    learned about some Quarkus extensions, including RESTful Web Services, JMS messaging,
    and persistence with Panache.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more Quarkus cloud-native features in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, instead, we will continue our discussion on the concept
    of middleware by having a look at the world of application integration.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snyk, *JVM Ecosystem Report* ([res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf](http://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: David Delabassee, *Opening Up Java EE* ([blogs.oracle.com/theaquarium/opening-up-ee-update](http://blogs.oracle.com/theaquarium/opening-up-ee-update))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimitris Andreadis, *JBoss AS7 Reloaded* ([www.slideshare.net/dandreadis/jboss-as7-reloaded](http://www.slideshare.net/dandreadis/jboss-as7-reloaded))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat, *The WildFly Community Official Documentation* ([docs.wildfly.org](http://docs.wildfly.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Foundation, *The Jakarta EE Tutorial*, ([eclipse-ee4j.github.io/jakartaee-tutorial](http://eclipse-ee4j.github.io/jakartaee-tutorial))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat, *Undertow* ([undertow.io](http://undertow.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Fowler, *Patterns of Enterprise Application Architecture*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux Foundation, *OpenApi* ([openapis.org](http://openapis.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SmartBear, *Swagger* ([swagger.io](http://swagger.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
