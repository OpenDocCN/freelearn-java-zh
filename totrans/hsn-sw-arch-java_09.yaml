- en: 'Chapter 7: Exploring Middleware and Frameworks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：探索中间件和框架
- en: In this chapter, we will start talking about the concept of middleware and how
    it has evolved over time. In particular, we will focus on the **Java Enterprise
    Edition** (**JEE**) standard, including the **Jakarta EE** transition. We will
    see a notable open source implementation, which is **WildFly** (formerly known
    as **JBoss Application Server**), and we will start exploring how the concept
    of middleware is evolving into cloud-native frameworks – in our case, **Quarkus**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始讨论中间件的概念以及它是如何随着时间的推移而演变的。特别是，我们将重点关注**Java企业版**（**JEE**）标准，包括**Jakarta
    EE**的过渡。我们将看到一个值得注意的开源实现，即**WildFly**（以前称为**JBoss应用服务器**），并且我们将开始探索中间件概念如何演变成云原生框架——在我们的案例中，是**Quarkus**。
- en: 'You will learn the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中将学习以下主题：
- en: The JEE standard
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEE标准
- en: The WildFly application server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WildFly应用服务器
- en: The most common JEE APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常见的JEE API
- en: Beyond JEE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越JEE
- en: Quarkus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus
- en: Our picture of middleware will be completed in the next chapter, in which we
    will see the approach to integration, which is another cornerstone of what's traditionally
    called middleware.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对中间件的看法将在下一章中完成，我们将看到集成方法，这是传统上所说的中间件的另一个基石。
- en: After reading this chapter, you will know the differences and similarities between
    the JEE standard and its cloud-native alternative, MicroProfile. Moreover, we
    will have seen the most common and useful APIs provided by both standards.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将了解JEE标准和其云原生替代品MicroProfile之间的差异和相似之处。此外，我们将看到这两个标准提供的最常见和最有用的API。
- en: But first of all, let's start with the most popular middleware standard for
    Java developers, which is, of course, JEE.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们从Java开发者中最受欢迎的中间件标准开始，当然是JEE。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please make sure that you have a supported **Java Virtual Machine** (**JVM**)
    installed on your machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的机器上安装了受支持的**Java虚拟机**（**JVM**）。
- en: 'You can find the source code used in this chapter on GitHub: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的源代码：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter7)。
- en: Introducing the JEE standard
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍JEE标准
- en: We (as programmers, who are well versed with the digital world) know that Java
    is a powerful and expressive language. It is a widely used tool for building applications,
    both in a traditional way (as it is already done in a majority of enterprise contexts)
    and more and more in a cloud-native way too (as we will see in this chapter).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们（作为对数字世界了如指掌的程序员）知道Java是一种强大且表达力丰富的语言。它是构建应用程序的广泛使用工具，无论是以传统方式（正如它已经在大多数企业环境中那样）还是越来越多地以云原生方式（正如我们将在本章中看到的那样）。
- en: According to the JVM Ecosystem Report 2021 by Snyk, roughly 37% of production
    applications use JEE (with Java EE, referring to the older version, still being
    used by a majority compared to newer JakartaEE implementations). Spring Boot counts
    for 57%, while Quarkus, which we are going to see in this chapter, is growing
    and is currently at 10%.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据2021年Snyk的JVM生态系统报告，大约37%的生产应用程序使用JEE（与Java EE相比，较老版本仍然被大多数使用，而较新的JakartaEE实现则较少）。Spring
    Boot占57%，而我们将在本章中看到的Quarkus正在增长，目前占10%。
- en: So, Java doesn't need an introduction per se. Everybody (at least, everybody
    who is reading this book) knows that it's a powerful and expressive language that
    aims to be available across platforms (write once, run everywhere – I love it!)
    and that it is based on the compilation of bytecode, which can then be executed
    by the virtual machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Java本身并不需要介绍。每个人（至少，阅读这本书的每个人）都知道它是一种强大且表达力丰富的语言，旨在跨平台可用（一次编写，到处运行——我爱它！）并且它基于字节码的编译，这些字节码随后可以被虚拟机执行。
- en: It's a technology platform that includes a programming language, specifications,
    documentation, and a set of supporting tools, including runtimes (the JVM), a
    compiler, and so on. The tools are provided by different vendors (with the major
    ones being Oracle, IBM, and Red Hat) and comply with the standards. The language
    is currently owned by Oracle. So far, so good.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个包含编程语言、规范、文档以及一系列支持工具的技术平台，包括运行时（JVM）、编译器等。这些工具由不同的供应商提供（主要供应商包括Oracle、IBM和Red
    Hat），并符合标准。目前，该语言由Oracle拥有。到目前为止，一切顺利。
- en: Then, we have the **Enterprise Edition**. There are a number of standards that
    are not really needed in the *plain* version of the Java technology. Features
    such as transactions and messaging are specifically targeted at server-side enterprise
    scenarios, such as banking applications, CRMs, and ERPs. For this reason, such
    features are standardized as an extension of the Java platform, namely the Enterprise
    Edition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有**企业版**。Java技术的**纯**版本实际上并不需要许多标准。如事务和消息传递等功能专门针对服务器端企业场景，例如银行应用、CRM和ERP。因此，这些功能被标准化为Java平台的一个扩展，即企业版。
- en: However, in 2017, Oracle decided to donate the rights of the Enterprise Edition
    to the Eclipse open source community while holding the rights to the Java language
    (and brand). For this reason, the Enterprise Edition has been renamed Jakarta
    EE after a community vote.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在2017年，Oracle决定将企业版的权利捐赠给Eclipse开源社区，同时保留对Java语言（和品牌）的权利。因此，经过社区投票，企业版已被更名为Jakarta
    EE。
- en: This transition caused some slight changes in the specification process, basically
    making it more open to cooperation and less linked to just one vendor. The old
    process was named the **Java Community Process** (**JCP**), while the new one
    is called the **Eclipse Foundation Specification Process** (**EFSP**). The most
    important concepts stay the same, such as the **Java Specification Request** (**JSR**),
    which is a way of specifying the new features, and the **Technology Compatibility
    Kits** (**TCKs**), which are used to certify adherence to the standard. Jakarta
    starts from version **8**, based on **Java EE 8**. At the time of writing, **Jakarta
    EE 9** is available. The examples in this chapter are tested against **JEE 8**
    (because it's the most widely used version right now) but should work properly
    in **JEE 9** too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这次过渡导致在规范过程中产生了一些轻微的变化，基本上使其更开放于合作，并且不再仅仅与一家供应商相关联。旧的过程被称为**Java社区进程**（**JCP**），而新的过程被称为**Eclipse基金会规范流程**（**EFSP**）。最重要的概念保持不变，例如**Java规范请求**（**JSR**），它是一种指定新功能的方式，以及**技术兼容性工具包**（**TCKs**），用于认证对标准的遵守。Jakarta从**版本8**开始，基于**Java
    EE 8**。在撰写本文时，**Jakarta EE 9**已经可用。本章中的示例针对**JEE 8**（因为它是目前最广泛使用的版本）进行测试，但也应在**JEE
    9**中正常工作。
- en: It's worth noting that in this section, we will install the WildFly application
    server in order to start playing with JEE (and later on, we will start working
    with Quarkus to learn about MicroProfile). In both cases, the only requirement
    on your machine is a compatible version of the JVM. If you are in doubt, you can
    download the version you need for free from the OpenJDK website ([http://openjdk.java.net/](http://openjdk.java.net/)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在本节中，我们将安装WildFly应用服务器，以便开始尝试使用JEE（稍后，我们将开始使用Quarkus来学习MicroProfile）。在这两种情况下，您机器上的唯一要求是兼容版本的JVM。如果您有疑问，您可以从OpenJDK网站免费下载您需要的版本（[http://openjdk.java.net/](http://openjdk.java.net/))。
- en: Diving into JEE implementations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入JEE实现
- en: As we said, the JEE specification (before and after the transition to Jakarta)
    provides TCKs. TCKs are suites of tests to certify compliance with the JEE standards.
    JEE currently provides a full profile and a web profile. The web profile is basically
    a subset of the specifications included in the full profile, aiming at a lighter
    implementation for some scenarios.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，JEE规范（在过渡到Jakarta之前和之后）提供TCKs。TCKs是一套用于认证符合JEE标准的测试。JEE目前提供完整配置文件和Web配置文件。Web配置文件基本上是完整配置文件中包含的规范的一个子集，旨在为某些场景提供更轻量级的实现。
- en: 'There are a number of application servers that are JEE compliant. In my personal
    experience, the most widely adopted servers are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多符合JEE规范的应用服务器。根据我个人的经验，最广泛采用的服务器如下：
- en: '**WildFly** is a fully open source JEE application server, and it has a commercially
    supported version named JBoss Enterprise Application Platform (by Red Hat).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WildFly** 是一个完全开源的 JEE 应用服务器，它有一个名为 JBoss Enterprise Application Platform（由
    Red Hat 支持）的商业版本。'
- en: '**WebSphere Application Server**, developed by IBM, is distributed in many
    different versions, including the open source Open Liberty.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 IBM 开发的 **WebSphere Application Server** 以许多不同的版本分发，包括开源的 Open Liberty。
- en: '**Oracle WebLogic Server** is developed and distributed by Oracle (the full
    profile only).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Oracle 开发和分发的 **Oracle WebLogic Server**（仅限完整配置文件）。
- en: Among the other servers fully implementing JEE specifications, Payara and GlassFish
    are worth mentioning. There are also a number of other interesting projects (such
    as Tomcat and Jetty) that are not fully JEE certified, but they implement most
    of the APIs and can plug into some of the others via external dependencies. In
    this chapter, we will work with WildFly, but thanks to the JEE standard, if we
    change some dependencies, everything should work in the other servers too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全实现 JEE 规范的其他服务器中，Payara 和 GlassFish 值得一提。还有一些其他有趣的项目（如 Tomcat 和 Jetty），它们并未完全获得
    JEE 认证，但实现了大部分 API，并且可以通过外部依赖连接到其他一些服务器。在本章中，我们将使用 WildFly，但多亏了 JEE 标准，如果我们更改一些依赖项，其他服务器也应该能够正常工作。
- en: Introducing the WildFly application server
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 WildFly 应用服务器
- en: WildFly is by far the application server that I've come across most often in
    my daily job. It's probably the most widespread Java application server. It was
    renamed from JBoss, as a contraction of `JBoss.org`), and the product family commercially
    supported by Red Hat (including **JBoss EAP**).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 是我在日常工作中遇到的最常见的应用服务器。它可能是最广泛使用的 Java 应用服务器。它曾更名为 JBoss，作为 `JBoss.org`
    的缩写），并由 Red Hat 商业支持的产品系列（包括 **JBoss EAP**）。
- en: It is worth mentioning that JBoss EAP is made of the same components as WildFly.
    There are no hidden features available in the commercial distribution. JBoss EAP
    is simply a frozen distribution of the WildFly components at a certain version,
    which is used to provide stability, certifications, and commercial support for
    enterprise environments. WildFly is developed in Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，JBoss EAP 由与 WildFly 相同的组件组成。商业发行版中没有隐藏的功能。JBoss EAP 简单地是在某个版本上冻结的 WildFly
    组件的发行版，用于为企业环境提供稳定性、认证和商业支持。WildFly 使用 Java 开发。
- en: Exploring the WildFly architecture
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 WildFly 架构
- en: If you have had a decent experience with WildFly, you may remember that JBoss
    used to be huge and sometimes slow. For this reason, a long time ago (around 2011),
    the server, then named **JBoss AS 7**, was rearchitected from the ground up. The
    resulting version was a modular and fast application server, which provided the
    basis for all the later releases (including the current one).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经有过不错的 WildFly 使用体验，你可能还记得 JBoss 以前很大，有时速度较慢。因此，很久以前（大约在 2011 年），当时名为 **JBoss
    AS 7** 的服务器从底层进行了重构。结果是模块化和快速的应用服务器，为所有后续版本（包括当前版本）提供了基础。
- en: Major changes were about class loading (made more granular), core feature implementation
    (moved to a modular, lazy-loading system), management, and configuration (unified
    into one single file). The result of this rearchitecting was then used for the
    **JBoss EAP 6** (and the following versions) commercial distribution. The latest
    version of WildFly (**22.0**) starts on my laptop in around 1 second. WildFly
    can be started in standalone mode (everything running in one Java process) or
    in domain mode, which is a way to centrally manage a fleet of instances from a
    single point.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变化涉及类加载（变得更加细粒度）、核心功能实现（转移到模块化、懒加载系统）、管理和配置（统一到一个单独的文件）。这次重构的结果被用于 **JBoss
    EAP 6**（及其后续版本）的商业发行版。最新的 WildFly 版本（**22.0**）在我的笔记本电脑上启动大约需要 1 秒。WildFly 可以以独立模式启动（所有内容都在一个
    Java 进程中运行）或以域模式启动，这是一种从单个点集中管理实例的方式。
- en: 'Important Note:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: A very common misconception is the overlapping of the concept of domain with
    the concepts of clustering and high availability. They are actually orthogonal
    concepts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的误解是将域的概念与集群和高可用性的概念混淆。实际上，它们是正交的概念。
- en: We can have an arbitrary number of standalone servers, individually managed
    and configured to be clustered in a highly available fashion, or a domain managing
    a fleet of non-clustered instances. Also, it's worth noting that we can have multiple
    server instances on a single machine (whether a physical or virtual host) by operating
    different port offsets (to avoid TCP port clashing) and different subdirectories.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有任意数量的独立服务器，每个服务器单独管理和配置，以高度可用性方式集群，或者一个域管理一队非集群实例。还值得注意的是，我们可以在单个机器上（无论是物理主机还是虚拟主机）运行多个服务器实例，通过操作不同的端口偏移量（以避免
    TCP 端口冲突）和不同的子目录。
- en: 'The server is distributed as a `.zip` file and the most significant folders
    are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器以 `.zip` 文件的形式分发，最显著的文件夹如下：
- en: '`bin` directory: This contains the executable scripts (both for `.sh` and `.bat`)
    for starting the server, along with some other utilities, such as for adding users
    and configuring vaults.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin` 目录：它包含启动服务器的可执行脚本（包括 `.sh` 和 `.bat`），以及一些其他实用程序，例如添加用户和配置保险库。'
- en: '`modules` directory: This contains the system dependencies of the application
    server, which implement the core JEE features (and other supporting subsystems).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules` 目录：它包含应用程序服务器的系统依赖项，实现了核心 JEE 功能（以及其他支持子系统）。'
- en: '`standalone` directory: This is used as a root directory when the server is
    started in standalone mode. It includes subdirectories such as `configuration`
    (used for storing configuration files), `data` (where the persistent data from
    the deployed applications is stored), `tmp` (used to store temporary files used
    by applications), `log` (the default location for the server and applications
    logfiles), and `deployments` (which can be used to deploy applications by dropping
    deployable files and is used for development purposes).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`standalone` 目录：当服务器以独立模式启动时，用作根目录。它包括如 `configuration`（用于存储配置文件）、`data`（存储已部署应用程序的持久数据）、`tmp`（用于存储应用程序使用的临时文件）、`log`（服务器和应用程序日志文件的默认位置）和
    `deployments`（可以通过放置可部署文件来部署应用程序，并用于开发目的）等子目录。'
- en: '`domain` directory: This is similar to `standalone`, but it doesn''t contain
    the `deployments` folder (which is used for drop-in deployment, which is when
    we deploy new applications by copying the artifact in the directory and expect
    the application server to pick it and deploy it. This is not supported in domain
    mode). It contains a `content` directory (supporting some system functionalities,
    specific to the domain operating mode) and a `server` directory, which contains
    a subdirectory for each server instance hosted in the current machine, in turn
    containing `tmp`, `data`, and `log` folders used by that particular server.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain` 目录：这与 `standalone` 类似，但它不包含 `deployments` 文件夹（用于即插即用部署，即通过复制目录中的工件并期望应用程序服务器选择并部署它。在域模式下不支持此功能）。它包含一个
    `content` 目录（支持一些特定于域操作模式的系统功能）和一个 `server` 目录，该目录包含当前机器上每个服务器实例的子目录，依次包含该特定服务器使用的
    `tmp`、`data` 和 `log` 文件夹。'
- en: So far, we've been introduced to the WildFly architecture; now let's see how
    to run a WildFly server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了 WildFly 架构；现在让我们看看如何运行 WildFly 服务器。
- en: Running the WildFly server
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 WildFly 服务器
- en: For the sake of this chapter, we will be running the WildFly server in standalone
    mode. Before we get started, please make sure that you have a supported JVM installed
    on your machine. We will need to download the latest server distribution from
    [https://www.wildfly.org/downloads/](https://www.wildfly.org/downloads/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将以独立模式运行 WildFly 服务器。在我们开始之前，请确保您的机器上已安装支持的 JVM。我们需要从 [https://www.wildfly.org/downloads/](https://www.wildfly.org/downloads/)
    下载最新的服务器发行版。
- en: 'We''ll use the following steps to install the WildFly server runtime:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤来安装 WildFly 服务器运行时：
- en: 'After downloading the required suitable files, we''ll unzip them and run the
    following command on the terminal:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载所需的合适文件后，我们将解压缩它们，并在终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also use the `.bat` script (if you are on Windows) to run the server.
    We get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `.bat` 脚本（如果您使用的是 Windows）来运行服务器。我们得到以下输出：
- en: '![Figure 7.1 – Initializing WildFly'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 初始化 WildFly'
- en: '](img/Figure_7.1_B16354.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16354.jpg)'
- en: Figure 7.1 – Initializing WildFly
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 初始化 WildFly
- en: Once the server is started, we can deploy our application by dropping our artifact
    (`.jar` / `.war` / `.ear`) into the `deployments` folder (which is not advised
    for production purposes) or, better yet, we can deploy by using the JBoss **Command-Line
    Interface** (**CLI**).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们可以通过将我们的工件（`.jar` / `.war` / `.ear`）放入`deployments`文件夹（不建议用于生产目的）或更好的是，我们可以通过使用JBoss
    **命令行界面**（**CLI**）来部署我们的应用程序。
- en: 'The JBoss CLI can be executed by running the `jboss-cli.sh` (or `.bat`) script
    from the `bin` directory. The CLI can be used to connect, configure, and manage
    WildFly setups (both locally and over the network). In order to use it to connect
    to a local standalone WildFly instance, we can simply use this command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过从`bin`目录运行`jboss-cli.sh`（或`.bat`）脚本来执行JBoss CLI。CLI可以用来连接、配置和管理WildFly设置（本地和通过网络）。为了使用它连接到本地独立WildFly实例，我们可以简单地使用以下命令：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will then enter the interactive WildFly CLI. To deploy our application,
    we can use this command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将进入交互式的WildFly CLI。要部署我们的应用程序，我们可以使用以下命令：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then exit the WildFly CLI with the `exit` command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`exit`命令退出WildFly CLI：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know the basics of configuring and operating the WildFly server,
    we can start playing with simple JEE examples.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了配置和操作WildFly服务器的基础知识，我们可以开始尝试简单的JEE示例。
- en: Understanding the most common JEE APIs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解最常用的JEE API
- en: Now that we have seen an overview of the JEE technology and implemented it with
    application servers, we will learn about the most common JEE APIs that are used
    in enterprise projects. We will have a look at some examples of those APIs at
    the end of this chapter, in the *Case studies and examples* section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JEE技术的概述并使用应用服务器实现了它，我们将学习在企业项目中使用的最常见JEE API。我们将在本章末尾的*案例研究和示例*部分查看这些API的一些示例。
- en: Dependency injection
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: I remember the times when dependency injection was simply not available in JEE,
    and we had to rely exclusively on **EJB version 2** (unfortunately) to wire our
    dependencies. This was probably one of the reasons behind the growth in popularity
    of the Spring Framework, which became widespread by offering a lightweight alternative
    to wiring, based on dependency injection, and avoiding verbose and error-prone
    configuration files. But that's another story that is out of the scope of this
    book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得那些在JEE中依赖注入还不存在的时候，我们不得不完全依赖于**EJB版本2**（遗憾的是）来连接我们的依赖。这可能是Spring框架流行增长的原因之一，它通过提供基于依赖注入的轻量级替代方案，避免了冗长且易出错的配置文件，从而变得广泛流行。但这又是另一个超出本书范围的故事。
- en: '**Dependency Injection** (**DI**) or **Contexts and Dependency Injection**
    (**CDI**) is a concept that extends and implements the **Inversion of Control**
    (**IoC**) principle. The idea here is that instead of letting each class instantiate
    the required classes, we can let an external entity (sometimes referred to as
    an IoC container) do that. This allows us to just use Java interfaces at design
    time and lets the container pick the right implementations, thus boosting flexibility
    and decoupling. Moreover, the CDI concept rationalizes the application structure
    by making the wiring points of one class with the others explicit.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）或**上下文与依赖注入**（**CDI**）是一个扩展并实现**控制反转**（**IoC**）原则的概念。这里的想法是，我们不必让每个类实例化所需的类，而是可以让一个外部实体（有时被称为IoC容器）来做这件事。这使我们能够在设计时仅使用Java接口，并让容器选择正确的实现，从而提高灵活性和解耦。此外，CDI概念通过使一个类与其他类的连接点明确，合理化了应用程序的结构。'
- en: In the current implementations of the CDI standard (`@Inject` annotation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在CDI标准的当前实现中（`@Inject`注解）。
- en: By marking a field (or a setter method, or a constructor) of our class with
    this annotation, we are basically telling the framework that we want that field
    instantiated and provided for us. The container tries to identify a class in the
    application that may satisfy that dependency. The objects that can be injected
    are almost any kind of Java class, including special things that provide access
    to JEE services, such as persistence context, data sources, and messaging.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的类的一个字段（或setter方法，或构造函数）上标记这个注解，我们基本上是在告诉框架我们希望该字段被实例化并提供给我们。容器试图在应用程序中识别一个可能满足该依赖的类。可以注入的对象几乎可以是任何类型的Java类，包括提供对JEE服务访问的特殊事物，如持久化上下文、数据源和消息传递。
- en: '*But how does the container identify the class to use?* Skipping the trivial
    case in which just one possible implementation is provided, of course, there are
    ways to define which compatible class to inject. One way is to use qualifiers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是容器是如何识别要使用哪个类的呢？* 跳过只提供一种可能实现的情况，当然，有方法来定义注入哪个兼容的类。一种方法就是使用限定符。'
- en: '`@Named` annotation. With this annotation, we can provide each compatible class
    with a name and then specify which one to use in the injection.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Named` 注解。使用这个注解，我们可以为每个兼容的类提供一个名称，然后指定在注入时使用哪一个。'
- en: Last, but not least, it's possible to mark a class with `@Default` and the other
    implementations with `@Alternatives` to identify which one we want to be selected.
    `@Alternatives` can then be given an order of priority.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，可以使用 `@Default` 标记一个类，并用 `@Alternatives` 标记其他实现，以标识我们想要选择哪一个。`@Alternatives`
    可以指定优先级顺序。
- en: 'CDI also provides the management of the life cycle of the objects, which means
    when the objects should be created and when they should be destroyed. The CDI
    scopes are configured by using annotations, as per the injection that we have
    just seen. The most commonly used scopes are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 还提供了对象生命周期的管理，这意味着对象应该在何时创建和何时销毁。CDI 范围是通过使用注解配置的，正如我们刚才看到的注入一样。最常用的范围如下：
- en: '**@ApplicationScoped**: This binds the creation and destruction of the objects
    with the life cycle of the whole application. This means that one instance is
    created at application startup and destroyed at shutdown. Only one instance will
    be managed by the container and shared by all the clients. In this sense, this
    annotation is an implementation of the singleton pattern.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@ApplicationScoped**：这会将对象的创建和销毁与整个应用程序的生命周期相关联。这意味着在应用程序启动时创建一个实例，并在关闭时销毁。容器将只管理一个实例，并由所有客户端共享。从这个意义上说，这个注解是单例模式的实现。'
- en: '**@Dependent**: This is the default scope that creates a class, which is linked
    to the life cycle of the object using it, and so it''s created and destroyed concurrently
    with the object in which it is injected.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Dependent**：这是默认的范围，创建一个与使用它的对象的生存周期相关联的类，因此它与注入的对象同时创建和销毁。'
- en: '**@SessionScoped**: This links the life cycle of the object with the HTTP session
    in which it is referenced (and so makes it a good tool for storing user and session
    information).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@SessionScoped**：这会将对象的生存周期与它所引用的 HTTP 会话相关联（因此使其成为存储用户和会话信息的好工具）。'
- en: '**@RequestScoped**: This binds the object life cycle to the life cycle of the
    HTTP request where it is referenced.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@RequestScoped**：这会将对象的生命周期绑定到它所引用的 HTTP 请求的生命周期。'
- en: '**@TransactionScoped**: This associates the life cycle of the object with the
    duration of the transactional boundary in which it is utilized.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@TransactionScoped**：这会将对象的生存周期与它所使用的事务边界的持续时间相关联。'
- en: 'Here is the diagram for CDI scopes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CDI 范围的图示：
- en: '![Figure 7.2 – CDI scopes'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.2 – CDI scopes]'
- en: '](img/Figure_7.2_B16354.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.2_B16354.jpg]'
- en: Figure 7.2 – CDI scopes
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – CDI 范围
- en: CDI specifications also provide hooks to specific life cycle events. The most
    commonly used are `@PostConstruct` and `@PreDestroy`, which are called immediately
    after object creation and before destruction, respectively.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 规范还提供了对特定生命周期事件的钩子。最常用的有 `@PostConstruct` 和 `@PreDestroy`，分别是在对象创建后立即调用和销毁前调用。
- en: Jakarta RESTful Web Services
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jakarta RESTful Web Services
- en: Another essential piece of Java applications nowadays is RESTful Web Services.
    The Jakarta EE standard for RESTful Web Services (`JAXRSApplication` class to
    the class path), all we have to do is create a bean for mapping the resource that
    we want to expose and annotate it accordingly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Java应用程序的另一个重要组成部分是 RESTful Web Services。Jakarta EE 标准的 RESTful Web Services（将
    `JAXRSApplication` 类添加到类路径），我们只需要创建一个映射我们想要公开的资源并相应注解的 bean。
- en: In the most common use case, we will have to map the whole class to the path
    we want to expose by annotating the class with the `@Path` annotation. We may
    then want to specify the media types that the class produces and consumes (usually
    JSON) by using the `@Produces` and `@Consumes` annotations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的情况下，我们将不得不通过使用 `@Path` 注解将整个类映射到我们想要公开的路径。然后，我们可能还想通过使用 `@Produces` 和 `@Consumes`
    注解来指定该类产生的和消费的媒体类型（通常是 JSON）。
- en: Each method of the class can be mapped to HTTP methods by using annotations
    such as `@Get`, `@Post`, `@Delete`, `@Put`, and `@Head`, and we can bind these
    methods to sub-paths by using the same `@Path` annotation. As an example, we can
    have the whole class bound to `/myPath` (with `GET`, `POST`, and other HTTP methods
    referring to that path) and then have the specific methods annotated to refer
    to `/myPath/mySubPath`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的每个方法都可以通过使用`@Get`、`@Post`、`@Delete`、`@Put`和`@Head`等注解将其映射到HTTP方法，并且我们可以使用相同的`@Path`注解将这些方法绑定到子路径。例如，我们可以将整个类绑定到`/myPath`（其中`GET`、`POST`和其他HTTP方法引用该路径），然后可以将特定的方法注解为引用`/myPath/mySubPath`。
- en: Another very common scenario is the binding of method parameters with HTTP path
    parameters (`@PathParam`), parameters on the query string (`@QueryParam`), and
    HTTP headers (`@HeaderParam`). We should make a special mention of the **Jakarta
    JSON Binding** (**JSON-B**) specification, which, acting behind the scenes, can
    provide the JSON to **Plain Old Java Objects** (**POJOs**) (and vice versa) mapping
    for our beans, provided that they have a simple structure (and without needing
    any complex configuration). This is true for the most common use cases, meaning
    the Java classes with simple type fields with getters and setters. But of course,
    it's possible to provide customizations and implement special cases, if we need
    to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的场景是将方法参数与HTTP路径参数（`@PathParam`）、查询字符串参数（`@QueryParam`）和HTTP头（`@HeaderParam`）绑定。我们应该特别提及**Jakarta
    JSON Binding**（**JSON-B**）规范，它在幕后工作，可以为我们的bean提供从JSON到**Plain Old Java Objects**（**POJOs**）（反之亦然）的映射，前提是它们具有简单的结构（并且不需要任何复杂的配置）。这对于最常见的用例是正确的，这意味着具有简单类型字段以及getter和setter的Java类。但当然，如果我们需要，我们也可以提供自定义和实现特殊案例。
- en: As part of the JAX-RS specification, we can create REST clients too (to query
    REST services). In order to do that, a common way is to use the `ClientBuilder`
    class, which provides a fluent API to specify the usual parameters of an HTTP
    client (such as timeouts, filters, and similar settings). We can then create a
    so-called `WebTarget` object, which is an object that allows us to specify the
    path to invoke using the client. Acting on `WebTarget`, it is possible to send
    requests by passing parameters and getting results (usually in form of JSON objects).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JAX-RS规范的一部分，我们也可以创建REST客户端（用于查询REST服务）。为了做到这一点，一种常见的方法是使用`ClientBuilder`类，它提供了一个流畅的API来指定HTTP客户端的常用参数（如超时、过滤器以及类似的设置）。然后我们可以创建一个所谓的`WebTarget`对象，这是一个允许我们指定使用客户端调用的路径的对象。在`WebTarget`上操作，我们可以通过传递参数并获取结果（通常是JSON对象的形式）来发送请求。
- en: An interesting twist of the JAX-RS specification is the possibility to manage
    **Server Sent Events** (**SSEs**). SSEs were introduced with the **HTML5** standardization
    and are a way to provide data from a server to a client in the form of events
    by using an open connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS规范的一个有趣之处在于管理**服务器发送事件**（**SSEs**）的可能性。SSEs是在**HTML5**标准化中引入的，它通过使用开放连接以事件的形式从服务器向客户端提供数据。
- en: What happens is that the client initiates the request to the server, but instead
    of getting all the data in one shot and closing the connection, it will keep the
    connection open and fetch the data as it comes from the client (eventually closing
    it at some point, or being disconnected by the server). The advantage here is
    that we can reuse the same connection to reduce the overhead, and we can get (and
    visualize) the data in real time without needing to poll the server for updates.
    The client could be a Java client or a web page in a browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是客户端向服务器发起请求，但不是一次性获取所有数据并关闭连接，而是保持连接打开，并随着数据的到来从客户端获取数据（最终在某个时刻关闭它，或者被服务器断开连接）。这里的优势是我们可以重用相同的连接来减少开销，并且我们可以在不需要轮询服务器以获取更新时实时获取（并可视化）数据。客户端可以是Java客户端或浏览器中的网页。
- en: 'In order to implement this behavior, JAX-RS provides `Sse` and `SseEventSink`
    resources that can be injected into our method with the `@Context` annotation,
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种行为，JAX-RS提供了`Sse`和`SseEventSink`资源，可以使用`@Context`注解将其注入到我们的方法中，如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have those two resources, we can use `sse` to build new events and
    `sseEventSink` to send such events. Once we''ve completed our interactions with
    the client, we can use `sseEventSink` to close the connection:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个资源，我们可以使用`sse`来构建新的事件，并使用`sseEventSink`来发送这些事件。一旦我们与客户端完成交互，我们可以使用`sseEventSink`来关闭连接：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, let''s summarize:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下：
- en: We create an `event` object by invoking `newEventBuilder` on the `sse` object
    injected in our class.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在注入到我们类中的`sse`对象上调用`newEventBuilder`来创建一个`event`对象。
- en: We set `mediaType` to JSON.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`mediaType`设置为JSON。
- en: We add the data we want to send, specifying the class type and the object instance
    containing the data.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加我们想要发送的数据，指定类类型和包含数据的对象实例。
- en: We call the `build` method to create the `event` instance.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`build`方法来创建`event`实例。
- en: We invoke the `send` method on the `eventSink` object, passing the event instance
    we just created.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`eventSink`对象上调用`send`方法，传递我们刚刚创建的事件实例。
- en: Eventually, we can close the connection by calling `close` on the `eventSink`
    object. Of course, in a real-world scenario, we may want to send a number of events
    (such as a consequence of something happening) before closing the connection.
    It doesn't make much sense to have `sse` just to send one event.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，我们可以通过在`eventSink`对象上调用`close`来关闭连接。当然，在现实世界的场景中，我们可能在关闭连接之前发送一系列事件（例如，某件事情发生的结果）。只为发送一个事件而使用`sse`并没有太多意义。
- en: 'One interesting scenario generated by SSE is the possibility to implement broadcast
    scenarios. In such scenarios, instead of having each client connected to a different
    thread (and receiving different messages), we can have clients all receiving the
    same message. In this way, we will have clients subscribing (usually calling a
    specific REST service) and then getting the data (calling another one). Here is
    a code example (simplified):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SSE产生的一个有趣的场景是实现广播场景的可能性。在这种情况下，而不是让每个客户端连接到不同的线程（并接收不同的消息），我们可以让所有客户端接收相同的信息。这样，我们将有客户端订阅（通常调用特定的REST服务）然后获取数据（调用另一个服务）。以下是一个代码示例（简化版）：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s summarize what this code does:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下这段代码做了什么：
- en: We create a `broadcast` method and annotate it to indicate that it will be associated
    with an HTTP `GET` method that is exposed on the `broadcast` path.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`broadcast`方法，并对其进行了注释，表示它将与在`broadcast`路径上公开的HTTP `GET`方法相关联。
- en: This `broadcast` method will be injected with an `sse` object instance present
    in the context.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个`broadcast`方法将被注入一个在上下文中存在的`sse`对象实例。
- en: We create a `broadcaster` object by invoking the `newBroadcaster` method on
    the `sse` object.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在`sse`对象上调用`newBroadcaster`方法来创建一个`broadcaster`对象。
- en: We create an `OutboundSseEvent` object by invoking the `newEventBuilder` method
    on the `sse` object.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在`sse`对象上调用`newEventBuilder`方法来创建一个`OutboundSseEvent`对象。
- en: We set `mediaType` to JSON.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`mediaType`设置为JSON。
- en: We add the data we want to send, specifying the class type and the object instance
    containing the data.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加我们想要发送的数据，指定类类型和包含数据的对象实例。
- en: We call the `build` method to create the `event` instance. We invoke the `broadcast`
    method on the `broadcaster` object, passing the `event` instance we just created.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`build`方法来创建`event`实例。我们在`broadcaster`对象上调用`broadcast`方法，传递我们刚刚创建的`event`实例。
- en: We create a `subscribe` method and annotate it to indicate that it will be associated
    with an HTTP `GET` method that is exposed on the `subscribe` path and that will
    produce answers with the `SERVER_SENT_EVENTS` media type.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`subscribe`方法，并对其进行了注释，表示它将与在`subscribe`路径上公开的HTTP `GET`方法相关联，并且将使用`SERVER_SENT_EVENTS`媒体类型生成答案。
- en: The `subscribe` method will be injected with an `SseEventSink` object instance
    present in the context.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`方法将被注入一个在上下文中存在的`SseEventSink`对象实例。'
- en: We create an instance of a `broadcaster` object by invoking the `newBroadcaster`
    method on the `sse` instance.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在`sse`实例上调用`newBroadcaster`方法来创建一个`broadcaster`对象实例。
- en: We register `sseEventSink` by passing it to the `register` method on the `broadcaster`
    object.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将`sseEventSink`传递给`broadcaster`对象的`register`方法来注册它。
- en: 'On the client side, we will most likely interact with SSE by using a framework
    such as Vue or Angular. But in any case, under the hood it will use the JavaScript
    `EventSource` object:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们很可能会通过使用Vue或Angular等框架与SSE进行交互。但无论如何，在底层它将使用JavaScript的`EventSource`对象：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As mentioned, we can also interact with SSE by using a Java client. Similar
    to the JavaScript version, the SSE implementation in Java provides an `EventSource`
    object too:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以通过使用Java客户端与SSE进行交互。类似于JavaScript版本，Java中的SSE实现也提供了一个`EventSource`对象：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A personal consideration here is to thoroughly test this kind of implementation
    in real production scenarios and manage and monitor exceptions. We must also consider
    some alternatives in case of unexpected disconnects that may be due to clients
    with unstable connections (such as mobile clients) or network devices misbehaving
    in the overall infrastructure. Frameworks usually also provide some resiliency
    features, such as connection retries (in case the backend is momentarily unavailable).
    Resiliency must be also considered from a backend perspective, hence if a failure
    occurs while sending a message (and an exception is thrown), you should consider
    handling (including retries). But since this is basically non-transactional (because
    of network connections being potentially unreliable), you should consider edge
    cases including duplicate events or message loss.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，个人考虑因素是彻底测试这种实现方式在实际生产场景中的效果，并管理和监控异常情况。我们还必须考虑一些备选方案，以防出现意外的断开连接，这可能是由于客户端（如移动客户端）连接不稳定或网络设备在整体基础设施中表现不佳所导致的。通常，框架也会提供一些弹性功能，例如连接重试（以防后端暂时不可用）。从后端的角度来看，弹性也必须被考虑，因此如果在发送消息时发生故障（并且抛出异常），你应该考虑处理（包括重试）。但由于这基本上是非事务性的（因为网络连接可能不可靠），你应该考虑边缘情况，包括重复事件或消息丢失。
- en: WebSocket
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket
- en: Jakarta EE includes support for WebSocket technology. Using this technology,
    we can implement full-duplex communication between client and server, supporting
    the development of a rich user experience in web applications. WebSocket sits
    directly on top of TCP, so it doesn't rely on HTTP. However, it is compatible
    with HTTP, meaning that, from a connection point of view, it uses a compatible
    handshake and may be transported over HTTP and HTTPS standard ports (`80` and
    `443`), so it is compatible with most network infrastructures.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE包括对WebSocket技术的支持。使用这项技术，我们可以在客户端和服务器之间实现全双工通信，支持在Web应用程序中开发丰富的用户体验。WebSocket直接位于TCP之上，因此它不依赖于HTTP。然而，它与HTTP兼容，这意味着从连接的角度来看，它使用兼容的握手，并且可能通过HTTP和HTTPS标准端口（`80`和`443`）传输，因此它与大多数网络基础设施兼容。
- en: 'In order to implement the WebSocket capabilities on the backend, you need to
    annotate a class with `@ServerEndpoint`, specifying the path on which the capabilities
    will be published. With this class, we can then annotate methods with `@OnMessage`,
    `@OnOpen`, `@OnClose`, and `@OnError` to intercept the message received, the client
    connected, the client disconnected, and error events, respectively. After the
    connection of a client, in the method annotated with `@OnOpen`, it''s possible
    to retrieve and store a session object. This object can then be used to send messages
    to the clients, hence implementing full-duplex communication, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后台实现WebSocket功能，你需要使用`@ServerEndpoint`注解一个类，指定将发布功能的路径。有了这个类，我们就可以使用`@OnMessage`、`@OnOpen`、`@OnClose`和`@OnError`注解方法来拦截接收到的消息、连接的客户端、断开的客户端和错误事件。在客户端连接后，在`@OnOpen`注解的方法中，可以检索和存储一个会话对象。然后可以使用这个对象向客户端发送消息，从而实现全双工通信，如下所示：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we saw when discussing server-sent events, WebSocket's applications are usually
    implemented on the client side using frameworks. However, JavaScript exposes a
    WebSocket object that can be used to mirror the server-side life cycle (`OnOpen`,
    `OnMessage`, and `OnError`) and the message-sending capabilities. As with SSE,
    my suggestion is to test this kind of interaction on an infrastructure that's
    comparable to the production one and be ready with alternatives in case something
    goes wrong with network connectivity, such as having graceful fallbacks. A nice
    implementation of this could be the **circuit breaker** pattern, as we are going
    to see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing
    Cloud-Native Architectures*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论服务器端事件时，WebSocket的应用通常是在客户端使用框架实现的。然而，JavaScript暴露了一个WebSocket对象，可以用来镜像服务器端的生命周期（`OnOpen`、`OnMessage`和`OnError`）以及消息发送能力。与SSE一样，我的建议是在与生产环境相当的基础设施上测试这种交互，并在网络连接出现问题时准备好备选方案，例如实现优雅降级。这种实现的不错例子可以是**断路器模式**，正如我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中看到的，*设计云原生架构*。
- en: Messaging
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传递
- en: '**Messaging** is another key component in modern applications. In the cloud-native
    microservices world, the **Java Message Service** (**JMS**) is considered to be
    an *enterprise-y*, complex manner of communication, often used together with other
    technologies, such as Kafka and AMQP. However, for many years, from **version
    2.0** onward (**3.0** was just released at the time of writing), JMS has become
    very easy to use (at least in basic use cases).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递**是现代应用中的另一个关键组件。在云原生微服务世界中，**Java消息服务**（**JMS**）被认为是一种**企业级**、复杂的通信方式，通常与其他技术一起使用，例如Kafka和AMQP。然而，多年来，从**版本2.0**开始（**3.0**在撰写本文时刚刚发布），JMS已经变得非常容易使用（至少在基本用例中）。'
- en: The idea behind the messaging standard in JEE (which is one of the things I
    like about the application servers in general) is that we can keep the code simple
    and compact and offload the configurations to the application server. This also
    has the advantage of separating the code from the configuration. This also has
    advantages in terms of clarity, portability, and testability.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JEE消息标准的理念（这是我总体上喜欢应用程序服务器的一个原因）是我们可以保持代码简单紧凑，并将配置卸载到应用程序服务器。这也具有将代码与配置分离的优势。这也在清晰度、可移植性和可测试性方面具有优势。
- en: 'In order to send messages, we can use the injection of JEE resources – in this
    case, `JMSContext`. With the same approach, we can inject an object representing
    our target queue. The API then allows us to create a producer from the `JMSContext`
    object and use it to send a message against the queue, such as in the following
    code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送消息，我们可以使用JEE资源的注入——在这种情况下，`JMSContext`。采用相同的方法，我们可以注入一个代表我们目标队列的对象。然后API允许我们从一个`JMSContext`对象创建一个生产者，并使用它向队列发送消息，如下代码片段所示：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With a similar kind of API, we can consume messages by creating a consumer and
    invoking the receive method against it. But this is not how it is done commonly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似类型的API，我们可以通过创建一个消费者并对其调用接收方法来消费消息。但这并不是常见的做法。
- en: 'The most widely used way is to use a `MessageListener` interface and the use
    of some annotations to configure the queue to attach to. The code is quite self-explanatory:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的方法是使用`MessageListener`接口和一些注解来配置要附加到的队列。代码相当直观：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both the consumer (MDB) and the producer example, the code looks for the
    default JMS connection factory, which is supposed to be bound to `java:/ConnectionFactory`.
    It is possible to explicitly state an alternative connection factory if we want
    to (such as when our application server must be connected to different brokers).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者（MDB）和生成器示例中，代码寻找默认的JMS连接工厂，它应该绑定到`java:/ConnectionFactory`。如果我们想的话，可以明确指定一个替代连接工厂（例如，当我们的应用程序服务器必须连接到不同的代理时）。
- en: In order to set the properties to connect to a broker, such as a host, port,
    username, and password (and associate it with a `java:/ConnectionFactory`), we
    will have to configure the application server. This is, of course, specific to
    the server we choose. In WildFly, we commonly do that by using a CLI (as we have
    seen when deploying applications) or by directly editing the configuration file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置连接到代理（如主机、端口、用户名和密码）的属性（并将其与`java:/ConnectionFactory`关联），我们必须配置应用程序服务器。这当然是特定于我们选择的服务器。在WildFly中，我们通常通过使用CLI（正如我们在部署应用程序时所见）或直接编辑配置文件来完成此操作。
- en: Persistence
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: '**Persistence** is often one of the must-have properties for Java EE applications.
    While other persistence alternatives are now widely used, such as NoSQL stores
    and **InMemory** caches, database persistence is unlikely to disappear anytime
    soon.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久性**通常是Java EE应用必须拥有的属性之一。虽然现在其他持久性替代方案（如NoSQL存储和**内存**缓存）被广泛使用，但数据库持久性不太可能在短期内消失。'
- en: Persistence in JEE is regulated by the **Java Persistence API** (**JPA**) specification.
    In the earlier versions, JPA was clumsy and painful to use (as was the EJB specification).
    This is not true anymore, and JPA is now very easy to use. As you may probably
    know, JPA is built around the **Object-Relational Mapping** (**ORM**) idea, which
    aims for relational database tables to be mapped to objects (in our case, Java
    objects).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JEE中的持久性由**Java持久性API**（**JPA**）规范进行管理。在早期版本中，JPA使用起来笨拙且痛苦（EJB规范也是如此）。但这不再是事实，JPA现在非常容易使用。正如你可能知道的，JPA是围绕**对象-关系映射**（**ORM**）理念构建的，旨在将关系数据库表映射到对象（在我们的情况下，Java对象）。
- en: 'So, the first thing to do to use JPA is to define our objects and how they
    map to database tables. As you can imagine, this is easily done by using annotations.
    The relevant annotations here are `@Entity` to identify the class and map it to
    the database, `@ID` to mark the field linked to the primary key, `@GeneratedValue`
    to define the strategy for the key generation, `@Table` to configure the table
    name (which defaults to the class name), and `@Column` to configure the column
    name for each class field (also, in this case, it defaults to the field name).
    This is what the code looks like:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用JPA的第一件事是要定义我们的对象以及它们如何映射到数据库表。正如您所想象的，这可以通过使用注解轻松完成。这里的注解包括`@Entity`来标识类并将其映射到数据库，`@ID`来标记与主键链接的字段，`@GeneratedValue`来定义键生成策略，`@Table`来配置表名（默认为类名），以及`@Column`来配置每个类字段的列名（在这种情况下，它也默认为字段名）。代码看起来是这样的：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After we have our classes linked to our database tables, it's time to interact
    with the database itself. You can easily do that by injecting the so-called `EntityManager`
    where it's needed. The entity manager is associated with a persistence context,
    which is essentially the set of configurations that you set into the application
    and the application server to make it aware of where the database should connect
    to, such as the **Java Database Connectivity** (**JDBC**) string and other properties.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将我们的类链接到数据库表之后，是时候与数据库本身进行交互了。您可以通过注入所谓的`EntityManager`来轻松地做到这一点。实体管理器与一个持久化上下文相关联，这本质上是你设置到应用和应用服务器中的配置集合，使其知道数据库应该连接到何处，例如**Java数据库连接**（**JDBC**）字符串和其他属性。
- en: 'You can use the entity manager to retrieve objects from the database by using
    the JPA query language (which is similar to SQL) to create new objects, delete
    them, and so on. Here is a code example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用实体管理器通过使用JPA查询语言（与SQL类似）来从数据库检索对象，创建新对象，删除它们等。以下是一个代码示例：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, consistent with the other APIs that we have seen so far, JPA
    is pretty easy to use. It will nicely decouple business logic (in your Java code)
    from configuration (in the application server) and standardize the implementation
    of common aspects such as table-to-POJO mapping and transaction usage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，与迄今为止我们所看到的其他API一样，JPA使用起来相当简单。它将很好地将业务逻辑（在您的Java代码中）与配置（在应用服务器中）解耦，并标准化常见方面的实现，例如表到POJO映射和事务使用。
- en: What's missing in Java EE
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java EE缺少什么
- en: One of the reasons why some developers are moving away from the JEE specification
    is that the evolution of the standard is a bit slow. One goal of the platform
    is to include a big list of vendors providing reference implementations and to
    give long-term stability to the standard users, so it will take time to evolve
    JEE. At the time of writing, a number of things were missing from JEE that need
    to be overcome by using third-party libraries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者之所以从JEE规范中移开，其中一个原因是标准的演变有点缓慢。平台的一个目标是要包括一个提供参考实现的厂商大列表，并为标准用户提供长期稳定性，因此JEE的演变将需要时间。在撰写本文时，JEE中缺少一些需要通过使用第三方库来克服的东西。
- en: 'We will try to summarize the most common criticisms in this area:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试总结这个领域中最常见的批评：
- en: '**Observability**: Since the beginning, some advanced monitoring capabilities
    have been missing from the JEE specification. **Java Management Extension** (**JMX**)
    was provided in the Java platform as a first attempt to provide some metrics and
    monitoring, and JDK Mission Control was donated to open source communities, providing
    some more advanced capabilities in terms of profiling.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性**：从开始，一些高级监控能力就缺失在JEE规范中。**Java管理扩展**（**JMX**）作为Java平台提供的一些指标和监控的第一个尝试被提供，JDK
    Mission Control被捐赠给开源社区，提供了更多关于分析的高级功能。'
- en: However, enterprises commonly complement such technologies with third-party
    software, sometimes proprietary software. As of today, more advanced monitoring
    capabilities, such as tracing, are commonly required for fully controlling the
    application behavior in production. Moreover, metric collections and display technologies
    based on stacks such as Prometheus and Grafana have become a de facto standard.
    Observability also includes things such as health and readiness probes, which
    are special services exposed by the application that can be useful for checking
    for application availability (and send an alert or implement some kind of workaround
    if the application is not available).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，企业通常会用第三方软件来补充这些技术，有时甚至是专有软件。截至今天，为了在生产环境中完全控制应用程序的行为，通常需要更高级的监控能力，例如跟踪。此外，基于Prometheus和Grafana等堆栈的指标收集和显示技术已成为一种事实上的标准。可观察性还包括诸如健康和就绪探测这样的内容，这些是应用程序暴露的特殊服务，可用于检查应用程序的可用性（如果应用程序不可用，则发送警报或实施某种形式的解决方案）。
- en: '**Security**: While JEE and Java, in general, are pretty rich in terms of security,
    including role-based access control at different architectural levels, support
    for encryption, multi-factor authentication, and authorization facilities is missing.
    There are some other features, such as OpenID Connect and JSON Web Token, that
    are still missing from the core specification.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：虽然JEE和Java在安全性方面相当丰富，包括不同架构级别的基于角色的访问控制、加密、多因素认证和授权功能，但支持仍然缺失。还有一些其他功能，如OpenID
    Connect和JSON Web Token，仍然缺失在核心规范中。'
- en: '**Fault tolerance**: In heavily decentralized environments, such as microservices
    and cloud-native, it''s crucial to defend the application from issues in external
    components, such as endpoints failing or responding slowly. In JEE, there is no
    standardized way to manage those events (other than normal exception handling).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**：在高度去中心化的环境中，例如微服务和云原生，防御应用程序免受外部组件问题（如端点失败或响应缓慢）的影响至关重要。在JEE中，没有标准化的方式来管理这些事件（除了正常的异常处理之外）。'
- en: '**OpenAPI**: REST services are widespread in the JEE world. However, JEE does
    not specify a way to define API contracts for REST services, as it''s done by
    the OpenAPI standard.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI**：REST服务在JEE世界中很普遍。然而，JEE没有指定定义REST服务API合同的方式，就像OpenAPI标准所做的那样。'
- en: Other features less likely to be standardized, such as alternative datastores
    (think about NoSQL databases) and alternative messaging (such as streaming platforms
    or AMQP), are also missing. All those functionalities are normally added by third-party
    libraries and connectors. As we will see in the upcoming sections, **MicroProfile**
    provides a way to overcome those limitations in a standard way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不太可能标准化的功能，例如替代数据存储（例如NoSQL数据库）和替代消息传递（例如流平台或AMQP），也缺失。所有这些功能通常都是由第三方库和连接器添加的。正如我们将在接下来的章节中看到的，**MicroProfile**提供了一种以标准方式克服这些限制的方法。
- en: What's great about Java EE
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java EE的亮点
- en: 'While some useful and modern technology is missing in the vanilla specification
    of JEE, as we have just said (but can be easily added via third-party libraries
    most of the time, such as what''s provided by the [smallrye.io](http://smallrye.io)
    project), I still think that JEE technology is just great and is here to stay.
    Some reasons are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JEE的基本规范中缺少一些有用的现代技术（但如我们刚才所说，大多数情况下可以通过第三方库轻松添加，例如[smallrye.io](http://smallrye.io)项目所提供的），但我仍然认为JEE技术非常出色，并且会继续存在。以下是一些原因：
- en: '**Vendor ecosystem**: As we saw at the beginning of this chapter, there are
    a number of alternative implementations, both paid and free, providing JEE compatibility.
    This will ensure long-term stability and (where needed) commercial support, which
    can be crucial in some environments.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商生态系统**：正如我们在本章开头所看到的，有许多替代实现，既有付费的也有免费的，提供JEE兼容性。这将确保长期稳定性和（在需要时）商业支持，这在某些环境中可能至关重要。'
- en: '**Operations**: While there is no fixed standard, as each vendor implements
    it in their own way, JEE enforces some configurability points on an application.
    This means that a JEE application can be easily fine-tuned for things such as
    thread pool size, timeouts, and authentication providers. While this is, of course,
    possible even while using other approaches, JEE tends to be more operation-friendly.
    Once the system administrators know about the specifics of the application server
    in use, they can easily change those aspects, regardless of the kind of application
    deployed.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：虽然没有固定的标准，因为每个供应商都以自己的方式实现它，但JEE对应用程序强制实施了一些可配置性点。这意味着JEE应用程序可以很容易地针对线程池大小、超时和身份验证提供者等进行微调。当然，即使使用其他方法，这也是可能的，但JEE通常更易于操作。一旦系统管理员了解了正在使用的应用程序服务器的具体细节，他们就可以轻松地更改这些方面，无论部署的是哪种类型的应用程序。'
- en: '**Battle-tested for enterprise needs**: JEE still provides things that are
    very useful (sometimes essential) in the enterprise world. We are talking about
    distributed transactions, connectors for legacy or enterprise systems, robust
    deployment standards, and so on. You are likely to find some of those features
    in alternative stacks, but they will often be fragmentary and less robust.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经过企业需求考验**：JEE仍然提供了在企业世界中非常有用（有时是必需的）的东西。我们谈论的是分布式事务、对遗留或企业系统的连接器、强大的部署标准等等。你可能会在替代堆栈中找到一些这些功能，但它们通常是不完整的且不够健壮。'
- en: This completes our quick overview of JEE's pros and cons. As you may know, a
    detailed explanation of JEE may take a whole (huge) book. However, in these sections,
    we have seen a simple selection of some basic APIs that are useful for building
    modern applications, including RESTful Web Services, JPA persistence, and messaging.
    We have also seen the pros and cons of the JEE framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对JEE优缺点的快速概述。正如你可能知道的，对JEE的详细解释可能需要一整本书（非常大）。然而，在这些部分中，我们已经看到了一些基本API的简单选择，这些API对于构建现代应用程序非常有用，包括RESTful
    Web服务、JPA持久性和消息传递。我们还看到了JEE框架的优缺点。
- en: In the next section, we will start talking about alternatives to application
    servers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始讨论应用程序服务器的替代方案。
- en: Going beyond Java Enterprise Edition
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越Java企业版
- en: In [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013), *Designing
    Software Architectures in Java – Methods and Styles*, we had a very quick look
    at containerizing Java applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013)，《Java软件架构设计——方法和风格》中，我们非常快速地看了一下容器化Java应用程序。
- en: We will now look into alternatives and extensions to Java Enterprise, including
    lightweight Java servers and **fat JAR** applications. Here, we will see a quick
    overview of why and how to implement fat JAR applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨Java Enterprise的替代方案和扩展，包括轻量级Java服务器和**胖JAR**应用程序。在这里，我们将快速概述为什么要实现胖JAR应用程序以及如何实现。
- en: Packaging microservices applications
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包微服务应用程序
- en: A **fat JAR** (also known as an **Uber JAR**) is likely to be one of the starting
    points in the inception of application service alternatives (and microservices
    runtimes). Frameworks such as Dropwizard, Spring Boot, and, more recently, Quarkus
    have been using this approach.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**胖JAR**（也称为**Uber JAR**）可能是应用程序服务替代方案（以及微服务运行时）的起点之一。例如，Dropwizard、Spring
    Boot和最近出现的Quarkus等框架都采用了这种方法。'
- en: The idea of fat JAR is that you package all you need into a single `.jar` file
    so that we have a self-contained and immutable way to deploy your applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 胖JAR的想法是将所有需要的东西打包到一个单一的`.jar`文件中，这样我们就有了一种自包含且不可变的方式来部署应用程序。
- en: 'The advantages are easy to imagine:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 优势很容易想象：
- en: '`.jar` file.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jar`文件。'
- en: '**Behavior is consistent between different environments**: You can test the
    application on a laptop without needing a full-fledged app server.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为在不同环境中保持一致**：你可以在笔记本电脑上测试应用程序，而无需完整的应用程序服务器。'
- en: '**Full control of the dependencies**: Versions and implementation of the supporting
    libraries are fixed at build time, so you will have fewer variables in production
    (and you are not forced to stick with what the app server provides).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全控制依赖项**：支持库的版本和实现是在构建时固定的，因此在生产中变量会更少（并且你不会被强迫坚持使用应用程序服务器提供的版本）。'
- en: 'Of course, all of this comes at a cost. Here are some not-so-obvious disadvantages
    of this approach:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些都有代价。以下是这种方法的某些不太明显的缺点：
- en: It's less standard (think about configurations). There are some de facto standards,
    such as `.yaml`, application properties files, or system properties. But this
    usually varies from app to app, even when using the same technology stack. Conversely,
    app servers tend to be more prescriptive in terms of what can be configured and
    where to put such configurations.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不太标准化（想想配置）。有一些既定标准，例如`.yaml`、应用程序属性文件或系统属性。但通常这些会因应用程序而异，即使使用相同的技术栈也是如此。相反，应用服务器在配置什么可以配置以及在哪里放置这些配置方面往往更为具体。
- en: While you can pick and choose the dependencies you need, you have to carry over
    such dependencies with each deployment (or scale). And if you use many dependencies,
    this will be impactful in terms of network usage and time lost (and compiling
    time too). With the application servers, you take for granted that such dependencies
    are already waiting for you in the application server.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然你可以选择和选择你需要的依赖项，但你必须将这样的依赖项携带到每次部署（或扩展）中。如果你使用许多依赖项，这将在网络使用和时间损失（以及编译时间）方面产生重大影响。使用应用服务器时，你假定这些依赖项已经在应用服务器中等待你。
- en: When it comes to supportability, either you get support services from a vendor
    or simply adhere to internal standards. You are normally bound to a fixed set
    of libraries and versions that have probably been tested to be compatible with
    your environment and to adhere to security and performances standards. With a
    fat JAR, you have less control over this at runtime and deployment time. You will
    have to move such controls at build time, and maybe double-check that the content
    of the fat JAR adheres to standards before putting it into your production environment.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到可支持性时，要么从供应商那里获得支持服务，要么简单地遵守内部标准。你通常会被绑定到一个固定的库和版本集合，这些库和版本可能已经被测试过，以确保与你的环境兼容，并遵守安全和性能标准。使用胖JAR，你在运行时和部署时对这一点控制较少。你将不得不在构建时移动这些控制，并在将其放入生产环境之前，可能还需要双重检查胖JAR的内容是否符合标准。
- en: As we discussed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*, containers changed
    the rules of the game a bit.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013)中讨论的，《Java软件架构设计
    – 方法与风格》，容器改变了游戏规则。
- en: With container technology, you can create a full portable environment, including
    a base operating system (sort of) with a filesystem in which you can place dependencies
    and resources together with your application. This means that you don't need a
    self-consistent application to deploy, as these features are provided by container
    technology. And, as already discussed, this may also be harmful when used together
    with containers, as they are designed to work in a layered way. So, you can use
    this feature to package and deploy only the upper level (containing your application
    code) instead of carrying over the whole dependency set.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器技术，你可以创建一个完整的可移植环境，包括一个基础操作系统（某种程度上）和一个文件系统，你可以在其中放置依赖项和资源，以及你的应用程序。这意味着你不需要一个自洽的应用程序来部署，因为这些功能由容器技术提供。而且，正如已经讨论过的，当与容器一起使用时，这也可能是有害的，因为它们被设计成以分层方式工作。因此，你可以使用这个功能来打包和部署只有上层（包含你的应用程序代码）而不是携带整个依赖集。
- en: So, while still convenient in some cases (such as local testing), fat JAR is
    not necessary right now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管在某些情况下（如本地测试）仍然方便，但现在胖JAR并不是必需的。
- en: But as we have seen, other than a different packaging approach, there are some
    features that may be very useful in the cloud-native and microservices world.
    These features are missing in JEE, such as observability and support for alternative
    technologies. It used to be common for microservices runtimes to define custom
    solutions to fill those gaps.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们所看到的，除了不同的打包方法之外，还有一些可能在云原生和微服务世界中非常有用的功能。这些功能在JEE中缺失，例如可观察性和对替代技术的支持。微服务运行时通常定义自定义解决方案来填补这些空白。
- en: But as previously mentioned, lack of standards is a known issue with microservices.
    This used to be a minor issue because early adopters were usually deeply technically
    skilled teams relying on self-support and that didn't need support from a third-party
    vendor.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但如前所述，缺乏标准是微服务中已知的问题。这曾经是一个小问题，因为早期的采用者通常是技术能力深厚的团队，他们依赖自我支持，不需要第三方供应商的支持。
- en: However, nowadays, the adoption of microservices, cloud-native, and general
    extensions to JEE is growing a lot. And factors such as long-term stability, enterprise
    support, and an open ecosystem are becoming more and more essential. That's one
    of the reasons behind MicroProfile.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，微服务、云原生和 JEE 的一般扩展的采用正在大幅增长。长期稳定性、企业支持和开放生态系统等因素变得越来越重要。这就是 MicroProfile
    的一个原因。
- en: Introducing MicroProfile
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 MicroProfile
- en: '**MicroProfile** started with a focus on extending the JEE specification with
    features offered by microservices. The development is backed by a consortium of
    industry players, such as IBM, Red Hat, Oracle, and Microsoft. The specification
    lives in parallel to Jakarta EE, sharing some functionality, evolving some others,
    and adding some more that are not part of JEE.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile** 从关注通过微服务提供的功能扩展 JEE 规范开始。该开发由 IBM、Red Hat、Oracle 和 Microsoft
    等行业参与者组成的联盟支持。该规范与 Jakarta EE 并行存在，共享一些功能，发展一些其他功能，并添加了一些不属于 JEE 的更多功能。'
- en: This works because the MicroProfile consortium, part of the Eclipse Foundation,
    has chosen a less bureaucratic and more frequent release model.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为 MicroProfile 联盟，作为 Eclipse 基金会的一部分，选择了一个更少官僚主义和更频繁的发布模式。
- en: 'This means that modern Java development can now basically take two parallel
    roads:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现代 Java 开发现在基本上可以走两条并行道路：
- en: '**Jakarta EE**: We can choose this if long-term stability and enterprise features
    are more important (or if you want to maintain and modernize existing code bases).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jakarta EE**：如果我们更重视长期稳定性和企业功能（或者如果我们想维护和现代化现有的代码库），我们可以选择这个选项。'
- en: '**MicroProfile**: We can choose this if cloud-native features and a frequent
    release cycle are priorities.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MicroProfile**：如果我们优先考虑云原生特性和频繁的发布周期，我们可以选择这个选项。'
- en: '*But what are the features added by MicroProfile?*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*但 MicroProfile 增加了哪些功能呢？*'
- en: MicroProfile specifications
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile 规范
- en: 'It''s really challenging to print a snapshot of something (that is changing
    very frequently) on paper. At the time of writing, MicroProfile releases a new
    version every 3 to 6 months. The most important features to highlight are the
    following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在纸上打印一个经常变化的快照（即变化非常频繁）是非常具有挑战性的。在撰写本文时，MicroProfile 每 3 到 6 个月发布一个新版本。以下是一些最重要的特性：
- en: '`.xml` files, system environments, and properties files) from the application
    itself. This provides the facilities for accessing the configuration values and
    checking for changes without needing to restart the application (in supported
    implementations).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xml` 文件、系统环境和属性文件）从应用程序本身获取。这提供了访问配置值和检查更改的设施，而无需重新启动应用程序（在支持的实施中）。'
- en: '**Fault tolerance**: This is a way to choreograph the reaction to failures
    (such as failing to call an external service) by using patterns such as circuit
    breaker, retry, and fallback.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错**：这是一种通过使用电路断路器、重试和回退等模式来编排对失败（如无法调用外部服务）的反应的方式。'
- en: '**OpenAPI**: This provides support for the OpenAPI standard, which is a way
    to define contracts for REST services, similar to what a WSDL schema provides
    to SOAP web services.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI**：这提供了对 OpenAPI 标准的支持，这是一种定义 REST 服务合同的方式，类似于 WSDL 架构为 SOAP 网络服务提供的支持。'
- en: '**OpenTracing**: This is a modern approach to monitoring and managing chains
    of calls in a distributed environment by passing an ID and introducing concepts
    such as spans and traces.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenTracing**：这是一种在分布式环境中通过传递 ID 并引入诸如跨度（spans）和跟踪（traces）等概念来监控和管理调用链的现代方法。'
- en: '**Health**: This is a standardized way to create liveness and readiness probes
    in order to instrument an application for checking the correct behavior of an
    application (when it''s live, that is, to verify whether it is up or down) and
    its readiness (when it''s ready to take requests).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康**：这是一种标准化的方式来创建存活性和就绪性探针，以便为检查应用程序的正确行为（当它是活跃的，即验证它是否上线或下线）及其就绪性（当它准备好接收请求时）提供工具。'
- en: '**Metrics**: This is an API for providing facilities for exporting monitorable
    values from your applications. This is usually used for things such as capacity
    planning and overall understanding of the application performances (such as the
    number of current transactions).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度量**：这是一个 API，用于提供从您的应用程序中导出可监控值的设施。这通常用于容量规划和对应用程序性能的整体理解（例如当前事务的数量）。'
- en: As you may have noticed, most of the preceding features exactly match what we
    highlighted in the *What's missing in Java EE* section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，前面的大部分功能与我们之前在“Java EE 缺失的功能”部分中强调的内容完全一致。
- en: We will explore some of those techniques in more detail in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中更详细地探讨这些技术，*设计云原生架构*。
- en: It's also important to highlight that MicroProfile encompasses specifications
    included in JEE (such as JAX-RS, JSON-B, and CDI, as we saw in the *Introducing
    the JEE standard* section). While MicroProfile tends to align the version of such
    shared libraries with one target JEE version, it may be that some of those versions
    are out of sync (being probably more up to date in the MicroProfile edition).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，MicroProfile包含了JEE（如JAX-RS、JSON-B和CDI，我们在*介绍JEE标准*部分中看到）中的规范。虽然MicroProfile倾向于将此类共享库的版本与一个目标JEE版本对齐，但可能某些版本已经不同步（在MicroProfile版本中可能更更新）。
- en: It's also worth noticing that MicroProfile does not imply any specific packaging
    model for applications. Some implementations, such as **Helidon** (backed by Oracle)
    and Quarkus (backed by Red Hat) tend to use fat JARs and similar, while others,
    such as **OpenLiberty** (provided by IBM) and WildFly (provided by Red Hat) run
    in a more traditional way (deployed into a lightweight running server).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，MicroProfile并不强制应用采用任何特定的打包模型。一些实现，例如由Oracle支持的**Helidon**和由Red Hat支持的Quarkus，倾向于使用胖JAR和类似格式，而其他如由IBM提供的**OpenLiberty**和由Red
    Hat提供的WildFly，则以更传统的方式运行（部署到轻量级运行服务器）。
- en: For the upcoming sections, we will start seeing more about Quarkus, which is
    an implementation of the MicroProfile standard and is becoming more and more popular
    and widely used.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将开始更多地了解Quarkus，它是一个MicroProfile标准的实现，并且越来越受欢迎和广泛使用。
- en: Exploring Quarkus
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Quarkus
- en: '**Quarkus** is an open source Java framework that aims to be optimized for
    cloud-native and microservices. It was born in the container and **Kubernetes**
    world, and for this reason, it''s been optimized by design for container and Kubernetes-based
    cloud-native applications.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus**是一个开源的Java框架，旨在为云原生和微服务进行优化。它诞生于容器和**Kubernetes**的世界，因此，它被设计为针对基于容器和Kubernetes的云原生应用进行了优化。'
- en: Quarkus comes from an engineering team with experience in many interesting projects,
    such as **Hibernate**, **Vert.X**, and **RESTEasy**, and so reuses a lot of good
    ideas and best practices from these famous communities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus来自一个拥有许多有趣项目经验的工程团队，如**Hibernate**、**Vert.X**和**RESTEasy**，因此大量重用了这些著名社区中的好想法和最佳实践。
- en: 'This is what a Quarkus application looks like when started from a terminal
    console:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从终端控制台启动的Quarkus应用程序的外观：
- en: '![Figure 7.3 – Quarkus starting'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – Quarkus启动'
- en: '](img/Figure_7.3_B16354.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16354.jpg)'
- en: Figure 7.3 – Quarkus starting
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – Quarkus启动
- en: As you can see, some spectacular ASCII art is shown and some interesting information,
    including the lightning-fast startup time of fewer than 1.5 seconds.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，展示了令人惊叹的ASCII艺术和一些有趣的信息，包括启动时间少于1.5秒的闪电般速度。
- en: '*But what are the most important benefits of Quarkus?*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*但Quarkus最重要的好处是什么？*'
- en: Better performances
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的性能
- en: 'One of the most famous benefits of Quarkus is its optimization. The framework
    was created with a *container-first* philosophy, and for this reason, it is heavily
    optimized both for startup time and memory usage. In order to achieve these objectives,
    Quarkus uses various techniques:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus最著名的优点之一是其优化。该框架是以*容器优先*的哲学创建的，因此，它在启动时间和内存使用方面都进行了大量优化。为了实现这些目标，Quarkus使用了各种技术：
- en: '**Less usage of reflection**: Reflection can be impactful in terms of performance.
    Quarkus reduces the use of reflection as much as possible.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少反射的使用**：反射在性能方面可能具有影响。Quarkus尽可能地减少反射的使用。'
- en: '**Move as much as possible to build time**: Quarkus does as much work as possible
    at build time. This means that all the things that can be done in advance, such
    as class path scanning and configuration loading, are done at build time and persisted
    as bytecode. In this way, not only will the application boot faster (because it
    has fewer things to do), but it will also be smaller in terms of memory footprint
    because of all the infrastructure that is not needed at runtime; that is, the
    ones *precompiled* at build time are not part of the final artifact.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能多地构建时间**：Quarkus在构建时尽可能做更多的工作。这意味着所有可以提前完成的事情，例如类路径扫描和配置加载，都会在构建时完成，并以字节码的形式持久化。这样，不仅应用程序启动速度更快（因为它要处理的事情更少），而且由于所有在运行时不需要的基础设施；也就是说，在构建时预编译的不会成为最终产品的组成部分。'
- en: '`Substrate` module). This allows further optimizations, further reducing the
    startup time and memory footprint.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substrate`模块）。这允许进一步的优化，进一步减少启动时间和内存占用。'
- en: But better performance is not the only benefit of Quarkus.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但更好的性能并不是Quarkus的唯一好处。
- en: Developer joy
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者喜悦
- en: The thing that I like the most about Quarkus is its ergonomics. As is common
    to hear from people working with it, Quarkus feels new and familiar at the same
    time. The language is extremely friendly if you come from a JEE background. It
    offers a ton of tools and facilities, not to mention all the *syntactic sugar*
    that makes even the most advanced features easy to use. In the Quarkus world,
    this is referred to as **developer joy**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢Quarkus的地方是它的易用性。正如经常听到的那样，Quarkus既新鲜又熟悉。如果您来自JEE背景，语言非常友好。它提供了一堆工具和设施，更不用说所有让最先进功能易于使用的*语法糖*了。在Quarkus的世界里，这被称为**开发者喜悦**。
- en: One of such facilities is the **developer mode**, which allows you to immediately
    see the changes in your application without needing a full recompile/repackage.
    It works like a charm when you change something (such as the source code, configuration
    file, and resources) and can immediately see the effect of such changes (such
    as simply refreshing the browser or recalling the API). I know this feature was
    already provided by other frameworks and libraries (with **JRebel** being one
    of the most famous), but the way it works out of the box is just magic for me,
    and, honestly, it's a great boost in terms of developer productivity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种设施是**开发者模式**，允许您立即看到应用程序中的更改，而无需完全重新编译/重新打包。当您更改某些内容（如源代码、配置文件和资源）并立即看到这些更改的效果时（如简单地刷新浏览器或调用API），它就像魔法一样起作用。我知道这个功能已经被其他框架和库（**JRebel**是最著名的之一）提供，但对我来说，它开箱即用的方式就是魔法，坦白说，这对开发者生产力是一个巨大的提升。
- en: But that's not the only *developer joy* feature. Each dependency added to Quarkus
    (which are more properly called **extensions**) is crafted to nicely fit the Quarkus
    world and use the framework's capabilities, first of all in terms of performances.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是唯一的**开发者喜悦**功能。添加到Quarkus中的每个依赖项（更准确地称为**扩展**）都被精心设计，以完美适应Quarkus的世界并利用框架的能力，首先是性能方面。
- en: You will find a lot of facilities and conventions over configuration and *intelligent
    defaults*, such as the way the configuration is treated (including environment
    management), a simple way to use both the imperative and reactive paradigms (and
    make them coexist), and the way it interacts with databases (by using the `Panache`
    extension). *But where to start?*
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到许多设施和约定，如配置和*智能默认值*，例如配置的处理方式（包括环境管理），简单使用命令和响应式范式（并使它们共存），以及它与数据库的交互方式（通过使用`Panache`扩展）。*但要从哪里开始呢？*
- en: Quarkus – hello world
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarkus – hello world
- en: 'Quarkus has a wizard for generating applications (both with **Maven** and **Gradle**
    support) located at [code.quarkus.io](http://code.quarkus.io). Follow these steps
    to create a new application:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus有一个生成应用程序的向导（支持**Maven**和**Gradle**），位于[code.quarkus.io](http://code.quarkus.io)。按照以下步骤创建一个新的应用程序：
- en: 'You can create a new application with the command line by using the Maven Quarkus
    plugin. In the current version, this means using the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用Maven Quarkus插件通过命令行创建一个新的应用程序。在当前版本中，这意味着使用以下命令：
- en: '[PRE14]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The plugin will then ask for all the required information, such as the artifact
    name and the dependency to start with. The following screenshot illustrates this
    (please note the cool emoticons too):'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件将要求提供所有必要的信息，例如工件名称和要开始的依赖项。以下截图说明了这一点（请注意，还有那些酷表情符号）：
- en: '![Figure 7.4 – The Quarkus Maven plugin'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – Quarkus Maven 插件'
- en: '](img/Figure_7.4_B16354.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16354.jpg)'
- en: Figure 7.4 – The Quarkus Maven plugin
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Quarkus Maven 插件
- en: 'After the plugin execution, you will have an application scaffold that you
    can use as a starting point (in this example, containing `resteasy` and `hibernate`
    dependencies). In order to run it and experiment with the developer mode, you
    can use the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件执行后，您将拥有一个可以作为起点使用的应用程序骨架（在这个例子中，包含 `resteasy` 和 `hibernate` 依赖项）。为了运行它并使用开发者模式进行实验，您可以使用以下命令：
- en: '[PRE15]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command uses a Maven wrapper script (in this case, `mvnw`, because I''m
    running on a Linux box, but a `mvnw.cmd` file is provided for Windows environments)
    to run the application in development mode. Since you are using RESTEasy, by default
    the application will answer with a `Hello RESTEasy` string on the following endpoint:
    `http://localhost:8080/hello-resteasy`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用 Maven 包装脚本（在这种情况下，`mvnw`，因为我正在 Linux 环境下运行，但为 Windows 环境提供了 `mvnw.cmd`
    文件）以开发者模式运行应用程序。由于您正在使用 RESTEasy，默认情况下，应用程序将在以下端点以 `Hello RESTEasy` 字符串响应：`http://localhost:8080/hello-resteasy`。
- en: In order to try the developer mode, you can change the source code (in this
    case, the `GreetingResource` class) to change the response. After you do that,
    you can refresh your browser and see the result without needing to recompile or
    repackage the code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试开发者模式，您可以更改源代码（在这个例子中，是 `GreetingResource` 类）以更改响应。完成此操作后，您可以刷新浏览器并查看结果，而无需重新编译或重新打包代码。
- en: Building techniques with Quarkus
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Quarkus 构建构建技术
- en: The development mode, needless to say, supports the development phase. In order
    to build and distribute Quarkus applications, you have other options.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 无需多言，开发模式支持开发阶段。为了构建和分发 Quarkus 应用程序，您还有其他选择。
- en: 'Quarkus is currently supported to run on OpenJDK (see the official website
    at `quarkus.io/get-started` for more information about the supported versions).
    In order to package your application, you can run the usual Maven command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Quarkus 支持在 OpenJDK 上运行（有关支持的版本信息，请参阅官方网站 `quarkus.io/get-started`）。为了打包您的应用程序，您可以使用常规的
    Maven 命令：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, Quarkus will build a so-called fast-jar. This is basically a package
    optimized for boot time performance and a small memory footprint. In order to
    execute an application packaged in this way, you will need to copy the whole `quarkus-app`
    folder (in the `target` folder), which contains all the libraries and resources
    needed to run the application. You can then run it with a similar command to this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Quarkus 将构建一个所谓的 fast-jar。这基本上是一个针对启动时间性能和较小内存占用进行优化的包。要执行以这种方式打包的应用程序，您需要复制整个
    `quarkus-app` 文件夹（在 `target` 文件夹中），其中包含运行应用程序所需的所有库和资源。然后，您可以使用类似以下命令运行它：
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also package the application in an UberJar form (be conscious of all
    the limitations of this approach, as discussed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*). To do so, one
    easy way is to pass the `quarkus.package.uber-jar=true` property to the Maven
    command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将应用程序打包成 UberJar 形式（请注意此方法的所有限制，如在第 [*第 1 章*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013)
    中讨论，*Java 软件架构设计 – 方法与风格*）。为此，一种简单的方法是将 `quarkus.package.uber-jar=true` 属性传递给
    Maven 命令：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This property can also be set in the `pom.xml` file or in the configuration
    file of Quarkus (the `application.properties` file, by default).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性也可以在 `pom.xml` 文件或 Quarkus 的配置文件（默认为 `application.properties` 文件）中设置。
- en: 'Last, but not least, as mentioned at the beginning of this section, Quarkus
    can be compiled into a native Linux executable without the JVM needing to be executed.
    To do so, you can simply use the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，如本节开头所述，Quarkus 可以编译成不需要执行 JVM 的原生 Linux 可执行文件。为此，您只需使用以下命令：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What Quarkus does under the hood is look for a GraalVM installation that is
    used for native compilation. The following screenshot shows what happens if we
    start Quarkus when the `GRAALVM_HOME` variable is not configured:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 在底层所做的是寻找用于原生编译的 GraalVM 安装。以下截图显示了当 `GRAALVM_HOME` 变量未配置时启动 Quarkus
    时会发生什么：
- en: '![Figure 7.5 – Quarkus building a native executable through Podman'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – Quarkus 通过 Podman 构建原生可执行文件'
- en: '](img/Figure_7.5_B16354.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16354.jpg)'
- en: Figure 7.5 – Quarkus building a native executable through Podman
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Quarkus 通过 Podman 构建原生可执行文件
- en: The `GRAALVM_HOME` variable is used to look up the install path of GraalVM.
    If not present, Quarkus will try a container build. This basically means that,
    if a container runtime (Podman or Docker) is installed on the local machine, Quarkus
    will download a container image to use for native building, so you can create
    a native executable without needing a local GraalVM installation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRAALVM_HOME`变量用于查找GraalVM的安装路径。如果不存在，Quarkus将尝试容器构建。这基本上意味着，如果本地机器上安装了容器运行时（Podman或Docker），Quarkus将下载一个容器镜像用于本地构建，这样你就可以创建一个本地可执行文件，而无需本地安装GraalVM。'
- en: Configuration management in Quarkus
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarkus的配置管理
- en: One lovely characteristic of Quarkus, in line with the developer joy idea, is
    the way it manages configurations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus的一个可爱特性，与开发者快乐理念一致，就是它管理配置的方式。
- en: Quarkus implements the MicroProfile `config` specification. We will see more
    about the MicroProfile functionalities in Quarkus, but since `config` is central
    to all the other extensions, it's worth having a look at it now.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus实现了MicroProfile的`config`规范。我们将更详细地了解Quarkus中的MicroProfile功能，但由于`config`是所有其他扩展的核心，现在看看它是很有价值的。
- en: 'In order to get and use a configurable value, you can use the following annotation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取和使用可配置的值，你可以使用以下注解：
- en: '[PRE20]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, you can provide a default value directly into the annotation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在注解中直接提供默认值。
- en: 'The configuration can be loaded by a number of different sources. Quarkus looks
    into the following sources (listed according to decreasing priority):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以通过多种不同的来源加载。Quarkus会检查以下来源（按优先级降序排列）：
- en: System properties (as in passing a command-line argument to the Java process,
    such as `–DmyProperty="myValue"`)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统属性（例如，向Java进程传递命令行参数，如`–DmyProperty="myValue"`）
- en: Environment variables
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: '`.env` files (files containing a set of environment variables) in the working
    directory'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录中的`.env`文件（包含一组环境变量的文件）
- en: An `application.properties` file (with the usual properties syntax, as in `key=value`)
    placed in a `config` subdirectory in the working directory
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置在工作目录中`config`子目录下的`application.properties`文件（使用通常的属性语法，如`key=value`）
- en: An `application.properties` file placed in `src/main/resources`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置在`src/main/resources`目录下的`application.properties`文件
- en: 'Quarkus supports the use of profiles in the configuration properties. This
    allows us to have different environments (or simply different sets of configurations)
    in the same configuration repository (such as in the same `application.properties`
    file). In order to do so, you can use a prefix in the configuration key, such
    as this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus支持在配置属性中使用配置文件。这使我们能够在同一个配置仓库中拥有不同的环境（或者简单地说，不同的配置集）（例如在同一个`application.properties`文件中）。为了做到这一点，你可以在配置键中使用前缀，例如这样：
- en: '[PRE21]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, Quarkus provides `dev`, `test`, and `prod` profiles. `dev` is activated
    when running in developer mode (`./mvnw compile quarkus:dev`, as seen in the previous
    section), `test` is activated when running tests, and `prod` is activated in all
    other scenarios.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Quarkus提供了`dev`、`test`和`prod`配置文件。`dev`在开发者模式下激活（如前文所述的`./mvnw compile
    quarkus:dev`），`test`在运行测试时激活，而`prod`在其他所有场景中激活。
- en: You can define as many configuration profiles as you need and activate them
    by using the `quarkus.profile` system property or the `QUARKUS_PROFILE` environment
    variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义你需要的任意多的配置文件，并通过使用`quarkus.profile`系统属性或`QUARKUS_PROFILE`环境变量来激活它们。
- en: So far, we have seen the basics of Quarkus, the most relevant benefits (including
    performances and language goodies), and how to build a basic `hello world` example.
    In the next section, we will have a look at the most common Quarkus extensions
    that are useful for building cloud-native applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Quarkus的基本知识，最相关的优势（包括性能和语言特性），以及如何构建基本的`hello world`示例。在下一节中，我们将探讨对构建云原生应用有用的最常见Quarkus扩展。
- en: Most common Quarkus extensions
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最常见的Quarkus扩展
- en: Quarkus is aiming at cloud-native applications and microservices but shares
    some features and functionalities with the JEE world. This is thanks to its adherence
    to the MicroProfile specification.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus旨在开发云原生应用和微服务，但与JEE世界共享一些特性和功能。这得益于其对MicroProfile规范的遵循。
- en: Such features are implementing common use cases and are very handy, as they
    allow you to use existing skills and, in some cases, existing JEE code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性实现了常见的用例，非常实用，因为它们允许你使用现有的技能，在某些情况下，还可以使用现有的JEE代码。
- en: In this section, we will go through a quick overview of the Quarkus extensions
    shared with the JEE specification.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速概述与 JEE 规范共享的 Quarkus 扩展。
- en: Content Dependency Injection
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容依赖注入
- en: '**CDI** is a structured way to wire and compose the objects of your application.
    CDI in Quarkus is based on the Contexts and Dependency Injection for **Java 2.0**
    specification, which defines CDI for both Java SE and Java EE.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**CDI** 是一种结构化的方式来连接和组合你的应用程序的对象。Quarkus 中的 CDI 基于 **Java 2.0** 规范的 Contexts
    and Dependency Injection，该规范为 Java SE 和 Java EE 定义了 CDI。'
- en: The Quarkus CDI implementation leverages the ArC framework and is not fully
    compliant with the CDI specification, even if it provides support for the most
    common CDI use cases such as DI (of course), qualifiers, life cycle callbacks,
    and interceptors. There are some known limitations, on some specific use cases
    (such as the use of decorators, and the conversation scope). Following the Quarkus
    optimization mantra, ArC moves the discovery and injection operations at build
    time to achieve better performances.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 的 CDI 实现利用了 ArC 框架，并且并不完全符合 CDI 规范，尽管它提供了对最常见 CDI 用例的支持，例如 DI（当然），限定符，生命周期回调和拦截器。对于一些特定的用例（例如装饰器的使用和会话作用域），存在一些已知的限制。遵循
    Quarkus 优化的箴言，ArC 将发现和注入操作移至构建时以实现更好的性能。
- en: REST services with JAX-RS
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 的 REST 服务
- en: 'In order to develop REST services, Quarkus provides a **JAX-RS** extension
    that mimics the Jakarta EE implementation almost completely. RESTEasy is commonly
    added by default in new Quarkus projects. However, in order to add these features
    to an existing Quarkus project, you can simply use this command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发 REST 服务，Quarkus 提供了一个几乎完全模仿 Jakarta EE 实现的 **JAX-RS** 扩展。RESTEasy 通常在新
    Quarkus 项目中默认添加。然而，为了将这些功能添加到现有的 Quarkus 项目中，你可以简单地使用以下命令：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As said, the JAX-RS implementation looks almost like the Jakarta EE implementation,
    so all the concepts we have seen in the previous section are still relevant (as
    previously mentioned, this will allow you to recycle skills and even existing
    code).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JAX-RS 实现看起来几乎与 Jakarta EE 实现相同，因此我们在上一节中看到的所有概念仍然相关（如前所述，这将允许你回收技能，甚至现有的代码）。
- en: WebSockets
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSockets
- en: Quarkus includes the `undertow-websockets` extension.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 包含 `undertow-websockets` 扩展。
- en: '**Undertow** is a highly performant web server technology written in Java.
    It can use both blocking and non-blocking APIs. Other than the WebSocket functionality
    (used by Quarkus), it provides other interesting web functionalities, such as
    full servlet API support. For this reason, Undertow is embedded into WildFly to
    provide web functionalities in full compliance with the JEE specification. Undertow
    has replaced Tomcat as the embedded web container in WildFly since **version 8**.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**Undertow** 是一种用 Java 编写的性能极高的 Web 服务器技术。它可以使用阻塞和非阻塞 API。除了 WebSocket 功能（由
    Quarkus 使用）之外，它还提供了其他有趣的 Web 功能，例如完整的 Servlet API 支持。因此，Undertow 被嵌入到 WildFly
    中，以完全符合 JEE 规范提供 Web 功能。自 **版本 8** 以来，Undertow 已取代 Tomcat 成为 WildFly 的嵌入式 Web
    容器。'
- en: 'In order to add the WebSocket functionality to an existing Quarkus project,
    you can use the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 WebSocket 功能添加到现有的 Quarkus 项目中，你可以使用以下命令：
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this extension, you can use the WebSocket technology in the same way we
    saw in the *Understanding the most common JEE APIs* section, in the *WebSockets*
    section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此扩展，你可以像在 *理解最常用的 JEE API* 部分，在 *WebSockets* 部分中看到的那样使用 WebSocket 技术。
- en: Messaging
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传递
- en: '`quarkus-artemis-jms` and `quarkus-qpid-jms`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-artemis-jms` 和 `quarkus-qpid-jms`。'
- en: The two dependencies are mostly equivalent from a functional point of view.
    Technically speaking, the `quarkus-artemis-jms` extensions use the `artemis jms`
    client to connect to the JMS broker, while `quarkus-qpid-jms` uses the AMQP standard
    as its wire protocol to connect to AMQP-compatible brokers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，这两个依赖项在大多数情况下是等效的。从技术上来说，`quarkus-artemis-jms` 扩展使用 `artemis jms` 客户端连接到
    JMS 代理，而 `quarkus-qpid-jms` 使用 AMQP 标准作为其连接到 AMQP 兼容代理的线协议。
- en: 'Unlike the JEE version, the Quarkus framework does not provide an injectable
    `JMSContext` object. But it does provide a JMS `ConnectionFactory` object, so
    you can easily get a producer from it, such as the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JEE 版本不同，Quarkus 框架不提供可注入的 `JMSContext` 对象。但它确实提供了一个 JMS `ConnectionFactory`
    对象，因此你可以轻松地从它获取生产者，例如以下所示：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Moreover, Quarkus does not provide the EJB subsystem, as it''s provided in
    the JEE specification, so you cannot use MDBs, the classic way provided by JEE
    to consume messages. A quick and easy way to do so is to create a consumer (against
    a `JMSContext` object, as per the producer) and use the `receive()` method. Since
    it''s a blocking call, you will have to create a new thread to encapsulate the
    receive logic without blocking the entire application. You''ll need something
    like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Quarkus 不提供 EJB 子系统，因为它在 JEE 规范中已提供，因此你不能使用 JEE 提供的典型方式（即消息驱动 Bean，MDB）来消费消息。一个快速简单的方法是创建一个消费者（针对
    `JMSContext` 对象，就像生产者一样）并使用 `receive()` 方法。由于这是一个阻塞调用，你将不得不创建一个新的线程来封装接收逻辑，以免阻塞整个应用程序。你需要像这样：
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The basic configurations for getting a producer and consumer to work are the
    server endpoint, user, and password. Those configs are stored in `quarkus.qpid-jms.url`,
    `quarkus.qpid-jms.username`, and `quarkus.qpid-jms.password` when using `quarkus-qpid`,
    and in `quarkus.artemis.url`, `quarkus.artemis.username`, and `quarkus.artemis.password`
    when using `quarkus-artemis`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使生产者和消费者正常工作的基本配置包括服务器端点、用户名和密码。当使用 `quarkus-qpid` 时，这些配置存储在 `quarkus.qpid-jms.url`、`quarkus.qpid-jms.username`
    和 `quarkus.qpid-jms.password` 中，当使用 `quarkus-artemis` 时，则存储在 `quarkus.artemis.url`、`quarkus.artemis.username`
    和 `quarkus.artemis.password` 中。
- en: That's it! Now you can send and receive JMS messages with Quarkus.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！现在你可以使用 Quarkus 发送和接收 JMS 消息了。
- en: Persistence
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化
- en: '`@Entity` and the other annotations that we have seen in order to specify mappings
    with database tables, and you can inject the `EntityManager` object in order to
    retrieve and persist objects to the database.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Entity` 以及我们之前看到的用于指定与数据库表映射的其他注解，你可以注入 `EntityManager` 对象以检索和持久化对象到数据库。
- en: To use Hibernate with Quarkus, you have to add the `quarkus-hibernate-orm` extension
    and a JDBC driver extension. The supported JDBC drivers are currently db2, Derby,
    H2, MariaDB, Microsoft SQL Server, MySQL, and PostgreSQL.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Quarkus 中使用 Hibernate，你必须添加 `quarkus-hibernate-orm` 扩展和一个 JDBC 驱动程序扩展。目前支持的
    JDBC 驱动程序包括 db2、Derby、H2、MariaDB、Microsoft SQL Server、MySQL 和 PostgreSQL。
- en: The basic properties to configure the database connection are `quarkus.datasource.db-kind`
    (configuring the type of database used), `quarkus.datasource.username`, `quarkus.datasource.password`,
    and `quarkus.datasource.jdbc.url`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据库连接的基本属性包括 `quarkus.datasource.db-kind`（配置使用的数据库类型）、`quarkus.datasource.username`、`quarkus.datasource.password`
    和 `quarkus.datasource.jdbc.url`。
- en: Although you can directly use Hibernate's `EntityManager`, Quarkus provides
    you with a more productive abstraction on top of it. This abstraction is Panache.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接使用 Hibernate 的 `EntityManager`，但 Quarkus 在其之上提供了一个更高效的抽象。这个抽象就是 Panache。
- en: Accelerated ORM development with Panache
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Panache 加速 ORM 开发
- en: '**Panache** is an amazing technology provided with Quarkus. It allows us to
    build ORM applications without redundant boilerplate code. It''s a boost for creating
    **Create Read Update Delete** (**CRUD**)-like applications in no time.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**Panache** 是 Quarkus 提供的一项令人惊叹的技术。它允许我们无需冗余的样板代码即可构建 ORM 应用程序。它极大地提高了创建类似
    **创建、读取、更新、删除**（**CRUD**）的应用程序的速度。'
- en: In order to develop CRUD applications using Panache on top of Hibernate, you
    need to add the `quarkus-hibernate-orm-panache` extension.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Panache 在 Hibernate 上开发 CRUD 应用程序，你需要添加 `quarkus-hibernate-orm-panache`
    扩展。
- en: Once you have this functionality enabled, you can use it in two main patterns,
    **Active Record** and the **repository**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了这个功能，你可以在两种主要模式中使用它，**Active Record** 和 **仓库**。
- en: Panache Active Record
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Panache Active Record
- en: Active Record is an architectural pattern. It was described by Martin Fowler
    in his *Patterns of Enterprise Application Architecture* book.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Active Record 是一种架构模式。它由马丁·福勒在其《企业应用架构模式》一书中描述。
- en: In this pattern, one class completely represents a database table. An object
    created from this class represents a row (with fields mapping columns), while
    methods of the class map the interaction with the database, such as `persist`,
    `delete`, and `find`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，一个类完全代表了一个数据库表。从这个类创建的对象代表了一行（字段映射列），而类的方法定义了与数据库的交互，例如 `persist`、`delete`
    和 `find`。
- en: 'In Quarkus, to implement this pattern, you must make your JPA entity (annotated
    with `@Entity`) extend the `PanacheEntity` class. You can then use all the methods
    inherited from this class in order to interact with the database, including features
    such as `persist`, `delete`, `find` and `list`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 中，要实现这种模式，你必须让你的 JPA 实体（用 `@Entity` 注解）扩展 `PanacheEntity` 类。然后你可以使用从这个类继承的所有方法来与数据库交互，包括
    `persist`、`delete`、`find` 和 `list` 等功能：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The obvious advantage here is that you don't have to directly interact with
    the `EntityManager` class anymore, and you have a number of methods ready to use
    for common use cases. But if you don't like the Active Record pattern, you can
    achieve pretty similar results with the repository approach.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的明显优势是您不再需要直接与 `EntityManager` 类进行交互，并且您有一系列现成的方法可供常见用例使用。但如果您不喜欢 Active Record
    模式，您可以使用仓库方法达到类似的效果。
- en: Panache repository
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Panache 仓库
- en: The repository pattern is an alternative to the Active Record one. Basically,
    instead of having both the entities and the methods (to find, update, delete,
    and persist objects) implemented in the same class, you split such responsibilities
    and have entities with no behavior and dedicated repository classes to implement
    database interactions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式是 Active Record 模式的替代方案。基本上，不是在同一个类中实现实体和方法（用于查找、更新、删除和持久化对象），而是将这样的责任分开，让实体没有行为，并使用专门的仓库类来实现数据库交互。
- en: 'In the Quarkus world, this means that your entities are standard JPA entities
    (with no need to extend the `PanacheEntity` class), while your designated repository
    will need to implement the `PanacheRepository` interface. You can then use the
    same methods that we have seen before (`persist`, `delete`, `find`, and `list`)
    against the repository class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 世界中，这意味着您的实体是标准的 JPA 实体（无需扩展 `PanacheEntity` 类），而您的指定仓库则需要实现 `PanacheRepository`
    接口。然后您可以使用之前见过的相同方法（`persist`、`delete`、`find` 和 `list`）对仓库类进行操作：
- en: '[PRE27]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the repository pattern is analogous to the Active Record one.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，仓库模式与 Active Record 模式类似。
- en: More complex relationships, such as one-to-many and many-to-many, can be modeled
    on an entity with the relevant annotations (in a similar way to what is doable
    with JPA), and can be retrieved and persisted with both the Active Record and
    Repository approaches. Moreover, Panache provides support for **Hibernate Query
    Language** (**HQL**) for complex queries. So far, we have learned about some of
    the Quarkus extensions and implemented basic APIs, similar to what we saw in the
    *Understanding the most common JEE APIs* section. Let's now see how Quarkus adds
    more features to those APIs by implementing the MicroProfile standard.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的关系，如一对一和多对多，可以使用具有相关注解的实体进行建模（类似于 JPA 可以做到的），并且可以使用 Active Record 和仓库方法进行检索和持久化。此外，Panache
    为复杂查询提供了对 **Hibernate 查询语言**（**HQL**）的支持。到目前为止，我们已经了解了 Quarkus 的一些扩展并实现了基本的 API，类似于我们在
    *理解最常见的 JEE API* 部分中看到的。现在让我们看看 Quarkus 如何通过实现 MicroProfile 标准来为这些 API 添加更多功能。
- en: Quarkus and the MicroProfile standard
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quarkus 和 MicroProfile 标准
- en: In this section, we are going to look at the MicroProfile standard and how Quarkus
    implements it. MicroProfile, as previously mentioned many times during this chapter
    (and in particular in the *Introducing MicroProfile* section), is a nice way to
    implement cloud-native microservices applications while adhering to a standard
    and hence avoiding vendor lock-in.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 MicroProfile 标准以及 Quarkus 如何实现它。正如在本章中多次提到的（特别是在 *介绍 MicroProfile*
    部分中），MicroProfile 是实现符合标准且避免供应商锁定的一种很好的方式，用于云原生微服务应用程序。
- en: Quarkus, in the current version, is compatible with the **3.2 version** of the
    MicroProfile specification. As we have seen, MicroProfile embraces and extends
    the JEE specification while providing features that are useful for cloud-native
    and microservices development.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本中，Quarkus 与 MicroProfile 规范的 **3.2 版本** 兼容。正如我们所见，MicroProfile 承袭并扩展了 JEE
    规范，同时提供了对云原生和微服务开发有用的功能。
- en: 'In the **3.2 version**, the most notable APIs in MicroProfile are as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **3.2 版本** 中，MicroProfile 中最显著的 API 如下所示：
- en: '**MicroProfile Config**, which is implemented by the Quarkus configuration,
    which we saw a couple of sections ago'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MicroProfile Config**，这是通过 Quarkus 配置实现的，我们在前面几节中见过'
- en: CDI and JAX-RS, which we saw in the *The most common Quarkus extensions* and
    *Understanding the most common JEE APIs* sections
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI 和 JAX-RS，我们在 *最常见的 Quarkus 扩展* 和 *理解最常见的 JEE API* 部分中见过
- en: MicroProfile Fault Tolerance, OpenAPI, Health, OpenTracing, and Metrics, which
    we will see in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile 容错、OpenAPI、健康、OpenTracing 和度量，我们将在 [*第 9 章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)
    中看到，*设计云原生架构*
- en: Other APIs, such as JWT authentication, Common Annotations, JSON-B, and JSON-P,
    which we will not cover
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 API，例如 JWT 验证、通用注解、JSON-B 和 JSON-P，我们不会涉及
- en: This has completed our overview on traditional JEE middleware, such as WildFly,
    and cloud-native alternatives, such as Quarkus. Let's have a look at some examples
    now.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对传统 JEE 中间件（如 WildFly）和云原生替代方案（如 Quarkus）的概述。现在让我们看看一些示例。
- en: Case studies and examples
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: In this section, we will model a very small subset of our mobile payment application.
    To follow up on the concepts we have seen, we will see some examples created for
    WildFly and Quarkus. For both technologies, since we will be interacting with
    a database, we will use H2, which is an easy-to-use open source database. You
    will find all the code in the GitHub repository located at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将模拟我们的移动支付应用程序的一个非常小的子集。为了跟进我们看到的理念，我们将看到为 WildFly 和 Quarkus 创建的一些示例。对于这两种技术，由于我们将与数据库交互，我们将使用易于使用的开源数据库
    H2。您将在位于 [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java)
    的 GitHub 仓库中找到所有代码。
- en: Setting up the database
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'As we''ve said, the prerequisite for our application is to have a database
    up and running. To set it up, execute the following steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所言，我们应用程序的先决条件是数据库已启动并运行。要设置它，执行以下步骤：
- en: First, download the latest version of H2 from the [www.h2database.com](http://www.h2database.com)
    website.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从 [www.h2database.com](http://www.h2database.com) 网站下载 H2 的最新版本。
- en: You can then simply run the executable script for your platform, located under
    the `bin` directory. In my case, it was `h2.sh`. It will require a correctly installed
    JVM.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以简单地运行位于 `bin` 目录下的平台可执行脚本。在我的情况下，它是 `h2.sh`。它需要一个正确安装的 JVM。
- en: 'After the database starts, the default browser will be opened, and the embedded
    H2 web console will be available. If you''re using H2 for the first time, it will,
    by default, try to connect in the embedded mode and create a test database in
    your `home` directory. You can log in with the default login credentials (which
    are `sa` as the username, with no password). The following screenshot shows the
    web console login screen, with all the needed configurations:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库启动后，默认浏览器将被打开，嵌入式 H2 Web 控制台将可用。如果您是第一次使用 H2，它将默认尝试以嵌入式模式连接并在您的 `home` 目录中创建一个测试数据库。您可以使用默认的登录凭据（用户名为
    `sa`，无密码）登录。以下截图显示了 Web 控制台登录屏幕，其中包含所有必要的配置：
- en: '![Figure 7.6 – The H2 login form'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – H2 登录表单'
- en: '](img/Figure_7.6_B16354.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – H2 登录表单](img/Figure_7.6_B16354.jpg)'
- en: Figure 7.6 – The H2 login form
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – H2 登录表单
- en: 'After you log in, you will be presented with a form to manipulate your newly
    created database. In order to create the `payment` table, you can copy and paste
    this SQL code into the SQL input form:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将看到一个表单来操作您新创建的数据库。为了创建 `payment` 表，您可以将以下 SQL 代码复制并粘贴到 SQL 输入表单中：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we are using H2 in embedded mode. This means that only one
    connection at a time will be allowed. So, before continuing with our examples,
    we will need to stop the `H2` Java process to allow WildFly to connect to the
    database. You can then reconnect with the web console by simply relaunching `H2`
    and using a different JDBC URL to connect in server mode. In my case, the string
    is as follows, and this allows more than one concurrent connection:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用嵌入式模式的 H2。这意味着一次只能允许一个连接。因此，在我们继续示例之前，我们需要停止 H2 Java 进程，以便 WildFly
    连接到数据库。然后，您可以通过简单地重新启动 H2 并使用不同的 JDBC URL 以服务器模式连接，通过 Web 控制台重新连接。在我的情况下，字符串如下，这允许多个并发连接：
- en: '[PRE29]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, another option is to completely skip this part and leave the table creation
    to Hibernate by leveraging the `hbm2ddl` configuration. I don't love this option,
    but it's still a viable alternative.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，另一种选择是完全跳过这一部分，并利用 `hbm2ddl` 配置让 Hibernate 创建表。我不太喜欢这个选项，但仍然是一个可行的替代方案。
- en: Moreover, consider that this is, of course, a simple example. In a real-world
    application, we would need some more tables (such as a `user` table). We would
    probably need to double-check our SQL statements with a DBA to check our data
    types against potential performance issues, depending on the expected volumes,
    or, most likely, we would have to interact with a database that's already been
    created for us. Now that we have a simple database, let's see how to interact
    with it by using WildFly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，这当然是一个简单的示例。在实际应用中，我们可能需要更多的表（例如`user`表）。我们可能需要与DBA双重检查我们的SQL语句，以检查数据类型可能对性能的影响，这取决于预期的数据量，或者，最有可能的是，我们需要与已经为我们创建的数据库进行交互。现在我们有一个简单的数据库，让我们看看如何通过WildFly与之交互。
- en: JPA and REST with JEE and WildFly
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JPA和REST与JEE和WildFly
- en: In order to start developing our JEE application, you will need to start from
    an empty project (in our case, with Maven support). There are many ways to do
    that. The easiest one is to clone the project related to this chapter on GitHub
    and reuse the `pom.xml` and the project structure.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发我们的JEE应用程序，您需要从一个空项目开始（在我们的情况下，带有Maven支持）。有许多方法可以做到这一点。最简单的方法是克隆GitHub上与本章相关的项目，并重用`pom.xml`和项目结构。
- en: As an alternative, you can install and use (see the `Readme` file from GitHub)
    the WildFly Maven archetype located at [https://github.com/wildfly/quickstart](https://github.com/wildfly/quickstart).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，您可以安装并使用位于[https://github.com/wildfly/quickstart](https://github.com/wildfly/quickstart)的WildFly
    Maven 架构（请参阅GitHub上的`Readme`文件）。
- en: 'The first step of our example is accessing the table we just created via JPA.
    To do so, you will have to create an entity mapping to the table. As we saw in
    previous sections, the syntax is pretty easy:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的第一步是通过JPA访问我们刚刚创建的表。为此，您需要创建一个实体映射到该表。正如我们在前面的章节中看到的，语法相当简单：
- en: '[PRE30]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you see, we are using the same names defined in the database (both for identifying
    the table name, which corresponds to the class name, and the column names, which
    are linked to the class field names). Different mapping is possible with the proper
    annotations.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用数据库中定义的相同名称（既用于识别表名，对应于类名，也用于列名，与类字段名相关联）。通过适当的注解，可以实现不同的映射。
- en: 'In order to manipulate our entity, we are going to use the repository pattern.
    Hence, we will create a `PaymentRepository` class, inject `EntityManager`, and
    use it for JPA operations. For the sake of simplicity, we will simply implement
    the `create` and `find` functionalities, but of course, these can be extended
    to cover all other possible requirements, such as finding by column:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作我们的实体，我们将使用仓库模式。因此，我们将创建一个`PaymentRepository`类，注入`EntityManager`，并用于JPA操作。为了简化，我们只需实现`create`和`find`功能，但当然，这些可以扩展以涵盖所有其他可能的请求，例如按列查找：
- en: '[PRE31]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last piece in this basic example is exposing the application using RESTful
    Web Services. To do so, we will need to create our `PaymentResource` class and
    annotate it accordingly, as we saw in the *REST services with JAX-RS* section:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本示例的最后一部分，我们需要通过RESTful Web服务公开应用程序。为此，我们需要创建我们的`PaymentResource`类并相应地注解它，正如我们在*使用JAX-RS的REST服务*部分所看到的：
- en: '[PRE32]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The notable thing here is that the `PaymentRepository` class, which we created
    previously, is injected using CDI and used from within the other methods. The
    two other methods, implementing REST capabilities (`find` and `create`), are annotated
    with `@GET` and `@POST`. The parameters for the `find` method are passed as `@PathParam("id")`,
    using the relevant annotation. The parameter for the `create` method is passed
    as a `Payment` object. The JSON serialization and deserialization are handled
    out of the box.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是，我们之前创建的`PaymentRepository`类，是通过CDI注入并用于其他方法中的。另外两个实现REST功能的方法（`find`和`create`），分别用`@GET`和`@POST`注解。`find`方法的参数通过`@PathParam("id")`传递，使用相关注解。`create`方法的参数通过`Payment`对象传递。JSON序列化和反序列化是自动处理的。
- en: 'In order to activate the REST subsystem, as mentioned, the simplest way is
    to create a class that extends `javax.ws.rs.core.Application` and annotate it
    by defining the root application path, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活REST子系统，正如之前提到的，最简单的方法是创建一个扩展`javax.ws.rs.core.Application`的类，并通过定义根应用程序路径对其进行注解，如下所示：
- en: '[PRE33]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, we need to configure the connection between the application server
    and the database.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置应用程序服务器和数据库之间的连接。
- en: WildFly ships with an example data source on H2, which is already configured
    in the default `standalone.xml` file. In order to configure the WildFly server
    to use the H2 database that we created in the previous section, we will have to
    change the `jdbc` connection string from `jdbc:h2:mem:test` to `jdbc:h2:tcp://localhost/~/test`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 随附一个在 H2 上的示例数据源，它已经在默认的 `standalone.xml` 文件中配置好了。为了配置 WildFly 服务器以使用我们在上一节中创建的
    H2 数据库，我们必须将 `jdbc` 连接字符串从 `jdbc:h2:mem:test` 更改为 `jdbc:h2:tcp://localhost/~/test`。
- en: Moreover, we didn't set a password in the H2 server for the database connection,
    so you will need to remove it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们没有为数据库连接在 H2 服务器中设置密码，所以你需要将其删除。
- en: 'To make our example application use such data source, you will need to change
    the `persistence.xml` JNDI name to the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的示例应用程序使用这样的数据源，你需要将 `persistence.xml` 的 JNDI 名称更改为以下内容：
- en: '[PRE34]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the same file, you will also need to set the `hibernate` dialect to H2:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，你还需要将 `hibernate` 方言设置为 H2：
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now everything is ready for deployment. First of all, we will start WildFly
    (in this case, by simply running `/bin/standalone.sh`). Then, we will package
    the application using a simple `mvn clean package` command. For development purposes,
    we can then deploy the compiled `.war` file to WildFly by copying it into the
    `/standalone/deployments` directory in the WildFly installation folder.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以部署了。首先，我们将启动 WildFly（在这种情况下，只需运行 `/bin/standalone.sh`）。然后，我们将使用简单的
    `mvn clean package` 命令打包应用程序。为了开发目的，然后我们可以将编译好的 `.war` 文件部署到 WildFly，通过将其复制到 WildFly
    安装文件夹中的 `/standalone/deployments` 目录。
- en: 'If everything worked correctly, you can then interact with REST services with
    this sample application. As an example, by using `curl` at the command line, you
    can create a payment like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常工作，你就可以使用这个示例应用程序与 REST 服务进行交互。例如，通过在命令行中使用 `curl`，你可以创建一个支付如下：
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can retrieve it like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样检索它：
- en: '[PRE37]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have now created a simple but complete JEE example of a REST application
    interacting with a database using JPA. We will use the same application and see
    what will change when we use Quarkus.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个简单但完整的 JEE 示例，这是一个使用 JPA 与数据库交互的 REST 应用程序。我们将使用同一个应用程序，看看当我们使用 Quarkus
    时会发生什么变化。
- en: JPA and REST (and more) with Quarkus
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JPA 和 REST（以及更多）与 Quarkus
- en: To create a skeleton application with Quarkus, using all the technology that
    we need, we can simply go to `code.quarkus.io` and select the technology that
    we need, which in our case is JAX-RS, `.zip` file with the right scaffold to start
    from.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个带有 Quarkus 的骨架应用程序，使用我们需要的所有技术，我们只需访问 `code.quarkus.io` 并选择我们需要的技術，在我们的例子中是
    JAX-RS，然后下载包含正确脚手的 `.zip` 文件以开始。
- en: 'Another alternative is to use the Maven command line, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 Maven 命令行，如下所示：
- en: '[PRE38]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This command is invoking the Quarkus Maven plugin, asking to create a new project,
    and defining the group ID and artifact ID to use. It specifies the name of a class
    exposing REST services and the path under which the services will be published.
    It also defines a number of extensions to be included, such as RESTEasy and Hibernate.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令正在调用 Quarkus Maven 插件，要求创建一个新的项目，并定义要使用的组 ID 和工件 ID。它指定了一个公开 REST 服务的类的名称以及服务将发布的路径。它还定义了要包含的一些扩展，例如
    RESTEasy 和 Hibernate。
- en: Once the new project is created, you can copy and paste the code developed for
    JEE into this project. In particular, you can override the content of `/src/main/java`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新项目，你就可以将为 JEE 开发的代码复制并粘贴到这个项目中。特别是，你可以覆盖 `/src/main/java` 中的内容。
- en: 'For the CDI to work, we need to configure the database connection. You have
    to add the following properties in `application.properties`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 CDI 工作，我们需要配置数据库连接。你必须在 `application.properties` 中添加以下属性：
- en: '[PRE39]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s it! This is the bare-minimum change required to make the application
    work in Quarkus. You can launch it with this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！这是使应用程序在 Quarkus 中工作所需的最小更改。你可以用以下方式启动它：
- en: '[PRE40]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These are the test methods that are exposed as a REST service (take into account
    that the Quarkus application is deployed as the root context, so you will have
    to remove the name of the application – in our case, `hosawj` – from the REST
    endpoints). Of course, you can also package the application in any other way that
    we have seen (for example, in a native executable or as a fat JAR).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是作为 REST 服务公开的测试方法（请注意，Quarkus 应用程序作为根上下文部署，所以你将不得不从 REST 端点中删除应用程序的名称——在我们的例子中是
    `hosawj`）。当然，你也可以以我们看到的任何其他方式打包应用程序（例如，作为原生可执行文件或胖 JAR）。
- en: But that's the simplest way to move a simple application from JEE to Quarkus.
    You are not using any advanced feature of Quarkus.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是将简单应用程序从JEE迁移到Quarkus的最简单方法。你并没有使用Quarkus的任何高级功能。
- en: 'A simple enhancement is to expose the OpenAPI and Swagger UI. It''s trivial
    to enable these features. You just need to add the relevant extension:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的增强是公开OpenAPI和Swagger UI。启用这些功能非常简单。你只需要添加相关的扩展：
- en: '[PRE41]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The OpenAPI for your application will now be exposed here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您应用程序的OpenAPI现在将在这里公开：
- en: '[PRE42]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Swagger UI will now be exposed here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI现在将在这里公开：
- en: '[PRE43]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Last, but not least, it''s advisable to simplify the ORM part by using Panache.
    To do so, you can use the existing repository and simply make it extend `PanacheRepository<Payment>`.
    Then, you will automatically have a lot of convenient ORM methods available, and
    you don''t have to explicitly manage `EntityManager`. Your repository will look
    like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，建议通过使用Panache简化ORM部分。为此，你可以使用现有的仓库，并简单地让它扩展`PanacheRepository<Payment>`。然后，你将自动拥有许多方便的ORM方法，而且你不需要显式管理`EntityManager`。你的仓库将看起来像这样：
- en: '[PRE44]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It will be very easy to simply extend using methods provided by Panache. If
    you prefer, it will be also very easy to get rid of the repository and implement
    an Active Record pattern, as discussed in the *Accelerated ORM development with
    Panache* section.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Panache提供的方法简单地扩展将会非常容易。如果你愿意，也可以非常容易地去除仓库并实现Active Record模式，正如在*使用Panache加速ORM开发*部分所讨论的那样。
- en: This will close our example section.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这将结束我们的示例部分。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen a very quick overview of the JEE specification
    and some very interesting alternatives, such as MicroProfile and Quarkus, which
    are certified MicroProfile implementations.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速概述了JEE规范和一些非常有趣的替代品，如MicroProfile和Quarkus，它们是经过认证的MicroProfile实现。
- en: We have learned about the JEE standard and why it's so popular. We also learned
    about the basic usage of the WildFly application server, along with some widely
    used JEE APIs, including RESTful Web Services, JMS messaging, and JPA persistence.
    We also learned about the MicroProfile standard, a modern alternative to JEE,
    and the Quarkus framework, which implements the MicroProfile standard. We also
    learned about some Quarkus extensions, including RESTful Web Services, JMS messaging,
    and persistence with Panache.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了JEE标准以及为什么它如此受欢迎。我们还学习了WildFly应用程序服务器的基本用法，以及一些广泛使用的JEE API，包括RESTful
    Web服务、JMS消息和JPA持久性。我们还了解了MicroProfile标准，它是JEE的现代替代品，以及实现了MicroProfile标准的Quarkus框架。我们还了解了一些Quarkus扩展，包括RESTful
    Web服务、JMS消息和Panache的持久性。
- en: We will see more Quarkus cloud-native features in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*中看到更多Quarkus云原生特性。
- en: In the next chapter, instead, we will continue our discussion on the concept
    of middleware by having a look at the world of application integration.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论中间件的概念，通过查看应用程序集成的世界。
- en: Further reading
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Snyk, *JVM Ecosystem Report* ([res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf](http://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf))
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Snyk，*JVM生态系统报告* ([res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf](http://res.cloudinary.com/snyk/image/upload/v1623860216/reports/jvm-ecosystem-report-2021.pdf))
- en: David Delabassee, *Opening Up Java EE* ([blogs.oracle.com/theaquarium/opening-up-ee-update](http://blogs.oracle.com/theaquarium/opening-up-ee-update))
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Delabassee，*开启Java EE* ([blogs.oracle.com/theaquarium/opening-up-ee-update](http://blogs.oracle.com/theaquarium/opening-up-ee-update))
- en: Dimitris Andreadis, *JBoss AS7 Reloaded* ([www.slideshare.net/dandreadis/jboss-as7-reloaded](http://www.slideshare.net/dandreadis/jboss-as7-reloaded))
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dimitris Andreadis，*JBoss AS7重载* ([www.slideshare.net/dandreadis/jboss-as7-reloaded](http://www.slideshare.net/dandreadis/jboss-as7-reloaded))
- en: Red Hat, *The WildFly Community Official Documentation* ([docs.wildfly.org](http://docs.wildfly.org))
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红帽，*WildFly社区官方文档* ([docs.wildfly.org](http://docs.wildfly.org))
- en: Eclipse Foundation, *The Jakarta EE Tutorial*, ([eclipse-ee4j.github.io/jakartaee-tutorial](http://eclipse-ee4j.github.io/jakartaee-tutorial))
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse基金会，*Jakarta EE教程* ([eclipse-ee4j.github.io/jakartaee-tutorial](http://eclipse-ee4j.github.io/jakartaee-tutorial))
- en: Red Hat, *Undertow* ([undertow.io](http://undertow.io))
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红帽，*Undertow* ([undertow.io](http://undertow.io))
- en: Martin Fowler, *Patterns of Enterprise Application Architecture*
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler，*企业应用架构模式*
- en: The Linux Foundation, *OpenApi* ([openapis.org](http://openapis.org))
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux基金会，*OpenApi* ([openapis.org](http://openapis.org))
- en: SmartBear, *Swagger* ([swagger.io](http://swagger.io))
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SmartBear，*Swagger* ([swagger.io](http://swagger.io))
