<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Testing Concurrent Applications</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover the following topics:</p>
<ul class="calibre17">
<li class="calibre18">Monitoring a Lock interface</li>
<li class="calibre18">Monitoring a Phaser class</li>
<li class="calibre18">Monitoring an Executor framework</li>
<li class="calibre18">Monitoring a fork/join pool</li>
<li class="calibre18">Monitoring a stream</li>
<li class="calibre18">Writing effective log messages</li>
<li class="calibre18">Analyzing concurrent code with FindBugs</li>
<li class="calibre18">Configuring Eclipse for debugging concurrency code</li>
<li class="calibre18">Configuring NetBeans for debugging concurrency code</li>
<li class="calibre18">Testing concurrency code with MultithreadedTC</li>
<li class="calibre18">Monitoring with JConsole</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">Testing an application is a critical task. Before you make an application ready for end users, you have to demonstrate its correctness. You use a test process to prove that correctness is achieved and errors are fixed. Testing is a common task in any software development and quality assurance process. You can find a lot of literature about testing processes and the different approaches you can apply to your developments. There are a lot of libraries as well, such as JUnit, and applications, such as Apache JMeter, that you can use to test your Java applications in an automated way. Testing is even more critical in concurrent application development.</p>
<p class="calibre4">The fact that concurrent applications have two or more threads that share data structures and interact with each other adds more difficulty to the testing phase. The biggest problem you will face when you test concurrent applications is that the execution of threads is non-deterministic. You can't guarantee the order of the execution of threads, so it's difficult to reproduce errors.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a Lock interface</h1>
            

            <article>
                
<p class="calibre4">A <kbd class="calibre15">Lock</kbd> interface is one of the basic mechanisms provided by the Java concurrency API to synchronize a block of code. It allows you to define a <strong class="calibre1">critical section</strong>. A critical section is a block of code that accesses a shared resource and can't be executed by more than one thread at the same time. This mechanism is implemented by the <kbd class="calibre15">Lock</kbd> interface and the <kbd class="calibre15">ReentrantLock</kbd> class.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about a <kbd class="calibre15">Lock</kbd> object and how to obtain that information.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyLock</kbd> that extends the <kbd class="calibre15">ReentrantLock</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class MyLock extends ReentrantLock {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement <kbd class="calibre15">getOwnerName()</kbd>. This method returns the name of the thread that has control of a lock (if any), using the protected method of the <kbd class="calibre15">Lock</kbd> class called <kbd class="calibre15">getOwner()</kbd>:</li>
</ol>
<pre class="calibre23">
        public String getOwnerName() {<br class="title-page-name"/>          if (this.getOwner()==null) {<br class="title-page-name"/>            return "None";<br class="title-page-name"/>          }<br class="title-page-name"/>          return this.getOwner().getName();<br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement <kbd class="calibre15">getThreads()</kbd>. This method returns a list of threads queued in a lock, using the protected method of the <kbd class="calibre15">Lock</kbd> class called <kbd class="calibre15">getQueuedThreads()</kbd>:</li>
</ol>
<pre class="calibre23">
        public Collection&lt;Thread&gt; getThreads() { <br class="title-page-name"/>          return this.getQueuedThreads(); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Declare a private <kbd class="calibre15">Lock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Lock lock;
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement a constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Task (Lock lock) { <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Create a loop with five steps:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          for (int i=0; i&lt;5; i++) {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Acquire the lock using the <kbd class="calibre15">lock()</kbd> method and print a message:</li>
</ol>
<pre class="calibre23">
        lock.lock(); <br class="title-page-name"/>        System.out.printf("%s: Get the Lock.\n",<br class="title-page-name"/>                          Thread.currentThread().getName());
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Put the thread to sleep for 500 milliseconds. Free the lock using the <kbd class="calibre15">unlock()</kbd> method and print a message:</li>
</ol>
<pre class="calibre23">
              try { <br class="title-page-name"/>                TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>                System.out.printf("%s: Free the Lock.\n",<br class="title-page-name"/>                                  Thread.currentThread().getName()); <br class="title-page-name"/>              } catch (InterruptedException e) { <br class="title-page-name"/>                e.printStackTrace(); <br class="title-page-name"/>              } finally { <br class="title-page-name"/>                lock.unlock(); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a <kbd class="calibre15">MyLock</kbd> object named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        MyLock lock=new MyLock();
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create an array of five <kbd class="calibre15">Thread</kbd> objects:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[5];
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create and start five threads to execute five <kbd class="calibre15">Task</kbd> objects:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++) { <br class="title-page-name"/>          Task task=new Task(lock); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create a loop with 15 steps:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;15; i++) {
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Write the name of the owner of the lock in the console:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Logging the Lock\n"); <br class="title-page-name"/>        System.out.printf("************************\n"); <br class="title-page-name"/>        System.out.printf("Lock: Owner : %s\n",lock.getOwnerName());
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Display the number and name of the threads queued for the lock:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Lock: Queued Threads: %s\n",<br class="title-page-name"/>                          lock.hasQueuedThreads()); <br class="title-page-name"/>        if (lock.hasQueuedThreads()){ <br class="title-page-name"/>          System.out.printf("Lock: Queue Length: %d\n",<br class="title-page-name"/>                            lock.getQueueLength()); <br class="title-page-name"/>          System.out.printf("Lock: Queued Threads: "); <br class="title-page-name"/>          Collection&lt;Thread&gt; lockedThreads=lock.getThreads(); <br class="title-page-name"/>          for (Thread lockedThread : lockedThreads) { <br class="title-page-name"/>            System.out.printf("%s ",lockedThread.getName()); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("\n"); <br class="title-page-name"/>        }
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Display information about the fairness and status of the <kbd class="calibre15">Lock</kbd> object:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Lock: Fairness: %s\n",lock.isFair()); <br class="title-page-name"/>        System.out.printf("Lock: Locked: %s\n",lock.isLocked()); <br class="title-page-name"/>        System.out.printf("************************\n");
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Put the thread to sleep for 1 second and close the loop and the class:</li>
</ol>
<pre class="calibre23">
              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented the <kbd class="calibre15">MyLock</kbd> class that extends the <kbd class="calibre15">ReentrantLock</kbd> class to return information that wouldn't have been available otherwise-it's protected data of the <kbd class="calibre15">ReentrantLock</kbd> class. The methods implemented by the <kbd class="calibre15">MyLock</kbd> class are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getOwnerName()</kbd>: Only one thread can execute a critical section protected by a <kbd class="calibre15">Lock</kbd> object. The lock stores the thread that is executing the critical section. This thread is returned by the protected <kbd class="calibre15">getOwner()</kbd> method of the <kbd class="calibre15">ReentrantLock</kbd> class.</li>
</ul>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getThreads()</kbd>: When a thread is executing a critical section, other threads that try to enter it are put to sleep before they continue executing that critical section. The protected method <kbd class="calibre15">getQueuedThreads()</kbd> of the <kbd class="calibre15">ReentrantLock</kbd> class returns the list of threads that are waiting to execute the critical section.</li>
</ul>
<p class="calibre4">We also used other methods that are implemented in the <kbd class="calibre15">ReentrantLock</kbd> class:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">hasQueuedThreads()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether there are threads waiting to acquire the calling <kbd class="calibre15">ReentrantLock</kbd></li>
<li class="calibre18"><kbd class="calibre15">getQueueLength()</kbd>: This method returns the number of threads that are waiting to acquire the calling <kbd class="calibre15">ReentrantLock</kbd></li>
<li class="calibre18"><kbd class="calibre15">isLocked()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether the calling <kbd class="calibre15">ReentrantLock</kbd> is owned by a thread</li>
<li class="calibre18"><kbd class="calibre15">isFair()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether the calling <kbd class="calibre15">ReentrantLock</kbd> has fair mode activated</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">There are other methods in the <kbd class="calibre15">ReentrantLock</kbd> class that can be used to obtain information about a <kbd class="calibre15">Lock</kbd> object:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getHoldCount()</kbd>: This returns the number of times the current thread has acquired the lock</li>
<li class="calibre18"><kbd class="calibre15">isHeldByCurrentThread()</kbd>: This returns a <kbd class="calibre15">Boolean</kbd> value indicating whether the lock is owned by the current thread</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Synchronizing a block of code with a lock</em> recipe in <a href="part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre14">Basic Thread Synchronization</em></li>
<li class="calibre18">The <em class="calibre14">Implementing a custom Lock class</em> recipe in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a Phaser class</h1>
            

            <article>
                
<p class="calibre4">One of the most complex and powerful functionalities offered by the Java Concurrency API is the ability to execute concurrent-phased tasks using the <kbd class="calibre15">Phaser</kbd> class. This mechanism is useful when we have some concurrent tasks divided into steps. The <kbd class="calibre15">Phaser</kbd> class provides the mechanism to synchronize threads at the end of each step so no thread starts its second step until all the threads have finished the first one.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about the status of a <kbd class="calibre15">Phaser</kbd> class and how to obtain that information.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">time</kbd>:</li>
</ol>
<pre class="calibre23">
        private final int time;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">Phaser</kbd> attribute named <kbd class="calibre15">phaser</kbd>:</li>
</ol>
<pre class="calibre23">
        private final Phaser phaser;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(int time, Phaser phaser) { <br class="title-page-name"/>          this.time=time; <br class="title-page-name"/>          this.phaser=phaser; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First, instruct the <kbd class="calibre15">phaser</kbd> attribute that the task starts its execution with the <kbd class="calibre15">arrive()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/> <br class="title-page-name"/>          phaser.arrive();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Write a message in the console indicating the start of phase one. Put the thread to sleep for the number of seconds specified by the <kbd class="calibre15">time</kbd> attribute. Write a message in the console indicating the end of phase one. And, synchronize with the rest of the tasks using the <kbd class="calibre15">arriveAndAwaitAdvance()</kbd> method of the <kbd class="calibre15">phaser</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Entering phase 1.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(time); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("%s: Finishing phase 1.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Repeat this behavior in both second and third phases. At the end of the third phase, use the <kbd class="calibre15">arriveAndDeregister()</kbd> method instead of <kbd class="calibre15">arriveAndAwaitAdvance()</kbd>:</li>
</ol>
<pre class="calibre23">
        System.out.printf("%s: Entering phase 2.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(time); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("%s: Finishing phase 2.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        phaser.arriveAndAwaitAdvance(); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("%s: Entering phase 3.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/>        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(time); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("%s: Finishing phase 3.\n",<br class="title-page-name"/>                          Thread.currentThread().getName()); <br class="title-page-name"/> <br class="title-page-name"/>        phaser.arriveAndDeregister();
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create a new <kbd class="calibre15">Phaser</kbd> object named <kbd class="calibre15">phaser</kbd> with three participants:</li>
</ol>
<pre class="calibre23">
        Phaser phaser=new Phaser(3);
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create and launch three threads to execute three task objects:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;3; i++) { <br class="title-page-name"/>          Task task=new Task(i+1, phaser); <br class="title-page-name"/>          Thread thread=new Thread(task); <br class="title-page-name"/>          thread.start(); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create a loop with 10 steps to write information about the <kbd class="calibre15">phaser</kbd> object:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;10; i++) {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Write information about the registered parties, the phase of the <kbd class="calibre15">phaser</kbd>, the arrived parties, and the unarrived parties:</li>
</ol>
<pre class="calibre23">
        System.out.printf("********************\n"); <br class="title-page-name"/>        System.out.printf("Main: Phaser Log\n"); <br class="title-page-name"/>        System.out.printf("Main: Phaser: Phase: %d\n",<br class="title-page-name"/>                          phaser.getPhase()); <br class="title-page-name"/>        System.out.printf("Main: Phaser: Registered Parties: %d\n",<br class="title-page-name"/>                          phaser.getRegisteredParties()); <br class="title-page-name"/>        System.out.printf("Main: Phaser: Arrived Parties: %d\n",<br class="title-page-name"/>                          phaser.getArrivedParties()); <br class="title-page-name"/>        System.out.printf("Main: Phaser: Unarrived Parties: %d\n",<br class="title-page-name"/>                          phaser.getUnarrivedParties()); <br class="title-page-name"/>        System.out.printf("********************\n");
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Put the thread to sleep for 1 second and close the loop and the class:</li>
</ol>
<pre class="calibre23">
              TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented a phased task in the <kbd class="calibre15">Task</kbd> class. This phased task has three phases and uses a <kbd class="calibre15">Phaser</kbd> interface to synchronize with other <kbd class="calibre15">Task</kbd> objects. The main class launches three tasks, and when these tasks execute their respective phases, it prints information about the status of the <kbd class="calibre15">phaser</kbd> object to the console. We used the following methods to get the status of the <kbd class="calibre15">phaser</kbd> object:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getPhase()</kbd>: This method returns the actual phase of a <kbd class="calibre15">phaser</kbd> object</li>
<li class="calibre18"><kbd class="calibre15">getRegisteredParties()</kbd>: This method returns the number of tasks that use a <kbd class="calibre15">phaser</kbd> object as a mechanism of synchronization</li>
<li class="calibre18"><kbd class="calibre15">getArrivedParties()</kbd>: This method returns the number of tasks that have arrived at the end of the actual phase</li>
<li class="calibre18"><kbd class="calibre15">getUnarrivedParties()</kbd>: This method returns the number of tasks that haven't yet arrived at the end of the actual phase</li>
</ul>
<p class="calibre4">The following screenshot shows part of the output of the program:</p>
<div class="cdpaligncenter"><img class="image-border11" src="../images/00058.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Running concurrent-phased tasks</em> recipe in <a href="part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 3</span></a>, <em class="calibre14">Thread Synchronization Utilities</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring an Executor framework</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Executor</kbd> framework provides a mechanism that separates the implementation of tasks from thread creation and management to execute the tasks. If you use an executor, you only have to implement <kbd class="calibre15">Runnable</kbd> objects and send them to the executor. It is the responsibility of an executor to manage threads. When you send a task to an executor, it tries to use a pooled thread for executing the task in order to avoid the creation of new threads. This mechanism is offered by the <kbd class="calibre15">Executor</kbd> interface and its implementing classes as the <kbd class="calibre15">ThreadPoolExecutor</kbd> class.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about the status of a <kbd class="calibre15">ThreadPoolExecutor</kbd> executor and how to obtain it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">long</kbd> attribute named <kbd class="calibre15">milliseconds</kbd>:</li>
</ol>
<pre class="calibre23">
        private final long milliseconds;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attribute:</li>
</ol>
<pre class="calibre23">
        public Task (long milliseconds) { <br class="title-page-name"/>          this.milliseconds=milliseconds; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Put the thread to sleep for the number of milliseconds specified by the <kbd class="calibre15">milliseconds</kbd> attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/> <br class="title-page-name"/>          System.out.printf("%s: Begin\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(milliseconds); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>          System.out.printf("%s: End\n",<br class="title-page-name"/>                            Thread.currentThread().getName()); <br class="title-page-name"/> <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Create a new <kbd class="calibre15">Executor</kbd> object using the <kbd class="calibre15">newCachedThreadPool()</kbd> method of the <kbd class="calibre15">Executors</kbd> class:</li>
</ol>
<pre class="calibre23">
        ThreadPoolExecutor executor = (ThreadPoolExecutor)<br class="title-page-name"/>                                Executors.newCachedThreadPool();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create and submit 10 <kbd class="calibre15">Task</kbd> objects to the executor. Initialize the objects with a random number:</li>
</ol>
<pre class="calibre23">
        Random random=new Random(); <br class="title-page-name"/>        for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>          Task task=new Task(random.nextInt(10000)); <br class="title-page-name"/>          executor.submit(task); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a loop with five steps. In each step, write information about the executor by calling the <kbd class="calibre15">showLog()</kbd> method and putting the thread to sleep for a second:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          showLog(executor); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Shut down the executor using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.shutdown();
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create another loop with five steps. In each step, write information about the executor by calling the <kbd class="calibre15">showLog()</kbd> method and putting the thread to sleep for a second:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;5; i++){ <br class="title-page-name"/>          showLog(executor); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        }
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Wait for the finalization of the executor using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        executor.awaitTermination(1, TimeUnit.DAYS);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Display a message indicating the end of the program:</li>
</ol>
<pre class="calibre23">
          System.out.printf("Main: End of the program.\n"); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">showLog()</kbd> method that receives <kbd class="calibre15">Executor</kbd> as a parameter. Write information about the size of the pool, the number of tasks, and the status of the executor:</li>
</ol>
<pre class="calibre23">
        private static void showLog(ThreadPoolExecutor executor) { <br class="title-page-name"/>          System.out.printf("*********************"); <br class="title-page-name"/>          System.out.printf("Main: Executor Log"); <br class="title-page-name"/>          System.out.printf("Main: Executor: Core Pool Size: %d\n",<br class="title-page-name"/>                            executor.getCorePoolSize()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Pool Size: %d\n",<br class="title-page-name"/>                            executor.getPoolSize()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Active Count: %d\n",<br class="title-page-name"/>                            executor.getActiveCount()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Task Count: %d\n",<br class="title-page-name"/>                            executor.getTaskCount()); 
</pre>
<pre class="calibre23">
          System.out.printf("Main: Executor: Completed Task Count: %d\n",<br class="title-page-name"/>                            executor.getCompletedTaskCount()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Shutdown: %s\n",<br class="title-page-name"/>                            executor.isShutdown()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Terminating: %s\n",<br class="title-page-name"/>                            executor.isTerminating()); <br class="title-page-name"/>          System.out.printf("Main: Executor: Terminated: %s\n",<br class="title-page-name"/>                            executor.isTerminated()); <br class="title-page-name"/>          System.out.printf("*********************\n"); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented a task that blocks its execution thread for a random number of milliseconds. Then, you sent 10 tasks to an executor, and while you were waiting for their finalization, you wrote information about the status of the executor to the console. You used the following methods to get the status of the <kbd class="calibre15">Executor</kbd> object:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getCorePoolSize()</kbd>: This method returns an <kbd class="calibre15">int</kbd> number, which refers to the core number of threads. It's the minimum number of threads that will be in the internal thread pool when the executor is not executing any task.</li>
<li class="calibre18"><kbd class="calibre15">getPoolSize()</kbd>: This method returns an <kbd class="calibre15">int</kbd> value, which refers to the actual size of the internal thread pool.</li>
<li class="calibre18"><kbd class="calibre15">getActiveCount()</kbd>: This method returns an <kbd class="calibre15">int</kbd> number, which refers to the number of threads that are currently executing tasks.</li>
<li class="calibre18"><kbd class="calibre15">getTaskCount()</kbd>: This method returns a <kbd class="calibre15">long</kbd> number, which refers to the number of tasks that have been scheduled for execution.</li>
<li class="calibre18"><kbd class="calibre15">getCompletedTaskCount()</kbd>: This method returns a <kbd class="calibre15">long</kbd> number, which refers to the number of tasks that have been executed by this executor and have finished their execution.</li>
<li class="calibre18"><kbd class="calibre15">isShutdown()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value when the <kbd class="calibre15">shutdown()</kbd> method of an executor is called to finish its execution.</li>
<li class="calibre18"><kbd class="calibre15">isTerminating()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value when the executor performs the <kbd class="calibre15">shutdown()</kbd> operation but hasn't finished it yet.</li>
<li class="calibre18"><kbd class="calibre15">isTerminated()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value when the executor finishes its execution.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a thread executor and controlling its rejected tasks</em> recipe in <a href="part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre14">Thread Executors</em></li>
<li class="calibre18">The <em class="calibre14">Customizing the ThreadPoolExecutor class</em> and <em class="calibre14">Implementing a priority-based Executor class</em> recipes in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a fork/join pool</h1>
            

            <article>
                
<p class="calibre4">The Executor framework provides a mechanism that allows you to separate task implementation from the creation and management of threads that execute the tasks. Java 9 includes an extension of the Executor framework for a specific kind of problem that will improve the performance of other solutions (using <kbd class="calibre15">Thread</kbd> objects directly or the Executor framework). It's the fork/join framework.</p>
<p class="calibre4">This framework is designed to solve problems that can be broken down into smaller tasks using theÂ <kbd class="calibre15">fork()</kbd> and <kbd class="calibre15">join()</kbd> operations. The main class that implements this behavior is <kbd class="calibre15">ForkJoinPool</kbd>.</p>
<p class="calibre4">In this recipe, you will learn what information you can obtain about a <kbd class="calibre15">ForkJoinPool</kbd> class and how to obtain it.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that extends the <kbd class="calibre15">RecursiveAction</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task extends RecursiveAction{
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> array attribute named <kbd class="calibre15">array</kbd> to store the array of elements you want to increment:</li>
</ol>
<pre class="calibre23">
        private final int array[];
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> to store the start and end positions of the block of elements this task has to process:</li>
</ol>
<pre class="calibre23">
        private final int start; <br class="title-page-name"/>        private final int end;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task (int array[], int start, int end) { <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method with the main logic of the task. If the task has to process more than 100 elements, first divide the elements into two parts, create two tasks to execute these parts, start its execution with the <kbd class="calibre15">fork()</kbd> method, and finally, wait for its finalization with the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        protected void compute() { <br class="title-page-name"/>          if (end-start&gt;100) { <br class="title-page-name"/>            int mid=(start+end)/2; <br class="title-page-name"/>            Task task1=new Task(array,start,mid); <br class="title-page-name"/>            Task task2=new Task(array,mid,end); <br class="title-page-name"/> <br class="title-page-name"/>            task1.fork(); <br class="title-page-name"/>            task2.fork(); <br class="title-page-name"/> <br class="title-page-name"/>            task1.join(); <br class="title-page-name"/>            task2.join();
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">If the task has to process 100 elements or less, increment the elements by putting the thread to sleep for 5 milliseconds after each operation:</li>
</ol>
<pre class="calibre23">
          } else { <br class="title-page-name"/>              for (int i=start; i&lt;end; i++) { <br class="title-page-name"/>                array[i]++; <br class="title-page-name"/> <br class="title-page-name"/>                try { <br class="title-page-name"/>                  Thread.sleep(5); <br class="title-page-name"/>                } catch (InterruptedException e) { <br class="title-page-name"/>                  e.printStackTrace(); <br class="title-page-name"/>                } <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/> <br class="title-page-name"/>          public static void main(String[] args) throws Exception {
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object named <kbd class="calibre15">pool</kbd>:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool();
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create an array of integer numbers, named <kbd class="calibre15">array</kbd>, with 10,000 elements:</li>
</ol>
<pre class="calibre23">
        int array[]=new int[10000];
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a new <kbd class="calibre15">Task</kbd> object to process the whole array:</li>
</ol>
<pre class="calibre23">
        Task task1=new Task(array,0,array.length);
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Send the task for execution to the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task1);
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">If the task doesn't finish its execution, call the <kbd class="calibre15">showLog()</kbd> method to write information about the status of the <kbd class="calibre15">ForkJoinPool</kbd> class and put the thread to sleep for a second:</li>
</ol>
<pre class="calibre23">
        while (!task1.isDone()) { <br class="title-page-name"/>          showLog(pool); <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Shut down the pool using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown();
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Wait for the finalization of the pool using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.awaitTermination(1, TimeUnit.DAYS);
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Call the <kbd class="calibre15">showLog()</kbd> method to write information about the status of the <kbd class="calibre15">ForkJoinPool</kbd> class and write a message in the console indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        showLog(pool); <br class="title-page-name"/>        System.out.printf("Main: End of the program.\n");
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the <kbd class="calibre15">showLog()</kbd> method. It receives a <kbd class="calibre15">ForkJoinPool</kbd> object as a parameter and writes information about its status and the threads and tasks that are being executed:</li>
</ol>
<pre class="calibre23">
        private static void showLog(ForkJoinPool pool) { <br class="title-page-name"/>          System.out.printf("**********************\n"); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool log\n"); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Parallelism: %d\n",<br class="title-page-name"/>                            pool.getParallelism()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Pool Size: %d\n",<br class="title-page-name"/>                            pool.getPoolSize()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Active Thread Count:<br class="title-page-name"/>                             %d\n", pool.getActiveThreadCount()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Running Thread Count:<br class="title-page-name"/>                             %d\n", pool.getRunningThreadCount()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Queued Submission:<br class="title-page-name"/>                             %d\n", pool.getQueuedSubmissionCount()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Queued Tasks: %d\n",<br class="title-page-name"/>                            pool.getQueuedTaskCount()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Queued Submissions:<br class="title-page-name"/>                             %s\n", pool.hasQueuedSubmissions()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Steal Count: %d\n",<br class="title-page-name"/>                            pool.getStealCount()); <br class="title-page-name"/>          System.out.printf("Main: Fork/Join Pool: Terminated : %s\n",<br class="title-page-name"/>                            pool.isTerminated()); <br class="title-page-name"/>          System.out.printf("**********************\n"); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented a task that increments the elements of an array, using a <kbd class="calibre15">ForkJoinPool</kbd> class, and a <kbd class="calibre15">Task</kbd> class that extends the <kbd class="calibre15">RecursiveAction</kbd> class. This is one of the tasks you can execute in a <kbd class="calibre15">ForkJoinPool</kbd> class. When the tasks were processing the array, you printed information about the status of the <kbd class="calibre15">ForkJoinPool</kbd> class to the console. You used the following methods to get the status of the <kbd class="calibre15">ForkJoinPool</kbd> class:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getPoolSize()</kbd>: This method returns an <kbd class="calibre15">int</kbd> value, which is the number of worker threads of the internal pool of a <kbd class="calibre15">ForkJoinPool</kbd> class</li>
<li class="calibre18"><kbd class="calibre15">getParallelism()</kbd>: This method returns the desired level of parallelism established for a pool</li>
<li class="calibre18"><kbd class="calibre15">getActiveThreadCount()</kbd>: This method returns the number of threads that are currently executing tasks</li>
<li class="calibre18"><kbd class="calibre15">getRunningThreadCount()</kbd>: This method returns the number of working threads that are not blocked in any synchronization mechanism</li>
<li class="calibre18"><kbd class="calibre15">getQueuedSubmissionCount()</kbd>: This method returns the number of tasks that have been submitted to a pool and haven't started their execution yet</li>
<li class="calibre18"><kbd class="calibre15">getQueuedTaskCount()</kbd>: This method returns the number of tasks that have been submitted to a pool and have started their execution</li>
<li class="calibre18"><kbd class="calibre15">hasQueuedSubmissions()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether the pool has queued tasks that haven't started their execution yet</li>
<li class="calibre18"><kbd class="calibre15">getStealCount()</kbd>: This method returns a <kbd class="calibre15">long</kbd> value specifying the number of times a worker thread has stolen a task from another thread</li>
<li class="calibre18"><kbd class="calibre15">isTerminated()</kbd>: This method returns a <kbd class="calibre15">Boolean</kbd> value indicating whether the fork/join pool has finished its execution</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in <a href="part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 5</span></a>, <em class="calibre14">Fork/Join Framework</em></li>
<li class="calibre18">The <em class="calibre14">Implementing the ThreadFactory interface to generate custom threads for the fork/join framework</em> and <em class="calibre14">Customizing tasks running in the fork/join framework</em> recipes in <a href="part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 8</span></a>, <em class="calibre14">Customizing Concurrency Classes</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring a stream</h1>
            

            <article>
                
<p class="calibre4">A stream in Java is a sequence of elements that could be processed (mapped, filtered, transformed, reduced, and collected) either parallelly or sequentially in a pipeline of declarative operations using <kbd class="calibre15">lambda</kbd> expressions. It was introduced in Java 8 to change the way one can process enormous sets of data in a functional way, with lambda expressions instead of the traditional imperative way.</p>
<p class="calibre4">The <kbd class="calibre15">Stream</kbd> interface doesn't provide a lot of methods as other concurrency classes to monitor its status. Only the <kbd class="calibre15">peek()</kbd> method allows you to write log information about the elements that are being processed. In this recipe, you will learn how to use this method to write information about a stream.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method. Declare two private variables, namely an <kbd class="calibre15">AtomicInteger</kbd> variable called <kbd class="calibre15">counter</kbd> and a <kbd class="calibre15">Random</kbd> object called <kbd class="calibre15">random</kbd>:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/> <br class="title-page-name"/>            AtomicLong counter = new AtomicLong(0); <br class="title-page-name"/>            Random random=new Random();
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create a stream of 1,000 random <kbd class="calibre15">double</kbd> numbers. The stream created is a sequential stream. You have to make it parallel using the <kbd class="calibre15">parallel()</kbd> method, and use the <kbd class="calibre15">peek()</kbd> method to increment the value of the <kbd class="calibre15">counter</kbd> variable and write a message in the console. Post this, use the <kbd class="calibre15">count()</kbd> method to count the number of elements in the array and store that number in an integer variable. Write the value stored in the <kbd class="calibre15">counter</kbd> variable and the value returned by the <kbd class="calibre15">count()</kbd> method in the console:</li>
</ol>
<pre class="calibre23">
        long streamCounter = random.doubles(1000).parallel()<br class="title-page-name"/>                             .peek( number -&gt; { <br class="title-page-name"/>          long actual=counter.incrementAndGet(); <br class="title-page-name"/>          System.out.printf("%d - %f\n", actual, number); <br class="title-page-name"/>        }).count(); <br class="title-page-name"/> <br class="title-page-name"/>        System.out.printf("Counter: %d\n", counter.get()); <br class="title-page-name"/>        System.out.printf("Stream Counter: %d\n", streamCounter);
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Now, set the value of the <kbd class="calibre15">counter</kbd> variable to 0. Create another stream of 1,000 random <kbd class="calibre15">double</kbd> numbers. Then, convert it into a parallel stream using the <kbd class="calibre15">parallel()</kbd> method, and use the <kbd class="calibre15">peek()</kbd> method to increment the value of the <kbd class="calibre15">counter</kbd> variable and write a message in the console. Finally, use the <kbd class="calibre15">forEach()</kbd> method to write all the numbers and the value of the counter variable in the console:</li>
</ol>
<pre class="calibre23">
            counter.set(0); <br class="title-page-name"/>            random.doubles(1000).parallel().peek(number -&gt; { <br class="title-page-name"/>              long actual=counter.incrementAndGet(); <br class="title-page-name"/>              System.out.printf("Peek: %d - %f\n", actual,number); <br class="title-page-name"/>            }).forEach( number -&gt; { <br class="title-page-name"/>              System.out.printf("For Each: %f\n", number); <br class="title-page-name"/>            }); <br class="title-page-name"/> <br class="title-page-name"/>            System.out.printf("Counter: %d\n", counter.get()); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, we used the <kbd class="calibre15">peek()</kbd> method in two different situations to count the number of elements that pass by this step of the stream and write a message in the console.</p>
<p class="calibre4">As described in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 6</span></a>, <em class="calibre14">Parallel and Reactive Streams</em>, <kbd class="calibre15">Stream</kbd> has a source, zero or more intermediate operations, and a final operation. In the first case, our final operation is the <kbd class="calibre15">count()</kbd> method. This method doesn't need to process the elements to calculate the returned value, so the <kbd class="calibre15">peek()</kbd> method will never be executed. You won't see any of the messages of the peek method in the console, and the value of the counter variable will be 0.</p>
<p class="calibre4">The second case is different. The final operation is the <kbd class="calibre15">forEach()</kbd> method, and in this case, all the elements of the stream will be processed. In the console, you will see messages of both <kbd class="calibre15">peek()</kbd> and <kbd class="calibre15">forEach()</kbd> methods. The final value of the <kbd class="calibre15">counter</kbd> variable will be 1,000.</p>
<p class="calibre4">The <kbd class="calibre15">peek()</kbd> method is an intermediate operation of a stream. Like with all intermediate operations, they are executed lazily, and they only process the necessary elements. This is the reason why it's never executed in the first case.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating streams from different sources</em>, <em class="calibre14">Reducing the elements of a stream</em> and <em class="calibre14">Collecting the elements of a stream</em> recipes in <a href="part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 6</span></a>, <em class="calibre14">Parallel and Reactive Streams</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Writing effective log messages</h1>
            

            <article>
                
<p class="calibre4">A <strong class="calibre1">log</strong> system is a mechanism that allows you to write information to one or more destinations. A <strong class="calibre1">Logger</strong> has the following components:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">One or more handlers</strong>: A handler will determine the destination and format of the log messages. You can write log messages in the console, a file, or a database.</li>
<li class="calibre18"><strong class="calibre1">A name</strong>: Usually, the name of a Logger used in a class is based on the class name and its package name.</li>
</ul>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">A level</strong>: Log messages have different levels that indicate their importance. A Logger also has a level to decide what messages it is going to write. It only writes messages that are as important as, or more important, than its level.</li>
</ul>
<p class="calibre4">You should use the log system because of the following two main reasons:</p>
<ul class="calibre17">
<li class="calibre18">Write as much information as you can when an exception is caught. This will help you localize the error and resolve it.</li>
<li class="calibre18">Write information about the classes and methods that the program is executing.</li>
</ul>
<p class="calibre4">In this recipe, you will learn how to use the classes provided by the <kbd class="calibre15">java.util.logging</kbd> package to add a log system to your concurrent application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">MyFormatter</kbd> that extends the <kbd class="calibre15">java.util.logging.Formatter</kbd> class. Implement the abstract <kbd class="calibre15">format()</kbd> method. It receives a <kbd class="calibre15">LogRecord</kbd> object as a parameter and returns a <kbd class="calibre15">String</kbd> object with a log message:</li>
</ol>
<pre class="calibre23">
        public class MyFormatter extends Formatter { <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public String format(LogRecord record) { <br class="title-page-name"/> <br class="title-page-name"/>            StringBuilder sb=new StringBuilder(); <br class="title-page-name"/>            sb.append("["+record.getLevel()+"] - "); <br class="title-page-name"/>            sb.append(new Date(record.getMillis())+" : "); <br class="title-page-name"/>            sb.append(record.getSourceClassName()+ "."<br class="title-page-name"/>                      +record.getSourceMethodName()+" : "); <br class="title-page-name"/>            sb.append(record.getMessage()+"\n");. <br class="title-page-name"/>            return sb.toString(); <br class="title-page-name"/>          }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">MyLoggerFactory</kbd>:</li>
</ol>
<pre class="calibre23">
        public class MyLoggerFactory {
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private static <kbd class="calibre15">Handler</kbd> attribute named <kbd class="calibre15">handler</kbd>:</li>
</ol>
<pre class="calibre23">
        private static Handler handler;
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the public static method <kbd class="calibre15">getLogger()</kbd> to create the <kbd class="calibre15">Logger</kbd> object that you're going to use to write log messages. It receives a <kbd class="calibre15">String</kbd> parameter called <kbd class="calibre15">name</kbd>. We synchronize this method with the <kbd class="calibre15">synchronized</kbd> keyword:</li>
</ol>
<pre class="calibre23">
        public synchronized static Logger getLogger(String name){
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Get <kbd class="calibre15">java.util.logging.Logger</kbd> associated with the name received as a parameter using the <kbd class="calibre15">getLogger()</kbd> method of the <kbd class="calibre15">Logger</kbd> class:</li>
</ol>
<pre class="calibre23">
        Logger logger=Logger.getLogger(name);
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Establish the log level to write all the log messages using the <kbd class="calibre15">setLevel()</kbd> method:</li>
</ol>
<pre class="calibre23">
        logger.setLevel(Level.ALL);
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">If the handler attribute has the null value, create a new <kbd class="calibre15">FileHandler</kbd> object to write log messages in the <kbd class="calibre15">recipe8.log</kbd> file. Assign a <kbd class="calibre15">MyFormatter</kbd> object to this handler; assign it as a formatter using the <kbd class="calibre15">setFormatter()</kbd> object:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          if (handler==null) { <br class="title-page-name"/>            handler=new FileHandler("recipe6.log"); <br class="title-page-name"/>            Formatter format=new MyFormatter(); <br class="title-page-name"/>            handler.setFormatter(format); <br class="title-page-name"/>          }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">If the <kbd class="calibre15">Logger</kbd> object does not have a handler associated with it, assign the handler using the <kbd class="calibre15">addHandler()</kbd> method:</li>
</ol>
<pre class="calibre23">
            if (logger.getHandlers().length==0) { <br class="title-page-name"/>              logger.addHandler(handler); <br class="title-page-name"/>            } <br class="title-page-name"/>          } catch (SecurityException e | IOException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Return the <kbd class="calibre15">Logger</kbd> object created:</li>
</ol>
<pre class="calibre23">
          return logger; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that implements the <kbd class="calibre15">Runnable</kbd> interface. It will be the task used to test your <kbd class="calibre15">Logger</kbd> object:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() {
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">First, declare a <kbd class="calibre15">Logger</kbd> object named <kbd class="calibre15">logger</kbd>. Initialize it using the <kbd class="calibre15">getLogger()</kbd> method of the <kbd class="calibre15">MyLogger</kbd> class by passing the name of this class as a parameter:</li>
</ol>
<pre class="calibre23">
        Logger logger= MyLogger.getLogger(this.getClass().getName());
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Write a log message indicating the beginning of the execution of the method, using the <kbd class="calibre15">entering()</kbd> method:</li>
</ol>
<pre class="calibre23">
        logger.entering(Thread.currentThread().getName(), "run()");
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Sleep the thread for two seconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          TimeUnit.SECONDS.sleep(2); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        }
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Write a log message indicating the end of the execution of the method, using the <kbd class="calibre15">exiting()</kbd> method:</li>
</ol>
<pre class="calibre23">
          logger.exiting(Thread.currentThread().getName(), "run()",<br class="title-page-name"/>                         Thread.currentThread()); <br class="title-page-name"/>        }
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Declare a <kbd class="calibre15">Logger</kbd> object named <kbd class="calibre15">logger</kbd>. Initialize it using the <kbd class="calibre15">getLogger()</kbd> method of the <kbd class="calibre15">MyLogger</kbd> class by passing the <kbd class="calibre15">Core</kbd> string as a parameter:</li>
</ol>
<pre class="calibre23">
        Logger logger=MyLogger.getLogger(Main.class.getName());
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Write a log message indicating the start of the execution of the main program, using the <kbd class="calibre15">entering()</kbd> method:</li>
</ol>
<pre class="calibre23">
        logger.entering(Main.class.getName(), "main()",args);
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create a <kbd class="calibre15">Thread</kbd> array to store five threads:</li>
</ol>
<pre class="calibre23">
        Thread threads[]=new Thread[5];
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Create five <kbd class="calibre15">Task</kbd> objects and five threads to execute them. Write log messages to indicate that you're going to launch a new thread and that you have created the thread:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          logger.log(Level.INFO,"Launching thread: "+i); <br class="title-page-name"/>          Task task=new Task(); <br class="title-page-name"/>          threads[i]=new Thread(task); <br class="title-page-name"/>          logger.log(Level.INFO,"Thread created: "+<br class="title-page-name"/>                     threads[i].getName()); <br class="title-page-name"/>          threads[i].start(); <br class="title-page-name"/>        }
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Write a log message to indicate that you have created the threads:</li>
</ol>
<pre class="calibre23">
        logger.log(Level.INFO,"Ten Threads created."+<br class="title-page-name"/>                   "Waiting for its finalization");
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Wait for the finalization of the five threads using the <kbd class="calibre15">join()</kbd> method. After the finalization of each thread, write a log message indicating that the thread has finished:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;threads.length; i++) { <br class="title-page-name"/>          try { <br class="title-page-name"/>            threads[i].join(); <br class="title-page-name"/>            logger.log(Level.INFO,"Thread has finished its execution",<br class="title-page-name"/>                       threads[i]); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            logger.log(Level.SEVERE, "Exception", e); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Write a log message to indicate the end of the execution of the main program, using the <kbd class="calibre15">exiting()</kbd> method:</li>
</ol>
<pre class="calibre23">
          logger.exiting(Main.class.getName(), "main()"); <br class="title-page-name"/>        }
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you used the <kbd class="calibre15">Logger</kbd> class provided by the Java logging API to write log messages in a concurrent application. First of all, you implemented the <kbd class="calibre15">MyFormatter</kbd> class to assign a format to the log messages. This class extends the <kbd class="calibre15">Formatter</kbd> class that declares the abstract <kbd class="calibre15">format()</kbd> method. This method receives a <kbd class="calibre15">LogRecord</kbd> object with all of the information of the log message and returns a formatted log message. In your class, you used the following methods of the <kbd class="calibre15">LogRecord</kbd> class to obtain information about the log message:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">getLevel()</kbd>: Returns the level of a message</li>
<li class="calibre18"><kbd class="calibre15">getMillis()</kbd>: Returns the date when a message was sent to a <kbd class="calibre15">Logger</kbd> object</li>
<li class="calibre18"><kbd class="calibre15">getSourceClassName()</kbd>: Returns the name of a class that had sent the message to the Logger</li>
<li class="calibre18"><kbd class="calibre15">getSourceMessageName()</kbd>: Returns the name of the method that had sent the message to the Logger</li>
<li class="calibre18"><kbd class="calibre15">getMessage()</kbd>: Returns the log message</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">MyLogger</kbd> class implements the static method <kbd class="calibre15">getLogger()</kbd>. This method creates a <kbd class="calibre15">Logger</kbd> object and assigns a <kbd class="calibre15">Handler</kbd> object to write log messages of the application to the <kbd class="calibre15">recipe6.log</kbd> file, using the <kbd class="calibre15">MyFormatter</kbd> formatter. You create the <kbd class="calibre15">Logger</kbd> object with the static method <kbd class="calibre15">getLogger()</kbd> of the <kbd class="calibre15">Logger</kbd>Â class. This method returns a different object per name that is passed as a parameter. You only created one <kbd class="calibre15">Handler</kbd> object, so all the <kbd class="calibre15">Logger</kbd> objects will write their log messages in the same file. You also configured the logger to write all the log messages, regardless of their level.</p>
<p class="calibre4">Finally, you implemented a <kbd class="calibre15">Task</kbd> object and a main program that writes different log messages in the log file. You used the following methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">entering()</kbd>: To write a message with the <kbd class="calibre15">FINER</kbd> level indicating that a method has started its execution</li>
<li class="calibre18"><kbd class="calibre15">exiting()</kbd>: To write a message with the <kbd class="calibre15">FINER</kbd> level indicating that a method has ended its execution</li>
<li class="calibre18"><kbd class="calibre15">log()</kbd>: To write a message with the specified level</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">When you work with a log system, you have to take into consideration two important points:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Write the necessary information</strong>: If you write too little information, the logger won't be useful because it won't fulfil its purpose. If you write a lot of information, you will generate large unmanageable log files; this will make it difficult to get the necessary information.</li>
<li class="calibre18"><strong class="calibre1">Use the adequate level for the messages</strong>: If you write high level information messages or low level error messages, you will confuse the user who will look at the log files. This will make it more difficult to know what happened in an error situation; alternatively, you will have too much of information making it difficult to know the main cause of the error.</li>
</ul>
<p class="calibre4">There are other libraries that provide a log system that is more complete than the <kbd class="calibre15">java.util.logging</kbd> package, such as the <kbd class="calibre15">Log4j</kbd> or <kbd class="calibre15">slf4j</kbd> libraries. But the <kbd class="calibre15">java.util.logging</kbd> package is part of the Java API, and all its methods are multithread safe; therefore, we can use it in concurrent applications without problems.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Using non-blocking thread-safe deques</em>, <em class="calibre14">Using blocking thread-safe deques</em>, <em class="calibre14">Using blocking thread-safe queuesÂ ordered by priority</em>, <em class="calibre14">Using thread-safe lists with delayed elements</em>Â andÂ <em class="calibre14">Using thread-safe navigable mapsÂ </em>recipes in <a href="part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre14">Concurrent Collections</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Analyzing concurrent code with FindBugs</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">Static code analysis tools</strong> are a set of tools that analyze the source code of an application while looking for potential errors. These tools, such as Checkstyle, PMD, or FindBugs, have a set of predefined rules of good practices and parse the source code looking for violations of these rules. The objective is to find errors or places that cause poor performance at an early stage, before they are executed in production. Programming languages usually offer such tools, and Java is not an exception. One of the tools that helps analyze Java code is FindBugs. It's an open source tool that includes a series of rules to analyze Java-concurrent code.</p>
<p class="calibre4">In this recipe, you will learn how to use this tool to analyze your Java-concurrent application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">Before you start this recipe, download FindBugs from the project's web page (<a href="http://findbugs.sourceforge.net/" class="calibre9"><span>http://findbugs.sourceforge.net/</span></a>). You can download a standalone application or an Eclipse plugin. In this recipe, I used the standalone version.</p>
<div class="packt_infobox">At the time of this writing, the actual version of FindBugs (3.0.1) doesn't include support for Java 9. You can download a preview of the 3.1.0 version with support for Java 9 from <a href="https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1" class="calibre29"><span class="urlpackt">https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1</span></a>.</div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> that extends the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">ReentrantLock</kbd> attribute named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        private ReentrantLock lock;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement a constructor of the class:</li>
</ol>
<pre class="calibre23">
        public Task(ReentrantLock lock) { <br class="title-page-name"/>          this.lock=lock; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. Get control of the lock, put the thread to sleep for 2 seconds, and free the lock:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock.lock(); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>            lock.unlock(); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) {
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Declare and create a <kbd class="calibre15">ReentrantLock</kbd> object named <kbd class="calibre15">lock</kbd>:</li>
</ol>
<pre class="calibre23">
        ReentrantLock lock=new ReentrantLock();
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create 10 <kbd class="calibre15">Task</kbd> objects and 10 threads to execute the tasks. Start the threads by calling the <kbd class="calibre15">run()</kbd> method:</li>
</ol>
<pre class="calibre23">
          for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>            Task task=new Task(lock); <br class="title-page-name"/>            Thread thread=new Thread(task); <br class="title-page-name"/>            thread.run(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Export the project as a <kbd class="calibre15">.jar</kbd> file. Call it <kbd class="calibre15">recipe7.jar</kbd>. Use the menu option of your IDE or the <kbd class="calibre15">javac</kbd> and <kbd class="calibre15">.jar</kbd> commands to compile and compress your application.</li>
<li value="9" class="calibre18">Start the FindBugs standalone application by running the <kbd class="calibre15">findbugs.bat</kbd> command in Windows or the <kbd class="calibre15">findbugs.sh</kbd> command in Linux.</li>
</ol>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Create a new project by clicking on the <span>New Project</span> option under the <span>File</span> menu in the menu bar:</li>
</ol>
<div class="cdpaligncenter"><img class="aligncenter" src="../images/00059.jpeg"/></div>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">The <em class="calibre14">FindBugs</em> application shows a window to configure the project. In the <span>Project name</span> field, type <kbd class="calibre15">Recipe07</kbd>. In the <span>Classpath for analysis field (jar, ear, war, zip, or directory)</span>, add the <kbd class="calibre15">.jar</kbd> file with the project. In the <span>Source directories field (optional; classes used when browsing found bugs)</span>, add the directory with the source code of the example. Refer to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img class="aligncenter1" src="../images/00060.jpeg"/></div>
<div class="cdpaligncenter"/>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Click on the <span>Analyze</span> button to create the new project and analyze its code.</li>
<li value="13" class="calibre18">The <em class="calibre14">FindBugs</em> application shows the result of the analysis of the code. In this case, it has found two bugs.</li>
<li value="14" class="calibre18">Click on one of the bugs and you'll see the source code of the bug on the right-hand side panel and the description of the bug in the panel at the bottom of the screen.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows the result of the analysis by FindBugs:</p>
<div class="cdpaligncenter"><img class="aligncenter2" src="../images/00061.jpeg"/></div>
<p class="calibre4">The analysis has detected the following two potential bugs in the application:</p>
<ul class="calibre17">
<li class="calibre18">One of the bugs is detected in the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">Task</kbd> class. If an <kbd class="calibre15">InterruptedExeption</kbd> exception is thrown, the task doesn't free the lock because it won't execute the <kbd class="calibre15">unlock()</kbd> method. This will probably cause a deadlock situation in the application.</li>
<li class="calibre18">The other bug is detected in the <kbd class="calibre15">main()</kbd> method of the <kbd class="calibre15">Main</kbd> class because you called the <kbd class="calibre15">run()</kbd> method of a thread directly, not the <kbd class="calibre15">start()</kbd> method to begin the execution of the thread.</li>
</ul>
<p class="calibre4">If you double-click on one of the two bugs, you will see detailed information about it. As you have included the source code reference in the configuration of the project, you will also see the source code where the bug was detected. The following screenshot shows you an example of this:</p>
<div class="cdpaligncenter"><img class="aligncenter3" src="../images/00062.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">Be aware that FindBugs can only detect some problematic situations (related or not to concurrency code). For example, if you delete the <kbd class="calibre15">unlock()</kbd> call in the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">Task</kbd> class and repeat the analysis, FindBugs won't alert you that<br class="title-page-name"/>
you will get the lock in the task but you will never be able to free it.</p>
<p class="calibre4">Use the tools of the static code analysis as a form of assistance to improve the quality of your code, but do not expect it to detect all the bugs.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Configuring NetBeans for debugging concurrency code</em> recipe inÂ <span>this chapter</span></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configuring Eclipse for debugging concurrency code</h1>
            

            <article>
                
<p class="calibre4">Nowadays, almost every programmer, regardless of the programming language in use, create their applications with an IDE. They provide lots of interesting functionalities integrated in the same application, such as:</p>
<ul class="calibre17">
<li class="calibre18">Project management</li>
<li class="calibre18">Automatic code generation</li>
<li class="calibre18">Automatic documentation generation</li>
<li class="calibre18">Integration with control version systems</li>
<li class="calibre18">A debugger to test applications</li>
<li class="calibre18">Different wizards to create projects and elements of the applications</li>
</ul>
<p class="calibre4">One of the most helpful features of an IDE is a debugger. Using it, you can execute your application step by step and analyze the values of all the objects and variables of your program.</p>
<p class="calibre4">If you work with Java, Eclipse is one of the most popular IDEs. It has an integrated debugger that allows you to test your applications. By default, when you debug a concurrent application and the debugger finds a breakpoint, it only stops the thread that has the breakpoint while it allows the rest of the threads to continue with their execution. In this recipe, you will learn how to change this configuration to help you test concurrent applications.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">You must have installed the Eclipse IDE. Open it and select a project with a concurrent application implemented, for example, one of the recipes implemented in the book.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Navigate to <span>Window</span> | <span>Preferences</span>.</li>
<li value="2" class="calibre18">Expand the <span>Java</span> option in the left-hand side menu.</li>
<li value="3" class="calibre18">Then, select the <span>Debug</span> option. The following screenshot illustrates the window:</li>
</ol>
<div class="cdpaligncenter"><img class="aligncenter4" src="../images/00063.jpeg"/></div>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Change the value of <span>Default suspend policy for new breakpoints</span> from <span>Suspend Thread</span> to <span>Suspend VM</span> (marked in red in the screenshot).</li>
<li value="5" class="calibre18">Click on the <span>OK</span> button to confirm the change.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">As mentioned in the introduction of this recipe, by default, when you debug a concurrent Java application in Eclipse and the debug process finds a breakpoint, it only suspends the thread that hits the breakpoint first, but it allows other threads to continue with their execution. The following screenshot shows an example of this:</p>
<div class="cdpaligncenter"><img class="aligncenter5" src="../images/00064.jpeg"/></div>
<p class="calibre4">You can see that only <span>worker-21</span> is suspended (marked in red in the screenshot), while the rest of the threads are running. However, while debugging a concurrent application, if you change <span>Default suspend policy for new breakpoints</span> to <span>Suspend VM</span>, all the threads will suspend their execution and the debug process will hit a breakpoint.. The following screenshot shows an example of this situation:</p>
<div class="cdpaligncenter"><img class="aligncenter6" src="../images/00065.jpeg"/></div>
<p class="calibre4">With the change, you can see that all the threads are suspended. You can continue debugging any thread you want. Choose the suspend policy that best suits your needs.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configuring NetBeans for debugging concurrency code</h1>
            

            <article>
                
<p class="calibre4">Software is necessary to develop applications that work properly, meet the quality standards of the company, and could be easily modified in future (in limited time and cost as low as possible). To achieve this goal, it is essential to use an IDE that can integrate Â several tools (compilers and debuggers) that facilitate the development of applications under one common interface.</p>
<p class="calibre4">If you work with Java, NetBeans is one of the most popular IDEs. It has an integrated debugger that allows you to test your application.</p>
<p class="calibre4">In this recipe, you will learn how to change the configuration of the Netbeans debugger to help you test concurrent applications.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">You should have the NetBeans IDE installed. Open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task1</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task1 implements Runnable {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare two private <kbd class="calibre15">Lock</kbd> attributes, named <kbd class="calibre15">lock1</kbd> and <kbd class="calibre15">lock2</kbd>:</li>
</ol>
<pre class="calibre23">
        private Lock lock1, lock2;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task1 (Lock lock1, Lock lock2) { <br class="title-page-name"/>          this.lock1=lock1; <br class="title-page-name"/>          this.lock2=lock2; <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First, get control of the <kbd class="calibre15">lock1</kbd> object using the <kbd class="calibre15">lock()</kbd> method and write aa message in the console indicating that you have got it:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock1.lock(); <br class="title-page-name"/>          System.out.printf("Task 1: Lock 1 locked\n");
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Then, get control of <kbd class="calibre15">lock2</kbd> using the <kbd class="calibre15">lock()</kbd> method and write a message in the console indicating that you have got it:</li>
</ol>
<pre class="calibre23">
        lock2.lock(); <br class="title-page-name"/>        System.out.printf("Task 1: Lock 2 locked\n");
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Finally, release the two lock objects-first the <kbd class="calibre15">lock2</kbd> object and then the <kbd class="calibre15">lock1</kbd> object:</li>
</ol>
<pre class="calibre23">
          lock2.unlock(); <br class="title-page-name"/>          lock1.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">Task2</kbd> and specify that it implements the <kbd class="calibre15">Runnable</kbd> interface:</li>
</ol>
<pre class="calibre23">
        public class Task2 implements Runnable{
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare two private <kbd class="calibre15">Lock</kbd> attributes, named <kbd class="calibre15">lock1</kbd> and <kbd class="calibre15">lock2</kbd>:</li>
</ol>
<pre class="calibre23">
        private Lock lock1, lock2;
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public Task2(Lock lock1, Lock lock2) { <br class="title-page-name"/>          this.lock1=lock1; <br class="title-page-name"/>          this.lock2=lock2; <br class="title-page-name"/>        }
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">run()</kbd> method. First, get control of the <kbd class="calibre15">lock2</kbd> object using the <kbd class="calibre15">lock()</kbd> method and write a message in the console indicating that you have got it:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void run() { <br class="title-page-name"/>          lock2.lock(); <br class="title-page-name"/>          System.out.printf("Task 2: Lock 2 locked\n");
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Then, get control of <kbd class="calibre15">lock1</kbd> using the <kbd class="calibre15">lock()</kbd> method and write a message in the console indicating that you have got it:</li>
</ol>
<pre class="calibre23">
        lock1.lock(); <br class="title-page-name"/>        System.out.printf("Task 2: Lock 1 locked\n");
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Finally, release the two lock objects-first <kbd class="calibre15">lock1</kbd> and then <kbd class="calibre15">lock2</kbd>:</li>
</ol>
<pre class="calibre23">
          lock1.unlock(); <br class="title-page-name"/>          lock2.unlock(); <br class="title-page-name"/>        }
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and adding the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main {
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Create two lock objects named <kbd class="calibre15">lock1</kbd> and <kbd class="calibre15">lock2</kbd>:</li>
</ol>
<pre class="calibre23">
        Lock lock1, lock2; <br class="title-page-name"/>        lock1=new ReentrantLock(); <br class="title-page-name"/>        lock2=new ReentrantLock();
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Create a <kbd class="calibre15">Task1</kbd> object named <kbd class="calibre15">task1</kbd>:</li>
</ol>
<pre class="calibre23">
        Task1 task1=new Task1(lock1, lock2);
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Create a <kbd class="calibre15">Task2</kbd> object named <kbd class="calibre15">task2</kbd>:</li>
</ol>
<pre class="calibre23">
        Task2 task2=new Task2(lock1, lock2);
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Execute both the tasks using two threads:</li>
</ol>
<pre class="calibre23">
        Thread thread1=new Thread(task1); <br class="title-page-name"/>        Thread thread2=new Thread(task2); <br class="title-page-name"/>         <br class="title-page-name"/>        thread1.start(); <br class="title-page-name"/>        thread2.start();
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">When the two tasks finish their execution, write a message in the console every 500 milliseconds. Use the <kbd class="calibre15">isAlive()</kbd> method to check whether a thread has finished its execution:</li>
</ol>
<pre class="calibre23">
        while ((thread1.isAlive()) &amp;&amp;(thread2.isAlive())) { <br class="title-page-name"/>          System.out.println("Main: The example is"+ "running"); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(500); <br class="title-page-name"/>          } catch (InterruptedException ex) { <br class="title-page-name"/>            ex.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Add a breakpoint in the first call to the <kbd class="calibre15">printf()</kbd> method of the <kbd class="calibre15">run()</kbd> method of the <kbd class="calibre15">Task1</kbd> class.</li>
<li value="20" class="calibre18">Debug the program. You will see the <span>Debugging</span> window in the top left-hand side corner of the main NetBeans window. The next screenshot illustrates the window with the thread that executes the <kbd class="calibre15">Task1</kbd> object. The thread is waiting in the breakpoint. The other threads of the application are running:</li>
</ol>
<div class="cdpaligncenter"><img class="aligncenter7" src="../images/00066.jpeg"/></div>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Pause the execution of the main thread. Select the thread, right-click on it, and select the <span>Suspend</span> option. The following screenshot shows the new appearance of the <span>Debugging</span> window. Refer to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img class="aligncenter8" src="../images/00067.jpeg"/></div>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Resume the two paused threads. Select each thread, right-click on them, and select the <span>Resume</span> option.</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">While debugging a concurrent application using NetBeans, when the debugger hits a breakpoint, it suspends the thread that hit the breakpoint and shows the <span>Debugging</span> window in the top left-hand side corner with the threads that are currently running.<br class="title-page-name"/>
You can use the window to pause or resume the threads that are currently running, using the <span>Pause</span> or <span>Resume</span> options. You can also see the values of the variables or attributes of the threads using the <span>Variables</span> tab.</p>
<p class="calibre4">NetBeans also includes a deadlock detector. When you select the <span>Check for Deadlock</span> option in the <span>Debug</span> menu, NetBeans performs an analysis of the application that you're debugging to determine whether there's a deadlock situation. This example presents a clear deadlock. The first thread gets <kbd class="calibre15">lock1</kbd> first and then <kbd class="calibre15">lock2</kbd>. The second thread gets the locks in reverse manner. The breakpoint inserted provokes the deadlock, but if you use the NetBeans deadlock detector, you'll not find anything. Therefore, this option should be used with caution. Change the locks used in both the tasks by the <kbd class="calibre15">synchronized</kbd> keyword and debug the program again. The code of <kbd class="calibre15">Task1</kbd> is as follows:</p>
<pre class="calibre23">
    @Override <br class="title-page-name"/>    public void run() { <br class="title-page-name"/>      synchronized(lock1) { <br class="title-page-name"/>        System.out.printf("Task 1: Lock 1 locked\n"); <br class="title-page-name"/>        synchronized(lock2) { <br class="title-page-name"/>          System.out.printf("Task 1: Lock 2 locked\n"); <br class="title-page-name"/>        } <br class="title-page-name"/>      } <br class="title-page-name"/>    }
</pre>
<p class="calibre4">The code of the <kbd class="calibre15">Task2</kbd> class will be analogous to this, but it changes the order of the locks. If you debug the example again, you will obtain a deadlock one more time. However, in this case, it's detected by the deadlock detector, as you can see in the following screenshot:</p>
<div class="cdpaligncenter"><img class="aligncenter9" src="../images/00068.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">There are options to control the debugger. Select <span>Options</span> from the <span>Tools</span> menu. Then, select the <span>Miscellaneous</span> option and the <span>Java Debugger</span> tab. The following screenshot illustrates this window:</p>
<div class="cdpaligncenter"><img class="aligncenter10" src="../images/00069.gif"/><br class="title-page-name"/></div>
<p class="calibre4">There are two options in the window that control the behavior described earlier:</p>
<ul class="calibre17">
<li class="calibre18"><span>New breakpoints suspend</span>: With this option, you can configure the behavior of NetBeans, which finds a breakpoint in a thread. You can suspend only that thread that has a breakpoint or all the threads of the application.</li>
<li class="calibre18"><span>Steps resume</span>: With this option, you can configure the behavior of NetBeans when you resume a thread. You can resume only the current thread or all the threads.</li>
</ul>
<p class="calibre4">Both the options have been marked in the screenshot presented earlier.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Configuring Eclipse for debugging concurrency code</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Testing concurrency code with MultithreadedTC</h1>
            

            <article>
                
<p class="calibre4"><kbd class="calibre15">MultithreadedTC</kbd> is a Java library for testing concurrent applications. Its main objective is to solve the problem of concurrent applications being non-deterministic. You can't control the order of execution of the different threads that form the application. For this purpose, it includes an internal <strong class="calibre1">metronome</strong>. These testing threads are implemented as methods of a class.</p>
<p class="calibre4">In this recipe, you will learn how to use the <kbd class="calibre15">MultithreadedTC</kbd> library to implement a test for <kbd class="calibre15">LinkedTransferQueue</kbd>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">Download the MultithreadedTC library from <a href="https://code.google.com/archive/p/multithreadedtc/" class="calibre9"><span>https://code.google.com/archive/p/multithreadedtc/</span></a> and the JUnit library, version 4.10, from <a href="http://junit.org/junit4/" class="calibre9"><span>http://junit.org/junit4/</span></a>. Add the <kbd class="calibre15">junit-4.10.jar</kbd> and <kbd class="calibre15">MultithreadedTC-1.01.jar</kbd> files to the libraries of the project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">ProducerConsumerTest</kbd> that extends the <kbd class="calibre15">MultithreadedTestCase</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class ProducerConsumerTest extends MultithreadedTestCase {
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">LinkedTransferQueue</kbd> attribute parameterized by the <kbd class="calibre15">String</kbd> class named <kbd class="calibre15">queue</kbd>:</li>
</ol>
<pre class="calibre23">
        private LinkedTransferQueue&lt;String&gt; queue;
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">initialize()</kbd> method. This method won't receive any parameters and will return no value. It will call the <kbd class="calibre15">initialize()</kbd> method of its parent class and then initialize the queue attribute:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void initialize() { <br class="title-page-name"/>          super.initialize(); <br class="title-page-name"/>          queue=new LinkedTransferQueue&lt;String&gt;(); <br class="title-page-name"/>          System.out.printf("Test: The test has been initialized\n"); <br class="title-page-name"/>        }
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">thread1()</kbd> method. It will implement the logic of the first consumer. Call the <kbd class="calibre15">take()</kbd> method of the queue and then write the returned value in the console:</li>
</ol>
<pre class="calibre23">
        public void thread1() throws InterruptedException { <br class="title-page-name"/>          String ret=queue.take(); <br class="title-page-name"/>          System.out.printf("Thread 1: %s\n",ret); <br class="title-page-name"/>        }
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">thread2()</kbd> method. It will implement the logic of the second consumer. First wait until the first thread has slept in the <kbd class="calibre15">take()</kbd> method. To put the thread to sleep, use the <kbd class="calibre15">waitForTick()</kbd> method.Â Then, call the <kbd class="calibre15">take()</kbd> method of the queue and write the returned value in the console:</li>
</ol>
<pre class="calibre23">
        public void thread2() throws InterruptedException { <br class="title-page-name"/>          waitForTick(1); <br class="title-page-name"/>          String ret=queue.take(); <br class="title-page-name"/>          System.out.printf("Thread 2: %s\n",ret); <br class="title-page-name"/>        }
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">thread3()</kbd> method. It will implement the logic of a producer.<br class="title-page-name"/>
First wait until the two consumers are blocked in the <kbd class="calibre15">take()</kbd> method; block this method using the <kbd class="calibre15">waitForTick()</kbd> method twice.Â Then, call the <kbd class="calibre15">put()</kbd> method of the queue to insert two strings in the queue:</li>
</ol>
<pre class="calibre23">
         public void thread3() { <br class="title-page-name"/>          waitForTick(1); <br class="title-page-name"/>          waitForTick(2); <br class="title-page-name"/>          queue.put("Event 1"); <br class="title-page-name"/>          queue.put("Event 2"); <br class="title-page-name"/>          System.out.printf("Thread 3: Inserted two elements\n"); <br class="title-page-name"/>        }
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Finally, implement the <kbd class="calibre15">finish()</kbd> method. Write a message in the console to indicate that the test has finished its execution. Check that the two events have been consumed (so the size of the queue is <kbd class="calibre15">0</kbd>) using the <kbd class="calibre15">assertEquals()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public void finish() { <br class="title-page-name"/>          super.finish(); <br class="title-page-name"/>          System.out.printf("Test: End\n"); <br class="title-page-name"/>          assertEquals(true, queue.size()==0); <br class="title-page-name"/>          System.out.printf("Test: Result: The queue is empty\n"); <br class="title-page-name"/>        }
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Next, implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) throws Throwable {
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Create a <kbd class="calibre15">ProducerConsumerTest</kbd> object named <kbd class="calibre15">test</kbd>:</li>
</ol>
<pre class="calibre23">
        ProducerConsumerTest test=new ProducerConsumerTest();
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Execute the test using the <kbd class="calibre15">runOnce()</kbd> method of the <kbd class="calibre15">TestFramework</kbd> class:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: Starting the test\n"); <br class="title-page-name"/>        TestFramework.runOnce(test); <br class="title-page-name"/>        System.out.printf("Main: The test has finished\n");
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you implemented a test for the <kbd class="calibre15">LinkedTransferQueue</kbd> class using the <kbd class="calibre15">MultithreadedTC</kbd> library. You can implement a test in any concurrent application or class using this library and its metronome. In the example, you implemented the classical producer/consumer problem with two consumers and a producer. You wanted to test that the first <kbd class="calibre15">String</kbd> object introduced in the buffer is consumed by the first consumer that arrives at the buffer, and the second <kbd class="calibre15">String</kbd> object introduced in the buffer is consumed by the second consumer that arrives at the buffer.</p>
<p class="calibre4">The <kbd class="calibre15">MultithreadedTC</kbd> library is based on the JUnit library, which is the most often used library to implement unit tests in Java. To implement a basic test using the <kbd class="calibre15">MultithreadedTC</kbd> library, you have to extend the <kbd class="calibre15">MultithreadedTestCase</kbd> class. This class extends the <kbd class="calibre15">junit.framework.AssertJUnit</kbd> class that includes all the methods to check the results of the test. It doesn't extend the <kbd class="calibre15">junit.framework.TestCase</kbd> class, so you can't integrate MultithreadedTC tests with other JUnit tests.</p>
<p class="calibre4">Then, you can implement the following methods:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">initialize()</kbd>: The implementation of this method is optional. It's executed when you start the test, so you can use it to initialize objects that are using the test.</li>
<li class="calibre18"><kbd class="calibre15">finish()</kbd>: The implementation of this method is optional. It's executed when the test has finished. You can use it to close or release resources used during the test or to check the results of the test.</li>
<li class="calibre18">Methods that implement the test: These methods have the main logic of the test you implement. They have to start with the <kbd class="calibre15">thread</kbd> keyword, followed by a string, for example, <kbd class="calibre15">thread1()</kbd>.</li>
</ul>
<p class="calibre4">To control the order of execution of threads, you used the <kbd class="calibre15">waitForTick()</kbd> method. This method receives an integer value as a parameter and puts the thread that is executing the method to sleep until all the threads that are running in the test are blocked. When they are blocked, the <kbd class="calibre15">MultithreadedTC</kbd> library resumes the threads that are blocked by a call to the <kbd class="calibre15">waitForTick()</kbd> method.</p>
<p class="calibre4">The integer you pass as a parameter of the <kbd class="calibre15">waitForTick()</kbd> method is used to control the order of execution. The metronome of the <kbd class="calibre15">MultithreadedTC</kbd> library has an internal counter. When all the threads are blocked, the library increments this counter to the next number specified in the <kbd class="calibre15">waitForTick()</kbd> calls that are blocked.</p>
<p class="calibre4">Internally, when the <kbd class="calibre15">MultithreadedTC</kbd> library has to execute a test, first it executes the <kbd class="calibre15">initialize()</kbd> method. Then it creates a thread per method that starts with the <kbd class="calibre15">thread</kbd> keyword (in your example, the methods <kbd class="calibre15">thread1()</kbd>, <kbd class="calibre15">thread2()</kbd>, and <kbd class="calibre15">thread3()</kbd>). When all the threads have finished their execution, it executes the <kbd class="calibre15">finish()</kbd> method. To execute the test, you used the <kbd class="calibre15">runOnce()</kbd> method of the <kbd class="calibre15">TestFramework</kbd> class.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">If the <kbd class="calibre15">MultithreadedTC</kbd> library detects that all the threads of the test are blocked except in the <kbd class="calibre15">waitForTick()</kbd> method, the test is declared to be in a deadlock state and a <kbd class="calibre15">java.lang.IllegalStateException</kbd> exception is thrown.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Analyzing concurrent code with FindBugs</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Monitoring with JConsole</h1>
            

            <article>
                
<p class="calibre4"><strong class="calibre1">JConsole</strong> is a monitoring tool that follows the JMX specification that allows you to get information about the execution of an application as the number of threads, memory use, or class loading. It is included with the JDK and it can be used to monitor local or remote applications. In this recipe, you will learn how to use this tool to monitor a simple concurrent application.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or a different IDE, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd> and specify the <kbd class="calibre15">Runnable</kbd> interface. Implement the <kbd class="calibre15">run()</kbd> method to write theÂ message in the console during 100 seconds:</li>
</ol>
<pre class="calibre23">
        public class Task implements Runnable { <br class="title-page-name"/> <br class="title-page-name"/>          @Override <br class="title-page-name"/>          public void run() { <br class="title-page-name"/> <br class="title-page-name"/>            Date start, end; <br class="title-page-name"/>            start = new Date(); <br class="title-page-name"/>            do { <br class="title-page-name"/>              System.out.printf("%s: tick\n",<br class="title-page-name"/>                                Thread.currentThread().getName()); <br class="title-page-name"/>              end = new Date(); <br class="title-page-name"/>            } while (end.getTime() - start.getTime() &lt; 100000); <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Implement the <kbd class="calibre15">Main</kbd> class with the <kbd class="calibre15">main()</kbd> method. Create 10 <kbd class="calibre15">Task</kbd> objects to create 10 threads. Start them and wait for their finalization using the <kbd class="calibre15">join()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { <br class="title-page-name"/> <br class="title-page-name"/>            Thread[] threads = new Thread[10]; <br class="title-page-name"/> <br class="title-page-name"/>            for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>              Task task=new Task(); <br class="title-page-name"/>              threads[i]=new Thread(task); <br class="title-page-name"/>              threads[i].start(); <br class="title-page-name"/>            } <br class="title-page-name"/> <br class="title-page-name"/>            for (int i=0; i&lt;10; i++) { <br class="title-page-name"/>              try { <br class="title-page-name"/>                threads[i].join(); <br class="title-page-name"/>              } catch (InterruptedException e) { <br class="title-page-name"/>                e.printStackTrace(); <br class="title-page-name"/>              } <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        }
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Open a console window and execute the <kbd class="calibre15">JConsole</kbd> application. It's included in the bin directory of the JDK-9 installation:</li>
</ol>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, we implemented a very simple example: running 10 threads for 100 seconds. These are threads that write messages in the console.</p>
<p class="calibre4">When you execute JConsole, you will see a window that shows all the Java applications that are running in your system. You can choose the one you want to monitor. The window will be similar to the following one:</p>
<div class="cdpaligncenter"><img class="aligncenter11" src="../images/00070.jpeg"/></div>
<p class="calibre4">In this case, we select our sample app and click on the <span>Connect</span> button. Then, you will be asked to establish an insecure connection with the application, with a dialog similar to the following one:</p>
<div class="cdpaligncenter"><img class="aligncenter12" src="../images/00071.jpeg"/></div>
<p class="calibre4">Click on the <span>Insecure connection</span> button. JConsole will show you information about your application using six tabs:</p>
<ul class="calibre17">
<li class="calibre18">The <span>Overview</span> tab provides an overview of memory use, the number of threads running in the application, the number of objects created, and CPU usage of the application.</li>
<li class="calibre18">The <span>Memory</span> tab shows the amount of memory used by the application. It has a combo where you can select the type of memory you want to monitor (heap, non-heap, or pools).</li>
<li class="calibre18">The <span>Threads</span> tab shows you information about the number of threads in the application and detailed information about each thread.</li>
<li class="calibre18">The <span>Classes</span> tab shows you information about the number of objects loaded in the application.</li>
<li class="calibre18">The <span>VW Summary</span> tab provides a summary of the JVM running the application.</li>
<li class="calibre18">The <span>MBeans</span> tab shows you information about the managed beans of the application.</li>
</ul>
<p class="calibre4">The threads tab is similar to the following one:</p>
<div class="cdpaligncenter"><img class="aligncenter13" src="../images/00072.jpeg"/><br class="title-page-name"/></div>
<p class="calibre4">It has two different parts. In the upper part, you have real-time information about the <strong class="calibre1">Peak</strong> number of threads (with a red line) and the number of <strong class="calibre1">Live Threads</strong> (with a blue line). In the lower part, we have a list of active threads. When you select one of these threads, you will see detailed information about that thread, including its status and the actual stack trace.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">You can use other applications to monitor applications that run Java. For example, you can use VisualVM included with the JDK. You can obtain necessary information about visualvm at <a href="https://visualvm.github.io" class="calibre9">https://visualvm.github.io</a>.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Testing concurrency code with MultithreadedTC</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>