<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous Improvements in JDK 10</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, new versions of Java were released every three years (on average). The release timeline changed with Java 9, with the adoption of a six-month release cadence. Java 10 was released just six months after the release of Java 9. We already covered the major features of Java 10 in the first three chapters; <a href="0ffcea11-5fd2-4b3a-a791-b5917061c1c7.xhtml" target="_blank">Chapter 1</a>, <em>Type Inference</em>, <a href="210b06d5-c434-43dd-90a7-23c1d83d69bf.xhtml" target="_blank">Chapter 2</a>, <em>AppCDS</em>, and <a href="5dad8c1c-c2c4-4f32-8e5e-e39ce138d989.xhtml" target="_blank">Chapter 3</a>, <em>Garbage Collector Optimizations</em>.</p>
<p>In this chapter, we'll cover the remaining additions or updates to Java 10, most of which are related to changes in the JDK or its implementation. We'll also cover a few additions and modifications to the Java API.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Thread-local handshakes</li>
<li>Time-based release versioning</li>
<li>Consolidating the JDK forest into a single repository</li>
<li>Heap allocation on alternative memory devices</li>
<li>Additional Unicode language-tag extensions</li>
<li>Root certificates</li>
<li>The experimental Java-based JIT compiler</li>
<li>Removal of the Native-Header Generation Tool</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter will include an overview of the JDK 10 features that are related to the JDK or their implementation. This chapter will not include any code for you to work with.</p>
<p class="mce-root"/>
<p>Since this chapter covers multiple features in Java 10, let's quickly map the features with its <strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>) number and scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping JDK 10 features with scopes and JEPs</h1>
                </header>
            
            <article>
                
<p>The following table lists the JDK 10 features that will be covered in this chapter, the features' corresponding JEP numbers, and their scopes:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td>
<p><strong>JEP No.</strong></p>
</td>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>296</p>
</td>
<td>
<p>Implementation</p>
</td>
<td>
<p>Consolidate the JDK forest into a single repository</p>
</td>
</tr>
<tr>
<td>
<p>312</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Thread-local handshakes</p>
</td>
</tr>
<tr>
<td>
<p>313</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Removal of the Native-Header Generation Tool (<kbd>javah</kbd>)</p>
</td>
</tr>
<tr>
<td>
<p>314</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Additional Unicode language-tag extensions</p>
</td>
</tr>
<tr>
<td>
<p>316</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Heap allocation on alternative memory devices</p>
</td>
</tr>
<tr>
<td>
<p>317</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Experimental Java-based JIT compiler</p>
</td>
</tr>
<tr>
<td>
<p>319</p>
</td>
<td>
<p>JDK</p>
</td>
<td>
<p>Root certificates</p>
</td>
</tr>
<tr>
<td>
<p>322</p>
</td>
<td>
<p>SE</p>
</td>
<td>
<p>Time-based release versioning</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's get started with the first feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consolidating the JDK forest into a single repository</h1>
                </header>
            
            <article>
                
<p>Up to Java 9, JDK's code base used multiple repositories (there are eight repositories in Java 9—<kbd>root</kbd>, <kbd>corba</kbd>, <kbd>hotspot</kbd>, <kbd>jaxp</kbd>, <kbd>jaxws</kbd>, <kbd>jdk</kbd>, <kbd>langtools</kbd>, and <kbd>nashorn</kbd>). Consolidating the JDK forest aims to combine the multiple repositories used by the JDK into a single repository.</p>
<p>As JDK's code base grew over the years, it was stored in separate repositories on purpose, for a separation of concerns. However, as the JDK evolved, the code base also developed interdependencies <span>across different repositories</span>.</p>
<p>The advantages offered by these multiple repositories have outgrown the disadvantages with their maintenance. For interdependent changesets, you can't perform a single commit to a repository. There have been cases where the code for even a single (and simple) bug fix spanned multiple repositories. In such cases, the commit can't be performed atomically. A common approach is to use the same bug ID across multiple repositories. But this is not mandated, since using the same bug ID is not mandated, commits for same bug across different repositories could be made using different bug IDs. This can lead to difficulty in tracking bug fixes.</p>
<p>Also, the individual repositories don't have independent development tracks and release cycles. Java has one main release cycle, which includes changes in all of these repositories. Therefore, it was high time to integrate the JDK code base into one repository, to ease its maintenance.</p>
<div class="packt_infobox">This is a housekeeping feature that won't affect how you write your code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thread-local handshakes</h1>
                </header>
            
            <article>
                
<p>Suppose that you need to pause a particular thread, executing a callback on it. Prior to thread-local handshakes, there wasn't any way to do that. The norm was to perform a global VM safepoint, which pauses all of the executing threads (and what a waste that is, if you meant to pause only one thread). With thread-local handshakes, it is possible to stop individual threads.</p>
<p>By aiming to reduce global VM safepoints, thread-local handshakes will reduce JVM latency and improve its efficiency.</p>
<div class="packt_infobox">Thread-local handshakes are a JVM implementation feature that can't be used directly by developers.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removal of the Native-Header Generation Tool (javah)</h1>
                </header>
            
            <article>
                
<p>This version of JEP has removed the <kbd>javah</kbd> tool from the tools shipped with the JDK.</p>
<p>Suppose that you need instances of your class to be referenced by native code in C. Developers have used the <kbd>javah</kbd> tool to generate the C header and source files from a Java class. The generated code is used to enable native code (say, written in C) to access the instances of your Java class. The <kbd>javah</kbd> tool creates a <kbd>.h</kbd> file, which defines <kbd>struct</kbd>, similar to the structure of your class. For multiple classes in a source file, the <kbd>javah</kbd> tool generates separate <kbd>.h</kbd> files.</p>
<p>The removal of <kbd>javah</kbd> doesn't imply any decline in the usage of your Java classes by the native code.</p>
<p>With Java 8, <kbd>javah</kbd> was enhanced to take on the responsibility of generating the C header and source code files. After testing over two versions, <kbd>javah</kbd> is being removed from Java SE 10.</p>
<div class="packt_infobox">The removal of the <kbd>javah</kbd> tool is compensated by the advanced compilation options in <kbd>javac</kbd>, which can be used to generate the C header and source files.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional Unicode language-tag extensions</h1>
                </header>
            
            <article>
                
<p>This feature enhances <kbd>java.util.Locale</kbd> and its related API to implement an additional Unicode extension of the BCP 47 language tag. Support for the BCP 47 language was added to JDK 7. However, in JDK 7, support for the Unicode locale extension was limited to calendar and numbers. This feature allowed for the addition of an extension to a locale. JDK 9 added support for <kbd>ca</kbd> and <kbd>nu</kbd> tags, from BCP 47.</p>
<p>JDK 10 added support for the following extensions:</p>
<ul>
<li><kbd>cu</kbd> (currency type)</li>
<li><kbd>fw</kbd> (first day of the week)</li>
<li><kbd>rg</kbd> (region over)</li>
</ul>
<div class="packt_infobox">When you specify a locale extension, such as a number or currency type, it is not guaranteed that the underlying platform supports the requested extension. Unicode tag extensions are a language feature, and they can be used directly by the developers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heap allocation on alternative memory devices</h1>
                </header>
            
            <article>
                
<p>When JVM exhausts its heap memory, your application crashes with <kbd>OutOfMemoryException</kbd>. Imagine if you could configure your JVM to use an alternate memory device, like a <strong>non-volatile dual in-line memory module</strong> (<strong>NV-DIMM</strong>). </p>
<p>With the ever-increasing memory demands of applications that deal with large amounts of data, and with the availability of low-cost NV-DIMM memory, the ability to use alternate memory devices for heap allocations is bliss. It also leads to systems that work with heterogeneous memory architectures.</p>
<p>This enhancement targets alternative memory devices that have the same semantics as <strong>Dynamic Random Access Memory</strong> (<strong>DRAM</strong>), so that they can be used instead of DRAM, without requiring any changes to the existing application code. All of the other memory structures, such as the stack, code heap, and so on, will continue to use DRAM.</p>
<p>A quick detail before we move forward—NV-DIMM has higher access latency compared to DRAM. But NV-DIMM has a larger capacity at a lower cost compared to DRAM. So, the low-priority processes can use NV-DIMM, whereas the high-priority processes can use DRAM memory.</p>
<div class="packt_infobox">Heap allocation is a JVM implementation detail that can't be used directly by developers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The experimental Java-based JIT compiler</h1>
                </header>
            
            <article>
                
<p>The Java compilers that you worked with until now were usually written in C/C++. What would you think about a Java compiler written in Java?</p>
<p>Graal, a Java-based <strong>just in-time</strong> (<strong>JIT</strong>) compiler, was introduced in Java 9. Java 10 enables the use of Graal as an experimental JIT compiler on Linux/x64 platforms. Eventually, Oracle will explore the possibility of using Graal as a Java-based JIT for the JDK.</p>
<p class="mce-root"/>
<p>Graal uses the JVM compiler interface, introduced in JDK 9. The objective of Graal is not to compete with the existing JIT compilers. It is a part of the project Metropolis, which explores and incubates Java-on-Java implementation techniques for HotSpot, the open JDK implementation of the JVM.</p>
<p>Since Graal is written in Java, fears of using Graal are related to lower startup performance of applications and increased heap usage.</p>
<p>The following command-line compiler option can be used to enable Graal as your JIT compiler:</p>
<pre><strong>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</strong></pre>
<div class="packt_infobox">Graal is an experimental JIT compiler that can be configured for use with command-line options.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Root certificates</h1>
                </header>
            
            <article>
                
<p>Imagine configuring an account on a cloud storage service provider, using your system. The cloud interface can request a certificate and their values to be stored on your system. When reconnecting to the cloud service, your system automatically authenticates it using the certificate.</p>
<p>With JDK, such certificates are stored in the <kbd>cacerts</kbd> keystore. The certificate file <kbd>cacerts</kbd> resides in the security directory of your JDK installation directory and represents <strong>Certification Authority</strong> (<strong>CA</strong>) certifications applicable to the system-wide key store, as follows:</p>
<ul>
<li>Windows: <kbd>JAVA_HOME\lib\security</kbd></li>
<li>Linux, Solaris, and macOS X: <kbd>JAVA_HOME/lib/security</kbd></li>
</ul>
<p>The root certificates are used to establish trust in the certificate chains employed in the various security protocols. The problem is that the <kbd>cacerts</kbd> keystore doesn't have any certificates in the JDK source code, which is mandatory for the default functionality of security components, such as TLS, in OpenJDK builds.</p>
<p>With root certificates, Oracle plans to bridge the gap between the OpenJDK build and OracleJDK builds. The users must populate their <kbd>cacerts</kbd> keystore with a set of root certificates to bridge this gap.</p>
<p class="mce-root"/>
<p>The plan is to provide a default set of root<strong> </strong>CA certificates in JDK, and open source the root certificates in Oracle's Java SE Root CA program.</p>
<p>The root certificates can be issued by the CAs of Oracle's Java SE Root CA program.</p>
<div class="packt_infobox">Root certificates are a JDK feature.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time-based release versioning</h1>
                </header>
            
            <article>
                
<p>The feature of time-based release versioning revises the version-string scheme of JDK SE platform, for current and future time-based release versions.</p>
<p>The proposed format is as follows:</p>
<pre>$FEATURE.$INTERIM.$UPDATE.$PATCH</pre>
<p>The following are the details of the elements used in the preceding string:</p>
<ul>
<li><kbd>$FEATURE</kbd>: With the new (and strict) six-month release cadence, this value is incremented every six months. The JDK version released on Mar 2018 was 10, the version released in Sep 2018 was JDK 11. JDK 12 released in Mar 2019, and so on.</li>
<li><kbd>$INTERIM</kbd>: With the six-month release cadence, there aren't any interim releases. However, this element is retained for potential future use cases.</li>
<li><kbd>$UPDATE</kbd>: This element represents an update, incremented for compatible update releases that fix security issues, regressions, and bugs in newer features. This is incremented a month after the increment in <kbd>$FEATURE</kbd>, and every three months thereafter.</li>
<li><kbd>$PATCH</kbd>: This element represents the emergency patch-release counter, for emergency releases for a critical bug.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you skimmed through the various additions and modifications to JDK 10, barring its main features of type inference, application class data sharing, and garbage collector optimization.</p>
<p>Most of the features covered in this chapter were related to the changes in JDK, including reducing global VM safepoints with thread-local handshakes, the removal of <kbd>javah</kbd>, using alternative memory devices for heap allocation, Graal, and root certificates. It includes fewer SE features—additional Unicode language-tag extensions and time-based release versioning. The consolidation of the JDK forest into a single repository is more of a housekeeping detail.</p>
<p>In the next chapter, we'll look at the new additions and modifications to JDK 11. I'm excited and hope you are, too!</p>


            </article>

            
        </section>
    </body></html>