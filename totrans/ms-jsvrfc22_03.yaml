- en: Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. JSF作用域 – 在管理Bean通信中的生命周期和使用
- en: If programming is an art, then working correctly with scopes is a part of it!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程是一种艺术，那么正确地使用作用域就是其中的一部分！
- en: This affirmation is generally true, not just in JSF. Should I use the session
    scope now, or the request scope? Do I have too many session beans? Can I inject
    this scope into that scope? Is this session object too big? How many times have
    you asked yourself these kinds of questions? I know ... many times! Maybe in this
    chapter you will find answers to some of these questions and you will fortify
    your knowledge about working with JSF scopes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言通常是正确的，不仅适用于JSF。我现在应该使用会话作用域，还是请求作用域？我是否有太多的会话Bean？我能将这个作用域注入到那个作用域中吗？这个会话对象是否太大？你问过自己这类问题有多少次了？我知道……很多次！也许在这一章中，你将找到一些问题的答案，并加强你对使用JSF作用域的知识。
- en: 'We have a lot to accomplish; therefore, let''s have a short overview of what
    you will see in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多事情要做；因此，让我们简要概述一下你将在本章中看到的内容：
- en: JSF scopes versus CDI scopes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF作用域与CDI作用域
- en: Request scope, session scope, view scope, application scope, conversation scope,
    flow scope, none scope, dependent scope, and custom scope
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求作用域、会话作用域、视图作用域、应用作用域、会话作用域、流程作用域、无作用域、依赖作用域和自定义作用域
- en: Beans injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean注入
- en: JSF scopes versus CDI scopes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF作用域与CDI作用域
- en: 'Even a JSF beginner might have heard about JSF managed beans (regular JavaBeans
    classes managed by JSF) and CDI beans (regular JavaBeans classes managed by CDI),
    and knows that JSF supports JSF scopes and CDI scopes. Starting with Java EE 6,
    CDI is recognized as the managed bean framework, besides EJBs. This causes confusion
    among programmers, because EJBs, CDIs, and JSF managed beans raise a critical
    question: which one to use and when?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是JSF初学者也可能听说过JSF管理Bean（由JSF管理的常规JavaBean类）和CDI Bean（由CDI管理的常规JavaBean类），并且知道JSF支持JSF作用域和CDI作用域。从Java
    EE 6开始，CDI被认可为管理Bean框架，除了EJBs之外。这导致程序员之间产生混淆，因为EJBs、CDIs和JSF管理Bean提出了一个关键问题：何时使用哪一个？
- en: Focusing on JSF, the unanimous answer is that CDI beans are more powerful than
    JSF beans. But, when you know right from the start that CDI will not be a part
    of your application or you are running the application inside a servlet container
    (which does not have CDI support by default, like Apache Tomcat), then JSF beans
    is the right choice. In other words, when you need a simple way to define beans
    and a neat mechanism for a dependency injection, then JSF bean will do the job,
    but when you need heavy artillery, such as events, type safe injection, automatic
    injection, producer methods, and interceptors, then CDI will represent the complete
    solution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于JSF，普遍的答案是CDI Bean比JSF Bean更强大。但是，当你从一开始就知道CDI不会成为你应用程序的一部分，或者你在一个没有默认CDI支持的服务器容器（如Apache
    Tomcat）中运行应用程序时，那么JSF Bean就是正确的选择。换句话说，当你需要一个简单的方式来定义Bean和一个整洁的依赖注入机制时，JSF Bean可以完成这项工作，但是当你需要重型武器，如事件、类型安全注入、自动注入、生产者方法和拦截器时，CDI将代表完整的解决方案。
- en: 'Moreover, NetBeans IDE 8.0 warns us that the JSF bean''s annotations will be
    deprecated in the next JSF version, while the CDI beans are recommended instead
    (as shown in the following screenshot). This warning and the new JSF 2.2 flow
    scope, introduced as a dependency on CDI, are powerful signals that JSF and CDI
    become closer and closer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NetBeans IDE 8.0警告我们，在下一个JSF版本中，JSF Bean的注解将被弃用，而CDI Bean被推荐使用（如以下截图所示）。这个警告和作为CDI依赖项引入的新JSF
    2.2流程作用域，是JSF和CDI越来越接近的强大信号：
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![JSF作用域与CDI作用域](img/6466EN_03_01.jpg)'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CDI beans are much powerful than JSF beans; therefore, use CDI beans whenever
    possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CDI Bean比JSF Bean更强大；因此，尽可能使用CDI Bean。
- en: So, strong arguments indicate CDI is often the right choice, but there are still
    instances where it is effective to use JSF beans, as you will soon discover.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，强有力的论据表明CDI通常是正确的选择，但仍然有一些情况下使用JSF Bean是有效的，正如你很快就会发现的。
- en: JSF bean's main annotations (such as `@ManagedBean` and scopes annotations)
    are defined in the package `javax.faces.bean`, while CDI's main annotations are
    defined in the `javax.inject` (such as, `@Named`) and `javax.enterprise.context`
    (such as, scopes) packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSF Bean的主要注解（如`@ManagedBean`和作用域注解）定义在`javax.faces.bean`包中，而CDI的主要注解定义在`javax.inject`（如`@Named`）和`javax.enterprise.context`（如作用域）包中。
- en: A JSF managed bean is annotated with `@ManagedBean`, which allows us to inject
    it in to another bean (not CDI beans!) and to access the bean properties and methods
    from JSF pages using EL expressions. A CDI bean is annotated with `@Named`, which
    provides an EL name to be used in view technologies, such as JSP or Facelets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JSF管理bean使用`@ManagedBean`注解，这允许我们将它注入到另一个bean（不是CDI bean！）中，并使用EL表达式从JSF页面访问bean属性和方法。CDI
    bean使用`@Named`注解，这为视图技术（如JSP或Facelets）提供了一个EL名称。
- en: 'Typically, a JSF bean is declared as shown in the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JSF bean的声明如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The JSF bean, `@ManagedBean`, supports an optional parameter, `name`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSF bean的`@ManagedBean`支持一个可选参数`name`。提供的名称可以用于以下方式从JSF页面引用bean：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A CDI bean has the same shape, with different annotations, as shown in the
    following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean具有相同的形状，但具有不同的注解，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The CDI bean, `@Named`, supports an optional parameter, `value`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的`@Named`注解支持一个可选参数`value`。提供的名称可以用于以下方式从JSF页面引用bean：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that CDI annotations cannot be mixed with JSF annotations in the same
    bean, only in the same application. For example, you cannot define a bean using
    `@ManagedBean` and a CDI scope (or any other combination between them), but you
    can have, in the same application, a managed bean (or more) and a CDI bean (or
    more).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CDI注解不能与JSF注解在同一个bean中混合，只能在同一个应用程序中。例如，您不能使用`@ManagedBean`和CDI作用域（或它们之间的任何其他组合）来定义一个bean，但您可以在同一个应用程序中有一个管理bean（或更多）和一个CDI
    bean（或更多）。
- en: 'In the following figure, you can see a short overview of JSF 2.2 scopes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您可以看到JSF 2.2作用域的简要概述：
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![JSF作用域与CDI作用域](img/6466EN_03_02.jpg)'
- en: In the next section, you will see how each JSF/CDI scope works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到每个JSF/CDI作用域是如何工作的。
- en: The request scope
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求作用域
- en: The **request scope** is bound to the HTTP request-response life cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求作用域**绑定到HTTP请求-响应生命周期。'
- en: The request scope is very useful in any web application, and an object defined
    in the request scope usually has a short lifespan; beans live as long as the HTTP
    request-response lives. When the container accepts an HTTP request from the client,
    the specified object is attached to the request scope and it is released when
    the container has finished transmitting the response to that request. A new HTTP
    request always comes in a new request scope object. In short, a request scope
    represents a user's interaction with a web application in a single HTTP request.
    Commonly, a request scope is useful for simple GET requests that expose some data
    to the user without requiring to store the data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在任何Web应用程序中都非常有用，定义在请求作用域中的对象通常具有较短的生存期；bean的生存期与HTTP请求-响应相同。当容器从客户端接受HTTP请求时，指定的对象附加到请求作用域，并在容器完成向该请求发送响应后释放。每个新的HTTP请求都会带来一个新的请求作用域对象。简而言之，请求作用域代表用户在单个HTTP请求中与Web应用程序的交互。通常，请求作用域对于简单的GET请求很有用，这些请求向用户公开一些数据，而无需存储数据。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope is present in JSF and CDI and functions in the same way. It
    can be used for nonrich AJAX and non-AJAX requests. For JSF managed beans (`@ManagedBean`),
    this is the default scope, when none is specified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域存在于JSF和CDI中，并且以相同的方式工作。它可以用于非富AJAX和非AJAX请求。对于JSF管理bean（`@ManagedBean`），这是默认的作用域，如果没有指定。
- en: For example, let's suppose that we have a predefined list of tennis players,
    and we randomly extract them one-by-one from this list and store them in another
    list. The current generated player and the list of extracted players are managed
    bean's properties and their values are rendered in a JSF page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个预定义的网球运动员列表，并且我们从这个列表中随机提取他们，并将他们存储在另一个列表中。当前生成的球员和提取的球员列表是管理bean的属性，它们的值在JSF页面中显示。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope annotation is `@RequestScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域注解是`@RequestScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'The code for the CDI bean can be written as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的代码可以写成如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The relevant part of the JSF page is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JSF页面的相关部分如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you click on the button labeled **Get Players With Page Forward** or **Get
    Players In Same View**, you will see something as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击标记为**使用页面前进获取玩家**或**获取同一视图中的玩家**的按钮时，您将看到以下截图所示的内容：
- en: '![The request scope](img/6466EN_03_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![请求作用域](img/6466EN_03_03.jpg)'
- en: Since a request scope lives as long as the HTTP request-response lives and page
    forward implies a single HTTP request-response, you will see the player extracted
    at the current request and the list of extracted players, which will always only
    contain this player. The list is created for each request and filled with the
    current player, which makes the list useless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求作用域的生命周期与HTTP请求-响应的生命周期相同，而页面前进意味着一个单独的HTTP请求-响应，因此您将看到在当前请求中提取的播放器和提取的播放器列表，该列表将始终只包含此播放器。列表为每个请求创建，并用当前播放器填充，这使得列表变得无用。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope doesn't lose the object's state while forwarding, because
    the source page and the destination page (the forwarded page) are part of the
    same request-response cycle. This is not true in the case of redirect actions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在转发时不会丢失对象的状态，因为源页面和目标页面（转发页面）是同一请求-响应周期的一部分。这并不适用于重定向操作。
- en: 'When you click on the button labeled **Get Players With Page Redirect**, you
    will see something as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击标记为**使用页面重定向获取玩家**的按钮时，您将看到以下截图所示的内容：
- en: '![The request scope](img/6466EN_03_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![请求作用域](img/6466EN_03_04.jpg)'
- en: The current extracted player and the list content is not available in this case,
    because a JSF redirect implies two requests, instead of one as in the forward
    case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当前提取的玩家和列表内容不可用，因为JSF重定向意味着两个请求，而不是像前进情况那样只有一个。
- en: 'Programmatically, you can access the request map using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码以编程方式访问请求映射：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Submitting a form defined in page 1 to page 2 via a bean, and then you have
    the following cases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将页面1中定义的表单通过豆提交到页面2，然后您有以下情况：
- en: If the same view or forward is used, then the data is available for display
    on page 2
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用相同的视图或前进，则数据将在页面2上可用以显示
- en: If redirect is used, then data will be lost and not available for display on
    page 2
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用重定向，则数据将丢失，无法在页面2上显示
- en: 'The JSF version of the CDI beans is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CDI豆的JSF版本如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And it works the same as the CDI bean!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它与CDI豆的功能相同！
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called for each request, since
    each request requires a separate instance of the request scoped bean.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将为每个请求调用，因为每个请求都需要请求作用域的独立实例。
- en: The case of the CDI bean is wrapped into the application named `ch3_1_1`, while
    the case of the JSF bean is wrapped into application named `ch3_1_2`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CDI豆的情况被封装在名为`ch3_1_1`的应用程序中，而JSF豆的情况被封装在名为`ch3_1_2`的应用程序中。
- en: The session scope
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话作用域
- en: The **session scope** lives across multiple HTTP request-response cycles (theoretical
    unlimited).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话作用域**跨越多个HTTP请求-响应周期（理论上无限）。'
- en: The request scope is very useful in any web application when you need a single
    interaction per HTTP request-response cycle. However, when you need objects visible
    for any HTTP request-response cycle that belongs to a user session, then you need
    a session scope; in this case, the bean lives as long as the HTTP session lives.
    The session scope allows you to create and bind objects to a session. It gets
    created upon the first HTTP request involving this bean in the session and gets
    destroyed when the HTTP session is invalidated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在任何需要每个HTTP请求-响应周期中只有一个交互的Web应用程序中非常有用。然而，当您需要用户会话中属于任何HTTP请求-响应周期的可见对象时，则需要会话作用域；在这种情况下，该豆的生命周期与HTTP会话的生命周期相同。会话作用域允许您创建并将对象绑定到会话。它会在会话中涉及此豆的第一个HTTP请求时创建，并在HTTP会话无效时销毁。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session scope is present in JSF and CDI and it functions the same way in
    both. Commonly, it is used for AJAX and non-AJAX requests that process user-specific
    data (such as credentials, shopping carts, and so on).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域存在于JSF和CDI中，并且在两者中功能相同。通常，它用于处理用户特定数据（如凭证、购物车等）的AJAX和非AJAX请求。
- en: Therefore, the first HTTP request initializes the session and stores the objects,
    while the subsequent requests have access to these objects for further tasks.
    A session invalidation occurs when the browser is closed, a timeout is fired,
    the logout is clicked, or a programmatic subroutine forces it. Normally, each
    time you need to preserve data across the whole session (multiple requests and
    pages), the session scope is the right choice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个HTTP请求初始化会话并存储对象，而后续请求可以访问这些对象以执行进一步的任务。当浏览器关闭、超时触发、点击注销或程序性子例程强制执行时发生会话失效。通常，每次需要在整个会话（多个请求和页面）中保留数据时，会话作用域是正确的选择。
- en: For example, you can add the session scope to the previous applications of this
    chapter for storing the list of randomly extracted players across multiple requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将会话作用域添加到本章之前的应用程序中，以存储跨多个请求随机提取的玩家列表。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session scope annotation is `@SessionScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域注解是`@SessionScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'The CDI bean is modified as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean修改如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, the JSF version is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，JSF版本如下：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the session scope bean might get passivated by the container and
    should be capable of passivity, which means that the session beans should be serializable
    (implement the `java.io.Serializable` interface); refer to the capability to persist/restore
    session data to/from the hard disk.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到会话作用域bean可能会被容器钝化，并且应该能够通过实现`java.io.Serializable`接口来钝化；参考将会话数据从硬盘上持久化/恢复的能力。
- en: 'The session objects lives across forward and redirect mechanisms. In the following
    screenshot, you can see the current extracted player and the list of extracted
    players after several requests belonging to the same session:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象在转发和重定向机制中保持有效。在下面的屏幕截图中，你可以看到当前提取的玩家和属于同一会话的几个请求后的提取玩家列表：
- en: '![The session scope](img/6466EN_03_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![会话作用域](img/6466EN_03_05.jpg)'
- en: Now the list is not useless anymore! You can add methods for manipulating its
    content, such as order or delete.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表不再是无用的了！你可以添加操作其内容的方法，例如排序或删除。
- en: 'Programmatically, you can access the session map as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式编程访问会话映射：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, you can invalidate a session as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以按以下方式使会话无效：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, data submitted through forms across the session scope will be available
    in subsequent requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过会话作用域提交的数据将在后续请求中可用。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only once during a session,
    when the session bean is instantiated. Subsequent requests will use this instance,
    so it can be a good place to add initialization stuff.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将在会话期间仅调用一次，当会话bean实例化时。后续请求将使用此实例，因此它是一个添加初始化内容的好地方。
- en: The case of the CDI bean is wrapped into the application named `ch3_2_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_2_2`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的情况被封装在名为`ch3_2_1`的应用中，而JSF bean的情况被封装在名为`ch3_2_2`的应用中。
- en: The view scope
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图作用域
- en: The **view scope** lives as long as you are navigating in the same JSF view
    in the browser window/tab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图作用域**在你在浏览器窗口/标签中导航同一JSF视图时保持有效。'
- en: The view scope is useful when you need to preserve data over multiple requests
    without leaving the current JSF view by clicking on a link, returning a different
    action outcome, or any other interaction that dumps the current view. It gets
    created upon an HTTP request and gets destroyed when you postback to a different
    view; as long as you postback to the same view, the view scope is alive.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在不点击链接、返回不同的操作结果或任何其他导致当前视图被丢弃的交互中保留数据时，视图作用域非常有用。它在HTTP请求时创建，在你回发到不同的视图时销毁；只要回发到相同的视图，视图作用域就保持活跃。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the view scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到视图作用域bean可能会被容器钝化，并且应该通过实现`java.io.Serializable`接口来钝化。
- en: Since the view scope is particularly useful when you are editing some objects
    while staying in the same view, it can be the perfect choice for rich AJAX requests.
    Moreover, since the view scope is bounded to the current view, it does not reflect
    the stored information in another window or tab of a browser; this is an issue
    specific to the session scope!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图作用域在您在相同视图中编辑某些对象时特别有用，因此它对于丰富的 AJAX 请求来说是一个完美的选择。此外，由于视图作用域绑定到当前视图，它不会反映浏览器中另一个窗口或标签页中存储的信息；这是一个特定于会话作用域的问题！
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to keep the view active, the bean methods (actions/listeners) must
    return `null` or `void`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持视图活跃，bean 方法（动作/监听器）必须返回 `null` 或 `void`。
- en: The view scope is not available in CDI, but JSF 2.2 has introduced it through
    the new annotation, `@ViewScoped`. This is defined in the `javax.faces.view.ViewScoped`
    package and it is compatible with CDI. Do not confuse this `@ViewScoped` with
    the one defined in the `javax.faces.bean` package, which is JSF compatible!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CDI 中不可用视图作用域，但 JSF 2.2 通过新的注解 `@ViewScoped` 引入了它。这定义在 `javax.faces.view.ViewScoped`
    包中，并且它与 CDI 兼容。不要将此 `@ViewScoped` 与定义在 `javax.faces.bean` 包中的那个混淆，后者是 JSF 兼容的！
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The view scope annotation is `@ViewScoped` and is defined in the `javax.faces.view`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 视图作用域注解是 `@ViewScoped`，它定义在 `javax.faces.view` 包中用于 CDI，以及定义在 `javax.faces.bean`
    包中用于 JSF。
- en: 'You can see the view scope in action by modifying the `PlayersBean` scope as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过修改 `PlayersBean` 的作用域来查看视图作用域的实际效果，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Firing multiple HTTP requests by clicking on the button labeled **Get Players
    In Same View** will reveal something like the following screenshot. Notice the
    action method (`newPlayer`) returns void and the button doesn't contain the `action`
    attribute, which means that you are in the same JSF view during the execution
    of these requests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击标记为 **Get Players In Same View** 的按钮来触发多个 HTTP 请求将揭示如下截图所示的内容。注意，动作方法 (`newPlayer`)
    返回 void，并且按钮不包含 `action` 属性，这意味着在执行这些请求期间，您处于相同的 JSF 视图中。
- en: '![The view scope](img/6466EN_03_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![视图作用域](img/6466EN_03_06.jpg)'
- en: The other two buttons contain the `action` attribute and indicate an explicit
    navigation, which means that the current view is changed at every request and
    the data is lost.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个按钮包含 `action` 属性，并指示显式导航，这意味着在每次请求时都会更改当前视图，并且数据会丢失。
- en: 'You can easily adapt `PlayersBean` (and any other bean) to use the JSF version
    of `@ViewScoped` as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地将 `PlayersBean`（以及任何其他bean）适配以使用 `@ViewScoped` 的 JSF 版本，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data submitted through forms across the view scope will be available in subsequent
    requests as long as you are in the same view.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视图作用域提交的表单数据，只要您处于同一视图，就会在后续请求中可用。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only when the view scoped
    bean is instantiated. Subsequent requests, from this view, will use this instance.
    As long as you are in the same view, this method will not be called again; therefore,
    it can be a good place to add initialization stuff specific to the current view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `@PostConstruct` 注解的方法仅在视图作用域的 bean 实例化时被调用。后续从这个视图发出的请求将使用此实例。只要您处于同一视图，此方法就不会再次被调用；因此，它是一个添加特定于当前视图的初始化内容的良好位置。
- en: The case of the CDI bean is wrapped into the application named `ch3_6_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_6_2`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean 的案例被封装在名为 `ch3_6_1` 的应用程序中，而 JSF bean 的案例被封装在名为 `ch3_6_2` 的应用程序中。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use the `UIViewRoot.restoreViewScopeState(FacesContext
    context, Object state)` method for restoring the view scope when it is not available.
    This will be exemplified in [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 版本开始，我们可以使用 `UIViewRoot.restoreViewScopeState(FacesContext context,
    Object state)` 方法来恢复不可用的视图作用域。这将在[第 12 章](ch12.html "第 12 章. Facelets 模板") *Facelets
    模板*中举例说明。
- en: The application scope
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序作用域
- en: The **application scope** lives as long as the web application lives.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序作用域**与 Web 应用程序的生命周期一样长。'
- en: An application scope extends the session scope with the shared state across
    all users' interactions with a web application; this scope lives as long as the
    web application lives. Since the beans in the application scope lives until the
    application shuts down (or they are programmatically removed), we can say that
    this scope lives most. More precisely, objects settled on the application scope
    can be accessed from any page that is part of the application (for example, JSF,
    JSP, and XHTML).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用范围通过所有用户与Web应用程序交互的共享状态扩展了会话范围；此范围与Web应用程序的生命周期相同。由于应用范围的bean在应用程序关闭（或它们被编程删除）之前一直存在，因此我们可以说这个范围存在时间最长。更精确地说，位于应用范围的对象可以从应用程序的任何页面访问（例如，JSF、JSP和XHTML）。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application scope should be used only for data that is safe to be shared.
    Since an application scoped bean is shared by all users, you need to be sure that
    the bean has an immutable state or you need to synchronize access.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应仅将应用范围用于可以安全共享的数据。由于应用范围的bean被所有用户共享，您需要确保该bean具有不可变状态，或者您需要同步访问。
- en: Usually, application scope objects are used as counters, but they can be used
    for many other tasks, such as initializations and navigations. For example, the
    application scope can be used to count how many users are online or to share that
    information with all users. Practically, it can be used to share data among all
    sessions, such as constants, common settings, and tracking variables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用范围对象用作计数器，但它们可以用于许多其他任务，例如初始化和导航。例如，应用范围可以用来统计在线用户数量，或者将此信息与所有用户共享。实际上，它可以用于在所有会话之间共享数据，例如常量、通用设置和跟踪变量。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application scope annotation is `@ApplicationScoped` and is defined in the
    `javax.enterprise.context` package for CDI, and in the `javax.faces.bean` package
    for JSF.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用范围注解是`@ApplicationScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'If you put the `PlayersBean` managed bean in the application scope, then the
    list of randomly extracted players will be available across all sessions. You
    can do it as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`PlayersBean`托管bean放入应用范围，那么随机抽取的玩家列表将在所有会话中可用。您可以通过以下代码实现：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JSF version is shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JSF版本在以下代码中显示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For testing the application scope, you need to open multiple browsers or use
    multiple machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用范围，您需要打开多个浏览器或使用多台机器。
- en: Be careful when you provide data from an application scoped bean to multiple
    sessions beans (for example, using injection), since the data shared by all sessions
    can be modified by each session separately. This can lead to inconsistent data
    across multiple users; therefore, be sure that the exposed application data isn't
    modified in sessions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在从应用范围的bean向多个会话bean（例如，使用注入）提供数据时，请务必小心，因为所有会话共享的数据可以由每个会话单独修改。这可能导致多个用户之间的数据不一致；因此，请确保暴露的应用数据在会话中不会被修改。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only when the application
    scoped bean is instantiated. Subsequent requests will use this instance. Usually,
    this happens when the application starts; therefore, place inside this method
    the initialization tasks specific to the application in the context of this bean.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的案例被包裹在名为`ch3_3_1`的应用中，而JSF bean的案例被包裹在名为`ch3_3_2`的应用中。
- en: 'Programmatically, you can access the application map using the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码以编程方式访问应用映射：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The case of the CDI bean is wrapped into the application named `ch3_3_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_3_2`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法仅在应用范围的bean实例化时调用。后续请求将使用此实例。通常，这发生在应用程序启动时；因此，请将此bean上下文中的应用特定初始化任务放在此方法内部。
- en: The conversation scope
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话范围
- en: The **conversation scope** allows developers to demarcate the lifespan of the
    session scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话范围**允许开发者界定会话范围的生命周期。'
- en: The conversation scope is committed to the user's interaction with JSF applications
    and represents a unit of work from the point of view of the user; a bean in this
    scope is able to follow a conversation with a user. We may charge the conversation
    scope as a developer-controlled session scope across multiple invocations of the
    JSF life cycle; while session scoped lives across unlimited requests, the conversation
    scopes lives only across a limited number of requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域致力于用户与 JSF 应用程序的交互，并代表用户视角上的工作单元；在这个作用域中的 Bean 能够跟踪与用户的对话。我们可以将对话作用域视为开发者控制的会话作用域，跨越
    JSF 生命周期的多次调用；而会话作用域跨越无限请求，对话作用域仅跨越有限数量的请求。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The conversation scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域 Bean 可能会被容器钝化，并且应该通过实现 `java.io.Serializable` 接口来具备钝化能力。
- en: The developer can explicitly set the conversation scope boundaries and can start,
    stop, or propagate the conversation scope based on the business logic flow. All
    long-running conversations are scoped to a particular HTTP servlet session and
    may not cross session boundaries. In addition, conversation scope keeps the state
    associated with a particular Web browser window/tab in a JSF application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以显式设置对话作用域的边界，并且可以根据业务逻辑流程启动、停止或传播对话作用域。所有长时间运行的对话都作用域于特定的 HTTP 服务器会话，并且可能不会跨越会话边界。此外，对话作用域在
    JSF 应用程序中保持与特定 Web 浏览器窗口/标签页相关的状态。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The conversation scope annotation is `@ConversationScoped` and is defined in
    the `javax.enterprise.context` package for CDI. This scope is not available in
    JSF!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域注解是 `@ConversationScoped`，它定义在 `javax.enterprise.context` 包中用于 CDI。这个作用域在
    JSF 中不可用！
- en: 'Dealing with the conversation scope is slightly different from the rest of
    the scopes. First, you mark the bean with `@ConversationScope`, represented by
    the `javax.enterprise.context.ConversationScoped` class. Second, CDI provides
    a built-in bean (`javax.enterprise.context.Conversation`) for controlling the
    life cycle of conversations in a JSF application—its main responsibility is to
    manage the conversation context. This bean may be obtained by injection, as shown
    in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理对话作用域与其他作用域略有不同。首先，您使用 `@ConversationScope` 标记 Bean，由 `javax.enterprise.context.ConversationScoped`
    类表示。其次，CDI 提供了一个内置的 Bean（`javax.enterprise.context.Conversation`），用于控制 JSF 应用程序中对话的生命周期——其主要职责是管理对话上下文。此
    Bean 可以通过注入获得，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By default, the `Conversation` object is in transient state and it should be
    transformed into a long-running conversation by calling the `begin` method. You
    also need to prepare for the destruction of the conversation by calling the `end`
    method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Conversation` 对象处于短暂状态，应该通过调用 `begin` 方法将其转换为长时间运行的对话。您还需要通过调用 `end`
    方法为对话的销毁做好准备。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we try to call the `begin` method when the conversation is active, or the
    `end` method when the conversation is inactive, `IllegalStateException` will be
    thrown. We can avoid this by testing the transitivity state of the `Conversation`
    objects using the method named `isTransient`, which returns a Boolean value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对话处于活动状态时尝试调用 `begin` 方法，或者在对话处于非活动状态时调用 `end` 方法，将会抛出 `IllegalStateException`。我们可以通过使用名为
    `isTransient` 的方法来避免这种情况，该方法返回一个布尔值，用于测试 `Conversation` 对象的传递性状态。
- en: 'Now, add the `begin`, `end`, and `isTransient` methods together to the following
    conversations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `begin`、`end` 和 `isTransient` 方法一起添加到以下对话中：
- en: 'For start conversation, the code is as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始对话，代码如下：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For stop conversation, the code is as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止对话，代码如下：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For example, you can add the conversation scope in `PlayersBean` as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在 `PlayersBean` 中添加对话作用域如下：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides injecting the built-in CDI bean, notice that you have defined a method
    (`startPlayerRnd`) for demarcating the conversation start point and another method
    (`stopPlayerRnd`) for demarcating the conversation stop point. In this example,
    both the methods are exposed to the user through two buttons, but you can control
    the conversation programmatically by calling them conditionally.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入内置的 CDI Bean，请注意您已经定义了一个方法（`startPlayerRnd`）用于标记对话的起始点，以及另一个方法（`stopPlayerRnd`）用于标记对话的结束点。在这个例子中，这两个方法都通过两个按钮暴露给用户，但您也可以通过有条件地调用它们来程序化地控制对话。
- en: 'Running the example inside a conversation will reveal something as shown in
    the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话中运行示例将揭示如下截图所示的内容：
- en: '![The conversation scope](img/6466EN_03_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![对话范围](img/6466EN_03_07.jpg)'
- en: The list of randomly extracted players will be empty or will contain only the
    current extracted player until the button labeled **Start Conversation** is clicked.
    At that moment the list will be stored in session, until the button labeled **Stop
    Conversation** is clicked.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随机抽取的玩家列表将保持为空或仅包含当前抽取的玩家，直到点击标记为**开始对话**的按钮。在此刻，列表将被存储在会话中，直到点击标记为**停止对话**的按钮。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During the conversation, the user may execute AJAX/non-AJAX requests against
    the bean or perform navigations to other pages that still reference this same
    managed bean. The bean will keep its state across user interactions using a **conversation
    identifier** generated by the container, and this is why the conversation scope
    can be the right choice when you need to implement wizards. But it might be a
    good idea to take into account the new JSF 2.2 flow scope as well, which solves
    several gaps of the conversation scope. See the upcoming section!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话过程中，用户可以对bean执行AJAX/非AJAX请求或导航到其他仍引用此相同管理bean的页面。bean将使用容器生成的**对话标识符**在用户交互中保持其状态，这就是为什么在需要实现向导时，对话范围可能是正确的选择。但是，考虑新的JSF
    2.2流程范围也是一个好主意，因为它解决了对话范围的几个缺陷。请参阅即将到来的部分！
- en: 'In this example, the conversation context automatically propagates with any
    JSF faces request or redirection (this facilitates the implementation of the common
    POST-then-redirect pattern), but it does not automatically propagate with non-faces
    requests, such as links. In this case, you need to include the unique identifier
    of the conversation as a request parameter. The CDI specification reserves the
    request parameter `cid` for this use. The following code will propagate the conversation
    context over a link:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，对话上下文会自动与任何JSF faces请求或重定向一起传播（这有助于实现常见的POST-then-redirect模式），但它不会自动与非faces请求（如链接）一起传播。在这种情况下，您需要将对话的唯一标识符作为请求参数包含在内。CDI规范为这种用途保留了请求参数`cid`。以下代码将通过链接传播对话上下文：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called for each request as
    long as the bean is not involved in a conversation. When the conversation begins,
    the method is called for that instance and subsequent requests will use this instance
    until the conversation ends. Therefore, be careful how you manage this method
    content.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将在每次请求中调用，只要bean不参与对话。当对话开始时，该方法会为该实例调用，后续请求将使用此实例，直到对话结束。因此，请小心管理此方法的内容。
- en: This example is wrapped into the application named `ch3_4` and is available
    in the code bundle of this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_4`的应用程序中，并可在本章的代码包中找到。
- en: The flow scope
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程范围
- en: The **flow scope** allows developers to group pages/views and demarcate the
    group with entry/exit points.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**流程范围**允许开发者对页面/视图进行分组，并通过入口/出口点来划分该组。'
- en: Between the request scope and the session scope, we have the CDI flow scope.
    This scope exists for a while in Spring Web Flow or ADF flow, and now is available
    in JSF 2.2 as well. Basically, the flow scope allows us to demarcate a set of
    related pages/views (usually, logic related) with an entry point (known as **start
    node**) and an exit point (known as **return node**).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求范围和会话范围之间，我们有CDI流程范围。这个范围在Spring Web Flow或ADF流程中存在一段时间，现在在JSF 2.2中也可用。基本上，流程范围允许我们通过一个入口点（称为**起始节点**）和一个出口点（称为**返回节点**）来划分一组相关的页面/视图（通常，逻辑相关）。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The flow scope is a good choice for applications that contain wizards, such
    as multiscreen subscriptions/registrations, bookings, and shopping carts. Generally
    speaking, any chunk of an application that has a logical start point and an end
    point can be encapsulated into the flow scope.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 流程范围是包含向导的应用程序的好选择，例如多屏幕订阅/注册、预订和购物车。一般来说，任何具有逻辑起点和终点的应用程序块都可以封装到流程范围中。
- en: In the same application, we can define multiple flows, which can be seen as
    modules that are reusable and capable to communicate. They can be called sequentially,
    can be encapsulated as Matrioska dolls or can create any custom design. Moreover,
    it is very easy to move, delete, or add a flow into such an application just by
    plugging in/out the entry and exit point.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一应用程序中，我们可以定义多个流，这些流可以被视为可重用且能够通信的模块。它们可以按顺序调用，可以封装成玛莉亚莎娃娃或创建任何自定义设计。此外，通过仅插入/拔出入口和出口点，就可以非常容易地将流移动、删除或添加到这样的应用程序中。
- en: 'To understand the benefits of using the flow scope, you have to identify some
    disadvantages of the applications that don''t use it. They are listed as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用流作用域的好处，您必须识别一些不使用它的应用程序的缺点。如下列所示：
- en: Each application is a big flow, but usually pages do not follow any intuitive
    logical design. Apparently, a disordered order governs even when pages are logically
    related, such as pages of a wizard or of a shopping cart.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序都是一个大型流，但通常页面并不遵循任何直观的逻辑设计。显然，即使页面在逻辑上相关，如向导或购物车页面，也由无序的顺序来管理。
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The flow scope allows us to define logical units of work.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流作用域允许我们定义逻辑工作单元。
- en: Reusing pages can be a difficult task to accomplish, since pages are so tied
    up to UI components and user interaction.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用页面可能是一项艰巨的任务，因为页面与UI组件和用户交互紧密相连。
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The flow scope provides reusability.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流作用域提供了可重用性。
- en: CDI provides conversation scope capable of stretching over several pages, but
    the flow scope fits better for JSF.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI提供了能够跨越多个页面的会话作用域，但流作用域更适合JSF。
- en: As the conversation scope, the flow scope covers a set of pages/views, but it
    has several main advantages, such as it is much more flexible, doesn't need that
    clumsy begin/end operation, flow scoped beans are created and destroyed automatically
    when the user enters or exists into/from a flow, provides easy-to-use support
    for inbound/outbound parameters, and prehandlers and posthandlers. A normal flow
    cannot be opened in multiple windows/tabs because information travels between
    pages with the session scope.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为会话作用域，流作用域覆盖了一组页面/视图，但它有几个主要优点，例如它更加灵活，不需要笨拙的开始/结束操作，流作用域的bean在用户进入或退出流时自动创建和销毁，提供了易于使用的对入站/出站参数、预处理程序和后处理程序的支持，并且预处理器和后处理器。由于信息在页面之间通过会话作用域传输，因此普通的流不能在多个窗口/标签页中打开。
- en: Note
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Data in a flow is scoped to that flow alone; therefore, flows can be opened
    in multiple windows/tabs.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 流中的数据仅限于该流本身；因此，可以在多个窗口/标签页中打开流。
- en: 'The **nodes** define the entry and exit points of a flow and there are five
    types of nodes, which are listed as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**定义了流的入口和出口点，并且有五种类型的节点，如下列所示：'
- en: '**View**: This represents any JSF page in the application that participates
    in the flow. It is known as a **view node** of the flow.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这代表应用程序中参与流的任何JSF页面。它被称为流的**视图节点**。'
- en: '**The method call**: This indicates an invocation of a method using EL. The
    called method may return an outcome that indicates which node should be navigated
    next.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法调用**：这表示使用EL调用方法。被调用的方法可能返回一个结果，指示下一个应导航的节点。'
- en: '**Switch**: The `switch` case statements are a substitute for long `if` statements.
    The cases are represented by EL expressions and are evaluated to Boolean values.
    Each case is accompanied by an outcome that will be used when the condition is
    evaluated to `true`. There is also a default outcome that will be used when all
    cases are evaluated to `false`.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换**：`switch`情况语句是长`if`语句的替代品。情况由EL表达式表示，并评估为布尔值。每个情况都伴随着一个结果，当条件评估为`true`时将使用该结果。还有一个默认结果，当所有情况都评估为`false`时将使用。'
- en: '**The flow call**: This is used to call another flow in the current flow—these
    are transition points between flows. The called flow (known as inner or nested
    flow) is nested in the flow that calls it (known as calling flow or outer flow).
    When the nested flow finishes its tasks, it will return a view node from the calling
    flow, which means that the calling flow will have control only after the nested
    flow''s lifespan comes to an end.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流调用**：这用于在当前流中调用另一个流——这些是流之间的转换点。被调用的流（称为内部或嵌套流）嵌套在调用它的流中（称为调用流或外部流）。当嵌套流完成其任务后，它将从调用流返回一个视图节点，这意味着调用流只有在嵌套流的生存周期结束时才会获得控制权。'
- en: '**The flow return**: This can be used for returning an outcome to the calling
    flow.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流返回**：这可以用于将结果返回给调用流。'
- en: Flows can pass parameters from one to the other. Parameters sent by a flow to
    another flow are known as **outbound parameters**, while parameters received by
    a flow from another flow are known as **inbound parameters**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以传递参数从一个传递到另一个。一个流发送给另一个流的参数被称为**出站参数**，而一个流从另一个流接收到的参数被称为**入站参数**。
- en: Well, at this point, you should have enough information about the flow scope
    to develop some examples. But, before doing this, you need to be aware of some
    tags, annotations, and conventions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这个时候，你应该已经拥有了足够的信息来开发一些示例。但在这样做之前，你需要注意一些标签、注解和约定。
- en: The flow definition is based on a set of conventions over configuration. A flow
    has a name, a folder in the web root of the application reflecting the flow name,
    and a view representing the start node that also reflects the flow name. This
    folder groups the pages/views that belong to the same flow.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 流定义基于配置的一组约定。一个流有一个名称，一个在应用程序Web根目录中反映流名称的文件夹，以及一个表示起始节点且也反映流名称的视图。此文件夹将属于同一流的页面/视图分组。
- en: In order to use a flow, you need to accomplish some configuration tasks. These
    can be done through a configuration file or programmatically. If you choose the
    first approach, then the configuration file can be limited to one flow, which
    means that it is stored in the flow folder and is named in the format *flowname*`-flow.xml`,
    or you can use the `faces-config.xml` file for having all flows in a single place.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一个流，你需要完成一些配置任务。这些任务可以通过配置文件或编程方式完成。如果你选择第一种方法，那么配置文件可以限制为一个流，这意味着它存储在流文件夹中，并以*flowname*`-flow.xml`的格式命名，或者你可以使用`faces-config.xml`文件将所有流放在一个地方。
- en: 'Since our first example uses the configuration file, we need to use tags. The
    main tags used for configuring a flow are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个示例使用配置文件，我们需要使用标签。用于配置流的标签如下：
- en: '`< flow-definition>`: This tag contains an `id` attribute that uniquely identifies
    the flow. The value of this ID is the flow name used to reference the flow from
    JSF pages or beans.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< flow-definition>`：此标签包含一个`id`属性，该属性唯一标识流。此ID的值是用于从JSF页面或bean引用流的流名称。'
- en: '`<view>`: It is nested in the `<flow-definition>` tag and indicates the JSF
    pages that represent the flow nodes; it associates an explicit ID to each page
    (Facelet) path (further, you can refer to each page by its ID). The page path
    is mapped in a `<vdl-document>` tag, nested in the `<view>` tag. The presence
    of this tag is optional, but as a convention, at least the `<view>` tag indicating
    the start node (start page) is present, especially if you want to set another
    start node besides the default one, which is represented by the page in the flow
    with the same name (ID) as the flow. Further, you can use the optional `<start-node>`*ID*`</start-node>`
    tag and indicate the ID of the `<view>` tag that maps the custom starting page.
    As an alternative, the start node of the flow can be indicated by setting the
    value of the `id` attribute of a `<view>` tag as the flow ID, and the content
    of the encapsulated `<vdl-document>` tag as the path of the custom starting page.
    When you refer to the flow ID, JSF will go to that page and automatically put
    you in the flow.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<view>`：它嵌套在`<flow-definition>`标签中，表示代表流节点的JSF页面；它为每个页面（Facelet）路径关联一个显式ID（进一步，你可以通过其ID引用每个页面）。页面路径在`<view>`标签中映射，该标签嵌套在`<view>`标签内。此标签的存在是可选的，但按照惯例，至少应该有一个`<view>`标签表示起始节点（起始页面），特别是如果你想设置除了默认的起始节点之外的另一个起始节点，该节点由与流具有相同名称（ID）的页面表示。此外，你可以使用可选的`<start-node>`*ID*`</start-node>`标签来指示映射自定义起始页面的`<view>`标签的ID。作为替代，流起始节点可以通过将`<view>`标签的`id`属性值设置为流ID，并将封装的`<vdl-document>`标签的内容作为自定义起始页面的路径来指示。当你引用流ID时，JSF将转到该页面并自动将你放入流中。'
- en: '`<flow-return>`: It is nested in the `<flow-definition>` tag and returns an
    outcome to the calling flow. You can refer to it through the value of the `id`
    attribute. There are at least three ways of getting out of a flow: using `<flow-return>`,
    using `<flow-call>` (presented later), or by abandoning the flow.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<flow-return>`：它嵌套在`<flow-definition>`标签中，并将结果返回给调用流。你可以通过`id`属性的值来引用它。至少有三种退出流的方法：使用`<flow-return>`，使用稍后介绍的`<flow-call>`，或者放弃流。'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We just said that a flow is identified by an ID (by a name). But, when the same
    flow name is defined in multiple documents (like in big projects that use multiple
    packaged flows from different vendors), there is one more ID needed. This ID is
    known as the **document ID**. Thus, when you need to identify a flow whose name
    appears in different documents, we need the flow ID and the defining document
    ID. Most of the time the document ID is omitted; therefore, it is not demonstrated
    in this section. In this section, you will see just a few hints about it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才说过，一个流程通过一个ID（一个名称）来识别。但是，当相同的流程名称在多个文档中定义（如在大型项目中使用来自不同供应商的多个打包流程），还需要一个额外的ID。这个ID被称为**文档ID**。因此，当你需要识别一个名称在不同文档中出现的流程时，我们需要流程ID和定义文档ID。大多数情况下，文档ID被省略；因此，本节中没有演示。在本节中，你将看到关于它的几个提示。
- en: 'In order to define the simplest flow, you need to be aware of the following
    diagram:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义最简单的流程，你需要了解以下图表：
- en: '![The flow scope](img/6466EN_03_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![流程范围](img/6466EN_03_08.jpg)'
- en: The simple flow
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的流程
- en: 'With these three tags, `<start-node>` and/or `<view>`, `<flow-return>`, and
    `<from-outcome>`, you can configure a simple flow, like a peddling registration
    form. Let''s suppose that a tennis player registers online to a tournament through
    a flow made up of two JSF pages (the flow name will be `registration`): a page
    containing a form used for collecting data and a confirmation page. Moreover,
    there will be two pages outside the flow, one for entering into the flow (like
    the first page of the website), and one that is called after confirmation.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个标签，`<start-node>`和/或`<view>`，`<flow-return>`，和`<from-outcome>`，你可以配置一个简单的流程，比如一个跑步注册表单。假设一个网球运动员通过由两个JSF页面组成的流程在线注册一个锦标赛（流程名称将为`registration`）：一个用于收集数据的表单页面和一个确认页面。此外，还将有两个页面在流程之外，一个用于进入流程（如网站的第一个页面），另一个在确认后调用。
- en: 'In the following diagram, you can see an image of our flow:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到我们流程的图像：
- en: '![The simple flow](img/6466EN_03_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![简单的流程](img/6466EN_03_09.jpg)'
- en: 'Let''s have a look at the code for the first page that is outside the flow
    and outside the registration folder (`index.xhtml`) as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看流程之外、注册文件夹之外的第一页的代码（`index.xhtml`）如下：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Two important things can be observed here. First, the following lines:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以观察到两个重要的事情。首先，以下几行：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line returns a Boolean value indicating whether the current page is
    or is not in a flow. Obviously, the `index.xhtml` page is not in a flow; therefore,
    `false` will be returned. You can use it for tests. The second line displays the
    ID of the current flow.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行返回一个布尔值，指示当前页面是否在流程中。显然，`index.xhtml`页面不在流程中；因此，将返回`false`。你可以用它进行测试。第二行显示当前流程的ID。
- en: Further, you need to take a look at the value of the attribute `action` of the
    `<h:commandButton>` tag. This value is the name (ID) of our flow; after the window
    context is enabled, JSF will search the indicated flow and navigate to the start
    node of the flow. By default, the window context is disabled.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要查看`<h:commandButton>`标签的`action`属性的值。这个值是我们流程的名称（ID）；在窗口上下文启用后，JSF将搜索指定的流程并导航到流程的起始节点。默认情况下，窗口上下文是禁用的。
- en: 'Therefore, when the button labeled **Start Registration** is clicked, the application
    steps in the registration flow and loads the start node page represented by the
    `registration.xhtml` page. The code for this page is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当点击标记为**开始注册**的按钮时，应用程序进入注册流程并加载由`registration.xhtml`页面表示的起始节点页面。此页面的代码如下：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are in the flow, `currentFlow` will return `true`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于流程中，`currentFlow`将返回`true`。
- en: 'It is more important to focus on the implicit object, `flowScope`; however,
    as you know from [Chapter 1](ch01.html "Chapter 1. Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)"), *Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)*, the `flowScope` implicit object (which
    indicates the current flow) is used for sharing data through the entire flow and
    maps to `facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`.
    For example, the value of the `<h:inputText>` tag can be put into the `flowScope`
    object and can be read from the flow scope in the next page, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是关注隐式对象`flowScope`；然而，正如您从[第1章](ch01.html "第1章。通过表达式语言(EL 3.0)动态访问JSF应用程序数据")中了解到的，*通过表达式语言(EL
    3.0)动态访问JSF应用程序数据*，`flowScope`隐式对象（表示当前流程）用于在整个流程中共享数据，并映射到`facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`。例如，`<h:inputText>`标签的值可以放入`flowScope`对象中，并且可以在下一页的流程作用域中读取，如下所示：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The button labeled **Register To Tournament** navigates to the second page
    in the flow, `confirm.xhtml`; this is a usual navigation case, there is nothing
    to say here. But the other button navigates outside the flow (to `index.xhtml`)
    by indicating the ID of a flow return. In the configuration file, this flow return
    is as shown in the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 标有**注册到锦标赛**的按钮导航到流程中的第二页`confirm.xhtml`；这是一个常见的导航情况，这里没有太多可说的。但另一个按钮通过指示流程返回的ID导航到流程外部（到`index.xhtml`）。在配置文件中，此流程返回的代码如下：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code of the `confirm.xhtml` page is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirm.xhtml`页面的代码如下：'
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This page displays the data that was entered and stored on the flow scope along
    with both the buttons. The first button navigates back to the `registration.xhtml`
    page, while the other one navigates to the `done.xhtml` page, which is outside
    the flow. The flow return is identified by the ID, as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面显示已输入并存储在流程作用域中的数据，以及两个按钮。第一个按钮导航回`registration.xhtml`页面，而另一个按钮导航到流程外部的`done.xhtml`页面。流程返回通过ID识别，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `done.xhtml` page just checks to see if the page is in flow and displays
    a simple message, as shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`done.xhtml`页面只是检查页面是否在流程中，并显示一条简单消息，如下面的代码所示：'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final step is to define the flow in a configuration file. Since you have
    a single flow, you can create a file `registration-flow.xml` in the `registration`
    folder. The following is the code of the `registration-flow.xml` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在配置文件中定义流程。由于您只有一个流程，您可以在`registration`文件夹中创建一个名为`registration-flow.xml`的文件。以下为`registration-flow.xml`文件的代码：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also place the following code inside the `faces-config.xml` file in
    the `<faces-flow-definition>` tag:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将以下代码放置在`faces-config.xml`文件中的`<faces-flow-definition>`标签内：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is wrapped into the application named `ch3_7_1` that is available
    in the code bundle of this chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_7_1`的应用程序中，该应用程序位于本章代码包中。
- en: Flows with beans
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有Bean的流程
- en: Beside pages, a flow can contain beans. A bean defined in a flow is annotated
    with `@FlowScoped`; this is a CDI annotation that enables automatic activation
    (when the scope is entered) and passivation (when the scope is exited). The `@FlowScoped`
    bean requires an attribute named `value` that contains the flow ID. The data stored
    in such a bean is available in all pages that belong to that flow.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了页面外，一个流程还可以包含Bean。在流程中定义的Bean被注解为`@FlowScoped`；这是一个CDI注解，它允许自动激活（当作用域进入时）和钝化（当作用域退出时）。`@FlowScoped`
    Bean需要一个名为`value`的属性，它包含流程ID。存储在这样的Bean中的数据可以在属于该流程的所有页面上访问。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The flow scope bean might get passivated by the container and should be capable
    of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 流程作用域Bean可能会被容器钝化，并且应该能够通过实现`java.io.Serializable`接口来支持钝化。
- en: 'Adding a bean in the registration flow can modify the initial diagram, as shown
    in the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册流程中添加Bean可以修改初始图，如下面的图所示：
- en: '![Flows with beans](img/6466EN_03_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![带有Bean的流程](img/6466EN_03_10.jpg)'
- en: As you can see, the bean will store the data collected from the registration
    form in the flow scope (in the previous example, this data was passed using the
    `flowScope` implicit object). The button labeled **Register To Tournament** will
    call the `registrationAction` bean method, which will decide if the data is valid
    and return the flow back to the `registration.xhtml` page or next to the `confirm.xhtml`
    page.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该Bean会将从注册表单收集的数据存储在流程作用域中（在先前的示例中，这些数据是通过`flowScope`隐式对象传递的）。标有“**注册参加锦标赛**”的按钮将调用`registrationAction`
    Bean方法，该方法将决定数据是否有效，并将流程返回到`registration.xhtml`页面或`confirm.xhtml`页面。
- en: 'The `registration.xhtml` page''s code is modified as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`registration.xhtml` 页面的代码修改如下：'
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code of `RegistrationBean` is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegistrationBean`的代码如下：'
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code is self explanatory, but what about the `getReturnValue` method? Well,
    this is just an example of how a flow scoped bean can indicate the outcome of
    a flow return. Instead of using the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的，但关于`getReturnValue`方法呢？这是一个流程作用域Bean如何指示流程返回结果的示例。而不是使用以下代码：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can use the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example is wrapped into the application named `ch3_7_2` that is available
    in the code bundle of this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_7_2`的应用程序中，该应用程序可在本章的代码包中找到。
- en: Nested flows
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套流程
- en: Well, now let's complicate things by adding another flow under the existing
    one. Let's suppose that after the registration, the player has to indicate the
    day and the hour when he is available to play the first match. This can be accomplished
    in a new flow named `schedule`. The `registration` flow will call the `schedule`
    flow and will pass some parameters to it. The `schedule` flow will return in the
    `registration` flow, which will provide a simple button for navigation outside
    the `registration` flow.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在让我们通过在现有流程下添加另一个流程来使事情变得复杂。假设在注册后，玩家必须指出他可以参加第一场比赛的日期和时间。这可以通过一个名为`schedule`的新流程来完成。`registration`流程将调用`schedule`流程，并向其传递一些参数。`schedule`流程将返回到`registration`流程，该流程将提供一个简单的按钮用于导航出`registration`流程。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The nested flow returns only in the calling flow. You have to refer to a page
    of the calling flow in the `<flow-return>` tag of the nested flow, including the
    pages returned by the calling flow.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套流程只返回到调用流程。您必须在嵌套流程的`<flow-return>`标签中引用调用流程的页面，包括调用流程返回的页面。
- en: 'Passing parameters is a thing that requires more tags in the configuration
    tag. Therefore, you need to know the following tags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 传递参数需要在配置标签中使用更多标签。因此，您需要了解以下标签：
- en: '`<flow-call>`: This calls another flow in the current flow. This tag requires
    the `id` attribute. The value of this attribute will be used to refer to this
    flow call.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<flow-call>`：在当前流程中调用另一个流程。此标签需要`id`属性。此属性的值将用于引用此流程调用。'
- en: '`<flow-reference>`: This is nested in the `<flow-call>` tag and contains the
    ID of the flow that must be called.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<flow-reference>`：这是嵌套在`<flow-call>`标签中，并包含必须调用的流程的ID。'
- en: '`<outbound-parameter>`: This is nested in the `<flow-call>` tag and defines
    parameters that must be passed to the called flow.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<outbound-parameter>`：这是嵌套在`<flow-call>`标签中，并定义了必须传递给被调用流程的参数。'
- en: '`<inbound-parameter>`: This defines the parameters passed from another flow.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<inbound-parameter>`：这定义了从另一个流程传递的参数。'
- en: 'In order to see these tags at work, you need to take a look at the application
    flow. The diagram of the application will change as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些标签在起作用，您需要查看应用程序流程。应用程序的图表将按以下方式更改：
- en: '![Nested flows](img/6466EN_03_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套流程](img/6466EN_03_11.jpg)'
- en: 'We resume our discussion from the `confirm.xhtml` page (defined in the `registration`
    flow). From this page, we want to navigate to the `schedule.xhtml` page, which
    is available in the `schedule` flow (the `schedule` folder). For this, we can
    add a new button, labeled **Schedule**, as shown in the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`confirm.xhtml`页面（在`registration`流程中定义）继续我们的讨论。从这个页面，我们想要导航到`schedule.xhtml`页面，该页面在`schedule`流程（`schedule`文件夹）中可用。为此，我们可以添加一个新按钮，标有**安排**，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The button''s `action` attribute value is the ID of the `<flow-call>` tag.
    When the button is clicked, JSF locates the corresponding `<flow-call>` tag and
    follows the flow with the ID indicated by the `<flow-id>` tag, as shown in the
    following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的`action`属性值是`<flow-call>`标签的ID。当按钮被点击时，JSF定位到相应的`<flow-call>`标签，并跟随由`<flow-id>`标签指示的流程，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Moreover, we want to pass several parameters from the `registration` flow to
    the `schedule` flow: the player name and surname (stored in the flow scoped `RegistrationBean`
    bean) and a constant representing some registration code (it can also be generated
    based on certain rules). This can be accomplished by the `<outbound-parameter>`
    tag, as shown in the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望从 `registration` 流程传递几个参数到 `schedule` 流程：玩家姓名和姓氏（存储在流程作用域的 `RegistrationBean`
    对象中）以及代表某些注册代码的常量（也可以根据某些规则生成）。这可以通过 `<outbound-parameter>` 标签实现，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `schedule.xhtml` page displays a hello message based on the received parameters
    and a form that allows to the player to enter the day and hour when he is available
    for playing the first match, as shown in the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule.xhtml` 页面根据接收到的参数显示一条问候信息，并允许玩家输入他可用于参加第一场比赛的日期和小时，如下面的代码所示：'
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the name and surname are obtained from the flow scope using the
    `flowScope` object, while the registration code is obtained from the flow scoped
    `ScheduleBean`; this bean stores the day, hour (received from the player), and
    registration code (received from the `registration` flow). Each piece of information
    received from the registration bean was guided to the place of storage using the
    `<inbound-parameter>` tag in the `schedule-flow.xml` file, as shown in the following
    code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，姓名和姓氏是通过 `flowScope` 对象从流程作用域中获得的，而注册代码是从流程作用域的 `ScheduleBean` 中获得的；这个对象存储了日期、小时（从玩家那里接收）和注册代码（从
    `registration` 流程接收）。从注册 Bean 接收到的每条信息都使用 `schedule-flow.xml` 文件中的 `<inbound-parameter>`
    标签引导到存储位置，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the day and hour are inserted, the button labeled **Save** should save
    the data and navigate to the `success.xhtml` page, which is a simple page that
    displays all data provided by the player. From this page, we can return to the
    calling flow, `registration`, via a simple button labeled **Exit Registration**,
    as shown in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在日期和小时插入后，标记为 **保存** 的按钮应该保存数据并导航到 `success.xhtml` 页面，这是一个显示玩家提供所有数据的简单页面。从该页面，我们可以通过一个标记为
    **退出注册** 的简单按钮返回到调用流程 `registration`，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The outcome, `taskFlowReturnThanks`, is defined in the `schedule-flow.xml`
    file as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果 `taskFlowReturnThanks` 在 `schedule-flow.xml` 文件中定义如下：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `thanks.xhtml` page is just a final step before the user exists from the
    `registration` flow, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`thanks.xhtml` 页面是用户从 `registration` 流程退出之前的最后一步，如下面的代码所示：'
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you want to jump over the `thanks.xhtml` page, directly outside of both
    flows, then you can define the flow return, `taskFlowReturnThanks`, to point out
    the `done.xhtml` page, which is returned by the calling flow via the `taskFlowReturnDone`
    flow return. Therefore, we can use the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跳过 `thanks.xhtml` 页面，直接从两个流程外部退出，那么你可以定义流程返回，`taskFlowReturnThanks`，指向 `done.xhtml`
    页面，这是由调用流程通过 `taskFlowReturnDone` 流程返回返回的。因此，我们可以使用以下代码：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example is wrapped into the application named `ch3_7_3` that is available
    in the code bundle of this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例被包含在名为 `ch3_7_3` 的应用程序中，该应用程序位于本章代码包中。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flows can be configured declaratively or programmatically using the JSF 2.2
    `FlowBuilder` API.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 流程可以使用 JSF 2.2 `FlowBuilder` API 声明性或编程地配置。
- en: Configuring flows programmatically
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程配置流程
- en: 'In all the previous examples, you saw how to configure a flow using the declarative
    approach. But, flows can be configured programmatically also. The steps for configuring
    a flow programmatically are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的示例中，你看到了如何使用声明性方法配置流程。但是，流程也可以通过编程方式配置。编程配置流程的步骤如下：
- en: Create a class and name it as the flow. This is more like a convention, not
    a requirement!
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类并将其命名为流程。这更像是一种约定，而不是要求！
- en: In this class, write a method as shown in the following code; the `@FlowDefinition`
    annotation is a class-level annotation that allows the flow definition to be defined
    using the `FlowBuilder` API. The name of this method can be any valid name, but
    `defineFlow` is like a convention. So, the name `defineFlow` is not mandatory,
    and you can even define more flows in the same class as long as you have annotated
    them correctly.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，编写一个如下所示的代码方法；`@FlowDefinition` 注解是一个类级别注解，它允许使用 `FlowBuilder` API 定义流程定义。这个方法的名称可以是任何有效的名称，但
    `defineFlow` 似乎是一种约定。所以，名称 `defineFlow` 不是强制的，你甚至可以在同一个类中定义更多的流程，只要正确地注解了它们。
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Use the `FlowBuilder` API to configure the flow.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `FlowBuilder` API 配置流程。
- en: 'Using the `FlowBuilder` API is pretty straightforward and intuitive. For example,
    you can write the `registration-flow.xml` file programmatically, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FlowBuilder` API 非常简单直观。例如，你可以按如下方式程序性地编写 `registration-flow.xml` 文件：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, for each tag used in the declarative approach, there is a corresponding
    method in the `FlowBuilder` API. For example, the `flowBuilder.id` method accepts
    two arguments: the first one represents the document ID (usually, an empty space),
    and the second one represents the flow ID.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于声明性方法中使用的每个标签，`FlowBuilder` API 中都有一个对应的方法。例如，`flowBuilder.id` 方法接受两个参数：第一个参数表示文档
    ID（通常为空格），第二个参数表示流程 ID。
- en: 'The `schedule-flow.xml` file can be programmatically translated as shown in
    the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule-flow.xml` 文件可以按如下所示程序性地转换：'
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called when the application
    enters into the current flow and the flow scoped bean is instantiated, while subsequent
    requests will use this instance until the flow is dumped. This is repeated if
    the application enters in this flow again. So, initializations specific to the
    current flow can be placed here.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 被注解为 `@PostConstruct` 的方法将在应用程序进入当前流程并实例化流程作用域的 bean 时被调用，而后续请求将使用此实例，直到流程被丢弃。如果应用程序再次进入此流程，此操作会重复。因此，可以在此处放置针对当前流程的特定初始化。
- en: This example is wrapped into the application named `ch3_7_5` that is available
    in the code bundle of this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为 `ch3_7_5` 的应用程序中，该应用程序位于本章的代码包中。
- en: Declarative and programmatic configurations can be mixed in the same application.
    For example, check the application named `ch3_7_4`, which uses programmatic configuration
    for the `registration` flow and declarative configuration for the `schedule` flow.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个应用程序中可以混合声明性和程序性配置。例如，检查名为 `ch3_7_4` 的应用程序，它为 `registration` 流程使用程序性配置，为
    `schedule` 流程使用声明性配置。
- en: Flows and navigation cases
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程和导航案例
- en: 'Navigation cases can be used for navigating inside flows. At this moment, when
    you click on the button labeled **Register To Tournament**, the flow goes in the
    `confirm.xhtml` page based on implicit navigation. But we can easily exemplify
    an explicit navigation in the flow by replacing the value of the `action` attribute
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 导航案例可以用于在流程内进行导航。在此刻，当您点击标记为 **注册到锦标赛** 的按钮时，流程将基于隐式导航进入 `confirm.xhtml` 页面。但我们可以通过替换
    `action` 属性的值轻松地展示流程中的显式导航：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, `confirm_outcome` cannot be automatically fetched to the `confirm.xhtml`
    page; therefore, in the `registration-flow.xml` file, we can add an explicit navigation
    case, as shown in the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`confirm_outcome` 不能自动获取到 `confirm.xhtml` 页面；因此，在 `registration-flow.xml`
    文件中，我们可以添加一个显式的导航案例，如下所示：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you need to use a navigation case to enter in a flow, you will have to
    specify the `<to-flow-document-id>`*document_ID*`</to-flow-document-id>` statement
    nested in the `<navigation-case>` tag. If there is no document ID, that uses `<to-flow-document-id/>`.
    Moreover a `<h:button>` (or `<h:link>`) can be used to enter in such a flow, as
    follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要使用导航案例进入流程时，您必须在 `<navigation-case>` 标签内指定 `<to-flow-document-id>`*document_ID*`</to-flow-document-id>`
    语句。如果没有文档 ID，则使用 `<to-flow-document-id/>`。此外，可以使用 `<h:button>`（或 `<h:link>`）进入此类流程，如下所示：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you choose to write a programmatic navigation case, then JSF 2.2 comes with
    a method named, `getToFlowDocumentId`, which should be overridden for indicating
    the document ID.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择编写程序性导航案例，那么 JSF 2.2 带有一个名为 `getToFlowDocumentId` 的方法，该方法需要被覆盖以指示文档 ID。
- en: At this point, everything comes to normal. Therefore, we can use explicit navigation
    cases for navigation between the flow's pages. The complete application is named
    `ch3_11_1`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切恢复正常。因此，我们可以使用显式导航案例在流程的页面之间进行导航。完整的应用程序命名为 `ch3_11_1`。
- en: 'In order to accomplish the same thing in a programmatic fashion, you need to
    use the `NavigationCaseBuilder` API, as shown in the following code; this is the
    same navigation case, so we have used only the needed methods:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以程序性的方式完成相同的事情，你需要使用 `NavigationCaseBuilder` API，如下所示；这是相同的导航案例，所以我们只使用了所需的方法：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example is wrapped in the complete application named `ch3_11_2`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在完整的应用程序 `ch3_11_2` 中。
- en: 'Moreover, you can even use a custom navigation handler. The new `NavigationHandlerWrapper`
    class (added in JSF 2.2) provides a simple implementation of the `NavigationHandler`
    class. Therefore, we can easily extend it to prove a navigation case using a custom
    navigation handler, as shown in the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你甚至可以使用自定义导航处理程序。新的`NavigationHandlerWrapper`类（在JSF 2.2中添加）提供了`NavigationHandler`类的一个简单实现。因此，我们可以轻松地扩展它以使用自定义导航处理程序证明导航案例，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, a quick configuration in the `faces-config.xml` file is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`faces-config.xml`文件中的快速配置如下：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the flow has a document ID, you need to override the `handleNavigation(FacesContext
    context, String fromAction, String outcome, String toFlowDocumentId)` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当流程有一个文档ID时，你需要重写`handleNavigation(FacesContext context, String fromAction,
    String outcome, String toFlowDocumentId)`方法。
- en: The complete application is named `ch3_11_3`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名称为`ch3_11_3`。
- en: Inspecting flow navigation cases
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查流程导航案例
- en: 'Whatever approach you choose for using navigation cases inside flows, you can
    always inspect them via the `ConfigurableNavigationHandler.inspectFlow` method.
    This method is invoked by the flow system to cause the flow to be inspected for
    navigation rules. You can easily override it to obtain information about navigation
    cases, by writing a custom configurable navigation handler. The easiest way to
    accomplish this is to extend the new `ConfigurableNavigationHandlerWrapper` class
    (introduced in JSF 2.2), which represents a simple implementation of `ConfigurableNavigationHandler`.
    For example, the following snippet of code sends in log information about each
    found navigation case:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方法在流程中使用导航案例，你都可以通过`ConfigurableNavigationHandler.inspectFlow`方法检查它们。此方法由流程系统调用以导致流程被检查导航规则。你可以轻松地重写它以获取有关导航案例的信息，通过编写一个自定义的可配置导航处理程序。最简单的方法是扩展新的`ConfigurableNavigationHandlerWrapper`类（在JSF
    2.2中引入），它代表`ConfigurableNavigationHandler`的一个简单实现。例如，以下代码段发送关于每个找到的导航案例的日志信息：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you attach this custom configurable navigation handler to one of the preceding
    three examples, then you will get information about the presented navigation case.
    The complete example is named `ch3_15`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此自定义可配置导航处理程序附加到前三个示例之一，那么你将获得有关所提供导航案例的信息。完整的示例名称为`ch3_15`。
- en: Using the initializer and finalizer
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用初始化器和终结器
- en: 'By using the `FlowBuilder` API, we can attach callback methods that will be
    automatically called when a flow is created and right before it is destroyed.
    The `FlowBuilder.initializer` method has the following signatures, which are called
    when the flow is created:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`FlowBuilder` API，我们可以附加回调方法，这些方法将在创建流程和销毁之前自动调用。`FlowBuilder.initializer`方法具有以下签名，当创建流程时被调用：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FlowBuilder.finalizer` signature is called before the flow is destroyed,
    as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlowBuilder.finalizer`签名在销毁流程之前被调用，如下所示：'
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For example, the `initializer` method can be used to pass external parameters
    into a flow. Let''s suppose that in the `index.xhtml` page (outside the flow),
    when we click on the button labeled **Start Registration**, we want to pass the
    tournament name and place into the flow, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用`initializer`方法将外部参数传递到流程中。假设在`index.xhtml`页面（在流程外部），当我们点击标有**开始注册**的按钮时，我们希望将锦标赛名称和地点传递到流程中，如下所示：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'These two parameters must be available when the flow starts, because the wrapped
    information is displayed in the `registration.xhml` page (the start node of the
    flow) via two properties from `RegistrationBean`, namely `tournamentName` and
    `tournamentPlace`. For this, we need to call a method from `RegistrationBean`
    capable of extracting this information and store it in these two properties, as
    shown in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数必须在流程开始时可用，因为包装的信息是通过`RegistrationBean`的两个属性在`registration.xhml`页面（流程的起始节点）中显示的，即`tournamentName`和`tournamentPlace`。为此，我们需要调用`RegistrationBean`中的一个方法来提取这些信息并将它们存储在这两个属性中，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now is the interesting part, because we can use the `initializer` method to
    indicate the `tournamentInitialize` method as the callback method that should
    be invoked when the flow is created. This can be done in the `registration-flow.xml`
    file as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分，因为我们可以使用`initializer`方法将`tournamentInitialize`方法指定为在创建流程时应调用的回调方法。这可以在`registration-flow.xml`文件中如下完成：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, at this moment, we can use the tournament name and place right from the
    beginning of the flow and during the flow's lifespan.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个时候，我们可以从流程的开始到流程的生命周期内直接使用锦标赛的名称和地点。
- en: 'Going further, another simple scenario can be the justification for using a
    `finalizer` method. Let''s suppose that we count the registered players via an
    application scoped bean named `PlayersCounterBean`, as shown in the following
    code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，另一个简单的场景可以是使用`finalizer`方法的理由。假设我们通过一个名为`PlayersCounterBean`的应用程序范围bean来计算注册的玩家，如下所示：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `count` variable should be increased when the player exits the flow, and
    the registration is successfully done; therefore, we can place a `finalizer` method
    in the `registration-flow.xml` file as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家退出流程并且注册成功时，`count`变量应该增加；因此，我们可以在`registration-flow.xml`文件中放置一个`finalizer`方法，如下所示：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `tournamentFinalize` method is implemented in `RegistrationBean`, as shown
    in the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`tournamentFinalize`方法在`RegistrationBean`中实现，如下所示：'
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since the `PlayersCounterBean` is an application bean, we can use its goodies
    outside the flow. The complete application is named `ch3_12_1`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PlayersCounterBean`是一个应用程序bean，我们可以在流程之外使用它的好处。完整的应用程序命名为`ch3_12_1`。
- en: 'The same output can be programmatically achieved using the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的输出可以使用以下代码程序性地实现：
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For the sake of variation, in this case we didn''t extract the parameter values
    using the request parameter `Map`. We preferred to use the implicit object `param`
    and to pass the values as arguments of the `tournamentInitialize` method as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了变化，在这种情况下，我们没有使用请求参数`Map`提取参数值。我们更愿意使用隐式对象`param`，并将值作为`tournamentInitialize`方法的参数传递，如下所示：
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The complete application is named `ch3_12_2`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch3_12_2`。
- en: Using the flow switch
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用流程切换
- en: 'The `switch` case statements are a substitute for long `if` statements and
    are useful to do conditional outcome mapping. In order to see it at work, we can
    suppose that for each tournament we have a separate `confirm.xhtml` page. Let''s
    have the four grand slams in tennis and the associated XHTML confirmation pages,
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`情况语句是长`if`语句的替代品，并且对于条件结果映射非常有用。为了看到它的工作情况，我们可以假设每个锦标赛都有一个单独的`confirm.xhtml`页面。让我们有网球四大满贯及其相关的XHTML确认页面，如下所示：'
- en: Roland Garros and `confirm_rg.xhtml`
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 罗兰·加洛斯和`confirm_rg.xhtml`
- en: Wimbledon and `confirm_wb.xhtml`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温布尔登和`confirm_wb.xhtml`
- en: US Open and `confirm_us.xhtml`
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国公开赛和`confirm_us.xhtml`
- en: Australian Open and `confirm_ao.xhtml`
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 澳大利亚公开赛和`confirm_ao.xhtml`
- en: 'The name and place of the tournament are passed in the flow via a simple form
    (one form per tournament), as follows (you already know from the preceding section
    how this information may be obtained inside the flow):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 锦标赛的名称和地点通过一个简单的表单（每个锦标赛一个表单）在流程中传递，如下所示（您可以从前面的章节中了解到如何在流程内部获取这些信息）：
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, after clicking on the button labeled **Register To...**, we need to choose
    the right confirmation page. For this, we can use a programmatic switch, as shown
    in the following code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在点击标记为**注册到...**的按钮后，我们需要选择正确的确认页面。为此，我们可以使用程序切换，如下所示：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that when no condition is evaluated to `true`, the selected node will
    be the `notournament.xhtml` page, which represents the default outcome. This is
    just a simple XHMTL page containing some specific text.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当没有条件评估为`true`时，选定的节点将是`notournament.xhtml`页面，它代表默认结果。这只是一个包含一些特定文本的简单XHMTL页面。
- en: 'The complete application is named `ch3_13`. Declaratively, this can be achieved
    in the `registration-flow.xml` file as shown in the following code. You can use
    `<view>` tags to hide the outcome''s path behind some IDs (map outcomes to pages),
    as we saw in the programmatic example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch3_13`。在`registration-flow.xml`文件中，可以通过以下代码声明性地实现这一点。您可以使用`<view>`标签将结果路径隐藏在ID之后（将结果映射到页面），正如我们在程序示例中看到的那样：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: So, switch can be useful when you don't want to map each outcome to a single
    page.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，切换在您不想将每个结果映射到单个页面时非常有用。
- en: This example wasn't wrapped in a complete application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子没有被包含在一个完整的应用程序中。
- en: Packaging flows
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包流程
- en: 'Flows act as logical units of work; therefore, they are portable across multiple
    applications. The portability is obtained by packaging the flow artifacts in a
    JAR file. Further, the JAR file can be added in any application `CLASSPATH` and
    the flow is ready to be used. To package a flow, you need to follow some conventions,
    which are listed as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 流作为工作逻辑单元；因此，它们可以在多个应用程序之间移植。这种可移植性是通过将流工件打包到JAR文件中获得的。此外，JAR文件可以添加到任何应用程序的`CLASSPATH`中，流就可以使用了。要打包一个流，你需要遵循一些约定，如下列所示：
- en: Explicitly define the flows in the `faces-config.xml` file.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`faces-config.xml`文件中明确定义流。
- en: In the JAR root, create a `META-INF` folder.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JAR根目录中创建一个`META-INF`文件夹。
- en: Add the `faces-config.xml` file in this folder.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件夹中的`faces-config.xml`文件添加进来。
- en: Add the `beans.xml` file in this folder.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件夹中的`beans.xml`文件添加进来。
- en: In the same folder, `META-INF`, create a subfolder named `flows`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中，`META-INF`，创建一个名为`flows`的子文件夹。
- en: In the `flows` folder, add all nodes (pages) of the flow.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`flows`文件夹中，添加流的所有节点（页面）。
- en: In the JAR root, outside the `META-INF` folder, add all the Java code (classes)
    needed by the flow.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JAR根目录中，在`META-INF`文件夹外部，添加流所需的全部Java代码（类）。
- en: 'Based on the preceding steps, the flow described in the *Flows with beans*
    section can be packaged in a JAR file named `registration.jar`, as shown in the
    following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的步骤，*带有bean的流*部分中描述的流可以被打包成一个名为`registration.jar`的JAR文件，如下面的截图所示：
- en: '![Packaging flows](img/6466EN_03_12.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![打包流](img/6466EN_03_12.jpg)'
- en: The complete application that uses this JAR file is named `ch3_14`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此JAR文件的应用程序完整名称为`ch3_14`。
- en: Programmatic flow scope
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序流作用域
- en: 'Programmatically speaking, the flow scope can be accessed via the `javax.faces.flow.FlowHandler`
    class. After obtaining a `FlowHandler` class''s object, you can easily access
    the current flow, add a new flow, and manipulate the flow map represented by `#{flowScope}`,
    as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程的角度讲，可以通过`javax.faces.flow.FlowHandler`类访问流作用域。在获得`FlowHandler`类的对象后，你可以轻松地访问当前流，添加一个新的流，并操纵由`#{flowScope}`表示的流映射，如下所示：
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Obviously, the `FlowHandler` class is the most important class involved in
    the interaction between runtime and the faces flow feature. This is an abstract
    class that can be extended to provide a custom flow handler implementation. In
    order to do that, you can start by creating a new `FlowHandlerFactory` class,
    which is used by the `Application` class to create the singleton instance of the
    `FlowHandler` class. This class has a simple implementation named `FlowHandlerFactoryWrapper`,
    which can be easily extended to return a custom flow handler, as shown in the
    following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`FlowHandler`类是参与运行时与面部流特征之间交互的最重要类。这是一个可以扩展以提供自定义流处理器实现的抽象类。为了做到这一点，你可以从创建一个新的`FlowHandlerFactory`类开始，该类被`Application`类用来创建`FlowHandler`类的单例实例。这个类有一个简单的实现名为`FlowHandlerFactoryWrapper`，它可以很容易地扩展以返回自定义流处理器，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This factory should be configured in the `faces-config.xml` file, as shown
    in the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 此工厂应在`faces-config.xml`文件中配置，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Further, the `CustomFlowHandler` class represents an extension of the `FlowHandler`
    class. Since the `FlowHandler` class is an abstract class, you need to provide
    an implementation for each of its methods, as shown in the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CustomFlowHandler`类代表了对`FlowHandler`类的扩展。由于`FlowHandler`类是一个抽象类，你需要为它的每个方法提供一个实现，如下面的代码所示：
- en: '[PRE71]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For example, you know from the previous sections that the `registration` flow
    passed several outbound parameters to the nested `schedule` flow. You saw how
    to accomplish that declaratively, in the `registration-flow.xml` file, and programmatically,
    via the `FlowBuilder` API, in the `Registration` class. You can do the same thing
    from a custom flow handler in the method named, `transition`, which is capable
    to perform a transition between a source flow (for example, `registration`) and
    a target flow (for example, `schedule`). When the `registration` flow calls the
    `schedule` flow, you can write the following code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以从前面的章节中知道，`registration`流向嵌套的`schedule`流传递了几个出站参数。你看到了如何在`registration-flow.xml`文件中声明性地完成这个操作，以及如何在`Registration`类中通过`FlowBuilder`
    API编程式地完成，如下面的代码所示。你可以在名为`transition`的方法中从自定义流处理器做同样的事情，这个方法能够在一个源流（例如，`registration`）和一个目标流（例如，`schedule`）之间执行转换。当`registration`流调用`schedule`流时，你可以编写以下代码：
- en: '[PRE72]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The target inbound parameters can be accessed as follows (the `Map` parameter
    cannot be altered):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 目标入站参数可以按以下方式访问（`Map`参数不能更改）：
- en: '[PRE73]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Flow parameters are represented by the `javax.faces.flow.Parameter` abstract
    class. The `CustomParameter` class provides an implementation as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 流参数由 `javax.faces.flow.Parameter` 抽象类表示。`CustomParameter` 类提供了以下实现：
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Dependent pseudo-scope
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖伪范围
- en: This is the default scope of a CDI bean (`@Named`) when nothing is specified.
    In this case, an object exists to serve exactly one bean and has the same life
    cycle as that bean; an instance of a dependent scoped bean is not shared between
    different users or different points of injection. It can also be explicitly specified
    by annotating the bean with the `@Dependent` annotation and importing `javax.enterprise.context.Dependent`.
    This scope is available only in CDI and is the only **non-contextual** scope.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CDI Bean（`@Named`）的默认范围，当没有指定任何内容时。在这种情况下，一个对象存在是为了精确地为一个 Bean 服务，并且具有与该
    Bean 相同的生命周期；依赖范围 Bean 的实例不会在不同用户或不同注入点之间共享。它也可以通过使用 `@Dependent` 注解和导入 `javax.enterprise.context.Dependent`
    来显式指定。这个范围仅在 CDI 中可用，并且是唯一的**非上下文**范围。
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All CDI scopes, except this one, are known as **normal** scopes. More details
    about normal scopes versus pseudo-scopes can be found in the *Normal scopes and
    pseudo-scopes* section at [http://docs.jboss.org/cdi/spec/1.0/html/contexts.html](http://docs.jboss.org/cdi/spec/1.0/html/contexts.html).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 CDI 范围，除了这个之外，都被称为**正常**范围。关于正常范围与伪范围的更多详细信息，可以在[http://docs.jboss.org/cdi/spec/1.0/html/contexts.html](http://docs.jboss.org/cdi/spec/1.0/html/contexts.html)的*正常范围和伪范围*部分找到。
- en: 'If you put the `PlayersBean` in the dependent scope, then the current extracted
    player and the list of randomly extracted players (which will be empty or will
    contain this player) is available only inside the bean, as shown in the following
    code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `PlayersBean` 放在依赖范围中，那么当前提取的玩家和随机提取的玩家列表（可能为空或包含此玩家）仅在 Bean 内部可用，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called for each request. Actually,
    it might be called multiple times during the same request, if the bean is used
    in several EL expressions. Initially, there is one instance of the bean, and this
    instance is reused if the bean EL name appears multiple times in the EL expression,
    but is not reused in the case of another EL expression or in the case of a re-evaluation
    of the same EL expression.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注有 `@PostConstruct` 的方法将为每个请求调用。实际上，如果 Bean 在多个 EL 表达式中使用，它可能会在同一个请求期间被多次调用。最初，有一个
    Bean 的实例，如果 Bean EL 名称在 EL 表达式中多次出现，则此实例会被重用，但在另一个 EL 表达式或同一 EL 表达式的重新评估的情况下则不会重用。
- en: This example is wrapped into the application named `ch3_5` that is available
    in the code bundle of this chapter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子被包裹在名为 `ch3_5` 的应用程序中，该应用程序位于本章代码包中。
- en: The none scope
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无范围
- en: The **none scoped** beans lives to serve other beans.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**无范围**的 Bean 生存下来为其他 Bean 服务。'
- en: The none scope seems to be the black sheep of JSF scopes. Even its name doesn't
    inspire something useful. Practically, a managed bean in this scope lives as long
    as a single EL expression evaluation and is not visible in any JSF page. If the
    application scope lives the longest, this scope lives the shortest. But, if you
    inject the none scoped managed beans in other managed beans, then they will live
    as long as their hosts. Actually, this is their job, to serve other beans.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 无范围似乎在 JSF 范围中是“黑羊”。即使它的名字也不让人联想到有用的东西。实际上，在这个范围内的管理 Bean 的生命周期与单个 EL 表达式评估一样长，并且在任何
    JSF 页面中都是不可见的。如果应用程序范围是最长的，那么这个范围就是最短的。但是，如果你在其他管理 Bean 中注入无范围的管理 Bean，那么它们将与宿主一样长。实际上，这是它们的职责，为其他
    Bean 服务。
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The none scoped objects used in the configuration file indicate managed beans
    that are used by other managed beans in the application.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中使用的无范围对象表示由其他管理 Bean 在应用程序中使用的管理 Bean。
- en: So, whenever you need a humble managed bean that is ready to be a part of a
    cool scope, such as a request or a session, you can annotate it with `@NoneScoped`,
    available in the `javax.faces.bean` package. Moreover, objects with the none scope
    can use other objects with the none scope.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次你需要一个谦逊的管理 Bean，它准备好成为请求或会话等酷范围的一部分时，你都可以使用 `javax.faces.bean` 包中的 `@NoneScoped`
    注解它。此外，具有无范围的对象可以使用具有无范围的其它对象。
- en: The custom scope
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义范围
- en: When none of the previous scopes meet your application needs, you have to pay
    attention to the JSF 2 custom scope. Most likely, you will never want to write
    a custom scope, but if it is necessary, then, in this section, you can see how
    to accomplish this task.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有前面的作用域满足你的应用程序需求时，你必须注意JSF 2自定义作用域。很可能你永远不会想编写自定义作用域，但如果有必要，那么在本节中，你可以看到如何完成这个任务。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The custom scope annotation is `@CustomScoped` and is defined in the `javax.faces.bean`
    package. It is not available in CDI!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义作用域注解是`@CustomScoped`，它定义在`javax.faces.bean`包中。它不在CDI中可用！
- en: In order to implement a custom scope, let's suppose that you want to control
    the life cycle of several beans that live in the application scope. Normally they
    live as long as the application lives, but you want to be able to add/remove them
    from the application scope at certain moments of the application flow. Of course,
    there are many approaches to do that, but remember that we look for a reason to
    implement a custom scope; therefore, we will try to write a custom scope nested
    in the application scope that will allow us to add/remove a batch of beans. Creating
    and destroying the scope itself will be reflected in creating and destroying the
    beans, which means that you don't need to refer to each bean.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现自定义作用域，假设你想要控制几个在应用程序作用域中存在的bean的生命周期。通常，它们的生命周期与应用程序的生命周期相同，但你希望能够在应用程序流程的某些时刻将它们添加/从应用程序作用域中移除。当然，有许多方法可以做到这一点，但请记住，我们寻找实现自定义作用域的原因；因此，我们将尝试编写一个嵌套在应用程序作用域中的自定义作用域，这将允许我们添加/移除一批bean。作用域的创建和销毁将反映在bean的创建和销毁中，这意味着你不需要引用每个bean。
- en: 'Actually, since this is just a demo, we will use only two beans: one will stay
    in the classical application scope (it can be useful for comparison of the application
    and custom scope lifespan), while the other one will be added/destroyed through
    the custom scope. The application purpose is not relevant; you should focus on
    the technique used to write a custom scope and paper over the assumptions and
    gaps. Think more on the lines that you can use this knowledge when you really
    need to implement a custom scope.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于这只是一个演示，我们将只使用两个bean：一个将保留在经典的应用程序作用域中（它可以用于比较应用程序和自定义作用域的生命周期），而另一个将通过自定义作用域被添加/销毁。应用程序的目的并不相关；你应该关注编写自定义作用域的技术，并填补假设和空白。多思考一下，当你真正需要实现自定义作用域时，你可以使用这些知识。
- en: Writing the custom scope class
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义作用域类
- en: 'The custom scope is represented by a class that extends the `ConcurrentHashMap<String,
    Object>` class. We need to allow concurrent access to an usual map because the
    exposed data may be accessed concurrently from multiple browsers. The code of
    the `CustomScope` class is as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义作用域由一个扩展`ConcurrentHashMap<String, Object>`类的类表示。我们需要允许对普通映射的并发访问，因为暴露的数据可能被多个浏览器并发访问。`CustomScope`类的代码如下：
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When our scope is created/destroyed, other components will be informed through
    events. In the `scopeCreated` method, you register `PostConstructCustomScopeEvent`,
    while in the `scopeDestroyed` method, you register `PreDestroyCustomScopeEvent`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的作用域被创建/销毁时，其他组件将通过事件得到通知。在`scopeCreated`方法中，你注册`PostConstructCustomScopeEvent`，而在`scopeDestroyed`方法中，你注册`PreDestroyCustomScopeEvent`。
- en: 'Now we have a custom scope, it is time to see how to declare a bean in this
    scope. Well, this is not hard and can be done with the `@CustomScoped` annotations
    and an EL expression, as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自定义作用域，是时候看看如何在这个作用域中声明一个bean了。嗯，这并不难，可以使用`@CustomScoped`注解和一个EL表达式来完成，如下所示：
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Resolving a custom scope EL expression
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析自定义作用域EL表达式
- en: 'At this point, JSF will iterate over the chain of existing resolvers in order
    to resolve the custom scope EL expression. Obviously, this attempt will end with
    an error, since no existing resolver will be able to satisfy this EL expression.
    So, you need to write a custom resolver as you saw in [Chapter 1](ch01.html "Chapter 1. Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)"), *Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)*. Based on
    that, you should obtain something as shown in the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，JSF将遍历现有解析器的链，以解析自定义作用域的EL表达式。显然，这次尝试将以错误结束，因为没有现有的解析器能够满足这个EL表达式。因此，你需要编写一个自定义解析器，就像你在[第1章](ch01.html
    "第1章。通过表达式语言(EL 3.0)动态访问JSF应用程序数据")中看到的那样，*通过表达式语言(EL 3.0)动态访问JSF应用程序数据*。基于此，你应该获得以下代码所示的内容：
- en: '[PRE78]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Do not forget to put the following resolver into the chain by adding it in
    the `faces-config.xml` file:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过在`faces-config.xml`文件中添加它来将以下解析器放入链中：
- en: '[PRE79]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Done! So far, you have created a custom scope, you put a bean into this scope,
    and learned that the brand new resolver provides access to this bean.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！到目前为止，你已经创建了一个自定义作用域，你将一个Bean放入这个作用域，并了解到这个全新的解析器提供了对这个Bean的访问。
- en: The custom scope must be stored somewhere, so nested in the application scope
    can be a choice (of course, other scopes can also be a choice, depending on your
    needs). When the scope is created, it has to be placed in the application map,
    and when it is destroyed, it has to be removed from the application map. The question
    is when to create it and when to destroy it? And the answer is, *it depends*.
    Most likely, this is a decision strongly tied to the application flow.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义作用域必须存储在某个地方，所以嵌套在应用程序作用域中可以是一个选择（当然，根据你的需求，其他作用域也可以是一个选择）。当作用域被创建时，它必须放置在应用程序映射中，当它被销毁时，它必须从应用程序映射中删除。问题是何时创建它，何时销毁它？答案是，*这取决于*。这很可能是与应用程序流程紧密相关的决定。
- en: Controlling the custom scope lifespan with action listeners
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动作监听器控制自定义作用域的生命周期
- en: 'Using action listeners can be a good practice even if it involves control from
    view declaration. Let''s suppose that the button labeled **START** will add the
    custom scope in the application map, as shown in the following code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 即使涉及从视图声明中进行控制，使用动作监听器也可以是一种良好的实践。假设标记为**START**的按钮将自定义作用域添加到应用程序映射中，如下面的代码所示：
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following `CreateCustomScope` class is a straightforward action listener
    as it implements the `ActionListener` interface:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`CreateCustomScope`类是一个简单的动作监听器，因为它实现了`ActionListener`接口：
- en: '[PRE81]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Following the same approach, the button labeled **STOP** will remove the custom
    scope from the application map as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的方法，标记为**STOP**的按钮将按照以下方式从应用程序映射中删除自定义作用域：
- en: '[PRE82]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following `DestroyCustomScope` class is the action listener as it implements
    the `ActionListener` interface:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`DestroyCustomScope`类作为动作监听器，因为它实现了`ActionListener`接口：
- en: '[PRE83]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This example is wrapped into the application named `ch3_8` that is available
    in the code bundle of this chapter. Just a run and a quick look over the code
    will clarify that the spaghetti-code is missing here.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_8`的应用程序中，该应用程序位于本章的代码包中。只需运行并快速查看代码，就可以清楚地看到这里没有缺失的意大利面代码。
- en: Controlling the custom scope lifespan with the navigation handler
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导航处理程序控制自定义作用域的生命周期
- en: 'Another approach is to control the custom scope lifespan based on the page''s
    navigation. This solution is more flexible and is hidden from the user. You can
    write a custom navigation handler by extending `NavigationHandler`. The next implementation
    puts the custom scope in the application map when the navigation reaches the page
    named `sponsored.xhtml`, and will remove it from the application map in any other
    navigation case. The code of the `CustomScopeNavigationHandler` class is as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是根据页面导航来控制自定义作用域的生命周期。这种解决方案更加灵活，并且对用户隐藏。你可以通过扩展`NavigationHandler`来编写自定义导航处理程序。下一个实现将自定义作用域放入应用程序映射中，当导航到达名为`sponsored.xhtml`的页面时，并在任何其他导航情况下将其从应用程序映射中删除。`CustomScopeNavigationHandler`类的代码如下：
- en: '[PRE84]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Do not forget to register the following navigation handler in the `faces-config.xml`
    file:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`faces-config.xml`文件中注册以下导航处理程序：
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This example is wrapped into the application named `ch3_9` that is available
    in the code bundle of this chapter. A quick look over the code will clarify that
    the spaghetti-code is missing here.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_9`的应用程序中，该应用程序位于本章的代码包中。快速查看代码可以清楚地看到这里没有缺失的意大利面代码。
- en: 'As I said earlier, JSF 2.2 comes with a wrapper class for `NavigationHandler`.
    This is a simple implementation that can be easily extended by developers. An
    instance of the class being wrapped is returned in the `getWrapped` method. For
    example, you can rewrite the `CustomScopeNavigationHandler` class, as shown in
    the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，JSF 2.2提供了一个`NavigationHandler`的包装类。这是一个简单的实现，可以很容易地被开发者扩展。`getWrapped`方法返回被包装的类的实例。例如，你可以重写`CustomScopeNavigationHandler`类，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This example is wrapped into the application named `ch3_10` that is available
    in the code bundle of this chapter.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_10`的应用程序中，该应用程序位于本章的代码包中。
- en: Managed bean instantiation
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Bean实例化
- en: 'By default, a managed bean is instantiated at first reference to it (a request,
    for example)—this is known as **lazy instantiation**. You can alter the default
    behavior by adding the `eager` attribute and set its value to `true`. This will
    instantiate the managed bean when the application starts, before any request is
    made. But, it is important to know that this works only for application scoped
    beans and the eager instantiated bean is placed in the application scope, as shown
    in the following lines of code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，管理Bean在第一次引用它时（例如请求）实例化——这被称为**延迟实例化**。您可以通过添加`eager`属性并将其值设置为`true`来更改默认行为。这将使管理Bean在应用启动时实例化，在发出任何请求之前。但，重要的是要知道这仅适用于应用作用域的Bean，并且延迟实例化的Bean被放置在应用作用域中，如下面的代码行所示：
- en: '[PRE87]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Beans injection
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean注入
- en: 'Normally, solutions depend on the concrete functional requirements, but finding
    the right solutions is what makes the difference between developers. Sometimes,
    developers get stuck or make mistakes when they work with objects in a scope that
    uses objects from another scope. From the following figure, you can seek some
    guidance for dealing with some of the most popular cases:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解决方案取决于具体的功能需求，但找到正确的解决方案是开发者之间的区别。有时，当开发者在使用来自另一个作用域的对象的作用域中工作时，他们可能会陷入困境或犯错误。从以下图中，您可以寻求一些处理一些最常见情况的指导：
- en: '![Beans injection](img/6466EN_03_13.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![Bean注入](img/6466EN_03_13.jpg)'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, there are some restrictions. As a general rule in JSF, don't
    use objects that have shorter lifespan than the objects you are calling it from.
    In other words, use objects whose lifespan is the same as, or longer than, the
    object being injected into. Breaking this rule will end up in a JSF exception.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一些限制。在JSF中，一般规则是不要使用生命周期比您调用的对象更短的对象。换句话说，使用生命周期与被注入对象相同或更长的对象。违反此规则将导致JSF异常。
- en: 'The logic behind this rule can be explained through the two most common mistakes,
    which are as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则的逻辑可以通过两个最常见的错误来解释，如下所示：
- en: '**Use request objects in session objects**: This is a bad thing, because we
    will have lots of requests (lots of instances) and only one session (one instance).
    Usually, requests belong to all users, while a session is one per user; therefore,
    it is unclear request object is injected? To be more clear, lots of requests means
    lots of associated beans, while a session means one bean. Now, it is illogical
    to inject one particular instance and skip all others. Moreover, how and when
    will you fetch the correct instance, since the request objects are transient,
    and usually, have a short lifespan! Even if you find a plausible use case, JSF
    will not allow you to do this via JSF managed beans.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在会话对象中使用请求对象**：这是不好的，因为我们会有很多请求（很多实例）和只有一个会话（一个实例）。通常，请求属于所有用户，而会话是每个用户一个；因此，不清楚请求对象是如何注入的？为了更清楚，许多请求意味着许多相关的Bean，而会话意味着一个Bean。现在，注入一个特定的实例而忽略其他所有实例是不合逻辑的。此外，您如何以及何时检索正确的实例，因为请求对象是瞬时的，通常生命周期较短！即使您找到一个合理的用例，JSF也不会允许您通过JSF管理Bean来实现这一点。'
- en: '**Use session objects in application objects**: The same logic can be applied
    further when we want to use session objects in application objects. Sessions are
    many as users, but the application is only one; therefore, you cannot inject all
    sessions in the application ... it is useless! Of course, you may want to fetch
    a certain session to the application, but you have to be sure that the pointed
    session exists; this is not a problem if you are interested in the session of
    the current user, but it may be an issue if you are interested in sessions of
    other users. Moreover, if there are many sessions, you have to correctly identify
    the desired session. Even if you find a plausible use case, JSF will not allow
    you to do this via JSF managed beans.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在应用对象中使用会话对象**：当我们要在应用对象中使用会话对象时，相同的逻辑可以进一步应用。会话的数量与用户数量一样多，但应用只有一个；因此，您不能将所有会话注入到应用中...这是没有用的！当然，您可能想将某个会话检索到应用中，但您必须确保指定的会话存在；如果您对当前用户的会话感兴趣，这并不是问题，但如果您对其他用户的会话感兴趣，可能会出现问题。此外，如果有许多会话，您必须正确识别所需的会话。即使您找到一个合理的用例，JSF也不会允许您通过JSF管理Bean来实现这一点。'
- en: Nevertheless, for CDI, these cases are not such a big issue. When you are using
    an object that has a shorter lifespan than the object you are calling it from
    (for example, injecting a request scoped bean into a session scoped bean), CDI
    classifies the use case as a mismatched injection and fixes the issue via CDI
    proxies. For each request, the CDI proxy re-establishes the connection to a live
    instance of the request scoped bean.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于CDI来说，这些情况并不是什么大问题。当你使用一个生命周期比调用它的对象更短的对象时（例如，将请求作用域的bean注入到会话作用域的bean中），CDI将这种情况分类为不匹配的注入，并通过CDI代理来解决这个问题。对于每个请求，CDI代理都会重新建立与请求作用域bean的实时实例的连接。
- en: 'Even when we follow the written rules, we are still vulnerable to the unwritten
    rules. One of the unwritten rules that can cause undesirable results is named
    **overuse** or **abuse**. The following are some cases to avoid:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 即使遵循了书面的规则，我们仍然容易受到未书面规则的侵害。可能导致不希望的结果的未书面规则之一被称为**过度使用**或**滥用**。以下是一些需要避免的情况：
- en: Overusing a view scoped bean for request scoped data may affect memory.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用视图作用域的bean来处理请求作用域的数据可能会影响内存。
- en: Overusing a request scoped bean for view scoped data may cause forms with unexpected
    behavior.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用请求作用域的bean来处理视图作用域的数据可能会导致表单出现意外的行为。
- en: Overusing an application scoped bean for request/view/session scoped data may
    cause an undesirably wide visibility of data across users and will affect memory.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用应用作用域的bean来处理请求/视图/会话作用域的数据可能会导致数据在用户之间具有不希望的范围，并影响内存。
- en: Overusing a session scoped bean for request/view data may cause an undesirably
    wide visibility of data across multiple browser windows/tabs in that session.
    As you know, view data are specific to a single browser window/tab, which allows
    us to open multiple tabs and keeps the data integrity while switching between
    tabs. On the other hand, if this data was exposed via the session scope, then
    the modifications in one window/tab will be reflected in the browser session;
    therefore, switching between tabs will lead to an apparently strange behavior,
    known as inconsistency of data. In case of using the session scope for request/view
    data, will also affect memory, since request/view scopes are meant to have a shorter
    lifespan than session scope.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用会话作用域的bean来处理请求/视图数据可能会导致在该会话的多个浏览器窗口/标签页中数据具有不希望的范围。正如你所知，视图数据是针对单个浏览器窗口/标签页的，这允许我们打开多个标签页，并在切换标签页时保持数据完整性。另一方面，如果这些数据通过会话作用域公开，那么一个窗口/标签页中的修改将在浏览器会话中反映出来；因此，在标签页之间切换将导致一种称为数据不一致性的明显奇怪的行为。在使用会话作用域处理请求/视图数据的情况下，也会影响内存，因为请求/视图作用域的预期生命周期比会话作用域短。
- en: Starting with JSF 2.0, managed beans can be injected (dependency injection)
    into the property of another managed bean using the `@ManagedProperty` annotation.
    You already know that from the previous chapter, where an example is provided.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.0开始，可以使用`@ManagedProperty`注解将管理bean注入到另一个管理bean的属性中（依赖注入）。你已经在上一章中知道了这一点，其中提供了一个示例。
- en: Another way to inject beans is to use the `@Inject` annotation, which is part
    of the CDI powerful injection mechanism.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注入bean的另一种方式是使用`@Inject`注解，它是CDI强大注入机制的一部分。
- en: So when do we use `@ManagedProperty` and when do we use `@Inject` ? Well, we
    know that both of them do the same thing in different ways and different containers,
    so maybe it is a good idea to use `@ManagedProperty` when you are working in a
    servlet container or just don't need CDI. Another good argument for `@ManagedProperty`
    is that you can use EL with it. But, if you are in a proper CDI environment where
    you can exploit CDI benefits, such as proxy scope leak prevention or better deploy-time
    dependency, then use CDI.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们何时使用`@ManagedProperty`，何时使用`@Inject`呢？嗯，我们知道它们以不同的方式在不同的容器中做相同的事情，所以当你在一个servlet容器中工作或者根本不需要CDI时，使用`@ManagedProperty`可能是个好主意。`@ManagedProperty`的另一个优点是你可以用它来使用表达式语言（EL）。但是，如果你在一个合适的CDI环境中，可以充分利用CDI的好处，比如防止代理作用域泄露或更好的部署时依赖，那么就使用CDI。
- en: 'The pacifist approach will combine these two in the same application. In this
    case, you have two options: to avoid any interaction between the managed beans
    and CDI beans or, obviously, to encourage the interaction between them for better
    performance. If you choose the second option, then it is important to keep in
    mind some simple rules of injection as shown in the following figure:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 和平主义方法将在同一应用程序中将这两者结合起来。在这种情况下，你有两个选择：避免管理bean和CDI bean之间的任何交互，或者显然地，鼓励它们之间的交互以获得更好的性能。如果你选择第二个选项，那么重要的是要记住以下图示中所示的一些简单的注入规则：
- en: '![Beans injection](img/6466EN_03_14.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![豆注射](img/6466EN_03_14.jpg)'
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have browsed through an overview of JSF/CDI scopes. It begins
    with an open discussion about JSF scopes versus CDI scopes, meant to provide a
    few advantages/disadvantages of choosing either one (or both). After a short overview
    of JSF/CDI scopes, each scope was detailed by covering fundamental knowledge,
    such as definition, usability, functionality, restrictions, and examples.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们浏览了JSF/CDI作用域的概述。它从关于JSF作用域与CDI作用域的开放讨论开始，旨在提供选择任何一个（或两个）的一些优缺点。在简要概述JSF/CDI作用域之后，每个作用域都通过涵盖基本知识，如定义、可用性、功能、限制和示例进行了详细说明。
- en: The chapter ends with a bunch of thoughts regarding beans injections. You can
    find several rules, tips, and bad practices commonly used in JSF applications
    mentioned out here.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以一系列关于豆注射的思考结束。在这里，你可以找到在JSF应用程序中常用的一些规则、技巧和不良做法。
- en: See you in the next two chapters, where we will cover many kinds of JSF artifacts
    and configuration stuff.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在下一章中相见，我们将涵盖许多种类的JSF工件和配置内容。
