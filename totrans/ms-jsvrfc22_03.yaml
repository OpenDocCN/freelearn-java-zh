- en: Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If programming is an art, then working correctly with scopes is a part of it!
  prefs: []
  type: TYPE_NORMAL
- en: This affirmation is generally true, not just in JSF. Should I use the session
    scope now, or the request scope? Do I have too many session beans? Can I inject
    this scope into that scope? Is this session object too big? How many times have
    you asked yourself these kinds of questions? I know ... many times! Maybe in this
    chapter you will find answers to some of these questions and you will fortify
    your knowledge about working with JSF scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a lot to accomplish; therefore, let''s have a short overview of what
    you will see in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: JSF scopes versus CDI scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request scope, session scope, view scope, application scope, conversation scope,
    flow scope, none scope, dependent scope, and custom scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beans injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF scopes versus CDI scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even a JSF beginner might have heard about JSF managed beans (regular JavaBeans
    classes managed by JSF) and CDI beans (regular JavaBeans classes managed by CDI),
    and knows that JSF supports JSF scopes and CDI scopes. Starting with Java EE 6,
    CDI is recognized as the managed bean framework, besides EJBs. This causes confusion
    among programmers, because EJBs, CDIs, and JSF managed beans raise a critical
    question: which one to use and when?'
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on JSF, the unanimous answer is that CDI beans are more powerful than
    JSF beans. But, when you know right from the start that CDI will not be a part
    of your application or you are running the application inside a servlet container
    (which does not have CDI support by default, like Apache Tomcat), then JSF beans
    is the right choice. In other words, when you need a simple way to define beans
    and a neat mechanism for a dependency injection, then JSF bean will do the job,
    but when you need heavy artillery, such as events, type safe injection, automatic
    injection, producer methods, and interceptors, then CDI will represent the complete
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, NetBeans IDE 8.0 warns us that the JSF bean''s annotations will be
    deprecated in the next JSF version, while the CDI beans are recommended instead
    (as shown in the following screenshot). This warning and the new JSF 2.2 flow
    scope, introduced as a dependency on CDI, are powerful signals that JSF and CDI
    become closer and closer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CDI beans are much powerful than JSF beans; therefore, use CDI beans whenever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: So, strong arguments indicate CDI is often the right choice, but there are still
    instances where it is effective to use JSF beans, as you will soon discover.
  prefs: []
  type: TYPE_NORMAL
- en: JSF bean's main annotations (such as `@ManagedBean` and scopes annotations)
    are defined in the package `javax.faces.bean`, while CDI's main annotations are
    defined in the `javax.inject` (such as, `@Named`) and `javax.enterprise.context`
    (such as, scopes) packages.
  prefs: []
  type: TYPE_NORMAL
- en: A JSF managed bean is annotated with `@ManagedBean`, which allows us to inject
    it in to another bean (not CDI beans!) and to access the bean properties and methods
    from JSF pages using EL expressions. A CDI bean is annotated with `@Named`, which
    provides an EL name to be used in view technologies, such as JSP or Facelets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a JSF bean is declared as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSF bean, `@ManagedBean`, supports an optional parameter, `name`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A CDI bean has the same shape, with different annotations, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The CDI bean, `@Named`, supports an optional parameter, `value`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that CDI annotations cannot be mixed with JSF annotations in the same
    bean, only in the same application. For example, you cannot define a bean using
    `@ManagedBean` and a CDI scope (or any other combination between them), but you
    can have, in the same application, a managed bean (or more) and a CDI bean (or
    more).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a short overview of JSF 2.2 scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you will see how each JSF/CDI scope works.
  prefs: []
  type: TYPE_NORMAL
- en: The request scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **request scope** is bound to the HTTP request-response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The request scope is very useful in any web application, and an object defined
    in the request scope usually has a short lifespan; beans live as long as the HTTP
    request-response lives. When the container accepts an HTTP request from the client,
    the specified object is attached to the request scope and it is released when
    the container has finished transmitting the response to that request. A new HTTP
    request always comes in a new request scope object. In short, a request scope
    represents a user's interaction with a web application in a single HTTP request.
    Commonly, a request scope is useful for simple GET requests that expose some data
    to the user without requiring to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request scope is present in JSF and CDI and functions in the same way. It
    can be used for nonrich AJAX and non-AJAX requests. For JSF managed beans (`@ManagedBean`),
    this is the default scope, when none is specified.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's suppose that we have a predefined list of tennis players,
    and we randomly extract them one-by-one from this list and store them in another
    list. The current generated player and the list of extracted players are managed
    bean's properties and their values are rendered in a JSF page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request scope annotation is `@RequestScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the CDI bean can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The relevant part of the JSF page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on the button labeled **Get Players With Page Forward** or **Get
    Players In Same View**, you will see something as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The request scope](img/6466EN_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since a request scope lives as long as the HTTP request-response lives and page
    forward implies a single HTTP request-response, you will see the player extracted
    at the current request and the list of extracted players, which will always only
    contain this player. The list is created for each request and filled with the
    current player, which makes the list useless.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The request scope doesn't lose the object's state while forwarding, because
    the source page and the destination page (the forwarded page) are part of the
    same request-response cycle. This is not true in the case of redirect actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the button labeled **Get Players With Page Redirect**, you
    will see something as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The request scope](img/6466EN_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The current extracted player and the list content is not available in this case,
    because a JSF redirect implies two requests, instead of one as in the forward
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically, you can access the request map using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Submitting a form defined in page 1 to page 2 via a bean, and then you have
    the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the same view or forward is used, then the data is available for display
    on page 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If redirect is used, then data will be lost and not available for display on
    page 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSF version of the CDI beans is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And it works the same as the CDI bean!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called for each request, since
    each request requires a separate instance of the request scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: The case of the CDI bean is wrapped into the application named `ch3_1_1`, while
    the case of the JSF bean is wrapped into application named `ch3_1_2`.
  prefs: []
  type: TYPE_NORMAL
- en: The session scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **session scope** lives across multiple HTTP request-response cycles (theoretical
    unlimited).
  prefs: []
  type: TYPE_NORMAL
- en: The request scope is very useful in any web application when you need a single
    interaction per HTTP request-response cycle. However, when you need objects visible
    for any HTTP request-response cycle that belongs to a user session, then you need
    a session scope; in this case, the bean lives as long as the HTTP session lives.
    The session scope allows you to create and bind objects to a session. It gets
    created upon the first HTTP request involving this bean in the session and gets
    destroyed when the HTTP session is invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The session scope is present in JSF and CDI and it functions the same way in
    both. Commonly, it is used for AJAX and non-AJAX requests that process user-specific
    data (such as credentials, shopping carts, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first HTTP request initializes the session and stores the objects,
    while the subsequent requests have access to these objects for further tasks.
    A session invalidation occurs when the browser is closed, a timeout is fired,
    the logout is clicked, or a programmatic subroutine forces it. Normally, each
    time you need to preserve data across the whole session (multiple requests and
    pages), the session scope is the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can add the session scope to the previous applications of this
    chapter for storing the list of randomly extracted players across multiple requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The session scope annotation is `@SessionScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CDI bean is modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the JSF version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the session scope bean might get passivated by the container and
    should be capable of passivity, which means that the session beans should be serializable
    (implement the `java.io.Serializable` interface); refer to the capability to persist/restore
    session data to/from the hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The session objects lives across forward and redirect mechanisms. In the following
    screenshot, you can see the current extracted player and the list of extracted
    players after several requests belonging to the same session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The session scope](img/6466EN_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the list is not useless anymore! You can add methods for manipulating its
    content, such as order or delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically, you can access the session map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can invalidate a session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, data submitted through forms across the session scope will be available
    in subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called only once during a session,
    when the session bean is instantiated. Subsequent requests will use this instance,
    so it can be a good place to add initialization stuff.
  prefs: []
  type: TYPE_NORMAL
- en: The case of the CDI bean is wrapped into the application named `ch3_2_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_2_2`.
  prefs: []
  type: TYPE_NORMAL
- en: The view scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **view scope** lives as long as you are navigating in the same JSF view
    in the browser window/tab.
  prefs: []
  type: TYPE_NORMAL
- en: The view scope is useful when you need to preserve data over multiple requests
    without leaving the current JSF view by clicking on a link, returning a different
    action outcome, or any other interaction that dumps the current view. It gets
    created upon an HTTP request and gets destroyed when you postback to a different
    view; as long as you postback to the same view, the view scope is alive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the view scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Since the view scope is particularly useful when you are editing some objects
    while staying in the same view, it can be the perfect choice for rich AJAX requests.
    Moreover, since the view scope is bounded to the current view, it does not reflect
    the stored information in another window or tab of a browser; this is an issue
    specific to the session scope!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to keep the view active, the bean methods (actions/listeners) must
    return `null` or `void`.
  prefs: []
  type: TYPE_NORMAL
- en: The view scope is not available in CDI, but JSF 2.2 has introduced it through
    the new annotation, `@ViewScoped`. This is defined in the `javax.faces.view.ViewScoped`
    package and it is compatible with CDI. Do not confuse this `@ViewScoped` with
    the one defined in the `javax.faces.bean` package, which is JSF compatible!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The view scope annotation is `@ViewScoped` and is defined in the `javax.faces.view`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the view scope in action by modifying the `PlayersBean` scope as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Firing multiple HTTP requests by clicking on the button labeled **Get Players
    In Same View** will reveal something like the following screenshot. Notice the
    action method (`newPlayer`) returns void and the button doesn't contain the `action`
    attribute, which means that you are in the same JSF view during the execution
    of these requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![The view scope](img/6466EN_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other two buttons contain the `action` attribute and indicate an explicit
    navigation, which means that the current view is changed at every request and
    the data is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily adapt `PlayersBean` (and any other bean) to use the JSF version
    of `@ViewScoped` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data submitted through forms across the view scope will be available in subsequent
    requests as long as you are in the same view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called only when the view scoped
    bean is instantiated. Subsequent requests, from this view, will use this instance.
    As long as you are in the same view, this method will not be called again; therefore,
    it can be a good place to add initialization stuff specific to the current view.
  prefs: []
  type: TYPE_NORMAL
- en: The case of the CDI bean is wrapped into the application named `ch3_6_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_6_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use the `UIViewRoot.restoreViewScopeState(FacesContext
    context, Object state)` method for restoring the view scope when it is not available.
    This will be exemplified in [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*.
  prefs: []
  type: TYPE_NORMAL
- en: The application scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **application scope** lives as long as the web application lives.
  prefs: []
  type: TYPE_NORMAL
- en: An application scope extends the session scope with the shared state across
    all users' interactions with a web application; this scope lives as long as the
    web application lives. Since the beans in the application scope lives until the
    application shuts down (or they are programmatically removed), we can say that
    this scope lives most. More precisely, objects settled on the application scope
    can be accessed from any page that is part of the application (for example, JSF,
    JSP, and XHTML).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application scope should be used only for data that is safe to be shared.
    Since an application scoped bean is shared by all users, you need to be sure that
    the bean has an immutable state or you need to synchronize access.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, application scope objects are used as counters, but they can be used
    for many other tasks, such as initializations and navigations. For example, the
    application scope can be used to count how many users are online or to share that
    information with all users. Practically, it can be used to share data among all
    sessions, such as constants, common settings, and tracking variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application scope annotation is `@ApplicationScoped` and is defined in the
    `javax.enterprise.context` package for CDI, and in the `javax.faces.bean` package
    for JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put the `PlayersBean` managed bean in the application scope, then the
    list of randomly extracted players will be available across all sessions. You
    can do it as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSF version is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For testing the application scope, you need to open multiple browsers or use
    multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when you provide data from an application scoped bean to multiple
    sessions beans (for example, using injection), since the data shared by all sessions
    can be modified by each session separately. This can lead to inconsistent data
    across multiple users; therefore, be sure that the exposed application data isn't
    modified in sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called only when the application
    scoped bean is instantiated. Subsequent requests will use this instance. Usually,
    this happens when the application starts; therefore, place inside this method
    the initialization tasks specific to the application in the context of this bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically, you can access the application map using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The case of the CDI bean is wrapped into the application named `ch3_3_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_3_2`.
  prefs: []
  type: TYPE_NORMAL
- en: The conversation scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **conversation scope** allows developers to demarcate the lifespan of the
    session scope.
  prefs: []
  type: TYPE_NORMAL
- en: The conversation scope is committed to the user's interaction with JSF applications
    and represents a unit of work from the point of view of the user; a bean in this
    scope is able to follow a conversation with a user. We may charge the conversation
    scope as a developer-controlled session scope across multiple invocations of the
    JSF life cycle; while session scoped lives across unlimited requests, the conversation
    scopes lives only across a limited number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The conversation scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The developer can explicitly set the conversation scope boundaries and can start,
    stop, or propagate the conversation scope based on the business logic flow. All
    long-running conversations are scoped to a particular HTTP servlet session and
    may not cross session boundaries. In addition, conversation scope keeps the state
    associated with a particular Web browser window/tab in a JSF application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The conversation scope annotation is `@ConversationScoped` and is defined in
    the `javax.enterprise.context` package for CDI. This scope is not available in
    JSF!
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with the conversation scope is slightly different from the rest of
    the scopes. First, you mark the bean with `@ConversationScope`, represented by
    the `javax.enterprise.context.ConversationScoped` class. Second, CDI provides
    a built-in bean (`javax.enterprise.context.Conversation`) for controlling the
    life cycle of conversations in a JSF application—its main responsibility is to
    manage the conversation context. This bean may be obtained by injection, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `Conversation` object is in transient state and it should be
    transformed into a long-running conversation by calling the `begin` method. You
    also need to prepare for the destruction of the conversation by calling the `end`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we try to call the `begin` method when the conversation is active, or the
    `end` method when the conversation is inactive, `IllegalStateException` will be
    thrown. We can avoid this by testing the transitivity state of the `Conversation`
    objects using the method named `isTransient`, which returns a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `begin`, `end`, and `isTransient` methods together to the following
    conversations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For start conversation, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For stop conversation, the code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, you can add the conversation scope in `PlayersBean` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Besides injecting the built-in CDI bean, notice that you have defined a method
    (`startPlayerRnd`) for demarcating the conversation start point and another method
    (`stopPlayerRnd`) for demarcating the conversation stop point. In this example,
    both the methods are exposed to the user through two buttons, but you can control
    the conversation programmatically by calling them conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example inside a conversation will reveal something as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The conversation scope](img/6466EN_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The list of randomly extracted players will be empty or will contain only the
    current extracted player until the button labeled **Start Conversation** is clicked.
    At that moment the list will be stored in session, until the button labeled **Stop
    Conversation** is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the conversation, the user may execute AJAX/non-AJAX requests against
    the bean or perform navigations to other pages that still reference this same
    managed bean. The bean will keep its state across user interactions using a **conversation
    identifier** generated by the container, and this is why the conversation scope
    can be the right choice when you need to implement wizards. But it might be a
    good idea to take into account the new JSF 2.2 flow scope as well, which solves
    several gaps of the conversation scope. See the upcoming section!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the conversation context automatically propagates with any
    JSF faces request or redirection (this facilitates the implementation of the common
    POST-then-redirect pattern), but it does not automatically propagate with non-faces
    requests, such as links. In this case, you need to include the unique identifier
    of the conversation as a request parameter. The CDI specification reserves the
    request parameter `cid` for this use. The following code will propagate the conversation
    context over a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called for each request as
    long as the bean is not involved in a conversation. When the conversation begins,
    the method is called for that instance and subsequent requests will use this instance
    until the conversation ends. Therefore, be careful how you manage this method
    content.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch3_4` and is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The flow scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **flow scope** allows developers to group pages/views and demarcate the
    group with entry/exit points.
  prefs: []
  type: TYPE_NORMAL
- en: Between the request scope and the session scope, we have the CDI flow scope.
    This scope exists for a while in Spring Web Flow or ADF flow, and now is available
    in JSF 2.2 as well. Basically, the flow scope allows us to demarcate a set of
    related pages/views (usually, logic related) with an entry point (known as **start
    node**) and an exit point (known as **return node**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope is a good choice for applications that contain wizards, such
    as multiscreen subscriptions/registrations, bookings, and shopping carts. Generally
    speaking, any chunk of an application that has a logical start point and an end
    point can be encapsulated into the flow scope.
  prefs: []
  type: TYPE_NORMAL
- en: In the same application, we can define multiple flows, which can be seen as
    modules that are reusable and capable to communicate. They can be called sequentially,
    can be encapsulated as Matrioska dolls or can create any custom design. Moreover,
    it is very easy to move, delete, or add a flow into such an application just by
    plugging in/out the entry and exit point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the benefits of using the flow scope, you have to identify some
    disadvantages of the applications that don''t use it. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each application is a big flow, but usually pages do not follow any intuitive
    logical design. Apparently, a disordered order governs even when pages are logically
    related, such as pages of a wizard or of a shopping cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope allows us to define logical units of work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reusing pages can be a difficult task to accomplish, since pages are so tied
    up to UI components and user interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope provides reusability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CDI provides conversation scope capable of stretching over several pages, but
    the flow scope fits better for JSF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the conversation scope, the flow scope covers a set of pages/views, but it
    has several main advantages, such as it is much more flexible, doesn't need that
    clumsy begin/end operation, flow scoped beans are created and destroyed automatically
    when the user enters or exists into/from a flow, provides easy-to-use support
    for inbound/outbound parameters, and prehandlers and posthandlers. A normal flow
    cannot be opened in multiple windows/tabs because information travels between
    pages with the session scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Data in a flow is scoped to that flow alone; therefore, flows can be opened
    in multiple windows/tabs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **nodes** define the entry and exit points of a flow and there are five
    types of nodes, which are listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This represents any JSF page in the application that participates
    in the flow. It is known as a **view node** of the flow.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The method call**: This indicates an invocation of a method using EL. The
    called method may return an outcome that indicates which node should be navigated
    next.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Switch**: The `switch` case statements are a substitute for long `if` statements.
    The cases are represented by EL expressions and are evaluated to Boolean values.
    Each case is accompanied by an outcome that will be used when the condition is
    evaluated to `true`. There is also a default outcome that will be used when all
    cases are evaluated to `false`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The flow call**: This is used to call another flow in the current flow—these
    are transition points between flows. The called flow (known as inner or nested
    flow) is nested in the flow that calls it (known as calling flow or outer flow).
    When the nested flow finishes its tasks, it will return a view node from the calling
    flow, which means that the calling flow will have control only after the nested
    flow''s lifespan comes to an end.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The flow return**: This can be used for returning an outcome to the calling
    flow.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows can pass parameters from one to the other. Parameters sent by a flow to
    another flow are known as **outbound parameters**, while parameters received by
    a flow from another flow are known as **inbound parameters**.
  prefs: []
  type: TYPE_NORMAL
- en: Well, at this point, you should have enough information about the flow scope
    to develop some examples. But, before doing this, you need to be aware of some
    tags, annotations, and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: The flow definition is based on a set of conventions over configuration. A flow
    has a name, a folder in the web root of the application reflecting the flow name,
    and a view representing the start node that also reflects the flow name. This
    folder groups the pages/views that belong to the same flow.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use a flow, you need to accomplish some configuration tasks. These
    can be done through a configuration file or programmatically. If you choose the
    first approach, then the configuration file can be limited to one flow, which
    means that it is stored in the flow folder and is named in the format *flowname*`-flow.xml`,
    or you can use the `faces-config.xml` file for having all flows in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our first example uses the configuration file, we need to use tags. The
    main tags used for configuring a flow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`< flow-definition>`: This tag contains an `id` attribute that uniquely identifies
    the flow. The value of this ID is the flow name used to reference the flow from
    JSF pages or beans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<view>`: It is nested in the `<flow-definition>` tag and indicates the JSF
    pages that represent the flow nodes; it associates an explicit ID to each page
    (Facelet) path (further, you can refer to each page by its ID). The page path
    is mapped in a `<vdl-document>` tag, nested in the `<view>` tag. The presence
    of this tag is optional, but as a convention, at least the `<view>` tag indicating
    the start node (start page) is present, especially if you want to set another
    start node besides the default one, which is represented by the page in the flow
    with the same name (ID) as the flow. Further, you can use the optional `<start-node>`*ID*`</start-node>`
    tag and indicate the ID of the `<view>` tag that maps the custom starting page.
    As an alternative, the start node of the flow can be indicated by setting the
    value of the `id` attribute of a `<view>` tag as the flow ID, and the content
    of the encapsulated `<vdl-document>` tag as the path of the custom starting page.
    When you refer to the flow ID, JSF will go to that page and automatically put
    you in the flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<flow-return>`: It is nested in the `<flow-definition>` tag and returns an
    outcome to the calling flow. You can refer to it through the value of the `id`
    attribute. There are at least three ways of getting out of a flow: using `<flow-return>`,
    using `<flow-call>` (presented later), or by abandoning the flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just said that a flow is identified by an ID (by a name). But, when the same
    flow name is defined in multiple documents (like in big projects that use multiple
    packaged flows from different vendors), there is one more ID needed. This ID is
    known as the **document ID**. Thus, when you need to identify a flow whose name
    appears in different documents, we need the flow ID and the defining document
    ID. Most of the time the document ID is omitted; therefore, it is not demonstrated
    in this section. In this section, you will see just a few hints about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define the simplest flow, you need to be aware of the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The flow scope](img/6466EN_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The simple flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With these three tags, `<start-node>` and/or `<view>`, `<flow-return>`, and
    `<from-outcome>`, you can configure a simple flow, like a peddling registration
    form. Let''s suppose that a tennis player registers online to a tournament through
    a flow made up of two JSF pages (the flow name will be `registration`): a page
    containing a form used for collecting data and a confirmation page. Moreover,
    there will be two pages outside the flow, one for entering into the flow (like
    the first page of the website), and one that is called after confirmation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see an image of our flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The simple flow](img/6466EN_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the code for the first page that is outside the flow
    and outside the registration folder (`index.xhtml`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important things can be observed here. First, the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first line returns a Boolean value indicating whether the current page is
    or is not in a flow. Obviously, the `index.xhtml` page is not in a flow; therefore,
    `false` will be returned. You can use it for tests. The second line displays the
    ID of the current flow.
  prefs: []
  type: TYPE_NORMAL
- en: Further, you need to take a look at the value of the attribute `action` of the
    `<h:commandButton>` tag. This value is the name (ID) of our flow; after the window
    context is enabled, JSF will search the indicated flow and navigate to the start
    node of the flow. By default, the window context is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when the button labeled **Start Registration** is clicked, the application
    steps in the registration flow and loads the start node page represented by the
    `registration.xhtml` page. The code for this page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since we are in the flow, `currentFlow` will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more important to focus on the implicit object, `flowScope`; however,
    as you know from [Chapter 1](ch01.html "Chapter 1. Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)"), *Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)*, the `flowScope` implicit object (which
    indicates the current flow) is used for sharing data through the entire flow and
    maps to `facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`.
    For example, the value of the `<h:inputText>` tag can be put into the `flowScope`
    object and can be read from the flow scope in the next page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The button labeled **Register To Tournament** navigates to the second page
    in the flow, `confirm.xhtml`; this is a usual navigation case, there is nothing
    to say here. But the other button navigates outside the flow (to `index.xhtml`)
    by indicating the ID of a flow return. In the configuration file, this flow return
    is as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of the `confirm.xhtml` page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This page displays the data that was entered and stored on the flow scope along
    with both the buttons. The first button navigates back to the `registration.xhtml`
    page, while the other one navigates to the `done.xhtml` page, which is outside
    the flow. The flow return is identified by the ID, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `done.xhtml` page just checks to see if the page is in flow and displays
    a simple message, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to define the flow in a configuration file. Since you have
    a single flow, you can create a file `registration-flow.xml` in the `registration`
    folder. The following is the code of the `registration-flow.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also place the following code inside the `faces-config.xml` file in
    the `<faces-flow-definition>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_7_1` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Flows with beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beside pages, a flow can contain beans. A bean defined in a flow is annotated
    with `@FlowScoped`; this is a CDI annotation that enables automatic activation
    (when the scope is entered) and passivation (when the scope is exited). The `@FlowScoped`
    bean requires an attribute named `value` that contains the flow ID. The data stored
    in such a bean is available in all pages that belong to that flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope bean might get passivated by the container and should be capable
    of passivity by implementing the `java.io.Serializable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a bean in the registration flow can modify the initial diagram, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flows with beans](img/6466EN_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the bean will store the data collected from the registration
    form in the flow scope (in the previous example, this data was passed using the
    `flowScope` implicit object). The button labeled **Register To Tournament** will
    call the `registrationAction` bean method, which will decide if the data is valid
    and return the flow back to the `registration.xhtml` page or next to the `confirm.xhtml`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `registration.xhtml` page''s code is modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of `RegistrationBean` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is self explanatory, but what about the `getReturnValue` method? Well,
    this is just an example of how a flow scoped bean can indicate the outcome of
    a flow return. Instead of using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_7_2` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Nested flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, now let's complicate things by adding another flow under the existing
    one. Let's suppose that after the registration, the player has to indicate the
    day and the hour when he is available to play the first match. This can be accomplished
    in a new flow named `schedule`. The `registration` flow will call the `schedule`
    flow and will pass some parameters to it. The `schedule` flow will return in the
    `registration` flow, which will provide a simple button for navigation outside
    the `registration` flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nested flow returns only in the calling flow. You have to refer to a page
    of the calling flow in the `<flow-return>` tag of the nested flow, including the
    pages returned by the calling flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing parameters is a thing that requires more tags in the configuration
    tag. Therefore, you need to know the following tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<flow-call>`: This calls another flow in the current flow. This tag requires
    the `id` attribute. The value of this attribute will be used to refer to this
    flow call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<flow-reference>`: This is nested in the `<flow-call>` tag and contains the
    ID of the flow that must be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<outbound-parameter>`: This is nested in the `<flow-call>` tag and defines
    parameters that must be passed to the called flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<inbound-parameter>`: This defines the parameters passed from another flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to see these tags at work, you need to take a look at the application
    flow. The diagram of the application will change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested flows](img/6466EN_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We resume our discussion from the `confirm.xhtml` page (defined in the `registration`
    flow). From this page, we want to navigate to the `schedule.xhtml` page, which
    is available in the `schedule` flow (the `schedule` folder). For this, we can
    add a new button, labeled **Schedule**, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The button''s `action` attribute value is the ID of the `<flow-call>` tag.
    When the button is clicked, JSF locates the corresponding `<flow-call>` tag and
    follows the flow with the ID indicated by the `<flow-id>` tag, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we want to pass several parameters from the `registration` flow to
    the `schedule` flow: the player name and surname (stored in the flow scoped `RegistrationBean`
    bean) and a constant representing some registration code (it can also be generated
    based on certain rules). This can be accomplished by the `<outbound-parameter>`
    tag, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `schedule.xhtml` page displays a hello message based on the received parameters
    and a form that allows to the player to enter the day and hour when he is available
    for playing the first match, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the name and surname are obtained from the flow scope using the
    `flowScope` object, while the registration code is obtained from the flow scoped
    `ScheduleBean`; this bean stores the day, hour (received from the player), and
    registration code (received from the `registration` flow). Each piece of information
    received from the registration bean was guided to the place of storage using the
    `<inbound-parameter>` tag in the `schedule-flow.xml` file, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the day and hour are inserted, the button labeled **Save** should save
    the data and navigate to the `success.xhtml` page, which is a simple page that
    displays all data provided by the player. From this page, we can return to the
    calling flow, `registration`, via a simple button labeled **Exit Registration**,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome, `taskFlowReturnThanks`, is defined in the `schedule-flow.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `thanks.xhtml` page is just a final step before the user exists from the
    `registration` flow, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to jump over the `thanks.xhtml` page, directly outside of both
    flows, then you can define the flow return, `taskFlowReturnThanks`, to point out
    the `done.xhtml` page, which is returned by the calling flow via the `taskFlowReturnDone`
    flow return. Therefore, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_7_3` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flows can be configured declaratively or programmatically using the JSF 2.2
    `FlowBuilder` API.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring flows programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all the previous examples, you saw how to configure a flow using the declarative
    approach. But, flows can be configured programmatically also. The steps for configuring
    a flow programmatically are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class and name it as the flow. This is more like a convention, not
    a requirement!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this class, write a method as shown in the following code; the `@FlowDefinition`
    annotation is a class-level annotation that allows the flow definition to be defined
    using the `FlowBuilder` API. The name of this method can be any valid name, but
    `defineFlow` is like a convention. So, the name `defineFlow` is not mandatory,
    and you can even define more flows in the same class as long as you have annotated
    them correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `FlowBuilder` API to configure the flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the `FlowBuilder` API is pretty straightforward and intuitive. For example,
    you can write the `registration-flow.xml` file programmatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, for each tag used in the declarative approach, there is a corresponding
    method in the `FlowBuilder` API. For example, the `flowBuilder.id` method accepts
    two arguments: the first one represents the document ID (usually, an empty space),
    and the second one represents the flow ID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `schedule-flow.xml` file can be programmatically translated as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called when the application
    enters into the current flow and the flow scoped bean is instantiated, while subsequent
    requests will use this instance until the flow is dumped. This is repeated if
    the application enters in this flow again. So, initializations specific to the
    current flow can be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch3_7_5` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative and programmatic configurations can be mixed in the same application.
    For example, check the application named `ch3_7_4`, which uses programmatic configuration
    for the `registration` flow and declarative configuration for the `schedule` flow.
  prefs: []
  type: TYPE_NORMAL
- en: Flows and navigation cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigation cases can be used for navigating inside flows. At this moment, when
    you click on the button labeled **Register To Tournament**, the flow goes in the
    `confirm.xhtml` page based on implicit navigation. But we can easily exemplify
    an explicit navigation in the flow by replacing the value of the `action` attribute
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `confirm_outcome` cannot be automatically fetched to the `confirm.xhtml`
    page; therefore, in the `registration-flow.xml` file, we can add an explicit navigation
    case, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to use a navigation case to enter in a flow, you will have to
    specify the `<to-flow-document-id>`*document_ID*`</to-flow-document-id>` statement
    nested in the `<navigation-case>` tag. If there is no document ID, that uses `<to-flow-document-id/>`.
    Moreover a `<h:button>` (or `<h:link>`) can be used to enter in such a flow, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you choose to write a programmatic navigation case, then JSF 2.2 comes with
    a method named, `getToFlowDocumentId`, which should be overridden for indicating
    the document ID.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, everything comes to normal. Therefore, we can use explicit navigation
    cases for navigation between the flow's pages. The complete application is named
    `ch3_11_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish the same thing in a programmatic fashion, you need to
    use the `NavigationCaseBuilder` API, as shown in the following code; this is the
    same navigation case, so we have used only the needed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped in the complete application named `ch3_11_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can even use a custom navigation handler. The new `NavigationHandlerWrapper`
    class (added in JSF 2.2) provides a simple implementation of the `NavigationHandler`
    class. Therefore, we can easily extend it to prove a navigation case using a custom
    navigation handler, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a quick configuration in the `faces-config.xml` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the flow has a document ID, you need to override the `handleNavigation(FacesContext
    context, String fromAction, String outcome, String toFlowDocumentId)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch3_11_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting flow navigation cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whatever approach you choose for using navigation cases inside flows, you can
    always inspect them via the `ConfigurableNavigationHandler.inspectFlow` method.
    This method is invoked by the flow system to cause the flow to be inspected for
    navigation rules. You can easily override it to obtain information about navigation
    cases, by writing a custom configurable navigation handler. The easiest way to
    accomplish this is to extend the new `ConfigurableNavigationHandlerWrapper` class
    (introduced in JSF 2.2), which represents a simple implementation of `ConfigurableNavigationHandler`.
    For example, the following snippet of code sends in log information about each
    found navigation case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you attach this custom configurable navigation handler to one of the preceding
    three examples, then you will get information about the presented navigation case.
    The complete example is named `ch3_15`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the initializer and finalizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using the `FlowBuilder` API, we can attach callback methods that will be
    automatically called when a flow is created and right before it is destroyed.
    The `FlowBuilder.initializer` method has the following signatures, which are called
    when the flow is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FlowBuilder.finalizer` signature is called before the flow is destroyed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the `initializer` method can be used to pass external parameters
    into a flow. Let''s suppose that in the `index.xhtml` page (outside the flow),
    when we click on the button labeled **Start Registration**, we want to pass the
    tournament name and place into the flow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'These two parameters must be available when the flow starts, because the wrapped
    information is displayed in the `registration.xhml` page (the start node of the
    flow) via two properties from `RegistrationBean`, namely `tournamentName` and
    `tournamentPlace`. For this, we need to call a method from `RegistrationBean`
    capable of extracting this information and store it in these two properties, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the interesting part, because we can use the `initializer` method to
    indicate the `tournamentInitialize` method as the callback method that should
    be invoked when the flow is created. This can be done in the `registration-flow.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: So, at this moment, we can use the tournament name and place right from the
    beginning of the flow and during the flow's lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, another simple scenario can be the justification for using a
    `finalizer` method. Let''s suppose that we count the registered players via an
    application scoped bean named `PlayersCounterBean`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count` variable should be increased when the player exits the flow, and
    the registration is successfully done; therefore, we can place a `finalizer` method
    in the `registration-flow.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tournamentFinalize` method is implemented in `RegistrationBean`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since the `PlayersCounterBean` is an application bean, we can use its goodies
    outside the flow. The complete application is named `ch3_12_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same output can be programmatically achieved using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of variation, in this case we didn''t extract the parameter values
    using the request parameter `Map`. We preferred to use the implicit object `param`
    and to pass the values as arguments of the `tournamentInitialize` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch3_12_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the flow switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` case statements are a substitute for long `if` statements and
    are useful to do conditional outcome mapping. In order to see it at work, we can
    suppose that for each tournament we have a separate `confirm.xhtml` page. Let''s
    have the four grand slams in tennis and the associated XHTML confirmation pages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Roland Garros and `confirm_rg.xhtml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wimbledon and `confirm_wb.xhtml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: US Open and `confirm_us.xhtml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Australian Open and `confirm_ao.xhtml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name and place of the tournament are passed in the flow via a simple form
    (one form per tournament), as follows (you already know from the preceding section
    how this information may be obtained inside the flow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after clicking on the button labeled **Register To...**, we need to choose
    the right confirmation page. For this, we can use a programmatic switch, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when no condition is evaluated to `true`, the selected node will
    be the `notournament.xhtml` page, which represents the default outcome. This is
    just a simple XHMTL page containing some specific text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete application is named `ch3_13`. Declaratively, this can be achieved
    in the `registration-flow.xml` file as shown in the following code. You can use
    `<view>` tags to hide the outcome''s path behind some IDs (map outcomes to pages),
    as we saw in the programmatic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: So, switch can be useful when you don't want to map each outcome to a single
    page.
  prefs: []
  type: TYPE_NORMAL
- en: This example wasn't wrapped in a complete application.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flows act as logical units of work; therefore, they are portable across multiple
    applications. The portability is obtained by packaging the flow artifacts in a
    JAR file. Further, the JAR file can be added in any application `CLASSPATH` and
    the flow is ready to be used. To package a flow, you need to follow some conventions,
    which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly define the flows in the `faces-config.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JAR root, create a `META-INF` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `faces-config.xml` file in this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `beans.xml` file in this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same folder, `META-INF`, create a subfolder named `flows`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `flows` folder, add all nodes (pages) of the flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JAR root, outside the `META-INF` folder, add all the Java code (classes)
    needed by the flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the preceding steps, the flow described in the *Flows with beans*
    section can be packaged in a JAR file named `registration.jar`, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging flows](img/6466EN_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application that uses this JAR file is named `ch3_14`.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic flow scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programmatically speaking, the flow scope can be accessed via the `javax.faces.flow.FlowHandler`
    class. After obtaining a `FlowHandler` class''s object, you can easily access
    the current flow, add a new flow, and manipulate the flow map represented by `#{flowScope}`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the `FlowHandler` class is the most important class involved in
    the interaction between runtime and the faces flow feature. This is an abstract
    class that can be extended to provide a custom flow handler implementation. In
    order to do that, you can start by creating a new `FlowHandlerFactory` class,
    which is used by the `Application` class to create the singleton instance of the
    `FlowHandler` class. This class has a simple implementation named `FlowHandlerFactoryWrapper`,
    which can be easily extended to return a custom flow handler, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This factory should be configured in the `faces-config.xml` file, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, the `CustomFlowHandler` class represents an extension of the `FlowHandler`
    class. Since the `FlowHandler` class is an abstract class, you need to provide
    an implementation for each of its methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you know from the previous sections that the `registration` flow
    passed several outbound parameters to the nested `schedule` flow. You saw how
    to accomplish that declaratively, in the `registration-flow.xml` file, and programmatically,
    via the `FlowBuilder` API, in the `Registration` class. You can do the same thing
    from a custom flow handler in the method named, `transition`, which is capable
    to perform a transition between a source flow (for example, `registration`) and
    a target flow (for example, `schedule`). When the `registration` flow calls the
    `schedule` flow, you can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The target inbound parameters can be accessed as follows (the `Map` parameter
    cannot be altered):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Flow parameters are represented by the `javax.faces.flow.Parameter` abstract
    class. The `CustomParameter` class provides an implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Dependent pseudo-scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default scope of a CDI bean (`@Named`) when nothing is specified.
    In this case, an object exists to serve exactly one bean and has the same life
    cycle as that bean; an instance of a dependent scoped bean is not shared between
    different users or different points of injection. It can also be explicitly specified
    by annotating the bean with the `@Dependent` annotation and importing `javax.enterprise.context.Dependent`.
    This scope is available only in CDI and is the only **non-contextual** scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All CDI scopes, except this one, are known as **normal** scopes. More details
    about normal scopes versus pseudo-scopes can be found in the *Normal scopes and
    pseudo-scopes* section at [http://docs.jboss.org/cdi/spec/1.0/html/contexts.html](http://docs.jboss.org/cdi/spec/1.0/html/contexts.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put the `PlayersBean` in the dependent scope, then the current extracted
    player and the list of randomly extracted players (which will be empty or will
    contain this player) is available only inside the bean, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called for each request. Actually,
    it might be called multiple times during the same request, if the bean is used
    in several EL expressions. Initially, there is one instance of the bean, and this
    instance is reused if the bean EL name appears multiple times in the EL expression,
    but is not reused in the case of another EL expression or in the case of a re-evaluation
    of the same EL expression.
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch3_5` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The none scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **none scoped** beans lives to serve other beans.
  prefs: []
  type: TYPE_NORMAL
- en: The none scope seems to be the black sheep of JSF scopes. Even its name doesn't
    inspire something useful. Practically, a managed bean in this scope lives as long
    as a single EL expression evaluation and is not visible in any JSF page. If the
    application scope lives the longest, this scope lives the shortest. But, if you
    inject the none scoped managed beans in other managed beans, then they will live
    as long as their hosts. Actually, this is their job, to serve other beans.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The none scoped objects used in the configuration file indicate managed beans
    that are used by other managed beans in the application.
  prefs: []
  type: TYPE_NORMAL
- en: So, whenever you need a humble managed bean that is ready to be a part of a
    cool scope, such as a request or a session, you can annotate it with `@NoneScoped`,
    available in the `javax.faces.bean` package. Moreover, objects with the none scope
    can use other objects with the none scope.
  prefs: []
  type: TYPE_NORMAL
- en: The custom scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When none of the previous scopes meet your application needs, you have to pay
    attention to the JSF 2 custom scope. Most likely, you will never want to write
    a custom scope, but if it is necessary, then, in this section, you can see how
    to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The custom scope annotation is `@CustomScoped` and is defined in the `javax.faces.bean`
    package. It is not available in CDI!
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement a custom scope, let's suppose that you want to control
    the life cycle of several beans that live in the application scope. Normally they
    live as long as the application lives, but you want to be able to add/remove them
    from the application scope at certain moments of the application flow. Of course,
    there are many approaches to do that, but remember that we look for a reason to
    implement a custom scope; therefore, we will try to write a custom scope nested
    in the application scope that will allow us to add/remove a batch of beans. Creating
    and destroying the scope itself will be reflected in creating and destroying the
    beans, which means that you don't need to refer to each bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, since this is just a demo, we will use only two beans: one will stay
    in the classical application scope (it can be useful for comparison of the application
    and custom scope lifespan), while the other one will be added/destroyed through
    the custom scope. The application purpose is not relevant; you should focus on
    the technique used to write a custom scope and paper over the assumptions and
    gaps. Think more on the lines that you can use this knowledge when you really
    need to implement a custom scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the custom scope class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The custom scope is represented by a class that extends the `ConcurrentHashMap<String,
    Object>` class. We need to allow concurrent access to an usual map because the
    exposed data may be accessed concurrently from multiple browsers. The code of
    the `CustomScope` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When our scope is created/destroyed, other components will be informed through
    events. In the `scopeCreated` method, you register `PostConstructCustomScopeEvent`,
    while in the `scopeDestroyed` method, you register `PreDestroyCustomScopeEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a custom scope, it is time to see how to declare a bean in this
    scope. Well, this is not hard and can be done with the `@CustomScoped` annotations
    and an EL expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Resolving a custom scope EL expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, JSF will iterate over the chain of existing resolvers in order
    to resolve the custom scope EL expression. Obviously, this attempt will end with
    an error, since no existing resolver will be able to satisfy this EL expression.
    So, you need to write a custom resolver as you saw in [Chapter 1](ch01.html "Chapter 1. Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)"), *Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)*. Based on
    that, you should obtain something as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to put the following resolver into the chain by adding it in
    the `faces-config.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Done! So far, you have created a custom scope, you put a bean into this scope,
    and learned that the brand new resolver provides access to this bean.
  prefs: []
  type: TYPE_NORMAL
- en: The custom scope must be stored somewhere, so nested in the application scope
    can be a choice (of course, other scopes can also be a choice, depending on your
    needs). When the scope is created, it has to be placed in the application map,
    and when it is destroyed, it has to be removed from the application map. The question
    is when to create it and when to destroy it? And the answer is, *it depends*.
    Most likely, this is a decision strongly tied to the application flow.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the custom scope lifespan with action listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using action listeners can be a good practice even if it involves control from
    view declaration. Let''s suppose that the button labeled **START** will add the
    custom scope in the application map, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `CreateCustomScope` class is a straightforward action listener
    as it implements the `ActionListener` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same approach, the button labeled **STOP** will remove the custom
    scope from the application map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `DestroyCustomScope` class is the action listener as it implements
    the `ActionListener` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_8` that is available
    in the code bundle of this chapter. Just a run and a quick look over the code
    will clarify that the spaghetti-code is missing here.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the custom scope lifespan with the navigation handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach is to control the custom scope lifespan based on the page''s
    navigation. This solution is more flexible and is hidden from the user. You can
    write a custom navigation handler by extending `NavigationHandler`. The next implementation
    puts the custom scope in the application map when the navigation reaches the page
    named `sponsored.xhtml`, and will remove it from the application map in any other
    navigation case. The code of the `CustomScopeNavigationHandler` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to register the following navigation handler in the `faces-config.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_9` that is available
    in the code bundle of this chapter. A quick look over the code will clarify that
    the spaghetti-code is missing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said earlier, JSF 2.2 comes with a wrapper class for `NavigationHandler`.
    This is a simple implementation that can be easily extended by developers. An
    instance of the class being wrapped is returned in the `getWrapped` method. For
    example, you can rewrite the `CustomScopeNavigationHandler` class, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This example is wrapped into the application named `ch3_10` that is available
    in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Managed bean instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, a managed bean is instantiated at first reference to it (a request,
    for example)—this is known as **lazy instantiation**. You can alter the default
    behavior by adding the `eager` attribute and set its value to `true`. This will
    instantiate the managed bean when the application starts, before any request is
    made. But, it is important to know that this works only for application scoped
    beans and the eager instantiated bean is placed in the application scope, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Beans injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, solutions depend on the concrete functional requirements, but finding
    the right solutions is what makes the difference between developers. Sometimes,
    developers get stuck or make mistakes when they work with objects in a scope that
    uses objects from another scope. From the following figure, you can seek some
    guidance for dealing with some of the most popular cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Beans injection](img/6466EN_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are some restrictions. As a general rule in JSF, don't
    use objects that have shorter lifespan than the objects you are calling it from.
    In other words, use objects whose lifespan is the same as, or longer than, the
    object being injected into. Breaking this rule will end up in a JSF exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic behind this rule can be explained through the two most common mistakes,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use request objects in session objects**: This is a bad thing, because we
    will have lots of requests (lots of instances) and only one session (one instance).
    Usually, requests belong to all users, while a session is one per user; therefore,
    it is unclear request object is injected? To be more clear, lots of requests means
    lots of associated beans, while a session means one bean. Now, it is illogical
    to inject one particular instance and skip all others. Moreover, how and when
    will you fetch the correct instance, since the request objects are transient,
    and usually, have a short lifespan! Even if you find a plausible use case, JSF
    will not allow you to do this via JSF managed beans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use session objects in application objects**: The same logic can be applied
    further when we want to use session objects in application objects. Sessions are
    many as users, but the application is only one; therefore, you cannot inject all
    sessions in the application ... it is useless! Of course, you may want to fetch
    a certain session to the application, but you have to be sure that the pointed
    session exists; this is not a problem if you are interested in the session of
    the current user, but it may be an issue if you are interested in sessions of
    other users. Moreover, if there are many sessions, you have to correctly identify
    the desired session. Even if you find a plausible use case, JSF will not allow
    you to do this via JSF managed beans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, for CDI, these cases are not such a big issue. When you are using
    an object that has a shorter lifespan than the object you are calling it from
    (for example, injecting a request scoped bean into a session scoped bean), CDI
    classifies the use case as a mismatched injection and fixes the issue via CDI
    proxies. For each request, the CDI proxy re-establishes the connection to a live
    instance of the request scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when we follow the written rules, we are still vulnerable to the unwritten
    rules. One of the unwritten rules that can cause undesirable results is named
    **overuse** or **abuse**. The following are some cases to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: Overusing a view scoped bean for request scoped data may affect memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing a request scoped bean for view scoped data may cause forms with unexpected
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing an application scoped bean for request/view/session scoped data may
    cause an undesirably wide visibility of data across users and will affect memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing a session scoped bean for request/view data may cause an undesirably
    wide visibility of data across multiple browser windows/tabs in that session.
    As you know, view data are specific to a single browser window/tab, which allows
    us to open multiple tabs and keeps the data integrity while switching between
    tabs. On the other hand, if this data was exposed via the session scope, then
    the modifications in one window/tab will be reflected in the browser session;
    therefore, switching between tabs will lead to an apparently strange behavior,
    known as inconsistency of data. In case of using the session scope for request/view
    data, will also affect memory, since request/view scopes are meant to have a shorter
    lifespan than session scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with JSF 2.0, managed beans can be injected (dependency injection)
    into the property of another managed bean using the `@ManagedProperty` annotation.
    You already know that from the previous chapter, where an example is provided.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to inject beans is to use the `@Inject` annotation, which is part
    of the CDI powerful injection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: So when do we use `@ManagedProperty` and when do we use `@Inject` ? Well, we
    know that both of them do the same thing in different ways and different containers,
    so maybe it is a good idea to use `@ManagedProperty` when you are working in a
    servlet container or just don't need CDI. Another good argument for `@ManagedProperty`
    is that you can use EL with it. But, if you are in a proper CDI environment where
    you can exploit CDI benefits, such as proxy scope leak prevention or better deploy-time
    dependency, then use CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pacifist approach will combine these two in the same application. In this
    case, you have two options: to avoid any interaction between the managed beans
    and CDI beans or, obviously, to encourage the interaction between them for better
    performance. If you choose the second option, then it is important to keep in
    mind some simple rules of injection as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Beans injection](img/6466EN_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have browsed through an overview of JSF/CDI scopes. It begins
    with an open discussion about JSF scopes versus CDI scopes, meant to provide a
    few advantages/disadvantages of choosing either one (or both). After a short overview
    of JSF/CDI scopes, each scope was detailed by covering fundamental knowledge,
    such as definition, usability, functionality, restrictions, and examples.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter ends with a bunch of thoughts regarding beans injections. You can
    find several rules, tips, and bad practices commonly used in JSF applications
    mentioned out here.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next two chapters, where we will cover many kinds of JSF artifacts
    and configuration stuff.
  prefs: []
  type: TYPE_NORMAL
