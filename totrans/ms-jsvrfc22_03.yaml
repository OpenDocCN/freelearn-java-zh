- en: Chapter 3. JSF Scopes – Lifespan and Use in Managed Beans Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. JSF作用域 – 在管理Bean通信中的生命周期和使用
- en: If programming is an art, then working correctly with scopes is a part of it!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程是一种艺术，那么正确地使用作用域就是其中的一部分！
- en: This affirmation is generally true, not just in JSF. Should I use the session
    scope now, or the request scope? Do I have too many session beans? Can I inject
    this scope into that scope? Is this session object too big? How many times have
    you asked yourself these kinds of questions? I know ... many times! Maybe in this
    chapter you will find answers to some of these questions and you will fortify
    your knowledge about working with JSF scopes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言通常是正确的，不仅适用于JSF。我现在应该使用会话作用域，还是请求作用域？我是否有太多的会话Bean？我能将这个作用域注入到那个作用域中吗？这个会话对象是否太大？你问过自己这类问题有多少次了？我知道……很多次！也许在这一章中，你将找到一些问题的答案，并加强你对使用JSF作用域的知识。
- en: 'We have a lot to accomplish; therefore, let''s have a short overview of what
    you will see in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多事情要做；因此，让我们简要概述一下你将在本章中看到的内容：
- en: JSF scopes versus CDI scopes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF作用域与CDI作用域
- en: Request scope, session scope, view scope, application scope, conversation scope,
    flow scope, none scope, dependent scope, and custom scope
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求作用域、会话作用域、视图作用域、应用作用域、会话作用域、流程作用域、无作用域、依赖作用域和自定义作用域
- en: Beans injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean注入
- en: JSF scopes versus CDI scopes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF作用域与CDI作用域
- en: 'Even a JSF beginner might have heard about JSF managed beans (regular JavaBeans
    classes managed by JSF) and CDI beans (regular JavaBeans classes managed by CDI),
    and knows that JSF supports JSF scopes and CDI scopes. Starting with Java EE 6,
    CDI is recognized as the managed bean framework, besides EJBs. This causes confusion
    among programmers, because EJBs, CDIs, and JSF managed beans raise a critical
    question: which one to use and when?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是JSF初学者也可能听说过JSF管理Bean（由JSF管理的常规JavaBean类）和CDI Bean（由CDI管理的常规JavaBean类），并且知道JSF支持JSF作用域和CDI作用域。从Java
    EE 6开始，CDI被认可为管理Bean框架，除了EJBs之外。这导致程序员之间产生混淆，因为EJBs、CDIs和JSF管理Bean提出了一个关键问题：何时使用哪一个？
- en: Focusing on JSF, the unanimous answer is that CDI beans are more powerful than
    JSF beans. But, when you know right from the start that CDI will not be a part
    of your application or you are running the application inside a servlet container
    (which does not have CDI support by default, like Apache Tomcat), then JSF beans
    is the right choice. In other words, when you need a simple way to define beans
    and a neat mechanism for a dependency injection, then JSF bean will do the job,
    but when you need heavy artillery, such as events, type safe injection, automatic
    injection, producer methods, and interceptors, then CDI will represent the complete
    solution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于JSF，普遍的答案是CDI Bean比JSF Bean更强大。但是，当你从一开始就知道CDI不会成为你应用程序的一部分，或者你在一个没有默认CDI支持的服务器容器（如Apache
    Tomcat）中运行应用程序时，那么JSF Bean就是正确的选择。换句话说，当你需要一个简单的方式来定义Bean和一个整洁的依赖注入机制时，JSF Bean可以完成这项工作，但是当你需要重型武器，如事件、类型安全注入、自动注入、生产者方法和拦截器时，CDI将代表完整的解决方案。
- en: 'Moreover, NetBeans IDE 8.0 warns us that the JSF bean''s annotations will be
    deprecated in the next JSF version, while the CDI beans are recommended instead
    (as shown in the following screenshot). This warning and the new JSF 2.2 flow
    scope, introduced as a dependency on CDI, are powerful signals that JSF and CDI
    become closer and closer:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NetBeans IDE 8.0警告我们，在下一个JSF版本中，JSF Bean的注解将被弃用，而CDI Bean被推荐使用（如以下截图所示）。这个警告和作为CDI依赖项引入的新JSF
    2.2流程作用域，是JSF和CDI越来越接近的强大信号：
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![JSF作用域与CDI作用域](img/6466EN_03_01.jpg)'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CDI beans are much powerful than JSF beans; therefore, use CDI beans whenever
    possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CDI Bean比JSF Bean更强大；因此，尽可能使用CDI Bean。
- en: So, strong arguments indicate CDI is often the right choice, but there are still
    instances where it is effective to use JSF beans, as you will soon discover.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，强有力的论据表明CDI通常是正确的选择，但仍然有一些情况下使用JSF Bean是有效的，正如你很快就会发现的。
- en: JSF bean's main annotations (such as `@ManagedBean` and scopes annotations)
    are defined in the package `javax.faces.bean`, while CDI's main annotations are
    defined in the `javax.inject` (such as, `@Named`) and `javax.enterprise.context`
    (such as, scopes) packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSF Bean的主要注解（如`@ManagedBean`和作用域注解）定义在`javax.faces.bean`包中，而CDI的主要注解定义在`javax.inject`（如`@Named`）和`javax.enterprise.context`（如作用域）包中。
- en: A JSF managed bean is annotated with `@ManagedBean`, which allows us to inject
    it in to another bean (not CDI beans!) and to access the bean properties and methods
    from JSF pages using EL expressions. A CDI bean is annotated with `@Named`, which
    provides an EL name to be used in view technologies, such as JSP or Facelets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JSF管理bean使用`@ManagedBean`注解，这允许我们将它注入到另一个bean（不是CDI bean！）中，并使用EL表达式从JSF页面访问bean属性和方法。CDI
    bean使用`@Named`注解，这为视图技术（如JSP或Facelets）提供了一个EL名称。
- en: 'Typically, a JSF bean is declared as shown in the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JSF bean的声明如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The JSF bean, `@ManagedBean`, supports an optional parameter, `name`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSF bean的`@ManagedBean`支持一个可选参数`name`。提供的名称可以用于以下方式从JSF页面引用bean：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A CDI bean has the same shape, with different annotations, as shown in the
    following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean具有相同的形状，但具有不同的注解，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The CDI bean, `@Named`, supports an optional parameter, `value`. The provided
    name can be used to reference the bean from JSF pages in the following manner:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的`@Named`注解支持一个可选参数`value`。提供的名称可以用于以下方式从JSF页面引用bean：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that CDI annotations cannot be mixed with JSF annotations in the same
    bean, only in the same application. For example, you cannot define a bean using
    `@ManagedBean` and a CDI scope (or any other combination between them), but you
    can have, in the same application, a managed bean (or more) and a CDI bean (or
    more).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CDI注解不能与JSF注解在同一个bean中混合，只能在同一个应用程序中。例如，您不能使用`@ManagedBean`和CDI作用域（或它们之间的任何其他组合）来定义一个bean，但您可以在同一个应用程序中有一个管理bean（或更多）和一个CDI
    bean（或更多）。
- en: 'In the following figure, you can see a short overview of JSF 2.2 scopes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您可以看到JSF 2.2作用域的简要概述：
- en: '![JSF scopes versus CDI scopes](img/6466EN_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![JSF作用域与CDI作用域](img/6466EN_03_02.jpg)'
- en: In the next section, you will see how each JSF/CDI scope works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到每个JSF/CDI作用域是如何工作的。
- en: The request scope
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求作用域
- en: The **request scope** is bound to the HTTP request-response life cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求作用域**绑定到HTTP请求-响应生命周期。'
- en: The request scope is very useful in any web application, and an object defined
    in the request scope usually has a short lifespan; beans live as long as the HTTP
    request-response lives. When the container accepts an HTTP request from the client,
    the specified object is attached to the request scope and it is released when
    the container has finished transmitting the response to that request. A new HTTP
    request always comes in a new request scope object. In short, a request scope
    represents a user's interaction with a web application in a single HTTP request.
    Commonly, a request scope is useful for simple GET requests that expose some data
    to the user without requiring to store the data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在任何Web应用程序中都非常有用，定义在请求作用域中的对象通常具有较短的生存期；bean的生存期与HTTP请求-响应相同。当容器从客户端接受HTTP请求时，指定的对象附加到请求作用域，并在容器完成向该请求发送响应后释放。每个新的HTTP请求都会带来一个新的请求作用域对象。简而言之，请求作用域代表用户在单个HTTP请求中与Web应用程序的交互。通常，请求作用域对于简单的GET请求很有用，这些请求向用户公开一些数据，而无需存储数据。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope is present in JSF and CDI and functions in the same way. It
    can be used for nonrich AJAX and non-AJAX requests. For JSF managed beans (`@ManagedBean`),
    this is the default scope, when none is specified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域存在于JSF和CDI中，并且以相同的方式工作。它可以用于非富AJAX和非AJAX请求。对于JSF管理bean（`@ManagedBean`），这是默认的作用域，如果没有指定。
- en: For example, let's suppose that we have a predefined list of tennis players,
    and we randomly extract them one-by-one from this list and store them in another
    list. The current generated player and the list of extracted players are managed
    bean's properties and their values are rendered in a JSF page.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个预定义的网球运动员列表，并且我们从这个列表中随机提取他们，并将他们存储在另一个列表中。当前生成的球员和提取的球员列表是管理bean的属性，它们的值在JSF页面中显示。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope annotation is `@RequestScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域注解是`@RequestScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'The code for the CDI bean can be written as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的代码可以写成如下：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The relevant part of the JSF page is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JSF页面的相关部分如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you click on the button labeled **Get Players With Page Forward** or **Get
    Players In Same View**, you will see something as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击标记为**使用页面前进获取玩家**或**获取同一视图中的玩家**的按钮时，您将看到以下截图所示的内容：
- en: '![The request scope](img/6466EN_03_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![请求作用域](img/6466EN_03_03.jpg)'
- en: Since a request scope lives as long as the HTTP request-response lives and page
    forward implies a single HTTP request-response, you will see the player extracted
    at the current request and the list of extracted players, which will always only
    contain this player. The list is created for each request and filled with the
    current player, which makes the list useless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求作用域的生命周期与HTTP请求-响应的生命周期相同，而页面前进意味着一个单独的HTTP请求-响应，因此您将看到在当前请求中提取的播放器和提取的播放器列表，该列表将始终只包含此播放器。列表为每个请求创建，并用当前播放器填充，这使得列表变得无用。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The request scope doesn't lose the object's state while forwarding, because
    the source page and the destination page (the forwarded page) are part of the
    same request-response cycle. This is not true in the case of redirect actions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在转发时不会丢失对象的状态，因为源页面和目标页面（转发页面）是同一请求-响应周期的一部分。这并不适用于重定向操作。
- en: 'When you click on the button labeled **Get Players With Page Redirect**, you
    will see something as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击标记为**使用页面重定向获取玩家**的按钮时，您将看到以下截图所示的内容：
- en: '![The request scope](img/6466EN_03_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![请求作用域](img/6466EN_03_04.jpg)'
- en: The current extracted player and the list content is not available in this case,
    because a JSF redirect implies two requests, instead of one as in the forward
    case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当前提取的玩家和列表内容不可用，因为JSF重定向意味着两个请求，而不是像前进情况那样只有一个。
- en: 'Programmatically, you can access the request map using the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码以编程方式访问请求映射：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Submitting a form defined in page 1 to page 2 via a bean, and then you have
    the following cases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将页面1中定义的表单通过豆提交到页面2，然后您有以下情况：
- en: If the same view or forward is used, then the data is available for display
    on page 2
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用相同的视图或前进，则数据将在页面2上可用以显示
- en: If redirect is used, then data will be lost and not available for display on
    page 2
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用重定向，则数据将丢失，无法在页面2上显示
- en: 'The JSF version of the CDI beans is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CDI豆的JSF版本如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And it works the same as the CDI bean!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它与CDI豆的功能相同！
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called for each request, since
    each request requires a separate instance of the request scoped bean.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将为每个请求调用，因为每个请求都需要请求作用域的独立实例。
- en: The case of the CDI bean is wrapped into the application named `ch3_1_1`, while
    the case of the JSF bean is wrapped into application named `ch3_1_2`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CDI豆的情况被封装在名为`ch3_1_1`的应用程序中，而JSF豆的情况被封装在名为`ch3_1_2`的应用程序中。
- en: The session scope
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话作用域
- en: The **session scope** lives across multiple HTTP request-response cycles (theoretical
    unlimited).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话作用域**跨越多个HTTP请求-响应周期（理论上无限）。'
- en: The request scope is very useful in any web application when you need a single
    interaction per HTTP request-response cycle. However, when you need objects visible
    for any HTTP request-response cycle that belongs to a user session, then you need
    a session scope; in this case, the bean lives as long as the HTTP session lives.
    The session scope allows you to create and bind objects to a session. It gets
    created upon the first HTTP request involving this bean in the session and gets
    destroyed when the HTTP session is invalidated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域在任何需要每个HTTP请求-响应周期中只有一个交互的Web应用程序中非常有用。然而，当您需要用户会话中属于任何HTTP请求-响应周期的可见对象时，则需要会话作用域；在这种情况下，该豆的生命周期与HTTP会话的生命周期相同。会话作用域允许您创建并将对象绑定到会话。它会在会话中涉及此豆的第一个HTTP请求时创建，并在HTTP会话无效时销毁。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session scope is present in JSF and CDI and it functions the same way in
    both. Commonly, it is used for AJAX and non-AJAX requests that process user-specific
    data (such as credentials, shopping carts, and so on).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域存在于JSF和CDI中，并且在两者中功能相同。通常，它用于处理用户特定数据（如凭证、购物车等）的AJAX和非AJAX请求。
- en: Therefore, the first HTTP request initializes the session and stores the objects,
    while the subsequent requests have access to these objects for further tasks.
    A session invalidation occurs when the browser is closed, a timeout is fired,
    the logout is clicked, or a programmatic subroutine forces it. Normally, each
    time you need to preserve data across the whole session (multiple requests and
    pages), the session scope is the right choice.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个HTTP请求初始化会话并存储对象，而后续请求可以访问这些对象以执行进一步的任务。当浏览器关闭、超时触发、点击注销或程序性子例程强制执行时发生会话失效。通常，每次需要在整个会话（多个请求和页面）中保留数据时，会话作用域是正确的选择。
- en: For example, you can add the session scope to the previous applications of this
    chapter for storing the list of randomly extracted players across multiple requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将会话作用域添加到本章之前的应用程序中，以存储跨多个请求随机提取的玩家列表。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The session scope annotation is `@SessionScoped` and is defined in the `javax.enterprise.context`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 会话作用域注解是`@SessionScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'The CDI bean is modified as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean修改如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, the JSF version is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，JSF版本如下：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the session scope bean might get passivated by the container and
    should be capable of passivity, which means that the session beans should be serializable
    (implement the `java.io.Serializable` interface); refer to the capability to persist/restore
    session data to/from the hard disk.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到会话作用域bean可能会被容器钝化，并且应该能够通过实现`java.io.Serializable`接口来钝化；参考将会话数据从硬盘上持久化/恢复的能力。
- en: 'The session objects lives across forward and redirect mechanisms. In the following
    screenshot, you can see the current extracted player and the list of extracted
    players after several requests belonging to the same session:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象在转发和重定向机制中保持有效。在下面的屏幕截图中，你可以看到当前提取的玩家和属于同一会话的几个请求后的提取玩家列表：
- en: '![The session scope](img/6466EN_03_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![会话作用域](img/6466EN_03_05.jpg)'
- en: Now the list is not useless anymore! You can add methods for manipulating its
    content, such as order or delete.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表不再是无用的了！你可以添加操作其内容的方法，例如排序或删除。
- en: 'Programmatically, you can access the session map as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式编程访问会话映射：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, you can invalidate a session as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以按以下方式使会话无效：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, data submitted through forms across the session scope will be available
    in subsequent requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过会话作用域提交的数据将在后续请求中可用。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only once during a session,
    when the session bean is instantiated. Subsequent requests will use this instance,
    so it can be a good place to add initialization stuff.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将在会话期间仅调用一次，当会话bean实例化时。后续请求将使用此实例，因此它是一个添加初始化内容的好地方。
- en: The case of the CDI bean is wrapped into the application named `ch3_2_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_2_2`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的情况被封装在名为`ch3_2_1`的应用中，而JSF bean的情况被封装在名为`ch3_2_2`的应用中。
- en: The view scope
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图作用域
- en: The **view scope** lives as long as you are navigating in the same JSF view
    in the browser window/tab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图作用域**在你在浏览器窗口/标签中导航同一JSF视图时保持有效。'
- en: The view scope is useful when you need to preserve data over multiple requests
    without leaving the current JSF view by clicking on a link, returning a different
    action outcome, or any other interaction that dumps the current view. It gets
    created upon an HTTP request and gets destroyed when you postback to a different
    view; as long as you postback to the same view, the view scope is alive.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在不点击链接、返回不同的操作结果或任何其他导致当前视图被丢弃的交互中保留数据时，视图作用域非常有用。它在HTTP请求时创建，在你回发到不同的视图时销毁；只要回发到相同的视图，视图作用域就保持活跃。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the view scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到视图作用域bean可能会被容器钝化，并且应该通过实现`java.io.Serializable`接口来钝化。
- en: Since the view scope is particularly useful when you are editing some objects
    while staying in the same view, it can be the perfect choice for rich AJAX requests.
    Moreover, since the view scope is bounded to the current view, it does not reflect
    the stored information in another window or tab of a browser; this is an issue
    specific to the session scope!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图作用域在您在相同视图中编辑某些对象时特别有用，因此它对于丰富的 AJAX 请求来说是一个完美的选择。此外，由于视图作用域绑定到当前视图，它不会反映浏览器中另一个窗口或标签页中存储的信息；这是一个特定于会话作用域的问题！
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to keep the view active, the bean methods (actions/listeners) must
    return `null` or `void`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持视图活跃，bean 方法（动作/监听器）必须返回 `null` 或 `void`。
- en: The view scope is not available in CDI, but JSF 2.2 has introduced it through
    the new annotation, `@ViewScoped`. This is defined in the `javax.faces.view.ViewScoped`
    package and it is compatible with CDI. Do not confuse this `@ViewScoped` with
    the one defined in the `javax.faces.bean` package, which is JSF compatible!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CDI 中不可用视图作用域，但 JSF 2.2 通过新的注解 `@ViewScoped` 引入了它。这定义在 `javax.faces.view.ViewScoped`
    包中，并且它与 CDI 兼容。不要将此 `@ViewScoped` 与定义在 `javax.faces.bean` 包中的那个混淆，后者是 JSF 兼容的！
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The view scope annotation is `@ViewScoped` and is defined in the `javax.faces.view`
    package for CDI, and in the `javax.faces.bean` package for JSF.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 视图作用域注解是 `@ViewScoped`，它定义在 `javax.faces.view` 包中用于 CDI，以及定义在 `javax.faces.bean`
    包中用于 JSF。
- en: 'You can see the view scope in action by modifying the `PlayersBean` scope as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过修改 `PlayersBean` 的作用域来查看视图作用域的实际效果，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Firing multiple HTTP requests by clicking on the button labeled **Get Players
    In Same View** will reveal something like the following screenshot. Notice the
    action method (`newPlayer`) returns void and the button doesn't contain the `action`
    attribute, which means that you are in the same JSF view during the execution
    of these requests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击标记为 **Get Players In Same View** 的按钮来触发多个 HTTP 请求将揭示如下截图所示的内容。注意，动作方法 (`newPlayer`)
    返回 void，并且按钮不包含 `action` 属性，这意味着在执行这些请求期间，您处于相同的 JSF 视图中。
- en: '![The view scope](img/6466EN_03_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![视图作用域](img/6466EN_03_06.jpg)'
- en: The other two buttons contain the `action` attribute and indicate an explicit
    navigation, which means that the current view is changed at every request and
    the data is lost.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个按钮包含 `action` 属性，并指示显式导航，这意味着在每次请求时都会更改当前视图，并且数据会丢失。
- en: 'You can easily adapt `PlayersBean` (and any other bean) to use the JSF version
    of `@ViewScoped` as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地将 `PlayersBean`（以及任何其他bean）适配以使用 `@ViewScoped` 的 JSF 版本，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data submitted through forms across the view scope will be available in subsequent
    requests as long as you are in the same view.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视图作用域提交的表单数据，只要您处于同一视图，就会在后续请求中可用。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only when the view scoped
    bean is instantiated. Subsequent requests, from this view, will use this instance.
    As long as you are in the same view, this method will not be called again; therefore,
    it can be a good place to add initialization stuff specific to the current view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `@PostConstruct` 注解的方法仅在视图作用域的 bean 实例化时被调用。后续从这个视图发出的请求将使用此实例。只要您处于同一视图，此方法就不会再次被调用；因此，它是一个添加特定于当前视图的初始化内容的良好位置。
- en: The case of the CDI bean is wrapped into the application named `ch3_6_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_6_2`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean 的案例被封装在名为 `ch3_6_1` 的应用程序中，而 JSF bean 的案例被封装在名为 `ch3_6_2` 的应用程序中。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use the `UIViewRoot.restoreViewScopeState(FacesContext
    context, Object state)` method for restoring the view scope when it is not available.
    This will be exemplified in [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 版本开始，我们可以使用 `UIViewRoot.restoreViewScopeState(FacesContext context,
    Object state)` 方法来恢复不可用的视图作用域。这将在[第 12 章](ch12.html "第 12 章. Facelets 模板") *Facelets
    模板*中举例说明。
- en: The application scope
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序作用域
- en: The **application scope** lives as long as the web application lives.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序作用域**与 Web 应用程序的生命周期一样长。'
- en: An application scope extends the session scope with the shared state across
    all users' interactions with a web application; this scope lives as long as the
    web application lives. Since the beans in the application scope lives until the
    application shuts down (or they are programmatically removed), we can say that
    this scope lives most. More precisely, objects settled on the application scope
    can be accessed from any page that is part of the application (for example, JSF,
    JSP, and XHTML).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用范围通过所有用户与Web应用程序交互的共享状态扩展了会话范围；此范围与Web应用程序的生命周期相同。由于应用范围的bean在应用程序关闭（或它们被编程删除）之前一直存在，因此我们可以说这个范围存在时间最长。更精确地说，位于应用范围的对象可以从应用程序的任何页面访问（例如，JSF、JSP和XHTML）。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application scope should be used only for data that is safe to be shared.
    Since an application scoped bean is shared by all users, you need to be sure that
    the bean has an immutable state or you need to synchronize access.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应仅将应用范围用于可以安全共享的数据。由于应用范围的bean被所有用户共享，您需要确保该bean具有不可变状态，或者您需要同步访问。
- en: Usually, application scope objects are used as counters, but they can be used
    for many other tasks, such as initializations and navigations. For example, the
    application scope can be used to count how many users are online or to share that
    information with all users. Practically, it can be used to share data among all
    sessions, such as constants, common settings, and tracking variables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用范围对象用作计数器，但它们可以用于许多其他任务，例如初始化和导航。例如，应用范围可以用来统计在线用户数量，或者将此信息与所有用户共享。实际上，它可以用于在所有会话之间共享数据，例如常量、通用设置和跟踪变量。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application scope annotation is `@ApplicationScoped` and is defined in the
    `javax.enterprise.context` package for CDI, and in the `javax.faces.bean` package
    for JSF.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 应用范围注解是`@ApplicationScoped`，在CDI中定义在`javax.enterprise.context`包中，在JSF中定义在`javax.faces.bean`包中。
- en: 'If you put the `PlayersBean` managed bean in the application scope, then the
    list of randomly extracted players will be available across all sessions. You
    can do it as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`PlayersBean`托管bean放入应用范围，那么随机抽取的玩家列表将在所有会话中可用。您可以通过以下代码实现：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JSF version is shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JSF版本在以下代码中显示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For testing the application scope, you need to open multiple browsers or use
    multiple machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用范围，您需要打开多个浏览器或使用多台机器。
- en: Be careful when you provide data from an application scoped bean to multiple
    sessions beans (for example, using injection), since the data shared by all sessions
    can be modified by each session separately. This can lead to inconsistent data
    across multiple users; therefore, be sure that the exposed application data isn't
    modified in sessions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在从应用范围的bean向多个会话bean（例如，使用注入）提供数据时，请务必小心，因为所有会话共享的数据可以由每个会话单独修改。这可能导致多个用户之间的数据不一致；因此，请确保暴露的应用数据在会话中不会被修改。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called only when the application
    scoped bean is instantiated. Subsequent requests will use this instance. Usually,
    this happens when the application starts; therefore, place inside this method
    the initialization tasks specific to the application in the context of this bean.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CDI bean的案例被包裹在名为`ch3_3_1`的应用中，而JSF bean的案例被包裹在名为`ch3_3_2`的应用中。
- en: 'Programmatically, you can access the application map using the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码以编程方式访问应用映射：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The case of the CDI bean is wrapped into the application named `ch3_3_1`, while
    the case of the JSF bean is wrapped into the application named `ch3_3_2`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法仅在应用范围的bean实例化时调用。后续请求将使用此实例。通常，这发生在应用程序启动时；因此，请将此bean上下文中的应用特定初始化任务放在此方法内部。
- en: The conversation scope
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话范围
- en: The **conversation scope** allows developers to demarcate the lifespan of the
    session scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话范围**允许开发者界定会话范围的生命周期。'
- en: The conversation scope is committed to the user's interaction with JSF applications
    and represents a unit of work from the point of view of the user; a bean in this
    scope is able to follow a conversation with a user. We may charge the conversation
    scope as a developer-controlled session scope across multiple invocations of the
    JSF life cycle; while session scoped lives across unlimited requests, the conversation
    scopes lives only across a limited number of requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域致力于用户与 JSF 应用程序的交互，并代表用户视角上的工作单元；在这个作用域中的 Bean 能够跟踪与用户的对话。我们可以将对话作用域视为开发者控制的会话作用域，跨越
    JSF 生命周期的多次调用；而会话作用域跨越无限请求，对话作用域仅跨越有限数量的请求。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The conversation scope bean might get passivated by the container and should
    be capable of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域 Bean 可能会被容器钝化，并且应该通过实现 `java.io.Serializable` 接口来具备钝化能力。
- en: The developer can explicitly set the conversation scope boundaries and can start,
    stop, or propagate the conversation scope based on the business logic flow. All
    long-running conversations are scoped to a particular HTTP servlet session and
    may not cross session boundaries. In addition, conversation scope keeps the state
    associated with a particular Web browser window/tab in a JSF application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以显式设置对话作用域的边界，并且可以根据业务逻辑流程启动、停止或传播对话作用域。所有长时间运行的对话都作用域于特定的 HTTP 服务器会话，并且可能不会跨越会话边界。此外，对话作用域在
    JSF 应用程序中保持与特定 Web 浏览器窗口/标签页相关的状态。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The conversation scope annotation is `@ConversationScoped` and is defined in
    the `javax.enterprise.context` package for CDI. This scope is not available in
    JSF!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对话作用域注解是 `@ConversationScoped`，它定义在 `javax.enterprise.context` 包中用于 CDI。这个作用域在
    JSF 中不可用！
- en: 'Dealing with the conversation scope is slightly different from the rest of
    the scopes. First, you mark the bean with `@ConversationScope`, represented by
    the `javax.enterprise.context.ConversationScoped` class. Second, CDI provides
    a built-in bean (`javax.enterprise.context.Conversation`) for controlling the
    life cycle of conversations in a JSF application—its main responsibility is to
    manage the conversation context. This bean may be obtained by injection, as shown
    in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理对话作用域与其他作用域略有不同。首先，您使用 `@ConversationScope` 标记 Bean，由 `javax.enterprise.context.ConversationScoped`
    类表示。其次，CDI 提供了一个内置的 Bean（`javax.enterprise.context.Conversation`），用于控制 JSF 应用程序中对话的生命周期——其主要职责是管理对话上下文。此
    Bean 可以通过注入获得，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By default, the `Conversation` object is in transient state and it should be
    transformed into a long-running conversation by calling the `begin` method. You
    also need to prepare for the destruction of the conversation by calling the `end`
    method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Conversation` 对象处于短暂状态，应该通过调用 `begin` 方法将其转换为长时间运行的对话。您还需要通过调用 `end`
    方法为对话的销毁做好准备。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we try to call the `begin` method when the conversation is active, or the
    `end` method when the conversation is inactive, `IllegalStateException` will be
    thrown. We can avoid this by testing the transitivity state of the `Conversation`
    objects using the method named `isTransient`, which returns a Boolean value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对话处于活动状态时尝试调用 `begin` 方法，或者在对话处于非活动状态时调用 `end` 方法，将会抛出 `IllegalStateException`。我们可以通过使用名为
    `isTransient` 的方法来避免这种情况，该方法返回一个布尔值，用于测试 `Conversation` 对象的传递性状态。
- en: 'Now, add the `begin`, `end`, and `isTransient` methods together to the following
    conversations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `begin`、`end` 和 `isTransient` 方法一起添加到以下对话中：
- en: 'For start conversation, the code is as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始对话，代码如下：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For stop conversation, the code is as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止对话，代码如下：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For example, you can add the conversation scope in `PlayersBean` as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在 `PlayersBean` 中添加对话作用域如下：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Besides injecting the built-in CDI bean, notice that you have defined a method
    (`startPlayerRnd`) for demarcating the conversation start point and another method
    (`stopPlayerRnd`) for demarcating the conversation stop point. In this example,
    both the methods are exposed to the user through two buttons, but you can control
    the conversation programmatically by calling them conditionally.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入内置的 CDI Bean，请注意您已经定义了一个方法（`startPlayerRnd`）用于标记对话的起始点，以及另一个方法（`stopPlayerRnd`）用于标记对话的结束点。在这个例子中，这两个方法都通过两个按钮暴露给用户，但您也可以通过有条件地调用它们来程序化地控制对话。
- en: 'Running the example inside a conversation will reveal something as shown in
    the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话中运行示例将揭示如下截图所示的内容：
- en: '![The conversation scope](img/6466EN_03_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![对话范围](img/6466EN_03_07.jpg)'
- en: The list of randomly extracted players will be empty or will contain only the
    current extracted player until the button labeled **Start Conversation** is clicked.
    At that moment the list will be stored in session, until the button labeled **Stop
    Conversation** is clicked.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随机抽取的玩家列表将保持为空或仅包含当前抽取的玩家，直到点击标记为**开始对话**的按钮。在此刻，列表将被存储在会话中，直到点击标记为**停止对话**的按钮。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During the conversation, the user may execute AJAX/non-AJAX requests against
    the bean or perform navigations to other pages that still reference this same
    managed bean. The bean will keep its state across user interactions using a **conversation
    identifier** generated by the container, and this is why the conversation scope
    can be the right choice when you need to implement wizards. But it might be a
    good idea to take into account the new JSF 2.2 flow scope as well, which solves
    several gaps of the conversation scope. See the upcoming section!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话过程中，用户可以对bean执行AJAX/非AJAX请求或导航到其他仍引用此相同管理bean的页面。bean将使用容器生成的**对话标识符**在用户交互中保持其状态，这就是为什么在需要实现向导时，对话范围可能是正确的选择。但是，考虑新的JSF
    2.2流程范围也是一个好主意，因为它解决了对话范围的几个缺陷。请参阅即将到来的部分！
- en: 'In this example, the conversation context automatically propagates with any
    JSF faces request or redirection (this facilitates the implementation of the common
    POST-then-redirect pattern), but it does not automatically propagate with non-faces
    requests, such as links. In this case, you need to include the unique identifier
    of the conversation as a request parameter. The CDI specification reserves the
    request parameter `cid` for this use. The following code will propagate the conversation
    context over a link:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，对话上下文会自动与任何JSF faces请求或重定向一起传播（这有助于实现常见的POST-then-redirect模式），但它不会自动与非faces请求（如链接）一起传播。在这种情况下，您需要将对话的唯一标识符作为请求参数包含在内。CDI规范为这种用途保留了请求参数`cid`。以下代码将通过链接传播对话上下文：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A method annotated with `@PostConstruct` will be called for each request as
    long as the bean is not involved in a conversation. When the conversation begins,
    the method is called for that instance and subsequent requests will use this instance
    until the conversation ends. Therefore, be careful how you manage this method
    content.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@PostConstruct`注解的方法将在每次请求中调用，只要bean不参与对话。当对话开始时，该方法会为该实例调用，后续请求将使用此实例，直到对话结束。因此，请小心管理此方法的内容。
- en: This example is wrapped into the application named `ch3_4` and is available
    in the code bundle of this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例被封装在名为`ch3_4`的应用程序中，并可在本章的代码包中找到。
- en: The flow scope
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程范围
- en: The **flow scope** allows developers to group pages/views and demarcate the
    group with entry/exit points.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**流程范围**允许开发者对页面/视图进行分组，并通过入口/出口点来划分该组。'
- en: Between the request scope and the session scope, we have the CDI flow scope.
    This scope exists for a while in Spring Web Flow or ADF flow, and now is available
    in JSF 2.2 as well. Basically, the flow scope allows us to demarcate a set of
    related pages/views (usually, logic related) with an entry point (known as **start
    node**) and an exit point (known as **return node**).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求范围和会话范围之间，我们有CDI流程范围。这个范围在Spring Web Flow或ADF流程中存在一段时间，现在在JSF 2.2中也可用。基本上，流程范围允许我们通过一个入口点（称为**起始节点**）和一个出口点（称为**返回节点**）来划分一组相关的页面/视图（通常，逻辑相关）。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The flow scope is a good choice for applications that contain wizards, such
    as multiscreen subscriptions/registrations, bookings, and shopping carts. Generally
    speaking, any chunk of an application that has a logical start point and an end
    point can be encapsulated into the flow scope.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 流程范围是包含向导的应用程序的好选择，例如多屏幕订阅/注册、预订和购物车。一般来说，任何具有逻辑起点和终点的应用程序块都可以封装到流程范围中。
- en: In the same application, we can define multiple flows, which can be seen as
    modules that are reusable and capable to communicate. They can be called sequentially,
    can be encapsulated as Matrioska dolls or can create any custom design. Moreover,
    it is very easy to move, delete, or add a flow into such an application just by
    plugging in/out the entry and exit point.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the benefits of using the flow scope, you have to identify some
    disadvantages of the applications that don''t use it. They are listed as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Each application is a big flow, but usually pages do not follow any intuitive
    logical design. Apparently, a disordered order governs even when pages are logically
    related, such as pages of a wizard or of a shopping cart.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope allows us to define logical units of work.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reusing pages can be a difficult task to accomplish, since pages are so tied
    up to UI components and user interaction.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope provides reusability.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CDI provides conversation scope capable of stretching over several pages, but
    the flow scope fits better for JSF.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the conversation scope, the flow scope covers a set of pages/views, but it
    has several main advantages, such as it is much more flexible, doesn't need that
    clumsy begin/end operation, flow scoped beans are created and destroyed automatically
    when the user enters or exists into/from a flow, provides easy-to-use support
    for inbound/outbound parameters, and prehandlers and posthandlers. A normal flow
    cannot be opened in multiple windows/tabs because information travels between
    pages with the session scope.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Data in a flow is scoped to that flow alone; therefore, flows can be opened
    in multiple windows/tabs.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **nodes** define the entry and exit points of a flow and there are five
    types of nodes, which are listed as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This represents any JSF page in the application that participates
    in the flow. It is known as a **view node** of the flow.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The method call**: This indicates an invocation of a method using EL. The
    called method may return an outcome that indicates which node should be navigated
    next.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Switch**: The `switch` case statements are a substitute for long `if` statements.
    The cases are represented by EL expressions and are evaluated to Boolean values.
    Each case is accompanied by an outcome that will be used when the condition is
    evaluated to `true`. There is also a default outcome that will be used when all
    cases are evaluated to `false`.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The flow call**: This is used to call another flow in the current flow—these
    are transition points between flows. The called flow (known as inner or nested
    flow) is nested in the flow that calls it (known as calling flow or outer flow).
    When the nested flow finishes its tasks, it will return a view node from the calling
    flow, which means that the calling flow will have control only after the nested
    flow''s lifespan comes to an end.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The flow return**: This can be used for returning an outcome to the calling
    flow.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flows can pass parameters from one to the other. Parameters sent by a flow to
    another flow are known as **outbound parameters**, while parameters received by
    a flow from another flow are known as **inbound parameters**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以传递参数从一个传递到另一个。一个流发送给另一个流的参数被称为**出站参数**，而一个流从另一个流接收到的参数被称为**入站参数**。
- en: Well, at this point, you should have enough information about the flow scope
    to develop some examples. But, before doing this, you need to be aware of some
    tags, annotations, and conventions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这个时候，你应该已经拥有了足够的信息来开发一些示例。但在这样做之前，你需要注意一些标签、注解和约定。
- en: The flow definition is based on a set of conventions over configuration. A flow
    has a name, a folder in the web root of the application reflecting the flow name,
    and a view representing the start node that also reflects the flow name. This
    folder groups the pages/views that belong to the same flow.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 流定义基于配置的一组约定。一个流有一个名称，一个在应用程序Web根目录中反映流名称的文件夹，以及一个表示起始节点且也反映流名称的视图。此文件夹将属于同一流的页面/视图分组。
- en: In order to use a flow, you need to accomplish some configuration tasks. These
    can be done through a configuration file or programmatically. If you choose the
    first approach, then the configuration file can be limited to one flow, which
    means that it is stored in the flow folder and is named in the format *flowname*`-flow.xml`,
    or you can use the `faces-config.xml` file for having all flows in a single place.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一个流，你需要完成一些配置任务。这些任务可以通过配置文件或编程方式完成。如果你选择第一种方法，那么配置文件可以限制为一个流，这意味着它存储在流文件夹中，并以*flowname*`-flow.xml`的格式命名，或者你可以使用`faces-config.xml`文件将所有流放在一个地方。
- en: 'Since our first example uses the configuration file, we need to use tags. The
    main tags used for configuring a flow are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个示例使用配置文件，我们需要使用标签。用于配置流的标签如下：
- en: '`< flow-definition>`: This tag contains an `id` attribute that uniquely identifies
    the flow. The value of this ID is the flow name used to reference the flow from
    JSF pages or beans.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< flow-definition>`：此标签包含一个`id`属性，该属性唯一标识流。此ID的值是用于从JSF页面或bean引用流的流名称。'
- en: '`<view>`: It is nested in the `<flow-definition>` tag and indicates the JSF
    pages that represent the flow nodes; it associates an explicit ID to each page
    (Facelet) path (further, you can refer to each page by its ID). The page path
    is mapped in a `<vdl-document>` tag, nested in the `<view>` tag. The presence
    of this tag is optional, but as a convention, at least the `<view>` tag indicating
    the start node (start page) is present, especially if you want to set another
    start node besides the default one, which is represented by the page in the flow
    with the same name (ID) as the flow. Further, you can use the optional `<start-node>`*ID*`</start-node>`
    tag and indicate the ID of the `<view>` tag that maps the custom starting page.
    As an alternative, the start node of the flow can be indicated by setting the
    value of the `id` attribute of a `<view>` tag as the flow ID, and the content
    of the encapsulated `<vdl-document>` tag as the path of the custom starting page.
    When you refer to the flow ID, JSF will go to that page and automatically put
    you in the flow.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<view>`：它嵌套在`<flow-definition>`标签中，表示代表流节点的JSF页面；它为每个页面（Facelet）路径关联一个显式ID（进一步，你可以通过其ID引用每个页面）。页面路径在`<view>`标签中映射，该标签嵌套在`<view>`标签内。此标签的存在是可选的，但按照惯例，至少应该有一个`<view>`标签表示起始节点（起始页面），特别是如果你想设置除了默认的起始节点之外的另一个起始节点，该节点由与流具有相同名称（ID）的页面表示。此外，你可以使用可选的`<start-node>`*ID*`</start-node>`标签来指示映射自定义起始页面的`<view>`标签的ID。作为替代，流起始节点可以通过将`<view>`标签的`id`属性值设置为流ID，并将封装的`<vdl-document>`标签的内容作为自定义起始页面的路径来指示。当你引用流ID时，JSF将转到该页面并自动将你放入流中。'
- en: '`<flow-return>`: It is nested in the `<flow-definition>` tag and returns an
    outcome to the calling flow. You can refer to it through the value of the `id`
    attribute. There are at least three ways of getting out of a flow: using `<flow-return>`,
    using `<flow-call>` (presented later), or by abandoning the flow.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<flow-return>`：它嵌套在`<flow-definition>`标签中，并将结果返回给调用流。你可以通过`id`属性的值来引用它。至少有三种退出流的方法：使用`<flow-return>`，使用稍后介绍的`<flow-call>`，或者放弃流。'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We just said that a flow is identified by an ID (by a name). But, when the same
    flow name is defined in multiple documents (like in big projects that use multiple
    packaged flows from different vendors), there is one more ID needed. This ID is
    known as the **document ID**. Thus, when you need to identify a flow whose name
    appears in different documents, we need the flow ID and the defining document
    ID. Most of the time the document ID is omitted; therefore, it is not demonstrated
    in this section. In this section, you will see just a few hints about it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才说过，一个流程通过一个ID（一个名称）来识别。但是，当相同的流程名称在多个文档中定义（如在大型项目中使用来自不同供应商的多个打包流程），还需要一个额外的ID。这个ID被称为**文档ID**。因此，当你需要识别一个名称在不同文档中出现的流程时，我们需要流程ID和定义文档ID。大多数情况下，文档ID被省略；因此，本节中没有演示。在本节中，你将看到关于它的几个提示。
- en: 'In order to define the simplest flow, you need to be aware of the following
    diagram:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义最简单的流程，你需要了解以下图表：
- en: '![The flow scope](img/6466EN_03_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![流程范围](img/6466EN_03_08.jpg)'
- en: The simple flow
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的流程
- en: 'With these three tags, `<start-node>` and/or `<view>`, `<flow-return>`, and
    `<from-outcome>`, you can configure a simple flow, like a peddling registration
    form. Let''s suppose that a tennis player registers online to a tournament through
    a flow made up of two JSF pages (the flow name will be `registration`): a page
    containing a form used for collecting data and a confirmation page. Moreover,
    there will be two pages outside the flow, one for entering into the flow (like
    the first page of the website), and one that is called after confirmation.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个标签，`<start-node>`和/或`<view>`，`<flow-return>`，和`<from-outcome>`，你可以配置一个简单的流程，比如一个跑步注册表单。假设一个网球运动员通过由两个JSF页面组成的流程在线注册一个锦标赛（流程名称将为`registration`）：一个用于收集数据的表单页面和一个确认页面。此外，还将有两个页面在流程之外，一个用于进入流程（如网站的第一个页面），另一个在确认后调用。
- en: 'In the following diagram, you can see an image of our flow:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到我们流程的图像：
- en: '![The simple flow](img/6466EN_03_09.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![简单的流程](img/6466EN_03_09.jpg)'
- en: 'Let''s have a look at the code for the first page that is outside the flow
    and outside the registration folder (`index.xhtml`) as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看流程之外、注册文件夹之外的第一页的代码（`index.xhtml`）如下：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Two important things can be observed here. First, the following lines:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以观察到两个重要的事情。首先，以下几行：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line returns a Boolean value indicating whether the current page is
    or is not in a flow. Obviously, the `index.xhtml` page is not in a flow; therefore,
    `false` will be returned. You can use it for tests. The second line displays the
    ID of the current flow.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行返回一个布尔值，指示当前页面是否在流程中。显然，`index.xhtml`页面不在流程中；因此，将返回`false`。你可以用它进行测试。第二行显示当前流程的ID。
- en: Further, you need to take a look at the value of the attribute `action` of the
    `<h:commandButton>` tag. This value is the name (ID) of our flow; after the window
    context is enabled, JSF will search the indicated flow and navigate to the start
    node of the flow. By default, the window context is disabled.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要查看`<h:commandButton>`标签的`action`属性的值。这个值是我们流程的名称（ID）；在窗口上下文启用后，JSF将搜索指定的流程并导航到流程的起始节点。默认情况下，窗口上下文是禁用的。
- en: 'Therefore, when the button labeled **Start Registration** is clicked, the application
    steps in the registration flow and loads the start node page represented by the
    `registration.xhtml` page. The code for this page is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当点击标记为**开始注册**的按钮时，应用程序进入注册流程并加载由`registration.xhtml`页面表示的起始节点页面。此页面的代码如下：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we are in the flow, `currentFlow` will return `true`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于流程中，`currentFlow`将返回`true`。
- en: 'It is more important to focus on the implicit object, `flowScope`; however,
    as you know from [Chapter 1](ch01.html "Chapter 1. Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)"), *Dynamic Access to JSF Application
    Data through Expression Language (EL 3.0)*, the `flowScope` implicit object (which
    indicates the current flow) is used for sharing data through the entire flow and
    maps to `facesContext.getApplication().getFlowHandler().getCurrentFlowScope()`.
    For example, the value of the `<h:inputText>` tag can be put into the `flowScope`
    object and can be read from the flow scope in the next page, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The button labeled **Register To Tournament** navigates to the second page
    in the flow, `confirm.xhtml`; this is a usual navigation case, there is nothing
    to say here. But the other button navigates outside the flow (to `index.xhtml`)
    by indicating the ID of a flow return. In the configuration file, this flow return
    is as shown in the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code of the `confirm.xhtml` page is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This page displays the data that was entered and stored on the flow scope along
    with both the buttons. The first button navigates back to the `registration.xhtml`
    page, while the other one navigates to the `done.xhtml` page, which is outside
    the flow. The flow return is identified by the ID, as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `done.xhtml` page just checks to see if the page is in flow and displays
    a simple message, as shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final step is to define the flow in a configuration file. Since you have
    a single flow, you can create a file `registration-flow.xml` in the `registration`
    folder. The following is the code of the `registration-flow.xml` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also place the following code inside the `faces-config.xml` file in
    the `<faces-flow-definition>` tag:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is wrapped into the application named `ch3_7_1` that is available
    in the code bundle of this chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Flows with beans
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beside pages, a flow can contain beans. A bean defined in a flow is annotated
    with `@FlowScoped`; this is a CDI annotation that enables automatic activation
    (when the scope is entered) and passivation (when the scope is exited). The `@FlowScoped`
    bean requires an attribute named `value` that contains the flow ID. The data stored
    in such a bean is available in all pages that belong to that flow.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow scope bean might get passivated by the container and should be capable
    of passivity by implementing the `java.io.Serializable` interface.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a bean in the registration flow can modify the initial diagram, as shown
    in the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Flows with beans](img/6466EN_03_10.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: As you can see, the bean will store the data collected from the registration
    form in the flow scope (in the previous example, this data was passed using the
    `flowScope` implicit object). The button labeled **Register To Tournament** will
    call the `registrationAction` bean method, which will decide if the data is valid
    and return the flow back to the `registration.xhtml` page or next to the `confirm.xhtml`
    page.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The `registration.xhtml` page''s code is modified as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code of `RegistrationBean` is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code is self explanatory, but what about the `getReturnValue` method? Well,
    this is just an example of how a flow scoped bean can indicate the outcome of
    a flow return. Instead of using the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can use the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example is wrapped into the application named `ch3_7_2` that is available
    in the code bundle of this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Nested flows
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, now let's complicate things by adding another flow under the existing
    one. Let's suppose that after the registration, the player has to indicate the
    day and the hour when he is available to play the first match. This can be accomplished
    in a new flow named `schedule`. The `registration` flow will call the `schedule`
    flow and will pass some parameters to it. The `schedule` flow will return in the
    `registration` flow, which will provide a simple button for navigation outside
    the `registration` flow.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nested flow returns only in the calling flow. You have to refer to a page
    of the calling flow in the `<flow-return>` tag of the nested flow, including the
    pages returned by the calling flow.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing parameters is a thing that requires more tags in the configuration
    tag. Therefore, you need to know the following tags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`<flow-call>`: This calls another flow in the current flow. This tag requires
    the `id` attribute. The value of this attribute will be used to refer to this
    flow call.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<flow-reference>`: This is nested in the `<flow-call>` tag and contains the
    ID of the flow that must be called.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<outbound-parameter>`: This is nested in the `<flow-call>` tag and defines
    parameters that must be passed to the called flow.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<inbound-parameter>`: This defines the parameters passed from another flow.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to see these tags at work, you need to take a look at the application
    flow. The diagram of the application will change as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested flows](img/6466EN_03_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'We resume our discussion from the `confirm.xhtml` page (defined in the `registration`
    flow). From this page, we want to navigate to the `schedule.xhtml` page, which
    is available in the `schedule` flow (the `schedule` folder). For this, we can
    add a new button, labeled **Schedule**, as shown in the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The button''s `action` attribute value is the ID of the `<flow-call>` tag.
    When the button is clicked, JSF locates the corresponding `<flow-call>` tag and
    follows the flow with the ID indicated by the `<flow-id>` tag, as shown in the
    following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Moreover, we want to pass several parameters from the `registration` flow to
    the `schedule` flow: the player name and surname (stored in the flow scoped `RegistrationBean`
    bean) and a constant representing some registration code (it can also be generated
    based on certain rules). This can be accomplished by the `<outbound-parameter>`
    tag, as shown in the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `schedule.xhtml` page displays a hello message based on the received parameters
    and a form that allows to the player to enter the day and hour when he is available
    for playing the first match, as shown in the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the name and surname are obtained from the flow scope using the
    `flowScope` object, while the registration code is obtained from the flow scoped
    `ScheduleBean`; this bean stores the day, hour (received from the player), and
    registration code (received from the `registration` flow). Each piece of information
    received from the registration bean was guided to the place of storage using the
    `<inbound-parameter>` tag in the `schedule-flow.xml` file, as shown in the following
    code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the day and hour are inserted, the button labeled **Save** should save
    the data and navigate to the `success.xhtml` page, which is a simple page that
    displays all data provided by the player. From this page, we can return to the
    calling flow, `registration`, via a simple button labeled **Exit Registration**,
    as shown in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The outcome, `taskFlowReturnThanks`, is defined in the `schedule-flow.xml`
    file as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `thanks.xhtml` page is just a final step before the user exists from the
    `registration` flow, as shown in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you want to jump over the `thanks.xhtml` page, directly outside of both
    flows, then you can define the flow return, `taskFlowReturnThanks`, to point out
    the `done.xhtml` page, which is returned by the calling flow via the `taskFlowReturnDone`
    flow return. Therefore, we can use the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example is wrapped into the application named `ch3_7_3` that is available
    in the code bundle of this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flows can be configured declaratively or programmatically using the JSF 2.2
    `FlowBuilder` API.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Configuring flows programmatically
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all the previous examples, you saw how to configure a flow using the declarative
    approach. But, flows can be configured programmatically also. The steps for configuring
    a flow programmatically are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Create a class and name it as the flow. This is more like a convention, not
    a requirement!
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this class, write a method as shown in the following code; the `@FlowDefinition`
    annotation is a class-level annotation that allows the flow definition to be defined
    using the `FlowBuilder` API. The name of this method can be any valid name, but
    `defineFlow` is like a convention. So, the name `defineFlow` is not mandatory,
    and you can even define more flows in the same class as long as you have annotated
    them correctly.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Use the `FlowBuilder` API to configure the flow.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the `FlowBuilder` API is pretty straightforward and intuitive. For example,
    you can write the `registration-flow.xml` file programmatically, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, for each tag used in the declarative approach, there is a corresponding
    method in the `FlowBuilder` API. For example, the `flowBuilder.id` method accepts
    two arguments: the first one represents the document ID (usually, an empty space),
    and the second one represents the flow ID.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The `schedule-flow.xml` file can be programmatically translated as shown in
    the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called when the application
    enters into the current flow and the flow scoped bean is instantiated, while subsequent
    requests will use this instance until the flow is dumped. This is repeated if
    the application enters in this flow again. So, initializations specific to the
    current flow can be placed here.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch3_7_5` that is available
    in the code bundle of this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Declarative and programmatic configurations can be mixed in the same application.
    For example, check the application named `ch3_7_4`, which uses programmatic configuration
    for the `registration` flow and declarative configuration for the `schedule` flow.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Flows and navigation cases
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigation cases can be used for navigating inside flows. At this moment, when
    you click on the button labeled **Register To Tournament**, the flow goes in the
    `confirm.xhtml` page based on implicit navigation. But we can easily exemplify
    an explicit navigation in the flow by replacing the value of the `action` attribute
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, `confirm_outcome` cannot be automatically fetched to the `confirm.xhtml`
    page; therefore, in the `registration-flow.xml` file, we can add an explicit navigation
    case, as shown in the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to use a navigation case to enter in a flow, you will have to
    specify the `<to-flow-document-id>`*document_ID*`</to-flow-document-id>` statement
    nested in the `<navigation-case>` tag. If there is no document ID, that uses `<to-flow-document-id/>`.
    Moreover a `<h:button>` (or `<h:link>`) can be used to enter in such a flow, as
    follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you choose to write a programmatic navigation case, then JSF 2.2 comes with
    a method named, `getToFlowDocumentId`, which should be overridden for indicating
    the document ID.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: At this point, everything comes to normal. Therefore, we can use explicit navigation
    cases for navigation between the flow's pages. The complete application is named
    `ch3_11_1`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish the same thing in a programmatic fashion, you need to
    use the `NavigationCaseBuilder` API, as shown in the following code; this is the
    same navigation case, so we have used only the needed methods:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This example is wrapped in the complete application named `ch3_11_2`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, you can even use a custom navigation handler. The new `NavigationHandlerWrapper`
    class (added in JSF 2.2) provides a simple implementation of the `NavigationHandler`
    class. Therefore, we can easily extend it to prove a navigation case using a custom
    navigation handler, as shown in the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, a quick configuration in the `faces-config.xml` file is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the flow has a document ID, you need to override the `handleNavigation(FacesContext
    context, String fromAction, String outcome, String toFlowDocumentId)` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch3_11_3`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting flow navigation cases
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whatever approach you choose for using navigation cases inside flows, you can
    always inspect them via the `ConfigurableNavigationHandler.inspectFlow` method.
    This method is invoked by the flow system to cause the flow to be inspected for
    navigation rules. You can easily override it to obtain information about navigation
    cases, by writing a custom configurable navigation handler. The easiest way to
    accomplish this is to extend the new `ConfigurableNavigationHandlerWrapper` class
    (introduced in JSF 2.2), which represents a simple implementation of `ConfigurableNavigationHandler`.
    For example, the following snippet of code sends in log information about each
    found navigation case:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you attach this custom configurable navigation handler to one of the preceding
    three examples, then you will get information about the presented navigation case.
    The complete example is named `ch3_15`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Using the initializer and finalizer
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using the `FlowBuilder` API, we can attach callback methods that will be
    automatically called when a flow is created and right before it is destroyed.
    The `FlowBuilder.initializer` method has the following signatures, which are called
    when the flow is created:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FlowBuilder.finalizer` signature is called before the flow is destroyed,
    as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For example, the `initializer` method can be used to pass external parameters
    into a flow. Let''s suppose that in the `index.xhtml` page (outside the flow),
    when we click on the button labeled **Start Registration**, we want to pass the
    tournament name and place into the flow, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'These two parameters must be available when the flow starts, because the wrapped
    information is displayed in the `registration.xhml` page (the start node of the
    flow) via two properties from `RegistrationBean`, namely `tournamentName` and
    `tournamentPlace`. For this, we need to call a method from `RegistrationBean`
    capable of extracting this information and store it in these two properties, as
    shown in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now is the interesting part, because we can use the `initializer` method to
    indicate the `tournamentInitialize` method as the callback method that should
    be invoked when the flow is created. This can be done in the `registration-flow.xml`
    file as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, at this moment, we can use the tournament name and place right from the
    beginning of the flow and during the flow's lifespan.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, another simple scenario can be the justification for using a
    `finalizer` method. Let''s suppose that we count the registered players via an
    application scoped bean named `PlayersCounterBean`, as shown in the following
    code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `count` variable should be increased when the player exits the flow, and
    the registration is successfully done; therefore, we can place a `finalizer` method
    in the `registration-flow.xml` file as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `tournamentFinalize` method is implemented in `RegistrationBean`, as shown
    in the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since the `PlayersCounterBean` is an application bean, we can use its goodies
    outside the flow. The complete application is named `ch3_12_1`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The same output can be programmatically achieved using the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For the sake of variation, in this case we didn''t extract the parameter values
    using the request parameter `Map`. We preferred to use the implicit object `param`
    and to pass the values as arguments of the `tournamentInitialize` method as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The complete application is named `ch3_12_2`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Using the flow switch
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` case statements are a substitute for long `if` statements and
    are useful to do conditional outcome mapping. In order to see it at work, we can
    suppose that for each tournament we have a separate `confirm.xhtml` page. Let''s
    have the four grand slams in tennis and the associated XHTML confirmation pages,
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Roland Garros and `confirm_rg.xhtml`
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wimbledon and `confirm_wb.xhtml`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: US Open and `confirm_us.xhtml`
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Australian Open and `confirm_ao.xhtml`
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name and place of the tournament are passed in the flow via a simple form
    (one form per tournament), as follows (you already know from the preceding section
    how this information may be obtained inside the flow):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, after clicking on the button labeled **Register To...**, we need to choose
    the right confirmation page. For this, we can use a programmatic switch, as shown
    in the following code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that when no condition is evaluated to `true`, the selected node will
    be the `notournament.xhtml` page, which represents the default outcome. This is
    just a simple XHMTL page containing some specific text.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete application is named `ch3_13`. Declaratively, this can be achieved
    in the `registration-flow.xml` file as shown in the following code. You can use
    `<view>` tags to hide the outcome''s path behind some IDs (map outcomes to pages),
    as we saw in the programmatic example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: So, switch can be useful when you don't want to map each outcome to a single
    page.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: This example wasn't wrapped in a complete application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Packaging flows
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flows act as logical units of work; therefore, they are portable across multiple
    applications. The portability is obtained by packaging the flow artifacts in a
    JAR file. Further, the JAR file can be added in any application `CLASSPATH` and
    the flow is ready to be used. To package a flow, you need to follow some conventions,
    which are listed as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly define the flows in the `faces-config.xml` file.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JAR root, create a `META-INF` folder.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `faces-config.xml` file in this folder.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `beans.xml` file in this folder.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same folder, `META-INF`, create a subfolder named `flows`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `flows` folder, add all nodes (pages) of the flow.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JAR root, outside the `META-INF` folder, add all the Java code (classes)
    needed by the flow.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the preceding steps, the flow described in the *Flows with beans*
    section can be packaged in a JAR file named `registration.jar`, as shown in the
    following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging flows](img/6466EN_03_12.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: The complete application that uses this JAR file is named `ch3_14`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic flow scope
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programmatically speaking, the flow scope can be accessed via the `javax.faces.flow.FlowHandler`
    class. After obtaining a `FlowHandler` class''s object, you can easily access
    the current flow, add a new flow, and manipulate the flow map represented by `#{flowScope}`,
    as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Obviously, the `FlowHandler` class is the most important class involved in
    the interaction between runtime and the faces flow feature. This is an abstract
    class that can be extended to provide a custom flow handler implementation. In
    order to do that, you can start by creating a new `FlowHandlerFactory` class,
    which is used by the `Application` class to create the singleton instance of the
    `FlowHandler` class. This class has a simple implementation named `FlowHandlerFactoryWrapper`,
    which can be easily extended to return a custom flow handler, as shown in the
    following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This factory should be configured in the `faces-config.xml` file, as shown
    in the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Further, the `CustomFlowHandler` class represents an extension of the `FlowHandler`
    class. Since the `FlowHandler` class is an abstract class, you need to provide
    an implementation for each of its methods, as shown in the following code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For example, you know from the previous sections that the `registration` flow
    passed several outbound parameters to the nested `schedule` flow. You saw how
    to accomplish that declaratively, in the `registration-flow.xml` file, and programmatically,
    via the `FlowBuilder` API, in the `Registration` class. You can do the same thing
    from a custom flow handler in the method named, `transition`, which is capable
    to perform a transition between a source flow (for example, `registration`) and
    a target flow (for example, `schedule`). When the `registration` flow calls the
    `schedule` flow, you can write the following code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The target inbound parameters can be accessed as follows (the `Map` parameter
    cannot be altered):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Flow parameters are represented by the `javax.faces.flow.Parameter` abstract
    class. The `CustomParameter` class provides an implementation as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Dependent pseudo-scope
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default scope of a CDI bean (`@Named`) when nothing is specified.
    In this case, an object exists to serve exactly one bean and has the same life
    cycle as that bean; an instance of a dependent scoped bean is not shared between
    different users or different points of injection. It can also be explicitly specified
    by annotating the bean with the `@Dependent` annotation and importing `javax.enterprise.context.Dependent`.
    This scope is available only in CDI and is the only **non-contextual** scope.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All CDI scopes, except this one, are known as **normal** scopes. More details
    about normal scopes versus pseudo-scopes can be found in the *Normal scopes and
    pseudo-scopes* section at [http://docs.jboss.org/cdi/spec/1.0/html/contexts.html](http://docs.jboss.org/cdi/spec/1.0/html/contexts.html).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put the `PlayersBean` in the dependent scope, then the current extracted
    player and the list of randomly extracted players (which will be empty or will
    contain this player) is available only inside the bean, as shown in the following
    code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method annotated with `@PostConstruct` will be called for each request. Actually,
    it might be called multiple times during the same request, if the bean is used
    in several EL expressions. Initially, there is one instance of the bean, and this
    instance is reused if the bean EL name appears multiple times in the EL expression,
    but is not reused in the case of another EL expression or in the case of a re-evaluation
    of the same EL expression.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: This example is wrapped into the application named `ch3_5` that is available
    in the code bundle of this chapter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The none scope
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **none scoped** beans lives to serve other beans.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The none scope seems to be the black sheep of JSF scopes. Even its name doesn't
    inspire something useful. Practically, a managed bean in this scope lives as long
    as a single EL expression evaluation and is not visible in any JSF page. If the
    application scope lives the longest, this scope lives the shortest. But, if you
    inject the none scoped managed beans in other managed beans, then they will live
    as long as their hosts. Actually, this is their job, to serve other beans.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The none scoped objects used in the configuration file indicate managed beans
    that are used by other managed beans in the application.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: So, whenever you need a humble managed bean that is ready to be a part of a
    cool scope, such as a request or a session, you can annotate it with `@NoneScoped`,
    available in the `javax.faces.bean` package. Moreover, objects with the none scope
    can use other objects with the none scope.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The custom scope
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When none of the previous scopes meet your application needs, you have to pay
    attention to the JSF 2 custom scope. Most likely, you will never want to write
    a custom scope, but if it is necessary, then, in this section, you can see how
    to accomplish this task.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The custom scope annotation is `@CustomScoped` and is defined in the `javax.faces.bean`
    package. It is not available in CDI!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement a custom scope, let's suppose that you want to control
    the life cycle of several beans that live in the application scope. Normally they
    live as long as the application lives, but you want to be able to add/remove them
    from the application scope at certain moments of the application flow. Of course,
    there are many approaches to do that, but remember that we look for a reason to
    implement a custom scope; therefore, we will try to write a custom scope nested
    in the application scope that will allow us to add/remove a batch of beans. Creating
    and destroying the scope itself will be reflected in creating and destroying the
    beans, which means that you don't need to refer to each bean.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, since this is just a demo, we will use only two beans: one will stay
    in the classical application scope (it can be useful for comparison of the application
    and custom scope lifespan), while the other one will be added/destroyed through
    the custom scope. The application purpose is not relevant; you should focus on
    the technique used to write a custom scope and paper over the assumptions and
    gaps. Think more on the lines that you can use this knowledge when you really
    need to implement a custom scope.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Writing the custom scope class
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The custom scope is represented by a class that extends the `ConcurrentHashMap<String,
    Object>` class. We need to allow concurrent access to an usual map because the
    exposed data may be accessed concurrently from multiple browsers. The code of
    the `CustomScope` class is as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When our scope is created/destroyed, other components will be informed through
    events. In the `scopeCreated` method, you register `PostConstructCustomScopeEvent`,
    while in the `scopeDestroyed` method, you register `PreDestroyCustomScopeEvent`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a custom scope, it is time to see how to declare a bean in this
    scope. Well, this is not hard and can be done with the `@CustomScoped` annotations
    and an EL expression, as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Resolving a custom scope EL expression
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, JSF will iterate over the chain of existing resolvers in order
    to resolve the custom scope EL expression. Obviously, this attempt will end with
    an error, since no existing resolver will be able to satisfy this EL expression.
    So, you need to write a custom resolver as you saw in [Chapter 1](ch01.html "Chapter 1. Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)"), *Dynamic
    Access to JSF Application Data through Expression Language (EL 3.0)*. Based on
    that, you should obtain something as shown in the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Do not forget to put the following resolver into the chain by adding it in
    the `faces-config.xml` file:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Done! So far, you have created a custom scope, you put a bean into this scope,
    and learned that the brand new resolver provides access to this bean.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The custom scope must be stored somewhere, so nested in the application scope
    can be a choice (of course, other scopes can also be a choice, depending on your
    needs). When the scope is created, it has to be placed in the application map,
    and when it is destroyed, it has to be removed from the application map. The question
    is when to create it and when to destroy it? And the answer is, *it depends*.
    Most likely, this is a decision strongly tied to the application flow.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the custom scope lifespan with action listeners
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using action listeners can be a good practice even if it involves control from
    view declaration. Let''s suppose that the button labeled **START** will add the
    custom scope in the application map, as shown in the following code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following `CreateCustomScope` class is a straightforward action listener
    as it implements the `ActionListener` interface:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Following the same approach, the button labeled **STOP** will remove the custom
    scope from the application map as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following `DestroyCustomScope` class is the action listener as it implements
    the `ActionListener` interface:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This example is wrapped into the application named `ch3_8` that is available
    in the code bundle of this chapter. Just a run and a quick look over the code
    will clarify that the spaghetti-code is missing here.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the custom scope lifespan with the navigation handler
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach is to control the custom scope lifespan based on the page''s
    navigation. This solution is more flexible and is hidden from the user. You can
    write a custom navigation handler by extending `NavigationHandler`. The next implementation
    puts the custom scope in the application map when the navigation reaches the page
    named `sponsored.xhtml`, and will remove it from the application map in any other
    navigation case. The code of the `CustomScopeNavigationHandler` class is as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Do not forget to register the following navigation handler in the `faces-config.xml`
    file:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This example is wrapped into the application named `ch3_9` that is available
    in the code bundle of this chapter. A quick look over the code will clarify that
    the spaghetti-code is missing here.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said earlier, JSF 2.2 comes with a wrapper class for `NavigationHandler`.
    This is a simple implementation that can be easily extended by developers. An
    instance of the class being wrapped is returned in the `getWrapped` method. For
    example, you can rewrite the `CustomScopeNavigationHandler` class, as shown in
    the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This example is wrapped into the application named `ch3_10` that is available
    in the code bundle of this chapter.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Managed bean instantiation
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, a managed bean is instantiated at first reference to it (a request,
    for example)—this is known as **lazy instantiation**. You can alter the default
    behavior by adding the `eager` attribute and set its value to `true`. This will
    instantiate the managed bean when the application starts, before any request is
    made. But, it is important to know that this works only for application scoped
    beans and the eager instantiated bean is placed in the application scope, as shown
    in the following lines of code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Beans injection
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, solutions depend on the concrete functional requirements, but finding
    the right solutions is what makes the difference between developers. Sometimes,
    developers get stuck or make mistakes when they work with objects in a scope that
    uses objects from another scope. From the following figure, you can seek some
    guidance for dealing with some of the most popular cases:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![Beans injection](img/6466EN_03_13.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there are some restrictions. As a general rule in JSF, don't
    use objects that have shorter lifespan than the objects you are calling it from.
    In other words, use objects whose lifespan is the same as, or longer than, the
    object being injected into. Breaking this rule will end up in a JSF exception.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic behind this rule can be explained through the two most common mistakes,
    which are as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**Use request objects in session objects**: This is a bad thing, because we
    will have lots of requests (lots of instances) and only one session (one instance).
    Usually, requests belong to all users, while a session is one per user; therefore,
    it is unclear request object is injected? To be more clear, lots of requests means
    lots of associated beans, while a session means one bean. Now, it is illogical
    to inject one particular instance and skip all others. Moreover, how and when
    will you fetch the correct instance, since the request objects are transient,
    and usually, have a short lifespan! Even if you find a plausible use case, JSF
    will not allow you to do this via JSF managed beans.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use session objects in application objects**: The same logic can be applied
    further when we want to use session objects in application objects. Sessions are
    many as users, but the application is only one; therefore, you cannot inject all
    sessions in the application ... it is useless! Of course, you may want to fetch
    a certain session to the application, but you have to be sure that the pointed
    session exists; this is not a problem if you are interested in the session of
    the current user, but it may be an issue if you are interested in sessions of
    other users. Moreover, if there are many sessions, you have to correctly identify
    the desired session. Even if you find a plausible use case, JSF will not allow
    you to do this via JSF managed beans.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, for CDI, these cases are not such a big issue. When you are using
    an object that has a shorter lifespan than the object you are calling it from
    (for example, injecting a request scoped bean into a session scoped bean), CDI
    classifies the use case as a mismatched injection and fixes the issue via CDI
    proxies. For each request, the CDI proxy re-establishes the connection to a live
    instance of the request scoped bean.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when we follow the written rules, we are still vulnerable to the unwritten
    rules. One of the unwritten rules that can cause undesirable results is named
    **overuse** or **abuse**. The following are some cases to avoid:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Overusing a view scoped bean for request scoped data may affect memory.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing a request scoped bean for view scoped data may cause forms with unexpected
    behavior.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing an application scoped bean for request/view/session scoped data may
    cause an undesirably wide visibility of data across users and will affect memory.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overusing a session scoped bean for request/view data may cause an undesirably
    wide visibility of data across multiple browser windows/tabs in that session.
    As you know, view data are specific to a single browser window/tab, which allows
    us to open multiple tabs and keeps the data integrity while switching between
    tabs. On the other hand, if this data was exposed via the session scope, then
    the modifications in one window/tab will be reflected in the browser session;
    therefore, switching between tabs will lead to an apparently strange behavior,
    known as inconsistency of data. In case of using the session scope for request/view
    data, will also affect memory, since request/view scopes are meant to have a shorter
    lifespan than session scope.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with JSF 2.0, managed beans can be injected (dependency injection)
    into the property of another managed bean using the `@ManagedProperty` annotation.
    You already know that from the previous chapter, where an example is provided.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Another way to inject beans is to use the `@Inject` annotation, which is part
    of the CDI powerful injection mechanism.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: So when do we use `@ManagedProperty` and when do we use `@Inject` ? Well, we
    know that both of them do the same thing in different ways and different containers,
    so maybe it is a good idea to use `@ManagedProperty` when you are working in a
    servlet container or just don't need CDI. Another good argument for `@ManagedProperty`
    is that you can use EL with it. But, if you are in a proper CDI environment where
    you can exploit CDI benefits, such as proxy scope leak prevention or better deploy-time
    dependency, then use CDI.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'The pacifist approach will combine these two in the same application. In this
    case, you have two options: to avoid any interaction between the managed beans
    and CDI beans or, obviously, to encourage the interaction between them for better
    performance. If you choose the second option, then it is important to keep in
    mind some simple rules of injection as shown in the following figure:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '![Beans injection](img/6466EN_03_14.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have browsed through an overview of JSF/CDI scopes. It begins
    with an open discussion about JSF scopes versus CDI scopes, meant to provide a
    few advantages/disadvantages of choosing either one (or both). After a short overview
    of JSF/CDI scopes, each scope was detailed by covering fundamental knowledge,
    such as definition, usability, functionality, restrictions, and examples.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The chapter ends with a bunch of thoughts regarding beans injections. You can
    find several rules, tips, and bad practices commonly used in JSF applications
    mentioned out here.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next two chapters, where we will cover many kinds of JSF artifacts
    and configuration stuff.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
