- en: Microservice Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about what microservices patterns are. We will
    also compare these with the monolithic patterns, looking at the advantages and
    drawbacks of a microservices-based application, as well as learn when to use microservices.
    Furthermore, we will also demonstrate how to switch from a traditional monolithic
    application to a microservices application, using implementation examples throughout. We
    will then look at the design patterns used to compose the microservices. After
    reading this chapter, you will be able to identify the parts of an application
    code that are eligible to be microservices, and you will also know how to implement
    a microservices-pattern-based application using Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining microservices patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how microservices architecture works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining when to use microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and drawbacks of a microservices-based application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architecture patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining microservices patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many years ago, I had the opportunity to work as a system architect and developer
    on an administrative–financial system. This involved the use of modules, such
    as accounts receivable and accounts payable, inventory control, purchasing, payroll,
    accounting, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The whole system was composed of several modules, and the delivery of the system
    was constructed in a modular way too. At the end of the application development,
    we had a large, integrated system with many dependencies between the modules.
    It was obvious that the system should be integrated, and we knew that very well.
    However, this integration was made with many dependencies and a strong coupling
    between modules. Sometime later, we also discovered that the dependencies and
    strong coupling were unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: We faced a lot of problems in maintaining the application (such as difficulty
    in implementing new frameworks and excessive bureaucracy), including the fact
    that whenever there was a need to include a functionality that originated from
    a requirement, we had to find the part of the code that was responsible for the
    problem, make the change, test it, and make a redeployment of the entire application.
    In addition to this, other related issues sometimes appeared, such as using a
    third-party library or framework to implement this new functionality. There was
    a bit of bureaucracy to that too. In short, a lot of time was spent on changing
    the application, and this only got worse as the application became larger.
  prefs: []
  type: TYPE_NORMAL
- en: After the system was ready, we wondered what it would be like if each module
    had its own life—that is, if each module behaved as a mini-application, so that
    it could be deployed without impacting the other modules. Furthermore, if each
    module could be developed practically in parallel, and there was minimum coupling
    required, then that would be very beneficial to the development and maintenance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it back to the present day, we noticed that among the several characteristics
    that are most often desired for the components of a system, we can highlight low
    coupling, which guarantees parallel development and much better maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: There is an architecture pattern called *microservices architecture* that partitions
    the application into several small services that have specific functions or responsibilities
    with very low coupling between these services, and which provides very good features,
    such as excellent evolutionary maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to an architecture that is based on microservices, it is much
    easier to implement each of the modules of the administrative–financial application
    as mini-applications. An accounts payable module, for example, would need its
    front end, and would depend on the combination of some microservices (such as
    a service that provides the constant accounts, another that provides the variable
    accounts, another that provides the payroll, and so on) in order to work.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are advantages and drawbacks to the microservices-based approach,
    and we should look closely at an application to determine whether it is worth
    using this architecture. The architecture based on microservices acts as a counterpoint
    to the traditional monolithic architecture in which the modules are much more
    coupled. So to discuss the architecture of microservices and establish a better
    definition of what microservices are, we must talk about monolithic architecture.
    This is exactly what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a brief comparison between microservices and SOA. Some people like to
    refer to microservices architecture as a lightweight SOA. Both architectures aim
    to break a monolithic scenario to increase scalability and maintenance. However,
    while SOA is enterprise-oriented, where applications can speak more easily, microservices
    are small, integrated services that form one or more business functionalities.
    This is the main difference—microservices are the result of the functional decomposition
    of a monolithic application into small, smart, and loosely coupled (such as SOA)
    components with well-defined responsibilities and easy maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a monolithic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical application contains a presentation layer, which is the client side
    of the application, a persistence layer or database, and an intermediary layer,
    which is the server side of the application and contains the business logic. The
    layer that interests us is the intermediary layer. This receives the requests
    from the client layer, performs some business logic, accesses the database if
    necessary (executing queries and updates), and provides the result to the client
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: This server-side layer generally consists of several modules or services. Although
    the application has a modular architecture, the application is deployed and packaged
    as a monolithic block. Modules represented by classes and files are contained
    in packaging files (EAR, WAR). These files are deployed together and belong to
    the same deployment. Most Java-based applications are packaged in a single `.war`
    or `.ear` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an example of an academic–financial system in a
    college:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3be57cdf-3210-4813-837b-ca04056c6012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The various modules of the application are deployed to a single file on the
    **Application Server**. Generally, the application runs in a single process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62b64fd4-034f-49ee-b55a-2c9d32ee4075.png)'
  prefs: []
  type: TYPE_IMG
- en: For simple applications with a limited number of business tasks, the monolithic
    way of doing things such as coding (there is usually only one language for server-side
    coding, and there is a unique data persistence technology), testing, and deploying
    is also fairly simple. However, some serious problems appear as the application
    begins to grow in complexity and the microservices will also be used to solve
    these problems. Later in this chapter, we will have a specific section showing
    the advantages and drawbacks of microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty in implementing new features and fixing bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long application startup time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inefficient continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficulty using new frameworks and technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficulty in implementing new features and fixing bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, the application grows and more lines of code are added to preexisting
    codes. Even when approaching the code with caution using the best object-oriented
    practices and patterns (low coupling and code reuse), the number of classes and
    libraries tends to grow. Maintenance becomes much more difficult. Common problems
    may arise, such as an increase in the responsibilities of some classes. This issue
    is more critical because the development team always changes. The code becomes
    more difficult to understand and some required changes can be made incorrectly.
    As a consequence of this, we have a delay in implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Long application startup time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application gets bigger (more classes, libs, and files), its initialization
    slows down, and the developer will take a lot of time to start up the application.
    Doing this several times a day greatly increases development time, so this is
    another factor that impacts the maintenance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each required change in the application, you need to deploy it in its entirety.
    Continuous deployment is very difficult because every time a part of the code
    is changed, the entire application must be deployed. Of course, in a test environment,
    you can group multiple changes together and make a single deployment. However,
    this is still inefficient as it requires all implementations to be completed.
    This scenario becomes worse for applications that require a deployment to be in
    production several times a day.
  prefs: []
  type: TYPE_NORMAL
- en: Low reliability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modules of a monolithic application usually run in the same process. Any
    error or bug in a module (such as a memory leak) impacts the entire process and,
    consequently, the entire application. Even if an application is executed with
    several nodes of the clustering system, and even if there are several instances
    of the application, the problem can be propagated by the other instances of the
    application if the error is due to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty using new frameworks and technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a large monolithic application with thousands and thousands of lines of written code,
    replacing a framework or even including new features is difficult because it will
    require changes in many parts of the application. Sometimes we should rewrite
    almost all of the code; situations like this are very common. The quality of the
    product does not improve, and the effort to maintain this quality gets much higher
    because the development team does not have enough time to introduce the new framework.
  prefs: []
  type: TYPE_NORMAL
- en: The scale cube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Art of Scalability* by Martin L. Abbott and Michael T. Fisher presents
    a three-dimensional scalability model called the scale cube. See the following
    diagram for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/859f2c4f-d115-455f-9098-74995155afdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This model shows that we can scale an application in three different ways,
    which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***X-*axis scaling:** This is the most common model, and proposes the execution
    of multiple clones of an application under the supervision of a load balancer.
    This type of scalability is also called **horizontal scalability**, where the
    solution for meeting the demand is the addition of more servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Z-*axis scaling:** This is similar to *X*-axisscaling (multiple instances
    running the same code), but in this case, each server takes responsibility for
    a part of the data. This type of scalability uses the concept of sharding, most
    commonly in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***Y-*axis scaling:** This has the strategy of decomposing the application
    in different services. The architecture of microservices is an example of *Y*-axis
    scaling. Using this scalability approach, a monolithic application is decomposed
    into a set of services. Each service is responsible for a set of related functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What microservices actually are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define microservices architecture as a way to develop an application
    using a set of small, low-coupling, independent, and deployable services. Each
    microservice is very well-defined, meaning that each microservice is responsible
    for a single task that is well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: So, microservices are small components that perform a specific job and may be
    used to benefit a business. Therefore, when developing an application under the
    architecture of microservices, we must break this same application into small
    components that are the microservices. As well as the other characteristics that
    we will see later, microservices can be changed and deployed without degrading
    the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are not a silver bullet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any technological solution, there are advantages and drawbacks to microservices,
    which will be explored later in this chapter. If microservices are applied well,
    then they will increase the reliability and scalability of an application that
    grows in complexity. However, the very nature of microservices can bring problems
    when they are poorly implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The strong independence of microservices means that they can be created using
    different languages, and can communicate using different protocols and APIs. In
    addition, an application may contain numerous microservices that are used for
    the benefit of the business. The plurality and quantity of the microservices make
    the control of these same microservices quite complex. Some extra care and energy
    should be taken in the implementation of an application based on microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining how microservices architecture works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is still no formal model to follow when implementing microservices
    architecture, we can highlight some common characteristics. We can also verify
    good practices when developing microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'With one or more related functionalities, a microservice is a small portion
    of the application that is used to benefit the business. From this definition
    of microservices, we will now look at each of the following common characteristics
    of microservices in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The application is decomposed into smaller components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitask teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler and smarter processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized governance of libraries and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolutionary systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application is decomposed into smaller components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing an application based on microservices architecture, we should
    consider breaking the application into smaller components that will be changed
    and deployed separately (as opposed to a monolithic application that must be fully
    deployed with every change of code). However, splitting an application into small
    services that act independently requires a longer development time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the access of the client of an application to a
    business component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/799b5bef-8c91-4a3c-af2b-e6feea7000c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the same client accessing the same functionality
    via microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/106c1994-3abe-45a5-99ff-863d6d9d79c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because microservices are small and independent, they can cause problems with
    accessing more complex services. These problems are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calls to several microservices to meet a functionality**: Generally, clients
    need services or functionalities that involve calls to several microservices. For
    example, in an academic–financial management system, a client who wants rich detail
    on the history of a college student may have to access many microservices. So, making
    multiple calls to various microservices reduces network performance, and this
    is critical when there is a mobile client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices can use different protocols**: Because microservices are independent,
    they may require different protocols to be accessed, such as REST, WebSocket,
    and so on. In other words, there is no uniformity of protocol for accessing microservices,
    and we can imagine how time-consuming it would be to have to communicate with
    each of these microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Different types of clients**: There are different types of clients, such
    as mobile clients and desktop clients. Each of these clients also has different
    needs. The amount of information offered to a mobile client is generally less
    rich than that offered for a desktop client. Another important issue is that network
    performance is different for these different types of client. A mobile network
    is slower than a local network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see an example of a set of functionalities
    that are found in a system and their respective calls to the various microservices
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cde92e1-8972-4cc2-9d7f-4c92707806b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The price to pay for decomposing an application into a set of microservices
    is quite clear. Controlling the various calls to microservices is a complex task,
    and there is still the question of having a single database. In these cases, transaction
    control becomes more complex.
  prefs: []
  type: TYPE_NORMAL
- en: To meet this set of problems, there is a solution called the API gateway that
    establishes a type of frontend for the clients of the application based on microservices.
    The API gateway interposes between clients and microservices. Sometimes, the request
    is just a call to a microservice, but in other cases, the API gateway functions
    as a coarse granulation layer that receives the request to a service and makes
    several calls to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2623eee3-a700-40bd-8100-c6850b72f430.png)'
  prefs: []
  type: TYPE_IMG
- en: Access to the various microservices from the client application works in the
    same way as if we were using an API. The **API Gateway** is in charge of accessing
    the different microservices and worrying about the different protocols used for
    this access. However, depending on the type of client application (whether it
    is a mobile app or a browser application, for instance), a certain system functionality
    may be different. For example, if we are in a mobile application, the amount of
    information that would be consulted in accessing the student's history would be
    less than a browser application would access (either because the presentation
    screens are different or because of performance issues in accessing the various
    microservices). Taking this problem into account, besides being an interface layer
    for microservice calls, the API gateway can still offer a specific API for each
    type of client.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a client mobile would access a mobile API, while a web client or a browser
    would access a web API. We can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/871ac169-b065-4e3e-8341-06e5f81c2cfb.png)'
  prefs: []
  type: TYPE_IMG
- en: In short, the **API Gateway** works as a general translator. So, the client
    focuses on the business and not on the translation for the requests or the answers.
    In addition, the client can make one call instead of several calls (if the functionality
    requires numerous microservices), which effectively improves network performance.
  prefs: []
  type: TYPE_NORMAL
- en: Multitask teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a monolithic application, there are specialized teams in each part of the
    application—a database team, a team that develops in the backend (Java), and a
    design team.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservice-based application, there is a multitask team, which is responsible
    for all parts of the microservice. Consequently, the team must be a generalist.
    But we know that even for a monolithic application, the developer often works
    as a full stack developer, and has the task of developing all parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Product focus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a monolithic application, the focus is always the application project, and
    the code is usually delivered to the application customer. However, in a microservices-based
    application, the focus is always on the product. The team that is responsible
    for the microservice can change and evolve the product without the typical delays
    experienced in a monolithic application. The product belongs to the development
    team that is responsible for the microservice, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f03d386-d564-4ae1-92ca-04346ceda145.png)'
  prefs: []
  type: TYPE_IMG
- en: Simpler and smarter processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices perform specialized and intelligent tasks through an extremely
    practical operation—there is a request, something is processed, and a response
    is returned to the microservice client.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized governance of libraries and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are used and called in one or more points of an application, or
    they are used by various applications. Furthermore, we must keep in mind the independent
    nature of microservices. As a result, there is a natural encouragement for the
    decentralization and governance of APIs and libraries. This means that microservice
    developers should use the tools that they think are necessary for microservice
    development, as long as the interface with the client does not change.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice should always have a small set of responsibilities. This definition
    is based on a principle called the single responsibility principle, which states
    that *a class must have only one reason to change*. In other words, a class with
    more than one motive to change would have more responsibilities, and would not
    be cohesive. This would create problems, such as high coupling between the responsibilities
    of a class, difficulty in reusing code, and difficult maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class that had methods that are responsible for calculation, as well as methods
    for formatting the result, would be an example of a class with little cohesion.
    Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first method (`calculateCotation`) is directly related to the business domain
    and the others (`generatePDF` and `generateXLS`) are related to the presentation
    of the calculated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SRP principle is part of a set of five principles called SOLID principles,
    which were popularized by Robert Cecil Martin (colloquially known as Uncle Bob)
    after the publication of his book *Agile Software Development: Principles, Patterns,
    and Practices*. In fact, these five principles are a subset of several principles
    reported in the book. The SOLID principles are principles of object-oriented programming,
    a paradigm whose purpose is to keep code more organized and easy to read. We can
    make an association between the word "solid" and the expression "solid code".
    Each of the five letters of the acronym SOLID is an initial of a principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**ingle responsibility principle (SRP)'
  prefs: []
  type: TYPE_NORMAL
- en: '** O**pen closed principle (OCP)'
  prefs: []
  type: TYPE_NORMAL
- en: '** L**iskov substitution principle (LSP)'
  prefs: []
  type: TYPE_NORMAL
- en: '** I**nterface segregation principle (ISP)'
  prefs: []
  type: TYPE_NORMAL
- en: '** D**ependency inversion principle (DIP)'
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because an application is now decomposed into multiple microservices, there
    is a greater chance of failure because one or more microservices can and probably
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a microservice-based application should take this into account.
    A microservice is implemented in such a way that it has a small impact in the
    case of failure and there is a recovery as soon as possible. As a result, the
    microservices-based application must be developed with fault tolerance as its
    goal. Of course, such an implementation increases the complexity of development.
  prefs: []
  type: TYPE_NORMAL
- en: The recovery task is facilitated because of the nature of the microservice.
    Because it is a small service, it can be created or initialized quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservices-based architecture is ideal for systems that have increased
    requirements and functionality over time. Systems that have a significant increase
    in business need services that can be reused. They also need a clear separation
    between their responsibilities, which are offered precisely by microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Decentralized data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each microservice has its own database—that is, each microservice has its own
    way of managing data, instead of a single, centralized database for the entire
    application, or even for the whole company. This means that, depending on the
    services, the databases may be quite different. We can have a relational database
    (or more than one), we can have NoSQL of several types as a documentary database,
    a graph database, or other kinds of database.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining when to use microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Taking into account the characteristics of an application based on the architecture
    of microservices, we can establish some criteria of when to use microservices architecture,
    as shown in the following bullet list:'
  prefs: []
  type: TYPE_NORMAL
- en: When a system grows in its amount of requirements and functionalities, meaning
    that it has evolved quickly. In this case, the system begins to mix the responsibilities
    between its modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to reuse services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the centralization of the APIs begins to block the evolution of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is a need for new features, APIs, libraries, and frameworks, and
    we do not want to rewrite all of the software for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that we have a sensational and innovative business model, and we must
    quickly make an application available for customers to enjoy this business. The
    adoption of a monolithic model, in principle, would make the application develop
    quickly, with quick tests and deployments as well. At this point, we might not
    have to think about the evolution of the system—we now want to think about the
    company's financial goal. Unfortunately, immediate profit may obscure the development
    of software that could offer greater profits in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two conflicting issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Delivering the product quickly so you can reach customers, capitalize the company,
    and think about the evolutionary scale of the product later, running the risk
    of creating software with poor maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have identified the criteria for using a microservices strategy, spending
    more time developing the application based on microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, both the architecture and project management teams should have
    some questions in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Will the application evolve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the team multitask?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will much development time initially be spent on a microservices product
    compared to a monolithic product?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to decompose an application into microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have two possibilities for decomposing an application—Either there is a monolithic
    application and we want to decompose it into microservices, or the application
    does not exist and we want to use the microservices strategy to create it.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of existing monolithic applications, it is always possible to establish
    an intermediate stage, starting with a monolithic system to create a hybrid architecture,
    for example. At this intermediate stage, there may not be an immediate need or
    sufficient time to change the entire monolithic application and replace it with
    another one based on microservices architecture. For example, we have the critical
    issue of the single database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is not really a definite model for decomposition, but we can perform
    some tasks that may help:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking care of the process of extracting application modules that are candidates
    for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing a hexagonal model for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can be very varied. There are technical microservices that are
    used throughout the application and that meet nonfunctional requirements, and there
    are microservices that are related to the application business application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use two approaches in order to create business microservices—using business
    capabilities or use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business capabilities:** This indicates the ability to generate value for
    the business application. The decomposition is small and each service would have
    a larger scope. For example, in an application that manages a college, we can
    have the following business capabilities such as Professor Management Service,
    Student Management Service, Course Management Service, Student Financial Management Service, College
    Events Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case:** We can perform a decomposition in services based on the use cases.
    In this case, the decomposition is large. For example, a college might have a
    Student Enrolment Service, Payment of Monthly Fee Service, Test Review Service,
    and a Student''s Academic Situation Service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking care of the process of extracting application modules that are candidates
    for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we must extract the application components or modules with well-defined
    interfaces. These modules would be eligible to become microservices. Looking at
    these module interfaces, we have to try to find out which of the following two
    situations is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: The modules are independent, meaning that the services are well-defined and
    have few responsibilities. Here, we must take care not to generate monolithic
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules are reusable. Some clear examples of modules that can be reused
    would be modules with more technical tasks that are used throughout all of the
    application, such as a print service, an email service, a storage service, a document
    download service, and so on. Modules with a higher business content—such as a
    ticket payment service, a credit card payment service, and so on—can also be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the example shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11e28fe2-ca88-48da-bbd3-4b5d7beedd46.png)'
  prefs: []
  type: TYPE_IMG
- en: When creating technical microservices, we must be careful not to carry a functionality
    of the business along with it.
  prefs: []
  type: TYPE_NORMAL
- en: Once this first approach is made, we still have a monolithic block that represents
    the core business. We can perform a decomposition of this block based on business
    capabilities or use case, and we can also discover new business modules with well-defined
    interfaces. We can then have modules such as a **Student Status Service**, **Professor
    Service**, **College Event Service**, and **Financial Student Service**. In addition,
    we can have microservices of the business with finer granularity, such as a **Ticket
    Payment Service**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66164aec-c17a-4d22-8a54-ae93eed2650a.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, business-connected microservices must not carry the responsibilities
    of other microservice candidate modules. This means that we have to see the size
    of each microservice, and this is related to their own responsibilities. The microservice
    should have few responsibilities, characterizing a cohesive service (we always
    have to remember the SRP principle). One way to avoid dependent services is to
    remember the independent nature of microservices. If there are two microservices
    that need to be deployed together, or one does not exist without the other, then
    these services should most likely only be one service.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to obtain this decomposition is to design our application in the
    hexagonal model, which we will see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a hexagonal model for the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical application keeps its various functional modules together. Generally,
    this typical application has a hexagonal structure or architecture (we will see
    a better definition of the hexagonal architecture later) with the core business
    in the center of the structure. The core business contains all the management
    of the services offered by the application. There are also links with the various
    components external to this core, such as messaging services, database, client
    machines, and so on. These connections with the external world have specific adapters
    and protocols, such as a database adapter, REST API, Web API, Messaging API, WebSocket
    protocol, and so on, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7884783-f603-46d2-88aa-3d033c5599d1.png)'
  prefs: []
  type: TYPE_IMG
- en: The idea behind the hexagonal model is to isolate the application's core domain
    from access to technical infrastructures, such as the database, message queue,
    storage, and so on. As previously stated, once the core domain is isolated, we
    can analyze it more deeply and try to extract the services connected to the business.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and drawbacks of a microservices-based application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other technology, there are advantages and disadvantages in using microservices-based
    architecture. Several problems may appear during the implementation of microservices,
    but the advantages can overcome the complexity encountered during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of the microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Small multitask team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can be written in different languages. This is a positive point because
    depending on the service, a specific language may provide more tools than another
    in obtaining the functionality served by the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment is faster and integration is performed more automatically. Changes
    of requirements mean only the deployment of the related microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest libraries, frameworks, and technologies can be quickly used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater fault tolerance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice is related to the product and not to the project. The developer
    has more freedom and thus can develop the service more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The knowledge of microservices is transmitted more quickly to the development
    team. Consequently, the necessary changes and maintenance of the code are made
    more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks of the microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The independence of microservices can bring complexity because the services
    can have different protocols for both communication and data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The increase of microservices makes the control and management of these services
    more complicated. For example, In order to maintain fault tolerance, there must
    be more programming effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As well as the problem of services with different protocols, the communication
    between the services is also more complex because some application functionalities
    may involve calls to several microservices, worsening network traffic. The developer,
    in these cases, should use tools and strategies such as the API gateway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction control is a complicating factor, especially when migrating from
    monolithic systems to an architecture based on microservices—for example, in situations
    in which a particular functionality or use case needs several microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each microservice runs in a single process, which means increasing memory consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are more difficult to perform because the application is distributed across
    microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architecture patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that microservices architecture is based on the functional
    decomposition that produces independent, self-sufficient services that may have
    different ways of communicating with the outside world using well-defined interfaces.
    This favors low coupling and well-defined functions, allowing high cohesion (well-defined
    responsibilities with a reduced number of functions).
  prefs: []
  type: TYPE_NORMAL
- en: Although the services act independently, the purpose of these services is to
    create an application—that is, a set of business-related functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these characteristics, we can extract some patterns that can be used
    for the implementation of the microservices architecture. Here are some of these
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chained pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous messaging pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name itself suggests, this pattern establishes the existence or creation
    of a somewhat more complex service that invokes the functions of more internal
    services. Consequently, this aggregating microservice acts as an intermediary
    service that is a composition of other microservices, in the sense that it calls
    the microservices, obtains the individual responses from each microservice, and
    applies the necessary business rule, returning the final response to the client. Let''s
    look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7298a5f-3d9f-4276-bab5-0fd124ab5577.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram appears to show that a few parts of the solutions are repeated,
    which characterizes the existence of a design pattern. We can make a comparison
    with a microservice that acts as a business facade, calling specific microservices
    to perform a more complex functionality on an application business level. On a
    larger scale, this same aggregator microservice may act as a microservice individual that
    is called by another aggregator microservice at a higher level. It is clear that
    having great knowledge of the application's business rules is vital.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is a variation of the aggregator pattern, but with one important
    difference. There is no data collection for all the internal microservices, meaning
    that there is no aggregation. The proxy pattern directs the call to a specific
    microservice and the analysis of the request is what determines which microservice
    should be called (a typical behavior of a proxy pattern).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there may be some benefit in the implementation of this proxy. Immediately
    before the response is returned to the client, there may be a transformation of
    this response to the format expected by the requesting client. Remember that different
    clients (including web browsers, mobile devices, and so on) can make the request. Let''s
    look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/926052e2-307e-4fda-831a-a2400c6604f7.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now see why an API gateway is clearly based on aggregator and proxy patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Chained pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the chained pattern is to present a more consistent and definitive
    final response to the client using a chain of services that communicate sequentially.
    In this way, **Service A** that acts as a first service in the chain communicate
    with **Service B**. **Service B** communicates with **Service C**, and so on.
    The calls are synchronous and the client remains locked until the final response
    returns from **Service A** to the client.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note here that the requests that arrive at the chain services
    may be different. In this way, the request sent from **Service A** to **Service
    B** may be very different from the request sent from **Service B** to **Service
    C**, and so on. In the same way, the response of the services may also be different.
    The response from **Service C** to **Service B** may be different from the response
    from **Service B** to **Service A**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbfeb09a-9a91-4be8-b976-bc725f6b5280.png)'
  prefs: []
  type: TYPE_IMG
- en: A practical example of this implementation is the generation of data for the
    printing of bank slips. Let's suppose that a bank provides two soap web services.
    One for registering the bank bill data in the bank and the other for getting the
    bank bill data registered with the bank. Our application contains two defined
    microservices—**Service A**, which registers the bank bill data in the data bank
    (that is, it calls the first registration web service); and **Service B**, which
    gets the definitive bank bill data, such as the code bar (meaning that it calls
    the second query web service), and returns the data for the bank bill generation.
  prefs: []
  type: TYPE_NORMAL
- en: A client application informs the bank data of a user to **Service**** A**. **Service
    A** is responsible for registering with the banking institution and, with the
    return of this registration, **Service A** makes a request to **Service B**. **Service
    B** then gets the definitive data for the generation of the bank bill. **Service
    B** passes this data to **Service A**, and it can then apply some transformation
    to that data and return it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: This same example can be implemented using the aggregator pattern. However,
    whenever a sequential order of steps is required to produce a final response,
    we can think of the chain pattern as a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Branch pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The branch pattern works as an extension of the aggregator pattern and can
    call different service chains in parallel. In the branch pattern implementation
    example, a first service, called **Service A**, is called by the client and can
    act as an aggregator, calling service chains to compose the response. Alternatively,
    based on the request, a specific service chain is called, thereby acting as a
    proxy pattern. Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4891478c-fe9f-4e96-974b-d9e3cc9870bb.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, the main difference between the chain pattern and the branch pattern
    is the calling of different microservice chains. However, if we make an abstraction,
    and consider each chain as an individual microservice, in essence, we will have
    an aggregator or a proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we think of microservices in practical terms, we immediately think of
    microservices implemented using the REST protocol. However, microservices based
    on a REST pattern are synchronous and therefore blocking. Sometimes, we need microservices
    that can be called asynchronously. The asynchronous mechanism is developed with
    techniques that are specific to each application (message queue, sending asynchronous
    events, and so on). Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce831d37-99a1-4052-aa9a-d713ea877f37.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Service A** receives the request from the client and calls **Service B**
    in a synchronous manner. However, **Service B** depends on **Service C** and calls
    it asynchronously through a message queue, for example. **Service C** reads the
    message from the queue, does the required logical processing, and also returns
    a response to **Service B** using the queue mechanism. (We should always keep
    in mind the independence of the services that are being called.)'
  prefs: []
  type: TYPE_NORMAL
- en: A way of communicating between **Service B** and **Service C** could be that
    **Service B** sends a request message to a `QRequest` queue and listens for a
    response from a `QReply` queue. **Service C** then reads the request message from
    the `QRequest` queue, performs the necessary processing, and sends a response
    to the `QReply` queue. **Service B** reads the response message from the `QReply` queue,
    applies a transformation or adds some other information, and then sends the response
    to **Service A**. It is clear that the specific details of this implementation
    should be taken into account, such as waiting for **Service C** to time out.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind the implementation of microservices in our example is to implement
    a microservice that provides the bank data for a client to generate a payment
    slip. The data returned will be the barcode of the payment slip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bank provides two SOAP web services, one to register the payment slip with
    the bank and one to provide the data for generating the payment slip that was
    already registered. As a result, we will make two microservices, one for registering
    the payment slip data and another for the query of the payment slip that was already
    registered. Each of these microservices will call the related web service. Next,
    we will construct a third, more complex microservice that will add two calls:
    a call to the registration microservice and another to retrieve what was registered.
    Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/260e087a-54a7-43c8-abe8-a4926fbc13e0.png)'
  prefs: []
  type: TYPE_IMG
- en: We could, in fact, make a microservice chain here; however, we opted for the
    aggregator pattern because we assume that multiple payment slips may have been
    previously batch-registered.
  prefs: []
  type: TYPE_NORMAL
- en: We will make three classes—one for each microservice. Each microservice will
    be implemented as a REST resource. To make the code simpler, we use only one request
    class and only one response class for the two microservices; the registering and
    querying microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payment slip registering class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the payment slip query class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the aggregator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Any client can then call this aggregator microservice in order to obtain the
    barcode and other information to generate the payment slip.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In almost every section of this book, we have shown that, besides being solutions
    to recurrent problems, patterns aim at the reuse of and low coupling between application
    components. Following this principle, the decomposition of an application into
    small independent parts that perform intelligent and specific tasks allows this
    application to evolve in a natural and organized way. These small parts with specific
    tasks are called microservices, and the method of developing a system based on
    the decomposition of the application into these small parts is called microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: However, like any technology, there are pros and cons to this. Developing an
    application and thinking about the control of the various microservices is a complex
    task, but once the microservices are well defined, the application is able to
    evolve much better than a monolithic application. In this way, the maintenance
    of the application is done more quickly, with the addition of new functionalities
    and the updating of the current functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The inclusion of new frameworks, APIs, and libraries is done much more quickly
    thanks to the decentralization of microservices. Teaching microservices to future
    development teams is also faster and easier, and deployment is also faster because
    there is no need to redeploy the entire application because of a change in one
    part of the application. We also looked at a mechanism called an API gateway.
    The API gateway establishes a type of frontend for the various clients of the
    application based on microservices, translating the clients' calls to the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we looked at some of the main design patterns that
    are used in the development of the microservices architecture, such as the aggregator
    pattern, the proxy pattern, and the chained pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter, [Chapter 8](91a5c7ea-6a16-4af1-b89a-0f918d4feb4e.xhtml), *Cloud-Native
    Application Patterns*, will address the cloud-native application pattern. Here,
    we'll look at a cloud application, as well as some of the key patterns that must
    be followed when developing an application in the cloud.
  prefs: []
  type: TYPE_NORMAL
