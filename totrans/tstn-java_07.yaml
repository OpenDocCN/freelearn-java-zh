- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Syntax and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin by looking at the syntax of the Java language.
    It might seem strange that it took till this chapter to look at syntax. To understand
    why, I must let you in on a secret: you already know how to code. This is the
    audience this book is for – you can program but have little or no experience with
    Java. I have no doubt that you could understand what was happening in every code
    sample you have seen so far. We will now formalize the Java syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coding structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to organize Java code into methods
    and classes. Decision-making and iteration in Java code are presented. When things
    go wrong, there can be, in many situations, the need to leave the code that caused
    the error and either carry out additional processing to solve the problem or exit
    the program. This is the role of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code from this chapter in the GitHub repository at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coding structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write code in any language, we know that it must be organized in very
    specific ways. You are familiar with this concept from whichever language or languages
    you already know, so all we must do is examine how they are coded in Java. We
    begin with code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Code blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every language has a structure for organizing the lines of code you write, and
    this is commonly called a `begin` and `end` keywords. Java uses opening (`{`)
    and closing (`}`) braces, as do C, C++, C#, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, all classes and methods must have an opening and closing brace. Blocks
    may be nested, as we will see when we examine iteration and decisions later in
    this section. Blocks also serve another purpose when it comes to variables. This
    is called the variable’s scope. Let’s look at this in practice in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss each line in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 1* declares a class named `Blocks`, and an opening brace appears on this
    line. C/C++ programmers typically place opening braces on their own line, and
    Java is fine with this. The Java style is to place an opening brace on the same
    line that names the block.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 3* declares an instance field. We know this because it is declared inside
    the class block and is not static. For every object, there will be a unique `classScope`
    variable. As this field is in the class block, it is visible to all non-static
    methods in the class. It is also available to any inner blocks in any method.
    It only goes out of scope when the object instantiated from this class goes out
    of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 4* declares a static or class variable. This variable will be shared
    by all instances of the class. It is visible in all blocks in the class. One thing
    it cannot be is a local method variable. Static variables can only be declared
    in the class block or scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 6* through *9* declare a static block. The code in this block is only
    ever executed once when the first instance of this object is created. You cannot
    declare fields in this block. You cannot interact with instance (non-static) variables,
    but you can interact with class (static) variables. You may also call upon static
    methods such as `System.out.print` or any static methods in this class. An interesting
    characteristic of static blocks is that they execute before the constructor. This
    is why they cannot access non-static variables and methods. These non-static variables
    are only valid after the constructor executes, not before.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 11* through *13* are just a constructor. If you add a `main` method
    to this example, you will be able to see that the static block always executes
    before the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 15* through *26* are a non-static method block named `perform` that
    in turn contains two additional blocks. In the `method` block, we have the `methodScope`
    local variable that is visible and accessible in the method and in any inner blocks.
    This variable will go out of scope when the execution of the method reaches the
    closing brace of the `method` block.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 18* through *20* consist of an `if` statement followed by a block that
    is executed should the `if` statement be `true`. In this block, we have declared
    a variable named `blockScope`. This variable comes into scope after the opening
    brace is encountered and the declaration is found. When the block ends, this variable
    goes out of scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 22* through *25* are another block. In here, we are declaring a variable
    of the same name and type as the class-scoped variable. When this occurs, the
    block version of a variable hides any variable declared in an outer block, which
    in this case is the class itself. To access the class block variable, as we have
    seen when we discussed methods, we use the `this` reference. If you create more
    blocks in blocks, which is not really a good idea, you can only access the class
    level variable with `this`, and any variable of the same name and the type in
    outer blocks becomes inaccessible.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, let’s briefly review the meaning of the terms *statement* and *expression*
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, any line of code that performs a task and ends in a semicolon is a
    statement. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are all statements. *Line 1* is a declaration statement where an integer
    variable is assigned space in memory and a value is assigned to it. *Line 2* is
    a call to a method. *Line 3* uses the square root method from the `Math` library
    to compute a result that you are assigning to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An expression in Java is any code that returns a result as part of a statement.
    The result may be from an assignment, some simple math, or as the return value
    from another method or Java construct, such as the `switch` expression that we
    will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in the *Statements* section, we can see that the *line 1* statement
    includes an expression that assigns a value to a variable. *Line 2* is just a
    statement as there is no value that is changing. *Line 3* takes the value returned
    by the call to `Math.sqrt` and assigns it to a variable. When we assign a new
    value to a variable, we describe this as changing its state. Statements that change
    the state of a variable do this with an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s family of operators is quite like what is found in C and most other languages
    derived from C/C++ or modeled on them. The rules of precedence are respected,
    and expressions inside parentheses are always carried out first. All the standard
    logical operators exist. As Java does not have pointers, operators that deal with
    pointers, such as the address of (`&`) and the indirection (`*`), do not exist
    in this language. There is one group of operators that I do want to highlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C/C++, we express the outcome of combining multiple Boolean expressions
    in one of two ways—either logical `AND` or logical `OR`. They are expressed as
    a double ampersand (`&&`) and a double pipe (`||`). They employ short-circuit
    evaluation, which means if there’s a condition that validates or invalidates the
    statement in the first comparison, then there is no need to carry out a second
    comparison. The values on each side of the operator must be Booleans. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is a matching set that can perform the same task but without short-circuit
    evaluation. These are the single ampersand (`&`) and the single pipe (`|`). When
    working with primitive types, they perform a bitwise operation. For the single
    ampersand (`&`), there must be a binary 1 in the same position in each value that
    becomes a binary 1 in the new value. Otherwise, a binary 0 is placed in the new
    value. For the single pipe (`|`), the matching bits must have one of the bits
    as a binary 1.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more operator in this family worth mentioning and that is the caret
    (`^`). This is the `XOR` operator. As used with the primitive types, the new value
    takes a binary 1 only if one of the two values being compared has a binary 1 in
    the same position. Otherwise, the result is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, there is a hierarchy of the numeric primitive types—as listed next—based
    on their size in memory and the range of allowable values. We saw this earlier
    in [*Chapter 4*](B19088_04.xhtml#_idTextAnchor086), *Language Fundamentals – Data
    Types* *and Variables*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`char`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assignment statements have a right-hand side and a left-hand side, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*LHS =* *RHS*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this list, you can only have a type on the LHS that has a larger range
    of values than the type on the RHS. This means you can write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the conversion from `int` on the RHS to `double` on the
    LHS is lossless. In the other direction, as shown next, it will be an error because
    the fractional part of `double` will be lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This all leads to the casting operator—the parenthesis plus type. The parenthesis
    is also used in other ways but when used here, it becomes an operator. To make
    the previous example work, you can cast `double` to `int`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a lossy conversion as the fractional component of the `double` value
    is sliced off, with no rounding. The value that ends up in `intValue` will be
    `23`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more operator—the arrow operator (`->`), which we will encounter
    when we examine the modern switch and functional programming. Let’s now move on
    and examine iteration, commonly called looping.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java provides us with two approaches to iteration. The first, which we will
    look at now, is the classical looping technique. We will examine using streams
    to iterate over every member of a collection in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin with the C-style `for` loop. This is a loop where the conditions
    for iteration are in the first line of the loop inside parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire `for` loop is considered a block. This means that an `x` variable
    is created when the `for` loop is entered, and it goes out of scope when the loop
    ends. If you need access to `x` after the loop ends, then declare it before the
    loop, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two special statements available in classic loops:'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement will end a loop before it finishes iterating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `continue` statement ends the current iteration of the loop and moves on
    to the next iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foreach loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more style of the `for` loop, called the `foreach` loop. It is
    predicated on the fact that every element in an array or collection will be processed.
    We will examine the `foreach` loop when we look at collections in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The while and do/while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a `for` loop is written, the maximum number of iterations is known right
    away. For our next loops, `while` and `do`/`while`, the number of iterations cannot
    be predicted as it will depend on something changing in the body of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In using `while` and `do`/`while`, the loop is dependent on something happening
    inside the loop block, which may change the variable that is being logically examined.
    Here is an example with an unpredictable ending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line instantiates the `java.util.Random` object. Next, we instantiate
    the variable that will be the basis of the logical test and give it a random value.
    The method call to `rand.nextInt(12)` will return a value with a range of 12 possible
    integers between 0 to 11 inclusively. This points out that a `while` loop can
    iterate zero or more times, but it is not possible to predict how many iterations.
    We express the logical test in the parentheses of the `while` statement. Inside
    the loop, we must perform some action that alters the state of the `x` loop variable.
    There are no restrictions on what you can code in the `while` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variation of the `while` loop is the `do`/`while` loop. This loop is guaranteed
    to iterate at least once as the logical test occurs at the end of the loop. You
    can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike the `while` loop, there is no need to initialize the loop
    variable as it will get its first value inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decision-making syntax in Java supports three structures available in C/C++
    and other languages. They are the `if`/`else` statement, the `switch` statement,
    and the ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `if` statement does not require an `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an either/or expression using `else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simplify this example by using the ternary operator, which uses a question
    mark and a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It begins with the logical test. While using parentheses in this situation is
    optional, I strongly recommend using them. After the question mark and on either
    side of the colon are the values that will be returned by the expression. You
    may also call a method if it returns a value of the appropriate type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need to define a test for ranges of value, you can use the `if`/`else`/`if`
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the C-style switch. As of Java 17, the syntax of the C-style switch
    can be considered obsolete. The fact that the new versions of the switch are recent
    additions makes it important that you understand the C-style version. A switch
    is a logical structure for comparing the `switch` variable to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A literal integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer constant variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a switch to determine the postal rate, which depends on the zone the
    mail is being sent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines that end in a colon are referred to as conditional labels. Should
    the `zone` variable’s value match the literal, then the code that follows the
    matching case is performed. When such a match with a case is found, all subsequent
    cases become `true`, regardless of the case value. Therefore, there is a `break`
    statement at the end of every case. You can simulate a test against a limited
    range of values by purposely not using a break everywhere, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As of Java 14, two new versions of the switch were introduced. These are the
    new `switch` expression and new `switch` statement. This will also be the first
    time we see the new arrow operator. Here is the expression version of the switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The break is gone as any match will end the switch. To match one of multiple
    items, we can use the comma operator to create a list. The arrow operator (`->`)
    points at the value that will be assigned to `continent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a `switch` expression, a `switch` statement does not return a value,
    but the matching case performs some action such as calling a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the new `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another type of switch that, as of this writing, is only available
    as a preview feature in Java 19, and that is the pattern-matching switch. As a
    preview feature, it may change when it becomes formally part of the language or
    even dropped from the language. I see this as an exciting new type of switch—you
    can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching will only work with objects and not primitives unless they
    are in one of Java’s primitive wrapper classes. When we assign the value `4` to
    the variable value of type `Object`, the compiler will auto-box the `int` primitive
    into an object of type `Integer`. Each `case` statement uses the class type in
    the case rather than a literal value. It also allows you to assign an identifier—in
    our case, `i`. Following the identifier is the new `when` keyword, after which
    you can write any valid Boolean expression. Only if the type matches and the logical
    expression after the `when` keyword is `true` is the case `true`. This should
    reduce the number of `if`/`else` `if`/ `else` `if`/ `else` `if` structures in
    your program. You will need Java 19 installed on your computer to experiment with
    this preview feature.
  prefs: []
  type: TYPE_NORMAL
- en: With how Java handles decisions out of the way, we can now look at how Java
    handles exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, when things go wrong, they can be classified as errors or exceptions.
    An error is a problem that cannot be recovered from. An exception is an error
    that can be detected in your code such that you can possibly recover from it.
    For example, a recursion that never ends will result in a `StackOverflowError`-type
    error. Converting the `Bob` string to an integer will result in a `NumberFormatException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of the primary exception classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The exception hierarchy](img/B19088_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The exception hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are objects of classes named after the type of exception that has
    occurred. In the diagram, you can see that at the root of the hierarchy is the
    `Throwable` class. From `Throwable`, we have two subclasses: `Error` and `Exception`.
    The subclasses of `Error` are named after the errors that may occur during program
    execution. These are errors that generally cannot be recovered from and should
    lead to the program ending.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it may be possible to recover from an exception as opposed to an error,
    these types of problems belong to the `Exception` branch. This branch is divided
    into two categories: `try`/`catch`. Failing to use a `try`/`catch` block will
    generate a compiler error. You must resolve this; otherwise, you cannot compile
    your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions do not require a `try`/`catch` block. The compiler will
    happily compile code that might generate an unchecked exception without this code
    in a try/catch block. Should you decide not to handle an unchecked exception,
    your program will end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at code that could have both types of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s review the important code lines.
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 3* is the first method that contains code that could result in a checked
    exception being thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 4* declares a `List` variable and sets it to `null`, which sets the `List`
    reference to zero. Local variables are not initialized, so they may already contain
    a value based on where in memory the reference is placed. If you do not properly
    allocate the `List` reference, usually done with `null`, there will be a compiler
    error in *line 11*. This will end the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 5* defines a path to a file. The `Paths.get()` method does not verify
    that the file exists, so no exception is thrown if the file does not exist.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 6* is the beginning of our `try` block where any code that may throw
    a checked exception is written. You may have lines of code in a `try` block that
    do not throw an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: In *line 7*, using `Files.readAllLines()`, each line in the file is added to
    the `List` variable. This is where an invalid file `Path` object can result in
    a checked exception named `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 8* is the end of the `try` block and the beginning of the first `catch`
    block. A `catch` block takes as a parameter a reference to an `Exception` object
    that is created by the JVM when the exception is detected in the code inside the
    `try` block while the program executes. The `NoSuchFileException` exception is
    a subclass of `IOException`. Subclass exceptions must be handled before the superclass
    exception.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 9* is the body of a `catch` block, where you can write code to handle
    the error in such a way that the program does not need to end. All `Exception`
    objects have a method that displays the stack trace. You will not handle errors
    this way in production. When we discuss logging in the next chapter, we will see
    a best-practice approach.'
  prefs: []
  type: TYPE_NORMAL
- en: In *line 10*, we have a second `catch` block. This is the `IOException` class.
    The code that reads the file can throw either a `NoSuchFileException` exception
    or an `IOException` exception. Some programmers may just catch `IOException`.
    As `NoSuchFileException` is a subclass of `IOException`, polymorphism allows you
    have both exceptions caught in one `catch` block that expects `IOException`. My
    preference is to use specific exception classes where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in *line 9*, here, in *line 11*, we are just printing the stack trace
    if this exception is caught here.
  prefs: []
  type: TYPE_NORMAL
- en: It is in *line 13* that a compiler error can occur if the `fileContents` variable
    is either not assigned `null` or assigned a reference from calling the `File.readAllLines`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: During development, the use of the `printStackTrace` method in an `Exception`
    object can be useful. When we move to production code, we should never make this
    method call. In the next chapter, we will see how to use logging to preserve this
    information without it appearing in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 16* is a method that will perform division by zero. This will generate
    an unchecked `ArithmeticException` exception. For this reason, you are not required
    to use a `try`/`catch` block. As the code is dividing by zero, an exception will
    be thrown, a stack trace will appear if this is a console application, and the
    program will end. A GUI program has no place to show a stack trace, so it will
    appear to just end suddenly.'
  prefs: []
  type: TYPE_NORMAL
- en: The stack trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your program ends due to an exception or after catching an exception,
    you can display a stack trace. The stack trace will appear in the console window.
    It is a list of every line of code that led to the exception before being caught
    or after the program ends. Here is the stack trace from the `doCheckedException`
    method when the filename in the `Path` object cannot be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The stack trace explicitly displayed when an exception occurs](img/B19088_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The stack trace explicitly displayed when an exception occurs
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the exception has traveled through several methods, many of
    which occurred in a Java library and not your code. To use this information to
    locate the possibly offending source code, go through the list and locate the
    first entry that comes from your code, starting from the beginning of the trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This line tells us that the exception happened in the `doCheckedException` method
    on *line 17*.
  prefs: []
  type: TYPE_NORMAL
- en: Ending the program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some situations, you may wish to end a program after catching its exception.
    You can end most programs with `System.exit(n)`, where `n` is a number you assign
    to this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The number—in this example, `12`—maps to a known error condition that must end
    the program. Here, after the stack trace is displayed, the program ends.
  prefs: []
  type: TYPE_NORMAL
- en: The throw and throws statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If an exception is thrown in a method, Java looks for a `catch` block. If there
    is no `catch` block in the method that threw the exception, then Java looks into
    the method that called the offending method. This continues until it gets to the
    `main` method, and at that point, the program ends. There are situations where
    you will want to catch an exception where it happens, but then you want to re-throw
    it to whatever method that came before it that has a `catch` block. In this `catch`
    block, we are displaying the stack trace to the console and then re-throwing the
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to re-throw, we must add to the method a `throws` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `throws`, whichever method calls `doCheckedException` must do
    this in a `try`/`catch` block, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `throws` clause to define that a method has a checked exception,
    but it will not be handled in the method. This means we can just call `checkedException()`
    without a `try`/`catch` block, as the method shows that it will be thrown to whichever
    `try`/`catch` block in another method called this method.
  prefs: []
  type: TYPE_NORMAL
- en: The finally block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be a third block for handling exceptions, called the `finally` block.
    In this block, you can write any code that you wish to execute if an exception
    is thrown or not. In this example, a message is displayed regardless of whether
    an exception is thrown or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the divisor is valid—not zero—then the code in the `finally` block is executed.
    If the divisor is invalid—is zero—the code in the `catch` block is executed followed
    by the code in the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse `finally` with the `finalize` method. The `finally` block is
    useful. The `finalize` method is not useful and should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own exception classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name of an exception class is the description of the problem that led to
    the exception being thrown. You can create your own exceptions and then throw
    your custom exception when you detect a serious problem in your code. The first
    step is to create an exception class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a checked exception class. If you do not want it to be checked, then
    extend `RuntimeException`. You can add additional methods or override methods
    in `Exception`, but this is not necessary. You create custom exceptions to define
    exceptions unique to your program that are not sufficiently described in the existing
    family of exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some code that will throw this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need code that will call this method. As the method we are calling
    has a `throws` clause, we must treat it as a checked exception, and we must use
    a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the stack trace that occurred when this code executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the exception class we created is the exception reported in
    the stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: There is one last issue to point out in regard to exceptions. Many languages
    such as C# and JavaScript do not have checked exceptions. The decision to catch
    these exceptions is solely at the discretion of the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an exception is a slow process in the JVM. It is not something you
    might notice, but if it happens often enough, it will result in slower execution
    of the program. For this reason, never use exception handling as part of the program
    logic. Exceptions are serious issues that, in most cases, imply an error or bug
    that can affect the outcome of the program. If you can detect an error in your
    code, typically by testing a value with an `if` statement, you should handle it
    with the code you write and not by expecting or throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how Java code is organized into blocks as
    defined by an opening and closing brace. The blocks can be an entire class, each
    method in the class, and a body of iteration and decision statements. From there,
    we learned how to classify lines of code as statements or expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Operators were the next topic. We reviewed the math and logic operators and
    how they are combined. The `cast` operator for converting from one type to another
    was also shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up were the two most common coding structures: iterations and decisions.
    The classic `for` loop, a loop where the number of iterations is known before
    the loop begins, was presented. The second style of loops was `while` and `do`/`while`
    loops. These loops do not know how many iterations there will be. This is determined
    in the repeating block of code.'
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making was next up. We looked at the `if` and `if`/`else` statements.
    These are effectively the same as found in any language that traces its lineage
    to the C language. The second decision structure we covered was the `switch` statement.
    As with `if`, it is virtually unchanged from its C roots. The good news is that
    this style of switch has been enhanced with three new versions.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic we looked at was exceptions. We looked at what exception classes
    and objects are and which category, checked or unchecked, they fall into. How
    we can handle exceptions rather than just let the program end was presented as
    well. Creating our own named exceptions and how we can use them was the last topic
    we covered.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should feel comfortable reading Java code. In our next chapter,
    we will look at additional features of the language and how they can be used to
    write cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Exceptions in* *Java*: [https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45](https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
