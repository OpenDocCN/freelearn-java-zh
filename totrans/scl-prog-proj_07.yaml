- en: Online Shopping - REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain how to develop a REST API using Play Framework.
    **API** is an acronym for **Application Programming Interface**. The **REST**
    acronym stands for **Representational State Transfer**. Basically, we will provide
    an interface for our application, so that other programs can interact with it.
    REST is an architectural pattern that will guide us in designing our API.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a program calling our API will be a user interface running in a browser,
    which we will implement in the next chapter. It could also be another backend
    application, which could be from another program, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: REST principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the API with persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying on Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The objective of the REST API is to interact with the shopping cart from the
    user interface in the browser. The main interactions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, removing, and updating products in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will design our API by following REST architecture principles which was defined
    in 2000, by Roy Fielding.
  prefs: []
  type: TYPE_NORMAL
- en: A formal description of the REST API can be found in *Fielding Dissertation,
    CHAPTER 5, Representational State Transfer (REST)*, at [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main principles of the architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is based on client-server architecture, which means that a server can serve
    multiple clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be stateless—the server should not keep any context between client
    calls. The context should be kept by the client. All of the information required
    for the processing on the server should be part of the message sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As no context is kept on the server, it should be possible to cache responses
    at the server level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each resource on the system should be identified uniquely. Since our resources
    are web resources, we use a **Uniform Resource Identifier (URI)** for that purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keeping all of the preceding in mind, let''s design our API. In [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, two tables where defined:'
  prefs: []
  type: TYPE_NORMAL
- en: The cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, in this chapter, we will keep these two objects to design our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the cart, we would like to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the quantity of a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a list of products in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the product, we would like to perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: List the products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's write the tests. We will create one test per API call, to cover
    all the cases. By doing so, we are going to define the URI for each case. All
    of the test implementations will be grouped in a test class; let's call it `APISpec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the class and define the URLs of our API; at this point, the `APISpec` class
    should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As in `DatabaseSpec`, we extend the ScalaTest integration class, `PlaySpec`,
    as well as a Play server, `GuiceOneServerPerSuite`, and define all of the URLs
    required. We defined the `wsClient` value, a helper from Play, to define a web
    service client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with a test of the product API, and, more precisely, with the
    list of products. The test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`WSClient` is a convenient class to perform a REST call; we just need to set
    the URL and call the HTTP method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `add a product` case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the new product to insert. Notice that we are using a string
    representation of the new product, using the JSON format. We could have defined
    it as an object, but that will be covered later in this chapter. To add something
    to the database, we are using the `HTTP POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now done with the product section. Now, we need to add new tests for
    listing all of the products in a cart, adding a product to the cart, deleting
    a product from the cart, and updating the quantity of a product in the cart. The
    corresponding unit tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have defined basic tests for all of the functions. When we run `ApiSpec`,
    all of the tests will fail with the error `404 was not equal to 200`. This is
    expected, as no route has been defined in Play.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define all of the URLs of our API in the `config/routes` file. In this file,
    we define the mapping between the URL and the code. In our example, the file looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more clarity, we squeezed the `controllers.WebServices` package to `W`,
    to fit the page width.
  prefs: []
  type: TYPE_NORMAL
- en: For each line, if it starts with `#`, the line is a comment; otherwise, the
    first column defines the HTTP action to perform, followed by the context URL.
    Finally, the last column is the method to call with the parameters, if any.
  prefs: []
  type: TYPE_NORMAL
- en: At the URL level, you can use the wildcard, `:`, to define a variable in the
    path; this variable can be used in the method call. For example, the `id` variable
    is defined in the `cart/products/:id` path, and then used in the `controllers.Cart.deleteProduct(id)`
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: We have now defined the route that Play is going to create; the next step is
    to define the methods defined in this routing file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, create a new file, named `WebServices`, in the `controllers` folder.
    In this file, the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have defined all of the methods, but instead of coding the details of all
    of the implementations, we will set it to `play.mvc.Results.TODO`. At that point,
    we can try to run the test, to make sure that we do not have any compilation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When running the test, `APISpec`, you should not get 404 errors anymore. However,
    the tests should now fail with the error 501 was not equal to 200.
  prefs: []
  type: TYPE_NORMAL
- en: This is expected. The server can now find the URL mapping for our REST calls,
    but in our code, all methods are implemented with `play.mvc.Results.TODO`. This
    special return value makes the server return the HTTP status error code 501.
  prefs: []
  type: TYPE_NORMAL
- en: What have we achieved? Well, Play is serving all of the URLs of our API. For
    each of them, it calls the associated method, and returns an error code instead
    of the real implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Checking the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it might be interesting to introduce external tools to check
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, these tools are widely used and can make your life easier, especially
    when you want to explain it to someone or perform multiple calls on a different
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paw**: This is a paid tool and only works on macOS. You can look upon it
    at [https://paw.cloud/](https://paw.cloud/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman**: This is a free and multiplatform application. Postman is a Google
    Chrome extension. You can look upon it at [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once one of these tools installed, start the project in IntelliJ, and then
    browse to, for example, `http://localhost:9000/cart/products`. You should receive
    the error 501 Not Implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e33a3eec-e74b-4a1a-a570-de1cd9fae4ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Observe the error in the TODO section
  prefs: []
  type: TYPE_NORMAL
- en: All of the defined URLs will have the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this tool is that you can see all of the details of the request
    and the response. It is very useful to understand the HTTP protocol with all of
    the headers, URL parameters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API with persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created the route for the API without an implementation.
    In the previous chapter, [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, we created the database to persist the carts. It is now
    time to bind the API with the persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the product tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to check not only the HTTP status but the content received back; for
    example, for the list of products, we would like to make sure that we are receiving
    all of the default products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we look at the body of the response and make sure that the three
    default products are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to check the `add a product` function, we first add the product,
    and then call the list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the product API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the tests are ready, so let's implement the API for all the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Product list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first method that we are going to implement is the list of products. As
    you will remember from [Chapter 6](3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml), *Online
    Shopping – Persistence*, we created a list of default products upon the creation
    of the application. Hence, our first task will be to get these products and send
    them back as JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already written a data access layer, the extraction from the database
    is pretty simple. Indeed, we just need to call the `all()` method from the product
    DAO instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `productDao.all()` method returns all of the products from the database
    as `Future[Seq[Product]]`. We can reuse what we learned in the previous chapter
    and use the `for` comprehension to extract, in the `products` variable, the sequence
    of products from `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: From the `products` variable, thanks to `.mkstring(",")`, we return a string
    with all of the products, separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: But we are not quite done yet. We mentioned that we would like to return a JSON
    representation of this sequence of products. Therefore, we need some mechanism
    to transform our case class instances into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We could improve the code and create it manually, but there are many good libraries
    that can help us to do it. It would be better to use one of them and reduce the
    boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding JSON with Circe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many Scala libraries to manipulate JSON, so why did we choose Circe?
  prefs: []
  type: TYPE_NORMAL
- en: Circe is a very clean JSON framework with good performance, but the real reason
    we have chosen it is that Circe provides a complete documentation, with an explanation
    of all of the principles used to play with JSON. Circe uses Cats underneath, which
    we used in [Chapter 3](f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml), *Handling
    Errors*. Cats is a library from Typelevel. Typelevel is a community that is extremely
    kind to newcomers in functional programming. It provides lots of great documentation;
    you can check it out at [https://typelevel.org/](https://typelevel.org/). In fact,
    if you wish to dig deeper into functional programming, this is the place to start!
    The downside of Circe is the number of transitive dependencies; hence, it is fine
    to use it in a server application, but it might be a little heavy if you want
    a smaller footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to integrate Circe with Play, we can use the integration done by Jilen
    at [https://github.com/jilen](https://github.com/jilen). We have already added
    the dependency to our template, but for reference, the following needs to be added
    to `libraryDependencies`, in `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the `Circe` trait to our controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will import the required classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are almost there; we need to replace `.mkstring(",")` with `.asJson`. That's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run `APISpec`; we should have your first working test for the API!
  prefs: []
  type: TYPE_NORMAL
- en: Action definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous code, the `for` comprehension retrieves the products from the
    database and converts them to JSON. We are already familiar with this kind of
    syntax, but what about `Action.async` and `Ok()`?
  prefs: []
  type: TYPE_NORMAL
- en: In Play, all of the `Action` elements are asynchronous. The expected return
    of an `Action` is a status, which represents the HTTP status code (`OK() = 200
    OK`, `Created() = 201 CREATED`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the return type of the `for` comprehension is a status
    wrapped in `Future`. The `Action.async` helper function allows us to create an
    asynchronous `Action` from this `Future`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next method to implement is the ability to add a product to the database.
  prefs: []
  type: TYPE_NORMAL
- en: If you are annoyed by the errors shown by IntelliJ when you start a new implementation,
    you can add a dummy return status.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will return a dummy status to avoid IntelliJ errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will complete the implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We expect to receive the new product details as a JSON payload in the body.
    Therefore, in the first line, we get the body as text; if it is not defined, we
    replace it with an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Circe provides a method, named `decode`, which takes a string as a parameter
    and transforms it into an object. The type parameter (`[Product]`, in our case)
    defines the class of the target object.
  prefs: []
  type: TYPE_NORMAL
- en: This `decode` method returns an `Either` instance. If there is an error, it
    will be `Left`, and if the decoding works, it will be `Right`. We can pattern
    match on this `Either` value to return `Ok`; or, in the case of an error, to return
    a `BadRequest` status.
  prefs: []
  type: TYPE_NORMAL
- en: When the decoding works, we call `productDao.insert` to store the new product
    in the database. If anything goes wrong during the insert, the `.recover` block
    will return an internal server error.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the cart test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we would like to do is test the list of products in the
    customer's cart. But how do we make sure that the customer can only see their
    cart and not somebody else's?
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve this problem, we are going to add a `login` endpoint on the API. This
    endpoint will create a session cookie and will keep the session ID in it. This
    way, the session ID will be passed every time a request is sent to the server.
    The server will then be able to associate a session ID with a specific customer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the client calls the login URL, the server responds with a `Set-Cookie`
    header. In this header, the encrypted session data can be obtained by using the `PLAY_SESSION`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the unit test for the new `login` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The test sends a `POST` request to the `login` endpoint. For now, we send a
    dummy payload, `myID`, which represents a user identifier. Once posted, we map
    the returned response to get the `Set-Cookie` header. This `header` contains multiple
    values, separated by semicolons. We are not interested in the other values; hence,
    we need to process this `header` to get only the `PLAY_SESSION` cookie. To do
    so, we split on the semicolon and keep only the element starting with the `PLAY_SESSION` key.
  prefs: []
  type: TYPE_NORMAL
- en: We assign this transformed response to a value: `cookieFuture`. We then wait
    for `Future` to complete; then, the response is split on `=`, and only the key
    is kept and checked.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the test now; it should fail, with a 404 Not Found error.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to add the new endpoint to the `routes` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this new entry, Play reacts to the `POST` action and calls the `login`
    method of the `Webservices` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this `login` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If a body with the username is present, the `OK` status is returned, with a
    new session cookie. The username is added in the cookie, with the `user` key,
    and can be retrieved on a subsequent request.
  prefs: []
  type: TYPE_NORMAL
- en: Run `APISpec` again; the login test should now be green.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the cookie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From now on, every time we interact with the cart, we will have to pass the
    cookie with the session ID to bind our user with the cart. The test to get the
    list of products in the cart is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we call the `login` endpoint to build the session cookie; then, the cookie
    is passed in the second call. In order to check the number of products in the
    cart, we use Circe to transform the JSON response to a sequence of a cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the session cookie has to be used by all of the subsequent tests, we
    can move the code to get the cookie from a `lazy val`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy` keyword indicates that the code will be evaluated as late as possible,
    upon the first usage of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can refactor our test to use it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the addition of a product to the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We must be able to remove a product from the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The last test is to update the quantity of a product in the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As the test is now defined, let's implement the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Listing products in cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something is missing from the implementation; indeed, we do not have a `cartDao`
    instance in our `WebService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add it, just add it as a new parameter; as all of the parameters are injected,
    Play will automatically do it for you. The `WebService` class definition becomes
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation to get all of the products is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addCartProduct` implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that the code is the same in the `.recover` partial function of `addCartProduct`
    and `listCartProducts`; in order to avoid code duplication, we could extract it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can refractor the list of products and add a product to use the new variable.
    The delete product action is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the update product action is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations; all of the tests are now passing!
  prefs: []
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An API needs to be documented to be usable. Indeed, when you want to use an
    API, you will not want to read a complete manual beforehand. It is better to have
    a self-explanatory and intuitive API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with the documentation and testing part, there is a useful framework:
    Swagger.'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger not only helps to write the documentation; it also allows you to test
    the API directly while reading the documentation. In order to visualize the documentation
    with the Swagger UI, you must first declare a specification file, in JSON or YAML
    format. This specification file defines all of the URLs and data models that constitute
    your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to use Swagger, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can write the specification of your API using the Swagger Editor, and Swagger
    will generate a skeleton of the code for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add the Swagger specification directly in the `route.conf` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add annotations in your code to generate the Swagger `specification`
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our project, we are going to generate the Swagger `specification` file by
    using annotations in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of doing it this way is that all of the associated documentation
    will be in one place. It makes it easier to keep the documentation in sync, especially
    when code gets refactored. Many Swagger options are configurable, simply by adding
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation is already done, thanks to the Gitter8 template we used to
    generate this project, so the following details are just for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration that we use is based on the `swagger-api/swagger-play` GitHub
    repository; please refer to it for any updates. We have to add a reference to
    the library in `build.sbt`. The `libraryDependencies` variable must contain the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the module must be enabled by adding the following to `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can publish the JSON definition by adding the following route
    in the `routes` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to serve the API documentation directly from our server. In order
    to do that, we need to add the `swagger-ui` dependency to `libraryDependencies`,
    in `built.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the `swagger-ui` exposed in Play, the `routes` file needs to be updated
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swagger UI uses JavaScript with inline code. By default, the security policy
    of Play forbids inline code. Also, we would like to allow requests from the localhost
    and from Heroku where it will be deployed. Hence, the following code needs to
    be added to `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: OK, the plumbing is done. It is time to add the definition of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Swagger is installed in our project, we need to provide some information
    about our API. First, we need to add the following to `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to declare our controller. For this, we will add the `@Api` annotation
    to the controller named `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we can run Play to see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sbt shell tab of IntelliJ enter `run` followed by *Enter* as in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12909458-8bd0-4898-a145-cc6c2fd224ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The console should print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now safely browse `http://localhost:9000/docs/swagger-ui/index.html?url=/v1/swagger.json`,
    Play is going to compile all the files and after a while, the Swagger UI will
    appear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/446f17d7-d741-4c0a-8c2e-2e1f2ee8d1e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Product and Cart API link. All of the endpoints are shown, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59f5552e-74f6-4d5c-a953-3024c64e925d.png)'
  prefs: []
  type: TYPE_IMG
- en: This looks good, but we have to add some information about our API. For example,
    if you click on the `login` endpoint, there is no way to test it with a body containing
    the username.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the `login` endpoint, go to the `WebService` class and add the following
    annotations, just before the `login` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ApiOperation` object adds a description of the operation and defines the
    content type of the body sent. In this case, we are not sending JSON, but just
    a plain string. The `ApiImplicitParams` object defines the body sent to the server.
    The `ApiResponses` object informs the user about the possible statuses that can
    be returned in the response. The `login` documentation is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bed6f262-12cc-493b-9995-7afc35a8b8e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on Try it out, you can type in a name and submit it by clicking
    on Execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90489ceb-8e83-4aa5-9fd9-036b0d1d8aac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The call should return a successful status code 200, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e13ea24d-7701-4a16-941f-0544af074fab.png)'
  prefs: []
  type: TYPE_IMG
- en: List of products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can add some annotations to the list of products, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use Swagger to call `GET /v1/products`, the result of the execution
    is a JSON representation of all of the products, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5a8c1a5-e02d-4fcc-aace-70169ba6a582.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For `addProduct`, the following are the annotations that we need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `dataType = "models.Product"` declaration, the Model section
    in Swagger shows a JSON model that corresponds to the `Product` case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09d78e29-18ca-460d-9aaa-3553833e5ec2.png)'
  prefs: []
  type: TYPE_IMG
- en: Cart endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s document the cart section with the list of products in the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `listCartProducts`, we receive an empty array. To test it with some
    products, complete the declaration of `addCartProduct` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swagger, we can now add a new product to the cart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e151c5a8-68a0-41bc-9b6f-9cf6d182a416.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the list of products will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7a14505-5dfe-4e07-a490-e7a60f0e62a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we can try to update a product. Add the following annotations to
    `updateCartProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use Swagger to update the quantity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/931138c7-a9e3-48e5-a02d-61594cd31862.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the update, the list of products returns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b020352-a2b9-40a9-ad02-ccb92a2293a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Perfect; the last operation to document is `deleteCartProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We now have complete Swagger documentation for our API, and users can test it
    directly from their browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API is now finished. We can deploy it to Heroku, to make it available on
    the internet. As we already set up Heroku in the previous chapter, there is just
    one command to achieve our deployment. From the command line in the root of your
    project, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once the deployment has finished, you can browse to [https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You can now test the API online.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to design and implement a REST API, while respecting
    the REST architectural principles.
  prefs: []
  type: TYPE_NORMAL
- en: We created tests to check the API from a client's perspective. We implemented
    all of the methods by using the DAO that we wrote in the last chapter. All of
    the calls are asynchronous because we used `Future`, which guarantees that our
    server can handle a lot of concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to use the excellent Circe library to encode and decode
    JSON from Scala. Finally, we added a web interface to document and test the API,
    using Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to use this API to create a web interface
    based on Scala.js.
  prefs: []
  type: TYPE_NORMAL
