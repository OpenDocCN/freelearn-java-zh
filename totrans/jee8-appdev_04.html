<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Enterprise JavaBeans</h1>
                </header>
            
            <article>
                
<p>Enterprise JavaBeans are server-side components that encapsulate the business logic of an application. <strong>Enterprise JavaBeans</strong> (<strong>EJB</strong>) simplify application development by automatically taking care of transaction management and security. There are two types of Enterprise JavaBean: session beans, which perform business logic, and message-driven beans, which act as a message listener.</p>
<p>Readers familiar with previous versions of J2EE will notice that entity beans were not mentioned in the preceding paragraph. In Java EE 5, entity beans were deprecated in favor of the <strong>Java Persistence API</strong> (<strong>JPA</strong>). Entity beans are still supported for backwards compatibility; however, the preferred way of doing <strong>Object Relational Mapping</strong> (<strong>ORM</strong>) is through the JPA.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Session beans</li>
<li>A simple session bean</li>
<li>A more realistic example</li>
<li>Using a session bean to implement the DAO design pattern
<ul>
<li>Singleton session beans</li>
</ul>
</li>
<li>Message-driven beans</li>
<li>Transactions in enterprise JavaBeans</li>
<li>Container-managed transactions</li>
<li>Bean-managed transactions</li>
<li>Enterprise JavaBeans life cycles</li>
<li>Stateful session bean life cycle</li>
<li>Stateless session bean life cycle</li>
<li>Message-driven bean life cycle</li>
<li>EJB timer service</li>
<li>EJB Security</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Session beans</h1>
                </header>
            
            <article>
                
<p>Like we previously mentioned, session beans typically encapsulate business logic. In Java EE, only one or two artifacts need to be created in order to create a session bean: the bean itself, and an optional business interface. These artifacts need to be decorated with the proper annotations to let the EJB container know they are session beans.</p>
<div class="packt_infobox">J2EE required application developers to create several artifacts in order to create a session bean. These artifacts include the bean itself, a local or remote interface (or both), a local home or a remote home interface (or both), and an XML deployment descriptor. As we shall see in this chapter, EJB development was greatly simplified in Java EE.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple session bean</h1>
                </header>
            
            <article>
                
<p>The following example illustrates a very simple session bean.:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook;<br/><br/>import javax.ejb.Stateless;<br/><br/><strong>@Stateless</strong><br/>public class SimpleSessionBean implements SimpleSession<br/>{ <br/>  private String message = <br/>      "If you don't see this, it didn't work!";<br/>  <br/>  public String getMessage()<br/>  {<br/>    return message;<br/>  }<br/>}</pre>
<p>The <kbd>@Stateless</kbd> annotation lets the EJB container know that this class is a <span class="0Text">stateless session bean</span>. There are three types of session bean: stateless, stateful, and singleton. Before we explain the difference between these types of session bean, we need to clarify how an instance of an EJB is provided to an EJB client application.</p>
<p>When a stateless session bean is deployed, the EJB container creates a series of instances of each session bean. This is what is typically referred to as the <span class="0Text">EJB pool</span>. When an EJB client application obtains an instance of an EJB, one of the instances in the pool is provided to this client application.</p>
<p>The difference between stateful and stateless session beans is that stateful session beans maintain a <span class="0Text">conversational state</span> with the client, whereas stateless session beans do not. In simple terms, this means that, when an EJB client application obtains an instance of a stateful session bean, we are guaranteed that the value of any instance variables in the bean will be consistent across method calls. Therefore, it is safe to modify any instance variables on a stateful session bean, since they will retain their value for the next method call. The EJB container saves the conversational state by passivating stateful session beans and retrieves the state when the bean is activated. Conversational state is the reason why the life cycle of stateful session beans is a bit more complex than the life cycle of stateless session beans or message-driven beans (the EJB life cycle is discussed later in this chapter).</p>
<p>The EJB container may provide any instance of an EJB in the pool when an EJB client application requests an instance of a stateless session bean. Since we are not guaranteed the same instance for every method call, values set to any instance variables in a stateless session bean may be "lost" (they are not really lost, the modification is in another instance of the EJB in the pool).</p>
<p>Other than being decorated with the <kbd>@Stateless</kbd> annotation, there is nothing special about this class. Notice that it implements an interface called <strong>SimpleSession</strong>. This interface is the bean's business interface. The <kbd>SimpleSession</kbd> interface is shown here:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.Remote; 
 
<strong>@Remote</strong> 
public interface SimpleSession 
{ 
  public String getMessage(); 
} </pre>
<p>The only peculiar thing about this interface is that it is decorated with the <kbd>@Remote</kbd> annotation. This annotation indicates that this is a <span class="0Text">remote business interface</span>. What this means is that the interface may be in a different JVM than the client application invoking it. Remote business interfaces may even be invoked across the network.</p>
<p>Business interfaces may also be decorated with the <kbd>@Local</kbd> interface. This annotation indicates that the business interface is a <span class="0Text">local business interface</span>. Local business interface implementations must be in the same JVM as the client application invoking its methods.</p>
<p>Since remote business interfaces can be invoked either from the same JVM or from a different JVM as the client application, at first glance we might be tempted to make all of our business interfaces remote. Before doing so, we must be aware of the fact that the flexibility provided by remote business interfaces comes with a performance penalty, since method invocations are made on the assumption that they will be made across the network. As a matter of fact, most typical Java EE applications consist of web applications acting as client applications for EJBs. In this case, the client application and the EJB are running on the same JVM, therefore local interfaces are used a lot more frequently than remote business interfaces.</p>
<p>Once we have compiled the session bean and its corresponding business interface, we need to place them in a JAR file and deploy them. How to deploy an EJB JAR file depends on what application server we are using. However, most modern application servers have an <kbd>autodeploy</kbd> directory; we can simply copy our EJB JAR file to this directory in most cases. Consult your application server documentation to find the exact location of its <kbd>autodeploy</kbd> directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing EJB client code</h1>
                </header>
            
            <article>
                
<p>Now that we have seen the session bean and its corresponding business interface, let's take a look at a client sample application:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.EJB; 
 
public class SessionBeanClient 
{ 
  <strong>@EJB 
  private static SimpleSession simpleSession;</strong> 
 
  private void invokeSessionBeanMethods() 
  { 
    System.out.println(simpleSession.getMessage()); 
 
    System.out.println("\nSimpleSession is of type: " 
        + simpleSession.getClass().getName()); 
  } 
 
  public static void main(String[] args) 
  { 
    new SessionBeanClient().invokeSessionBeanMethods(); 
  } 
 
} </pre>
<p>The preceding code simply declares an instance variable of type <kbd>net.ensode.SimpleSession</kbd>, which is the business interface for our session bean. The instance variable is decorated with the <kbd>@EJB</kbd> annotation; this annotation lets the EJB container know that this variable is a business interface for a session bean. The EJB container then injects an implementation of the business interface for the client code to use.</p>
<p>Since our client is a standalone application (as opposed to a Java EE artifact such as a WAR file or another EJB JAR file), it isn't actually deployed to the application server. In order for it to be able to access code deployed to the server, it must have access to the application server's client libraries. The procedure on how to accomplish this varies from application server to application server. When using GlassFish, our client code must be placed in a JAR file and executed through the <kbd><span class="0Text">appclient</span></kbd> utility. This utility can be found at <kbd>[glassfish installation directory]/glassfish/bin/</kbd>. Assuming this directory is in the PATH environment variable, and assuming we placed our client code in a JAR file called <kbd>simplesessionbeanclient.jar</kbd>, we would execute the preceding client code by typing the following command in the command line:</p>
<pre><strong>appclient -client simplesessionbeanclient-jar-with-dependencies.jar</strong></pre>
<p>Executing the preceding command results in the following console output:</p>
<pre><strong>If you don't see this, it didn't work!</strong>
    
<strong>SimpleSession is of type: net.ensode.javaeebook._SimpleSession_Wrapper<br/></strong></pre>
<p>This is the output of the <kbd>SessionBeanClient</kbd> class.<strong><br/></strong></p>
<div class="packt_infobox">We are using Maven to build our code. For this example, we used the Maven Assembly plugin (<a href="http://maven.apache.org/plugins/maven-assembly-plugin/"><span class="9Text">http://maven.apache.org/plugins/maven-assembly-plugin/</span></a>) to build a client JAR file that includes all dependencies. This frees us from having to specify all the dependent JAR files in the <kbd>-classpath</kbd> command line option of <kbd>appclient</kbd>. To build this JAR file, simply invoke <kbd>mvn assembly:assembly</kbd> from the command line.</div>
<p>The first line of output is simply the return value of the <kbd>getMessage()</kbd> method we implemented in the session bean. The second line of output displays the fully qualified class name of the class implementing the business interface. Notice that the class name is not the fully qualified name of the session bean we wrote; instead, what is actually provided is an implementation of the business interface created behind the scenes by the EJB container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A more realistic example</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw a very simple "Hello world" type of example. In this section, we will use a more realistic example. Session beans are frequently used as <span class="0Text">Data Access Objects</span> (<strong>DAOs</strong>). Sometimes they are used as a wrapper for JDBC calls, other times they are used to wrap calls to obtain or modify JPA entities. In this section, we will take the latter approach.</p>
<p>The following example illustrates how to implement the DAO design pattern in a session bean. Before looking at the bean implementation, let's look at its corresponding business interface:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.Remote; 
 
@Remote 
public interface CustomerDao 
{ 
  public void saveCustomer(Customer customer); 
 
  public Customer getCustomer(Long customerId); 
 
  public void deleteCustomer(Customer customer); 
} </pre>
<p>As we can see, this is a remote interface implementing three methods; the <kbd>saveCustomer()</kbd> method saves customer data to the database, the <kbd>getCustomer()</kbd> method obtains data for a customer from the database, and the <kbd>deleteCustomer()</kbd> method deletes customer data from the database. All of these methods take an instance of the <kbd>Customer</kbd> entity we developed in <a href="1dec503e-112f-4f75-8569-4311c0cee377.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Object Relational Mapping with JPA</em> as a parameter.</p>
<p>Let's now take a look at the session bean implementing the preceding business interface. As we are about to see, there are some differences between the way JPA code is implemented in a session bean and in a plain old <kbd>Java</kbd> object:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.Stateful; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
 
@Stateful 
public class CustomerDaoBean implements CustomerDao { 
 
    @PersistenceContext 
    private EntityManager entityManager;     
 
    public void saveCustomer(Customer customer) { 
        if (customer.getCustomerId() == null) { 
            saveNewCustomer(customer); 
        } else { 
            updateCustomer(customer); 
        } 
    } 
 
    private void saveNewCustomer(Customer customer) { 
        entityManager.persist(customer); 
    } 
 
    private void updateCustomer(Customer customer) { 
        entityManager.merge(customer); 
    } 
 
    public Customer getCustomer(Long customerId) { 
        Customer customer; 
 
        customer = entityManager.find(Customer.class, customerId); 
 
        return customer; 
    } 
 
    public void deleteCustomer(Customer customer) { 
        entityManager.remove(customer); 
    } 
} </pre>
<p>The main difference between the preceding session bean and previous JPA examples is that in previous examples, JPA calls were wrapped between calls to <kbd>UserTransaction.begin()</kbd> and <kbd>UserTransaction.commit()</kbd>. The reason we had to do this is because JPA calls are required to be wrapped in a transaction; if they are not in a transaction, most JPA calls will throw a <kbd>TransactionRequiredException</kbd>. The reason we don't have to explicitly wrap JPA calls in a transaction like in previous examples is because session bean methods are implicitly transactional, there is nothing we need to do to make them that way. This default behavior is what is known as c<span class="0Text">ontainer-managed transactions</span>. Container-managed transactions are discussed in detail later in this chapter.</p>
<p>As mentioned in <a href="1dec503e-112f-4f75-8569-4311c0cee377.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Object Relational Mapping with Java Persistence API</em>, when a JPA entity is retrieved in one transaction and updated in a different transaction, the <kbd>EntityManager.merge()</kbd> method needs to be invoked to update the data in the database. Invoking <kbd>EntityManager.persist()</kbd> in this case will result in a "Cannot persist detached object" exception.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking session beans from web applications</h1>
                </header>
            
            <article>
                
<p>Frequently, Java EE applications consist of web applications acting as clients for EJBs. Before Java EE 6, the most common way of deploying a Java EE application that consists of both a web application and one or more session beans was to package both the WAR file for the web application and the EJB JAR files into an <strong>EAR</strong> (<strong>Enterprise ARchive</strong>) file.</p>
<p>Java EE 6 simplified the packaging and deployment of applications consisting of both EJBs and web components.</p>
<p>In this section, we will develop a JSF application with a CDI named bean acting as a client to the DAO session bean we just discussed in the previous section.</p>
<p>In order to make this application act as an EJB client, we will develop a <kbd>CustomerController</kbd> named bean so that it delegates the logic to save a new customer to the database to the <kbd>CustomerDaoBean</kbd> session bean we developed in the previous section:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook.jsfjpa; 
 
//imports omitted for brevity 
 
@Named 
@RequestScoped 
public class CustomerController implements Serializable { 
 
    <strong>@EJB 
    private CustomerDaoBean customerDaoBean;</strong> 
 
    private Customer customer; 
 
    private String firstName; 
    private String lastName; 
    private String email; 
 
    public CustomerController() { 
        customer = new Customer(); 
    } 
 
    public String saveCustomer() { 
        String returnValue = "customer_saved"; 
 
        try { 
            populateCustomer(); 
            <strong>customerDaoBean.saveCustomer(customer);</strong> 
        } catch (Exception e) { 
            e.printStackTrace(); 
            returnValue = "error_saving_customer"; 
        } 
 
        return returnValue; 
    } 
 
    private void populateCustomer() { 
        if (customer == null) { 
            customer = new Customer(); 
        } 
        customer.setFirstName(getFirstName()); 
        customer.setLastName(getLastName()); 
        customer.setEmail(getEmail()); 
    } 
 
//setters and getters omitted for brevity 
 
} </pre>
<p>As we can see, all we had to do was to declare an instance of the <kbd>CustomerDaoBean</kbd> session bean, and decorate it with the <kbd>@EJB</kbd> annotation so that an instance of the corresponding EJB is injected, then invoke the EJB's <kbd>saveCustomer()</kbd> method.</p>
<p>Notice that we injected an instance of the session bean directly into our client code. The reason we can do this is because of a feature introduced in Java EE 6. When using Java EE 6 or newer, we can do away with local interfaces and use session bean instances directly in our client code.</p>
<p>Now that we have modified our web application to be a client for our session bean, we need to package it in a <strong>WAR</strong> (<strong>web archive</strong>) file and deploy it in order to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton session beans</h1>
                </header>
            
            <article>
                
<p>A new type of session bean that was introduced in Java EE 6 is the <span class="0Text">singleton session bean</span>. A single instance of each singleton session bean exists in the application server.</p>
<p>Singleton session beans are useful to cache database data. Caching frequently-used data in a singleton session bean increases performance since it greatly minimizes trips to the database. The common pattern is to have a method in our bean decorated with the <kbd>@PostConstruct</kbd> annotation; in this method we retrieve the data we want to cache. Then we provide a setter method for the bean's clients to call. The following example illustrates this technique:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook.singletonsession;  
 
import java.util.List;  
import javax.annotation.PostConstruct;  
import javax.ejb.Singleton;  
import javax.persistence.EntityManager;  
import javax.persistence.PersistenceContext;  
import javax.persistence.Query;  
import net.ensode.javaeebook.entity.UsStates;  
 
<strong>@Singleton </strong> 
public class SingletonSessionBean implements  
    SingletonSessionBeanRemote {  
 
  @PersistenceContext  
  private EntityManager entityManager;  
  private List&lt;UsStates&gt; stateList;  
 
  @PostConstruct  
  public void init() {  
    Query query = entityManager.createQuery(  
        "Select us from UsStates us");  
    stateList = query.getResultList();  
  }  
 
  @Override  
  public List&lt;UsStates&gt; getStateList() {  
    return stateList;  
  }  
}  </pre>
<p>Since our bean is a singleton, all of its clients would access the same instance, avoiding having duplicate data in memory. Additionally, since it is a singleton, it is safe to have an instance variable, since all clients access the same instance of the bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous method calls</h1>
                </header>
            
            <article>
                
<p>Sometimes it is useful to have some processing done asynchronously, that is, invoking a method call and returning control immediately to the client, without having the client wait for the method to finish.</p>
<p>In earlier versions of Java EE, the only way to invoke EJB methods asynchronously was to use message-driven beans (discussed in the next section). Although message-driven beans are fairly easy to write, they do require some configuration, such as setting up JMS message queues or topics, before they can be used.</p>
<p>EJB 3.1 introduced the <kbd>@Asynchronous</kbd> annotation, which can be used to mark a method in a session bean as asynchronous. When an EJB client invokes an asynchronous method, control immediately goes back to the client, without waiting for the method to finish.</p>
<p>Asynchronous methods can only return <kbd>void</kbd> or an implementation of the <kbd>java.util.concurrent.Future</kbd> interface. The following example illustrates both scenarios:</p>
<pre style="padding-left: 60px"><span>package net.ensode.javaeebook.asynchronousmethods;</span><br/>import java.util.concurrent.Future;  
import java.util.logging.Level;  
import java.util.logging.Logger;  
import javax.ejb.AsyncResult;  
import javax.ejb.Asynchronous;  
import javax.ejb.Stateless;  
 
@Stateless  
public class AsynchronousSessionBean implements  
    AsynchronousSessionBeanRemote {  
 
  private static Logger logger = Logger.getLogger(  
      AsynchronousSessionBean.class.getName());  
 
 <strong> @Asynchronous </strong> 
  @Override  
  <strong>public void slowMethod()</strong> {  
    long startTime = System.currentTimeMillis();  
    logger.info("entering " + this.getClass().getCanonicalName()  
        + ".slowMethod()");  
    try {  
      Thread.sleep(10000); //simulate processing for 10 seconds  
    } catch (InterruptedException ex) {  
      Logger.getLogger(AsynchronousSessionBean.class.getName()).  
          log(Level.SEVERE, null, ex);  
    }  
    logger.info("leaving " + this.getClass().getCanonicalName()  
        + ".slowMethod()");  
    long endTime = System.currentTimeMillis();  
    logger.info("execution took " + (endTime - startTime)  
        + " milliseconds");  
  }  
 
 <strong> @Asynchronous </strong> 
  @Override  
 <strong> public Future&lt;Long&gt; slowMethodWithReturnValue()</strong> {  
    try {  
      Thread.sleep(15000); //simulate processing for 15 seconds  
    } catch (InterruptedException ex) {  
      Logger.getLogger(AsynchronousSessionBean.class.getName()).  
          log(Level.SEVERE, null, ex);  
    }  
 
    return new AsyncResult&lt;Long&gt;(42L);  
  }  
}  </pre>
<p>When our asynchronous method returns <kbd>void</kbd>, the only thing we need to do is decorate the method with the <kbd>@Asynchronous</kbd> annotation, then call it as usual from the client code.</p>
<p>If we need a return value, this value needs to be wrapped in an implementation of the <kbd>java.util.concurrent.Future</kbd> interface. The Java EE API provides a convenience implementation in the form of the <kbd>javax.ejb.AsyncResult</kbd> class. Both the <kbd>Future</kbd> interface and the <kbd>AsyncResult</kbd> class use generics; we need to specify our return type as the type parameter of these artifacts.</p>
<p>The <kbd>Future</kbd> interface has several methods we can use to cancel execution of an asynchronous method, check to see if the method is done, get the return value of the method, or check to see if the method is canceled. The following table lists these methods:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cancel(boolean mayInterruptIfRunning)</kbd></p>
</td>
<td>
<p>Cancels method execution. If the <kbd>boolean</kbd> parameter is true, then this method will attempt to cancel the method execution even if it is already running.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>get()</kbd></p>
</td>
<td>
<p>Will return the "unwrapped" return value of the method; the return value will be of the <kbd>type</kbd> parameter of the <kbd>Future</kbd> interface implementation returned by the method.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>get(long timeout, TimeUnit unit)</kbd></p>
</td>
<td>
<p>Will attempt the "unwrapped" return value of the method; the return value will be of the <kbd>type</kbd> parameter of the <kbd>Future</kbd> interface implementation returned by the method. This method will block the amount of time specified by the first parameter. The unit of time to wait is determined by the second parameter; the <kbd>TimeUnit</kbd> enum has constants for NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, and so on. Refer to its Javadoc documentation for the complete list.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isCancelled()</kbd></p>
</td>
<td>
<p>Returns true if the method has been canceled, false otherwise.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isDone()</kbd></p>
</td>
<td>
<p>Returns true if the method has finished executing, false otherwise.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As we can see, the <kbd>@Asynchronous</kbd> annotation makes it very easy to make asynchronous calls without having the overhead of having to set up message queues or topics. It is certainly a welcome addition to the EJB specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message-driven beans</h1>
                </header>
            
            <article>
                
<p>The purpose of a message-driven bean is to consume messages from a Java Message Service (JMS) queue or a JMS topic, depending on the messaging domain used (refer to <a href="cef6345a-3cb4-4d30-aa7b-a31c4f710e57.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Java Message Service</em>). A message-driven bean must be decorated with the <kbd>@MessageDriven</kbd> annotation; the <kbd>mappedName</kbd> attribute of this annotation must contain the <strong>Java Naming and Directory Interface</strong> (<strong>JNDI</strong>) name of the JMS message queue or JMS message topic that the bean will be consuming messages from. The following example illustrates a simple message-driven bean:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.MessageDriven; 
import javax.jms.JMSException; 
import javax.jms.Message; 
import javax.jms.MessageListener; 
import javax.jms.TextMessage; 
 
<strong>@MessageDriven(mappedName = "jms/JavaEE8BookQueue")</strong> 
public class ExampleMessageDrivenBean implements MessageListener 
{ 
  public void onMessage(Message message) 
  { 
    TextMessage textMessage = (TextMessage) message; 
    try 
    { 
      System.out.print("Received the following message: "); 
      System.out.println(textMessage.getText()); 
      System.out.println(); 
    } 
    catch (JMSException e) 
    { 
      e.printStackTrace(); 
    } 
  } 
} </pre>
<p>Message-driven beans must be decorated with the <kbd>@MessageDriven</kbd> annotation. They listen for messages on the queue or topic defined in the <kbd>mappedName</kbd> attribute of the <kbd>@MessageDriven</kbd> interface (<kbd>jms/JavaEEBookQueue</kbd> in this example).</p>
<p>It is recommended, but not required, for message-driven beans to implement the <kbd>javax.jms.MessageListener</kbd> interface; however message-driven beans must have a method called <kbd>onMessage()</kbd> whose signature is identical to the preceding example.</p>
<p>Client applications never invoke a message-driven bean's methods directly; instead they put messages in the message queue or topic, then the bean consumes those messages and acts appropriately. The preceding example simply prints the message to standard output; since message-driven beans execute inside an EJB container, standard output gets redirected to a log. If using GlassFish, the server log file can be found at <kbd>[GlassFish installation directory]/glassfish/domains/domain1/logs/server.log</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transactions in enterprise JavaBeans</h1>
                </header>
            
            <article>
                
<p>Like we mentioned earlier in this chapter, by default all EJB methods are automatically wrapped in a transaction. This default behavior is known as c<span class="0Text">ontainer-managed transactions</span>, since transactions are managed by the EJB container. Application developers may also choose to manage transactions themselves, which can be accomplished by using bean-managed transactions. Both of these approaches are discussed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Container-managed transactions</h1>
                </header>
            
            <article>
                
<p>Because EJB methods are transactional by default, we run into an interesting dilemma when an EJB method is invoked from client code that is already in a transaction. How should the EJB container behave? Should it suspend the client transaction, execute its method in a new transaction, and then resume the client transaction? Should it not create a new transaction and execute its method as part of the client transaction? Should it throw an exception?</p>
<p>By default, if an EJB method is invoked by client code that is already in a transaction, the EJB container will simply execute the session bean method as part of the client transaction. If this is not the behavior we need, we can change it by decorating the method with the <kbd>@TransactionAttribute</kbd> annotation. This annotation has a <kbd>value</kbd> attribute that determines how the EJB container will behave when the session bean method is invoked within an existing transaction and when it is invoked outside any transactions. The value of the <kbd>value</kbd> attribute is typically a constant defined in the <kbd>javax.ejb.TransactionAttributeType</kbd> enum.</p>
<p>The following table lists the possible values for the <kbd>@TransactionAttribute</kbd> annotation:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Values</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.MANDATORY</kbd></p>
</td>
<td>
<p>Forces the method to be invoked as part of a client transaction. If the method is called outside any transactions, it will throw a <kbd>TransactionRequiredException</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.NEVER</kbd></p>
</td>
<td>
<p>The method is never executed in a transaction. If the method is invoked as part of a client transaction, it will throw a <kbd>RemoteException</kbd>. No transaction is created if the method is not invoked inside a client transaction.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.NOT_SUPPORTED</kbd></p>
</td>
<td>
<p>If the method is invoked as part of a client transaction, the client transaction is suspended and the method is executed outside any transaction; after the method completes, the client transaction is resumed. No transaction is created if the method is not invoked inside a client transaction.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.REQUIRED</kbd></p>
</td>
<td>
<p>If the method is invoked as part of a client transaction, the method is executed as part of this transaction. If the method is invoked outside any transaction, a new transaction is created for the method. This is the default behavior.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.REQUIRES_NEW</kbd></p>
</td>
<td>
<p>If the method is invoked as part of a client transaction, this transaction is suspended, and a new transaction is created for the method. Once the method completes, the client transaction is resumed. If the method is called outside any transactions, a new transaction is created for the method.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TransactionAttributeType.SUPPORTS</kbd></p>
</td>
<td>
<p>If the method is invoked as part of a client transaction, it is executed as part of this transaction. If the method is invoked outside a transaction, no new transaction is created for the method.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Although the default transaction attribute is reasonable in most cases, it is good to be able to override this default if necessary. For example, as transactions have a performance impact, being able to turn off transactions for a method that does not need them is beneficial. For a case like this, we would decorate our method as illustrated in the following code snippet:</p>
<pre style="padding-left: 60px">@TransactionAttribute(value=TransactionAttributeType.NEVER)  
public void doitAsFastAsPossible() 
{ 
  //performance critical code goes here. 
} </pre>
<p>Other transaction attribute types can be declared by annotating the methods with the corresponding constant in the <kbd>TransactionAttributeType</kbd> enum.</p>
<p>If we wish to override the default transaction attribute consistently across all methods in a session bean, we can decorate the session bean class with the <kbd>@TransactionAttribute</kbd> annotation; the value of its <kbd>value</kbd> attribute will be applied to every method in the session bean.</p>
<p>Container-managed transactions are automatically rolled back whenever an exception is thrown inside an EJB method. Additionally, we can programmatically roll back a container-managed transaction by invoking the <kbd>setRollbackOnly()</kbd> method on an instance of <kbd>javax.ejb.EJBContext</kbd> corresponding to the session bean in question. The following example is a new version of the session bean we saw earlier in this chapter, modified to roll back transactions if necessary:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
//imports omitted 
 
@Stateless 
public class CustomerDaoRollbackBean implements CustomerDaoRollback 
{ 
  <strong>@Resource     
  private EJBContext ejbContext;</strong> 
 
  @PersistenceContext 
  private EntityManager entityManager; 
 
 
 
 
 
 
  public void saveNewCustomer(Customer customer) 
  { 
    <strong>if (customer == null || customer.getCustomerId() != null) 
    { 
      ejbContext.setRollbackOnly(); 
    }</strong> 
    else 
    { 
      customer.setCustomerId(getNewCustomerId()); 
      entityManager.persist(customer); 
    } 
  } 
 
  public void updateCustomer(Customer customer) 
  { 
    <strong>if (customer == null || customer.getCustomerId() == null) 
    { 
      ejbContext.setRollbackOnly(); 
    }</strong> 
    else 
    { 
      entityManager.merge(customer); 
    } 
  } 
//Additional method omitted for brevity. 
 
} </pre>
<p>In this version of the DAO session bean, we deleted the <kbd>saveCustomer()</kbd> method and made the <kbd>saveNewCustomer()</kbd> and <kbd>updateCustomer()</kbd> methods public. Each of these methods now checks to see if the <kbd>customerId</kbd> field is set correctly for the operation we are trying to perform (<kbd>null</kbd> for inserts and not <kbd>null</kbd> for updates). It also checks to make sure the object to be persisted is not <kbd>null</kbd>. If any of the checks results in invalid data, the method simply rolls back the transaction by invoking the <kbd>setRollBackOnly()</kbd> method on the injected instance of <kbd>EJBContext</kbd> and does not update the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean-managed transactions</h1>
                </header>
            
            <article>
                
<p>As we have seen, container-managed transactions make it ridiculously easy to write code that is wrapped in a transaction. There is nothing special that we need to do to make them that way; as a matter of fact, some developers are sometimes not even aware that they are writing code that will be transactional in nature when they develop session beans. Container-managed transactions cover most typical use cases that we will encounter. However they do have a limitation; each method can be wrapped in a single transaction or <span>without a</span> transaction. With container-managed transactions, it is not possible to implement a method that generates more than one transaction, but this can be accomplished by using b<span class="0Text">ean-managed transactions:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import java.sql.Connection; 
import java.sql.PreparedStatement; 
import java.sql.ResultSet; 
import java.sql.SQLException; 
import java.util.List; 
 
import javax.annotation.Resource; 
import javax.ejb.Stateless; 
import javax.ejb.TransactionManagement; 
import javax.ejb.TransactionManagementType; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.sql.DataSource; 
import javax.transaction.UserTransaction; 
 
@Stateless 
<strong>@TransactionManagement(value = TransactionManagementType.BEAN)</strong> 
public class CustomerDaoBmtBean implements CustomerDaoBmt 
{ 
  <strong>@Resource 
  private UserTransaction userTransaction; 
</strong> 
  @PersistenceContext 
  private EntityManager entityManager; 
 
  @Resource(name = "jdbc/__CustomerDBPool") 
  private DataSource dataSource; 
 
  public void saveMultipleNewCustomers( 
      List&lt;Customer&gt; customerList) 
  { 
    for (Customer customer : customerList) 
    { 
      try 
      { 
        <strong>userTransaction.begin();</strong> 
        customer.setCustomerId(getNewCustomerId()); 
        entityManager.persist(customer); 
        <strong>userTransaction.commit();</strong> 
      } 
      catch (Exception e) 
      { 
        e.printStackTrace(); 
      } 
    } 
  } 
 
  private Long getNewCustomerId() 
  { 
    Connection connection; 
    Long newCustomerId = null; 
    try 
    { 
      connection = dataSource.getConnection(); 
      PreparedStatement preparedStatement =  
          connection.prepareStatement("select " + 
          "max(customer_id)+1 as new_customer_id " +  
          "from customers"); 
 
      ResultSet resultSet = preparedStatement.executeQuery(); 
 
      if (resultSet != null &amp;&amp; resultSet.next()) 
      { 
        newCustomerId = resultSet.getLong("new_customer_id"); 
      } 
 
      connection.close(); 
    } 
    catch (SQLException e) 
    { 
      e.printStackTrace(); 
    } 
 
    return newCustomerId; 
  } 
} </pre>
<p>In this example, we implemented a method named <kbd>saveMultipleNewCustomers()</kbd>. This method takes a <kbd>List</kbd> of customers as its sole parameter. The intention of this method is to save as many elements in the <kbd>ArrayList</kbd> as possible. An exception while saving one of the entities should not stop the method from attempting to save the remaining elements. This behavior is not possible using container-managed transactions, since an exception thrown when saving one of the entities will roll back the whole transaction; the only way to achieve this behavior is through bean-managed transactions.</p>
<p>As can be seen in the example, we declare that the session bean uses bean-managed transactions by decorating the class with the <kbd>@TransactionManagement</kbd> annotation and using <kbd>TransactionManagementType.BEAN</kbd> as the value for its <kbd>value</kbd> attribute (the only other valid value for this attribute is <kbd>TransactionManagementType.CONTAINER</kbd>, but since this is the default value, it is not necessary to specify it).</p>
<p>To be able to programmatically control transactions, we inject an instance of <kbd>javax.transaction.UserTransaction</kbd>, which is then used in the <kbd>for</kbd> loop inside the <kbd>saveMultipleNewCustomers()</kbd> method to begin and commit transactions in each iteration of the loop.</p>
<p>If we need to roll back a bean-managed transaction, we can do it by simply calling the <kbd>rollback()</kbd> method on the appropriate instance of <kbd>javax.transaction.UserTransaction</kbd>.</p>
<p>Before moving on, it is worth noting that, even though all the examples in this section were session beans, the concepts explained apply to message-driven beans as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enterprise JavaBean life cycles</h1>
                </header>
            
            <article>
                
<p>Enterprise JavaBeans go through different states in their life cycle. Each type of EJB has different states. States specific to each type of EJB are discussed in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateful session bean life cycle</h1>
                </header>
            
            <article>
                
<p>We can annotate methods in session beans so that they are automatically invoked by the EJB container at certain points in the bean's life cycle. For example, we could have a method invoked right after the bean is created or right before it is destroyed.</p>
<p>Before explaining the annotations available to implement life cycle methods, a brief explanation of the session bean life cycle is in order. The life cycle of a stateful session bean is different from the life cycle of a stateless or singleton session bean.</p>
<p>A stateful session bean life cycle contains three states: <span class="0Text"><span class="packt_screen">Does Not Exist</span></span>, <span class="0Text"><span class="packt_screen">Ready</span></span>, and <span class="0Text"><span class="packt_screen">Passive</span>:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c17032d2-5069-48a4-9719-59c822d02be3.png" style="width:10.83em;height:15.58em;"/></div>
<p>Before a stateful session bean is deployed, it is in the <span class="0Text"><span class="packt_screen">Does Not Exist</span></span> state. Upon successful deployment, the EJB container does any required dependency injection on the bean and it goes into the <span class="packt_screen"><span class="0Text">Ready</span></span> state. At this point, the bean is ready to have its methods called by a client application.</p>
<p>When a stateful session bean is in the <span class="packt_screen">Ready</span> state, the EJB container may decide to passivate it, that is, to move it from the main memory to secondary storage, when this happens the bean goes into the <span class="packt_screen"><span class="0Text">Passive</span></span> state.</p>
<p>If an instance of a stateful session bean hasn't been accessed for a period of time, the EJB container will set the bean to the <span class="packt_screen">Does Not Exist</span> state. How long a bean will stay in memory before being destroyed varies from application server to application server, and is usually configurable. By default, GlassFish will send a stateful session bean to the <span class="packt_screen">Does Not Exist</span> state after 90 minutes of inactivity. When deploying our code to GlassFish, this default can be changed by going to the GlassFish administration console; expanding the <span class="packt_screen">Configuration</span> node in the tree at the right-hand side; expanding the <span class="packt_screen">server-config</span> node; clicking on the <span class="packt_screen">EJB Container</span> node; scrolling down towards the bottom of the page and modifying the value of the <span class="packt_screen">Removal Timeout</span> text field; and then finally clicking on either of the <span class="packt_screen">Save</span> buttons (the top right or bottom right of the main page):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/7eb7d285-e165-4914-810e-5dfb26e3c601.png"/></div>
<p>However, this technique sets the timeout value for all stateful session beans. If we need to modify the timeout value for a specific session bean, we need to include a <kbd>glassfish-ejb-jar.xml</kbd> deployment descriptor in the JAR file containing the session bean. In this deployment descriptor, we can set the timeout value as the value of the <kbd>&lt;removal-timeout-in-seconds&gt;</kbd> element:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt; 
&lt;glassfish-ejb-jar&gt; 
  &lt;enterprise-beans&gt; 
    &lt;ejb&gt; 
      &lt;ejb-name&gt;MyStatefulSessionBean&lt;/ejb-name&gt; 
      &lt;bean-cache&gt; 
          &lt;removal-timeout-in-seconds&gt; 
              600 
          &lt;/removal-timeout-in-seconds&gt; 
      &lt;/bean-cache&gt; 
    &lt;/ejb&gt; 
  &lt;/enterprise-beans&gt; 
&lt;/glassfish-ejb-jar&gt; </pre>
<p>Even though we are no longer required to create an <kbd>ejb-jar.xml</kbd> for our session beans (this was necessary in previous versions of the J2EE specification), we can still write one if we want to. The <kbd>&lt;ejb-name&gt;</kbd> element in the <kbd>glassfish-ejb-jar.xml</kbd> deployment descriptor must match the value of the element of the same name in <kbd>ejb-jar.xml</kbd>. If we choose not to create an <kbd>ejb-jar.xml</kbd>, then this value must match the name of the EJB class. The timeout value for the stateful session bean must be the value of the <kbd>&lt;removal-timeout-in-seconds&gt;</kbd> element; as the name of the element suggests, the unit of time to use is seconds. In the preceding example, we set the timeout value to 600 seconds, or 10 minutes.</p>
<p>Any methods in a stateful session bean decorated with the <kbd>@PostActivate</kbd> annotation will be invoked just after the stateful session bean has been activated. Similarly, any method decorated with the <kbd>@PrePassivate</kbd> annotation will be invoked just before the stateful session bean is passivated.</p>
<p>When a stateful session bean that is in the <span class="packt_screen">Ready</span> state times out and is sent to the <span class="packt_screen">Does not Exist</span> state, any method decorated with the <kbd>@PreDestroy</kbd> annotation is executed. If the session bean is in the <span class="packt_screen">Passive</span> state and it times out, methods decorated with the <kbd>@PreDestroy</kbd> annotation are not executed. Additionally, if a client of the stateful session bean executes any method decorated with the <kbd>@Remove</kbd> annotation, any methods decorated with the <kbd>@PreDestroy</kbd> annotation are executed and the bean is marked for garbage collection.</p>
<p>The <kbd>@PostActivate</kbd>, <kbd>@PrePassivate</kbd>, and <kbd>@Remove</kbd> annotations are valid only for stateful session beans. The <kbd>@PreDestroy</kbd> and <kbd>@PostConstruct</kbd> annotations are valid for stateful session beans, stateless session beans, and message-driven beans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless and singleton session bean life cycles</h1>
                </header>
            
            <article>
                
<p>A stateless or singleton session bean life cycle contains only the <span class="0Text"><span class="packt_screen">Does Not Exist</span></span> and <span class="0Text"><span class="packt_screen">Ready</span></span> states:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/dc7b289c-697e-46f9-b57a-ba55d6fc22b9.png" style="width:9.58em;height:11.67em;"/></div>
<p>Stateless and singleton session beans are never passivated. A stateless or singleton session bean's methods can be decorated with the <kbd>@PostConstruct</kbd> and the <kbd>@PreDestroy</kbd> annotations. Just like in stateful session beans, any methods decorated with the <kbd>@PostConstruct</kbd> annotation will be executed when the session bean goes from the <span class="packt_screen">Does Not Exist</span> to the <span class="packt_screen">Ready</span> State, and any methods decorated with the <kbd>@PreDestroy</kbd> annotation will be executed when a stateless session bean goes from the <span class="packt_screen">Ready</span> state to the <span class="packt_screen">Does Not Exist</span> state. Stateless and singleton session beans are never passivated, therefore any <kbd>@PrePassivate</kbd> and <kbd>@PostActivate</kbd> annotations in a stateless session bean are simply ignored by the EJB container.</p>
<p>Most application servers allow us to configure how long to wait before an idle stateless or singleton session bean is destroyed. If using GlassFish, we can control how the life cycle of stateless session beans (and message-driven beans) is managed via the administration web console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/0180b4b8-333b-4a8a-95df-2aa96f1c9c83.png" style="width:65.92em;height:16.67em;"/></div>
<p>The settings shown in the preceding screenshot allow us to control the stateless session bean life cycle:</p>
<ul>
<li><span class="packt_screen">Initial and Minimum Pool Size</span> refers to the minimum number of beans in the pool</li>
<li><span class="packt_screen">Maximum Pool Size</span> refers to the maximum number of beans in the pool</li>
<li><span class="packt_screen">Pool Resize Quantity</span> refers to how many beans will be removed from the pool when the pool idle timeout expires</li>
<li><span class="packt_screen">Pool Idle Timeout</span> refers to the number of seconds of inactivity to wait before removing beans from the pool</li>
</ul>
<p>The preceding settings affect all poolable (stateless session beans and message-driven beans) EJBs. Just like with stateful session beans, these settings can be overridden on a case-by-case basis, by adding a GlassFish-specific <kbd>glassfish-ejb.jar.xml</kbd> deployment descriptor:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
 
 
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt; 
&lt;glassfish-ejb-jar&gt; 
    &lt;enterprise-beans&gt; 
        &lt;ejb&gt; 
            &lt;ejb-name&gt;MyStatelessSessionBean&lt;/ejb-name&gt; 
            &lt;bean-pool&gt; 
                &lt;steady-pool-size&gt;10&lt;/steady-pool-size&gt; 
                &lt;max-pool-size&gt;60&lt;/max-pool-size&gt; 
                &lt;resize-quantity&gt;5&lt;/resize-quantity&gt; 
                &lt;pool-idle-timeout-in-seconds&gt; 
                    900 
                &lt;/pool-idle-timeout-in-seconds&gt; 
            &lt;/bean-pool&gt; 
        &lt;/ejb&gt; 
    &lt;/enterprise-beans&gt; 
&lt;/glassfish-ejb-jar&gt; </pre>
<p><kbd>glassfish-ejb-jar.xml</kbd> contains XML tags that are equivalent to the corresponding settings in the web console:</p>
<ul>
<li><kbd>&lt;steady-pool-size&gt;</kbd> corresponds to <span class="packt_screen">Initial and Minimum Pool Size</span> in the GlassFish web console</li>
<li><kbd>&lt;max-pool-size&gt;</kbd> corresponds to <span class="packt_screen">Maximum Pool Size</span> in the GlassFish web console</li>
<li><kbd>&lt;resize-quantity&gt;</kbd> corresponds to <span class="packt_screen">Pool Resize Quantity</span> in the GlassFish web console</li>
<li><kbd>&lt;pool-idle-timeout-in-seconds&gt;</kbd> corresponds to <span class="packt_screen">Pool Idle Timeout</span> in the GlassFish web console</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message-driven bean life cycle</h1>
                </header>
            
            <article>
                
<p>Just like stateless session beans, message-driven beans contain only the <span class="packt_screen">Does Not Exist</span> and <span class="packt_screen">Ready</span> states:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/84436122-97a2-4839-b994-2e8a6f2fa641.png" style="width:9.58em;height:11.67em;"/></div>
<p>A message-driven bean can have methods decorated with the <kbd>@PostConstruct</kbd> and <kbd>@PreDestroy</kbd> methods. Methods decorated with the <kbd>@PostConstruct</kbd> are executed just before the bean goes to the <span class="packt_screen">Ready</span> state. Methods decorated with the <kbd>@PreDestroy</kbd> annotation are executed just before the bean goes to the <span class="packt_screen">Does Not Exist</span> state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EJB timer service</h1>
                </header>
            
            <article>
                
<p>Stateless session beans and message-driven beans can have a method that is executed periodically at regular intervals of time. This can be accomplished by using the <span class="0Text">EJB timer service</span><span class="1Text">.</span> The following example illustrates how to take advantage of this feature:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
//imports omitted 
 
@Stateless 
public class EjbTimerExampleBean implements EjbTimerExample 
{ 
  private static Logger logger = <strong>Logger.getLogger(EjbTimerExampleBean.class</strong>  
      .getName());  
  <strong>@Resource  
  TimerService timerService;  
</strong> 
  public void startTimer(Serializable info)  
  {  
    <strong>Timer timer = timerService.createTimer  
      (new Date(), 5000, info);</strong>  
  }  
 
  public void stopTimer(Serializable info)  
  {  
    Timer timer;  
    Collection timers = timerService.getTimers();  
 
    for (Object object : timers)  
    {  
      timer = ((Timer) object);  
 
      if (timer.getInfo().equals(info))  
      {  
        timer.cancel();  
        break;  
      }  
    }  
  }  
 
<strong>  @Timeout </strong> 
  public void logMessage(Timer timer)  
  {  
    logger.info("This message was triggered by :" +  
        timer.getInfo() + " at "  
        + System.currentTimeMillis());  
  }  
} </pre>
<p>In the preceding example, we inject an implementation of the <kbd>javax.ejb.TimerService</kbd> interface by decorating an instance variable of this type with the <kbd>@Resource</kbd> annotation. We can then create a timer by invoking the <kbd>createTimer()</kbd> method of this <kbd>TimerService</kbd> instance.</p>
<p>There are several overloaded versions of the <kbd>createTimer()</kbd> method. The one we chose to use takes an instance of <kbd>java.util.Date</kbd> as its first parameter; this parameter is used to indicate the first time the timer should expire ("trfgo off"). In the example, we chose to use a brand new instance of the <kbd>Date</kbd> class, which makes the timer expire immediately. The second parameter of the <kbd>createTimer()</kbd> method is the amount of time to wait, in milliseconds, before the timer expires again. In the preceding example, the timer will expire every five seconds. The third parameter of the <kbd>createTimer()</kbd> method can be an instance of any class implementing the <kbd>java.io.Serializable</kbd> interface. Since a single EJB can have several timers executing concurrently, this third parameter is used to uniquely identify each of the timers. If we don't need to identify the timers, null can be passed as a value for this parameter.</p>
<div class="packt_infobox">The EJB method invoking <kbd>TimerService.createTimer()</kbd> must be called from an EJB client. Placing this call in an EJB method (decorated with the <kbd>@PostConstruct</kbd> annotation to start the timer automatically when the bean is placed in the <span class="packt_screen">Ready</span> state) will result in an <kbd>IllegalStateException</kbd> being thrown.</div>
<p>We can stop a timer by invoking its <kbd>cancel()</kbd> method. There is no way to directly obtain a single timer associated with an EJB; what we need to do is invoke the <kbd>getTimers()</kbd> method on the instance of <kbd>TimerService</kbd> that is linked to the EJB. This method will return a collection containing all the timers associated with the EJB; we can then iterate through the collection and cancel the correct one by invoking its <kbd>getInfo()</kbd> method. This method will return the <kbd>Serializable</kbd> object we passed as a parameter to the <kbd>createTimer()</kbd> method.</p>
<p>Finally, any EJB method decorated with the <kbd>@Timeout</kbd> annotation will be executed when a timer expires. Methods decorated with this annotation must return void and take a single parameter of type <kbd>javax.ejb.Timer</kbd>. In our example, the method simply writes a message to the server log.</p>
<p>The following class is a standalone client for the preceding EJB:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.EJB; 
 
public class Client 
{ 
  @EJB  
  private static EjbTimerExample ejbTimerExample;  
 
  public static void main(String[] args)  
  {  
    try  
    {  
      System.out.println("Starting timer 1...");  
    <strong>  ejbTimerExample.startTimer("Timer 1"); </strong> 
      System.out.println("Sleeping for 2 seconds...");  
      Thread.sleep(2000);  
      System.out.println("Starting timer 2...");  
     <strong> ejbTimerExample.startTimer("Timer 2"); </strong> 
      System.out.println("Sleeping for 30 seconds...");  
      Thread.sleep(30000);  
      System.out.println("Stopping timer 1...");  
     <strong> ejbTimerExample.stopTimer("Timer 1"); </strong> 
      System.out.println("Stopping timer 2...");  
     <strong> ejbTimerExample.stopTimer("Timer 2");</strong>  
      System.out.println("Done.");  
    }  
    catch (InterruptedException e)  
    {  
      e.printStackTrace();  
    }  
  }  
} </pre>
<p>The example simply starts a timer, waits for a couple of seconds, and then starts a second timer. It then sleeps for 30 seconds and then stops both timers. After deploying the EJB and executing the client, we should see some entries like this in the server log:</p>
<pre>    <strong>[2013-08-26T20:44:55.180-0400] [glassfish 4.0] [INFO] [] [net.ensode.javaeebook.EjbTimerExampleBean] [tid: _ThreadID=147 _ThreadName=__ejb-thread-pool1] [timeMillis: 1377564295180] [levelValue: 800] [[</strong>
    
    <strong>  This message was triggered by :Timer 1 at 1377564295180]]</strong>
    
    
    
    <strong>[2013-08-26T20:44:57.203-0400] [glassfish 4.0] [INFO] [] [net.ensode.javaeebook.EjbTimerExampleBean] [tid: _ThreadID=148 _ThreadName=__ejb-thread-pool2] [timeMillis: 1377564297203] [levelValue: 800] [[</strong>
    
    <strong>  This message was triggered by :Timer 2 at 1377564297203]]</strong>
    
    
    
    <strong>[2013-08-26T20:44:58.888-0400] [glassfish 4.0] [INFO] [] [net.ensode.javaeebook.EjbTimerExampleBean] [tid: _ThreadID=149 _ThreadName=__ejb-thread-pool3] [timeMillis: 1377564298888] [levelValue: 800] [[</strong>
    
    <strong>  This message was triggered by :Timer 1 at 1377564298888]]</strong>
    
    
    
    <strong>[2013-08-26T20:45:01.156-0400] [glassfish 4.0] [INFO] [] [net.ensode.javaeebook.EjbTimerExampleBean] [tid: _ThreadID=150 _ThreadName=__ejb-thread-pool4] [timeMillis: 1377564301156] [levelValue: 800] [[</strong>
    
    <strong>  This message was triggered by :Timer 2 at 1377564301156]]</strong>
  </pre>
<p>These entries are created each time one of the timer expires.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calendar-based EJB timer expressions</h1>
                </header>
            
            <article>
                
<p>The example in the previous section has one disadvantage: the <kbd>startTimer()</kbd> method in the session bean must be invoked from a client in order to start the timer. This restriction makes it difficult to have the timer start as soon as the bean is deployed.</p>
<p>Java EE 6 introduced calendar-based EJB timer expressions. Calendar-based expressions allow one or more methods in our session beans to be executed at a certain date and time. For example, we could configure one of our methods to be executed every night at 8:10 pm, which is exactly what our next example does:</p>
<pre style="padding-left: 60px">package com.ensode.javaeebook.calendarbasedtimer; 
 
import java.util.logging.Logger; 
import javax.ejb.Stateless; 
import javax.ejb.LocalBean; 
import javax.ejb.Schedule; 
 
@Stateless 
@LocalBean 
public class CalendarBasedTimerEjbExampleBean { 
 
  private static Logger logger = Logger.getLogger( 
      CalendarBasedTimerEjbExampleBean.class.getName()); 
 
  <strong>@Schedule(hour = "20", minute = "10")</strong> 
  public void logMessage() { 
    logger.info("This message was triggered at:" 
        + System.currentTimeMillis()); 
  } 
} </pre>
<p>As we can see in the preceding example, we set up the time when the method will be executed via the <kbd>javax.ejb.Schedule</kbd> annotation. In this particular example, we set up our method to be executed at 8:10 pm by setting the <kbd>hour</kbd> attribute of the <kbd>@Schedule</kbd> annotation to <kbd>"20"</kbd>, and its minute attribute to <kbd>"10"</kbd> (since the value of the hour attribute is 24 hour-based, hour 20 is equivalent to 8:00 pm).</p>
<p>The <kbd>@Schedule</kbd> annotation has several other attributes that allow a lot of flexibility in specifying when the method should be executed. We could, for instance, have a method executed on the third Friday of every month, or on the last day of the month, and so on and so forth.</p>
<p>The following table lists all the attributes in the <kbd>@Schedule</kbd> annotation that allow us to control when the annotated method will be executed:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Attribute</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example values</strong></p>
</td>
<td>
<p><strong>Default value</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>dayOfMonth</kbd></p>
</td>
<td>
<p>The day of the month</p>
</td>
<td>
<p><kbd>"3"</kbd>: The third day of the month<br/>
<kbd>"Last"</kbd>: The last day of the month</p>
<p><kbd>"-2"</kbd>: Two days before the end of the month</p>
<p><kbd>"1st Tue"</kbd>: The first Tuesday of the month</p>
</td>
<td>
<p><kbd>"*"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>dayOfWeek</kbd></p>
</td>
<td>
<p>The day of the week</p>
</td>
<td>
<p><kbd>"3"</kbd>: Every Wednesday</p>
<p><kbd>"Thu"</kbd>: Every Thursday</p>
</td>
<td>
<p><kbd>"*"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hour</kbd></p>
</td>
<td>
<p>Hour of the day (24 hour-based)</p>
</td>
<td>
<p><kbd>"14"</kbd>: 2:00 pm</p>
</td>
<td>
<p><kbd>"0"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>minute</kbd></p>
</td>
<td>
<p>Minute of the hour</p>
</td>
<td>
<p><kbd>"10"</kbd>: Ten minutes after the hour</p>
</td>
<td>
<p><kbd>"0"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>month</kbd></p>
</td>
<td>
<p>Month of the year</p>
</td>
<td>
<p><kbd>"2"</kbd>: February</p>
<p><kbd>"March"</kbd>: March</p>
</td>
<td>
<p><kbd>"*"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>second</kbd></p>
</td>
<td>
<p>Second of the minute</p>
</td>
<td>
<p><kbd>"5"</kbd>: Five seconds after the minute</p>
</td>
<td>
<p><kbd>"0"</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>timezone</kbd></p>
</td>
<td>
<p>Timezone ID</p>
</td>
<td>
<p><kbd>"America/New York"</kbd></p>
</td>
<td>
<p>""</p>
</td>
</tr>
<tr>
<td>
<p><kbd>year</kbd></p>
</td>
<td>
<p>Four digit year</p>
</td>
<td>
<p><kbd>"2010"</kbd></p>
</td>
<td>
<p><kbd>"*"</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>In addition to single values, most attributes accept the asterisk (<kbd>*</kbd>) as a wild card, meaning that the annotated method will be executed every unit of time (every day, hour, and so on).</p>
<p>Additionally, we can specify more than one value by separating the values with commas; for example, if we needed a method to be executed every Tuesday and Thursday, we could annotate the method as <kbd>@Schedule(dayOfWeek="Tue, Thu")</kbd>.</p>
<p>We can also specify a range of values, with the first value and last value separated by a dash (-); to execute a method from Monday through Friday, we could use <kbd>@Schedule(dayOfWeek="Mon-Fri")</kbd>.</p>
<p>Additionally, we could specify that we need the method to be executed every <em>n</em> units of time (for example, every day, every 2 hours, every 10 minutes, and so on). To do something like this, we could use <kbd>@Schedule(hour="*/12")</kbd>, which would execute the method every 12 hours.</p>
<p>As we can see, the <kbd>@Schedule</kbd> annotation provides a lot of flexibility when it comes to specifying when we need our methods executed. Plus, it provides the advantage of not needing a client call to activate the scheduling. Additionally, it has the advantage of using a cron-like syntax; therefore, developers familiar with this Unix tool will feel right at home using this annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EJB security</h1>
                </header>
            
            <article>
                
<p>Enterprise JavaBeans allow us to declaratively decide which users can access their methods. For example, some methods might only be available to users in certain roles. A typical scenario is that only users with the administrator role can add, delete, or modify other users in the system.</p>
<p>The following example is a slightly modified version of the DAO session bean we saw earlier in this chapter. In this version, some methods that were previously private are made public. Additionally, the session bean was modified to allow only users in certain roles to access its methods:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
// imports omitted 
 
@Stateless 
<strong>@RolesAllowed("appadmin")</strong> 
public class CustomerDaoBean implements CustomerDao 
{ 
  @PersistenceContext 
  private EntityManager entityManager; 
 
  @Resource(name = "jdbc/__CustomerDBPool") 
  private DataSource dataSource; 
 
  public void saveCustomer(Customer customer) 
  { 
    if (customer.getCustomerId() == null) 
    { 
      saveNewCustomer(customer); 
    } 
    else 
    { 
      updateCustomer(customer); 
    } 
  } 
 
  public Long saveNewCustomer(Customer customer) 
  {      
    entityManager.persist(customer); 
 
    return customer.getCustomerId(); 
  } 
 
  public void updateCustomer(Customer customer) 
  { 
    entityManager.merge(customer); 
  } 
 
<strong>  @RolesAllowed({ "appuser", "appadmin" })</strong> 
  public Customer getCustomer(Long customerId) 
  { 
    Customer customer; 
 
    customer = entityManager.find(Customer.class, customerId); 
 
    return customer; 
  } 
 
  public void deleteCustomer(Customer customer) 
  { 
    entityManager.remove(customer); 
  } 
} </pre>
<p>As we can see, we declare what roles have access to the methods by using the <kbd>@RolesAllowed</kbd> annotation. This annotation can take either a single string or an array of strings as a parameter. When a single string is used as a parameter for this annotation, only users with the role specified by the parameter can access the method. If an array of strings is used as a parameter, users with any of the roles specified by the array's elements can access the method.</p>
<p>The <kbd>@RolesAllowed</kbd> annotation can be used to decorate an EJB class, in which case its values apply to all the methods in the EJB, or to one or more methods; in this second case its values apply only to the method the annotation is decorating. If, like in our example, both the EJB class and one or more of its methods are decorated with the <kbd>@RolesAllowed</kbd> annotation, the method level annotation takes precedence.</p>
<p>The procedure to create roles varies from application server to application server; when using GlassFish, application roles need to be mapped to a security realm's group name (refer to <a href="31a037d6-63a1-415d-a27f-dbec1ccff2cb.xhtml" target="_blank">Chapter 9</a>, <em>Securing Java EE Applications</em> for details). This mapping, along with what realm to use, is set in the <kbd>glassfish-ejb-jar.xml</kbd> deployment descriptor:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt; 
&lt;glassfish-ejb-jar&gt; 
    &lt;security-role-mapping&gt; 
        &lt;role-name&gt;appuser&lt;/role-name&gt; 
        &lt;group-name&gt;appuser&lt;/group-name&gt; 
    &lt;/security-role-mapping&gt; 
    &lt;security-role-mapping&gt; 
        &lt;role-name&gt;appadmin&lt;/role-name&gt; 
        &lt;group-name&gt;appadmin&lt;/group-name&gt; 
    &lt;/security-role-mapping&gt; 
    &lt;enterprise-beans&gt; 
        &lt;ejb&gt; 
            &lt;ejb-name&gt;CustomerDaoBean&lt;/ejb-name&gt; 
            &lt;ior-security-config&gt; 
                &lt;as-context&gt; 
                    &lt;auth-method&gt;username_password&lt;/auth-method&gt; 
                    &lt;realm&gt;file&lt;/realm&gt; 
                    &lt;required&gt;true&lt;/required&gt; 
                &lt;/as-context&gt; 
            &lt;/ior-security-config&gt; 
        &lt;/ejb&gt; 
    &lt;/enterprise-beans&gt; 
&lt;/glassfish-ejb-jar&gt; </pre>
<p>The <kbd>&lt;security-role-mapping&gt;</kbd> element of <kbd>glassfish-ejb-jar.xml</kbd> does the mapping between application roles and the security realm's group. The value of the <kbd>&lt;role-name&gt;</kbd> sub element must contain the application role; this value must match the value used in the <kbd>@RolesAllowed</kbd> annotation. The value of the <kbd>&lt;group-name&gt;</kbd> sub-element must contain the name of the security group in the security realm used by the EJB. In the preceding example, we map two application roles to the corresponding groups in the security realm. Although in this particular example the name of the application role and the security group match, this does not need to be the case.</p>
<div class="packt_infobox"><span class="packt_screen">Automatically matching roles to security groups:</span> <span>When using GlassFish, it is possible to automatically match any application roles to identically-named security groups in the security realm. This can be accomplished by logging in to the GlassFish web console, clicking on the</span> <span class="packt_screen">Configuration</span> <span>node, clicking on</span> <span class="packt_screen">Security</span><span>, clicking on the checkbox labeled</span> <span class="packt_screen">Default</span> <span class="packt_screen">Principal To Role Mapping,</span> <span>and finally saving this configuration change.</span></div>
<p>As can be seen in the example, the security realm to use for authentication is defined in the <kbd>&lt;realm&gt;</kbd> sub-element of the <kbd>&lt;as-context&gt;</kbd> element. The value of this sub-element must match the name of a valid security realm in the application server. Other sub-elements of the <kbd>&lt;as-context&gt;</kbd> element include <kbd>&lt;auth-method&gt;;</kbd> the only valid value for this element is <kbd>username_password</kbd>, and <kbd>&lt;required&gt;</kbd>, whose only valid values are <kbd>true</kbd> and <kbd>false</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client authentication</h1>
                </header>
            
            <article>
                
<p>If the client code accessing a secured EJB is part of a web application whose user has already authenticated, then the user's credentials will be used to determine whether the user should be allowed to access the method they are trying to execute.</p>
<p>When using GlassFish as our application server, standalone clients must be executed through the <kbd>appclient</kbd> utility. The following code illustrates a typical client for the secured session bean:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook; 
 
import javax.ejb.EJB; 
 
public class Client 
{ 
 <strong> @EJB</strong> 
  private static CustomerDao customerDao; 
 
  public static void main(String[] args) 
  { 
    Long newCustomerId; 
 
    Customer customer = new Customer(); 
    customer.setFirstName("Mark"); 
    customer.setLastName("Butcher"); 
    customer.setEmail("butcher@phony.org"); 
 
    System.out.println("Saving New Customer..."); 
    newCustomerId = customerDao.saveNewCustomer(customer); 
 
    System.out.println("Retrieving customer..."); 
    customer = customerDao.getCustomer(newCustomerId); 
    System.out.println(customer); 
  } 
} </pre>
<p>As we can see, the code does nothing to authenticate the user. The session bean is simply injected into the code via the <kbd>@EJB</kbd> annotation and it is used as usual. How this is handled varies depending on what application server we are using. GlassFish's <kbd>appclient</kbd> utility takes care of authenticating the user, after invoking the client code via the <kbd>appclient</kbd> utility:</p>
<pre>appclient -client ejbsecurityclient.jar</pre>
<p>The <kbd>appclient</kbd> utility will present the user with a login window when it attempts to invoke a secure method on the EJB:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ded62140-eecf-4f97-a13a-11fdf832ee38.png" style="width:23.83em;height:10.92em;"/></div>
<p>Assuming the credentials are correct and that the user has the appropriate permissions, the EJB code will execute and we should see the expected output from the preceding <kbd>Client</kbd> class:</p>
<pre>    <strong>Saving New Customer...</strong>
    <strong>Retrieving customer...</strong>
    <strong>customerId = 29</strong>
    <strong>firstName = Mark</strong>
    <strong>lastName = Butcher</strong>
    <strong>email = <span class="InternetLink">butcher@phony.org</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to implement business logic via stateless and stateful session beans. Additionally, we covered how to implement message-driven beans to consume JMS messages.</p>
<p>We also explained how to take advantage of the transactional nature of EJBs to simplify implementing the DAO pattern.</p>
<p>Additionally, we explained the concept of container-managed transactions, and how to control them by using the appropriate annotations. We also explained how to implement bean-managed transactions, for cases in which container-managed transactions are not enough to satisfy our requirements.</p>
<p>Life cycles for the different types of Enterprise JavaBean were covered, including an explanation on how to have EJB methods automatically invoked by the EJB container at certain points in the life cycle.</p>
<p>We also covered how to have EJB methods invoked periodically by the EJB container by taking advantage of the EJB timer service.</p>
<p>Finally, we looked at how to make sure EJB methods are only invoked by authorized users by annotating EJB classes and/or methods with the appropriate EJB security annotations.</p>


            </article>

            
        </section>
    </body></html>