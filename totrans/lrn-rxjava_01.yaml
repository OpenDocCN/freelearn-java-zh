- en: Thinking Reactively
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式思维
- en: It is assumed you are fairly comfortable with Java and know how to use classes,
    interfaces, methods, properties, variables, static/nonstatic scopes, and collections.
    If you have not done concurrency or multithreading, that is okay. RxJava makes
    these advanced topics much more accessible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对 Java 比较熟悉，并且知道如何使用类、接口、方法、属性、变量、静态/非静态作用域和集合。如果您没有进行过并发或多线程编程，那也无所谓。RxJava
    使这些高级主题变得更加容易理解。
- en: Have your favorite Java development environment ready, whether it is Intellij
    IDEA, Eclipse, NetBeans, or any other environment of your choosing. I will be
    using Intellij IDEA, although it should not matter or impact the examples in this
    book. I recommend that you have a build automation system as well such as Gradle
    or Maven, which we will walk through shortly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好您喜欢的 Java 开发环境，无论是 Intellij IDEA、Eclipse、NetBeans 还是您选择的任何其他环境。我将使用 Intellij
    IDEA，尽管这不应该影响本书中的示例。我建议您还应该有一个构建自动化系统，例如 Gradle 或 Maven，我们很快就会介绍这些。
- en: 'Before we dive deep into RxJava, we will cover some core topics first:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 RxJava 之前，我们首先会介绍一些核心主题：
- en: A brief history of Reactive Extensions and RxJava
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactive Extensions 和 RxJava 的简要历史
- en: Thinking reactively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式思维
- en: Leveraging RxJava
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 RxJava
- en: Setting up your first RxJava project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的第一个 RxJava 项目
- en: Building your first reactive applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建您的第一个反应式应用程序
- en: Differences between RxJava 1.0 and RxJava 2.0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava 1.0 和 RxJava 2.0 之间的区别
- en: A brief history of ReactiveX and RxJava
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveX 和 RxJava 的简要历史
- en: As developers, we tend to train ourselves to think in counter-intuitive ways.
    Modeling our world with code has never been short of challenges. It was not long
    ago that object-oriented programming was seen as the silver bullet to solve this
    problem. Making blueprints of what we interact with in real life was a revolutionary
    idea, and this core concept of classes and objects still impacts how we code today.
    However, business and user demands continued to grow in complexity. As 2010 approached,
    it became clear that object-oriented programming only solved part of the problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们倾向于训练自己以反直觉的方式思考。用代码来模拟我们的世界从未缺乏挑战。面向对象编程被看作是解决这个问题的银弹，不久前还被视为革命性的想法，而类和对象的核心概念至今仍在影响我们的编码方式。然而，业务和用户需求持续增长，复杂性也在增加。随着
    2010 年的临近，很明显，面向对象编程只解决了问题的一部分。
- en: Classes and objects do a great job of representing an entity with properties
    and methods, but they become messy when they need to interact with each other
    in increasingly complex (and often unplanned) ways. Decoupling patterns and paradigms
    emerged, but this yielded an unwanted side effect of growing amounts of boilerplate
    code. In response to these problems, functional programming began to make a comeback,
    not to replace object-oriented programming, but rather to complement it and fill
    this void. Reactive programming, a functional event-driven programming approach,
    began to receive special attention.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象在表示具有属性和方法的对象方面做得很好，但当它们需要以越来越复杂（并且通常是未计划）的方式相互交互时，它们就会变得混乱。解耦模式和范式出现了，但这导致了大量样板代码的副作用。为了应对这些问题，函数式编程开始复兴，不是为了取代面向对象编程，而是为了补充它并填补这个空白。反应式编程，一种函数式事件驱动编程方法，开始受到特别的关注。
- en: A couple of reactive frameworks emerged ultimately, including **Akka** and **Sodium**.
    But at Microsoft, a computer scientist named Erik Meijer created a reactive programming
    framework for .NET called **Reactive Extensions**. In a matter of years, Reactive
    Extensions (also called **ReactiveX** or **Rx***)* was ported to several languages
    and platforms, including JavaScript, Python, C++, Swift, and Java, of course.
    ReactiveX quickly emerged as a cross-language standard to bring reactive programming
    into the industry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终出现了几个反应式框架，包括 **Akka** 和 **Sodium**。但在微软，一位名叫 Erik Meijer 的计算机科学家创建了一个名为 **Reactive
    Extensions** 的反应式编程框架。在短短几年内，Reactive Extensions（也称为 **ReactiveX** 或 **Rx**）被移植到包括
    JavaScript、Python、C++、Swift 和 Java 在内的多种语言和平台上。ReactiveX 迅速成为跨语言标准，将反应式编程带入行业。
- en: RxJava, the ReactiveX port for Java, was created in large part by Ben Christensen
    from Netflix and David Karnok. RxJava 1.0 was released in November 2014, followed
    by RxJava 2.0 in November 2016\. RxJava is the backbone to other ReactiveX JVM
    ports, such as **RxScala**, **RxKotlin**, and **RxGroovy**. It has become a core
    technology for Android development and has also found its way into Java backend
    development. Many RxJava adapter libraries, such as **RxAndroid** ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid)),
    **RxJava-JDBC** ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc)),
    **RxNetty** ([https://github.com/ReactiveX/RxNetty](https://github.com/ReactiveX/RxNetty)),
    and  **RxJavaFX** ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX))
    adapted several Java frameworks to become reactive and work with RxJava out of
    the box.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava，Java的ReactiveX端口，主要由Netflix的Ben Christensen和David Karnok创建。RxJava 1.0于2014年11月发布，随后在2016年11月发布了RxJava
    2.0。RxJava是其他ReactiveX JVM端口的支柱，例如**RxScala**、**RxKotlin**和**RxGroovy**。它已成为Android开发的核心技术，并且也进入了Java后端开发领域。许多RxJava适配库，如**RxAndroid**
    ([https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid))、**RxJava-JDBC**
    ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc))、**RxNetty**
    ([https://github.com/ReactiveX/RxNetty](https://github.com/ReactiveX/RxNetty))和**RxJavaFX**
    ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX))，将几个Java框架适配为响应式，并能够与RxJava无缝协作。
- en: This all shows that RxJava is more than a library. It is part of a greater ReactiveX
    ecosystem that represents an entire approach to programming. The fundamental idea
    of ReactiveX is that *events are data and data are events*. This is a powerful
    concept that we will explore later in this chapter, but first, let's step back
    and look at the world through the reactive lens.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都表明，RxJava不仅仅是一个库。它是更大的ReactiveX生态系统的一部分，代表了整个编程方法。ReactiveX的基本思想是*事件是数据，数据是事件*。这是一个强大的概念，我们将在本章后面进行探讨，但首先，让我们退后一步，用响应式视角来看待这个世界。
- en: Thinking reactively
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式思考
- en: Suspend everything you know about Java (and programming in general) for a moment,
    and let's make some observations about our world. These may sound like obvious
    statements, but as developers, we can easily overlook them. Bring your attention
    to the fact that everything is in motion. Traffic, weather, people, conversations,
    financial transactions, and so on are all moving. Technically, even something
    stationary as a rock is in motion due to the earth's rotation and orbit. When
    you consider the possibility that everything can be modeled as in motion, you
    may find it a bit overwhelming as a developer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时放下你对Java（以及一般编程）的所有已知知识，让我们对我们的世界做一些观察。这些可能听起来像是显而易见的陈述，但作为开发者，我们很容易忽略它们。请注意，一切都在运动。交通、天气、人们、对话、金融交易等等都在移动。技术上，甚至像石头这样静止的东西也因为地球的旋转和轨道而处于运动状态。当你考虑一切都可以被建模为运动的可能性时，你可能会发现这作为开发者来说有点令人不知所措。
- en: Another observation to note is that these different events are happening concurrently.
    Multiple activities are happening at the same time. Sometimes, they act independently,
    but other times, they can converge at some point to interact. For instance, a
    car can drive with no impact on a person jogging. They are two separate streams
    of events. However, they may converge at some point and the car will stop when
    it encounters the jogger.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的观察是，这些不同的事件是同时发生的。多个活动在同一时间进行。有时，它们独立行动，但有时，它们可以在某个点上汇聚以进行交互。例如，一辆车在跑步者没有受到影响的情况下行驶。它们是两个独立的事件流。然而，它们可能在某个点上汇聚，当车遇到跑步者时，车会停下来。
- en: If this is how our world works, why do we not model our code this way?. Why
    do we not model code as multiple concurrent streams of events or data happening
    at the same time? It is not uncommon for developers to spend more time managing
    the states of objects and doing it in an imperative and sequential manner. You
    may structure your code to execute **Process 1**, **Process 2**, and then **Process
    3**, which depends on Process 1 and Process 2\. Why not kick-off Process 1 and
    Process 2 simultaneously, and then the completion of these two events immediately
    kicks-off Process 3? Of course, you can use callbacks and Java concurrency tools,
    but RxJava makes this much easier and safer to express.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的世界就是这样运作的，为什么我们不以这种方式来建模我们的代码呢？为什么我们不把代码建模为同时发生的多个并发的事件或数据流呢？开发者花费更多时间管理对象的状态，并以命令式和顺序的方式进行操作，这种情况并不少见。你可能将你的代码结构化为执行**过程1**、**过程2**，然后是**过程3**，这依赖于过程1和过程2。为什么不同时启动过程1和过程2，然后这两个事件的完成立即启动过程3呢？当然，你可以使用回调和Java并发工具，但RxJava使这变得更加容易和安全地表达。
- en: Let's make one last observation. A book or music CD is static. A book is an
    unchanging sequence of words and a CD is a collection of tracks. There is nothing
    dynamic about them. However, when we read a book, we are reading each word one
    at a time. Those words are effectively put in motion as a stream being consumed
    by our eyes. It is no different with a music CD track, where each track is put
    in motion as sound waves and your ears are consuming each track. Static items
    can, in fact, be put in motion too. This is an abstract but powerful idea because
    we made each of these static items a series of events. When we level the playing
    field between data and events by treating them both the same, we unleash the power
    of functional programming and unlock abilities you previously might have thought
    impractical. The fundamental idea behind reactive programming is that *events
    are data and data are events*. This may seem abstract, but it really does not
    take long to grasp when you consider our real-world examples. The runner and car
    both have properties and states, but they are also in motion. The book and CD
    are put in motion when they are consumed. Merging the event and data to become
    one allows the code to feel organic and representative of the world we are modeling.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个最后的观察。一本书或音乐CD是静态的。一本书是一系列不变的文字，CD是一系列曲目。它们没有动态性。然而，当我们读书时，我们是逐个阅读每个单词。这些单词实际上被置于运动中，作为被我们眼睛消费的流。音乐CD的曲目也是如此，每个曲目被置于运动中，作为声波，你的耳朵消费每个曲目。静态物品实际上也可以被置于运动中。这是一个抽象但强大的想法，因为我们把每个静态物品变成了一系列事件。当我们通过将数据和事件同等对待来使数据与事件处于同一水平时，我们就释放了函数式编程的力量，并解锁了你以前可能认为不切实际的能力。反应式编程背后的基本思想是**事件是数据，数据是事件**。这可能看起来很抽象，但当你考虑我们的现实世界例子时，实际上并不需要很长时间就能理解。跑步者和汽车都有属性和状态，但它们也在运动中。当它们被消费时，书和CD被置于运动中。将事件和数据合并为一个整体，使得代码感觉有机且能代表我们正在建模的世界。
- en: Why should I learn RxJava?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么要学习RxJava？
- en: ReactiveX and RxJava paints a broad stroke against many problems programmers
    face daily, allowing you to express business logic and spend less time engineering
    code. Have you ever struggled with concurrency, event handling, obsolete data
    states, and exception recovery? What about making your code more maintainable,
    reusable, and evolvable so it can keep up with your business? It might be presumptuous
    to call reactive programming a **silver bullet** to these problems, but it certainly
    is a progressive leap in addressing them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX和RxJava为程序员每天面临的许多问题画了一幅广泛的画，允许你表达业务逻辑，并减少编写代码的时间。你是否曾经为并发、事件处理、过时的数据状态和异常恢复而挣扎过？关于使你的代码更具可维护性、可重用性和可扩展性，以便它能跟上你的业务？称反应式编程为这些问题的**银弹**可能有些自以为是，但它确实是在解决这些问题方面的一个进步飞跃。
- en: There is also growing user demand to make applications real time and responsive.
    Reactive programming allows you to quickly analyse and work with live data sources
    such as Twitter feeds or stock prices. It can also cancel and redirect work, scale
    with concurrency, and cope with rapidly emitting data. Composing events and data
    as streams that can be mixed, merged, filtered, split, and transformed opens up
    radically effective ways to compose and evolve code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户对使应用程序实时和响应的需求也在不断增长。反应式编程允许你快速分析和处理实时数据源，如Twitter流或股价。它还可以取消和重定向工作，与并发性一起扩展，并处理快速发射的数据。将事件和数据作为可以混合、合并、过滤、拆分和转换的流来组合，开辟了极其有效的代码组合和演变方式。
- en: In summary, reactive programming makes many hard tasks easy, enabling you to
    add value in ways you might have thought impractical earlier. If you have a process
    written reactively and you discover that you need to run part of it on a different
    thread, you can implement this change in a matter of seconds. If you find network
    connectivity issues crashing your application intermittently, you can gracefully
    use reactive recovery strategies that wait and try again. If you need to inject
    an operation in the middle of your process, it is as simple as inserting a new
    operator. Reactive programming is broken up into modular chain links that can
    be added or removed, which can help overcome all the aforementioned problems quickly.
    In essence, RxJava allows applications to be tactical and evolvable while maintaining
    stability in production.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，反应式编程使得许多困难任务变得简单，使你能够以你之前可能认为不切实际的方式增加价值。如果你有一个编写为反应式的进程，并且发现你需要将其中一部分运行在不同的线程上，你可以在几秒钟内实现这个更改。如果你发现网络连接问题间歇性地使你的应用程序崩溃，你可以优雅地使用等待并重试的反应式恢复策略。如果你需要在进程的中间注入一个操作，这就像插入一个新的操作符一样简单。反应式编程被分解为模块化的链链接，可以添加或删除，这有助于快速克服上述所有问题。本质上，RxJava允许应用程序在保持生产稳定性同时变得战术性和可演化的。
- en: What we will learn in this book?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在这本书中将学到什么？
- en: As stated earlier, RxJava is the ReactiveX port for Java. In this book, we will
    focus primarily on RxJava 2.0, but I will call out significant differences in
    RxJava 1.0\. We will place priority on learning to think reactively and leverage
    the practical features of RxJava. Starting with a high-level understanding, we
    will gradually move deeper into how RxJava works. Along the way, we will learn
    about reactive patterns and tricks to solve common problems programmers encounter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，RxJava是Java的ReactiveX端口。在这本书中，我们将主要关注RxJava 2.0，但我将指出RxJava 1.0中的显著差异。我们将优先学习如何以反应式的方式思考并利用RxJava的实用功能。从高层次的理解开始，我们将逐渐深入了解RxJava的工作原理。在这个过程中，我们将学习关于反应式模式和解决程序员遇到的常见问题的技巧。
- en: In [Chapter 2](7fea3844-94e9-442e-9d54-239d146a8250.xhtml), *The Observable
    and Subscribers,* [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml)*, Basic
    Operators,* and [Chapter 4](d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml), *Combining
    Observables,* we will cover core Rx concepts with `Observable`, `Observer`, and
    `Operator`. These are the three core entities that make up RxJava applications.
    You will start writing reactive programs immediately and have a solid knowledge
    foundation to build on for the rest of the book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](7fea3844-94e9-442e-9d54-239d146a8250.xhtml)，*可观察者和订阅者*，[第3章](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml)，*基本操作符*和[第4章](d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml)，*合并可观察者*中，我们将通过`Observable`、`Observer`和`Operator`来介绍Rx的核心概念。这三个核心实体构成了RxJava应用程序。你将立即开始编写反应式程序，并拥有一个坚实的基础来构建整本书。
- en: '[Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml), *Multicasting, Replaying,
    and Caching*, and [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml), *Concurrency
    and Parallelization*, will explore more of the nuances of RxJava and how to effectively
    leverage concurrency.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml)，*多播、重放和缓存*以及[第6章](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml)，*并发和并行化*将探讨RxJava的更多细微之处以及如何有效地利用并发。'
- en: In [Chapter 7](964f5943-b955-49f7-b53e-801754d06c3c.xhtml), *Switching, Throttling,
    Windowing, and Buffering* and [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml),
    *Flowables and Backpressure,* we will learn about the different ways to cope with
    reactive streams that produce data/events faster than they can be consumed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](964f5943-b955-49f7-b53e-801754d06c3c.xhtml)，*切换、节流、窗口和缓冲*以及[第8章](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)，*可流动性和背压*中，我们将学习如何应对产生数据/事件的速度超过其消费速度的反应式流的不同方法。
- en: Finally, [Chapter 9](3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml), *Transformers
    and Custom Operators*, [Chapter 10](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml),
    *Testing and Debugging*, [Chapter 11](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml),
    *RxJava on Android*, and [Chapter 12](42947483-7be8-4693-a7e4-2527ad9f180b.xhtml),
    *Using RxJava with Kotlin New,* will touch on several miscellaneous (but essential)
    topics including custom operators as well as how to use RxJava with testing frameworks,
    Android, and the Kotlin language.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第 9 章 *转换器和自定义操作符*，第 10 章 *测试和调试*，第 11 章 *RxJava 在 Android 上的应用*，以及第 12 章
    *使用 Kotlin 新特性与 RxJava 结合* 将涉及一些（但很重要）的杂项主题，包括自定义操作符以及如何使用测试框架、Android 和 Kotlin
    语言与 RxJava 结合。
- en: Setting up
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'There are two co-existing versions of RxJava currently: 1.0 and 2.0\. We will
    go through some of the major differences later and discuss which version you should
    use.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在两个共存的 RxJava 版本：1.0 和 2.0。我们将在稍后讨论一些主要差异，并讨论你应该使用哪个版本。
- en: RxJava 2.0 is a fairly lightweight library and comes just above 2 **Megabytes**
    (**MBs**) in size. This makes it practical for Android and other projects that
    require a low dependency overhead. RxJava 2.0 has only one dependency, called
    **Reactive Streams** ( [http://www.reactive-streams.org/](http://www.reactive-streams.org/)),
    which is a core library (made by the creators of RxJava) that sets a standard
    for asynchronous stream implementations, one of which is RxJava 2.0.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 2.0 是一个相对轻量级的库，其大小仅为 2 **兆字节**（**MBs**）。这使得它在需要低依赖开销的 Android 和其他项目中非常实用。RxJava
    2.0 只有一个依赖项，称为 **Reactive Streams**（[http://www.reactive-streams.org/](http://www.reactive-streams.org/)），这是一个核心库（由
    RxJava 的创建者制作），为异步流实现设定了标准，其中之一就是 RxJava 2.0。
- en: It may be used in other libraries beyond RxJava and is a critical effort in
    the standardization of reactive programming on the Java platform. Note that RxJava
    1.0 does not have any dependencies, including Reactive Streams, which was realized
    after 1.0.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用于 RxJava 之外的库，并且是 Java 平台上反应式编程标准化的关键努力。请注意，RxJava 1.0 没有任何依赖项，包括 Reactive
    Streams，这是在 1.0 之后实现的。
- en: If you are starting a project from scratch, try to use RxJava 2.0\. This is
    the version we will cover in this book, but I will call out significant differences
    in 1.0\. While RxJava 1.0 will be supported for a good while due to countless
    projects using it, innovation will likely only continue onward in RxJava 2.0\.
    RxJava 1.0 will only get maintenance and bug fixes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从零开始一个项目，尝试使用 RxJava 2.0。这是我们将在本书中介绍的这个版本，但我会指出 1.0 版本中的重大差异。虽然由于无数项目在使用它，RxJava
    1.0 将会得到一段时间的支持，但创新可能只会继续在 RxJava 2.0 中进行。RxJava 1.0 将只获得维护和错误修复。
- en: Both RxJava 1.0 and 2.0 run on Java 1.6+. In this book, we will use Java 8,
    and it is recommended that you use a minimum of Java 8 so you can use lambdas
    out of the box. For Android, there are ways to leverage lambdas in earlier Java
    versions that will be addressed later. But weighing the fact that Android Nougat
    uses Java 8 and Java 8 has been out since 2014, hopefully, you will not have to
    do any workarounds to leverage lambdas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 1.0 和 2.0 都运行在 Java 1.6+ 上。在这本书中，我们将使用 Java 8，并建议你使用至少 Java 8，这样你就可以直接使用
    lambda 表达式。对于 Android，稍后我们将讨论如何利用早期 Java 版本的 lambda 表达式。但考虑到 Android Nougat 使用
    Java 8，而 Java 8 自 2014 年以来就已经发布，希望你不需要进行任何工作来利用 lambda 表达式。
- en: Navigating the Central Repository
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航中央仓库
- en: 'To bring in RxJava as a dependency, you have a few options. The best place
    to start is to go to The Central Repository (search [http://search.maven.org/](http://search.maven.org/))
    and search for `rxjav`. You should see RxJava 2.0 and RxJava 1.0 as separate repositories
    at the top of the search results, as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 RxJava 作为依赖项引入，你有几种选择。最好的开始方法是访问中央仓库（搜索 [http://search.maven.org/](http://search.maven.org/)）并搜索
    `rxjav`。你应该在搜索结果顶部看到 RxJava 2.0 和 RxJava 1.0 作为单独的仓库，如下面的截图所示：
- en: '![](img/4c4839c1-0f03-433d-820e-ad6e10f1188e.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c4839c1-0f03-433d-820e-ad6e10f1188e.jpeg)'
- en: Searching for RxJava in the Central Repository (RxJava 2.0 and 1.0 are highlighted)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在中央仓库中搜索 RxJava（RxJava 2.0 和 1.0 被突出显示）
- en: At the time of writing, RxJava 2.0.2 is the latest version for RxJava 2.0 and
    RxJava 1.2.3 is the latest for RxJava 1.0\. You can download the latest JAR file
    for either by clicking the JAR links in the far right under the Download column.
    You can then configure your project to use the JAR file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，RxJava 2.0.2 是 RxJava 2.0 的最新版本，RxJava 1.2.3 是 RxJava 1.0 的最新版本。您可以通过点击下载列最右侧的
    JAR 链接下载任何一个的最新 JAR 文件。然后，您可以配置您的项目使用该 JAR 文件。
- en: 'However, you might want to consider using Gradle or Maven to automatically
    import these libraries into your project. This way, you can easily share and store
    your code project (through GIT or other version control systems) without having
    to download and configure RxJava manually into it each time. To view the latest
    configurations for Maven, Gradle, and several other build automation systems,
    click on the version number for either of the repositories, as highlighted in
    the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能还想考虑使用 Gradle 或 Maven 自动将这些库导入到您的项目中。这样，您可以轻松地共享和存储您的代码项目（通过 GIT 或其他版本控制系统），而无需每次都手动下载和配置
    RxJava。要查看 Maven、Gradle 以及其他几个构建自动化系统的最新配置，请点击任一存储库的版本号，如下面的截图所示：
- en: '*![](img/f79c7693-cd05-4ebc-82c7-b3c75f9c0ebd.jpeg)*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/f79c7693-cd05-4ebc-82c7-b3c75f9c0ebd.jpeg)'
- en: Click the version number under the *Latest Version* column to view the configurations
    for Maven, Gradle, and other major build automation systems
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“最新版本”列下的版本号，可以查看 Maven、Gradle 以及其他主要构建自动化系统的配置。
- en: Using Gradle
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gradle
- en: There are several automated build systems available, but the two most mainstream
    options are Gradle and Maven. Gradle is somewhat a successor to Maven and is especially
    the go-to build automation solution for Android development. If you are not familiar
    with Gradle and would like to learn how to use it, check out the Gradle Getting
    Started guide ([https://gradle.org/getting-started-gradle-java/](https://gradle.org/getting-started-gradle-java/)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的自动化构建系统有很多，但最主流的两个选项是 Gradle 和 Maven。Gradle 可以说是 Maven 的继承者，并且是 Android 开发的首选构建自动化解决方案。如果您不熟悉
    Gradle 并且想学习如何使用它，请查看 Gradle 入门指南 ([https://gradle.org/getting-started-gradle-java/](https://gradle.org/getting-started-gradle-java/))。
- en: 'There are also several decent books that cover Gradle in varying degrees of
    depth, which you can find at [https://gradle.org/books/](https://gradle.org/books/).
    The following screenshot displays the The Central Repository page showing how
    to set up RxJava 2.0.2 for Gradle:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些不错的书籍涵盖了不同深度的 Gradle，您可以在 [https://gradle.org/books/](https://gradle.org/books/)
    找到它们。以下截图显示了中央仓库页面，展示了如何为 Gradle 设置 RxJava 2.0.2：
- en: '![](img/79a6c5b2-4cdc-445e-a053-44f5e6a71999.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79a6c5b2-4cdc-445e-a053-44f5e6a71999.jpeg)'
- en: You can find the latest Gradle configuration code and copy it into your Gradle
    script
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Gradle 脚本中找到最新的 Gradle 配置代码并将其复制进去
- en: 'In your `build.gradle` script, ensure that you have declared `mavenCentral()`
    as one of your repositories. Type in or paste that dependency line `compile ''io.reactivex.rxjava2:rxjava:x.y.z''`,
    where `x.y.z` is the version number you want to use, as shown in the following
    code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `build.gradle` 脚本中，请确保您已声明 `mavenCentral()` 作为您的仓库之一。输入或粘贴以下依赖项行 `compile
    'io.reactivex.rxjava2:rxjava:x.y.z'`，其中 `x.y.z` 是您想要使用的版本号，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build your Gradle project and you should be good to go! You will then have RxJava
    and its types available for use in your project.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Gradle 项目，您应该就可以使用了！然后，您将在项目中可以使用 RxJava 及其类型。
- en: Using Maven
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Maven
- en: 'You also have the option to use Maven, and you can view the appropriate configuration
    in The Central Repository by selecting the Apache Maven configuration information,
    as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有选择使用 Maven 的选项，您可以通过选择以下截图所示的 Apache Maven 配置信息在中央仓库中查看相应的配置：
- en: '![](img/32185d73-dc73-4380-b6e2-e4f0b2cadd0f.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32185d73-dc73-4380-b6e2-e4f0b2cadd0f.jpeg)'
- en: Select and then copy the *Apache Maven* configuration
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择并复制 *Apache Maven* 配置
- en: 'You can then copy and paste the `<dependency>` block containing the RxJava
    configuration and paste it inside a  `<dependencies>`block in your `pom.xml` file.
    Rebuild your project, and you should now have RxJava set up as a dependency. The
    `x.y.z` version number corresponds to the desired RxJava version that you want
    to use:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以复制并粘贴包含 RxJava 配置的 `<dependency>` 块，并将其粘贴到您的 `pom.xml` 文件中的 `<dependencies>`
    块内。重新构建您的项目，现在您应该已经将 RxJava 设置为依赖项。`x.y.z` 版本号对应于您想要使用的 RxJava 版本：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A quick exposure to RxJava
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速了解 RxJava
- en: Before we dive deep into the reactive world of RxJava, here is a quick exposure
    to get your feet wet first. In ReactiveX, the core type you will work with is
    the `Observable`. We will be learning more about the `Observable` throughout the
    rest of this book. But essentially, an `Observable` pushes things. A given **`Observable<T>`**pushes
    things of type `T` through a series of operators until it arrives at an `Observer`
    that consumes the items.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨RxJava的响应式世界之前，这里有一个快速介绍，让你先湿一下脚。在ReactiveX中，你将工作的核心类型是`Observable`。我们将在本书的其余部分学习更多关于`Observable`的内容。但基本上，`Observable`推送事物。给定的**`Observable<T>`**通过一系列操作符推送类型为`T`的事物，直到到达一个消费这些项的`Observer`。
- en: 'For instance, create a new `Launcher.java` file in your project and put in
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的项目中创建一个新的`Launcher.java`文件，并放入以下代码：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our `main()` method,  we have an `Observable<String>` that will push five
    string objects. An `Observable` can push data or events from virtually any source,
    whether it is a database query or live Twitter feeds. In this case, we are quickly
    creating an `Observable` using `Observable.just()`, which will emit a fixed set
    of items.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`方法中，我们有一个将推送五个字符串对象的`Observable<String>`。`Observable`可以从几乎任何来源推送数据或事件，无论是数据库查询还是实时Twitter流。在这种情况下，我们使用`Observable.just()`快速创建一个`Observable`，它将发射一组固定项。
- en: In RxJava 2.0, most types you will use are contained in the `io.reactivex` package.
    In RxJava 1.0, the types are contained in the `rx` package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava 2.0中，你将使用的多数类型都包含在`io.reactivex`包中。在RxJava 1.0中，类型包含在`rx`包中。
- en: 'However, running this `main()` method is not going to do anything other than
    declare `Observable<String>`. To make this `Observable` actually push these five
    strings (which are called emissions), we need an `Observer` to subscribe to it
    and receive the items. We can quickly create and connect an `Observer` by passing
    a lambda expression that specifies what to do with each string it receives:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行这个`main()`方法除了声明`Observable<String>`之外不会做任何事情。为了使这个`Observable`实际上推送这五个字符串（称为排放），我们需要一个`Observer`来订阅它并接收这些项。我们可以通过传递一个lambda表达式来快速创建和连接一个`Observer`，该lambda表达式指定对每个接收到的字符串要执行的操作：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run this code, we should get the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们应该得到以下输出：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What happened here is that our `Observable<String>` pushed each string object
    one at a time to our `Observer`, which we shorthanded using the lambda expression
    `s -> System.out.println(s)`. We pass each string through the parameter `s` (which
    I arbitrarily named) and instructed it to print each one. Lambdas are essentially
    mini functions that allow us to quickly pass instructions on what action to take
    with each incoming item. Everything to the left of the arrow `->` are arguments
    (which in this case is a string we named `s`), and everything to the right is
    the action (which is `System.out.println(s)`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的情况是，我们的`Observable<String>`逐个将字符串对象推送到我们的`Observer`，我们使用lambda表达式`s ->
    System.out.println(s)`来简写它。我们通过参数`s`（我随意命名的）传递每个字符串，并指示它打印每个字符串。Lambda表达式本质上是一些小函数，允许我们快速传递对每个传入项要采取的操作的指令。箭头`->`左侧是参数（在这种情况下是一个我们命名为`s`的字符串），右侧是操作（即`System.out.println(s)`）。
- en: If you are unfamiliar with lambda expressions, turn to *Appendix,* to learn
    more about how they work. If you want to invest extra time in understanding lambda
    expressions, I highly recommend that you read at least the first few chapters
    of *Java 8 Lambdas* (O'Reilly) ([http://shop.oreilly.com/product/0636920030713.do](http://shop.oreilly.com/product/0636920030713.do))
    by Richard Warburton. Lambda expressions are a critical topic in modern programming and
    have become especially relevant to Java developers since their adoption in Java
    8\. We will be using lambdas constantly in this book, so definitely take some
    time getting comfortable with them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对lambda表达式不熟悉，请参阅*附录*，了解更多关于它们的工作原理。如果你想额外花时间理解lambda表达式，我强烈推荐你至少阅读理查德·沃伯顿的《Java
    8 Lambdas》（O'Reilly）的前几章（[http://shop.oreilly.com/product/0636920030713.do](http://shop.oreilly.com/product/0636920030713.do)）。Lambda表达式是现代编程中的一个关键主题，自从Java
    8引入以来，对Java开发者来说尤其相关。在这本书中，我们将不断使用lambda表达式，所以请确保花些时间熟悉它们。
- en: 'We can also use several operators between `Observable` and `Observer` to transform
    each pushed item or manipulate them in some way. Each operator returns a new `Observable`
    derived-off the previous one but reflects that transformation. For example, we
    can use `map()` to turn each string emission into its `length()`, and each length
    integer will then be pushed to `Observer` , as shown in the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`Observable`和`Observer`之间使用几个运算符来转换每个推送的项目或以某种方式操作它们。每个运算符都会返回一个新的`Observable`，它是从上一个`Observable`派生出来的，但反映了这种转换。例如，我们可以使用`map()`将每个字符串发射转换为它的`length()`，然后每个长度整数将被推送到`Observer`，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run this code, we should get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们应该得到以下输出：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you have used Java 8 Streams or Kotlin sequences, you might be wondering
    how `Observable` is any different. The key difference is that `Observable` pushes
    the items while Streams and sequences pull the items. This may seem subtle, but
    the impact of a push-based iteration is far more powerful than a pull-based one.
    As we saw earlier, you can push not only data, but also events. For instance,
    `Observable.interval()` will push a consecutive `Long` at each specified time
    interval, as shown in the following code snippet. This `Long` emission is not
    only data, but also an event! Let''s take a look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Java 8 Streams或Kotlin序列，你可能想知道`Observable`有什么不同。关键的区别是`Observable`推送项目，而Streams和序列则拉取项目。这看起来可能很微妙，但基于推送的迭代的影响远大于基于拉取的迭代。正如我们之前看到的，你可以推送不仅数据，还可以事件。例如，`Observable.interval()`将在每个指定的时间间隔推送一个连续的`Long`，如下面的代码片段所示。这个`Long`发射不仅是数据，也是一个事件！让我们看看：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this code, we should get the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们应该得到以下输出：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you run the preceding code, you will see that a consecutive emission fires
    every second. This application will run for about five seconds before it quits,
    and you will likely see emissions `0` to `4` fired, each separated by a just a
    second's gap. This simple idea that data is a series of events over time will
    unlock new possibilities in how we tackle programming.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，你会看到每秒都会触发一个连续的发射。这个应用程序将在大约五秒后退出，你可能会看到发射`0`到`4`，每个发射之间只隔了一秒钟。这个简单的想法，即数据是随时间的一系列事件，将为我们解决编程问题提供新的可能性。
- en: On a side note, we will get more into concurrency later, but we had to create
    a **`sleep()`** method because this `Observable` fires emissions on a computation
    thread when subscribed to. The main thread used to launch our application is not
    going to wait on this `Observable` since it fires on a computation thread, not
    the main thread. Therefore, we use `sleep()` to pause the main thread for 5000
    milliseconds and then allow it to reach the end of the `main()` method (which
    will cause the application to terminate). This gives `Observable.interval()` a
    chance to fire for a five second window before the application quits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们将在稍后更深入地探讨并发，但我们必须创建一个**`sleep()`**方法，因为当订阅时，这个`Observable`会在计算线程上触发发射。用于启动我们应用程序的主线程不会等待这个`Observable`，因为它在计算线程上触发，而不是主线程。因此，我们使用`sleep()`暂停主线程5000毫秒，然后允许它到达`main()`方法的末尾（这将导致应用程序终止）。这给了`Observable.interval()`一个在应用程序退出前五秒内触发发射的机会。
- en: Throughout this book, we will uncover many mysteries about `Observable` and
    the powerful abstractions it takes care of for us. If you've conceptually understood
    what is going on here so far, congrats! You are already becoming familiar with
    how reactive code works. To emphasize again, emissions are pushed one at a time
    all the way to `Observer`. Emissions represent both data and an event, which can
    be emitted over time. Of course, beyond `map()`, there are hundreds of operators
    in RxJava, and we will learn about the key ones in this book. Learning which operators
    to use for a situation and how to combine them is the key to mastering RxJava.
    In the next chapter, we will cover `Observable` and `Observer` much more comprehensively.
    We will also demystify events and data being represented in `Observable` a bit
    more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将揭示许多关于`Observable`及其为我们处理的强大抽象的奥秘。如果你到目前为止已经从概念上理解了这里发生的事情，恭喜你！你已经开始熟悉响应式代码的工作方式。再次强调，发射是一次性推送到`Observer`的。发射代表数据和事件，这些事件可以在时间上发射。当然，除了`map()`之外，RxJava还有数百个运算符，我们将在本书中学习关键的一些。了解在特定情况下使用哪些运算符以及如何组合它们是掌握RxJava的关键。在下一章中，我们将更全面地介绍`Observable`和`Observer`。我们还将进一步揭开`Observable`中代表的事件和数据。
- en: RxJava 1.0 versus RxJava 2.0 - which one do I use?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier, you are encouraged to use RxJava 2.0 if you can. It will
    continue to grow and receive new features, while RxJava 1.0 will be maintained
    for bug fixes. However, there are other considerations that may lead you to use
    RxJava 1.0.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: If you inherit a project that is already using RxJava 1.0, you will likely continue
    using that until it becomes feasible to refactor to 2.0\. You can also check out
    David Akarnokd's *RxJava2Interop* project ([https://github.com/akarnokd/RxJava2Interop](https://github.com/akarnokd/RxJava2Interop)),
    which converts Rx types from RxJava 1.0 to RxJava 2.0 and vice versa. After you
    finish this book, you may consider using this library to leverage RxJava 2.0 even
    if you have the RxJava 1.0 legacy code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In RxJava, there are several libraries to make several Java APIs reactive and
    plug into RxJava seamlessly. Just to name a few, these libraries include RxJava-JDBC,
    RxAndroid, RxJava-Extras, RxNetty, and RxJavaFX. At the time of writing this,
    only RxAndroid and RxJavaFX have been fully ported to RxJava 2.0 (although many
    other libraries are following). By the time you are reading this, all major RxJava
    extension libraries will hopefully be ported to RxJava 2.0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You will also want to prefer RxJava 2.0 because it was built on much of the
    hindsight and wisdom gained from RxJava 1.0\. It has better performance, simpler
    APIs, a cleaner approach to backpressure, and a bit more safety when hacking together
    your own operators.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: When to use RxJava
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common question ReactiveX newcomers ask is what circumstances warrant a reactive
    approach? Do we always want to use RxJava? As someone who has been living and
    breathing reactive programming for a while, I have learned that there are two
    answers to this question:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The first answer is when you first start out: *yes!* You always want to take
    a reactive approach. The only way to truly become a master of reactive programming
    is to build reactive applications from the ground up. Think of everything as `Observable`
    and always model your program in terms of data and event flows. When you do this,
    you will leverage everything reactive programming has to offer and see the quality
    of your applications go up significantly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The second answer is that when you become experienced in RxJava, you will find
    cases where RxJava may not be appropriate. There will occasionally be times where
    a reactive approach may not be optimal, but usually, this exception applies to
    only part of your code. Your entire project itself should be reactive. There may
    be parts that are not reactive and for good reason. These exceptions only stand
    out to a trained Rx veteran who sees that returning `List<String>` is perhaps
    better than returning `Observable<String>`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Rx greenhorns should not worry about when something should be reactive versus
    something not reactive. Over time, they will start to see cases where the benefits
    of Rx are marginalized, and this is something that only comes with experience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Rx 新手来说，不必担心何时应该使用响应式编程，何时不应该。随着时间的推移，他们将会开始看到那些使 Rx 优势边缘化的案例，而这只有通过经验才能获得。
- en: So for now, no compromises. Go reactive all the way!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在不要妥协。全面拥抱响应式编程！
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to look at the world in a reactive way. As a
    developer, you may have to retrain yourself from a traditional imperative mindset
    and develop a reactive one. Especially if you have done imperative, object-oriented
    programming for a long time, this can be challenging. But the return on investment
    will be significant as your applications will become more maintainable, scalable,
    and evolvable. You will also have faster turn around and more legible code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何以响应式的方式看待世界。作为一个开发者，你可能需要从传统的命令式思维模式中重新训练自己，并发展出响应式思维。特别是如果你长时间从事命令式和面向对象的编程，这可能会是一项挑战。但回报将是显著的，因为你的应用程序将变得更加易于维护、可扩展和可进化。你也将拥有更快的周转时间和更易读的代码。
- en: We also covered how to configure a RxJava project using Gradle or Maven and
    what decisions should drive whether you should choose RxJava 2.0 versus RxJava
    1.0\. We also got a brief introduction to reactive code and how `Observable` works
    through push-based iteration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何使用 Gradle 或 Maven 配置 RxJava 项目，以及应该根据什么决策来选择 RxJava 2.0 而不是 RxJava 1.0。我们还简要介绍了响应式代码以及
    `Observable` 如何通过基于推送的迭代工作。
- en: By the time you finish this book, you will hopefully find reactive programming
    intuitive and easy to reason with. I hope you find that RxJava not only makes
    you more productive, but also helps you take on tasks you hesitated to do earlier.
    So let's get started!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这本书的时候，你可能会希望发现响应式编程直观且易于理解。我希望你发现 RxJava 不仅使你更高效，还帮助你承担之前犹豫不决的任务。那么，让我们开始吧！
