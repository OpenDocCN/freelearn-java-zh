<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Creating and Adding REST Resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating and Adding REST Resources</h1></div></div></div><p>Up until this point, our application doesn't really do much. This is because it lacks configured REST resources. A REST resource is something that one can refer to as an entity, and in our case, a set of URI templates with a common base URL that one can interact with using common HTTP methods.</p><div class="section" title="Creating a resource class"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec15"/>Creating a resource class</h1></div></div></div><p>We are<a id="id59" class="indexterm"/> building a phonebook application, and thus we need to implement the necessary functionalities for storing and managing contacts. We will create the resource class for the phonebook service. This class will be responsible for handling HTTP requests and generating JSON responses. The resource class will initially provide the endpoints for retrieving, creating, updating, and deleting contacts.</p><p>Please note that we are not yet dealing with structured data or interacting with a database, and thus contact-related information transmitted to and from our application does not follow a specific format.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>How to do it...</h2></div></div></div><p>Perform the following steps for creating a resource class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new package, <code class="literal">com.dwbook.phonebook.resources,</code> and add a <code class="literal">ContactResource</code> class in it.</li><li class="listitem">Import the required packages, <code class="literal">javax.ws.rs.*</code> and <code class="literal">javax.ws.rs.core.*.wdasdasd</code>:<div class="informalexample"><pre class="programlisting">import javax.ws.rs.*;
import javax.ws.rs.core.*;</pre></div></li><li class="listitem">Specify the URI template of the resource by annotating the class with the <code class="literal">@Path</code> annotation<a id="id60" class="indexterm"/> and also specify the response <code class="literal">Content-Type</code> header using <a id="id61" class="indexterm"/>the <code class="literal">@Produces</code> annotation:<div class="informalexample"><pre class="programlisting">@Path("/contact")
@Produces(MediaType.APPLICATION_JSON)
public class ContactResource {
  // code...
}</pre></div></li><li class="listitem">In order to add a method that will return the information regarding a stored contact, create the <code class="literal">#getContact()</code>method. This method will return a <code class="literal">javax.ws.rs.core.Response</code> object, which is a simple but efficient way of <a id="id62" class="indexterm"/>manipulating the actual HTTP response sent to the <a id="id63" class="indexterm"/>client that performs the request. Add the <code class="literal">@GET</code> and <code class="literal">@PATH</code> annotations as shown in the following code snippet. This will bind the method to HTTP GET requests to <code class="literal">/contact/{id}</code>. The <code class="literal">{id}</code> part of the URI represents a variable, and is bound to the <code class="literal">int id</code> parameter<a id="id64" class="indexterm"/> of the same method via the <code class="literal">@PathParam</code> annotation:<div class="informalexample"><pre class="programlisting">  @GET
  @Path("/{id}")
  public Response getContact(@PathParam("id") int id) {
    // retrieve information about the contact with theprovided id
    // ...
    return Response
        .ok("{contact_id: " + id + ", name: \"Dummy Name\",phone: \"+0123456789\" }")
        .build();
  }</pre></div></li><li class="listitem">Similarly, we need to implement appropriate methods for creating, deleting, and updating<a id="id65" class="indexterm"/> contacts. The <code class="literal">#createContact()</code> method for creating contacts will be bound to HTTP POST requests to the <code class="literal">/contact</code> URI. Since nothing is appended to our base URI, this method does not need to be annotated with <code class="literal">@Path</code>. This method will return a <code class="literal">Response</code> object<a id="id66" class="indexterm"/> as well, like all of our resource's methods will, indicating that a new contact has been created:<div class="informalexample"><pre class="programlisting">@POST
public Response createContact(
    @FormParam("name") String name,
    @FormParam("phone") String phone) {
  // store the new contact 
  // ...
  return Response
      .created(null)
      .build();
}</pre></div></li><li class="listitem">For deleting existing contacts, the HTTP client needs to send an HTTP DELETE request to a particular contact's URI. Due to this, the respective method's URI will be exactly the same as the one for retrieving a single contact. Add the <code class="literal">#deleteContact()</code> method to our resource class, as shown in the following <a id="id67" class="indexterm"/>code snippet. We will also need to indicate that the requested URI does not have content anymore:<div class="informalexample"><pre class="programlisting">@DELETE
@Path("/{id}")
public Response deleteContact(@PathParam("id") int id) {
  // delete the contact with the provided id
  // ...
  return Response
      .noContent()
      .build();
}</pre></div></li><li class="listitem">The updates<a id="id68" class="indexterm"/> to existing contacts are generally performed by HTTP PUT requests to a contact's endpoint. The <code class="literal">#updateContact()</code> method<a id="id69" class="indexterm"/> is going to handle such requests and indicate that the update was successful, returning the <a id="id70" class="indexterm"/>appropriate <code class="literal">Response</code> object:<div class="informalexample"><pre class="programlisting">@PUT
@Path("/{id}")
public Response updateContact(
    @PathParam("id") int id,
    @FormParam("name") String name,
    @FormParam("phone") String phone) {
  // update the contact with the provided ID
  // ...
  return Response
        .ok("{contact_id: "+ id +", name: \""+ name +"\",phone: \""+ phone +"\" }")
        .build();
  }</pre></div></li><li class="listitem">Add the implemented resource to our Dropwizard application's environment by modifying the <code class="literal">run</code> method in the <code class="literal">App</code> class via the <code class="literal">JerseyEnvironment#register()</code> method<a id="id71" class="indexterm"/>, as shown in the following code. You also need to add an import clause on top of the <code class="literal">App.java</code> file for the <code class="literal">ContactResource</code> class (import <code class="literal">com.dwbook.phonebook.resources.ContactResource</code>). You should also see that in order to access our application's Jersey environment, you may <a id="id72" class="indexterm"/>use the <code class="literal">Environment#jersey()</code> method:<div class="informalexample"><pre class="programlisting">public void run(PhonebookConfiguration c, Environment e) 
      throws Exception {
    // ...
    // Add the resource to the environment
    e.jersey().register(new ContactResource());
  }</pre></div></li><li class="listitem">Rebuild (with <code class="literal">mvn package</code> ) and run the application <code class="literal">java -jar target/dwbook-phonebook-1.0-SNAPSHOT.jar server config.yaml</code>. You will see a message indicating that our (Jersey based) Dropwizard application<a id="id73" class="indexterm"/> is starting along with a list of configured resources, in this case, the resources defined in our <code class="literal">com.dwbook.phonebook.resources.ContactResource </code>class.<div class="mediaobject"><img src="graphics/9530OS_04_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Point your browser at <code class="literal">http://localhost:8</code><code class="literal">080/contact/100</code> and see the results; it will generate a dummy JSON representation with the ID 100, which you provided in the URL (a path parameter, which will work with any integer).<div class="mediaobject"><img src="graphics/9530OS_04_02.jpg" alt="How to do it..."/></div></li></ol></div><p>The service is running and listening to incoming requests. You can shut it down by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> in your terminal. After a few seconds, the service will stop.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>How it works…</h2></div></div></div><p>The resource class is the most important part of a RESTful Web Service, as it is the place where you define the resources and their URIs you wish to expose.</p><p>The <code class="literal">@Produces</code> annotation<a id="id74" class="indexterm"/> defines the content type of the responses the class methods generate. Despite of defining the value of the HTTP <code class="literal">Content-Type</code> header, it is also used to instruct Jackson to transform the representations to the appropriate format, JSON in this<a id="id75" class="indexterm"/> case; thus the <code class="literal">MediaType.APPLICATION_JSON</code> definition. In case we would want to return an XML document as the response, we should use <code class="literal">MediaType.APPLICATION_XML</code> instead.</p><p>We use<a id="id76" class="indexterm"/> the <code class="literal">@Path</code> annotation to define a URI template. By applying it and bringing it on to the level of a class, we define that the base URI of our resources will be <code class="literal">/contact</code>. We used this annotation for the <code class="literal">#getContact</code> method as well, specifying <a id="id77" class="indexterm"/>the<code class="literal">/{id}</code> template. This leads on to the complete URI that will trigger the execution of <code class="literal">#getContact</code> being <code class="literal">/contact/{id}</code>.</p><p>The <code class="literal">{id}</code> part <a id="id78" class="indexterm"/>of the URI is a path parameter, which we mapped to the <code class="literal">int id</code> argument using the <code class="literal">@PathParam</code> annotation. <code class="literal">PathParam</code> takes the name of the path parameter as its parameter, which in this case is <code class="literal">id</code>.</p><p>Jersey will intercept every incoming HTTP request and try to match it with the defined URI template in order to find which resource class method to invoke.</p><p>It is generally a good practice to define the base URI at the class level, and additionally, more specific URI templates per method.</p><p>In order to configure our application to use the resources we created, we had to add them to the execution<a id="id79" class="indexterm"/> environment, post initialization, in the <code class="literal">#run()</code> method of the <code class="literal">App</code> class.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>There's more…</h2></div></div></div><p>A representation is an entity; something that one can refer to. A representation can be created, updated, deleted, and returned. A REST resource is an endpoint that accepts HTTP requests for such operations.</p><p>We used <a id="id80" class="indexterm"/>the <code class="literal">@GET</code> annotation for the <code class="literal">#getContact()</code> method. This implies that the method is bound to, and only to, the HTTP GET verb. We used this verb because we were returning data about an entity without modifying it in any way.</p><div class="section" title="HTTP verbs – RESTful convention"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>HTTP verbs – RESTful convention</h3></div></div></div><p>Generally, a RESTful <a id="id81" class="indexterm"/>Web Service uses four fundamental HTTP methods (verbs) mapped to CRUD operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">POST for creating a resource</li><li class="listitem" style="list-style-type: disc">PUT for updating a resource</li><li class="listitem" style="list-style-type: disc">DELETE for deleting a resource</li><li class="listitem" style="list-style-type: disc">GET for returning the representation of a resource</li></ul></div><p>GET is an idempotent operation; if given the same input, it will return the same results without modifying the requesting entity in any case.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>You can map HTTP verbs to a resource method (for example, <code class="literal">#getContact()</code>) using an appropriate annotation (such as <code class="literal">@POST</code>, <code class="literal">@PUT</code>, <code class="literal">@DELETE</code>, and <code class="literal">@GET</code>).</p></div></div></div><div class="section" title="HTTP response codes"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec11"/>HTTP response codes</h3></div></div></div><p>Another<a id="id82" class="indexterm"/> important RESTful Web Service design principle, apart from CRUD operations being mapped to specific HTTP methods, is the usage of specific response codes according to the request and the outcome of the action it triggered.</p><p>According to this convention, when a new entity is created successfully, our application would respond indicating <code class="literal">201 Created</code> as the HTTP Response Status code.</p><p>Similarly, when an entity is successfully deleted, our application would send the <code class="literal">204 No Content</code> code. The <code class="literal">204 No Content</code> code may also be used in other cases where the response we send to the client does not include an entity, and not only in cases where we delete resources.</p><p>For most cases though, when our application is returning data while responding to GET requests, the <code class="literal">200 OK</code> response code is sufficient.</p><p>We used the <a id="id83" class="indexterm"/>response class in our implementation in order to include specific response codes to our application's responses.</p></div><div class="section" title="The Response class"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec12"/>The Response class</h3></div></div></div><p>The <code class="literal">javax.ws.rs.Response</code> class, instances of which all of our methods return, provides<a id="id84" class="indexterm"/> a set of <code class="literal">ResponseBuilder</code> methods that we can use for constructing the data we return to the client that performs the HTTP request to our service.</p><p>The <a id="id85" class="indexterm"/>method <code class="literal">Response#ok()</code> accepts an <code class="literal">Object</code> instance as the parameter, which is then serialized to our service's response format (defined by the <code class="literal">@Produces</code> annotation) accordingly. The usage of this method returns an <code class="literal">HTTP 200 OK</code> response code to the client.</p><p>The <code class="literal">Response#noContent()</code> method returns an HTTP <code class="literal">204 No Content</code> response code to the<a id="id86" class="indexterm"/> client, indicating that no content is applicable to this request.</p><p>On the<a id="id87" class="indexterm"/> other hand, the <code class="literal">Response#created()</code> method is used <a id="id88" class="indexterm"/>to send a <code class="literal">201 Created</code> response code along with the URI of the newly created resource. The URI (or null) can be passed as a parameter to this method and will be used as the value for the <code class="literal">Location</code> header of the response.</p><p>The <code class="literal">Response</code> class has a number of useful methods like these, but it also enables us to set custom response codes without necessarily using one of the predefined methods. To do so, you <a id="id89" class="indexterm"/>can use the <code class="literal">Response#status()</code> method by providing it with the appropriate response code, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Response.status(Status.MOVED_PERMANENTLY);</strong></span>
</pre></div><p>Additionally, we are able to use the <code class="literal">ResponseBuilder#entity()</code> method in order to set the <a id="id90" class="indexterm"/>appropriate response payload. The <code class="literal">#entity()</code> method<a id="id91" class="indexterm"/> accepts <code class="literal">Object</code> as the parameter and processes it in <a id="id92" class="indexterm"/>a way similar to the <code class="literal">Response#created()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Response.status(Status.MOVED_PERMANENTLY).entity(new Object());</strong></span>
</pre></div><p>What should be noted is that all these methods return a <code class="literal">ResponseBuilder</code> instance and can be chained as well. In order to build the <code class="literal">Response</code> object, we<a id="id93" class="indexterm"/> must use the <code class="literal">ResponseBuilder#build()</code> method.</p></div></div></div></div></body></html>