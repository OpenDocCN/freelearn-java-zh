- en: Advanced REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to take a look at adding designs to a REST API
    using contract and validation. Then, we will learn about using JSON Web Tokens
    for authentication. And finally, we''ll explore diagnosability, that is, logging,
    metrics, and tracing for a REST API. In this chapter, we''ll cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying Design by Contract—adding validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSON Web Tokens for authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagnosability—logging, metrics, and tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Design by Contract – adding validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at adding validation to the `@PathParam`
    annotation using Javax validation annotations. We will be adding validation POJOs
    and `POST` bodies using Javax validation annotations. I'm going to show you how
    to send the HTTP 404 status code for bad and invalid requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to our IDE. As usual, we will prepare a small template project
    to get started. We create a `BookResource` similar to the one created in the previous
    [Chapter 5](c828a46b-ed97-455d-8228-15b525774aa5.xhtml), *Using Server-Sent Events
    (SSEs)*. There''s one thing missing though: there''s nothing that tells the API
    that the ISBN is valid. Let''s assume we wanted to add a validation for the ISBN
    and make sure that it''s always 10-characters long and that it only contains digits.
    Of course, we could program this manually, but there''s a better approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use Javax validation for this. Let''s do that by adding the
    `@Pattern` annotation. If you hover over the `@Pattern` annotation in your IDE,
    you''ll see that this annotation comes from the Javax validation constraints package.
    We want to use `@Pattern` to say that we want a regular expression (`regexp`)
    only `[0-9]`, and it needs to be 10-digits long; that''s all you need to validate
    the ISBN in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the `@POST` method to create a new book, and we are unsure whether
    the book sent is valid. First, we add a Javax validation (`@Valid`) annotation.
    In this case, we use `@Valid`, which refers the validation to the annotations
    within the `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Book` class has an `isbn` and a `title` but no Javax validation annotations.
    The ISBN should be a valid ISBN and the title should neither be null nor blank.
    We add the `@NotBlank` and `@NotNull` annotations for the `title` and `@Pattern`
    of `isbn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put this to the test. Let''s open our Postman client and try out the
    GET Books list API. We see here that we get one book back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e91cb270-da64-4fa5-8303-3f396b266af1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's try to get a book with an invalid ISBN and see what happens; click
    on the GET Invalid Book API (`http://localhost:8080/advanced/books/4711`). You
    see `4711` in the URI we pass, which is not a valid ISBN because it's not 10-digits
    long. If we send this, we expect that the server will send us back a bad request;
    this tells us the request we sent is not valid. If we request a valid book (GET
    Valid Book), we get status 200 OK, which means the first validations work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new valid book by requesting POST new valid book; we can see
    it has a valid ISBN—10-digits long—and a title. We send this and we get status
    code 201 Created back, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbf9a5cb-269e-4469-b465-c6e1249fa593.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create an invalid book by requesting POST invalid book. Have a look
    at the Body; you''ll see an empty `title` and an invalid `isbn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we send this request, we get 400 Bad Request; the server will not accept
    any bad books that do not comply with our validation annotations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we're going to have a look at using JSON Web Tokens for
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON Web Tokens for authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at decoding **JSON Web Tokens**
    (**JWTs**) using the Auth0 library. We'll see how you can implement and use the
    `ContainerRequest` and `ContainerResponse` filters to handle JWT authentication
    for our REST resources. Finally, we'll be injecting and using decoded JWT in our
    REST resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started. If you visit the JWT website ([https://jwt.io/](https://jwt.io/)),
    you can find relevant information about JWT. Under Debugger, you can see what
    a JWT looks like. We can see the token under Encoded—it consists of a HEADER,
    PAYLOAD, and VERIFY SIGNATURE. This JWT uses symmetric encryption to generate
    the signature. Therefore this value will later be transmitted by the HTTP authorization
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7d71f08-d188-433c-8a86-3837dc6e90b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As usual, we prepare a small template project to get started. First, we activate
    a third-party library, which is required to handle JWT and decode it. We do that
    by adding the following dependency in the POM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement the `ContainerResponse` and `ContainerRequest` filters;
    we do that in the `JwtAuthzVerifier` class. We let the `JwtAuthzVerifier` class
    implement `ContainerRequestFilter` and `ContainerResponseFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement those two methods. We need to implement `filter`. To do so,
    we extract the authorization header from `requestContext` and then decode the
    bearer token (`decodeBearerToken`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the request header, we use `ContainerRequestContext` and extract
    `AUTHORIZATION_HEADER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have that, we can decode the bearer token. This is where we will use
    the Auth0 library. We''ve provided a bit of verification code, which is basically
    programming against the used library. Finally, on the response, we will throw
    away the decoded JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s almost it, but a couple of things are missing. We need to annotate
    `@Provider` under `@ApplicationScoped`. We also need an annotation that will be
    active, so we call `@JwtAuthz`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the `@JwtAuthz` annotation. So far, this is a very basic
    annotation, but we need a special annotation. We need the `@NameBinding` annotation.
    Basically, this annotation binds the annotated `@Provider`, which we''ve done
    in the `JwtAuthzVerifier` class. In this case, we can put the `@Target` annotation
    on a `TYPE`, which is the REST resource, or a REST method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to activate our resource and the verifier. Let''s jump to `AuthenticationResource`
    and to the last final bit. We need to activate our JWT filter for this resource.
    We do that using the `@JwtAuthz` annotation directly on the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we inject the decoded JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add an `authenticate` method. We obtain the claims (`decodedJWT.getClaims()`)
    of the decoded JWT. We construct a `response` and echo the `name` and `subject`
    claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s switch to our REST client. If you want to access this resource, go to
    the path of our `authenticate` resource. Here, we''ve prepared an `Authorization`
    header, and in the Value we use `Bearer` as a token type followed by the JSON
    Web Token in encoded format. When we send this, we should expect the 200 OK status.
    You should see the decoded `name` and `subject` claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4cbc5b1-bc3b-4bae-b076-2be6b531f876.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assume we changed the Value of the `Authorization` header to `Bearer
    notvalid`. If we send this, we should get 401 Unauthorized and the `Invalid JWT
    token.` message. We just secured our REST API using a simple JWT authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63bd77cc-a4d8-47d4-9401-0d8b84d4e87b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will talk about diagnosability and adding logging, metrics,
    and tracing to your REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosability – logging, metrics, and tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at adding request-and-response logging
    using the Jersey logging feature. We'll have a look at using MicroProfile 1.2
    APIs to add metrics and health endpoints. Finally, we'll see how we can include
    tracing with the `OpenTracing` API and Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, let's have a quick look at the diagnosability triangle. Diagnosability
    is really important when it comes to developing web services and distributed applications.
    When people talk about metrics, you might have heard of Prometheus; when it comes
    to logging, maybe you've heard about Fluentd; and for tracing, OpenTracing is
    the most state-of-the-art API out there. Make sure you have a look at these technologies
    and their stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the diagnosability triangle for a small web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/727f06ad-8c5d-460d-ba17-b05464817def.png)'
  prefs: []
  type: TYPE_IMG
- en: The diagnosability triangle
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the IDE to get started. Open the POM file and add a few dependencies.
    The first dependency we want to enable is the `jersey.core` or `jersey-common`
    dependency. This is where the logging feature and the logging filter reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable request-and-response logging for every request, we activate `LoggingFeature`
    in the `JAXRSConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you hover over `LoggingFeature` in our IDE, you can see that it comes from
    the `jersey-common` module; usually this is already provided so we don''t need
    to write it—no extra dependency to add. The final thing we want to do is modify
    `LoggingFeature`. Here, we add a few extra properties and we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will log every request and every response to your log file. Be careful;
    it will produce some seriously large logs. Next, we look at how we can use MicroProfile
    APIs to add metrics and health checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to our POM and activate MicroProfile APIs. Since we''re using
    Payara micro edition, those APIs are also available to us. There are APIs for
    health checks, metrics, fault-tolerance if you need it, and for JWT Auth if you
    don''t want to implement this yourself. We need to add the following dependencies
    in our POM file (the entire code can be found at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go to `MetricsResource` and add a few metrics. This is actually really
    straightforward. Imagine you have a REST resource and you''re interested in how
    long it took for the invocation of the `POST` request. For this, you can add the
    `@Timed` annotation. We specify we want the `unit` in `"milliseconds"` and MicroProfile
    will make sure that every invocation is timed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s even easier if you just want to count invocations. For this, we can use
    the `@Counted` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you''re interested in the current absolute value, you can use `@Gauge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So `@Counted`, `@Gauge`, and `@Timed` are the three metric annotations you can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe we also want to add some health checks, because a good microservice should
    provide health checks. We can specify an `@ApplicationScoped` bean. We annotate
    it using `@Health`, which implements `HealthCheck`; this comes from the MicroProfile
    API. Then we implement our basic health-check logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing is tracing—this is a really complicated issue. I want to show
    you how we can add tracing to your web service. First, we add the tracing API,
    then we add Jaeger as the tracing implementation. We also use a special annotation
    to add OpenTracing to JAX-RS 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the required dependencies. After this we just need to activate the
    tracer. This is done in only a couple of lines of code. We construct a tracing
    `Configuration` from the environment. We register this `Configuration` and `getTracer`
    using `GlobalTracer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what our web service looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman and issue a few requests, such as POST Timed Metric and POST Counted
    Metric. POST Timed Metric invokes the `@Timed` request. POST Counted Metric invokes
    the `@Counted` request; we invoke this one a couple of times.
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the GET Metrics endpoint, which is provided automatically by the MicroProfile
    implementation. We issue our metrics and we can see our custom metrics, such as
    `MetricsResource.gauge`, `MetricsResource.timed`, and `MetricsResource.timed`.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't want JSON and want to use Prometheus, we can do that by invoking
    the Metrics for Prometheus GET request. We can see the Prometheus metrics data
    automatically provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also invoke the GET Healthcheck request to see whether everything is
    okay, we should get the following Body in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Everything is working and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at validating REST API parameters and payloads using
    Javax validation. We learned how to add JWT paste authentication to a REST service
    and decoded JSON Web Tokens manually. Finally, we talked about adding, logging,
    and metrics, and tracing using Jersey, MicroProfile, and other open source components.
  prefs: []
  type: TYPE_NORMAL
