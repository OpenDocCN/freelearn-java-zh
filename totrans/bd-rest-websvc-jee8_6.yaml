- en: Advanced REST APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 REST API
- en: 'In this chapter, we''re going to take a look at adding designs to a REST API
    using contract and validation. Then, we will learn about using JSON Web Tokens
    for authentication. And finally, we''ll explore diagnosability, that is, logging,
    metrics, and tracing for a REST API. In this chapter, we''ll cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用合同和验证向 REST API 添加设计。然后，我们将学习如何使用 JSON Web Tokens 进行身份验证。最后，我们将探索可诊断性，即
    REST API 的日志记录、指标和跟踪。在本章中，我们将涵盖以下主题：
- en: Applying Design by Contract—adding validation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用设计规范——添加验证
- en: Using JSON Web Tokens for authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON Web Tokens 进行身份验证
- en: Diagnosability—logging, metrics, and tracing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可诊断性——日志记录、指标和跟踪
- en: Applying Design by Contract – adding validation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用设计规范——添加验证
- en: In this section, we're going to take a look at adding validation to the `@PathParam`
    annotation using Javax validation annotations. We will be adding validation POJOs
    and `POST` bodies using Javax validation annotations. I'm going to show you how
    to send the HTTP 404 status code for bad and invalid requests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 Javax 验证注解向 `@PathParam` 注解添加验证。我们将添加使用 Javax 验证注解的验证 POJO 和
    `POST` 主体。我将向您展示如何发送 HTTP 404 状态码以表示错误和无效的请求。
- en: 'Let''s switch to our IDE. As usual, we will prepare a small template project
    to get started. We create a `BookResource` similar to the one created in the previous
    [Chapter 5](c828a46b-ed97-455d-8228-15b525774aa5.xhtml), *Using Server-Sent Events
    (SSEs)*. There''s one thing missing though: there''s nothing that tells the API
    that the ISBN is valid. Let''s assume we wanted to add a validation for the ISBN
    and make sure that it''s always 10-characters long and that it only contains digits.
    Of course, we could program this manually, but there''s a better approach.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到我们的 IDE。像往常一样，我们将准备一个小型模板项目以开始。我们创建了一个 `BookResource`，类似于在上一章 [第 5 章](c828a46b-ed97-455d-8228-15b525774aa5.xhtml)，*使用服务器发送事件
    (SSEs)* 中创建的。不过，有一件事是缺失的：没有告诉 API ISBN 是有效的。让我们假设我们想要为 ISBN 添加一个验证，并确保它总是 10 个字符长，并且只包含数字。当然，我们可以手动编写这个程序，但有一个更好的方法。
- en: 'Instead, we can use Javax validation for this. Let''s do that by adding the
    `@Pattern` annotation. If you hover over the `@Pattern` annotation in your IDE,
    you''ll see that this annotation comes from the Javax validation constraints package.
    We want to use `@Pattern` to say that we want a regular expression (`regexp`)
    only `[0-9]`, and it needs to be 10-digits long; that''s all you need to validate
    the ISBN in this case:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用 Javax 验证来实现这一点。让我们通过添加 `@Pattern` 注解来完成它。如果你在 IDE 中悬停在 `@Pattern`
    注解上，你会看到这个注解来自 Javax 验证约束包。我们想使用 `@Pattern` 来表示我们想要一个只包含 `[0-9]` 的正则表达式（`regexp`），并且它需要是
    10 位长；这就是在这种情况下验证 ISBN 所需要的一切：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have the `@POST` method to create a new book, and we are unsure whether
    the book sent is valid. First, we add a Javax validation (`@Valid`) annotation.
    In this case, we use `@Valid`, which refers the validation to the annotations
    within the `Book` class:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `@POST` 方法来创建一个新的书籍，并且我们不确定发送的书籍是否有效。首先，我们添加一个 Javax 验证 (`@Valid`) 注解。在这种情况下，我们使用
    `@Valid`，它将验证指向 `Book` 类内的注解：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Book` class has an `isbn` and a `title` but no Javax validation annotations.
    The ISBN should be a valid ISBN and the title should neither be null nor blank.
    We add the `@NotBlank` and `@NotNull` annotations for the `title` and `@Pattern`
    of `isbn`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book` 类有一个 `isbn` 和一个 `title`，但没有 Javax 验证注解。ISBN 应该是有效的 ISBN，标题既不能为空也不能为空白。我们为
    `title` 添加了 `@NotBlank` 和 `@NotNull` 注解，为 `isbn` 添加了 `@Pattern`：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s put this to the test. Let''s open our Postman client and try out the
    GET Books list API. We see here that we get one book back:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行测试。让我们打开我们的 Postman 客户端并尝试 GET Books 列表 API。我们在这里看到我们返回了一本书：
- en: '![](img/e91cb270-da64-4fa5-8303-3f396b266af1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e91cb270-da64-4fa5-8303-3f396b266af1.png)'
- en: Now let's try to get a book with an invalid ISBN and see what happens; click
    on the GET Invalid Book API (`http://localhost:8080/advanced/books/4711`). You
    see `4711` in the URI we pass, which is not a valid ISBN because it's not 10-digits
    long. If we send this, we expect that the server will send us back a bad request;
    this tells us the request we sent is not valid. If we request a valid book (GET
    Valid Book), we get status 200 OK, which means the first validations work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取一个无效 ISBN 的书籍并看看会发生什么；点击 GET Invalid Book API (`http://localhost:8080/advanced/books/4711`)。你会在我们传递的
    URI 中看到 `4711`，这不是一个有效的 ISBN，因为它不是 10 位长。如果我们发送这个请求，我们期望服务器会返回一个错误请求；这告诉我们我们发送的请求是不有效的。如果我们请求一个有效的书籍（GET
    Valid Book），我们得到状态码 200 OK，这意味着第一次验证是有效的。
- en: 'Let''s create a new valid book by requesting POST new valid book; we can see
    it has a valid ISBN—10-digits long—and a title. We send this and we get status
    code 201 Created back, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过请求POST新有效书籍来创建一个新的有效书籍；我们可以看到它有一个有效的ISBN——10位长——和一个标题。我们发送这个请求，并得到状态码201
    Created，如下截图所示：
- en: '![](img/dbf9a5cb-269e-4469-b465-c6e1249fa593.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbf9a5cb-269e-4469-b465-c6e1249fa593.png)'
- en: 'Now let''s create an invalid book by requesting POST invalid book. Have a look
    at the Body; you''ll see an empty `title` and an invalid `isbn`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过请求POST无效书籍来创建一个无效的书籍。看看Body；你会看到一个空的`title`和一个无效的`isbn`：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we send this request, we get 400 Bad Request; the server will not accept
    any bad books that do not comply with our validation annotations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发送这个请求，我们会得到400 Bad Request；服务器将不接受任何不符合我们验证注释的无效书籍。
- en: In the next section, we're going to have a look at using JSON Web Tokens for
    authentication.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看使用JSON Web Tokens进行身份验证。
- en: Using JSON Web Tokens for authentication
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON Web Tokens进行身份验证
- en: In this section, we're going to take a look at decoding **JSON Web Tokens**
    (**JWTs**) using the Auth0 library. We'll see how you can implement and use the
    `ContainerRequest` and `ContainerResponse` filters to handle JWT authentication
    for our REST resources. Finally, we'll be injecting and using decoded JWT in our
    REST resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看使用Auth0库解码**JSON Web Tokens**（**JWTs**）。我们将了解如何实现和使用`ContainerRequest`和`ContainerResponse`过滤器来处理我们的REST资源的JWT身份验证。最后，我们将在我们的REST资源中注入和使用解码后的JWT。
- en: 'Let''s get started. If you visit the JWT website ([https://jwt.io/](https://jwt.io/)),
    you can find relevant information about JWT. Under Debugger, you can see what
    a JWT looks like. We can see the token under Encoded—it consists of a HEADER,
    PAYLOAD, and VERIFY SIGNATURE. This JWT uses symmetric encryption to generate
    the signature. Therefore this value will later be transmitted by the HTTP authorization
    header:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。如果你访问JWT网站（[https://jwt.io/](https://jwt.io/)），你可以找到关于JWT的相关信息。在调试器下，你可以看到JWT的样子。我们可以看到在编码部分下的令牌——它由一个HEADER、PAYLOAD和一个VERIFY
    SIGNATURE组成。这个JWT使用对称加密来生成签名。因此，这个值将随后通过HTTP授权头传输：
- en: '![](img/a7d71f08-d188-433c-8a86-3837dc6e90b6.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7d71f08-d188-433c-8a86-3837dc6e90b6.png)'
- en: 'As usual, we prepare a small template project to get started. First, we activate
    a third-party library, which is required to handle JWT and decode it. We do that
    by adding the following dependency in the POM file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们准备一个小型模板项目以开始。首先，我们激活一个第三方库，该库是处理JWT和解码所必需的。我们通过在POM文件中添加以下依赖项来完成此操作：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to implement the `ContainerResponse` and `ContainerRequest` filters;
    we do that in the `JwtAuthzVerifier` class. We let the `JwtAuthzVerifier` class
    implement `ContainerRequestFilter` and `ContainerResponseFilter`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现`ContainerResponse`和`ContainerRequest`过滤器；我们在`JwtAuthzVerifier`类中这样做。我们让`JwtAuthzVerifier`类实现`ContainerRequestFilter`和`ContainerResponseFilter`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s implement those two methods. We need to implement `filter`. To do so,
    we extract the authorization header from `requestContext` and then decode the
    bearer token (`decodeBearerToken`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这两个方法。我们需要实现`filter`。要做到这一点，我们需要从`requestContext`中提取授权头，然后解码bearer令牌（`decodeBearerToken`）：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To obtain the request header, we use `ContainerRequestContext` and extract
    `AUTHORIZATION_HEADER`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取请求头，我们使用`ContainerRequestContext`并提取`AUTHORIZATION_HEADER`：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have that, we can decode the bearer token. This is where we will use
    the Auth0 library. We''ve provided a bit of verification code, which is basically
    programming against the used library. Finally, on the response, we will throw
    away the decoded JWT:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们就可以解码bearer令牌。这就是我们将使用Auth0库的地方。我们提供了一些验证代码，这基本上是针对所使用的库进行编程。最后，在响应中，我们将丢弃解码后的JWT：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s almost it, but a couple of things are missing. We need to annotate
    `@Provider` under `@ApplicationScoped`. We also need an annotation that will be
    active, so we call `@JwtAuthz`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎就是这样，但还有一些事情需要补充。我们需要在`@ApplicationScoped`下注释`@Provider`。我们还需要一个激活的注释，所以我们调用`@JwtAuthz`：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s have a look at the `@JwtAuthz` annotation. So far, this is a very basic
    annotation, but we need a special annotation. We need the `@NameBinding` annotation.
    Basically, this annotation binds the annotated `@Provider`, which we''ve done
    in the `JwtAuthzVerifier` class. In this case, we can put the `@Target` annotation
    on a `TYPE`, which is the REST resource, or a REST method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`@JwtAuthz`注解。到目前为止，这是一个非常基础的注解，但我们需要一个特殊的注解。我们需要`@NameBinding`注解。基本上，这个注解将注解的`@Provider`绑定，我们在`JwtAuthzVerifier`类中已经做到了这一点。在这种情况下，我们可以在`TYPE`上放置`@Target`注解，即REST资源或REST方法：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to activate our resource and the verifier. Let''s jump to `AuthenticationResource`
    and to the last final bit. We need to activate our JWT filter for this resource.
    We do that using the `@JwtAuthz` annotation directly on the resource:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要激活我们的资源和验证器。让我们跳转到`AuthenticationResource`和最后的最后。我们需要为这个资源激活我们的JWT过滤器。我们通过在资源上直接使用`@JwtAuthz`注解来实现这一点：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we inject the decoded JWT:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们注入解码后的JWT：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we add an `authenticate` method. We obtain the claims (`decodedJWT.getClaims()`)
    of the decoded JWT. We construct a `response` and echo the `name` and `subject`
    claims:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个`authenticate`方法。我们获取解码JWT的声明（`decodedJWT.getClaims()`）。我们构建一个`response`并回显`name`和`subject`声明：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s switch to our REST client. If you want to access this resource, go to
    the path of our `authenticate` resource. Here, we''ve prepared an `Authorization`
    header, and in the Value we use `Bearer` as a token type followed by the JSON
    Web Token in encoded format. When we send this, we should expect the 200 OK status.
    You should see the decoded `name` and `subject` claims:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到我们的REST客户端。如果你想访问这个资源，请访问我们的`authenticate`资源路径。在这里，我们准备了一个`Authorization`头，在值中使用`Bearer`作为令牌类型，后面跟着编码格式的JSON
    Web Token。当我们发送这个请求时，我们应该期望得到200 OK状态。你应该能看到解码后的`name`和`subject`声明：
- en: '![](img/a4cbc5b1-bc3b-4bae-b076-2be6b531f876.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4cbc5b1-bc3b-4bae-b076-2be6b531f876.png)'
- en: 'Let''s assume we changed the Value of the `Authorization` header to `Bearer
    notvalid`. If we send this, we should get 401 Unauthorized and the `Invalid JWT
    token.` message. We just secured our REST API using a simple JWT authentication:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`Authorization`头的值更改为`Bearer notvalid`。如果我们发送这个请求，我们应该得到401未授权和`Invalid
    JWT token.`消息。我们刚刚使用简单的JWT身份验证保护了我们的REST API：
- en: '![](img/63bd77cc-a4d8-47d4-9401-0d8b84d4e87b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63bd77cc-a4d8-47d4-9401-0d8b84d4e87b.png)'
- en: In the next section, we will talk about diagnosability and adding logging, metrics,
    and tracing to your REST APIs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论可诊断性，并将日志、指标和跟踪添加到你的REST API中。
- en: Diagnosability – logging, metrics, and tracing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可诊断性 – 日志、指标和跟踪
- en: In this section, we're going to take a look at adding request-and-response logging
    using the Jersey logging feature. We'll have a look at using MicroProfile 1.2
    APIs to add metrics and health endpoints. Finally, we'll see how we can include
    tracing with the `OpenTracing` API and Jaeger.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Jersey的日志功能添加请求和响应日志。我们将查看使用MicroProfile 1.2 API添加指标和健康端点。最后，我们将看看如何使用`OpenTracing`
    API和Jaeger来包含跟踪。
- en: Before we start, let's have a quick look at the diagnosability triangle. Diagnosability
    is really important when it comes to developing web services and distributed applications.
    When people talk about metrics, you might have heard of Prometheus; when it comes
    to logging, maybe you've heard about Fluentd; and for tracing, OpenTracing is
    the most state-of-the-art API out there. Make sure you have a look at these technologies
    and their stacks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们快速看一下可诊断性的三角形。当涉及到开发Web服务和分布式应用时，可诊断性非常重要。当人们谈论指标时，你可能听说过Prometheus；当涉及到日志时，你可能听说过Fluentd；而对于跟踪，OpenTracing是当前最先进的API。确保你查看这些技术和它们的堆栈。
- en: 'Let''s explore the diagnosability triangle for a small web service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个小型Web服务的可诊断性三角形：
- en: '![](img/727f06ad-8c5d-460d-ba17-b05464817def.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/727f06ad-8c5d-460d-ba17-b05464817def.png)'
- en: The diagnosability triangle
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可诊断性三角形
- en: 'Let''s open the IDE to get started. Open the POM file and add a few dependencies.
    The first dependency we want to enable is the `jersey.core` or `jersey-common`
    dependency. This is where the logging feature and the logging filter reside:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开集成开发环境（IDE）开始吧。打开POM文件并添加一些依赖项。我们想要启用的第一个依赖项是`jersey.core`或`jersey-common`依赖项。这是日志功能和日志过滤器所在的位置：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To enable request-and-response logging for every request, we activate `LoggingFeature`
    in the `JAXRSConfiguration` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个请求启用请求和响应日志，我们激活`JAXRSConfiguration`类中的`LoggingFeature`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you hover over `LoggingFeature` in our IDE, you can see that it comes from
    the `jersey-common` module; usually this is already provided so we don''t need
    to write it—no extra dependency to add. The final thing we want to do is modify
    `LoggingFeature`. Here, we add a few extra properties and we''re done:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我们IDE中悬停在`LoggingFeature`上，你可以看到它来自`jersey-common`模块；通常这已经提供了，所以我们不需要编写它——不需要添加额外的依赖。我们最后要做的就是修改`LoggingFeature`。在这里，我们添加一些额外的属性，然后我们就完成了：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will log every request and every response to your log file. Be careful;
    it will produce some seriously large logs. Next, we look at how we can use MicroProfile
    APIs to add metrics and health checks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录每个请求和每个响应到你的日志文件中。小心；它将生成一些非常庞大的日志。接下来，我们看看如何使用MicroProfile API添加指标和健康检查。
- en: 'Let''s switch to our POM and activate MicroProfile APIs. Since we''re using
    Payara micro edition, those APIs are also available to us. There are APIs for
    health checks, metrics, fault-tolerance if you need it, and for JWT Auth if you
    don''t want to implement this yourself. We need to add the following dependencies
    in our POM file (the entire code can be found at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8)):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到我们的POM并激活MicroProfile API。由于我们使用Payara micro edition，这些API对我们也是可用的。有健康检查、指标、容错（如果你需要的话）以及JWT认证（如果你不想自己实现的话）的API。我们需要在我们的POM文件中添加以下依赖项（整个代码可以在[https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8)找到）：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s go to `MetricsResource` and add a few metrics. This is actually really
    straightforward. Imagine you have a REST resource and you''re interested in how
    long it took for the invocation of the `POST` request. For this, you can add the
    `@Timed` annotation. We specify we want the `unit` in `"milliseconds"` and MicroProfile
    will make sure that every invocation is timed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去`MetricsResource`添加一些指标。这实际上非常简单。想象一下，你有一个REST资源，你感兴趣的是`POST`请求的调用耗时。为此，你可以添加`@Timed`注解。我们指定`unit`为`"milliseconds"`，MicroProfile将确保每次调用都会计时：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It''s even easier if you just want to count invocations. For this, we can use
    the `@Counted` annotation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想计数调用，那就更容易了。为此，我们可以使用`@Counted`注解：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, if you''re interested in the current absolute value, you can use `@Gauge`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你对当前绝对值感兴趣，可以使用`@Gauge`：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So `@Counted`, `@Gauge`, and `@Timed` are the three metric annotations you can
    use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`@Counted`、`@Gauge`和`@Timed`是你可以使用的三个指标注解。
- en: 'Maybe we also want to add some health checks, because a good microservice should
    provide health checks. We can specify an `@ApplicationScoped` bean. We annotate
    it using `@Health`, which implements `HealthCheck`; this comes from the MicroProfile
    API. Then we implement our basic health-check logic:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们还想添加一些健康检查，因为一个好的微服务应该提供健康检查。我们可以指定一个`@ApplicationScoped`的bean。我们使用`@Health`注解它，它实现了`HealthCheck`；这来自MicroProfile
    API。然后我们实现我们的基本健康检查逻辑：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last thing is tracing—this is a really complicated issue. I want to show
    you how we can add tracing to your web service. First, we add the tracing API,
    then we add Jaeger as the tracing implementation. We also use a special annotation
    to add OpenTracing to JAX-RS 2:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是跟踪——这是一个非常复杂的问题。我想向你展示如何将跟踪添加到你的Web服务中。首先，我们添加跟踪API，然后我们添加Jaeger作为跟踪实现。我们还使用一个特殊的注解将OpenTracing添加到JAX-RS
    2：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These are the required dependencies. After this we just need to activate the
    tracer. This is done in only a couple of lines of code. We construct a tracing
    `Configuration` from the environment. We register this `Configuration` and `getTracer`
    using `GlobalTracer`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是所需的依赖项。之后我们只需要激活tracer。这只需要几行代码。我们从环境构造一个跟踪`Configuration`。我们使用`GlobalTracer`注册这个`Configuration`和`getTracer`：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's see what our web service looks like.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的Web服务看起来像什么。
- en: Open Postman and issue a few requests, such as POST Timed Metric and POST Counted
    Metric. POST Timed Metric invokes the `@Timed` request. POST Counted Metric invokes
    the `@Counted` request; we invoke this one a couple of times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Postman并发出一些请求，例如POST Timed Metric和POST Counted Metric。POST Timed Metric调用`@Timed`请求。POST
    Counted Metric调用`@Counted`请求；我们调用这个请求几次。
- en: We invoke the GET Metrics endpoint, which is provided automatically by the MicroProfile
    implementation. We issue our metrics and we can see our custom metrics, such as
    `MetricsResource.gauge`, `MetricsResource.timed`, and `MetricsResource.timed`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 GET 指标端点，这是 MicroProfile 实现自动提供的。我们发布我们的指标，我们可以看到我们的自定义指标，例如 `MetricsResource.gauge`、`MetricsResource.timed`
    和 `MetricsResource.timed`。
- en: If we don't want JSON and want to use Prometheus, we can do that by invoking
    the Metrics for Prometheus GET request. We can see the Prometheus metrics data
    automatically provided.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用 JSON 而想使用 Prometheus，我们可以通过调用 Prometheus 指标 GET 请求来实现。我们可以看到自动提供的 Prometheus
    指标数据。
- en: 'You can also invoke the GET Healthcheck request to see whether everything is
    okay, we should get the following Body in Postman:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调用 GET 健康检查请求来查看一切是否正常，我们应该在 Postman 中获得以下 Body：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Everything is working and we're done.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常，我们已经完成了。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at validating REST API parameters and payloads using
    Javax validation. We learned how to add JWT paste authentication to a REST service
    and decoded JSON Web Tokens manually. Finally, we talked about adding, logging,
    and metrics, and tracing using Jersey, MicroProfile, and other open source components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Javax 验证来验证 REST API 参数和有效载荷。我们学习了如何将 JWT 验证添加到 REST 服务中，并手动解码
    JSON Web Tokens。最后，我们讨论了使用 Jersey、MicroProfile 和其他开源组件添加、记录、指标和跟踪。
