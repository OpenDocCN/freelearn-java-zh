- en: Introduction to Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Technology is nothing. What''s important is that you have faith in people,
    that they''re good and smart, and if you give them tools, they''ll do wonderful
    things with them."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Steve Jobs'
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we are used to facing programming problems and solving them using
    abstractions, programming models, or some design patterns. These programming models
    tend to make ours and consumer's lives easier. This chapter is about learning
    one such programming model that solves more than one problem. We'll understand
    and work with Akka, which is based on *Actor models*. We can think of Akka libraries
    (well mostly) as an open source set of libraries that help you write concurrent,
    fault tolerant, and distributed applications. We'll talk about what you might
    expect from this toolkit. As we go through the chapter, we'll try understanding
    the actor model and how these actors work together, as well as how the actor mechanism
    is different from any other concurrency mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through all the Akka libraries is outside of the scope of this chapter
    as well as the book, hence we''ll focus on understanding the actor system, which
    is the basis for any other library available within the Akka toolkit. This will
    enable us to use them when needed. In this chapter, we''ll be going through the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care about Akka*?*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's up with the Actor model?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actors in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supervising fault in our Actor*s*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So why do we care about another programming model? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we care about Akka?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a large amount of data all around us, our computer/processing systems are
    striving for performance. With multicore architecture and distributed computing,
    we are achieving high performance with acceptable availability of services. But
    this cannot be taken for granted; we have come to a point where we already have
    mechanisms to deal with problems that arise due to either incapability of systems
    or the programming models we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the advent of multicore architecture, our systems are capable of processing
    a large amount of data with high performance. But there is a fault in our programming
    models, which we use to mutate states, and at the same time use several threads
    to vary the states present in our programs. This has given us a reason to think.
  prefs: []
  type: TYPE_NORMAL
- en: Two or more threads trying to process a particular shared state might cause
    a *deadlock* (more on this in [Chapter 13](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84),
    *Concurrent Programming in Scala*, where we discuss concurrency and threads in
    more detail) and your program may not even complete. But still, we are discussing
    the problem; nowhere do we see the solution. One way in which we can think of
    dealing with threads and problems is using some sort of locking mechanism so that
    two separate threads cannot access the same instance/state at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: But think of it this way, by introducing locks, we are making our operating
    systems interrupt/suspend the thread and restore it later to perform the same
    task. It's expecting more from your computer's CPU.
  prefs: []
  type: TYPE_NORMAL
- en: It means that without locks we are facing problems with states of our instances,
    and now with locks in place, the program's performance takes a hit. Now picture
    a multithreaded distributed environment; life's worse there.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the way we handle failures in multithreaded environments is not pleasing.
    Hence, what we need for handling these is a different mechanism altogether. In
    the case of Akka*,* we let entities interact via messages. We create entities
    in terms of Actors that communicate by passing messages to each other. You may
    compare this kind of communication to network communication where we depend on
    HTTP request-responses to perform the intended operation. Similarly, by encapsulating
    the state within Actor instances, we tend to pass immutable instances to another
    actor to perform some logic. That receiving actor, after applying/performing some
    logic, returns back a response. That's how we can build our systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actor models have proven to be a highly effective solution. Akka provides this
    actor model and enforces a tree-like structure for actors. Some points to note
    down about actors:'
  prefs: []
  type: TYPE_NORMAL
- en: By communicating via messages, we omit the possibility of corrupting the state
    for a particular instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because one actor can process one message at a time, we avoid the deadlock situation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a hierarchy in place, it's easier to form a domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent-child relationship between two actors makes it possible for us to
    handle faulty behavior; in Akka terminology, we call it a *supervision strategy*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll go through the way *actors* communicate and how messages are ordered/stored
    and executed. First, let's try to understand the *Actor Model*.
  prefs: []
  type: TYPE_NORMAL
- en: What's up with the Actor Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From our discussion, it''s clear that we have some entities that act on receipt
    of some messages, or let''s say requests. We call them Actors*.* To solve some
    domain-specific problems, we might want to have more than one Actor*.* Think of
    a basic scenario of e-commerce checkout flow. There''s more than one area of concern.
    The following diagram represents the basic intended flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By taking a look at the diagram, it''s clear that we have few entities, and
    these entities are going to take care of specific concerns. We have named these
    entities based on their area of concern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CheckoutActor** might have the responsibility to fetch details from the cart
    and show the respective information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you might want to apply some coupon code or offer. Our system
    has to validate that coupon or offer code and based on that we might want to modify
    order details. For this particular process, we have **HandleOffersActor***.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShippingActor** has the responsibility of fetching user-specific information
    such as address, and based on that we can calculate the estimated time for shipping.
    It''s important to note that **ShippingActor** is not restricted to process the
    whole logic within, and can call another child actor named **UserInfoActor***,*
    which does nothing but to fetch a user''s information. Another point to note is
    that the operation of fetching user information is so general that this Actor might
    be useful outside this particular hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After shipping details are in place, we might want to redirect a user to a payment
    page, where we can perform payment-specific logic. For that, we have **PaymentsActor***.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, based on the payment's success or failure, we might want to handle
    orders. For example, upon successful payment, we want to proceed to ordering,
    and in case of failure we might want to send an email to the user stating that
    they process payment again! For this purpose, we have **HandleNewOrdersActor***.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the whole scenario, we can see that the whole flow makes a hierarchy of actors.
    Let's say **ShippingActor** fails to provide user information from the database,
    due to network/connection issues. Now it's up to us as to how we want to deal
    with that. Similarly, upon **PaymentsActor** failure, it's up to the business
    to make a decision about what to do next. It could be to proceed and take orders
    with payment status pending and payment method on delivery or to ask the user
    to retry. So, handling such scenarios is easier when you have your entities in
    a hierarchical manner, performing logic.
  prefs: []
  type: TYPE_NORMAL
- en: In this simple scenario, we understood that these actors form a hierarchy, or
    let's call it a group, and live within a system; in Akka terminology, we call
    it an **ActorSystem**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Actor system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka documentation simply explains an **ActorSystem** as a heavyweight structure
    that will allocate 1 to N threads, and we should create one per *logical* application.
    Once we create an actor system, we get the license to create actors under that
    system. We'll take a look at how we can create Actors in the next sections*.*
  prefs: []
  type: TYPE_NORMAL
- en: When we create actors as part of a system, these actors share the same configuration
    (such as *dispatchers, paths,* and *addresses)* as the Actor system.
  prefs: []
  type: TYPE_NORMAL
- en: Within an Actor system, there's a **root guardian** Actor; this serves as a
    parent actor to all actors residing within an actor system, internal actors, as
    well actors that we create. So, as expected, this is the last actor to be stopped
    when the system terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why Akka provides these guardian actors is to supervise the first-level
    actors we create, so for user created actors too, we have a specific **user guardian**.
    Similarly, for system provided actors, Akka has system guardian.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram to understand the hierarchy of guardian
    actors in the Akka system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous diagram, we can see there''s a path representation of each
    actor specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '**root guardian**: `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**user guardian**: `/user`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**system guardian**: `/system`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, whenever we create an actor within an Actor system, we tend to create a
    first-level. Hence, in the example shown in the diagram, we can see that the actor''s
    path is appended to `/user`*,* in our case it is the `SimpleActor`*,* hence the
    path formed is `/user/simpleActor`*.* With an Actor system defined as `system`*,*
    for creating these *first-level* (more on this in the next few sections) actors,
    we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll try out creating an actor ourselves in subsequent sections, but for
    now it''s worth nothing the way we called an `actorOf` method on `system` to create
    a *first-level* Actor. From here, we can create child Actors for our first-level
    Actor. And for that purpose, we use `context` instead of a `system` instance.
    It''ll look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, by using `context` instead of `system`*,* we are specifying that the
    actor that we want to create is going to be in the context of the current Actor,
    making it a child actor. It''s important to notice that this call to the following
    definition can only be made from within an Actor. So, with this method call, we
    get a child Actor for our `simpleActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the call was made from `SimpleActor` and `SimpleActor` is the
    first-level actor, our `anotherSimpleActor` path may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have seen the child actor path, it''s obvious that path for our
    `simple-actor` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Also, a few points worth noting are the usage of `Props` and the return type
    of the `actorOf` method.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Props` can be seen as a configuration object for `ActorRef`*.* We can create
    instances of the props configuration with some configuration. The following is
    an example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to know about the `Props` object is that it is immutable
    and hence thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Actor references and paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create an Actor*,* what we get in response is an `ActorRef`*.* This
    is a reference to our created Actor*.* Why we might need an `ActorRef` is to pass
    throughout the system to other actors as a reference. These references are used
    for message passing. Every actor that we create has a reference to itself through
    self.
  prefs: []
  type: TYPE_NORMAL
- en: From within an actor, it's possible to obtain an *actor reference* of the calling
    Actor via a method named `sender()`*.*
  prefs: []
  type: TYPE_NORMAL
- en: We can also give names to actor references. In our case, we named our `SimpleActor`
    reference `simple-actor:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We also know that these Actors are created in a hierarchical fashion and we
    can give unique names to *actor instances.* Hence, these names together make a
    path for each Actor. The path is unique for each Actor. Our `SimpleActor` path
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that due to the hierarchy, we have paths for different actors, because
    actors must have unique names. We can also see that regardless of your actor being
    created on a remote network, its path is going to have the same structure along
    with host and port.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting existing actorRefs via actorSelection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to every actor having its own unique ID, we can refer to a particular actor
    via its path using the `actorSelection` method. We can call the `actorSelection` method
    on `system` or `context` and get the `ActorRef`*.*
  prefs: []
  type: TYPE_NORMAL
- en: When we call `actorSelection` on `system`*,* we need to pass the absolute Actor
    path starting from root, whereas while calling the same on `context`*,* we can
    pass the path relative to the current Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the current Actor (first-level Actor) has a `SiblingActor`*,* at the
    same level, we may refer to the sibling Actor''s actor reference as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In these two approaches, the first one used to represent the parent Actor*.*
    The other approach directly referred to the Actor''s path. With this, we were
    able to get the actor references, but it''s discouraged because we might not want
    to write actor paths explicitly. We can leverage use of `actorSelection`*, *when
    suppose we want to make use of a wildcard (*), that is, to send messages to all
    the actors below a certain (*) level in hierarchy. The following diagram will
    clear what we mean by that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, in previous diagram, by providing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can obtain the reference, that point to all the `LogicAActor` parameters
    in previously mentioned hierarchy. Also it's worth knowing that a call to the
    `actorOf` method creates an actor on the context or system, depending upon which
    it's invoked. Whereas a call to `actorSelection` does not create any new actors,
    it points to `actorpath` which we pass, and doesn't ensure actor's existence there.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through simple entities in an Actor system, let's try
    and understand how the Actor life cycle works and what approaches we might want
    to choose to kill an actor instance.
  prefs: []
  type: TYPE_NORMAL
- en: How the Actor life cycle works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we make a call to method `actorOf`*,* what we get in return is an `ActorRef`that
    in turn also possesses a particular path where we've created the Actor*.* With
    this call, we know exactly there's an Actor instance created, been assigned a
    unique ID, and hook methods are called. There's this method named `preStart()` that
    gets called as the very first action, after a new Actor is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few points to note when a new Actor is created:'
  prefs: []
  type: TYPE_NORMAL
- en: A new Actor path is reserved for the Actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique ID is assigned to the Actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the instance is created, the `preStart()` method is called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When an Actor is restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: The `preRestart()` is called on the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New instance is created, replaces the old instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `postRestart()` method is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When an Actor is stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: The `postStop()` method is called on the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terminated message is sent to watchers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actor path is allowed to be used again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous diagram illustrates this whole cycle. An important point to note
    is that we get these hook methods in the form of `preStart`, `preRestart`, `postStop`, and `postRestart`.
    Using these methods, we can define some logic as required.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we're aware of the actor model and have also discussed that Actors
    communicate via messages, let's practice them.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world in Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For writing our first Akka actor, we need to add the `akka-actor` library dependency.
    For dependency management we'll be using SBT and, as we know, we'll be defining
    these library dependencies in our `build.sbt` file. To do this, we need to have
    SBT installed on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with a simple Akka project, we can simply follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Lightbend''s **TECH HUB** ([https://developer.lightbend.com](https://developer.lightbend.com))
    and click on START A PROJECT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Search for **Akka Quickstart** Scala under Akka projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on CREATE A PROJECT FOR ME!:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Extract the downloaded ZIP (compressed) file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can open the extracted folder in **IntelliJ IDEA** IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on File | New | Project from Existing Sources...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose the `build.sbt` from the project (`akka-quickstart-scala`) we''ve just
    extracted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And you get the project open in the IntelliJ window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is one way of starting with an Akka project. This project has already defined
    all the `akka-actors` specific dependencies. We don't have to define them on their
    own. But we would like to start by taking the first step ourselves hence let's
    start with a bootstrapped `sbt-scala` project and define library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take some steps to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite command line (Command prompt in Windows/Terminal in Linux
    and macOS), and go to the desired directory where you want to locate the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give the command `sbt new sbt/scala-seed.g8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Command prompt will ask for the name of the project. Give a name to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The command will generate the Scala seed project for us. We can follow *Steps
    1* to *3* to open the **Acala** seed project in IntelliJ IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `build.sbt` file. The file might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This file specifies that we have a root project in the current directory named
    `Hello`*.* Along with that, we have given some version-specific information, and
    the final line specifies that we currently have one `libraryDependency`*,* that
    is, `scala-test`*.* This value comes from the `Dependencies.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define `akka-actors` specific dependencies in this `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With this, we would use the `sbt update` command for updating libraries, and
    give a command in the current project directory using `cmd/terminal`*.*
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, we're ready to write our first Akka actor.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing an Actor is as simple as writing a class that extends the `akka.actor.Actor`
    class. And we know that Actors respond to messages, so to identify messages, we
    have a method named `receive` that we have to define for each Actor we write.
    Let''s write our `SimpleActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we wrote the `SimpleActor` with some empty behavior defined in the `receive`
    method. But here we''ve just wrote our Actor; we have to instantiate the Actor
    as part of an Actor system*.* After instantiating, we might also want to run our
    application to see the behavior, hence, let''s write the entry point to our application
    and instantiate an Actor system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement gives us an instance for an Actor system with the name `SimpleActorSystem`.
    Now, we want to create an instance of our `SimpleActor` as a top (first) level
    actor, hence we''ll use the `simpleActorSystem.actorOf` method available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now we have an Actor system available, and we have created an Actor instance.
    It is to be noted that by convention, we''ve created a companion object for our
    Actor class and defined its `props` value in it. We can also name our actor by
    giving an extra argument as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This line gives our actor a `namesimple-actor`*.* For now, the behavior defined
    for our Actor is empty*.* We would like to define a `receive` method for our actor.
    Let's think, what's the simplest thing our actor can do? It may be to call any
    public finance API to give us stock information or to call any API to perform
    currency conversion; that's up to us. For this example scenario, we'll call our
    `football.csv` file to fetch and show information to the user. Lets see how this
    can work using actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define some utility methods we might need to perform, parsing
    from string response to `Players` data. We have this case class for `Players`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined two utility methods named `bufferedSourceToList` and `asPlayers`*;* these
    methods do what they say. So, let''s now define our `SimpleActor` receive method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the receive methods, or let's say `SimpleActor` method's behavior,
    for a particular request such as `ShowFootballPlayersRequest`*.* The request itself
    contains the required information to fetch the information from the URI for the
    file. We defined this request as a final case class in the companion object of
    `SimpleActor`*.* This conventional approach specifies the requests our actor supports.
    On receipt of such a request for players information, our actor fetches information
    from the file at the location specified, and then it prints the player's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use it. We''re going to send a request of `ShowFootballPlayersRequest` type
    using our actor reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll consider a request containing a player's name and the source for a list
    of players. For example, the source can be any public API to get the player's
    information; in our case, it's a simple `List[Player]` with all the player's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we would like to do is create a simple request and response.
    For this, we can define these in our `SimpleActor` companion object. First is
    a simple request with the player''s name and a list of players we''ll pass along.
    The second one is a response container which has nothing but an option player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's define a receive method for such a request, of type `GetPlayerInformationRequest`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A few points to note about this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used a logger implementation to log information specific to this Actor.
    For this, we have used the `ActorLogging` trait. Simply mix in this trait by using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we receive a message to perform some expensive operation, we perform that
    operation and wrap that in future*,* and want to return back future''s reference
    to the calling Actor. For this purpose, we''ve used a method named `pipe` from
    the `akka.pattern` package. This method expects an execution context. The way
    we use pipe or the similar syntax method `pipeTo` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This `pipe` or `pipeTo` method sends back the response to the calling site.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the behavior of our Actor for messages of type `GetPlayerInformationRequest`*,*
    let''s call the Actor with this message. First, we''ll create the source, `List[Player]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Performing an ask call to the simple Actor is as simple as questioning the
    Actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this `?` is called *ask method*; we use this method when we expect a response
    from the called Actor. We need to give an `import` statement to import this method
    in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we might want to make sure this request gets completed in a given time
    duration. We''ll ensure that particular timeout duration by bringing an implicit
    timeout value in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on successful completion of our request we can obtain the values from
    the response. So, let''s do that and print the player''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, we mapped the response to the desired type by providing a `mapTo` method,
    and then we mapped values from the future and printed. We've used the *fire-and-forget*
    way of sending a message to one actor and we've waited for some response using
    the *ask* method. There's another way we can communicate messages and that's using
    the `forward` method.
  prefs: []
  type: TYPE_NORMAL
- en: The tell versus ask versus forward method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use one of these three approaches to transmit messages from one actor to
    another. As we''ve already established, `tell` transmits messages and does not
    wait for the response; this way, we ensure *at most once* delivery. We can also
    use the `ask` method in cases where we expect our called *actors* to respond back
    with some messages of the response type. There might be scenarios where you want
    to forward a message of a particular type with the same actor reference (`ActorRef`)
    to another Actor*.* For this purpose, we can use the `forward` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined `AnotherActor`*,* and we can make this a child actor of our
    `SimpleActor`*.* To do that, let''s instantiate this actor by giving a `context.actorOf`
    call from `SimpleActor`*.* Then, on receipt of a message of type `ShowFootballPlayersRequest`,
    we''ll forward the message to `anotherActor`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SimpleActor` class simply forwards the message to another actor; now,
    we can have a look at the whole code we have written and try to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is our main *SimpleActor* and its companion object. Let''s
    take a look at *AnotherActor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the entry point to our application where we boot the Actor system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have this `Util` object which consists of utility methods. With this,
    we have defined the `Player` case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After using our Actor, we should terminate its instance.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way of stopping actors is by calling the `stop` method from the `system`
    or `context` for a particular actor. To do this, we can define a particular message
    that can be passed to the actor, telling it to stop. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the times the preferred way of terminating an actor is by sending a
    `PoisonPill` message to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This simple message passing can terminate the actor gracefully. The termination
    takes place after all the messages in the Actor's queue are processed before the
    poison pill is processed. Stopping an *actor* stops all of its child actors. Remember,
    we talked about those hook methods that can be called if we want to perform some
    logic when the actor is starting up or at termination. Let's take a look at those.
  prefs: []
  type: TYPE_NORMAL
- en: The preStart and postStop hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define these methods in the `SimpleActor` class to log the starting
    and stopping of our `SimpleActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Similar methods are also available for restart operations in the form of `preRestart`
    and `postRestart`*.*
  prefs: []
  type: TYPE_NORMAL
- en: When we discuss communicating via messages, the question of in which order the
    messages get delivered to other actors arises, and also at what guarantee of message
    delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Actor communication via messages and its semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about the fashion of *fire-and-forget* regarding message passing;
    to understand this a bit more, let's take a look at a diagram explaining message
    delivery semantics.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram explains the semantics of message delivery; when we send
    messages over a network, there are chances of it getting delivered and also chances
    of it being lost. Also, in the case of an unsuccessful or successful attempt to
    deliver a message, we might try to send a message or we might not. It depends
    on us if want to try sending a message exactly once and then not the second time
    or so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these assumptions, we can make some formal terminologies specifying
    what we discussed, and we call them:'
  prefs: []
  type: TYPE_NORMAL
- en: At most once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram explains each of the three approaches in simple terms. It's important
    to know that in case of the Actor's communication, we have at most once delivery;
    in other terms, it means no guaranteed delivery. When actors communicate, a message
    might or might not be delivered to the called Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Actors are pretty lightweight and can accommodate a large number of messages
    fired to them; when we send a message to an actor, the messages get delivered
    to the actor's mailbox. An actor's mailbox is a queue that gets instantiated when
    we create an actor's instance. We know the way queue works is FIFO, *first in
    first out.* The ordering of the execution of the messages depends on the order
    in which they arrive to the mailbox.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, our discussions were based on the possibilities of successful execution
    of the logic implemented via Actors. But we know that Akka provides a very nice
    fault handling mechanism in the *form* of a *supervision strategy.* Let's discuss
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Supervising fault in our actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a possibility that our logic ends up in a network error or some unexpected
    exception. Imagine a scenario where our service needs to call a particular database
    instance to fetch some data. We might face *connection timed out* or some other
    similar errors. In that case, what should be our behavior? Maybe trying to establish
    the connection a couple of times will help, this can be achieved if our tasks
    are performed in such a hierarchical manner. We can achieve this task by performing
    hierarchy via the *actors* in place. And if some actor from down in the hierarchy
    fails and can communicate the failure to parent actor, the parent actor, based
    on the type of failure, can restart/kill the actor or perform some other operation
    as required. This is in a sense supervising the actors below in the hierarchy;
    let's say parent actors can supervise child actors. The way we define this strategy
    comes under the Akka defined supervision strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Supervision in a sense is about reacting to *failures* within an actor's hierarchy.
    Apart from the *root guardian,* every *actor* has a parent/supervisor to supervise.
    Every actor when instantiated becomes a part of a *default supervision strategy*.
    It's also important to observe that *failures* need a separate channel to be communicated
    to supervisors. So, Akka has a separate group of *system level actors,* which
    deal with the communication of such messages.
  prefs: []
  type: TYPE_NORMAL
- en: Since we deal with actors in case of failures also, our reactions should be
    in terms of actor-specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, think about the actions a supervisor can perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Resume child actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart child actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop child actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalate the failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a supervisor actor encounters a *failed child actor,* it can perform one
    of the actions described above. Depending on our preference, we might want to
    apply the strategy to all the children actors, regardless of if all of them failed
    or not. It's also possible to only *resume/restart/stop* the failing child actor.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the children on which the *supervision strategy* should be applied,
    we have two strategies, namely *OneForOneStrategy* and *AllForOneStrategy.* Let's
    take a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: OneForOne versus AllForOne strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the scenario where we have `SimpleActor` and `AnotherSimpleActor` actors.
    There's one child actor for `SimpleActor` named `SimplerrrActor`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '**SimpleActor**: `/user/topLevelActor/simpleActor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AnotherSimpleActor**:` /user/topLevelActor/anotherSimpleActor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SimplerrrActor**:` /user/topLevelActor/simpleActor/simplerrrActor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In such cases, the user guardian is going to take care of `topLevelActor` and
    `topLevelActor` is going to supervise `SimpleActor` and `AnotherSimpleActor`*.*
    If something goes wrong in `SimpleActor` and we want all the actors to resume/restart/stop,
    we can define an `AllForOneStrategy`*.* If we want to perform such actions only
    on the failed `SimpleActor` and its subsequent children, we can opt for `OneForOneStrategy`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'These two are defined as case classes in Scala, which takes a few parameters
    in the form of `maxNrOfRetries`, `withinTimeRange`, and `loggingEnabled`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is to specify the number of times we might want to retry
    the strategy on the child actor; we can make it an infinite number of times by
    specifying -1 as the number. After the specified number of times, the child actor
    will stop. A second parameter specifies the duration after which the next retry
    should happen. As shown, the value `Duration.Inf` specifies no time window at
    all. Finally, we have to specify the logging behavior; it expects a Boolean value,
    and by default, it's true and means enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two strategy classes extend the parent abstract class `SupervisorStrategy`.
    The way these two strategies work can be understood via the diagram here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the choice is ours to apply whichever strategy that suits our needs/situation.
    We define these strategies based on the type of failures; in the case that we've
    not covered a particular failure occurs, the failure gets escalated to the parent
    supervisor Actor. There's a defined set of actions performed by supervisors.
  prefs: []
  type: TYPE_NORMAL
- en: Default supervision strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the Akka system looks for a few exception types from failure messages
    received from child Actors. Let's take a look at those scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default supervision strategy will stop the failing child Actor in case
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActorInitializationException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActorKilledException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeathPactException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in case of exception, it'll restart the failing Actor.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, let's try implementing one strategy on our own.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the supervision strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While overriding the default `supervisorStrategy`*,* all we do is define the
    value with arguments and provide a `Decider`; this decider contains the logic
    to be implemented in case of exceptions. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a `OneForOneStrategy`, and on a case by case basis, the
    action to be performed in regards to the failing actor. A full example with this
    strategy in place can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the code, we have a `TopLevelActor`*,* which sends messages to its
    child Actor `SuperSimpleActor`*,* hence, `TopLevelActor` becomes a supervisor
    for its child actor. We have overridden the `supervisorStrategy`. According to
    the new Strategy, we can resume/restart based on the types of exceptions. The
    rest of the example is self-explanatory. We've logged the start and restart steps
    of our actors by overriding `preStart` *and* `preRestart` methods. Upon running
    the example, we'll get the logged output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since these failures are communicated via system level actors, the order of
    messages logged does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: With this example, we've pretty much covered how we can implement a supervisor
    strategy for our Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Akka library also provides `akka-testkit` for the testing of actors. It comes
    with a construct which make it easier to test actors. Let's go through the library
    and write unit test cases for our actor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the testing of Actors that we create, we might consider few entities that
    are needed to be present. These entities might be:'
  prefs: []
  type: TYPE_NORMAL
- en: A test actor-system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `testActor` (the message sender)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor under testing (whose behavior we want to test)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions to be made in case of an actors expected message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akka's `test-kit` library provides us with all of these needed entities ready-made.
    We can use these to test our actors. Let's write a simple actor test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expect case is to check if our `GetPlayerInformationRequest` works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is a very simple example of how we can write an Actor test
    case. We should make sure that the test case we write is in the test directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before we discuss our *test case,* let's run it. To run it, we can simply right-click
    using mouse and choose the Run option*.* In our case, the test case should pass.
    Now, let's take a look at the case we wrote.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to observe is the declaration we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We named our actor test case `SimpleActorSpec`, and extended `Testkit` by passing
    an `ActorSystem` for testing purposes. We've also mixed in `ImplicitSender`, which
    in turn returns the response from our actor under test, `SimpleActor`. Finally,
    `WordSpecLike` and the other `BeforeAndAfterAll` are just to provide DSL-like
    syntax methods for writing test cases. We can see these syntax methods in the
    form of must and in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the implementation, we''ve done what''s expected, created the actor under
    the test''s reference, and provided dummy data as in the players list. We also
    created a dummy response that''s expected from our `SimpleActor`. The following
    line sends the message to `SimpleActor`, which in turn responds back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The assertion part is handled using the `expectMsg` method. Here, we compared
    the dummy response to the expected response. For assertion purposes, `scala-test`
    library provides many alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we wrote a simple test case for our `SimpleActor`*.* We've covered
    all the basics we need to understand and write actors in Akka*.* There are a few
    advanced configuration-related topics such as *dispatchers, mailbox implementations*,
    and *routing* you might want to have a look at. For those, we can first thank
    the beautifully covered standard *documentation* of Akka available at: [https://doc.akka.io/docs/akka/2.5.8/index-actors.html](https://doc.akka.io/docs/akka/2.5.8/index-actors.html)*.*
  prefs: []
  type: TYPE_NORMAL
- en: And if you still have a question in mind about what's next or where to go from
    here, let me tell you there's way more that Akka provides. We've already talked
    about Akka as a set of open source libraries. These libraries are available for
    different problems. Libraries such as `akka-http`, streams, and clustering provide
    you with respective solutions. The good part is all these libraries are based
    on the abstraction of actor-model. And we have covered that in our chapter, so
    let's summarize what we've learnt in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to Akka for us. We tried to understand the
    basic underlying principle of actors. We've covered one of the most important
    libraries Akka provides, `akka-actors`. Starting from why we need a library of
    this sort, to understanding the way we implement Actors in Akka, we covered it
    all. Then from there, we covered the important supervision strategy in Akka. We
    talked about and practiced our own custom supervisor strategy. Finally, we had
    a look at `akka-testkit`, a testkit provided by Akka. With this, we covered what
    was needed to understand Akka actors and the basics of it. In the next chapter,
    we'll focus on how we can handle concurrency in Scala. We know it's importance
    in modern architecture, so the next chapter will be an exciting one.
  prefs: []
  type: TYPE_NORMAL
