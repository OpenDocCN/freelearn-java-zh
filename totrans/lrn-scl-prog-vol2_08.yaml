- en: Using Powerful Functional Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用强大的函数式构造
- en: '"We cannot solve our problems with the same thinking we used when we created
    them."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们不能用创造问题时使用的相同思维方式来解决我们的问题。”'
- en: – Albert Einstein
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – 阿尔伯特·爱因斯坦
- en: When we try to solve problems by writing programs, our intention is to write
    better code. More precisely*,* we mean that code should be readable and efficient
    at compile time and runtime. Readability and efficiency are two major factors,
    along with other important concepts such as concurrency, asynchronous tasks, and
    so on. We can think of the first two as the building blocks for the next set of
    characteristics we want. Scala, as a multi-paradigm language, provides multiple
    constructs that ensure the code we write is optimized, and also provides syntactic
    sugar wherever required. Many of the functional constructs or concepts used in
    *functional programming* enable you to write *better* code that not only fulfills
    the first two requirements but also allows your code to run in *concurrent* and
    *distributed* environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图通过编写程序来解决问题时，我们的目的是编写更好的代码。更确切地说，我们指的是代码应该是可读的，并且在编译时和运行时都是高效的。可读性和效率是两个主要因素，以及其他重要的概念，如并发、异步任务等。我们可以将前两个视为我们想要的下一种特性的构建块。Scala
    作为一种多范式语言，提供了多种结构来确保我们编写的代码是优化的，并在需要时提供了语法糖。许多在 *函数式编程* 中使用的函数式结构或概念使你能够编写 *更好*
    的代码，不仅满足前两个要求，而且允许你的代码在 *并发* 和 *分布式* 环境中运行。
- en: 'Our intention in this chapter is to learn the ways we can make our code better.
    For that, we''ll go through some of the syntactical constructs. Let''s take a
    look at what we are going to go through in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中的目的是学习我们可以使我们的代码变得更好的方法。为此，我们将探讨一些语法结构。让我们看看本章我们将要探讨的内容：
- en: For expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于表达式
- en: Pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Option type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项类型
- en: Lazy declaration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒声明
- en: Tail call optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Combinators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合子
- en: Type parameterization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数化
- en: All these concepts are simple but very useful for when you write Scala code.
    Some of them we've already gone through, such as *for expressions.* Our intention
    here is to compare for expressions with the available higher-order functions,
    such as `map`, `flatMap`, and `withFilter`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些概念都很简单但非常有用，尤其是在你编写 Scala 代码时。其中一些我们已经讨论过，比如 *for 表达式*。我们的目的是将 for 表达式与可用的更高阶函数，如
    `map`、`flatMap` 和 `withFilter` 进行比较。
- en: For expressions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于表达式
- en: 'We would not be wrong, if we say that the `for` expressions are powerful constructs
    in Scala. For expressions let you traverse through any collection and perform
    operations such as filtering and yielding out new collections. We have already
    gone through this concept in [Chapter 3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Shaping Up our Scala Program.* Let''s recall the example we saw:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们说 `for` 表达式是 Scala 中的强大构造，那我们并不会错。`for` 表达式允许你遍历任何集合并执行过滤和产生新集合的操作。我们已经在
    [第 3 章](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84)，“塑造我们的 Scala 程序”中讨论过这个概念。让我们回顾一下我们看到的例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous example, we have a collection of `Person` objects. We are performing
    a traversal on the collection and generating another collection consisting of
    names for all persons based on some condition. As we already know, for this we
    are using three constructs, or let''s say expressions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个 `Person` 对象的集合。我们在这个集合上执行遍历，并基于某些条件生成一个包含所有人员名称的新集合。正如我们所知，为此我们使用了三个结构，或者说表达式：
- en: Generator
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: '`person <- persons`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person <- persons`'
- en: Definition
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义
- en: '`age = person.age`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age = person.age`'
- en: '`name = person.name`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name = person.name`'
- en: Filter
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器
- en: '`age > 20`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age > 20`'
- en: 'With these three expressions we were able to perform slightly complex logic
    with very little syntactical effort. We could have done a similar operation in
    the form of higher-order functions. Using `map` and `withFilter` we can perform
    such operations, let''s take a look at an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个表达式，我们能够以非常少的语法努力执行稍微复杂的逻辑。我们也可以用高阶函数的形式执行类似的操作。使用 `map` 和 `withFilter`
    我们可以执行这样的操作，让我们来看一个例子：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have used higher-order functions to implement the same logic we implemented
    using for expressions. We're already familiar with the `map` method from a collection.
    It's going to provide you a list of persons whose age is greater than 20\. So
    now, we have the same logic implemented in two different ways. First, in the form
    of *for expressions*, and second, in the form of *higher-order functions.* So
    it's important for us to know how this happens. What the Scala compiler does is
    it internally breaks down for expressions into higher-order functions. Programmers
    tend to prefer using for expressions for readability but it's a matter of choice.
    Now that we know what happens internally, we can start thinking about the translation
    Scala does for slightly complex for expressions, can't we? Yes, so let's try it
    out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了高阶函数来实现我们使用 for 表达式实现的相同逻辑。我们已经熟悉了集合中的 `map` 方法。它将提供一个年龄大于 20 岁的人的列表。所以现在，我们以两种不同的方式实现了相同的逻辑。首先，以
    *for 表达式* 的形式，其次，以 *高阶函数* 的形式。因此，了解这是如何发生的对我们来说很重要。Scala 编译器所做的是，它将 for 表达式内部分解为高阶函数。程序员倾向于使用
    for 表达式以提高可读性，但这只是一个选择问题。既然我们已经了解了内部发生的事情，我们可以开始思考 Scala 对稍微复杂的 for 表达式进行的转换，不是吗？是的，所以让我们试试看。
- en: 'Now, suppose we have a list of car brands, and each brand has many cars in
    it (in other words, each brand has a list of cars). The code will look something
    like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个汽车品牌列表，每个品牌下有许多汽车（换句话说，每个品牌都有一个汽车列表）。代码看起来可能如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may want to yield a list of pairs for all the Tesla cars whose name starts
    with the `Model` keyword . You''ll perform something like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望为所有以 `Model` 关键字开头的特斯拉汽车生成一个对列表。你将执行如下操作：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We used for expressions for this task. This has two generator expressions,
    and we are also performing a filtering operation on it. While translating these
    kinds of for expressions into higher-order functions, Scala uses the `flatMap`
    method. Let''s see how the same can be implemented using `flatMap`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 for 表达式来完成这个任务。这个任务有两个生成器表达式，我们也在它上面执行了过滤操作。在将这些类型的 for 表达式转换为高阶函数时，Scala
    使用了 `flatMap` 方法。让我们看看如何使用 `flatMap` 实现相同的功能：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We got a similar result with this definition. So let''s try to break this `teslaCarsStartsWithModel2`
    down to understand how we implemented this. First, what we had was the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了类似的结果。所以让我们尝试将这个 `teslaCarsStartsWithModel2` 分解开来，理解我们是如何实现这个功能的。首先，我们有的如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In scenarios where we have two generators, we use `flatMap` functions instead
    of `map`. Let''s go through the translation from for expressions to higher-order
    functions step by step:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在有两个生成器的情况下，我们使用 `flatMap` 函数而不是 `map`。让我们一步一步地通过 for 表达式到高阶函数的转换过程：
- en: 'We have the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有以下内容：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We first used `flatMap`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们首先使用了 `flatMap`:'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we''ve got the brand, we have access to the cars list. We can proceed
    with a filtering predicate as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了品牌，我们可以访问汽车列表。我们可以继续使用以下过滤谓词：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the final version of our implementation. What we have done here is we
    filtered out elements from our `cars` collection and finally transformed our collection
    to the intended form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的实现最终版本。我们在这里所做的是，我们从 `cars` 集合中过滤出元素，并最终将我们的集合转换为预期的形式。
- en: So this is the way the Scala compiler does translations of our for expressions
    into the provided functions. As programmers, we only have to deal with the implementation
    part. You may want to put your logic in the for expressions instead of writing
    nested higher-order functions, and Scala does the rest for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是 Scala 编译器将我们的 for 表达式转换为提供函数的方式。作为程序员，我们只需要处理实现部分。你可能希望将你的逻辑放在 for 表达式中，而不是编写嵌套的高阶函数，Scala
    会为你完成剩下的工作。
- en: Here, we learned how you can add your logic in different forms in detail. Similarly,
    you'll also find cases that we will have to go through and then execute any logic
    applicable. In this process of matching different cases, we can empower ourselves
    by matching through different patterns. For example, we may want to match our
    list type against the possible values. The options are going to be either an empty
    list or a list with certain values. Scala doesn't limit you to matching in these
    two ways, but you'll have more options to match against. All this is possible
    via a concept called *pattern matching.* The good thing is, we've already gone
    through the pattern matching concept so what we are going to do now is try to
    understand it further.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们详细学习了你可以以不同形式添加你的逻辑。同样，你也会找到我们必须通过并执行任何适用逻辑的案例。在这个过程中匹配不同的案例，我们可以通过匹配不同的模式来增强自己。例如，我们可能想要匹配我们的列表类型与可能的值。选项将是空列表或具有某些值的列表。Scala不会限制你只以这两种方式匹配，但你将拥有更多匹配的选项。所有这些都是通过一个称为*模式匹配*的概念实现的。好事是，我们已经了解了模式匹配的概念，所以我们现在要做的是进一步理解它。
- en: Pattern matching
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'We use **pattern matching** to execute code on a case-by-case basis. Take a
    look at the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**模式匹配**根据案例执行代码。看看以下内容：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By taking a look at the structure of our pattern match expression, we see a
    few things. First, we execute a match on some value followed by the `match` keyword
    and then we put cases. For each case we specify some patterns. Now, the pattern
    can be a constant value, a variable, or even a constructor. We'll soon have a
    look at all of these patterns. Pattern matching also allows us to put guards on
    our match in the form of a condition. In that case, the pattern will only match
    if the condition is applicable. If you take a look at the previous toy example
    about `somelist`, you'll see there's an *`*_*` underscore. It's called a **wildcard
    pattern**. It'll match all values or patterns against the case. Logically, you
    can't put another case after a wildcard. For example, the following does not make
    any sense and throws a warning:*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的模式匹配表达式结构，我们可以看到一些事情。首先，我们执行一个匹配某个值，然后跟随着`match`关键字，然后放置案例。对于每个案例，我们指定一些模式。现在，模式可以是一个常量值、一个变量，甚至是一个构造函数。我们很快就会查看所有这些模式。模式匹配还允许我们以条件的形式在我们的匹配中放置守卫。在这种情况下，只有当条件适用时，模式才会匹配。如果你看一下之前的关于`somelist`的玩具示例，你会看到一个*`*_*`下划线。它被称为**通配符模式**。它将匹配所有值或模式与案例。从逻辑上讲，你不能在通配符之后放置另一个案例。例如，以下没有意义，并会抛出一个警告：
- en: '*[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE14]'
- en: This is a pretty basic example of pattern matching in Scala. There are more
    ways we can pattern match. Why not take a look at all of them?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Scala中模式匹配的相当基础的例子。我们还有更多可以模式匹配的方式。为什么不看看所有这些方式呢？
- en: Different ways we can pattern match
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式模式匹配
- en: Pattern matching in Scala proves to be a very important concept. We can match
    on variables, constants, and even constructors. We'll take a look at all of them.
    Let's start with matching against a variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的模式匹配证明是一个非常重要的概念。我们可以对变量、常量甚至构造函数进行匹配。我们将逐一查看它们。让我们从对变量的匹配开始。
- en: Matching a variable
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配变量
- en: 'At times, when we have to use the value after the pattern match is successful,
    we want to match against cases with variables. What this does is it assigns the
    value to the variable and then we can use that in our code for that particular
    case. It''s better if we look at the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们需要在模式匹配成功后使用值时，我们想要对带有变量的案例进行匹配。这样做的作用是将值分配给变量，然后我们可以在我们的代码中为特定案例使用它。如果我们看一下以下示例，会更好：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have defined a method which tries to convert a number represented by
    a string to an integer. Then, we call the method with a parameter and try to match
    the same using a variable named `someValue`. This `someValue` variable is going
    to be of the same type as the value's matched type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个方法，该方法尝试将字符串表示的数字转换为整数。然后，我们用参数调用该方法，并尝试使用名为`someValue`的变量进行匹配。这个`someValue`变量将与匹配的值的类型相同。
- en: Matching a constant
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配常量
- en: 'We can also match cases against a constant, such as basic switch statements.
    Take a look at the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对常量进行案例匹配，例如基本的switch语句。看看以下内容：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we directly matched our expression against constant values. This can be
    any value, depending upon the type your method accepts. You are allowed to match
    against a Boolean, string, or any other constant value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接将我们的表达式与常量值进行匹配。这可以是任何值，具体取决于你的方法接受的数据类型。你可以匹配布尔值、字符串或任何其他常量值。
- en: Matching a constructor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配构造函数
- en: 'Okay, what does a constructor pattern look like? It''s about matching a constructor
    against a value, or we could say, extracting values of our choice. Let''s take
    an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，构造函数模式看起来是什么样子？它涉及到将构造函数与一个值进行匹配，或者说，提取我们选择的价值。让我们来看一个例子：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only difference we can see here is, instead of providing a variable, we
    gave a constructor pattern. `Some(value)` lets you extract the `value` out of
    itself. Here in the given example, the `safeToInt` method returns an `Option`
    type. We''re going to learn about types in subsequent sections. For now, the interesting
    information for us is that we have two subtypes of our `Option` type named `Some`
    and `None`, and as the names suggest, `Some` means some value and `None` means
    no value. The `Some` subtype expects a particular value as its constructor parameter.
    Hence it''s possible for us to match on that. The following line does the exact
    thing we just mentioned:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能看到的唯一区别是，我们不是提供一个变量，而是给出了一个构造函数模式。`Some(value)`让你从自身中提取`value`。在这个给定的例子中，`safeToInt`方法返回一个`Option`类型。我们将在后续章节中学习类型。现在，对我们来说有趣的信息是我们有`Option`类型的两个子类型，分别命名为`Some`和`None`。正如名称所暗示的，`Some`表示有值，而`None`表示没有值。`Some`子类型期望一个特定的值作为其构造函数参数。因此，我们可以对它进行匹配。下面的行正是我们刚才提到的：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this declaration we can extract a value, in our case the extracted parameter
    name is also `value`, hence we used it. This is an example of using a constructor
    for our pattern matching. We''ve learned about `case` classes in Scala and also
    mentioned that `case` classes provide us an exact structure, using which we can
    directly perform pattern matching. So let''s take an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个声明，我们可以提取一个值，在我们的例子中，提取的参数名称也是`value`，因此我们使用了它。这是一个使用构造函数进行模式匹配的例子。我们已经了解了Scala中的`case`类，并且提到`case`类为我们提供了一个精确的结构，通过这个结构我们可以直接进行模式匹配。所以让我们来看一个例子：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here in this example, we defined three categories of employees: `Developer`,
    `Consultant`, and `ContractEmp`. We''ve a problem to solve: we''ll have to process
    the joining bonus amount for specific employees in a specific category with some
    conditions. The whole logic is very simple to implement in terms of `case` classes
    and pattern matching and that''s what we have done here. Take a look at the following
    line from the previous solution:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了三种员工类别：`Developer`、`Consultant`和`ContractEmp`。我们有一个问题要解决：我们必须根据某些条件处理特定类别中特定员工的入职奖金。整个逻辑在`case`类和模式匹配方面非常容易实现，这正是我们在这里所做的事情。看看以下来自前一个解决方案的行：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we matched against a `case` class constructor. We gave some names to the
    required parameters, others we replaced with the wildcard `_` underscore. Here,
    we had to put a condition on the `id` parameter*,* hence we mentioned it in the
    constructor of the respective `case` class. You can see how `case` classes and
    pattern matching can make a slightly complex domain problem very easy to solve.
    Well, it doesn''t end there, there''s more. We can also put guards against our
    `case` expressions. Let''s see the same example with guards:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们与`case`类构造函数进行匹配。我们对所需的参数给出了一些名称，其他则用通配符`_`（下划线）替换。在这里，我们必须对`id`参数设置一个条件，因此在相应的`case`类构造函数中提到了它。你可以看到`case`类和模式匹配如何使一个稍微复杂的领域问题变得非常容易解决。嗯，这还没有结束，还有更多。我们还可以在我们的`case`表达式上设置守卫。让我们看看带有守卫的相同例子：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we look at the following expression, we can see guards on our `case` patterns.
    So the value will only match if the guard allows it to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看以下表达式，我们可以看到在我们的`case`模式上有守卫。所以值只有在守卫允许的情况下才会匹配：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, before going to the right-hand side of the execution block, this expression
    checks if the `id` starts with `"DL"`, and based on that, it matches. This is
    how we can use a constructor directly to extract parameters and use them. You
    can also use patterns in some more ways. For example, we can perform a match against
    a sequence or a tuple. It''s also possible for when we have to match some nested
    expression, or match a `case` class that has another `case` class inside. For
    our code to make more sense, and for readability purposes, we can bind the nesting
    `case` class using the `@` symbol and perform pattern matching. Let''s take an
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行块的右侧之前，这个表达式检查`id`是否以`"DL"`开头，并根据这个结果进行匹配。这就是我们可以直接使用构造器提取参数并使用它们的方式。你还可以以更多的方式使用模式。例如，我们可以对序列或元组执行匹配。当我们必须匹配一些嵌套表达式，或者匹配一个包含另一个`case`类的`case`类时，这也是可能的。为了使我们的代码更有意义，并且为了可读性，我们可以使用`@`符号绑定嵌套`case`类并执行模式匹配。让我们举一个例子：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example is self-explanatory. We have a nested `case` class inside
    our `Car`, named `CarBrand`, and we performed a pattern match against that. We
    got access to that particular object using the `@` symbol. So, these are a few
    ways we can use pattern matching to perform all those tasks very easily. By now,
    you must have an idea about pattern matching; how powerful and important it is.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是自我解释的。我们在`Car`内部有一个嵌套的`case`类，名为`CarBrand`，并对其进行了模式匹配。我们使用`@`符号访问了该特定对象。所以，这些都是我们可以使用模式匹配轻松执行所有这些任务的几种方法。到现在，你一定对模式匹配有了概念；它有多么强大和重要。
- en: 'While performing all these pattern matches, we felt that there are counter
    cases where we don''t want to perform matches, and use a wildcard so that we can
    provide any value in return. It''s possible that there''s no intended value for
    such cases, and we just want our code to make sense and at the same time return
    a meaningful response. In those cases, we can use our `Option` type. As the name
    suggests, when you define a type as `Option`, you may get either some value or
    no value. To make it more clear, let''s recall our `safeToInt` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行所有这些模式匹配的过程中，我们感觉到有一些反例，我们不想执行匹配，并使用通配符，这样我们就可以提供任何返回值。可能在这种情况下没有预期的值，我们只想让我们的代码有意义，同时返回一个有意义的响应。在这些情况下，我们可以使用我们的`Option`类型。正如其名所示，当你将类型定义为`Option`时，你可能得到一些值或没有值。为了使其更清楚，让我们回顾一下我们的`safeToInt`函数：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, in the definition of our `safeToInt` function, we defined our response
    type to be `Option` simply because we knew that it may or may not respond with
    a meaningful value. Now the reason for using an `Option` instead of using any
    type directly is clear, let's discuss the `Option` type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在我们的`safeToInt`函数的定义中，我们定义了我们的响应类型为`Option`，仅仅因为我们知道它可能或可能不会响应一个有意义的值。现在使用`Option`而不是直接使用任何类型的理由是清晰的，让我们讨论`Option`类型。
- en: Option type
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项类型
- en: 'Option is one of the type constructors that Scala provides. The question arises,
    what''s a type constructor? The answer is simple; it lets you construct a type.
    We''ll take two statements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是Scala提供的一种类型构造器。问题随之而来，什么是类型构造器？答案是简单的；它允许你构造一个类型。我们将考虑两个陈述：
- en: '`Option` is a type constructor'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Option`是一种类型构造器'
- en: '`Option[Int]` is a type'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Option[Int]`是一种类型'
- en: Let's discuss these in detail. When I say `Foo` is a type constructor, it means
    that `Foo` expects you to provide a particular type in the form of a parameter.
    It looks like `Foo[T]`, where `T` is an actual type. We call them **type parameters**
    and we'll talk about them in the following few sections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这些。当我说`Foo`是一个类型构造器时，我的意思是`Foo`期望你以参数的形式提供一个特定的类型。它看起来像`Foo[T]`，其中`T`是一个实际类型。我们称它们为**类型参数**，我们将在接下来的几节中讨论它们。
- en: 'In the second statement, we saw that we gave an `Int` type to our `Option`
    type constructor in brackets and it formed a type. If you try this in the Scala
    REPL, it''ll tell you exactly the same thing we discussed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个陈述中，我们看到了我们给我们的`Option`类型构造器括号中一个`Int`类型，并形成了一个类型。如果你在Scala REPL中尝试这样做，它会告诉你我们讨论的完全相同的事情：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In simple words, the `Option[T]` type represents an optional value of any given
    type `T`. Now `T` can be any type you pass, in the previous example it was `Int`.
    The `Option[T]` type has two subtypes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`Option[T]`类型表示任何给定类型`T`的可选值。现在`T`可以是您传递的任何类型，在上一个例子中它是`Int`。`Option[T]`类型有两个子类型：
- en: '`Some(T)`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Some(T)`'
- en: '`None`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`'
- en: 'When there''s a value available, we''ll get the `Some` value, otherwise `None`.
    The `Option` type also provides you a `map` method. The way you would want to
    use an option value is by calling the `map` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当有值可用时，我们会得到`Some`值，否则得到`None`。`Option`类型还为你提供了一个`map`方法。你想要使用选项值的方式是调用`map`方法：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What happens here is the `map` method gives you the respective value if it''s
    available. Otherwise, if the optional value is `None`, it''s not going to do anything.
    Usually, you would want to use this type as an exception handling mechanism. How
    can we do this? We''ve already seen an example of it. Recall our `safeToInt` method,
    without `Option` it''ll look like this (maybe):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里发生的情况是，`map`方法会给你相应的值，如果它可用的话。否则，如果可选值是`None`，它将不会做任何事情。通常，你可能会想将这种类型用作异常处理机制。我们如何做到这一点？我们已经看到了一个例子。回想一下我们的`safeToInt`方法，如果没有`Option`，它可能看起来像这样（也许）：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But if you take a look at the signature, the declaration tells you that the
    function is going to return you an `Int` but the function, in reality, may also
    throw an `Exception`. That's neither intended nor correct. The function should
    follow its own declaration. Hence, we can use our `Option` type, which as a savior,
    does what our declaration says. `Option` is one of the constructs *functional
    programming* provides for you.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你看一下签名，声明告诉你函数将返回一个`Int`，但实际上函数可能会抛出一个`Exception`。这既不是预期的，也不正确。函数应该遵循其自己的声明。因此，我们可以使用我们的`Option`类型，作为救星，做我们声明的事情。`Option`是函数式编程为你提供的构造之一。
- en: There're more of these and they provide you with some ready-to-use constructs.
    Some of them are the types, `Either`, `Try`, and a few more. You may refer to
    the Scala API documentation ([http://www.scala-lang.org/api/2.12.3/scala/util/Either.html](http://www.scala-lang.org/api/2.12.3/scala/util/Either.html))
    for more information about these types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型还有很多，它们为你提供了一些现成的构造。其中一些是类型，如`Either`、`Try`以及一些其他的。你可以参考Scala API文档（[http://www.scala-lang.org/api/2.12.3/scala/util/Either.html](http://www.scala-lang.org/api/2.12.3/scala/util/Either.html)）来获取更多关于这些类型的信息。
- en: Next, we'll talk about one more functional construct. It's more than just a
    construct, it's a scheme of evaluation. Yes, we are talking about *lazy evaluation.*
    Scala allows you to use this scheme in more than one way. Let's talk about the
    `lazy` keyword.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一个功能构造。它不仅仅是一个构造，它是一种评估方案。是的，我们正在谈论*懒加载*。Scala允许你以多种方式使用这种方案。让我们谈谈`lazy`关键字。
- en: Lazy declaration
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒声明
- en: Before learning more about the `lazy` keyword or lazy evaluation, let's talk
    about why we need it and exactly what it is. Just how beneficial lazy evaluation
    is can be explained with a few lines, or a few pages, but for our understanding
    let's have a one liner.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习更多关于`lazy`关键字或懒加载之前，让我们先谈谈为什么我们需要它以及它究竟是什么。懒加载的好处可以用几行或几页文字来解释，但为了我们的理解，让我们用一个简单的句子来说明。
- en: '**Lazy evaluation** lets you write your code in a way where the order of evaluation
    doesn''t matter. It also saves you some time, by only evaluating expressions that
    you need. It''s like so many complex evaluations, that exists in your code, but
    never evaluation dues to a certain. The last line is only possible due to the
    concept of lazy evaluation. In Scala, you can declare a value as `lazy`. Let''s
    take an example. Try the following in the Scala REPL:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载**让你能够以评估顺序无关的方式编写代码。它还通过只评估所需的表达式来为你节省一些时间。它就像代码中存在许多复杂的评估，但由于某种原因从未被评估。最后一行之所以可能，是因为懒加载的概念。在Scala中，你可以声明一个值为`lazy`。让我们举一个例子。在Scala
    REPL中尝试以下操作：'
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, when we assigned a value of `1` to our `val v`, the REPL gave us the `Int`
    type and the value as `<lazy>`, and for the `val z` we got `1`. Why this happened
    is because of the `lazy` declaration. In Scala, when you declare a value as lazy,
    the compiler evaluates the value only when we use it for the first time. With
    this, you free yourself from the worry of putting the `val` declaration in any
    order. Each `lazy` value is evaluated when it's needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们将值`1`赋给我们的`val v`时，REPL给了我们`Int`类型和值`<lazy>`，而对于`val z`，我们得到了`1`。为什么会发生这种情况是因为`lazy`声明。在Scala中，当你声明一个值为懒时，编译器只有在第一次使用它时才会评估这个值。有了这个，你就无需担心将`val`声明放在任何顺序。每个`lazy`值在其需要时才会被评估。
- en: While we're talking about making our code optimized, let's look at another concept,
    *tail call optimization.* We first introduced *tail call optimization* in [Chapter
    3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84), *Shaping Up our Scala
    Program* while discussing *recursion.* Let's talk about it in brief.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在讨论优化我们的代码时，让我们看看另一个概念，*尾递归优化*。我们首次介绍*尾递归优化*是在[第3章](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84)，“塑造我们的Scala程序”中，讨论*递归*时。让我们简要地谈谈它。
- en: Tail call optimization
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归优化
- en: 'We are familiar with the limitations recursion brings with it. We are aware
    that each function call, if not tail recursive, builds a new stack frame. For
    scenarios where we have to deal with a large number of function calls, this could
    possibly result in a stack overflow, which is undesirable. So, what''s suggested
    in this kind of scenario is to make the recursive function call the last statement
    in your function definition, the Scala compiler then does the rest for you. Take
    a look at the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉递归带来的局限性。我们知道，如果函数调用不是尾递归，每次函数调用都会创建一个新的栈帧。对于必须处理大量函数调用的场景，这可能会导致栈溢出，这是我们不希望的。因此，在这种情况下建议的是，将递归函数调用作为你函数定义中的最后一个语句，然后Scala编译器会为你完成剩下的工作。看看下面的例子：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, if you take a closer look, you''ll see that wherever
    we made a recursive call, it''s the last statement in that particular scope. It
    means that our call to `someRecursiveMethod` is a last call and there was no other
    call after that. If it isn''t, the Scala compiler will alert you with a message
    saying the recursive call is not in the tail position:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果你仔细观察，你会发现我们每次进行递归调用时，它都是该特定作用域中的最后一个语句。这意味着我们对`someRecursiveMethod`的调用是最后一个调用，之后没有其他调用。如果不是这样，Scala编译器会通过一条消息提醒你，说递归调用不在尾递归位置：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, one thing to notice is that we''re helping out the Scala compiler by
    providing the annotation as `tailrec`. When we provide this annotation, the compiler
    considers your function as a tail recursive function. Evaluation of such a function
    does not create separate stack frames on each call, but uses the ones already
    created. This is how we avoid stack overflow and use recursion. What we''ve tried
    to do in our example is match to a list of names. Yes, you''re already familiar
    with the notion of pattern matching. If not `Nil`, we check for the name `Raven`
    in the list*,* and then we stop further calls. If you''re missing `break` or `continue`
    statements in Scala, this is the way that you can implement them: by using recursion
    and checking for the condition.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，需要注意的一点是，我们通过提供`tailrec`注解来帮助Scala编译器。当我们提供这个注解时，编译器会将你的函数视为尾递归函数。这种函数的评估不会在每个调用时创建新的栈帧，而是使用已经创建的栈帧。这就是我们避免栈溢出并使用递归的方式。在我们的例子中，我们尝试匹配一个名字列表。是的，你已经熟悉模式匹配的概念。如果不是`Nil`，我们会在列表中检查名字`Raven`，然后停止进一步的调用。如果你在Scala中缺少`break`或`continue`语句，这是你可以实现它们的方式：通过递归和检查条件。
- en: So this was all about tail call optimization. We've also seen that the Scala
    compiler helps us when we provide the annotation. Well, recursion helps you avoid
    mutability and at the same time achieve complex logic, adding to the already powerful
    functional programming. Since we are learning about functional programming constructs,
    it's really important for us to know that they are rooted in *eternal mathematics.*
    Mathematics created the notion of functional programming, and almost all functional
    programming concepts come from some mathematical proof or concept. One of them
    is a combinator. Learning about combinators or understanding how they are related
    to mathematics is beyond the scope of this book but we will look at a short introduction
    and see a simple example. It'll be fun. Let's go through *combinators.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是关于尾递归优化的一切。我们还看到，当提供注解时，Scala编译器会帮助我们。嗯，递归可以帮助你避免可变性，同时实现复杂的逻辑，这增加了已经强大的函数式编程。由于我们正在学习函数式编程结构，了解它们根植于*永恒的数学*是非常重要的。数学创造了函数式编程的概念，几乎所有函数式编程的概念都来自某些数学证明或概念。其中之一是组合子。了解组合子或理解它们如何与数学相关超出了本书的范围，但我们将简要介绍并查看一个简单的例子。这将会很有趣。让我们通过*组合子*来了解。
- en: Combinators
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合子
- en: 'Wikipedia says the following about **combinators**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科关于**组合子**的描述如下：
- en: '"A Combinator is a higher-order function that uses only function application
    and earlier defined Combinators to define a result from its arguments."'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “组合子是一个高阶函数，它只使用函数应用和先前定义的组合子来从其参数定义一个结果。”
- en: 'As well as this definition, we could also say that a combinator is a closed
    *lambda* expression. We have already seen lambda applications in several places
    and defined them. A lambda is nothing more than an anonymous definition of any
    function. For example, when you pass an expression to our beloved `foreach` method,
    you pass it in the form of a lambda expression. Take a look at the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个定义，我们还可以说，组合子是一个封闭的 *lambda* 表达式。我们已经在前几个地方看到了 lambda 的应用，并且对它们进行了定义。lambda
    仅仅是对任何函数的匿名定义。例如，当你将一个表达式传递给我们的“foreach”方法时，你以 lambda 表达式的形式传递它。看看下面的例子：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the `foreach` method takes a lambda expression and executes it. To be
    more precise, `(b: Brand)` contained in the brackets is an example of a lambda.
    Now, let''s ask some questions. What do lambdas have to do with combinators? Or
    let''s ask, what''s the working (functional) programmer''s definition of a combinator?
    Well, to answer these kinds of questions, we''ll use the first Wikipedia definition.
    If you take a closer look, there are a few things to notice. Firstly, it''s a
    higher-order function and secondly, it''s a closed lambda. Closed means it does
    not contain any *free* variables. For those of you who want to know what a free
    variable is, take a look at the following lambda:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`foreach` 方法接受一个 lambda 表达式并执行它。更准确地说，括号内的 `(b: Brand)` 是 lambda 的一个例子。现在，让我们提出一些问题。lambda
    与组合子有什么关系？或者让我们问，工作（函数式）程序员对组合子的定义是什么？好吧，为了回答这些问题，我们将使用第一个维基百科的定义。如果你仔细观察，有几个需要注意的地方。首先，它是一个高阶函数，其次，它是一个封闭的
    lambda。封闭意味着它不包含任何 *自由* 变量。对于那些想知道什么是自由变量的你，请看以下 lambda：'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, `y` is a free variable. We''ve seen these kinds of higher-order functions
    with no free variables before: our `map` and `filter` functions. These are called
    combinators. In functional programming, we tend to use these a lot. You can also
    use these as transformations to already available data. If we use these combinators
    together, they''re really helpful for forming data flow logic. This means, if
    you use `map`, `filter`, and `fold` as combinators together, you can create a
    domain logic out of your program. This way of writing programs is often used in
    functional programming. You''ll find more of these when you check out the written
    libraries. Various combinators are used for all sorts of collections and other
    data structures. The reason for using these combinators is that they provide an
    abstract or, in other words, a generalized approach to perform some operations.
    Hence they''re used everywhere. It''s easy and fun to implement some logic that
    looks like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`y` 是一个自由变量。我们之前已经见过这类没有自由变量的高阶函数：我们的 `map` 和 `filter` 函数。这些被称为组合子。在函数式编程中，我们倾向于大量使用这些。你也可以将这些用作对现有数据的转换。如果我们将这些组合子组合起来，它们对于形成数据流逻辑非常有帮助。这意味着，如果你将
    `map`、`filter` 和 `fold` 作为组合子一起使用，你可以从你的程序中创建出领域逻辑。这种编写程序的方式在函数式编程中经常被使用。当你查看编写好的库时，你会找到更多这样的例子。各种组合子被用于各种集合和其他数据结构。使用这些组合子的原因在于它们提供了一种抽象的，或者说，一种通用的方法来执行某些操作。因此，它们被广泛应用于各个领域。实现一些类似以下逻辑的代码既容易又有趣：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's really a powerful construct and used a lot in functional programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个强大的构造，在函数式编程中被广泛使用。
- en: Now that you've learned about combinators, and are also aware of higher-order
    functions, you're equipped to solve programming problems. So what now? It's time
    to take the next step. We'll dive into the abstract (sea) levels of Scala programming.
    If we can make our solutions abstract, it means the solutions we provide should
    satisfy more than just one problem statement. Let's start with learning about
    t*ype parameterization.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了组合子，并且也意识到了高阶函数，你就有能力解决编程问题。那么接下来呢？现在是时候迈出下一步了。我们将深入 Scala 编程的抽象（海洋）层面。如果我们能使我们的解决方案抽象化，这意味着我们提供的解决方案应该满足不止一个问题陈述。让我们从学习关于
    t*ype parameterization* 开始。
- en: Type parameterization
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数化
- en: For an introduction to **type parameterization**, we'll refer to two examples
    we've already seen to try to make some sense of it. I know you're following the
    chapter with interest and you've gone through the examples and concepts we've
    talked about, so let's do an exercise. Think of our savior, `Option[T]` type and
    try to think why you would want to pass a type (as it requires `T` to be a type)
    to `Option`. What purpose can it serve?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**类型参数化**的介绍，我们将参考我们已经看到的两个例子，试图弄清楚它的意义。我知道你很感兴趣地跟随着这一章，你已经阅读了我们讨论的例子和概念，所以让我们做一个练习。想想我们的救星`Option[T]`类型，并尝试思考你为什么想向`Option`传递一个类型（因为它要求`T`是一个类型）。它可以有什么用途？
- en: 'I think you''ve come up with some idea. Maybe you thought that by passing a
    type of our choice, we can make our code with the `Option` type work in more than
    one scenario. If you thought so, great! Let''s call it generalizing our solution.
    And moreover, let''s call the approach a generic approach to programming. How
    does it look? Let''s take a look at the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你提出了一些想法。也许你认为通过传递我们选择的一种类型，我们可以让我们的代码使用`Option`类型在多个场景下工作。如果你这样想，太好了！让我们称它为我们的解决方案的泛化。而且，让我们称这种方法为编程的泛型方法。它看起来怎么样？让我们看看下面的代码：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So as the code suggests, we have some optional strings, which can be of the
    `Int`, `String`, or `Boolean` type*.* Our intention was to convert them to their
    respective types. So we formed some functions, which take the optional string
    and then we convert them to their respective types, so we passed a function literal
    for that. If we can't think of a few counter cases, then it means it's working.
    However, the solution is bulky; it doesn't feel good. Plus, we can see that there's
    some repetitiveness in the code. We are doing an almost similar operation to `mapToXXX`,
    where we think of `XXX` as any type. It seems that we can generalize the solution.
    Let's think about it, how can we do this?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以正如代码所暗示的，我们有一些可选的字符串，可以是`Int`、`String`或`Boolean`类型*.* 我们的意图是将它们转换为它们各自类型。因此，我们形成了一些函数，它们接受可选的字符串，然后我们将它们转换为它们各自类型，所以为此我们传递了一个函数字面量。如果我们不能想到几个反例，那么这意味着它正在工作。然而，这个解决方案很庞大；它感觉不太好。此外，我们可以看到代码中存在一些重复性。我们在几乎相同的操作中使用了`mapToXXX`，其中我们将`XXX`视为任何类型。看起来我们可以泛化这个解决方案。让我们考虑一下，我们如何做到这一点？
- en: 'How can we tell the method about the types we are going to provide? One solution
    is to pass the types to the method as parameters and then use them in the declaration.
    Let''s try the solution and see what the code looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何告诉方法我们将提供的类型？一个解决方案是将类型作为参数传递给方法，然后在声明中使用它们。让我们尝试这个解决方案，看看代码会是什么样子：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the generalization, we are able to perform the same logic with just one
    function. So, let''s take a look at the change and the way we gave type parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化之后，我们只需一个函数就能执行相同的逻辑。所以，让我们看看变化以及我们如何给出类型参数：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding `mapToValue` function, after giving the function name, that
    is, `mapToValue`, we gave `T` in braces as a type parameter. With this, we got
    the license to use this type parameter in the function declaration and definition.
    Hence, we used it as a type in a function literal and as return types. We''re
    allowed to give any number of type parameters based on the use. For example, if
    you want to make it more generalized, the function may look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`mapToValue`函数中，在给出函数名，即`mapToValue`之后，我们在花括号中给出了`T`作为类型参数。有了这个，我们就得到了在函数声明和定义中使用这个类型参数的许可。因此，我们将其用作函数字面量中的类型以及返回类型。根据使用情况，我们可以给出任意数量的类型参数。例如，如果你想让它更通用，函数可能看起来像以下这样：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this definition, we used two type parameters, `A` and `B`, and hence made
    our method more generalized. If you take a look at the `map` method from `Option[T]`,
    it looks like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，我们使用了两个类型参数`A`和`B`，因此使我们的方法更加通用。如果你看看`Option[T]`中的`map`方法，它看起来如下：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have used type parameters in the function definition of `map`. So,
    according to this, for `Option[A]`, we have a `map` method, which takes a function
    from `A` type to `B` type. So the compiler will infer the `A` and `B` type when
    you give a call to this `map` method from the context.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`map`函数的定义中使用了类型参数。根据这一点，对于`Option[A]`，我们有一个从`A`类型到`B`类型的函数`map`方法。所以当你从这个`map`方法中给出调用时，编译器会根据上下文推断出`A`和`B`类型。
- en: This is just an introduction to type parameterization. In the next chapter,
    we'll get to see more of it along with some advanced concepts. With this, we can
    end our chapter, let's summarize what we've learned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于类型参数化的简介。在下一章中，我们将看到更多关于它的内容，以及一些高级概念。有了这些，我们可以结束本章，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter gave us insights into how we can implement logic with different
    flavors of implementation. We talked about for expressions and their translation
    into higher-order functions. We saw how *pattern matching* can make complex logic
    look very simple. We also talked about constructs such as `Option` and the `lazy`
    keyword. These enable us to write code that is meaningful and optimized. Then
    we discussed *tail call optimization*. We confronted *combinators*, and then finally
    we got an introduction to *type parameterization*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让我们了解了如何以不同的实现风格实现逻辑。我们讨论了for表达式及其转换为高阶函数。我们看到*模式匹配*如何使复杂的逻辑看起来非常简单。我们还讨论了诸如`Option`和`lazy`关键字这样的结构。这些使我们能够编写有意义的和优化的代码。然后我们讨论了*尾调用优化*。我们面对了*组合子*，最后我们得到了关于*类型参数化*的介绍。
- en: In the next chapter, we'll start from where we ended this chapter. We'll talk
    more about types, parameterized types, and variance relationships, and let me
    tell you, that will be fun.*
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从本章结束的地方开始。我们将更多地讨论类型、参数化类型和变体关系，让我告诉你，那将会很有趣*。
