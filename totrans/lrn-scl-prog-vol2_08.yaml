- en: Using Powerful Functional Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We cannot solve our problems with the same thinking we used when we created
    them."'
  prefs: []
  type: TYPE_NORMAL
- en: – Albert Einstein
  prefs: []
  type: TYPE_NORMAL
- en: When we try to solve problems by writing programs, our intention is to write
    better code. More precisely*,* we mean that code should be readable and efficient
    at compile time and runtime. Readability and efficiency are two major factors,
    along with other important concepts such as concurrency, asynchronous tasks, and
    so on. We can think of the first two as the building blocks for the next set of
    characteristics we want. Scala, as a multi-paradigm language, provides multiple
    constructs that ensure the code we write is optimized, and also provides syntactic
    sugar wherever required. Many of the functional constructs or concepts used in
    *functional programming* enable you to write *better* code that not only fulfills
    the first two requirements but also allows your code to run in *concurrent* and
    *distributed* environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our intention in this chapter is to learn the ways we can make our code better.
    For that, we''ll go through some of the syntactical constructs. Let''s take a
    look at what we are going to go through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: For expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail call optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type parameterization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these concepts are simple but very useful for when you write Scala code.
    Some of them we've already gone through, such as *for expressions.* Our intention
    here is to compare for expressions with the available higher-order functions,
    such as `map`, `flatMap`, and `withFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: For expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would not be wrong, if we say that the `for` expressions are powerful constructs
    in Scala. For expressions let you traverse through any collection and perform
    operations such as filtering and yielding out new collections. We have already
    gone through this concept in [Chapter 3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Shaping Up our Scala Program.* Let''s recall the example we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have a collection of `Person` objects. We are performing
    a traversal on the collection and generating another collection consisting of
    names for all persons based on some condition. As we already know, for this we
    are using three constructs, or let''s say expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person <- persons`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age = person.age`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name = person.name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age > 20`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these three expressions we were able to perform slightly complex logic
    with very little syntactical effort. We could have done a similar operation in
    the form of higher-order functions. Using `map` and `withFilter` we can perform
    such operations, let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used higher-order functions to implement the same logic we implemented
    using for expressions. We're already familiar with the `map` method from a collection.
    It's going to provide you a list of persons whose age is greater than 20\. So
    now, we have the same logic implemented in two different ways. First, in the form
    of *for expressions*, and second, in the form of *higher-order functions.* So
    it's important for us to know how this happens. What the Scala compiler does is
    it internally breaks down for expressions into higher-order functions. Programmers
    tend to prefer using for expressions for readability but it's a matter of choice.
    Now that we know what happens internally, we can start thinking about the translation
    Scala does for slightly complex for expressions, can't we? Yes, so let's try it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we have a list of car brands, and each brand has many cars in
    it (in other words, each brand has a list of cars). The code will look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may want to yield a list of pairs for all the Tesla cars whose name starts
    with the `Model` keyword . You''ll perform something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We used for expressions for this task. This has two generator expressions,
    and we are also performing a filtering operation on it. While translating these
    kinds of for expressions into higher-order functions, Scala uses the `flatMap`
    method. Let''s see how the same can be implemented using `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We got a similar result with this definition. So let''s try to break this `teslaCarsStartsWithModel2`
    down to understand how we implemented this. First, what we had was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In scenarios where we have two generators, we use `flatMap` functions instead
    of `map`. Let''s go through the translation from for expressions to higher-order
    functions step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We first used `flatMap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got the brand, we have access to the cars list. We can proceed
    with a filtering predicate as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the final version of our implementation. What we have done here is we
    filtered out elements from our `cars` collection and finally transformed our collection
    to the intended form.
  prefs: []
  type: TYPE_NORMAL
- en: So this is the way the Scala compiler does translations of our for expressions
    into the provided functions. As programmers, we only have to deal with the implementation
    part. You may want to put your logic in the for expressions instead of writing
    nested higher-order functions, and Scala does the rest for you.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we learned how you can add your logic in different forms in detail. Similarly,
    you'll also find cases that we will have to go through and then execute any logic
    applicable. In this process of matching different cases, we can empower ourselves
    by matching through different patterns. For example, we may want to match our
    list type against the possible values. The options are going to be either an empty
    list or a list with certain values. Scala doesn't limit you to matching in these
    two ways, but you'll have more options to match against. All this is possible
    via a concept called *pattern matching.* The good thing is, we've already gone
    through the pattern matching concept so what we are going to do now is try to
    understand it further.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use **pattern matching** to execute code on a case-by-case basis. Take a
    look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By taking a look at the structure of our pattern match expression, we see a
    few things. First, we execute a match on some value followed by the `match` keyword
    and then we put cases. For each case we specify some patterns. Now, the pattern
    can be a constant value, a variable, or even a constructor. We'll soon have a
    look at all of these patterns. Pattern matching also allows us to put guards on
    our match in the form of a condition. In that case, the pattern will only match
    if the condition is applicable. If you take a look at the previous toy example
    about `somelist`, you'll see there's an *`*_*` underscore. It's called a **wildcard
    pattern**. It'll match all values or patterns against the case. Logically, you
    can't put another case after a wildcard. For example, the following does not make
    any sense and throws a warning:*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE14]'
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty basic example of pattern matching in Scala. There are more
    ways we can pattern match. Why not take a look at all of them?
  prefs: []
  type: TYPE_NORMAL
- en: Different ways we can pattern match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching in Scala proves to be a very important concept. We can match
    on variables, constants, and even constructors. We'll take a look at all of them.
    Let's start with matching against a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, when we have to use the value after the pattern match is successful,
    we want to match against cases with variables. What this does is it assigns the
    value to the variable and then we can use that in our code for that particular
    case. It''s better if we look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a method which tries to convert a number represented by
    a string to an integer. Then, we call the method with a parameter and try to match
    the same using a variable named `someValue`. This `someValue` variable is going
    to be of the same type as the value's matched type.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a constant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also match cases against a constant, such as basic switch statements.
    Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we directly matched our expression against constant values. This can be
    any value, depending upon the type your method accepts. You are allowed to match
    against a Boolean, string, or any other constant value.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, what does a constructor pattern look like? It''s about matching a constructor
    against a value, or we could say, extracting values of our choice. Let''s take
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference we can see here is, instead of providing a variable, we
    gave a constructor pattern. `Some(value)` lets you extract the `value` out of
    itself. Here in the given example, the `safeToInt` method returns an `Option`
    type. We''re going to learn about types in subsequent sections. For now, the interesting
    information for us is that we have two subtypes of our `Option` type named `Some`
    and `None`, and as the names suggest, `Some` means some value and `None` means
    no value. The `Some` subtype expects a particular value as its constructor parameter.
    Hence it''s possible for us to match on that. The following line does the exact
    thing we just mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this declaration we can extract a value, in our case the extracted parameter
    name is also `value`, hence we used it. This is an example of using a constructor
    for our pattern matching. We''ve learned about `case` classes in Scala and also
    mentioned that `case` classes provide us an exact structure, using which we can
    directly perform pattern matching. So let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here in this example, we defined three categories of employees: `Developer`,
    `Consultant`, and `ContractEmp`. We''ve a problem to solve: we''ll have to process
    the joining bonus amount for specific employees in a specific category with some
    conditions. The whole logic is very simple to implement in terms of `case` classes
    and pattern matching and that''s what we have done here. Take a look at the following
    line from the previous solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we matched against a `case` class constructor. We gave some names to the
    required parameters, others we replaced with the wildcard `_` underscore. Here,
    we had to put a condition on the `id` parameter*,* hence we mentioned it in the
    constructor of the respective `case` class. You can see how `case` classes and
    pattern matching can make a slightly complex domain problem very easy to solve.
    Well, it doesn''t end there, there''s more. We can also put guards against our
    `case` expressions. Let''s see the same example with guards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the following expression, we can see guards on our `case` patterns.
    So the value will only match if the guard allows it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, before going to the right-hand side of the execution block, this expression
    checks if the `id` starts with `"DL"`, and based on that, it matches. This is
    how we can use a constructor directly to extract parameters and use them. You
    can also use patterns in some more ways. For example, we can perform a match against
    a sequence or a tuple. It''s also possible for when we have to match some nested
    expression, or match a `case` class that has another `case` class inside. For
    our code to make more sense, and for readability purposes, we can bind the nesting
    `case` class using the `@` symbol and perform pattern matching. Let''s take an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is self-explanatory. We have a nested `case` class inside
    our `Car`, named `CarBrand`, and we performed a pattern match against that. We
    got access to that particular object using the `@` symbol. So, these are a few
    ways we can use pattern matching to perform all those tasks very easily. By now,
    you must have an idea about pattern matching; how powerful and important it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'While performing all these pattern matches, we felt that there are counter
    cases where we don''t want to perform matches, and use a wildcard so that we can
    provide any value in return. It''s possible that there''s no intended value for
    such cases, and we just want our code to make sense and at the same time return
    a meaningful response. In those cases, we can use our `Option` type. As the name
    suggests, when you define a type as `Option`, you may get either some value or
    no value. To make it more clear, let''s recall our `safeToInt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the definition of our `safeToInt` function, we defined our response
    type to be `Option` simply because we knew that it may or may not respond with
    a meaningful value. Now the reason for using an `Option` instead of using any
    type directly is clear, let's discuss the `Option` type.
  prefs: []
  type: TYPE_NORMAL
- en: Option type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Option is one of the type constructors that Scala provides. The question arises,
    what''s a type constructor? The answer is simple; it lets you construct a type.
    We''ll take two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Option` is a type constructor'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Option[Int]` is a type'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's discuss these in detail. When I say `Foo` is a type constructor, it means
    that `Foo` expects you to provide a particular type in the form of a parameter.
    It looks like `Foo[T]`, where `T` is an actual type. We call them **type parameters**
    and we'll talk about them in the following few sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second statement, we saw that we gave an `Int` type to our `Option`
    type constructor in brackets and it formed a type. If you try this in the Scala
    REPL, it''ll tell you exactly the same thing we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In simple words, the `Option[T]` type represents an optional value of any given
    type `T`. Now `T` can be any type you pass, in the previous example it was `Int`.
    The `Option[T]` type has two subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some(T)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When there''s a value available, we''ll get the `Some` value, otherwise `None`.
    The `Option` type also provides you a `map` method. The way you would want to
    use an option value is by calling the `map` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens here is the `map` method gives you the respective value if it''s
    available. Otherwise, if the optional value is `None`, it''s not going to do anything.
    Usually, you would want to use this type as an exception handling mechanism. How
    can we do this? We''ve already seen an example of it. Recall our `safeToInt` method,
    without `Option` it''ll look like this (maybe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But if you take a look at the signature, the declaration tells you that the
    function is going to return you an `Int` but the function, in reality, may also
    throw an `Exception`. That's neither intended nor correct. The function should
    follow its own declaration. Hence, we can use our `Option` type, which as a savior,
    does what our declaration says. `Option` is one of the constructs *functional
    programming* provides for you.
  prefs: []
  type: TYPE_NORMAL
- en: There're more of these and they provide you with some ready-to-use constructs.
    Some of them are the types, `Either`, `Try`, and a few more. You may refer to
    the Scala API documentation ([http://www.scala-lang.org/api/2.12.3/scala/util/Either.html](http://www.scala-lang.org/api/2.12.3/scala/util/Either.html))
    for more information about these types.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll talk about one more functional construct. It's more than just a
    construct, it's a scheme of evaluation. Yes, we are talking about *lazy evaluation.*
    Scala allows you to use this scheme in more than one way. Let's talk about the
    `lazy` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before learning more about the `lazy` keyword or lazy evaluation, let's talk
    about why we need it and exactly what it is. Just how beneficial lazy evaluation
    is can be explained with a few lines, or a few pages, but for our understanding
    let's have a one liner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation** lets you write your code in a way where the order of evaluation
    doesn''t matter. It also saves you some time, by only evaluating expressions that
    you need. It''s like so many complex evaluations, that exists in your code, but
    never evaluation dues to a certain. The last line is only possible due to the
    concept of lazy evaluation. In Scala, you can declare a value as `lazy`. Let''s
    take an example. Try the following in the Scala REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, when we assigned a value of `1` to our `val v`, the REPL gave us the `Int`
    type and the value as `<lazy>`, and for the `val z` we got `1`. Why this happened
    is because of the `lazy` declaration. In Scala, when you declare a value as lazy,
    the compiler evaluates the value only when we use it for the first time. With
    this, you free yourself from the worry of putting the `val` declaration in any
    order. Each `lazy` value is evaluated when it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: While we're talking about making our code optimized, let's look at another concept,
    *tail call optimization.* We first introduced *tail call optimization* in [Chapter
    3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84), *Shaping Up our Scala
    Program* while discussing *recursion.* Let's talk about it in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Tail call optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are familiar with the limitations recursion brings with it. We are aware
    that each function call, if not tail recursive, builds a new stack frame. For
    scenarios where we have to deal with a large number of function calls, this could
    possibly result in a stack overflow, which is undesirable. So, what''s suggested
    in this kind of scenario is to make the recursive function call the last statement
    in your function definition, the Scala compiler then does the rest for you. Take
    a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, if you take a closer look, you''ll see that wherever
    we made a recursive call, it''s the last statement in that particular scope. It
    means that our call to `someRecursiveMethod` is a last call and there was no other
    call after that. If it isn''t, the Scala compiler will alert you with a message
    saying the recursive call is not in the tail position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, one thing to notice is that we''re helping out the Scala compiler by
    providing the annotation as `tailrec`. When we provide this annotation, the compiler
    considers your function as a tail recursive function. Evaluation of such a function
    does not create separate stack frames on each call, but uses the ones already
    created. This is how we avoid stack overflow and use recursion. What we''ve tried
    to do in our example is match to a list of names. Yes, you''re already familiar
    with the notion of pattern matching. If not `Nil`, we check for the name `Raven`
    in the list*,* and then we stop further calls. If you''re missing `break` or `continue`
    statements in Scala, this is the way that you can implement them: by using recursion
    and checking for the condition.'
  prefs: []
  type: TYPE_NORMAL
- en: So this was all about tail call optimization. We've also seen that the Scala
    compiler helps us when we provide the annotation. Well, recursion helps you avoid
    mutability and at the same time achieve complex logic, adding to the already powerful
    functional programming. Since we are learning about functional programming constructs,
    it's really important for us to know that they are rooted in *eternal mathematics.*
    Mathematics created the notion of functional programming, and almost all functional
    programming concepts come from some mathematical proof or concept. One of them
    is a combinator. Learning about combinators or understanding how they are related
    to mathematics is beyond the scope of this book but we will look at a short introduction
    and see a simple example. It'll be fun. Let's go through *combinators.*
  prefs: []
  type: TYPE_NORMAL
- en: Combinators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wikipedia says the following about **combinators**:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Combinator is a higher-order function that uses only function application
    and earlier defined Combinators to define a result from its arguments."'
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as this definition, we could also say that a combinator is a closed
    *lambda* expression. We have already seen lambda applications in several places
    and defined them. A lambda is nothing more than an anonymous definition of any
    function. For example, when you pass an expression to our beloved `foreach` method,
    you pass it in the form of a lambda expression. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `foreach` method takes a lambda expression and executes it. To be
    more precise, `(b: Brand)` contained in the brackets is an example of a lambda.
    Now, let''s ask some questions. What do lambdas have to do with combinators? Or
    let''s ask, what''s the working (functional) programmer''s definition of a combinator?
    Well, to answer these kinds of questions, we''ll use the first Wikipedia definition.
    If you take a closer look, there are a few things to notice. Firstly, it''s a
    higher-order function and secondly, it''s a closed lambda. Closed means it does
    not contain any *free* variables. For those of you who want to know what a free
    variable is, take a look at the following lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `y` is a free variable. We''ve seen these kinds of higher-order functions
    with no free variables before: our `map` and `filter` functions. These are called
    combinators. In functional programming, we tend to use these a lot. You can also
    use these as transformations to already available data. If we use these combinators
    together, they''re really helpful for forming data flow logic. This means, if
    you use `map`, `filter`, and `fold` as combinators together, you can create a
    domain logic out of your program. This way of writing programs is often used in
    functional programming. You''ll find more of these when you check out the written
    libraries. Various combinators are used for all sorts of collections and other
    data structures. The reason for using these combinators is that they provide an
    abstract or, in other words, a generalized approach to perform some operations.
    Hence they''re used everywhere. It''s easy and fun to implement some logic that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's really a powerful construct and used a lot in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about combinators, and are also aware of higher-order
    functions, you're equipped to solve programming problems. So what now? It's time
    to take the next step. We'll dive into the abstract (sea) levels of Scala programming.
    If we can make our solutions abstract, it means the solutions we provide should
    satisfy more than just one problem statement. Let's start with learning about
    t*ype parameterization.*
  prefs: []
  type: TYPE_NORMAL
- en: Type parameterization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an introduction to **type parameterization**, we'll refer to two examples
    we've already seen to try to make some sense of it. I know you're following the
    chapter with interest and you've gone through the examples and concepts we've
    talked about, so let's do an exercise. Think of our savior, `Option[T]` type and
    try to think why you would want to pass a type (as it requires `T` to be a type)
    to `Option`. What purpose can it serve?
  prefs: []
  type: TYPE_NORMAL
- en: 'I think you''ve come up with some idea. Maybe you thought that by passing a
    type of our choice, we can make our code with the `Option` type work in more than
    one scenario. If you thought so, great! Let''s call it generalizing our solution.
    And moreover, let''s call the approach a generic approach to programming. How
    does it look? Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So as the code suggests, we have some optional strings, which can be of the
    `Int`, `String`, or `Boolean` type*.* Our intention was to convert them to their
    respective types. So we formed some functions, which take the optional string
    and then we convert them to their respective types, so we passed a function literal
    for that. If we can't think of a few counter cases, then it means it's working.
    However, the solution is bulky; it doesn't feel good. Plus, we can see that there's
    some repetitiveness in the code. We are doing an almost similar operation to `mapToXXX`,
    where we think of `XXX` as any type. It seems that we can generalize the solution.
    Let's think about it, how can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we tell the method about the types we are going to provide? One solution
    is to pass the types to the method as parameters and then use them in the declaration.
    Let''s try the solution and see what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After the generalization, we are able to perform the same logic with just one
    function. So, let''s take a look at the change and the way we gave type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `mapToValue` function, after giving the function name, that
    is, `mapToValue`, we gave `T` in braces as a type parameter. With this, we got
    the license to use this type parameter in the function declaration and definition.
    Hence, we used it as a type in a function literal and as return types. We''re
    allowed to give any number of type parameters based on the use. For example, if
    you want to make it more generalized, the function may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In this definition, we used two type parameters, `A` and `B`, and hence made
    our method more generalized. If you take a look at the `map` method from `Option[T]`,
    it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used type parameters in the function definition of `map`. So,
    according to this, for `Option[A]`, we have a `map` method, which takes a function
    from `A` type to `B` type. So the compiler will infer the `A` and `B` type when
    you give a call to this `map` method from the context.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an introduction to type parameterization. In the next chapter,
    we'll get to see more of it along with some advanced concepts. With this, we can
    end our chapter, let's summarize what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave us insights into how we can implement logic with different
    flavors of implementation. We talked about for expressions and their translation
    into higher-order functions. We saw how *pattern matching* can make complex logic
    look very simple. We also talked about constructs such as `Option` and the `lazy`
    keyword. These enable us to write code that is meaningful and optimized. Then
    we discussed *tail call optimization*. We confronted *combinators*, and then finally
    we got an introduction to *type parameterization*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start from where we ended this chapter. We'll talk
    more about types, parameterized types, and variance relationships, and let me
    tell you, that will be fun.*
  prefs: []
  type: TYPE_NORMAL
