- en: Using Powerful Functional Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We cannot solve our problems with the same thinking we used when we created
    them."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: – Albert Einstein
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: When we try to solve problems by writing programs, our intention is to write
    better code. More precisely*,* we mean that code should be readable and efficient
    at compile time and runtime. Readability and efficiency are two major factors,
    along with other important concepts such as concurrency, asynchronous tasks, and
    so on. We can think of the first two as the building blocks for the next set of
    characteristics we want. Scala, as a multi-paradigm language, provides multiple
    constructs that ensure the code we write is optimized, and also provides syntactic
    sugar wherever required. Many of the functional constructs or concepts used in
    *functional programming* enable you to write *better* code that not only fulfills
    the first two requirements but also allows your code to run in *concurrent* and
    *distributed* environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Our intention in this chapter is to learn the ways we can make our code better.
    For that, we''ll go through some of the syntactical constructs. Let''s take a
    look at what we are going to go through in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: For expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Option type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy declaration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail call optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type parameterization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these concepts are simple but very useful for when you write Scala code.
    Some of them we've already gone through, such as *for expressions.* Our intention
    here is to compare for expressions with the available higher-order functions,
    such as `map`, `flatMap`, and `withFilter`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: For expressions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would not be wrong, if we say that the `for` expressions are powerful constructs
    in Scala. For expressions let you traverse through any collection and perform
    operations such as filtering and yielding out new collections. We have already
    gone through this concept in [Chapter 3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Shaping Up our Scala Program.* Let''s recall the example we saw:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous example, we have a collection of `Person` objects. We are performing
    a traversal on the collection and generating another collection consisting of
    names for all persons based on some condition. As we already know, for this we
    are using three constructs, or let''s say expressions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Generator
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person <- persons`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Definition
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age = person.age`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name = person.name`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age > 20`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these three expressions we were able to perform slightly complex logic
    with very little syntactical effort. We could have done a similar operation in
    the form of higher-order functions. Using `map` and `withFilter` we can perform
    such operations, let''s take a look at an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have used higher-order functions to implement the same logic we implemented
    using for expressions. We're already familiar with the `map` method from a collection.
    It's going to provide you a list of persons whose age is greater than 20\. So
    now, we have the same logic implemented in two different ways. First, in the form
    of *for expressions*, and second, in the form of *higher-order functions.* So
    it's important for us to know how this happens. What the Scala compiler does is
    it internally breaks down for expressions into higher-order functions. Programmers
    tend to prefer using for expressions for readability but it's a matter of choice.
    Now that we know what happens internally, we can start thinking about the translation
    Scala does for slightly complex for expressions, can't we? Yes, so let's try it
    out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we have a list of car brands, and each brand has many cars in
    it (in other words, each brand has a list of cars). The code will look something
    like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may want to yield a list of pairs for all the Tesla cars whose name starts
    with the `Model` keyword . You''ll perform something like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We used for expressions for this task. This has two generator expressions,
    and we are also performing a filtering operation on it. While translating these
    kinds of for expressions into higher-order functions, Scala uses the `flatMap`
    method. Let''s see how the same can be implemented using `flatMap`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We got a similar result with this definition. So let''s try to break this `teslaCarsStartsWithModel2`
    down to understand how we implemented this. First, what we had was the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In scenarios where we have two generators, we use `flatMap` functions instead
    of `map`. Let''s go through the translation from for expressions to higher-order
    functions step by step:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We first used `flatMap`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we''ve got the brand, we have access to the cars list. We can proceed
    with a filtering predicate as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the final version of our implementation. What we have done here is we
    filtered out elements from our `cars` collection and finally transformed our collection
    to the intended form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: So this is the way the Scala compiler does translations of our for expressions
    into the provided functions. As programmers, we only have to deal with the implementation
    part. You may want to put your logic in the for expressions instead of writing
    nested higher-order functions, and Scala does the rest for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Here, we learned how you can add your logic in different forms in detail. Similarly,
    you'll also find cases that we will have to go through and then execute any logic
    applicable. In this process of matching different cases, we can empower ourselves
    by matching through different patterns. For example, we may want to match our
    list type against the possible values. The options are going to be either an empty
    list or a list with certain values. Scala doesn't limit you to matching in these
    two ways, but you'll have more options to match against. All this is possible
    via a concept called *pattern matching.* The good thing is, we've already gone
    through the pattern matching concept so what we are going to do now is try to
    understand it further.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use **pattern matching** to execute code on a case-by-case basis. Take a
    look at the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By taking a look at the structure of our pattern match expression, we see a
    few things. First, we execute a match on some value followed by the `match` keyword
    and then we put cases. For each case we specify some patterns. Now, the pattern
    can be a constant value, a variable, or even a constructor. We'll soon have a
    look at all of these patterns. Pattern matching also allows us to put guards on
    our match in the form of a condition. In that case, the pattern will only match
    if the condition is applicable. If you take a look at the previous toy example
    about `somelist`, you'll see there's an *`*_*` underscore. It's called a **wildcard
    pattern**. It'll match all values or patterns against the case. Logically, you
    can't put another case after a wildcard. For example, the following does not make
    any sense and throws a warning:*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty basic example of pattern matching in Scala. There are more
    ways we can pattern match. Why not take a look at all of them?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Different ways we can pattern match
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching in Scala proves to be a very important concept. We can match
    on variables, constants, and even constructors. We'll take a look at all of them.
    Let's start with matching against a variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Matching a variable
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, when we have to use the value after the pattern match is successful,
    we want to match against cases with variables. What this does is it assigns the
    value to the variable and then we can use that in our code for that particular
    case. It''s better if we look at the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have defined a method which tries to convert a number represented by
    a string to an integer. Then, we call the method with a parameter and try to match
    the same using a variable named `someValue`. This `someValue` variable is going
    to be of the same type as the value's matched type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Matching a constant
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also match cases against a constant, such as basic switch statements.
    Take a look at the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we directly matched our expression against constant values. This can be
    any value, depending upon the type your method accepts. You are allowed to match
    against a Boolean, string, or any other constant value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Matching a constructor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, what does a constructor pattern look like? It''s about matching a constructor
    against a value, or we could say, extracting values of our choice. Let''s take
    an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only difference we can see here is, instead of providing a variable, we
    gave a constructor pattern. `Some(value)` lets you extract the `value` out of
    itself. Here in the given example, the `safeToInt` method returns an `Option`
    type. We''re going to learn about types in subsequent sections. For now, the interesting
    information for us is that we have two subtypes of our `Option` type named `Some`
    and `None`, and as the names suggest, `Some` means some value and `None` means
    no value. The `Some` subtype expects a particular value as its constructor parameter.
    Hence it''s possible for us to match on that. The following line does the exact
    thing we just mentioned:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this declaration we can extract a value, in our case the extracted parameter
    name is also `value`, hence we used it. This is an example of using a constructor
    for our pattern matching. We''ve learned about `case` classes in Scala and also
    mentioned that `case` classes provide us an exact structure, using which we can
    directly perform pattern matching. So let''s take an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here in this example, we defined three categories of employees: `Developer`,
    `Consultant`, and `ContractEmp`. We''ve a problem to solve: we''ll have to process
    the joining bonus amount for specific employees in a specific category with some
    conditions. The whole logic is very simple to implement in terms of `case` classes
    and pattern matching and that''s what we have done here. Take a look at the following
    line from the previous solution:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we matched against a `case` class constructor. We gave some names to the
    required parameters, others we replaced with the wildcard `_` underscore. Here,
    we had to put a condition on the `id` parameter*,* hence we mentioned it in the
    constructor of the respective `case` class. You can see how `case` classes and
    pattern matching can make a slightly complex domain problem very easy to solve.
    Well, it doesn''t end there, there''s more. We can also put guards against our
    `case` expressions. Let''s see the same example with guards:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we look at the following expression, we can see guards on our `case` patterns.
    So the value will only match if the guard allows it to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, before going to the right-hand side of the execution block, this expression
    checks if the `id` starts with `"DL"`, and based on that, it matches. This is
    how we can use a constructor directly to extract parameters and use them. You
    can also use patterns in some more ways. For example, we can perform a match against
    a sequence or a tuple. It''s also possible for when we have to match some nested
    expression, or match a `case` class that has another `case` class inside. For
    our code to make more sense, and for readability purposes, we can bind the nesting
    `case` class using the `@` symbol and perform pattern matching. Let''s take an
    example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example is self-explanatory. We have a nested `case` class inside
    our `Car`, named `CarBrand`, and we performed a pattern match against that. We
    got access to that particular object using the `@` symbol. So, these are a few
    ways we can use pattern matching to perform all those tasks very easily. By now,
    you must have an idea about pattern matching; how powerful and important it is.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'While performing all these pattern matches, we felt that there are counter
    cases where we don''t want to perform matches, and use a wildcard so that we can
    provide any value in return. It''s possible that there''s no intended value for
    such cases, and we just want our code to make sense and at the same time return
    a meaningful response. In those cases, we can use our `Option` type. As the name
    suggests, when you define a type as `Option`, you may get either some value or
    no value. To make it more clear, let''s recall our `safeToInt` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, in the definition of our `safeToInt` function, we defined our response
    type to be `Option` simply because we knew that it may or may not respond with
    a meaningful value. Now the reason for using an `Option` instead of using any
    type directly is clear, let's discuss the `Option` type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Option type
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Option is one of the type constructors that Scala provides. The question arises,
    what''s a type constructor? The answer is simple; it lets you construct a type.
    We''ll take two statements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`Option` is a type constructor'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Option[Int]` is a type'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's discuss these in detail. When I say `Foo` is a type constructor, it means
    that `Foo` expects you to provide a particular type in the form of a parameter.
    It looks like `Foo[T]`, where `T` is an actual type. We call them **type parameters**
    and we'll talk about them in the following few sections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second statement, we saw that we gave an `Int` type to our `Option`
    type constructor in brackets and it formed a type. If you try this in the Scala
    REPL, it''ll tell you exactly the same thing we discussed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In simple words, the `Option[T]` type represents an optional value of any given
    type `T`. Now `T` can be any type you pass, in the previous example it was `Int`.
    The `Option[T]` type has two subtypes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`Some(T)`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When there''s a value available, we''ll get the `Some` value, otherwise `None`.
    The `Option` type also provides you a `map` method. The way you would want to
    use an option value is by calling the `map` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What happens here is the `map` method gives you the respective value if it''s
    available. Otherwise, if the optional value is `None`, it''s not going to do anything.
    Usually, you would want to use this type as an exception handling mechanism. How
    can we do this? We''ve already seen an example of it. Recall our `safeToInt` method,
    without `Option` it''ll look like this (maybe):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But if you take a look at the signature, the declaration tells you that the
    function is going to return you an `Int` but the function, in reality, may also
    throw an `Exception`. That's neither intended nor correct. The function should
    follow its own declaration. Hence, we can use our `Option` type, which as a savior,
    does what our declaration says. `Option` is one of the constructs *functional
    programming* provides for you.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: There're more of these and they provide you with some ready-to-use constructs.
    Some of them are the types, `Either`, `Try`, and a few more. You may refer to
    the Scala API documentation ([http://www.scala-lang.org/api/2.12.3/scala/util/Either.html](http://www.scala-lang.org/api/2.12.3/scala/util/Either.html))
    for more information about these types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll talk about one more functional construct. It's more than just a
    construct, it's a scheme of evaluation. Yes, we are talking about *lazy evaluation.*
    Scala allows you to use this scheme in more than one way. Let's talk about the
    `lazy` keyword.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Lazy declaration
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before learning more about the `lazy` keyword or lazy evaluation, let's talk
    about why we need it and exactly what it is. Just how beneficial lazy evaluation
    is can be explained with a few lines, or a few pages, but for our understanding
    let's have a one liner.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation** lets you write your code in a way where the order of evaluation
    doesn''t matter. It also saves you some time, by only evaluating expressions that
    you need. It''s like so many complex evaluations, that exists in your code, but
    never evaluation dues to a certain. The last line is only possible due to the
    concept of lazy evaluation. In Scala, you can declare a value as `lazy`. Let''s
    take an example. Try the following in the Scala REPL:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, when we assigned a value of `1` to our `val v`, the REPL gave us the `Int`
    type and the value as `<lazy>`, and for the `val z` we got `1`. Why this happened
    is because of the `lazy` declaration. In Scala, when you declare a value as lazy,
    the compiler evaluates the value only when we use it for the first time. With
    this, you free yourself from the worry of putting the `val` declaration in any
    order. Each `lazy` value is evaluated when it's needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: While we're talking about making our code optimized, let's look at another concept,
    *tail call optimization.* We first introduced *tail call optimization* in [Chapter
    3](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84), *Shaping Up our Scala
    Program* while discussing *recursion.* Let's talk about it in brief.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在讨论优化我们的代码时，让我们看看另一个概念，*尾递归优化*。我们首次介绍*尾递归优化*是在[第3章](part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84)，“塑造我们的Scala程序”中，讨论*递归*时。让我们简要地谈谈它。
- en: Tail call optimization
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归优化
- en: 'We are familiar with the limitations recursion brings with it. We are aware
    that each function call, if not tail recursive, builds a new stack frame. For
    scenarios where we have to deal with a large number of function calls, this could
    possibly result in a stack overflow, which is undesirable. So, what''s suggested
    in this kind of scenario is to make the recursive function call the last statement
    in your function definition, the Scala compiler then does the rest for you. Take
    a look at the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉递归带来的局限性。我们知道，如果函数调用不是尾递归，每次函数调用都会创建一个新的栈帧。对于必须处理大量函数调用的场景，这可能会导致栈溢出，这是我们不希望的。因此，在这种情况下建议的是，将递归函数调用作为你函数定义中的最后一个语句，然后Scala编译器会为你完成剩下的工作。看看下面的例子：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, if you take a closer look, you''ll see that wherever
    we made a recursive call, it''s the last statement in that particular scope. It
    means that our call to `someRecursiveMethod` is a last call and there was no other
    call after that. If it isn''t, the Scala compiler will alert you with a message
    saying the recursive call is not in the tail position:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果你仔细观察，你会发现我们每次进行递归调用时，它都是该特定作用域中的最后一个语句。这意味着我们对`someRecursiveMethod`的调用是最后一个调用，之后没有其他调用。如果不是这样，Scala编译器会通过一条消息提醒你，说递归调用不在尾递归位置：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, one thing to notice is that we''re helping out the Scala compiler by
    providing the annotation as `tailrec`. When we provide this annotation, the compiler
    considers your function as a tail recursive function. Evaluation of such a function
    does not create separate stack frames on each call, but uses the ones already
    created. This is how we avoid stack overflow and use recursion. What we''ve tried
    to do in our example is match to a list of names. Yes, you''re already familiar
    with the notion of pattern matching. If not `Nil`, we check for the name `Raven`
    in the list*,* and then we stop further calls. If you''re missing `break` or `continue`
    statements in Scala, this is the way that you can implement them: by using recursion
    and checking for the condition.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，需要注意的一点是，我们通过提供`tailrec`注解来帮助Scala编译器。当我们提供这个注解时，编译器会将你的函数视为尾递归函数。这种函数的评估不会在每个调用时创建新的栈帧，而是使用已经创建的栈帧。这就是我们避免栈溢出并使用递归的方式。在我们的例子中，我们尝试匹配一个名字列表。是的，你已经熟悉模式匹配的概念。如果不是`Nil`，我们会在列表中检查名字`Raven`，然后停止进一步的调用。如果你在Scala中缺少`break`或`continue`语句，这是你可以实现它们的方式：通过递归和检查条件。
- en: So this was all about tail call optimization. We've also seen that the Scala
    compiler helps us when we provide the annotation. Well, recursion helps you avoid
    mutability and at the same time achieve complex logic, adding to the already powerful
    functional programming. Since we are learning about functional programming constructs,
    it's really important for us to know that they are rooted in *eternal mathematics.*
    Mathematics created the notion of functional programming, and almost all functional
    programming concepts come from some mathematical proof or concept. One of them
    is a combinator. Learning about combinators or understanding how they are related
    to mathematics is beyond the scope of this book but we will look at a short introduction
    and see a simple example. It'll be fun. Let's go through *combinators.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是关于尾递归优化的一切。我们还看到，当提供注解时，Scala编译器会帮助我们。嗯，递归可以帮助你避免可变性，同时实现复杂的逻辑，这增加了已经强大的函数式编程。由于我们正在学习函数式编程结构，了解它们根植于*永恒的数学*是非常重要的。数学创造了函数式编程的概念，几乎所有函数式编程的概念都来自某些数学证明或概念。其中之一是组合子。了解组合子或理解它们如何与数学相关超出了本书的范围，但我们将简要介绍并查看一个简单的例子。这将会很有趣。让我们通过*组合子*来了解。
- en: Combinators
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合子
- en: 'Wikipedia says the following about **combinators**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科关于**组合子**的描述如下：
- en: '"A Combinator is a higher-order function that uses only function application
    and earlier defined Combinators to define a result from its arguments."'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as this definition, we could also say that a combinator is a closed
    *lambda* expression. We have already seen lambda applications in several places
    and defined them. A lambda is nothing more than an anonymous definition of any
    function. For example, when you pass an expression to our beloved `foreach` method,
    you pass it in the form of a lambda expression. Take a look at the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the `foreach` method takes a lambda expression and executes it. To be
    more precise, `(b: Brand)` contained in the brackets is an example of a lambda.
    Now, let''s ask some questions. What do lambdas have to do with combinators? Or
    let''s ask, what''s the working (functional) programmer''s definition of a combinator?
    Well, to answer these kinds of questions, we''ll use the first Wikipedia definition.
    If you take a closer look, there are a few things to notice. Firstly, it''s a
    higher-order function and secondly, it''s a closed lambda. Closed means it does
    not contain any *free* variables. For those of you who want to know what a free
    variable is, take a look at the following lambda:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, `y` is a free variable. We''ve seen these kinds of higher-order functions
    with no free variables before: our `map` and `filter` functions. These are called
    combinators. In functional programming, we tend to use these a lot. You can also
    use these as transformations to already available data. If we use these combinators
    together, they''re really helpful for forming data flow logic. This means, if
    you use `map`, `filter`, and `fold` as combinators together, you can create a
    domain logic out of your program. This way of writing programs is often used in
    functional programming. You''ll find more of these when you check out the written
    libraries. Various combinators are used for all sorts of collections and other
    data structures. The reason for using these combinators is that they provide an
    abstract or, in other words, a generalized approach to perform some operations.
    Hence they''re used everywhere. It''s easy and fun to implement some logic that
    looks like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's really a powerful construct and used a lot in functional programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about combinators, and are also aware of higher-order
    functions, you're equipped to solve programming problems. So what now? It's time
    to take the next step. We'll dive into the abstract (sea) levels of Scala programming.
    If we can make our solutions abstract, it means the solutions we provide should
    satisfy more than just one problem statement. Let's start with learning about
    t*ype parameterization.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Type parameterization
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an introduction to **type parameterization**, we'll refer to two examples
    we've already seen to try to make some sense of it. I know you're following the
    chapter with interest and you've gone through the examples and concepts we've
    talked about, so let's do an exercise. Think of our savior, `Option[T]` type and
    try to think why you would want to pass a type (as it requires `T` to be a type)
    to `Option`. What purpose can it serve?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'I think you''ve come up with some idea. Maybe you thought that by passing a
    type of our choice, we can make our code with the `Option` type work in more than
    one scenario. If you thought so, great! Let''s call it generalizing our solution.
    And moreover, let''s call the approach a generic approach to programming. How
    does it look? Let''s take a look at the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So as the code suggests, we have some optional strings, which can be of the
    `Int`, `String`, or `Boolean` type*.* Our intention was to convert them to their
    respective types. So we formed some functions, which take the optional string
    and then we convert them to their respective types, so we passed a function literal
    for that. If we can't think of a few counter cases, then it means it's working.
    However, the solution is bulky; it doesn't feel good. Plus, we can see that there's
    some repetitiveness in the code. We are doing an almost similar operation to `mapToXXX`,
    where we think of `XXX` as any type. It seems that we can generalize the solution.
    Let's think about it, how can we do this?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we tell the method about the types we are going to provide? One solution
    is to pass the types to the method as parameters and then use them in the declaration.
    Let''s try the solution and see what the code looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the generalization, we are able to perform the same logic with just one
    function. So, let''s take a look at the change and the way we gave type parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding `mapToValue` function, after giving the function name, that
    is, `mapToValue`, we gave `T` in braces as a type parameter. With this, we got
    the license to use this type parameter in the function declaration and definition.
    Hence, we used it as a type in a function literal and as return types. We''re
    allowed to give any number of type parameters based on the use. For example, if
    you want to make it more generalized, the function may look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this definition, we used two type parameters, `A` and `B`, and hence made
    our method more generalized. If you take a look at the `map` method from `Option[T]`,
    it looks like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have used type parameters in the function definition of `map`. So,
    according to this, for `Option[A]`, we have a `map` method, which takes a function
    from `A` type to `B` type. So the compiler will infer the `A` and `B` type when
    you give a call to this `map` method from the context.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This is just an introduction to type parameterization. In the next chapter,
    we'll get to see more of it along with some advanced concepts. With this, we can
    end our chapter, let's summarize what we've learned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave us insights into how we can implement logic with different
    flavors of implementation. We talked about for expressions and their translation
    into higher-order functions. We saw how *pattern matching* can make complex logic
    look very simple. We also talked about constructs such as `Option` and the `lazy`
    keyword. These enable us to write code that is meaningful and optimized. Then
    we discussed *tail call optimization*. We confronted *combinators*, and then finally
    we got an introduction to *type parameterization*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start from where we ended this chapter. We'll talk
    more about types, parameterized types, and variance relationships, and let me
    tell you, that will be fun.*
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
