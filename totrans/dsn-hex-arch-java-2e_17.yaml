- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Design Practices for Your Hexagonal Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While exploring the hexagonal architecture in this book, we learned about some
    of the principles and techniques that characterize a hexagonal application. By
    visualizing a system with clearly defined boundaries, we established three hexagons:
    Domain, Application, and Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Using these hexagons as a guide, we explored how to separate the business code
    from the technology code. This separation allowed us to explore ways of creating
    change-tolerant systems. But we did not stop there. Going the extra mile, we learned
    how the Quarkus framework could be used to turn a hexagonal application into a
    cloud-native application.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of this book equipped with the fundamental ideas needed
    to create hexagonal systems. In this chapter, we will explore some helpful design
    practices we can apply when creating robust hexagonal applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Domain-Driven Design** (**DDD**) to shape the Domain hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for creating ports and use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with multiple adapter categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion – the hexagonal journey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be aware of the design practices that can
    make your hexagonal architecture project more robust. These practices will also
    help you to decide when and how to employ the hexagonal architecture principles.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are both available for the **Linux**, **Mac**, and **Windows** operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter17)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Domain-Driven Design to shape the Domain hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When employing the hexagonal architecture to design a system’s code structure,
    we cannot stress enough how important it is to first implement the Domain hexagon.
    It’s the Domain hexagon that sets the tone for the development of the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: As long as you keep the code in the Domain hexagon that purely expresses the
    problem domain—the code that does not merge business concerns with technology
    ones—you are on the right path to ensuring the encapsulation level that favors
    a more change-tolerant design. The technique you’ll use to develop the Domain
    hexagon should not be your main concern at this stage—instead, your aim should
    be to create a Domain hexagon that is focused on the system’s purpose, rather
    than the technology you might use to implement it. So, you can develop the Domain
    hexagon using your own set of principles, or you can borrow ideas from others
    who have addressed a similar problem previously.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using DDD is that it means you don’t need to reinvent the wheel.
    Most—if not all—of the concepts and principles that you need to model your problem
    domain are well established in the rich body of knowledge present in DDD techniques.
    However, this does not mean you must follow all DDD principles to the letter.
    The recommended approach is to adopt and adapt the things you find helpful for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore some of the approaches you can follow when using DDD to
    design the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the business we are in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good application design reflects a good understanding of the business it is
    intended to serve. The design journey does not start in the code but by seeking
    business knowledge. I’m not telling you to become a business expert in the field
    you intend to build software for. However, I think it’s important to understand
    the fundamentals because if you don’t, mistakes made at the start of the design
    phase can cause irreversible damage that will extend through the software project.
  prefs: []
  type: TYPE_NORMAL
- en: In the best scenario, the project can survive these early mistakes, but not
    without paying the high cost of tangled and hard-to-maintain software. In the
    worst scenario, the result is unusable software, and starting a new project from
    scratch is the best thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the business fundamentals is the first thing we should do. The
    business details are important too, and we should pay close attention to them
    if we want to make top-notch software. But mistakes relating to details aren’t
    as serious as mistakes relating to fundamentals. The former is generally easier
    and cheaper to fix than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the topology and inventory system for a moment. We have a business
    rule stating that only edge routers from the same country can be connected to
    each other. We use the edge routers to handle regional traffic because they have
    less traffic capacity than core routers. The core routers can be located in different
    countries because they have more traffic capacity.
  prefs: []
  type: TYPE_NORMAL
- en: The whole domain model has been built based on these business premises. We compromise
    the entire system development if we fail to understand and translate these business
    premises into a cohesive domain model. Everything we build on top of such a model
    will be based on weak or wrong assumptions. That’s why we need to spend whatever
    time is necessary to grasp the business fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see some of the techniques we can use to build business knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Business Model Canvas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An excellent exercise to understand how the business works can be done with
    the Business Model Canvas technique. A **Business Model Canvas** is a tool for
    creating business models. It provides instruments to analyze and understand the
    main elements of a business. By providing a structured and simplified way to identify
    a business’s main aspects, the Business Model Canvas can be the starting point
    to draw the big picture you and your team need to understand the business fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: The tool’s main benefit is its focus on the key elements that are crucial for
    the profitability of a business. Another helpful aspect is how it represents customers
    and partners in the overall business landscape. This helps us to understand how
    well the business model is fulfilling the expectations of both customers and partners.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage is that it does not provide a deep and comprehensive view of
    how a business should operate to produce good results. Also, it does not touch
    on the business strategy. Much of its emphasis is on end results instead of long-term
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variation of—and an alternative to—the Business Model Canvas called
    the **Lean Canvas**, which is more directed toward start-ups. The main difference
    with this approach is that it focuses on the high uncertainty level that start-ups
    face when they try to develop new ideas and products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration of the Business Model Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – The Business Model Canvas](img/B19777_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – The Business Model Canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the preceding figure, the Business Model Canvas lets us structure
    each business aspect in distinct parts. This separation helps us to visualize
    the main elements comprising the business. Here are the elements of the Business
    Model Canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Key Partners** element represents our key partners and suppliers and contains
    information about the key resources or activities that are involved in that relationship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Key Activities**, we state the value propositions required for the key
    activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Key Resources**, we need to identify the value propositions required to
    enable the key resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Value Propositions**, we describe the elements of value we intend to deliver
    to the customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Customer Relationships** element is about the expectations of each customer
    segment in establishing and maintaining a relationship with us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Channels**, we identify the communication channels through which our customer
    segments will reach us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Customer Segments** element represents the groups of people we want to
    deliver value to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Cost Structure** element describes the highest costs involved in enabling
    the business model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Revenue Streams** element shows the value our customers are really willing
    to pay for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the Business Model Canvas, we also have the Event Storming technique
    as an alternative, which is geared more toward DDD projects. Let’s examine it
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Event storming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you do not find the Business Model Canvas a suitable approach, another technique
    called **event storming** can help you understand your business needs. Created
    by Alberto Brandolini, event storming uses colored sticky notes to map business
    elements into domain events, commands, actors, and aggregates. Each one of these
    sticky note elements has its own color, as shown in the following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – The Event Storming technique](img/B19777_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – The Event Storming technique
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, the sticky notes from event storming
    use the same terminology we encounter when dealing with DDD. That’s because event
    storming was created especially for those who use DDD and need to understand the
    business requirements for their project.
  prefs: []
  type: TYPE_NORMAL
- en: The event storming sessions should be conducted by developers, domain experts,
    and a facilitator who coordinates the session to ensure the mapping efforts go
    in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point of an event storming session is usually a challenging business
    process to model. In these sessions, it’s common to discuss how actors and their
    actions influence the business processes. Another central point is how external
    systems support and interact with the business processes. Risks and pain points
    are also essential subjects to map to identify business-critical areas. To learn
    more about event storming, check out its website at [https://www.eventstorming.com](https://www.eventstorming.com).
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand how the business works, we need to translate that knowledge
    into a domain model. In the next section, we’ll see how collaboration can help
    us to increase our knowledge about the business.
  prefs: []
  type: TYPE_NORMAL
- en: Promoting collaboration to increase knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The domain model is the outcome of people trying to understand the business
    and translating that understanding into code. In order to get the most out of
    this process, collaboration plays a vital role where the degree of complexity
    is high and things are hard to accomplish. To overcome this complexity, we need
    to establish a collaborative atmosphere where everyone involved in the project
    can contribute with relevant information that helps to build the big picture.
    The collaborative approach helps to ensure that everyone is on the same page regarding
    the problem domain, leading to a domain model that better reflects the business
    concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from using the code itself to capture and convey the problem domain knowledge,
    written documentation is another useful tool for collaboration. I’m not talking
    about writing long and comprehensive documentation – I mean the opposite. Let
    me explain.
  prefs: []
  type: TYPE_NORMAL
- en: Concise documentation that is focused on explaining the building blocks of a
    system can help people who aren’t acquainted with the code to make their first
    steps into understanding the system and, consequently, the problem domain. Sometimes,
    an introduction to the system’s main elements quickly leads to a comprehensive
    understanding of the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: What I’m saying may seem obvious, but very often, I’ve stumbled upon a complex
    code base with poor or no documentation at all. When the problem domain is complex,
    it’s natural for the code to be complex too. Without documentation to explain
    the basic system, what’s already complicated becomes even harder to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend allocating some time at the end of the project to write the system
    documentation. New joiners, in particular, will benefit from a friendly document
    providing an overview of the system’s big picture.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how important it is to have a solid foundation based on an
    understanding of the business requirements and have discussed the value of collaboration
    in increasing our knowledge of the problem domain, let’s explore some of the DDD
    techniques to adopt when building the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Applying DDD techniques to build the Domain hexagon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll explore some design practices to help us establish clear
    boundaries in the hexagonal system. Complementing what we saw in [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038),
    *Wrapping Business Rules inside Domain Hexagon*, we’ll see the importance of creating
    subdomains, searching for a ubiquitous language, and defining bounded contexts
    to distinguish the different aspects of the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Subdomains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of a **subdomain** is to group the elements that support the core
    domain but cannot be considered elements that express the core domain. These supporting
    elements are essential for the activities conducted by the core domain. Without
    the supporting elements, the core domain cannot work. There are also generic subdomains
    whose purpose is to provide additional capabilities to both core domains and supporting
    subdomains. A generic subdomain works as a standalone component that doesn’t depend
    on things provided by other domains.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that we have primary activities in the core domain. And in the subdomain,
    we have secondary activities that enable the primary ones. If we blend primary
    and secondary activities, we’ll end up with a domain model with mixed concerns.
    It may not be a big deal for smaller systems, but in larger ones, it can add a
    considerable complexity that can undermine the productivity of anyone trying to
    understand the system. That’s why it’s a good approach to break a domain into
    subdomains. We’ll always have a core domain concentrating on the most important
    part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a banking system as an example to explore the subdomain idea further.
    In such a system, it’s possible to identify the following domains:'
  prefs: []
  type: TYPE_NORMAL
- en: As a core domain, we have **Transactions** that allow users to receive and send
    money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As supporting subdomains, we may have **Loans** and **Insurances** that add
    more capabilities to the system but rely on the **Transactions** core domain to
    enable such capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have **Authentication** as a generic subdomain, serving both the
    core domain and supporting subdomains that require every transaction to be authenticated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how subdomains relate to the core domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Banking system subdomains](img/B19777_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – Banking system subdomains
  prefs: []
  type: TYPE_NORMAL
- en: The **Transactions** core domain contains the system’s building block elements.
    These elements are also present in the **Loans** and **Insurances** subdomains,
    but for different purposes. The generic **Authentication** subdomain knows nothing
    about the other domains. It only provides an authentication mechanism that is
    shared across the core domain and supporting subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of DDD’s touchstones is its emphasis on how we use language to describe
    a domain model. This emphasis aims to avoid the pitfall of ambiguities in our
    general communication seeping into the system code we want to create.
  prefs: []
  type: TYPE_NORMAL
- en: As human beings, we have much more capacity than computers to handle ambiguities
    in language because we can add context to our words. Computers, on the other hand,
    don’t have this ability unless we provide it for them. In order to decrease the
    ambiguity level of a system, a ubiquitous language seeks precise terminology to
    describe the things that comprise the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining precise terminology, however, is not enough to ensure that we’ll always
    convey the right meaning in the domain model, as similar words may have a different
    meaning depending on the context in which they are used. That’s why there’s another
    technique in DDD called bounded context that we can use to deal with differences
    in meaning within a domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **bounded context** idea is a response to the fact that words have a different
    meaning depending on the context in which they are used. When we bring this idea
    to DDD, we may find that a domain model element can have a different meaning or
    behave differently depending on the context where it’s applied. If we do not actively
    take action to explicitly define a context to clarify the meaning of such a domain
    model element, we are contributing to the ambiguity within the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the topology and inventory system. Suppose that other than
    inventory capabilities, we want to allow the system to get a real-time status
    and basic information from routers and other network equipment. This new feature
    could result in two contexts: one for inventory and the other for status.'
  prefs: []
  type: TYPE_NORMAL
- en: From the inventory perspective, a router means a static record in a database.
    On the other hand, from the status perspective, a router is a *living* thing that
    issues real-time data. By expressing this distinction in the form of a bounded
    context, we ensure that our understanding of one context does not blur with another.
    More than that, by structuring the code within the clear boundaries that a bounded
    context can provide, we’re creating a system that can evolve and receive changes
    in a more organized way. Also, we are enforcing the Single Responsibility Principle
    at the level of modules. This means a module should change only for a single reason
    and not multiple reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The DDD techniques discussed in this session don’t offer much value if we don’t
    first grasp our business needs. That’s why we started by exploring some of the
    techniques we can use to enhance our understanding of the business model. Once
    we know about the business we’re in, we can safely employ the DDD techniques (such
    as subdomains and bounded contexts) to establish boundaries between different
    system components and remove ambiguities within the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see how we can implement bounded contexts and subdomains in a hexagonal
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing bounded contexts and subdomains in a hexagonal system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our approach to implementing a bounded context relies on the creation of a subdomain.
    Here, we discuss both bounded contexts and subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bounded contexts can exist with or without a subdomain. We’ve already seen
    that the topology and inventory system can check the status of network equipment.
    Suppose we determine that the status element is an integral and critical characteristic
    of the problem domain. In that case, we can make the status element part of the
    core domain instead of putting it into a supporting subdomain. But we’d still
    need to deal with the ambiguity of having domain elements serving different purposes.
    To solve this problem, we’d have to establish two bounded contexts within the
    core domain: one bounded context for inventory and another for status.'
  prefs: []
  type: TYPE_NORMAL
- en: If we decide that the status element is not a part of the core domain, we can
    model it as a subdomain, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing the topology and inventory system, we placed a single domain
    model inside the Domain hexagon. This domain model meets the business requirements
    related to the inventory management of network assets. Consider the scenario where
    the topology and inventory system can access network equipment to check its status.
    To avoid mixing concerns between inventory management and status information,
    we’ll break the **Domain Hexagon** into two domain models. The first one is a
    **Core Domain** serving inventory management needs. The second domain model is
    a **Subdomain** for status information needs. The following diagram shows the
    representation of the new **Domain Hexagon**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The Domain Hexagon](img/B19777_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The Domain Hexagon
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **Domain Hexagon**, we now have the **Inventory Core Domain** and
    the **Status Subdomain**. In the following steps, we’ll configure the Domain hexagon
    module to reflect the new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project’s root `pom.xml` file, we add the new Maven `modules` element,
    which represents the core domain and subdomains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note, we added the `domain/inventory-core-domain` and `domain/status-sub-domain`
    Maven modules in the `pom.xml` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before proceeding, please ensure to move all the files from `domain/src/main/java`
    to `domain/inventory-core-domain/src/main/java`. The `domain` Maven module will
    be used as a parent project to aggregate both the core domain and subdomain projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the `pom.xml` file from the `domain` Maven module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `domain` Maven module depends on `inventory-core-domain` and `status-sub-domain`.
    We kept the `domain` module but broke it into two parts. With this approach, there
    will be no need to change anything in the Application and Framework hexagons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to reconfigure the `module-info.java` module descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `transitive` keyword is necessary to ensure the exports from `inventory_core_domain`
    and `status_sub_domain` are visible for other modules depending on the `domain`
    module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we configure the `pom.xml` file for the `inventory-core-domain` Maven
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding example is a straightforward `pom.xml` file containing only the
    `artifactId` and the `parent` coordinates. In addition to `pom.xml`, we need to
    provide a `module-info.java` file, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This Java module provides better encapsulation for the inventory core domain.
    Note that we’re also exporting the `entity`, `service`, `specification`, and `vo`
    packages. They are all part of the core domain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we configure the `pom.xml` file of the `status-sub-domain` Maven module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We declare a dependency on the `inventory-core-domain` Maven module because
    we use the same entities present in the core domain to provide status information
    capabilities in the `status-sub-domain` subdomain Maven module. The difference,
    though, is that the same entity, in the same way as `Router`, can have a different
    meaning (and also a data model) when we are in the status information context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish, we need to configure the `module-info.java` file for `status_sub_domain`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re exporting only one package and declaring that this module depends on `inventory_core_domain`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the Maven and Java modules properly configured to help us enforce
    the boundaries between the core domain and subdomain, let’s explore the use of
    a bounded context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s consider that the topology and inventory system can now check the status
    of a router. To isolate this behavior and establish a context for such activities,
    we will create a class called `RouterInfo` in the subdomain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `RouterInfo` class, we have a dummy method called `getRouterStatus`,
    which is just to illustrate that the `Router` entity can assume a different behavior
    and data model in the context of status information. It’s very simple to make
    this subdomain feature available for the Application and Framework hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that to see how the subdomain fits into the overall hexagonal system
    by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding a new method definition in `RouterManagementUseCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getRouterStatus` method integrates with the subdomain to retrieve the router
    status.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we implement `getRouterStatus` in `RouterManagementInputPort`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are getting an instance of the `RouterInfo` object from the subdomain
    and calling the `getRouterStatus` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we implement the endpoint in `RouterManagementAdapter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are using the RESTEasy Reactive to implement the `/get-router-status`
    endpoint that will get the router status information from the subdomain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding `curl` command gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of DDD elements such as subdomains and bounded contexts
    helps us understand how we can integrate these elements with the hexagonal architecture.
    Using Maven and Java modules, we can emphasize the boundaries between the core
    domain and subdomain even more.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s shift our attention to the Application hexagon, which is the realm
    of ports and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The need for creating ports and use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After putting some effort into modeling the problem domain in the Domain hexagon,
    the next step is to move on to the Application hexagon and define how the system
    enables the behaviors that fulfills the business-related operations that come
    from the Domain hexagon. Actors—who could be both users and other systems—drive
    these behaviors. They dictate the system’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The moment when we start implementing the Application hexagon is crucial because
    we begin to think in aspects that are not directly related to the domain model.
    Instead, these aspects may be related to integrations for communicating with other
    systems. But we shouldn’t go so far as to decide which technologies to use. We
    don’t take decisions related to technology when implementing the Application hexagon.
    Rather, technology concerns are a subject that we go deep into in the Framework
    hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: We employ use cases to define what a system can do to meet actors’ needs. Without
    considering specific technical details, we can state that a good moment to create
    a use case is when we need to express an actor’s intent on the system. The actor’s
    intent plays a fundamental role in shaping the system’s behaviors. By employing
    use cases, we can describe such behaviors. Input ports come next by defining how
    the system will actually accomplish the actor’s goals. Input ports can be implemented
    right away or be implemented later. However, they must be implemented before you
    decide to move on to the Framework hexagon. If you choose to implement the Framework
    hexagon before implementing input ports, there will be no way to make the Framework
    hexagon communicate with the Application hexagon. In other words, use cases and
    ports are the bridge between both hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: There is not much to be concerned about when it comes to output ports because
    they are interfaces implemented by output adapters in the Framework hexagon. Output
    adapters, in their turn, can pose some problems if we have multiple categories
    of them. Next, we’ll assess some of the consequences of having multiple adapter
    categories.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with multiple adapter categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of the hexagonal architecture, adapters help us to increase the
    hexagonal system’s compatibility with different protocols and technology. In the
    Framework hexagon, we finally decide how the system will expose its features through
    input adapters and how it will communicate with external systems through output
    adapters.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way to what happens in the Application and Domain hexagons, the
    Framework hexagon is encapsulated in its own Java module. This module approach
    helps us enforce the boundaries between each system hexagon. From the Framework
    hexagon’s perspective, it’s good to group all input and output adapters within
    the same module. Although modularization can help us set boundaries, it is not
    enough to prevent the maintainability challenges we may face when dealing with
    multiple adapter categories.
  prefs: []
  type: TYPE_NORMAL
- en: What I mean by adapter category is a classification to group adapters that enable
    the integration with a specific technology. For example, in the topology and inventory
    system, we have the `RouterManagementAdapter` and `SwitchManagementAdapter` input
    adapters. These adapters expose HTTP RESTful endpoints. So, these input adapters
    comprise the adapter category that provides HTTP support for the hexagonal system.
    If we want to enable integration with another technology, for example, gRPC, we
    need to create a new set of adapters in an adapter category that supports exposing
    gRPC endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with input adapters, we don’t face a significant maintainability
    burden by having multiple adapter categories providing support to different technologies
    in the hexagonal system. However, some issues may arise if we have multiple adapter
    categories for output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: With output adapters, we can integrate the hexagonal application with external
    systems. But it’s important to pay attention where we need to provide translation
    mechanisms for every new integration. These translations help us to map data coming
    in and going out through output adapters. If adapter categories for output adapters
    grow too large, it can potentially create a maintainability problem. In that scenario,
    we would need to keep multiple translation mechanisms for every adapter category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario. Imagine a system that started out with all
    of its data being served by a database. As the main system evolved, the developers
    migrated its parts into smaller subsystems to prevent the main system from becoming
    too big. But during this migration process, certain use cases could not be fully
    migrated to the new subsystems, resulting in a situation where the main system
    still needed to fetch data from both the database and the subsystems in order
    to fulfill some of its business rules. In this circumstance, the main system requires
    two output adapters: one for the database and another for the subsystem. Allowing
    two output adapters to serve the same purpose due to an unfinished migration can
    potentially increase the maintenance cost. One of the main problems of this approach
    is the need to translate the domain model data, which comes from the database
    and the subsystem.'
  prefs: []
  type: TYPE_NORMAL
- en: So, for input adapters, we have a low risk when employing multiple adapter categories.
    However, the same cannot be said about output adapters. The recommendation here
    is to be aware of the trade-off in having to maintain several translation mechanisms
    for multiple output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion – the hexagonal journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fascinating things about software development is that we can employ
    many methods to achieve the same result. This freedom adds to the fun of software
    development and fosters creativity. Creativity is the main force behind clever
    solutions for complex problems. That’s why we should always leave space for creativity
    in any software project. But when combined with tight schedules and resources,
    freedom and creativity should be managed to produce valuable software without
    adding unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: I see the hexagonal architecture as an approach that can help us manage these
    different requirements. It provides a clear set of principles to organize system
    code within flexible yet consistent boundaries. The hexagonal approach offers
    a model to direct our creative efforts in an organized and – to a certain extent
    – standardized way.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture is not for everyone, nor is it suitable for every
    project. However, people seeking ways to standardize their software development
    practices will find the hexagonal architecture to be a useful blueprint to scaffold
    their next software project. Nevertheless, it’s important to understand the considerable
    complexity involved in structuring a system using hexagonal principles. If the
    project is for a medium or large, long-term, and highly mutable system, I believe
    the hexagonal architecture is an excellent choice to ensure the system’s maintainability
    in the long run. On the other hand, if we’re talking about small applications
    responsible for, let’s say, one or two things, then using the hexagonal architecture
    would be like using a gun to kill an ant. So, you need to carefully assess the
    scenario to check if the hexagonal architecture will bring more solutions than
    problems to your project.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture is not a silver bullet that will magically solve
    your technical debt and maintainability issues. These problems have more to do
    with your attitude to keep things simple than with the software architecture you
    choose to structure your application. But the hexagonal architecture can help
    you tackle those issues if you’re already committed to an attitude to keep things
    simple and easy to understand no matter how complex the problem domain you’re
    dealing with is. I encourage you to keep a simple attitude and explore and extend
    the hexagonal architecture ideas. For me, it’s been an unending learning and rewarding
    experience to design hexagonal systems. I wish the same to you.
  prefs: []
  type: TYPE_NORMAL
- en: Let me finish this book by sincerely thanking you for accompanying me on this
    hexagonal journey.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by exploring some ideas relating to DDD, and we discussed
    the importance of understanding our business needs before jumping straight to
    development. We also learned about the Business Model Canvas and event storming.
  prefs: []
  type: TYPE_NORMAL
- en: While on the topic of DDD, we learned how subdomains and bounded contexts are
    essential to help establish clear boundaries within the Domain hexagon. After
    that, we discussed use cases and ports. We learned that it’s essential to implement
    input ports before starting to build the Framework hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about the maintainability consequences of having multiple adapter
    categories, mainly when dealing with output adapters that require translation
    mechanisms. Finally, we ended the book by reflecting on our hexagonal journey
    and the importance of keeping software development simple.
  prefs: []
  type: TYPE_NORMAL
- en: When using Quarkus, especially the native image feature, we need to consider
    the large amount of memory and time required to build a native executable. If
    your CI environment is constrained, you may face problems caused by insufficient
    computational resources. Also, bear in mind that compilation time considerably
    increases when compiling native images. If your priority is faster compilation
    rather than a more rapid system startup, you may have to reconsider using native
    images. I always recommend checking the Quarkus documentation and the Quarkus
    community through the official mailing list and other channels. This can help
    you learn more about Quarkus and stay updated on common issues and how to solve
    them. If the community help is not enough, you can seek Quarkus’ official support
    provided by Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture provides us with the principles to develop robust
    and change-tolerant systems. Quarkus is a cutting-edge technology that we can
    use to apply hexagonal principles to create modern, cloud-native applications.
    By combining hexagonal architecture with Quarkus, we can produce fantastic software.
    I encourage you to experiment and further explore the possibilities of such a
    fascinating combination. The hexagonal journey of this book ends here, but you
    guys can start a new one by applying, tweaking, and evolving the ideas I have
    presented to you.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What techniques can we use to understand our business needs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we employ subdomains and bounded contexts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to define use cases and create input ports before implementing
    the Framework hexagon?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the consequences of having multiple adapter categories for output adapters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Business Model Canvas and event storming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subdomains and bounded contexts help us establish clear boundaries to prevent
    mixing the meaning and concerns of the entities in a domain model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because use cases and input ports are the bridge between the Framework and Application
    hexagons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can lead to several translation mechanisms that may be hard to maintain if
    we have too many of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
