<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-103"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-104"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.2.1">Object Relational Mapping with Jakarta Persistence</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Jakarta EE applications frequently need to persist data in a relational database. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will cover how to connect to</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.4.1"> a database and</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.5.1"> perform </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">CRUD</span></strong><span class="koboSpan" id="kobo.9.1">)</span><strong class="bold"><span class="koboSpan" id="kobo.10.1"> operations </span></strong><span class="koboSpan" id="kobo.11.1">via </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.12.1">Jakarta Persistence</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Jakarta Persistence is the standard Jakarta EE </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">Object Relational Mapping</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.17.1">ORM</span></strong><span class="koboSpan" id="kobo.18.1">) tool. </span><span class="koboSpan" id="kobo.18.2">We will discuss </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.19.1">this API in detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">The following are the topics covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">CUSTOMERDB database</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Jakarta Persistence</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Persisting data with </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Jakarta Persistence</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Entity relationships</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Composite </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">primary keys</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Jakarta Persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Query Language</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Criteria API</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Bean </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Validation support</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.37.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.38.1">The source code used in this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.42.1">The CUSTOMERDB database</span></h1>
<p><span class="koboSpan" id="kobo.43.1">Our examples </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.44.1">in this chapter use a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">CUSTOMERDB</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">This database contains tables to track customers and order information for a fictitious store. </span><span class="koboSpan" id="kobo.46.3">For simplicity, the database uses an in-memory </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">H2 database.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">A simple utility that automatically starts the database and populates all reference tables is included with this book’s example code. </span><span class="koboSpan" id="kobo.48.2">The utility can be found under </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">ch08_src/customerdb</span></strong><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">It is a Maven application. </span><span class="koboSpan" id="kobo.50.3">Therefore, it can be built from the command line via </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">mvn install</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">It creates an executable JAR file with all dependencies included. </span><span class="koboSpan" id="kobo.52.3">The created JAR file can be found under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">target</span></strong><span class="koboSpan" id="kobo.54.1"> directory, it can be run from the command line by issuing the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.56.1">
java -jar customerdb-jar-with-dependencies.jar</span></pre> <p><span class="koboSpan" id="kobo.57.1">The schema for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">CUSTOMERDB</span></strong><span class="koboSpan" id="kobo.59.1"> database is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.63.1"><img alt="Figure 8.1 – CUSTOMERDB database schema (The intend of this schema is to show the layout; the readability of the text in the boxes, under the headings, is not essential.)" src="image/B21231_8_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.64.1">Figure 8.1 – CUSTOMERDB database schema (The intent of this schema is to show the layout; the readability of the text in the boxes, under the headings, is not essential.)</span></p>
<p><span class="koboSpan" id="kobo.65.1">As can be seen in the </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.66.1">diagram, the database contains tables to store customer information including their names, addresses, and email addresses. </span><span class="koboSpan" id="kobo.66.2">It also contains tables to store order and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">item information.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ADDRESS_TYPES</span></strong><span class="koboSpan" id="kobo.70.1"> table stores values such as “Home”, “Mailing” and “Shipping”, to distinguish the type of address in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">ADDRESSES</span></strong><span class="koboSpan" id="kobo.72.1"> table; similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">TELEPHONE_TYPES</span></strong><span class="koboSpan" id="kobo.74.1"> table stores the values “Cell”, “Home”, and “Work”. </span><span class="koboSpan" id="kobo.74.2">These two tables are prepopulated when creating the database, as well as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">US_STATES</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.76.1"> table.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.77.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.78.1">For simplicity, our database only deals with </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">U.S. </span><span class="koboSpan" id="kobo.79.2">addresses.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.80.1">Configuring Jakarta Persistence</span></h1>
<p><span class="koboSpan" id="kobo.81.1">Jakarta Persistence requires a bit </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.82.1">of configuration before our code can work properly. </span><span class="koboSpan" id="kobo.82.2">A data source needs to be defined. </span><span class="koboSpan" id="kobo.82.3">The data source specifies information on how to reach the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Relational Database Management System</span></strong><span class="koboSpan" id="kobo.84.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.85.1">RDBMS</span></strong><span class="koboSpan" id="kobo.86.1">) system</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.87.1"> we are connecting to (server, port, database user credentials, etc.). </span><span class="koboSpan" id="kobo.87.2">There are two ways it can be set up. </span><span class="koboSpan" id="kobo.87.3">It can be done via the Jakarta EE implementation configuration, but how to do this is dependent on the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">specific implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">It can also be done by annotating an application-scoped CDI bean via the @</span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">DataSourceDefinition annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">There are advantages and disadvantages to each approach. </span><span class="koboSpan" id="kobo.91.2">Defining the data source as part of the Jakarta EE runtime configuration allows us to deploy our code to different environments (development, test, production) without having to make any modifications to our code. </span><span class="koboSpan" id="kobo.91.3">It also prevents adding any user credentials to our source. </span><span class="koboSpan" id="kobo.91.4">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.93.1"> works across Jakarta EE implementations, and allows us to test and deploy our code without having to configure our Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">EE runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">For simplicity, our examples use </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.97.1">, but for production code, configuring the Jakarta EE implementation is probably a </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">better idea.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Typically, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.101.1"> in an application-scoped CDI bean, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
package com.ensode.jakartaeebook.beanvalidation.init;
//imports omitted for brevity
@ApplicationScoped
</span><strong class="bold"><span class="koboSpan" id="kobo.104.1">@DataSourceDefinition(name =</span></strong><span class="koboSpan" id="kobo.105.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">"java:app/jdbc/customerdbDatasource",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.107.1">  className = "org.h2.jdbcx.JdbcDataSource",</span></strong><span class="koboSpan" id="kobo.108.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">url = "jdbc:h2:tcp://127.0.1.1:9092/mem:customerdb",</span></strong><span class="koboSpan" id="kobo.110.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">user = "sa",</span></strong><span class="koboSpan" id="kobo.112.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">password = "")</span></strong><span class="koboSpan" id="kobo.114.1">
public class DbInitializer {
  private void init(@Observes @Initialized(ApplicationScoped.class) Object object) {
    //This method will be invoked when the CDI application scope is initialized, during deployment
    //No logic necessary, class level @DataSourceDefinition will create a data source to be used by the application.
</span><span class="koboSpan" id="kobo.114.2">  }
}</span></pre> <p><span class="koboSpan" id="kobo.115.1">The value of </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.116.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">name</span></strong><span class="koboSpan" id="kobo.118.1"> attribute in </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.120.1"> defines the JNDI name or our data source. </span><span class="koboSpan" id="kobo.120.2">The value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">url</span></strong><span class="koboSpan" id="kobo.122.1"> attribute of </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.124.1"> defines the </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Java Database Connectivity</span></strong><span class="koboSpan" id="kobo.126.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">JDBC</span></strong><span class="koboSpan" id="kobo.128.1">) URL of </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.129.1">our relational database, the exact format of the JDBC URL depends on the RDBMS we are using. </span><span class="koboSpan" id="kobo.129.2">For our examples, we are using an in-memory H2 database. </span><span class="koboSpan" id="kobo.129.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">user</span></strong><span class="koboSpan" id="kobo.131.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">password</span></strong><span class="koboSpan" id="kobo.133.1"> attributes of </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.135.1"> define the user credentials needed to log in to </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">our database.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Once a data source has been defined, an XML configuration file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.139.1"> must be deployed in the WAR file containing the aforementioned bean. </span><span class="koboSpan" id="kobo.139.2">This file must be placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">WEB-INF/classes/META-INF/</span></strong><span class="koboSpan" id="kobo.141.1"> directory inside the WAR file. </span><span class="koboSpan" id="kobo.141.2">An example </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.143.1"> configuration file is </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="3.0" 
         
         xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
           https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">&lt;persistence-unit name="customerPersistenceUnit"&gt;</span></strong><span class="koboSpan" id="kobo.147.1">
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;jta-data-source&gt;java:app/jdbc/customerdbDatasource&lt;/jta-data-source&gt;
    &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">&lt;/persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.149.1">
&lt;/persistence&gt;</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.151.1"> must </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.152.1">contain at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.154.1"> element. </span><span class="koboSpan" id="kobo.154.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.156.1"> element must provide a value for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">name</span></strong><span class="koboSpan" id="kobo.158.1"> attribute and must contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">&lt;jta-data-source&gt;</span></strong><span class="koboSpan" id="kobo.160.1"> child element whose value is the JNDI name of the data source to be used for the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">persistence unit.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">&lt;jta-data-source&gt;</span></strong><span class="koboSpan" id="kobo.164.1"> tag must come from a data source configured in our Jakarta EE implementation. </span><span class="koboSpan" id="kobo.164.2">Notice that in our example, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">&lt;jta-data-source&gt;</span></strong><span class="koboSpan" id="kobo.166.1"> tag matches the value of the name attribute in the data source we defined </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">@DataSourceDefinition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">The value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">&lt;provider&gt;</span></strong><span class="koboSpan" id="kobo.172.1"> tag must be an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">jakarta.persistence.spi.PersistenceProvider</span></strong><span class="koboSpan" id="kobo.174.1"> interface. </span><span class="koboSpan" id="kobo.174.2">The exact value depends on the Jakarta Persistence implementation being used. </span><span class="koboSpan" id="kobo.174.3">In our example, we are using GlassFish as our Jakarta EE implementation, which includes EclipseLink as its Jakarta Persistence implementation. </span><span class="koboSpan" id="kobo.174.4">Therefore, we use the EclipseLink-provided </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">PersistenceProvider implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">The reason more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.178.1"> element is allowed is because an application may access more than one database. </span><span class="koboSpan" id="kobo.178.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.180.1"> element is required for each database the application will access. </span><span class="koboSpan" id="kobo.180.2">If the application defines more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.182.1"> element, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">@PersistenceContext</span></strong><span class="koboSpan" id="kobo.184.1"> annotation used to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">EntityManager</span></strong><span class="koboSpan" id="kobo.186.1"> must provide a value for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">unitName</span></strong><span class="koboSpan" id="kobo.188.1"> element. </span><span class="koboSpan" id="kobo.188.2">The value for this element must match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">name</span></strong><span class="koboSpan" id="kobo.190.1"> attribute of the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.192.1"> element </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">persistence.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">If our </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">persistence.xml</span></strong><span class="koboSpan" id="kobo.198.1"> configuration class defines more than one persistence unit, we need to list the Jakarta Persistence entities managed by that persistence unit via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">&lt;class&gt;</span></strong><span class="koboSpan" id="kobo.200.1"> tag inside each </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.202.1"> tag. </span><span class="koboSpan" id="kobo.202.2">Listing each Jakarta EE entity inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">&lt;persistence-unit&gt;</span></strong><span class="koboSpan" id="kobo.204.1"> is a tedious task, but thankfully, most projects define a single persistence unit. </span><span class="koboSpan" id="kobo.204.2">We</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.205.1"> can avoid listing each and every Jakarta Persistence entity by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">&lt;exclude-unlisted-classes&gt;</span></strong><span class="koboSpan" id="kobo.207.1"> tag with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">false</span></strong><span class="koboSpan" id="kobo.209.1">, as illustrated in </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">our example.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.211.1">Persisting data with Jakarta Persistence</span></h1>
<p><span class="koboSpan" id="kobo.212.1">Jakarta Persistence</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.213.1"> is used to persist data to an RDBMS. </span><span class="koboSpan" id="kobo.213.2">Jakarta </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.214.1">Persistence Entities are regular Java classes; the Jakarta EE runtime knows these classes are Entities because they are decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">@Entity</span></strong><span class="koboSpan" id="kobo.216.1"> annotation. </span><span class="koboSpan" id="kobo.216.2">Let’s look at a Jakarta Persistence Entity mapping to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">CUSTOMER</span></strong><span class="koboSpan" id="kobo.218.1"> table in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">CUSTOMERDB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
package com.ensode.jakartaeebook.persistenceintro.entity
//imports omitted for brevity
</span><strong class="bold"><span class="koboSpan" id="kobo.222.1">@Entity</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.223.1">@Table(name = "CUSTOMERS")</span></strong><span class="koboSpan" id="kobo.224.1">
public class Customer implements Serializable {
  </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">@Id</span></strong><span class="koboSpan" id="kobo.226.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">@Column(name = "CUSTOMER_ID")</span></strong><span class="koboSpan" id="kobo.228.1">
  private Long customerId;
  </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">@Column(name = "FIRST_NAME")</span></strong><span class="koboSpan" id="kobo.230.1">
  private String firstName;
  </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">@Column(name = "LAST_NAME")</span></strong><span class="koboSpan" id="kobo.232.1">
  private String lastName;
  private String email;
  //getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">In our example code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">@Entity</span></strong><span class="koboSpan" id="kobo.235.1"> annotation lets any other Jakarta EE-compliant runtime know that this class is a Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">Persistence entity.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">@Table(name = "CUSTOMERS")</span></strong><span class="koboSpan" id="kobo.239.1"> annotation lets the application server know what table to</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.240.1"> map the entity to. </span><span class="koboSpan" id="kobo.240.2">The value of the name</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.241.1"> element contains the name of the database table that the entity maps to. </span><span class="koboSpan" id="kobo.241.2">This annotation is optional. </span><span class="koboSpan" id="kobo.241.3">If the name of the class maps the name of the database table (case insensitive), then it isn’t necessary to specify what table the entity </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">maps to.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">@Id</span></strong><span class="koboSpan" id="kobo.245.1"> annotation indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">customerId</span></strong><span class="koboSpan" id="kobo.247.1"> field maps to the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">primary key.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">@Column</span></strong><span class="koboSpan" id="kobo.251.1"> annotation maps each field to a column in the table. </span><span class="koboSpan" id="kobo.251.2">If the name of the field matches the name of the database column, then this annotation is not needed. </span><span class="koboSpan" id="kobo.251.3">This is the reason why the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">email</span></strong><span class="koboSpan" id="kobo.253.1"> field is </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">not annotated.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">EntityManager</span></strong><span class="koboSpan" id="kobo.257.1"> interface </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.258.1">is used to persist entities to a database. </span><span class="koboSpan" id="kobo.258.2">The following example illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">its usage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
package com.ensode.jakartaeebook.persistenceintro.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class JakartaPersistenceDemoBean {
  </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">@PersistenceContext</span></strong><span class="koboSpan" id="kobo.262.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">private EntityManager entityManager;</span></strong><span class="koboSpan" id="kobo.264.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">@Resource</span></strong><span class="koboSpan" id="kobo.266.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">private UserTransaction userTransaction;</span></strong><span class="koboSpan" id="kobo.268.1">
  public String updateDatabase() {
    String retVal = "confirmation";
    Customer customer = new Customer();
    Customer customer2 = new Customer();
    Customer customer3;
    customer.setCustomerId(3L);
    customer.setFirstName("James");
    customer.setLastName("McKenzie");
    customer.setEmail("jamesm@example.com");
    customer2.setCustomerId(4L);
    customer2.setFirstName("Charles");
    customer2.setLastName("Jonson");
    customer2.setEmail("cjohnson@example.org");
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">userTransaction.begin();</span></strong><span class="koboSpan" id="kobo.270.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">entityManager.persist(customer);</span></strong><span class="koboSpan" id="kobo.272.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">entityManager.persist(customer2);</span></strong><span class="koboSpan" id="kobo.274.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">customer3 = entityManager.find(Customer.class, 4L);</span></strong><span class="koboSpan" id="kobo.276.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">customer3.setLastName("Johnson");</span></strong><span class="koboSpan" id="kobo.278.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">entityManager.persist(customer3);</span></strong><span class="koboSpan" id="kobo.280.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">entityManager.remove(customer);</span></strong><span class="koboSpan" id="kobo.282.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">userTransaction.commit();</span></strong><span class="koboSpan" id="kobo.284.1">
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.285.1">Our example CDI named bean obtains an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">jakarta.persistence.EntityManager</span></strong><span class="koboSpan" id="kobo.287.1"> interface via dependency injection. </span><span class="koboSpan" id="kobo.287.2">This is done by decorating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">EntityManager</span></strong><span class="koboSpan" id="kobo.289.1"> variable with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">PersistenceContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">An instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">jakarta.transaction.UserTransaction</span></strong><span class="koboSpan" id="kobo.295.1"> interface is then injected via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">@Resource</span></strong><span class="koboSpan" id="kobo.297.1"> annotation. </span><span class="koboSpan" id="kobo.297.2">This object is necessary, as without it, invoking calls to persist Entities to the database the code would throw </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">jakarta.persistence.TransactionRequiredException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">EntityManager</span></strong><span class="koboSpan" id="kobo.302.1"> instances perform many database-related tasks including finding entities in the database, updating them, and </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">deleting them.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Since Jakarta</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.305.1"> Persistence </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.306.1">entities are </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">plain old Java objects</span></strong><span class="koboSpan" id="kobo.308.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.309.1">POJOs</span></strong><span class="koboSpan" id="kobo.310.1">), they </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.311.1">can be instantiated via the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">new operator.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">persist()</span></strong><span class="koboSpan" id="kobo.315.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">EntityManager</span></strong><span class="koboSpan" id="kobo.317.1"> must be in a transaction, therefore it is necessary to start one by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">begin()</span></strong><span class="koboSpan" id="kobo.319.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">UserTransaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">We then insert two new rows into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.325.1"> table by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">persist()</span></strong><span class="koboSpan" id="kobo.327.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">EntityManager</span></strong><span class="koboSpan" id="kobo.329.1"> for the two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Customer</span></strong><span class="koboSpan" id="kobo.331.1"> class we populated earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">After persisting the data contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">customer</span></strong><span class="koboSpan" id="kobo.335.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">customer2</span></strong><span class="koboSpan" id="kobo.337.1"> objects, we search the database for a row in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.339.1"> table with a primary key of 4. </span><span class="koboSpan" id="kobo.339.2">We do this by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">find()</span></strong><span class="koboSpan" id="kobo.341.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">EntityManager</span></strong><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">This method takes the class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Entity</span></strong><span class="koboSpan" id="kobo.345.1"> we are searching for as its first parameter, and the primary key of the row corresponding to the object we want </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">to obtain.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">The primary key we set for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">customer2</span></strong><span class="koboSpan" id="kobo.349.1"> object was 4, therefore what we have now is a copy of this object. </span><span class="koboSpan" id="kobo.349.2">The last name of this customer was misspelled when we originally inserted his data into the database, so we now correct Mr. </span><span class="koboSpan" id="kobo.349.3">Johnson’s last name by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">setLastName()</span></strong><span class="koboSpan" id="kobo.351.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">customer3</span></strong><span class="koboSpan" id="kobo.353.1">, then update the information in the database by </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">invoking </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">entityManager.persist()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">We then delete the information for the customer object by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">entityManager.remove()</span></strong><span class="koboSpan" id="kobo.359.1"> and</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.360.1"> passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">customer</span></strong><span class="koboSpan" id="kobo.362.1"> object as </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">a </span></span><span class="No-Break"><a id="_idIndexMarker366"/></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Finally, we commit the changes to the database by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">commit()</span></strong><span class="koboSpan" id="kobo.367.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">userTransaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.371.1">Cannot persist detached object exception</span></p>
<p class="callout"><span class="koboSpan" id="kobo.372.1">Frequently, an application will retrieve a Jakarta Persistence entity via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">EntityManager.find()</span></strong><span class="koboSpan" id="kobo.374.1"> method, then pass this entity to a business or user interface layer, where it will potentially be modified, and later the database data corresponding to the entity will be updated. </span><span class="koboSpan" id="kobo.374.2">In cases like this, invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">EntityManager.persist()</span></strong><span class="koboSpan" id="kobo.376.1"> will result in an exception. </span><span class="koboSpan" id="kobo.376.2">In order to update Jakarta Persistence entities this way we need to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">EntityManager.merge()</span></strong><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">This method takes an instance of the Jakarta Persistence entity as its single argument and updates the corresponding row in the database with the data stored </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Now that we’ve seen how to handle single Jakarta Persistence entities, we’ll focus our attention on how to define </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">entity relationships.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.382.1">Entity relationships</span></h1>
<p><span class="koboSpan" id="kobo.383.1">In the previous section, we saw </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.384.1">how to retrieve, insert, update, and delete single entities from the database. </span><span class="koboSpan" id="kobo.384.2">Entities are rarely isolated – in the vast majority of cases, they are related to </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">other entities.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Entities can have one-to-one, one-to-many, many-to-one, and </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">many-to-many relationships.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">In the CUSTOMERDB database, for example, there is</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.389.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">one-to-one relationship</span></strong><span class="koboSpan" id="kobo.391.1"> between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.393.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.395.1"> tables. </span><span class="koboSpan" id="kobo.395.2">This means that each customer has exactly one corresponding row in the login info table. </span><span class="koboSpan" id="kobo.395.3">There is also a </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">one-to-many relationship</span></strong><span class="koboSpan" id="kobo.397.1"> between</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.398.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.400.1"> table and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">ORDERS</span></strong><span class="koboSpan" id="kobo.402.1"> table. </span><span class="koboSpan" id="kobo.402.2">This is because a customer can place many orders, but each order belongs only to a single customer. </span><span class="koboSpan" id="kobo.402.3">There is also a </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">many-to-many relationship</span></strong><span class="koboSpan" id="kobo.404.1"> between</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.405.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ORDERS</span></strong><span class="koboSpan" id="kobo.407.1"> table and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">ITEMS</span></strong><span class="koboSpan" id="kobo.409.1"> table. </span><span class="koboSpan" id="kobo.409.2">This is because an order can contain many items and an item can be in </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">many orders.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">In the next few sections, we discuss how to establish relationships between Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">Persistence entities.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.413.1">One-to-one relationships</span></h2>
<p><span class="koboSpan" id="kobo.414.1">One-to-one relationships </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.415.1">occur when an instance of an entity</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.416.1"> can have zero or one corresponding instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">another entity.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">One-to-one entity relationships can be bidirectional (each entity is aware of the relationship) or unidirectional (only one of the entities is aware of the relationship). </span><span class="koboSpan" id="kobo.418.2">In the CUSTOMERDB database, the one-to-one mapping between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.420.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.422.1"> tables is unidirectional, since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.424.1"> table has a foreign key to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.426.1"> table, but not the other way around. </span><span class="koboSpan" id="kobo.426.2">As we will soon see, this fact does not stop us from creating a bidirectional one-to-one relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Customer</span></strong><span class="koboSpan" id="kobo.428.1"> entity and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">LoginInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> entity.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The source code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.433.1"> entity, which maps to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.435.1"> table, is </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "LOGIN_INFO")
public class LoginInfo {
  @Id
  @Column(name = "LOGIN_INFO_ID")
  private Long loginInfoId;
  @Column(name = "LOGIN_NAME")
  private String loginName;
  private String password;
  </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">@OneToOne</span></strong><span class="koboSpan" id="kobo.439.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">@JoinColumn(name = "CUSTOMER_ID")</span></strong><span class="koboSpan" id="kobo.441.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">private Customer customer;</span></strong><span class="koboSpan" id="kobo.443.1">
  //getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.444.1">The code for this entity is very similar to the code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Customer</span></strong><span class="koboSpan" id="kobo.446.1"> entity; it defines fields that map to database columns. </span><span class="koboSpan" id="kobo.446.2">Each field whose name does not match the database column name is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">@Column</span></strong><span class="koboSpan" id="kobo.448.1">, in addition to that, the primary key is annotated </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">@Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Where the</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.453.1"> preceding code gets interesting is in the</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.454.1"> declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">customer</span></strong><span class="koboSpan" id="kobo.456.1"> field. </span><span class="koboSpan" id="kobo.456.2">As can be seen in the code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">customer</span></strong><span class="koboSpan" id="kobo.458.1"> field is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">@OneToOne</span></strong><span class="koboSpan" id="kobo.460.1">, this lets the Jakarta EE runtime know that there is a one-to-one relationship between this entity and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Customer</span></strong><span class="koboSpan" id="kobo.462.1"> entity. </span><span class="koboSpan" id="kobo.462.2">The customer field is also annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">@JoinColumn</span></strong><span class="koboSpan" id="kobo.464.1">. </span><span class="koboSpan" id="kobo.464.2">This annotation lets the container know what column in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.466.1"> table is the foreign key corresponding to the primary key on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">CUSTOMER</span></strong><span class="koboSpan" id="kobo.468.1"> table. </span><span class="koboSpan" id="kobo.468.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.470.1">, the table that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.472.1"> entity maps to, has a foreign key to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">CUSTOMER</span></strong><span class="koboSpan" id="kobo.474.1"> table, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.476.1"> entity owns the relationship. </span><span class="koboSpan" id="kobo.476.2">If the relationship was unidirectional, we wouldn’t have to make any changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Customer</span></strong><span class="koboSpan" id="kobo.478.1"> entity. </span><span class="koboSpan" id="kobo.478.2">However, since we would like to have a bidirectional relationship between these two entities, we need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.480.1"> field to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Customer</span></strong><span class="koboSpan" id="kobo.482.1"> entity, along with the corresponding getter and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">setter methods.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">As we mentioned </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.485.1">before, in order to make the one-to-one relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Customer</span></strong><span class="koboSpan" id="kobo.487.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.489.1"> entities bidirectional, we need</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.490.1"> to make a few simple changes to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Customer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable {
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;
  @Column(name = "FIRST_NAME")
  private String firstName;
  @Column(name = "LAST_NAME")
  private String lastName;
  private String email;
  </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">@OneToOne(mappedBy = "customer")</span></strong><span class="koboSpan" id="kobo.495.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">private LoginInfo loginInfo;</span></strong><span class="koboSpan" id="kobo.497.1">
  public LoginInfo getLoginInfo() {
    return loginInfo;
  }
  public void setLoginInfo(LoginInfo loginInfo) {
    this.loginInfo = loginInfo;
  }
  //additional setters and getters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.498.1">The only</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.499.1"> change we need to make to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">Customer</span></strong><span class="koboSpan" id="kobo.501.1"> entity</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.502.1"> to make the one-to-one relationship bidirectional is to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.504.1"> field to it, along with the corresponding setter and getter methods. </span><span class="koboSpan" id="kobo.504.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">loginInfo</span></strong><span class="koboSpan" id="kobo.506.1"> field is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">@OneToOne</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Customer</span></strong><span class="koboSpan" id="kobo.510.1"> entity does not own the relationship (the table it maps to does not have a foreign key to the corresponding table), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">mappedBy</span></strong><span class="koboSpan" id="kobo.512.1"> element of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">@OneToOne</span></strong><span class="koboSpan" id="kobo.514.1"> annotation needs to be added. </span><span class="koboSpan" id="kobo.514.2">This element specifies what field in the corresponding entity has the other end of the relationship. </span><span class="koboSpan" id="kobo.514.3">In this particular case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">customer</span></strong><span class="koboSpan" id="kobo.516.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.518.1"> entity corresponds to the other end of this </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">one-to-one relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">The following Java class illustrates the use of the </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">preceding entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
package com.ensode.jakartaeebook.entityrelationship.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class OneToOneRelationshipDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  @Resource
  private UserTransaction userTransaction;
  public String updateDatabase() {
    String retVal = "confirmation";
    Customer customer;
    </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">LoginInfo loginInfo = new LoginInfo();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.524.1">    loginInfo.setLoginInfoId(1L);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.525.1">    loginInfo.setLoginName("charlesj");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.526.1">    loginInfo.setPassword("iwonttellyou");</span></strong><span class="koboSpan" id="kobo.527.1">
    try {
      userTransaction.begin();
      </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">customer = entityManager.find(Customer.class, 4L);</span></strong><span class="koboSpan" id="kobo.529.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">loginInfo.setCustomer(customer);</span></strong><span class="koboSpan" id="kobo.531.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">entityManager.persist(loginInfo);</span></strong><span class="koboSpan" id="kobo.533.1">
      userTransaction.commit();
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.534.1">In this</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.535.1"> example, we first create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.537.1"> entity and populate it with some data. </span><span class="koboSpan" id="kobo.537.2">We then obtain an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">Customer</span></strong><span class="koboSpan" id="kobo.539.1"> entity from the database by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">find()</span></strong><span class="koboSpan" id="kobo.541.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">EntityManager</span></strong><span class="koboSpan" id="kobo.543.1"> (data for this entity was inserted into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.545.1"> table in one of the previous examples). </span><span class="koboSpan" id="kobo.545.2">We then</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.546.1"> invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">setCustomer()</span></strong><span class="koboSpan" id="kobo.548.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">LoginInfo</span></strong><span class="koboSpan" id="kobo.550.1"> entity, passing the customer object as a parameter. </span><span class="koboSpan" id="kobo.550.2">Finally, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">EntityManager.persist()</span></strong><span class="koboSpan" id="kobo.552.1"> method to save the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">What happens behind the scenes is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">CUSTOMER_ID</span></strong><span class="koboSpan" id="kobo.556.1"> column of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">LOGIN_INFO</span></strong><span class="koboSpan" id="kobo.558.1"> table gets populated with the primary key of the corresponding row in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">CUSTOMERS</span></strong><span class="koboSpan" id="kobo.560.1"> table. </span><span class="koboSpan" id="kobo.560.2">This can be easily verified by querying the </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">CUSTOMERDB database.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.562.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.563.1">Notice how the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">EntityManager.find()</span></strong><span class="koboSpan" id="kobo.565.1"> to obtain the customer entity is inside the same transaction where we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">EntityManager.persist()</span></strong><span class="koboSpan" id="kobo.567.1">. </span><span class="koboSpan" id="kobo.567.2">If this is not the case the database will not be </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">updated successfully.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.569.1">One-to-many relationships</span></h2>
<p><span class="koboSpan" id="kobo.570.1">Jakarta Persistence one-to-many entity </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.571.1">relationships </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.572.1">can be </span><em class="italic"><span class="koboSpan" id="kobo.573.1">bidirectional</span></em><span class="koboSpan" id="kobo.574.1"> (i.e., one entity contains a many-to-one relationship and the corresponding entity contains an inverse one-to-many relationship) or </span><em class="italic"><span class="koboSpan" id="kobo.575.1">unidirectional</span></em><span class="koboSpan" id="kobo.576.1"> (one entity contains a many-to-one relationship to another entity, which does not have a corresponding one-to-many </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">relationship defined).</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">With SQL, one-to-many relationships are defined by foreign keys in one of the tables. </span><span class="koboSpan" id="kobo.578.2">The “many” part of the relationship is the one containing a foreign key to the “one” part of the relationship. </span><span class="koboSpan" id="kobo.578.3">One-to-many relationships defined in an RDBMS are typically unidirectional, since making them bidirectional usually results in </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">denormalized data.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Just like when defining a unidirectional one-to-many relationship in an RDBMS, in Jakarta Persistence the “many” part of the relationship is the one that has a reference to the “one” part of the relationship, therefore the annotation used to define the relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">@ManyToOne</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">In the CUSTOMERDB </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.585.1">database, there is a unidirectional</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.586.1"> one-to-many relationship between customers and orders. </span><span class="koboSpan" id="kobo.586.2">We define this relationship in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Order</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "ORDERS")
public class Order {
  @Id
  @Column(name = "ORDER_ID")
  private Long orderId;
  @Column(name = "ORDER_NUMBER")
  private String orderNumber;
  @Column(name = "ORDER_DESCRIPTION")
  private String orderDescription;
  @ManyToOne
  @JoinColumn(name = "CUSTOMER_ID")
  private Customer customer;
  //setters and getters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.590.1">If we were to define a unidirectional many-to-one relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Orders</span></strong><span class="koboSpan" id="kobo.592.1"> entity and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Customer</span></strong><span class="koboSpan" id="kobo.594.1"> entity, we wouldn’t need to make any changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Customer</span></strong><span class="koboSpan" id="kobo.596.1"> entity. </span><span class="koboSpan" id="kobo.596.2">To define a bidirectional one-to-many relationship between the two entities, a new field decorated </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.597.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">@OneToMany</span></strong><span class="koboSpan" id="kobo.599.1"> annotation needs to be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">Customer</span></strong><span class="koboSpan" id="kobo.601.1"> entity, as</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.602.1"> illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">next example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "CUSTOMERS")
public class Customer implements Serializable {
  @Id
  @Column(name = "CUSTOMER_ID")
  private Long customerId;
  @Column(name = "FIRST_NAME")
  private String firstName;
  @Column(name = "LAST_NAME")
  private String lastName;
  private String email;
  @OneToOne(mappedBy = "customer")
  private LoginInfo loginInfo;
  </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">@OneToMany(mappedBy = "customer")</span></strong><span class="koboSpan" id="kobo.606.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">private Set&lt;Order&gt; orders;</span></strong><span class="koboSpan" id="kobo.608.1">
  public Set&lt;Order&gt; getOrders() {
    return orders;
  }
  public void setOrders(Set&lt;Order&gt; orders) {
    this.orders = orders;
  }
  //additional getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.609.1">The only difference</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.610.1"> between this version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Customer</span></strong><span class="koboSpan" id="kobo.612.1"> entity and the previous one is the addition of the orders field and related getter and setter methods. </span><span class="koboSpan" id="kobo.612.2">Of special interest is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">@OneToMany</span></strong><span class="koboSpan" id="kobo.614.1"> annotation decorating this field. </span><span class="koboSpan" id="kobo.614.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">mappedBy</span></strong><span class="koboSpan" id="kobo.616.1"> attribute must match the name of the corresponding field in the entity corresponding to the “many” part of the relationship. </span><span class="koboSpan" id="kobo.616.2">In simple terms, the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">mappedBy</span></strong><span class="koboSpan" id="kobo.618.1"> attribute</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.619.1"> must match the name of the field decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">@ManyToOne</span></strong><span class="koboSpan" id="kobo.621.1"> annotation in the bean at the other side of </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">The following example code illustrates how to persist one-to-many relationships to </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
package com.ensode.jakartaeebook.entityrelationship.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class OneToManyRelationshipDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  @Resource
  private UserTransaction userTransaction;
  public String updateDatabase() {
    String retVal = "confirmation";
    Customer customer;
    Order order1;
    Order order2;
    order1 = new Order();
    order1.setOrderId(1L);
    order1.setOrderNumber("SFX12345");
    order1.setOrderDescription("Dummy order.");
    order2 = new Order();
    order2.setOrderId(2L);
    order2.setOrderNumber("SFX23456");
    order2.setOrderDescription("Another dummy order.");
    try {
      userTransaction.begin();
      customer = entityManager.find(Customer.class, 4L);
      order1.setCustomer(customer);
      order2.setCustomer(customer);
      entityManager.persist(order1);
      entityManager.persist(order2);
      userTransaction.commit();
    }catch (NotSupportedException |
      SystemException |
      SecurityException |
      IllegalStateException |
      RollbackException |
      HeuristicMixedException |
      HeuristicRollbackException e) {
      retVal = "error";
      e.printStackTrace();
     }
      return retVal;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.626.1">Our example</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.627.1"> instantiates two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">Order</span></strong><span class="koboSpan" id="kobo.629.1"> entity, populates them with </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.630.1">some data, then in a transaction, an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Customer</span></strong><span class="koboSpan" id="kobo.632.1"> entity is located, and used as the parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">setCustomer()</span></strong><span class="koboSpan" id="kobo.634.1"> method of both instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Order</span></strong><span class="koboSpan" id="kobo.636.1"> entity. </span><span class="koboSpan" id="kobo.636.2">We then persist both </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">Order</span></strong><span class="koboSpan" id="kobo.638.1"> entities by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">EntityManager.persist()</span></strong><span class="koboSpan" id="kobo.640.1"> for each one </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Just like when dealing with one-to-one relationships, what happens behind the scenes is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">CUSTOMER_ID</span></strong><span class="koboSpan" id="kobo.644.1"> column of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">ORDERS</span></strong><span class="koboSpan" id="kobo.646.1"> table in the CUSTOMERDB database is populated with the primary key corresponding to the related row in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">CUSTOMERS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> table.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Since the</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.650.1"> relationship is bidirectional, we can obtain all orders related to a</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.651.1"> customer by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">getOrders()</span></strong><span class="koboSpan" id="kobo.653.1"> method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Customer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> entity.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.656.1">Many-to-many relationships</span></h2>
<p><span class="koboSpan" id="kobo.657.1">In the CUSTOMERDB database, there is </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.658.1">a many-to-many relationship</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.659.1"> between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">ORDERS</span></strong><span class="koboSpan" id="kobo.661.1"> table and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">ITEMS</span></strong><span class="koboSpan" id="kobo.663.1"> table. </span><span class="koboSpan" id="kobo.663.2">We can map this relationship by adding a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Collection&lt;Item&gt;</span></strong><span class="koboSpan" id="kobo.665.1"> field to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Order</span></strong><span class="koboSpan" id="kobo.667.1"> entity and decorating it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">ManyToMany</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.670.1"> annotation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "ORDERS")
public class Order {
  @Id
  @Column(name = "ORDER_ID")
  private Long orderId;
  @Column(name = "ORDER_NUMBER")
  private String orderNumber;
  @Column(name = "ORDER_DESCRIPTION")
  private String orderDescription;
  @ManyToOne
  @JoinColumn(name = "CUSTOMER_ID")
  private Customer customer;
  </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">@ManyToMany</span></strong><span class="koboSpan" id="kobo.673.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">@JoinTable(name = "ORDER_ITEMS",</span></strong><span class="koboSpan" id="kobo.675.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">joinColumns = @JoinColumn(name = "ORDER_ID",</span></strong><span class="koboSpan" id="kobo.677.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">referencedColumnName = "ORDER_ID"),</span></strong><span class="koboSpan" id="kobo.679.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.680.1">inverseJoinColumns = @JoinColumn(name = "ITEM_ID",</span></strong><span class="koboSpan" id="kobo.681.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">referencedColumnName = "ITEM_ID"))</span></strong><span class="koboSpan" id="kobo.683.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.684.1">private Collection&lt;Item&gt; items;</span></strong><span class="koboSpan" id="kobo.685.1">
  public Collection&lt;Item&gt; getItems() {
    return items;
  }
  public void setItems(Collection&lt;Item&gt; items) {
    this.items = items;
  }
  //additional getters and setters omitted
}</span></pre> <p><span class="koboSpan" id="kobo.686.1">As we can see in the preceding code, in addition to being annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">@ManyToMany</span></strong><span class="koboSpan" id="kobo.688.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">items</span></strong><span class="koboSpan" id="kobo.690.1"> field is</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.691.1"> also annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">@JoinTable</span></strong><span class="koboSpan" id="kobo.693.1">. </span><span class="koboSpan" id="kobo.693.2">As its name suggests, this annotation lets the application server know what table is used as a join table to create the </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.694.1">many-to-many relationship between the </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">two entities.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">@JoinTable</span></strong><span class="koboSpan" id="kobo.697.1"> has three relevant elements: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">name</span></strong><span class="koboSpan" id="kobo.699.1"> element, which defines the name of the join table, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">joinColumns</span></strong><span class="koboSpan" id="kobo.701.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">inverseJoinColumns</span></strong><span class="koboSpan" id="kobo.703.1"> elements, which define the columns that serve as foreign keys in the join table pointing to the entities’ primary keys. </span><span class="koboSpan" id="kobo.703.2">Values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">joinColumns</span></strong><span class="koboSpan" id="kobo.705.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">inverseJoinColumns</span></strong><span class="koboSpan" id="kobo.707.1"> elements are yet another annotation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">@JoinColumn</span></strong><span class="koboSpan" id="kobo.709.1"> annotation. </span><span class="koboSpan" id="kobo.709.2">This annotation has two relevant elements, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">name</span></strong><span class="koboSpan" id="kobo.711.1"> element, which defines the name of the column in the join table, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">referencedColumnName</span></strong><span class="koboSpan" id="kobo.713.1"> element, which defines the name of the column in the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">entity table.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">Item</span></strong><span class="koboSpan" id="kobo.717.1"> entity is a </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.718.1">simple entity mapping to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">ITEMS</span></strong><span class="koboSpan" id="kobo.720.1"> table</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.721.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">CUSTOMERDB database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.723.1">
package com.ensode.jakartaeebook.entityrelationship.entity;
//imports omitted for brevity
@Entity
@Table(name = "ITEMS")
public class Item {
  @Id
  @Column(name = "ITEM_ID")
  private Long itemId;
  @Column(name = "ITEM_NUMBER")
  private String itemNumber;
  @Column(name = "ITEM_SHORT_DESC")
  private String itemShortDesc;
  @Column(name = "ITEM_LONG_DESC")
  private String itemLongDesc;
  </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">@ManyToMany(mappedBy = "items")</span></strong><span class="koboSpan" id="kobo.725.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">private Collection&lt;Order&gt; orders;</span></strong><span class="koboSpan" id="kobo.727.1">
  public Collection&lt;Order&gt; getOrders() {
    return orders;
  }
  public void setOrders(Collection&lt;Order&gt; orders) {
    this.orders = orders;
  }
  //addtional getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.728.1">Just like</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.729.1"> one-to-one and one-to-many relationships, many-to-many relationships can be unidirectional or bidirectional. </span><span class="koboSpan" id="kobo.729.2">Since we would like the</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.730.1"> many-to-many relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Order</span></strong><span class="koboSpan" id="kobo.732.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">Item</span></strong><span class="koboSpan" id="kobo.734.1"> entities to be bidirectional, we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">Collection&lt;Order&gt;</span></strong><span class="koboSpan" id="kobo.736.1"> field and decorated it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">@ManyToMany</span></strong><span class="koboSpan" id="kobo.738.1"> annotation. </span><span class="koboSpan" id="kobo.738.2">Since the corresponding field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">Order</span></strong><span class="koboSpan" id="kobo.740.1"> entity already has the join table defined, it is not necessary to do it again here. </span><span class="koboSpan" id="kobo.740.2">The entity containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">@JoinTable </span></strong><span class="koboSpan" id="kobo.742.1">annotation is said to own the relationship, in a many-to-many relationship, either entity can own the relationship. </span><span class="koboSpan" id="kobo.742.2">In our example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">Order</span></strong><span class="koboSpan" id="kobo.744.1"> entity owns it, since its </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Collection&lt;Item&gt;</span></strong><span class="koboSpan" id="kobo.746.1"> field is decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">JoinTable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.749.1"> annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Just like with the one-to-one and one-to-many relationships, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">@ManyToMany</span></strong><span class="koboSpan" id="kobo.752.1"> annotation on the non-owning side of a bidirectional many-to-many relationship must contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">mappedBy</span></strong><span class="koboSpan" id="kobo.754.1"> element indicating what field in the owning entity defines </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">the relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">Now that we have seen the changes necessary to establish a bidirectional many-to-many relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Order</span></strong><span class="koboSpan" id="kobo.758.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Item</span></strong><span class="koboSpan" id="kobo.760.1"> entities, we can see the relationship in action in the </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.762.1">
package com.ensode.jakartaeebook.entityrelationship.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class ManyToManyRelationshipDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  @Resource
  private UserTransaction userTransaction;
  public String updateDatabase() {
    String retVal = "confirmation";
    Order order;
    Collection&lt;Item&gt; items = new ArrayList&lt;Item&gt;();
    Item item1 = new Item();
    Item item2 = new Item();
    item1.setItemId(1L);
    item1.setItemNumber("BCD1234");
    item1.setItemShortDesc("Notebook Computer");
    item2.setItemId(2L);
    item2.setItemNumber("CDF2345");
    item2.setItemShortDesc("Cordless Mouse");
    items.add(item1);
    items.add(item2);
    try {
      userTransaction.begin();
      </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">entityManager.persist(item1);</span></strong><span class="koboSpan" id="kobo.764.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">entityManager.persist(item2);</span></strong><span class="koboSpan" id="kobo.766.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">order = entityManager.find(Order.class, 1L);</span></strong><span class="koboSpan" id="kobo.768.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">order.setItems(items);</span></strong><span class="koboSpan" id="kobo.770.1">
      entityManager.persist(order);
      userTransaction.commit();
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.771.1">The preceding code creates two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">Item</span></strong><span class="koboSpan" id="kobo.773.1"> entity and populates them with some data. </span><span class="koboSpan" id="kobo.773.2">It then adds these two instances to a collection. </span><span class="koboSpan" id="kobo.773.3">A transaction is then started, the</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.774.1"> two </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">Item</span></strong><span class="koboSpan" id="kobo.776.1"> instances are persisted in the</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.777.1"> database. </span><span class="koboSpan" id="kobo.777.2">Then an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">Order</span></strong><span class="koboSpan" id="kobo.779.1"> entity is retrieved from the database. </span><span class="koboSpan" id="kobo.779.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">setItems()</span></strong><span class="koboSpan" id="kobo.781.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Order</span></strong><span class="koboSpan" id="kobo.783.1"> entity instance is then invoked, passing the collection containing the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">Item</span></strong><span class="koboSpan" id="kobo.785.1"> instances as a parameter. </span><span class="koboSpan" id="kobo.785.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">Customer</span></strong><span class="koboSpan" id="kobo.787.1"> instance is then persisted into the database. </span><span class="koboSpan" id="kobo.787.2">At this point, two rows are created behind the scenes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">ORDER_ITEMS</span></strong><span class="koboSpan" id="kobo.789.1"> table, which is the join table between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">ORDERS</span></strong><span class="koboSpan" id="kobo.791.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">ITEMS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.793.1"> tables.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.794.1">Composite primary keys</span></h1>
<p><span class="koboSpan" id="kobo.795.1">Most tables in the</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.796.1"> CUSTOMERDB database have a column with the sole purpose of serving as a primary key (this type of primary key is sometimes referred to as a surrogate primary key or as an artificial primary key). </span><span class="koboSpan" id="kobo.796.2">However, some databases are not designed this way. </span><span class="koboSpan" id="kobo.796.3">Instead, a column in the database that is known to be unique across rows is used as the primary key. </span><span class="koboSpan" id="kobo.796.4">If there is no column whose value is not guaranteed to be unique across rows, then a combination of two or more columns is used as the table’s primary key. </span><span class="koboSpan" id="kobo.796.5">It is possible to map this </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.797.1">kind of primary key to Jakarta Persistence entities by using a </span><strong class="bold"><span class="koboSpan" id="kobo.798.1">primary </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.799.1">key class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">There is one table in the CUSTOMERDB database that does not have a surrogate primary key, this table is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">ORDER_ITEMS</span></strong><span class="koboSpan" id="kobo.803.1"> table. </span><span class="koboSpan" id="kobo.803.2">This table serves as a join table between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">ORDERS</span></strong><span class="koboSpan" id="kobo.805.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">ITEMS</span></strong><span class="koboSpan" id="kobo.807.1"> tables. </span><span class="koboSpan" id="kobo.807.2">In addition to having foreign keys for these two tables, this table has an additional column called </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">ITEM_QTY</span></strong><span class="koboSpan" id="kobo.809.1">, which stores the quantity of each item in an order. </span><span class="koboSpan" id="kobo.809.2">Since this table does not have a surrogate primary key, the Jakarta Persistence entity mapping to it must have a custom primary key class. </span><span class="koboSpan" id="kobo.809.3">In this table, the combination of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">ORDER_ID</span></strong><span class="koboSpan" id="kobo.811.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">ITEM_ID</span></strong><span class="koboSpan" id="kobo.813.1"> columns must be unique. </span><span class="koboSpan" id="kobo.813.2">Therefore, this is a good combination for a composite primary key, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
package com.ensode.jakartaeebook.compositeprimarykeys.entity;
import java.io.Serializable;
public class OrderItemPK implements Serializable {
  public Long orderId;
  public Long itemId;
  public OrderItemPK() {
  }
  public OrderItemPK(Long orderId, Long itemId) {
    this.orderId = orderId;
    this.itemId = itemId;
  }
  @Override
  public boolean equals(Object obj) {
    boolean returnVal = false;
    if (obj == null) {
      returnVal = false;
    } else if (!obj.getClass().equals(this.getClass())) {
      returnVal = false;
    } else {
      OrderItemPK other = (OrderItemPK) obj;
      if (this == other) {
        returnVal = true;
      } else if (orderId != null &amp;&amp; other.orderId != null
          &amp;&amp; this.orderId.equals(other.orderId)) {
        if (itemId != null &amp;&amp; other.itemId != null
            &amp;&amp; itemId.equals(other.itemId)) {
          returnVal = true;
        }
      } else {
        returnVal = false;
      }
    }
    return returnVal;
  }
  @Override
  public int hashCode() {
    if (orderId == null || itemId == null) {
      return 0;
    } else {
      return orderId.hashCode() ^ itemId.hashCode();
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.816.1">A custom </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.817.1">primary key class must satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">following requirements:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.819.1">The class must </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">be public</span></span></li>
<li><span class="koboSpan" id="kobo.821.1">It must </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">implement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">java.io.Serializable</span></strong></span></li>
<li><span class="koboSpan" id="kobo.824.1">It must have a public constructor that takes </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">no arguments</span></span></li>
<li><span class="koboSpan" id="kobo.826.1">Its fields must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">public</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.828.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">protected</span></strong></span></li>
<li><span class="koboSpan" id="kobo.830.1">Its field names and types must match those of </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">the entity</span></span></li>
<li><span class="koboSpan" id="kobo.832.1">It must override the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">hashCode()</span></strong><span class="koboSpan" id="kobo.834.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">equals()</span></strong><span class="koboSpan" id="kobo.836.1"> methods defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">java.lang.Object</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1"> class</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.839.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">OrderPK</span></strong><span class="koboSpan" id="kobo.841.1"> class meets all of these requirements. </span><span class="koboSpan" id="kobo.841.2">It also has a convenience constructor that takes two </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">Long</span></strong><span class="koboSpan" id="kobo.843.1"> objects meant to initialize its </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">orderId</span></strong><span class="koboSpan" id="kobo.845.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">itemId</span></strong><span class="koboSpan" id="kobo.847.1"> fields. </span><span class="koboSpan" id="kobo.847.2">This constructor was added for convenience; this is not a requirement for the class to be used as a primary </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">key class.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">When an entity uses a custom primary key class, it must be annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">@IdClass</span></strong><span class="koboSpan" id="kobo.851.1">. </span><span class="koboSpan" id="kobo.851.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">OrderItem</span></strong><span class="koboSpan" id="kobo.853.1"> class uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">OrderItemPK</span></strong><span class="koboSpan" id="kobo.855.1"> as its custom primary key class, it is annotated with </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">said annotation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.857.1">
package com.ensode.jakartaeebook.compositeprimarykeys.entity;
//imports omitted
@Entity
@Table(name = "ORDER_ITEMS")
</span><strong class="bold"><span class="koboSpan" id="kobo.858.1">@IdClass(value = OrderItemPK.class)</span></strong><span class="koboSpan" id="kobo.859.1">
public class OrderItem {
  </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">@Id</span></strong><span class="koboSpan" id="kobo.861.1">
  @Column(name = "ORDER_ID")
  private Long orderId;
  </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">@Id</span></strong><span class="koboSpan" id="kobo.863.1">
  @Column(name = "ITEM_ID")
  private Long itemId;
  @Column(name = "ITEM_QTY")
  private Long itemQty;
  //getters and setters omitted
}</span></pre> <p><span class="koboSpan" id="kobo.864.1">There are two </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.865.1">differences between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">OrderItem</span></strong><span class="koboSpan" id="kobo.867.1"> entity and the previous entities we have seen. </span><span class="koboSpan" id="kobo.867.2">The first difference is that this entity is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">@IdClass</span></strong><span class="koboSpan" id="kobo.869.1">, indicating the primary key class corresponding to it. </span><span class="koboSpan" id="kobo.869.2">The second difference is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">OrderItem</span></strong><span class="koboSpan" id="kobo.871.1"> has more than one field annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">@Id</span></strong><span class="koboSpan" id="kobo.873.1">. </span><span class="koboSpan" id="kobo.873.2">Since this entity has a composite primary key, each field that is part of the primary key must be annotated with </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">this annotation.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">Obtaining a reference of an entity with a composite primary key is not much different than obtaining a reference to an entity with a primary key consisting of a single field. </span><span class="koboSpan" id="kobo.875.2">The following example demonstrates how to </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.877.1">
package com.ensode.jakartaeebook.compositeprimarykeys.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class CompositePrimaryKeyDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  private OrderItem orderItem;
  public String findOrderItem() {
    String retVal = "confirmation";
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.878.1">orderItem = entityManager.find(OrderItem.class,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.879.1">     new OrderItemPK(1L, 2L));</span></strong><span class="koboSpan" id="kobo.880.1">
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
  //getters and setters omitted
}</span></pre> <p><span class="koboSpan" id="kobo.881.1">As can be seen</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.882.1"> in this example, the only difference between locating an entity with a composite primary key and an entity with a primary key consisting of a single field is that an instance of the custom primary key class must be passed as the second argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">EntityManager.find()</span></strong><span class="koboSpan" id="kobo.884.1"> method; fields for this instance must be populated with the appropriate values for each field that is part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">primary key.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.886.1">Jakarta Persistence Query Language</span></h1>
<p><span class="koboSpan" id="kobo.887.1">All of our </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.888.1">examples that obtain entities from the database so far have conveniently assumed that the primary key for the entity is known ahead of time. </span><span class="koboSpan" id="kobo.888.2">We all know that frequently this is not the case. </span><span class="koboSpan" id="kobo.888.3">Whenever we need to search for an entity by a field other than the entity’s primary key, we can use the </span><strong class="bold"><span class="koboSpan" id="kobo.889.1">Jakarta Persistence Query </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.890.1">Language</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.891.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.892.1">JPQL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">JPQL is an SQL-like language used for retrieving, updating, and deleting entities in a database. </span><span class="koboSpan" id="kobo.894.2">The following example illustrates how to use JPQL to retrieve a subset of states from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">US_STATES</span></strong><span class="koboSpan" id="kobo.896.1"> table in the </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">CUSTOMERDB database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.898.1">
package com.ensode.jakartaeebook.jpql.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class SelectQueryDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  private List&lt;UsState&gt; matchingStatesList;
  public String findStates() {
    String retVal = "confirmation";
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.899.1">Query query = entityManager.createQuery(</span></strong><span class="koboSpan" id="kobo.900.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.901.1">"SELECT s FROM UsState s WHERE s.usStateNm "</span></strong><span class="koboSpan" id="kobo.902.1">
            </span><strong class="bold"><span class="koboSpan" id="kobo.903.1">+ "LIKE :name");</span></strong><span class="koboSpan" id="kobo.904.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.905.1">query.setParameter("name", "New%");</span></strong><span class="koboSpan" id="kobo.906.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.907.1">matchingStatesList = query.getResultList();</span></strong><span class="koboSpan" id="kobo.908.1">
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
  //getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.909.1">The preceding code invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">EntityManager.createQuery()</span></strong><span class="koboSpan" id="kobo.911.1"> method, passing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">String</span></strong><span class="koboSpan" id="kobo.913.1"> containing a JPQL query as a parameter. </span><span class="koboSpan" id="kobo.913.2">This method returns an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">jakarta.persistence.Query</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">The query retrieves all </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">UsState</span></strong><span class="koboSpan" id="kobo.917.1"> entities whose names start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">word “New”.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">As can be seen in the preceding code, JPQL is similar to SQL, however, there are some differences that may confuse readers with SQL knowledge. </span><span class="koboSpan" id="kobo.919.2">The equivalent SQL code for the query in the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
SELECT * from US_STATES s where s.US_STATE_NM like 'New%'</span></pre> <p><span class="koboSpan" id="kobo.922.1">The first difference between </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.923.1">JPQL and SQL is that in JPQL, we always reference entity names, whereas in SQL table names are referenced. </span><span class="koboSpan" id="kobo.923.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">s</span></strong><span class="koboSpan" id="kobo.925.1"> after the entity name in the JPQL query is an alias for the entity. </span><span class="koboSpan" id="kobo.925.2">Table aliases are optional in SQL, but entity aliases are required in JPQL. </span><span class="koboSpan" id="kobo.925.3">Keeping these differences in mind, the JPQL query should now be a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">less confusing.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">:name</span></strong><span class="koboSpan" id="kobo.929.1"> in the </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.930.1">query is a </span><strong class="bold"><span class="koboSpan" id="kobo.931.1">named parameter</span></strong><span class="koboSpan" id="kobo.932.1">. </span><span class="koboSpan" id="kobo.932.2">Named parameters are meant to be substituted with </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.933.1">actual values. </span><span class="koboSpan" id="kobo.933.2">This is done by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">setParameter()</span></strong><span class="koboSpan" id="kobo.935.1"> method in the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">jakarta.persistence.Query</span></strong><span class="koboSpan" id="kobo.937.1"> returned by the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">EntityManager.createQuery()</span></strong><span class="koboSpan" id="kobo.939.1">. </span><span class="koboSpan" id="kobo.939.2">A JPQL query can have multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">named parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">To actually run the query and retrieve the entities from the database, we can invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">getResultList()</span></strong><span class="koboSpan" id="kobo.943.1"> method on the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">jakarta.persistence.Query</span></strong><span class="koboSpan" id="kobo.945.1"> obtained from </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">EntityManager.createQuery()</span></strong><span class="koboSpan" id="kobo.947.1">. </span><span class="koboSpan" id="kobo.947.2">This method returns an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">java.util.List</span></strong><span class="koboSpan" id="kobo.949.1"> interface, this list contains the entities matching the query criteria. </span><span class="koboSpan" id="kobo.949.2">If no entities match the criteria, then an empty list </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">If we are certain that the query will return exactly one entity, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">getSingleResult()</span></strong><span class="koboSpan" id="kobo.953.1"> method may be alternatively called on </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">Query</span></strong><span class="koboSpan" id="kobo.955.1">, this method returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">Object</span></strong><span class="koboSpan" id="kobo.957.1"> that must be cast to the </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">appropriate entity.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">The preceding example uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">LIKE</span></strong><span class="koboSpan" id="kobo.961.1"> operator to find entities whose name starts with the word “New”. </span><span class="koboSpan" id="kobo.961.2">This is accomplished by substituting the query’s named parameter with the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">New%</span></strong><span class="koboSpan" id="kobo.963.1">. </span><span class="koboSpan" id="kobo.963.2">The percent sign at the end of the parameter value means that any number of characters after the word “New” will match the expression. </span><span class="koboSpan" id="kobo.963.3">The percent sign can be used anywhere in the parameter value, for example, a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">%Dakota</span></strong><span class="koboSpan" id="kobo.965.1"> would match any entities whose names end in “Dakota”, while a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">A%a</span></strong><span class="koboSpan" id="kobo.967.1"> would match any states whose names start with a capital “A” and end with a lowercase “a”. </span><span class="koboSpan" id="kobo.967.2">There can be more than one percent sign in a parameter value. </span><span class="koboSpan" id="kobo.967.3">The underscore sign (</span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">_</span></strong><span class="koboSpan" id="kobo.969.1">) can be used to match a single character, all the rules for the percent sign apply to the underscore </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.971.1">In addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">LIKE</span></strong><span class="koboSpan" id="kobo.973.1"> operator, there are other operators that can be used to retrieve entities from </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">the database:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.975.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">=</span></strong><span class="koboSpan" id="kobo.977.1"> operator will retrieve entities whose field on the left of the operator exactly match the value to the right of </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">the operator</span></span></li>
<li><span class="koboSpan" id="kobo.979.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">&gt;</span></strong><span class="koboSpan" id="kobo.981.1"> operator will retrieve entities whose field on the left of the operator is greater than the value to the right of </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">the operator</span></span></li>
<li><span class="koboSpan" id="kobo.983.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">&lt;</span></strong><span class="koboSpan" id="kobo.985.1"> operator will retrieve entities whose field on the left of the operator is less than the value to the right of </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">the operator</span></span></li>
<li><span class="koboSpan" id="kobo.987.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">&gt;=</span></strong><span class="koboSpan" id="kobo.989.1"> operator will retrieve entities whose field on the left of the operator is greater than or equal to the value to the right of </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">the operator</span></span></li>
<li><span class="koboSpan" id="kobo.991.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">&lt;=</span></strong><span class="koboSpan" id="kobo.993.1"> operator will retrieve entities whose field on the left of the operator is less than or equal to the value to the right of </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the operator</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.995.1">All of the preceding operators work the same way as the equivalent operators in SQL. </span><span class="koboSpan" id="kobo.995.2">Just like in SQL, these operators can be combined with the “AND” and “OR” operators. </span><span class="koboSpan" id="kobo.995.3">Conditions combined with the “AND” operator match if both conditions are true, while conditions combined with the “OR” operator match if at least one of the conditions </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">is true.</span></span></p>
<p><span class="koboSpan" id="kobo.997.1">If we intend to</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.998.1"> use a query many times, it can be stored in</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.999.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">named query</span></strong><span class="koboSpan" id="kobo.1001.1">. </span><span class="koboSpan" id="kobo.1001.2">Named queries can be defined by decorating the relevant entity class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">@NamedQuery</span></strong><span class="koboSpan" id="kobo.1003.1"> annotation. </span><span class="koboSpan" id="kobo.1003.2">This annotation has two elements, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">name</span></strong><span class="koboSpan" id="kobo.1005.1"> element used to set the name of the query; and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">query</span></strong><span class="koboSpan" id="kobo.1007.1"> element defining the query itself. </span><span class="koboSpan" id="kobo.1007.2">To execute a named query, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">createNamedQuery()</span></strong><span class="koboSpan" id="kobo.1009.1"> method must be invoked in an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">EntityManager</span></strong><span class="koboSpan" id="kobo.1011.1">. </span><span class="koboSpan" id="kobo.1011.2">This method takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">String</span></strong><span class="koboSpan" id="kobo.1013.1"> containing the query name as its sole parameter, and returns an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">jakarta.persistence.Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">In addition to retrieving entities, JPQL can be used to modify or delete entities. </span><span class="koboSpan" id="kobo.1017.2">However, entity modification and deletion can be done programmatically via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">EntityManager</span></strong><span class="koboSpan" id="kobo.1019.1"> interface, doing so results in code that tends to be more readable than when using JPQL. </span><span class="koboSpan" id="kobo.1019.2">Because of this, we will not cover entity modification and deletion via JPQL. </span><span class="koboSpan" id="kobo.1019.3">Readers interested in writing JPQL queries to modify and delete entities, as well as readers wishing to know more about JPQL are encouraged to review the Jakarta Persistence 3.1 specification. </span><span class="koboSpan" id="kobo.1019.4">This specification can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">at </span></span><a href="https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1"><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1023.1">In addition to JPQL, Jakarta Persistence provides an API we can use to create queries, named, appropriately enough, the </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">Criteria API.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1025.1">Criteria API</span></h1>
<p><span class="koboSpan" id="kobo.1026.1">The Jakarta Persistence </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">Criteria API</span></strong><span class="koboSpan" id="kobo.1028.1"> is </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1029.1">meant as a complement to JPQL. </span><span class="koboSpan" id="kobo.1029.2">The Criteria API allows us to write Jakarta Persistence queries programmatically, without having to rely </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">on JPQL.</span></span></p>
<p><span class="koboSpan" id="kobo.1031.1">The Criteria API </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1032.1">offers a few advantages over JPQL – for instance, JPQL queries are stored as Strings, and the compiler has no way of validating JPQL syntax. </span><span class="koboSpan" id="kobo.1032.2">Additionally, JPQL is not type safe; we could write a JPQL query in which our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">where</span></strong><span class="koboSpan" id="kobo.1034.1"> clause could have a string value for a numeric property, and our code would compile and deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">just fine.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">The following code example illustrates how to use the Criteria API in our Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">EE applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1038.1">
package com.ensode.jakartaeebook.criteriaapi.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class CriteriaApiDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  private List&lt;UsState&gt; matchingStatesList;
  public String findStates() {
    String retVal = "confirmation";
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1039.1">CriteriaBuilder criteriaBuilder = entityManager.</span></strong><span class="koboSpan" id="kobo.1040.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.1041.1">getCriteriaBuilder();</span></strong><span class="koboSpan" id="kobo.1042.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1043.1">CriteriaQuery&lt;UsState&gt; criteriaQuery =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1044.1">        criteriaBuilder.createQuery(UsState.class);</span></strong><span class="koboSpan" id="kobo.1045.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">Root&lt;UsState&gt; root = criteriaQuery.from(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1047.1">          UsState.class);</span></strong><span class="koboSpan" id="kobo.1048.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1049.1">Metamodel metamodel = entityManager.getMetamodel();</span></strong><span class="koboSpan" id="kobo.1050.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1051.1">EntityType&lt;UsState&gt; usStateEntityType =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1052.1">        metamodel.entity(UsState.class);</span></strong><span class="koboSpan" id="kobo.1053.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">SingularAttribute&lt;UsState, String&gt; usStateAttribute =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1055.1">       usStateEntityType.getDeclaredSingularAttribute(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1056.1">         "usStateNm",String.class);</span></strong><span class="koboSpan" id="kobo.1057.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">Path&lt;String&gt; path = root.get(usStateAttribute);</span></strong><span class="koboSpan" id="kobo.1059.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">Predicate predicate = criteriaBuilder.like(</span></strong><span class="koboSpan" id="kobo.1061.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">path, "New%");</span></strong><span class="koboSpan" id="kobo.1063.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1064.1">criteriaQuery = criteriaQuery.where(predicate);</span></strong><span class="koboSpan" id="kobo.1065.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">TypedQuery typedQuery = entityManager.createQuery(</span></strong><span class="koboSpan" id="kobo.1067.1">
              </span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">criteriaQuery);</span></strong><span class="koboSpan" id="kobo.1069.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1070.1">matchingStatesList = typedQuery.getResultList();</span></strong><span class="koboSpan" id="kobo.1071.1">
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
  //getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.1072.1">The preceding example is equivalent to the JPQL example we saw earlier in this chapter. </span><span class="koboSpan" id="kobo.1072.2">This example, however, takes advantage of the </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1073.1">Criteria API instead of relying </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">on JPQL.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">When writing code using the</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1076.1"> Criteria API, the first thing we need to do is to obtain an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">jakarta.persistence.criteria.CriteriaBuilder </span></strong><span class="koboSpan" id="kobo.1078.1">interface. </span><span class="koboSpan" id="kobo.1078.2">As we can see in the preceding example, we need to obtain said instance by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">getCriteriaBuilder()</span></strong><span class="koboSpan" id="kobo.1080.1"> method on </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">EntityManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1084.1">From our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1086.1"> implementation, we need to obtain an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">jakarta.persistence.criteria.CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1088.1"> interface. </span><span class="koboSpan" id="kobo.1088.2">We do this by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">createQuery()</span></strong><span class="koboSpan" id="kobo.1090.1"> method in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1092.1"> implementation. </span><span class="koboSpan" id="kobo.1092.2">Notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1094.1"> is generically typed. </span><span class="koboSpan" id="kobo.1094.2">The generic type argument dictates the type of result that our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1096.1"> implementation will return upon execution. </span><span class="koboSpan" id="kobo.1096.2">By taking advantage of generics in this way, the Criteria API allows us to write </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">type-safe code.</span></span></p>
<p><span class="koboSpan" id="kobo.1098.1">Once we have obtained a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1100.1"> implementation, from it we can obtain an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">jakarta.persistence.criteria.Root</span></strong><span class="koboSpan" id="kobo.1102.1"> interface. </span><span class="koboSpan" id="kobo.1102.2">The Root implementation dictates what Jakarta Persistence entity we will be querying from. </span><span class="koboSpan" id="kobo.1102.3">It is analogous to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">FROM</span></strong><span class="koboSpan" id="kobo.1104.1"> query in JPQL (</span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">and SQL).</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">The next two lines in our example take advantage of another feature of the Jakarta Persistence specification, the </span><strong class="bold"><span class="koboSpan" id="kobo.1107.1">Metamodel API</span></strong><span class="koboSpan" id="kobo.1108.1">. </span><span class="koboSpan" id="kobo.1108.2">In</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1109.1"> order to take advantage of the Metamodel API, we need to obtain an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">jakarta.persistence.metamodel.Metamodel</span></strong><span class="koboSpan" id="kobo.1111.1"> interface by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">getMetamodel()</span></strong><span class="koboSpan" id="kobo.1113.1"> method on </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">EntityManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1117.1">From our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">Metamodel</span></strong><span class="koboSpan" id="kobo.1119.1"> implementation, we can obtain a generically typed instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">jakarta.persistence.metamodel.EntityType</span></strong><span class="koboSpan" id="kobo.1121.1"> interface. </span><span class="koboSpan" id="kobo.1121.2">The generic type argument indicates the Jakarta Persistence entity our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">EntityType</span></strong><span class="koboSpan" id="kobo.1123.1"> implementation corresponds to. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">EntityType</span></strong><span class="koboSpan" id="kobo.1125.1"> allows us to browse the persistent attributes of our Jakarta Persistence entities at runtime. </span><span class="koboSpan" id="kobo.1125.2">Which is exactly what we do in the next line in our example. </span><span class="koboSpan" id="kobo.1125.3">In our case, we are getting an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1127.1">, which maps to a simple, singular attribute in our Jakarta Persistence entity. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">EntityType</span></strong><span class="koboSpan" id="kobo.1129.1"> has methods to obtain attributes that map to collections, sets, lists, and maps. </span><span class="koboSpan" id="kobo.1129.2">Obtaining these types of attributes is very similar to obtaining a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1131.1">, therefore we won’t be covering those directly. </span><span class="koboSpan" id="kobo.1131.2">Please refer to the Jakarta EE API documentation at </span><a href="https://jakarta.ee/specifications/platform/10/apidocs/"><span class="koboSpan" id="kobo.1132.1">https://jakarta.ee/specifications/platform/10/apidocs/</span></a><span class="koboSpan" id="kobo.1133.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.1135.1">As we can see in our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1137.1"> contains two generic type arguments. </span><span class="koboSpan" id="kobo.1137.2">The first argument dictates the Jakarta Persistence entity we are working with, and the second one indicates the type of the attribute. </span><span class="koboSpan" id="kobo.1137.3">We obtain our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1139.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">getDeclaredSingularAttribute()</span></strong><span class="koboSpan" id="kobo.1141.1"> method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">EntityType</span></strong><span class="koboSpan" id="kobo.1143.1"> implementation, and passing the attribute name (as declared in our Jakarta Persistence entity) as </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">a String.</span></span></p>
<p><span class="koboSpan" id="kobo.1145.1">Once we have obtained our  </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1147.1"> implementation, we need to obtain an import </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">jakarta.persistence.criteria.Path</span></strong><span class="koboSpan" id="kobo.1149.1"> implementation by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">get()</span></strong><span class="koboSpan" id="kobo.1151.1"> method in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">Root</span></strong><span class="koboSpan" id="kobo.1153.1"> instance, and passing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">SingularAttribute</span></strong><span class="koboSpan" id="kobo.1155.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1157.1">In our example, we will get a list of all the “new” states in the United States (that is, all states whose names start with “New”). </span><span class="koboSpan" id="kobo.1157.2">This, of course, is a job for a “like” condition. </span><span class="koboSpan" id="kobo.1157.3">We can do this with the Criteria API by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">like()</span></strong><span class="koboSpan" id="kobo.1159.1"> method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1161.1"> implementation. </span><span class="koboSpan" id="kobo.1161.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">like()</span></strong><span class="koboSpan" id="kobo.1163.1"> method takes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">Path</span></strong><span class="koboSpan" id="kobo.1165.1"> implementation as its first parameter, and the value to search for as its </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">second parameter.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1168.1"> has a number of methods that are analogous to SQL and JPQL clauses such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">equals(),</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">greaterThan()</span></strong><span class="koboSpan" id="kobo.1171.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">lessThan()</span></strong><span class="koboSpan" id="kobo.1173.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">and()</span></strong><span class="koboSpan" id="kobo.1175.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">or()</span></strong><span class="koboSpan" id="kobo.1177.1">, and so on and so forth (for the complete list, refer to the online Jakarta EE documentation). </span><span class="koboSpan" id="kobo.1177.2">These methods can be combined to</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1178.1"> create complex queries via the </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">Criteria API.</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">like()</span></strong><span class="koboSpan" id="kobo.1182.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1184.1"> returns an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">jakarta.persistence.criteria.Predicate</span></strong><span class="koboSpan" id="kobo.1186.1"> interface, which we need to pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">where()</span></strong><span class="koboSpan" id="kobo.1188.1"> method in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1190.1"> implementation. </span><span class="koboSpan" id="kobo.1190.2">This method returns a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1192.1">, which we assign to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">criteriaBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.1195.1">At this point, we are ready to build our query. </span><span class="koboSpan" id="kobo.1195.2">When working with the Criteria API, we deal with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">jakarta.persistence.TypedQuery</span></strong><span class="koboSpan" id="kobo.1197.1"> interface, which can be thought of as a type-safe version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Query</span></strong><span class="koboSpan" id="kobo.1199.1"> interface we use with JPQL. </span><span class="koboSpan" id="kobo.1199.2">We obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">TypedQuery</span></strong><span class="koboSpan" id="kobo.1201.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">createQuery()</span></strong><span class="koboSpan" id="kobo.1203.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">EntityManager</span></strong><span class="koboSpan" id="kobo.1205.1">, and passing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">CriteriaQuery</span></strong><span class="koboSpan" id="kobo.1207.1"> implementation as </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">To obtain our query results as a list, we simply invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">getResultList()</span></strong><span class="koboSpan" id="kobo.1211.1"> on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">TypedQuery</span></strong><span class="koboSpan" id="kobo.1213.1"> implementation. </span><span class="koboSpan" id="kobo.1213.2">It is worth reiterating that the Criteria API is type safe, therefore attempting to assign the results of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">getResultList()</span></strong><span class="koboSpan" id="kobo.1215.1"> to a List of the wrong type would result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">compilation error.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1"> Let’s look into how we can update data with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">Criteria API.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1219.1">Updating data with the Criteria API</span></h2>
<p><span class="koboSpan" id="kobo.1220.1">We can </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1221.1">update database data using the Criteria API using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">CriteriaUpdate</span></strong><span class="koboSpan" id="kobo.1223.1"> interface. </span><span class="koboSpan" id="kobo.1223.2">The </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1224.1">following example illustrates how to </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">do so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1226.1">
package com.ensode.jakartaeebook.criteriaupdate.namedbean;
//imports omitted for brevity
@Named
@RequestScoped
public class CriteriaUpdateDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  @Resource
  private UserTransaction userTransaction
  private int updatedRows;
  public String updateData() {
    String retVal = "confirmation";
    try {
      userTransaction.begin();
      insertTempData();
      </span><strong class="bold"><span class="koboSpan" id="kobo.1227.1">CriteriaBuilder criteriaBuilder =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1228.1">        entityManager.getCriteriaBuilder();</span></strong><span class="koboSpan" id="kobo.1229.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1230.1">CriteriaUpdate&lt;Address&gt; criteriaUpdate =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1231.1">        criteriaBuilder.createCriteriaUpdate(Address.class);</span></strong><span class="koboSpan" id="kobo.1232.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1233.1">Root&lt;Address&gt; root = criteriaUpdate.from(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1234.1">          Address.class);</span></strong><span class="koboSpan" id="kobo.1235.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">criteriaUpdate.set("city", "New York");</span></strong><span class="koboSpan" id="kobo.1237.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1238.1">criteriaUpdate.where(criteriaBuilder.equal(</span></strong><span class="koboSpan" id="kobo.1239.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.1240.1">root.get("city"), "New Yorc"));</span></strong><span class="koboSpan" id="kobo.1241.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1242.1">Query query = entityManager.createQuery(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1243.1">          criteriaUpdate);</span></strong><span class="koboSpan" id="kobo.1244.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1245.1">updatedRows = query.executeUpdate();</span></strong><span class="koboSpan" id="kobo.1246.1">
      userTransaction.commit();
    } catch (Exception e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
 //getters and setters omitted
  private void insertTempData() throws Exception {
    //method body omitted
  }
}</span></pre> <p><span class="koboSpan" id="kobo.1247.1">What this</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1248.1"> example is doing is finding all of the database rows with entries of a </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1249.1">city called “New Yorc” (a typo), and replacing the value with the correct spelling of “</span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">New York”.</span></span></p>
<p><span class="koboSpan" id="kobo.1251.1">Just like in the previous example, we obtain an instance of a class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1253.1"> interface by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">getCriteriaBuilder()</span></strong><span class="koboSpan" id="kobo.1255.1"> method on our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">EntityManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.1258.1">We then obtain an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">CriteriaUpdate</span></strong><span class="koboSpan" id="kobo.1260.1"> by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">createCriteriaUpdate()</span></strong><span class="koboSpan" id="kobo.1262.1"> on our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">CriteriaBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.1265.1">The next step is to obtain an instance of a class implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Root</span></strong><span class="koboSpan" id="kobo.1267.1"> by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">from()</span></strong><span class="koboSpan" id="kobo.1269.1"> method on our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">CriteriaUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.1272.1">We then invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">set()</span></strong><span class="koboSpan" id="kobo.1274.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">CriteriaUpdate</span></strong><span class="koboSpan" id="kobo.1276.1"> to specify the new values our rows will have after they have been updated. </span><span class="koboSpan" id="kobo.1276.2">The first parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">set()</span></strong><span class="koboSpan" id="kobo.1278.1"> method must be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">String</span></strong><span class="koboSpan" id="kobo.1280.1"> matching the property name in the Entity class, and the second parameter must be the </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">new value.</span></span></p>
<p><span class="koboSpan" id="kobo.1282.1">At this point, we build the where clause by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">where()</span></strong><span class="koboSpan" id="kobo.1284.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">CriteriaUpdate</span></strong><span class="koboSpan" id="kobo.1286.1">, and passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">Predicate</span></strong><span class="koboSpan" id="kobo.1288.1"> returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">equal()</span></strong><span class="koboSpan" id="kobo.1290.1"> method invoked </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">CriteriaBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1294.1">Then we get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">Query</span></strong><span class="koboSpan" id="kobo.1296.1"> implementation by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">createQuery()</span></strong><span class="koboSpan" id="kobo.1298.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">EntityManager</span></strong><span class="koboSpan" id="kobo.1300.1">, and passing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">CriteriaUpdate</span></strong><span class="koboSpan" id="kobo.1302.1"> instance as </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">a parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">Finally, we</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1305.1"> execute our query as usual by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">executeUpdate()</span></strong><span class="koboSpan" id="kobo.1307.1"> on </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1308.1">our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1"> implementation.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1311.1">Deleting data with the Criteria API</span></h2>
<p><span class="koboSpan" id="kobo.1312.1">We can </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1313.1">delete database data with the Jakarta Persistence</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1314.1"> Criteria API. </span><span class="koboSpan" id="kobo.1314.2">This can be done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">CriteriaDelete</span></strong><span class="koboSpan" id="kobo.1316.1"> interface. </span><span class="koboSpan" id="kobo.1316.2">The following code snippet illustrates </span><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">its usage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1318.1">
package com.ensode.jakartaeebook.criteriadelete.namedbean;
//imports omitted
@Named
@RequestScoped
public class CriteriaDeleteDemoBean {
  @PersistenceContext
  private EntityManager entityManager;
  @Resource
  private UserTransaction userTransaction;
  private int deletedRows;
  public String deleteData() {
    String retVal = "confirmation";
    try {
      userTransaction.begin();
</span><strong class="bold"><span class="koboSpan" id="kobo.1319.1">      CriteriaBuilder criteriaBuilder =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1320.1">        entityManager.getCriteriaBuilder();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1321.1">      CriteriaDelete&lt;Address&gt; criteriaDelete</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1322.1">        </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1323.1">= criteriaBuilder.createCriteriaDelete(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1324.1">          Address.class);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1325.1">      Root&lt;Address&gt; root = criteriaDelete.from(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1326.1">        Address.class);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1327.1">      criteriaDelete.where(criteriaBuilder.or(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1328.1">        criteriaBuilder.equal(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1329.1">          root.get("city"), "New York"),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1330.1">          criteriaBuilder.equal(root.get("city"),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1331.1">              "New York")));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1332.1">      Query query = entityManager.createQuery(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1333.1">        </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1334.1">criteriaDelete);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1335.1">      deletedRows = query.executeUpdate();</span></strong><span class="koboSpan" id="kobo.1336.1">
      userTransaction.commit();
    } catch (HeuristicMixedException
            | HeuristicRollbackException
            | NotSupportedException
            | RollbackException
            | SystemException
            | IllegalStateException
            | SecurityException e) {
      retVal = "error";
      e.printStackTrace();
    }
    return retVal;
  }
  //getters and setters omitted
}</span></pre> <p><span class="koboSpan" id="kobo.1337.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">CriteriaDelete</span></strong><span class="koboSpan" id="kobo.1339.1">, we first obtain an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1341.1"> as usual, then invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">createCriteriaDelete()</span></strong><span class="koboSpan" id="kobo.1343.1"> method on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">CriteriaBuilder</span></strong><span class="koboSpan" id="kobo.1345.1"> instance to obtain an implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">CriteriaDelete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">Once we have an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">CriteriaDelete</span></strong><span class="koboSpan" id="kobo.1351.1">, we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">where </span></strong><span class="koboSpan" id="kobo.1353.1">clause as it is usually done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">Criteria API.</span></span></p>
<p><span class="koboSpan" id="kobo.1355.1">Once we have </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1356.1">built our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">where </span></strong><span class="koboSpan" id="kobo.1358.1">clause, we obtain an implementation </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1359.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">Query</span></strong><span class="koboSpan" id="kobo.1361.1"> interface and invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">executeUpdate()</span></strong><span class="koboSpan" id="kobo.1363.1"> on it </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">as usual.</span></span></p>
<p><span class="koboSpan" id="kobo.1365.1">Now that we’ve seen how to insert and retrieve database data, we’ll turn our attention to data validation via </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">Bean Validation.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1367.1">Bean Validation support</span></h1>
<p><span class="koboSpan" id="kobo.1368.1">Bean Validation</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1369.1"> is a Jakarta EE specification consisting of a number of annotations used to simplify data validation. </span><span class="koboSpan" id="kobo.1369.2">Jakarta Persistence Bean Validation support allows us to annotate our entities with Bean Validation annotations. </span><span class="koboSpan" id="kobo.1369.3">These annotations allow us to easily validate user input and perform </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">data sanitation.</span></span></p>
<p><span class="koboSpan" id="kobo.1371.1">Taking advantage of Bean Validation is very simple. </span><span class="koboSpan" id="kobo.1371.2">All we need to do is annotate our Jakarta Persistence Entity fields or getter methods with any of the validation annotations defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">jakarta.validation.constraints</span></strong><span class="koboSpan" id="kobo.1373.1"> package. </span><span class="koboSpan" id="kobo.1373.2">Once our fields are annotated as appropriate, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">EntityManager</span></strong><span class="koboSpan" id="kobo.1375.1"> will prevent non-validating data from </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">being persisted.</span></span></p>
<p><span class="koboSpan" id="kobo.1377.1">The following code</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1378.1"> example is a modified version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">Customer</span></strong><span class="koboSpan" id="kobo.1380.1"> Jakarta Persistence entity we saw earlier in this chapter. </span><span class="koboSpan" id="kobo.1380.2">It has been modified to take advantage of Bean Validation in some of </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">its fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1382.1">
package com.ensode.jakartaeebook.beanvalidation.entity;
//imports omitted for brevity
@Entity
@Table(name = "CUSTOMERS")
</span><strong class="bold"><span class="koboSpan" id="kobo.1383.1">public class Customer implements Serializable {</span></strong><span class="koboSpan" id="kobo.1384.1">
  @Id
  @Column(name = "CUSTOMER_ID")
</span><strong class="bold"><span class="koboSpan" id="kobo.1385.1">  private Long customerId;</span></strong><span class="koboSpan" id="kobo.1386.1">
  @Column(name = "FIRST_NAME")
  </span><strong class="bold"><span class="koboSpan" id="kobo.1387.1">@NotNull</span></strong><span class="koboSpan" id="kobo.1388.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1389.1">@Size(min = 2, max = 20)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1390.1">  private String firstName;</span></strong><span class="koboSpan" id="kobo.1391.1">
  @Column(name = "LAST_NAME")
  </span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">@NotNull</span></strong><span class="koboSpan" id="kobo.1393.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1394.1">@Size(min = 2, max = 20)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1395.1">  private String lastName;</span></strong><span class="koboSpan" id="kobo.1396.1">
  private String email;
  // getters and setters omitted for brevity
}</span></pre> <p><span class="koboSpan" id="kobo.1397.1">In this example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">@NotNull</span></strong><span class="koboSpan" id="kobo.1399.1"> annotation to prevent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">firstName</span></strong><span class="koboSpan" id="kobo.1401.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">lastName</span></strong><span class="koboSpan" id="kobo.1403.1"> of our entity from being persisted with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">null</span></strong><span class="koboSpan" id="kobo.1405.1"> values. </span><span class="koboSpan" id="kobo.1405.2">We also used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">@Size</span></strong><span class="koboSpan" id="kobo.1407.1"> annotation to restrict the minimum and maximum length of </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">these fields.</span></span></p>
<p><span class="koboSpan" id="kobo.1409.1">That is all we need to do to take advantage of bean validation in Jakarta Persistence. </span><span class="koboSpan" id="kobo.1409.2">If our code attempts to persist or update an instance of our entity that does not pass the declared validation, an exception of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">jakarta.validation.ConstraintViolationException</span></strong><span class="koboSpan" id="kobo.1411.1"> will be thrown, and the entity will not </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">be persisted.</span></span></p>
<p><span class="koboSpan" id="kobo.1413.1">As we can see Bean Validation pretty much automates data validation, freeing us from having to manually write </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">validation code.</span></span></p>
<p><span class="koboSpan" id="kobo.1415.1">In addition to the </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1416.1">two annotations discussed in the previous example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">jakarta.validation.constraints</span></strong><span class="koboSpan" id="kobo.1418.1"> package contains several additional annotations we can use to automate validation on our Jakarta Persistence entities. </span><span class="koboSpan" id="kobo.1418.2">Please refer to the online Jakarta EE 10 API for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">complete list.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.1420.1">Final notes</span></h1>
<p><span class="koboSpan" id="kobo.1421.1">In the examples for this chapter, we demonstrated database access directly from CDI named beans serving as controllers. </span><span class="koboSpan" id="kobo.1421.2">We did this to get the point across without bogging ourselves down with details; however, in general, this is not a good practice. </span><span class="koboSpan" id="kobo.1421.3">Database access code should be encapsulated</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1422.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.1423.1">Data Access </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1424.1">Objects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1426.1">DAOs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1428.1">DAO design pattern</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1429.1">For more information on the </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.1430.1">DAO design pattern, </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">see </span></span><a href="http://www.oracle.com/technetwork/java/dao-138818.html"><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">http://www.oracle.com/technetwork/java/dao-138818.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1433.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1434.1">Named beans typically assume the role of controllers and/or models when using the </span><strong class="bold"><span class="koboSpan" id="kobo.1435.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.1436.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1437.1">MVC</span></strong><span class="koboSpan" id="kobo.1438.1">) design pattern, a</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1439.1"> practice so common that it has become a de-facto standard for Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">EE applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1441.1">MVC design pattern</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1442.1">For more information about the </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.1443.1">MVC design pattern, </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">see </span></span><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1447.1">Additionally, we chose not to show any user interface code in our examples as it was irrelevant to the topic at hand. </span><span class="koboSpan" id="kobo.1447.2">However, the code downloads for this chapter include Jakarta Faces pages that invoke the named beans in this chapter and display a confirmation page once the named-bean </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">invocation finishes.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1449.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1450.1">This chapter covered how to access data in a database via Jakarta Persistence, the standard object-relational mapping API of </span><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">Jakarta EE.</span></span></p>
<p><span class="koboSpan" id="kobo.1452.1">In this chapter, we covered the </span><span class="No-Break"><span class="koboSpan" id="kobo.1453.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1454.1">How to mark a Java class as a Jakarta Persistence entity by decorating it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">@Entity</span></strong><span class="koboSpan" id="kobo.1456.1"> annotation, and how to map it to a database table via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">@Table</span></strong><span class="koboSpan" id="kobo.1458.1"> annotation. </span><span class="koboSpan" id="kobo.1458.2">We also covered how to map entity fields to database columns via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">Column</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1"> annotation.</span></span></li>
<li><span class="koboSpan" id="kobo.1462.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">jakarta.persistence.EntityManager</span></strong><span class="koboSpan" id="kobo.1464.1"> interface to find, persist, and update Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">Persistence entities.</span></span></li>
<li><span class="koboSpan" id="kobo.1466.1">How to define unidirectional and bidirectional one-to-one, one-to-many, and many-to-many relationships between Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1">Persistence entities.</span></span></li>
<li><span class="koboSpan" id="kobo.1468.1">How to use composite primary keys by developing custom primary </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">key classes.</span></span></li>
<li><span class="koboSpan" id="kobo.1470.1">How to retrieve entities from a database by using the </span><strong class="bold"><span class="koboSpan" id="kobo.1471.1">Jakarta Persistence Query Language</span></strong><span class="koboSpan" id="kobo.1472.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1473.1">JPQL</span></strong><span class="koboSpan" id="kobo.1474.1">) and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">Criteria API.</span></span></li>
<li><span class="koboSpan" id="kobo.1476.1">Bean Validation, which allows us to easily validate input by simply annotating our Jakarta Persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.1477.1">entity fields.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1478.1">Jakarta Persistence abstracts out database access code and allows us to code against Java objects as opposed to database tables. </span><span class="koboSpan" id="kobo.1478.2">It also works with every popular RDBMS system, making our code easily portable across different relational database </span><span class="No-Break"><span class="koboSpan" id="kobo.1479.1">management systems.</span></span></p>
</div>
</body></html>