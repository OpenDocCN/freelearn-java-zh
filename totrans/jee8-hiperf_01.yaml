- en: Money – The Quote Manager Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before working on evaluating and enhancing the performance of your application,
    you need to indeed have an application. In this part, we will create a small application
    that we will use to illustrate every part of the book. This chapter doesn't intend
    to explain all the steps required to create a Java EE application. It will give
    you the overall steps and ensure that the references to the steps will be obvious
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use case of this application will be a microservice that provides a set
    of web services to manage stocks and shares. This chapter will, therefore, introduce
    you to the application environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Application code structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing data over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting with writing code, make sure that you have an environment ready
    to work with Java EE. We need a **Java Virtual Machine 8** (**JVM 8**) and, more
    particularly, the **Java Development Kit** **8** (**JDK** **8**). As a quick reminder,
    Java EE version *V* is based on **Java Standalone Edition** (**Java SE**) version
    *V* as well. You can download the JDK on the Oracle website ([http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can download the OpenJDK version of the JDK on the OpenJDK
    project website ([http://openjdk.java.net/install/](http://openjdk.java.net/install/)),
    but I recommend that you use the Oracle version. We will discuss this later in
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to accept the license agreement and select the right distribution
    for your operating system (Windows, Linux, or macOS).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a JDK, we need a tool to build our application and convert
    it into a format that we will be able to deploy in our Java EE server. This book
    will use Apache Maven ([https://maven.apache.org/](https://maven.apache.org/)) to
    build the application. It can be downloaded on the Apache Maven download page
    ([https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)).
    We need the binary distribution; Linux users have to select the `tar.gz` format
    while Windows users have to select the `.zip` archive.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have everything we need to create our application. You will
    probably want to have an **Integrated Development Environme****nt** (**IDE**),
    such as NetBeans ([https://netbeans.org/](https://netbeans.org/)), Eclipse ([https://eclipse.org/ide/](https://eclipse.org/ide/)),
    or Intellij Idea ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)).
    Since this book is more about performance than development, we won't go into much
    detail about IDEs. If you need one, just select the one you are the most familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the environment is ready, we will set variables to define where
    to find the software without having to use the full path to the binary or script
    each time. `JAVA_HOME` will point to the folder you extracted from the JDK, and
    `MAVEN_HOME` will point to the folder you extracted from the Apache Maven archive.
    Here is an example for Linux (replace `export` with `set` for a DOS shell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to ensure that the JDK and Maven tools are available. For this,
    we add them to `PATH` on Linux and `Path` on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can validate your setup by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To run a Java EE application, we also need a container, such as GlassFish, WildFly,
    WebSphere Liberty Profile, or Apache TomEE. The deployment being specific and
    Java EE 8 being very recent, we will use GlassFish in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to get everything ready, we will use a database. We will use MySQL
    as a very common case, but any other relational database will work as well. You
    can download MySQL from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/),
    but most Linux distributions will have a package ready to install. For instance,
    on Ubuntu you can just execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application will import some stock quotations daily; it will then expose
    them and allow you to update them through a web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement it, we will use a standard Java EE architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The persistence layer will use JPA 2.2 and store the data in a MySQL database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A service layer will implement the business logic and orchestrate the persistence
    layer. It will rely on the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Transaction API** (**JTA**) 1.2 for transactionality'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context and Dependency Injection** 2.0 (**CDI**) for **Inversion of Control**
    (**IoC**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Validation 2.0 for validations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A front layer will expose a part of the service layer through HTTP. It will
    rely on the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS 2.1 for stateless endpoints
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket 1.1 for stateful communications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-B 1.0 for marshalling/unmarshalling
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a picture summarizing this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae41dfe2-23c1-40d1-8b26-2005e62ebb7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Application project highlights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to create and run this application, we will need to set up a build
    tool. For this book, it will be Apache Maven; however, Gradle, Ant, or any other
    alternative will work perfectly as well. We will then identify some key parts
    of the application code and, finally, we will insert some data to ensure that
    our application is usable before investigating its performance.
  prefs: []
  type: TYPE_NORMAL
- en: The build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only dependency Java EE requires is the Java EE API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer, you can indeed register all the individual specifications, but
    it will require more work to maintain the list with Java EE upgrades. For this
    reason, the bundle is often preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the point is to ensure that the API is provided, which means it will not
    be packaged in the deliverable and will inherit from the server API. The server
    providing the services associated with the API also provides the API with the
    right supported version and the right defaults matching the built-in implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java EE 6, there are two main flavors of Java EE: the web profile and
    the full profile. The web profile is a light version, with only half the specifications
    compared with the full profile, more or less. The web profile supports only web
    applications and, therefore, `war` files. Most of this book will work with a web
    profile server, so we will package our application as `war`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need Java 8, don''t forget to configure the Java source and target
    version in the build. It can be done in different ways, but configuring `maven-compiler-plugin` as
    follows is an efficient one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our data model will be simple: a *quote* will be linked to a *customer*. This
    means that a *customer* can see a set of *quotes*, and *quotes* can be seen by
    a set of customers. In terms of use cases, we want to be able to monetize our
    API and make the customers pay to access some quote prices. To do so, we will
    need a sort of whitelist of quotes per customer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA uses a descriptor called `persistence.xml`, placed in the META-INF repository
    of resources (or WEB-INF), which defines how `EntityManager`, which is a class
    that allows the manipulation of our model, will be instantiated. Here is what
    it looks like for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The link between the database and the Java code is done through entities. An
    entity is a **plain old java object** (**POJO**) that is decorated with the `javax.persistence`
    annotations. They mainly define the mapping between the database and the Java
    model. For instance, `@Id` marks a Java field that must match the database identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of our `Quote` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This simple model implicitly defines a *QUOTE* table with three columns, *ID,
    NAME,* and *VALUE* (the casing can depend on the database), and a table to manage
    the relationship with the *CUSTOMER* table, which is named  `QUOTE_CUSTOMER` by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same spirit, our `Customer` entity just defines an identifier and name
    as columns and also the reverse relationship to the `Quote` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What is important here is to notice the relationships in the model. We will
    deal with this later on.
  prefs: []
  type: TYPE_NORMAL
- en: The service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the book being to discuss the performance and not how to write a
    Java EE application, we will not detail the whole service layer here. However,
    to ensure a common knowledge of what we are dealing with, we will illustrate the
    code with one service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using JTA 1.2 with JPA 2.2 to establish a link between our database
    and the Java model. The `QuoteService` bean, responsible for managing the `Quote`
    persistence, can therefore look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: JPA may or may not be used in a transactional context, depending on the kind
    of operation you do. When you *read* data, you can often do it without any transaction
    until you need some lazy loading. However, when you *write* data (insert/update/delete
    entities), JPA requires a running transaction to be able to execute the action.
    This is to ensure consistency of data but also has some implications on the code.
    To respect that requirement, and have an active transaction, we use `@Transactional` on
    methods instead of relying on **Enterprise Java Bean** **3.2** (**EJB 3.2**),
    so we can reuse the power of CDI (`@ApplicationScoped`, for instance, which will
    avoid creating a new instance per injection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our finders are very simple and directly use the `EntityManager` API. The only
    new thing Java 8 brings us in this code is the ability to wrap the result with
    `Optional` which offers a programmatic way to deal with the presence or absense
    of the entity instead of relying on a null check. Concretely, the caller can use
    our finder this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This kind of code hides the conditional branches behind a fluent API, which
    makes it more expressive and readable, while the lambdas stay small enough.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used inline queries in this code, not static ones like in the `@NamedQuery`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The JAX-RS layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we step back one second and think about which stopover the application will
    execute, we can identify a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP communication handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload (un)marshalling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of the separation of concern principles, or simply for technical constraints
    between layers, it is very common to use a Data Transfer Object between the JAX-RS/front
    layer and the CDI/business layer. Of course, this statement can be applied to
    the business sub-layers as well, but in the case of this book, we will just do
    it in the JAX-RS layer. To make it obvious in the book, we will prefix the JAX-RS
    model with `Json`. Check out the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, the front layer role is to delegate most of the logic to the
    service layer and convert the business model to the front model (it can almost
    be seen as a Java to JavaScript conversion for a lot of modern applications):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We set the JAX-RS `@ApplicationPath` to `/api` to ensure that our endpoints
    are deployed under the `/api` subcontext.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why use JAX-RS and WebSocket? Don't they serve the same purpose? Not exactly,
    in fact, it is becoming more and more common to use both in the same application
    even if WebSocket is still a bit recent.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS (and, more generally, HTTP/1 and the brand new HTTP/2) is generally web
    application oriented. Understand that it is often used for applications with a
    user interface (which needs to be compatible with all browsers). It is also commonly
    used in environments where you cannot assume much about the network setup. More
    particularly, in environments where you cannot assume the network setup, the proxies
    will let WebSocket connections work properly (either preventing them completely
    or disconnecting them too early). The last common case where HTTP-based solutions
    make a lot of sense is to try to target a market where clients can be developed
    in any language (Java, Python, Ruby, Go, Node.js, and so on). The fact that the
    technology is today spreading all over the world and works well with stateless
    connections, makes it easier to get started with, and it is therefore more accessible
    than WebSocket, which requires some care from client developers.
  prefs: []
  type: TYPE_NORMAL
- en: However, WebSocket will fit cases where you have higher performance or reactivity
    constraints, a state to maintain in order to handle the business use case, or
    you simply want to push the information from the server without requiring a client
    operation (such as polling).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start using a connected protocol such as WebSocket, the first thing
    to define is your own communication protocol: the format of the message you send/receive
    and the order of the messages (if needed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our WebSocket layer will be responsible for enabling a client to quickly access the quote prices.
    Therefore, we will react on a client''s request (it will contain the name of the quote
    that we want to get the price for) and we will respond with two pieces of information:
    whether we found the quote and the current price, if existing.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to pick a format to prepare the content sent through the WebSocket
    over the wire. Here, the choice is often guided by a trade-off between the client
    (consumers of the service), the requirements, the performances, and the ease of
    implementation. In our case, we will consider that our clients can be written
    in Java as well as in JavaScript. That is why we will use JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the protocol, here is a full communication round-trip, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/047d3c1b-cce8-44cd-96bb-a5cc090c638c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The communication protocol is based on a single message type in our case, so
    a full client/server communication looks like these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The client will connect to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client will request the price of a quote N times, based on its symbol (name/identifier).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming there is no I/O error or timeout, the client will trigger a disconnect,
    which will end the communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we need multiple bricks of Java EE and we need the following
    to put them together:'
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket API, obviously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-B (we could use JSON-P, but it is less friendly) for the Java to JSON conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI, to link the WebSocket to the business layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start easy, we can modelize our payloads. Our request has only one `name`
    attribute, so JSON-B allows us to define it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other side (that is, the response), we have to return a `value` attribute
    with the price of the quote and a `found` Boolean marking `value` as filled or
    not. Here again, JSON-B allows us to do a direct mapping of this model with a
    plain POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to ensure that the WebSocket will be able to deserialize and serialize these
    objects as required. The specification defines `Encoder` and `Decoder` APIs for
    this purpose. Since we will back our implementation by JSON-B, we can directly
    implement it using the (I/O) stream flavors of these APIs (called `TextStream`).
    Actually, before doing so, we need to get a `Jsonb` instance. Considering that
    we have already created one and made it available in CDI, we can then simply inject
    the instance in our coders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The decoding side is now fast to develop, thanks to the JSON-B API, which fits
    this usage very well with its `fromJson()` API. We will just note that this side
    is specific to `ValueRequest`*,* since we need to specify the type to instantiate
    it (compared with the encoding side, which can determine it dynamically):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a way to handle our messages, we need to bind our WebSocket
    endpoint and implement the `@OnMessage` method to find the price and send it back
    to the client relying on our business layer. In terms of implementation, we will
    react to a `ValueRequest` message, try to find the corresponding quote, fill the
    response payload, and send it back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Provision some data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have our application. Now, we need to ensure that it has some
    data and, then, move on to evaluating its performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without delving too much into the business details, we will implement the provisioning
    in two passes:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all the symbols to update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each symbol found, update the price in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do so, we will use two public webservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv](http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv),
    to find a set of symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://query1.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=financialData](https://query1.finance.yahoo.com/v10/finance/quoteSummary/%7Bsymbol%7D?modules=financialData),
    to find the current price of each quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one is a plain CSV file, which we will parse without any library to
    keep things simple and because the format does not require special escaping/parsing. The
    second one will return a JSON payload, which we can read directly using the JAX-RS
    2.1 client API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can retrieve our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we directly read a buffered reader backed by the HTTP response stream. Once
    the symbols are extracted, we can simply iterate over them and request the price
    of each quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code sends an HTTP request, thanks to the JAX-RS client API and
    JSON-B, which unmarshalls a data model. Then, we use the obtained data to update
    our database quote if it already exists; otherwise, we use the data to create
    the database quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code now needs to be wired to be executed. We have multiple options here:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute it at startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute it regularly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute it when an endpoint is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of this book, we will use the first two options. The startup
    is common for us, even if it is not as realistic, because once started, we will
    get some data. The second option will use an EJB 3.2 `@Schedule`, which will run
    hourly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The startup implementation requires a simple CDI bean with a method calling
    the previous logic when `@ApplicationScoped` is created (at startup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The scheduling is done, thanks to the Enterprise Java Bean `@Schedule` API,
    which allows us, in one annotation, to request the container to regularly execute
    a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In a real application, you will probably want to configure the refresh frequency
    and use the `TimerService` API to trigger the execution based on the application
    configuration. In the same spirit, the startup execution could be ignored based
    on the configuration in order to have a faster startup.
  prefs: []
  type: TYPE_NORMAL
- en: Application summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working on the performance, it is always important to keep two things
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The application business (what the application does)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application technical stack (how the application was designed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the information you have about these two points is very high-level,
    ensure that you know them before working on the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do this exercise with our application and ensure that we know how to answer
    both the questions.
  prefs: []
  type: TYPE_NORMAL
- en: The application business
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is responsible for providing the quote prices to HTTP or WebSocket
    clients. With its model and customer/quote relationship, it can enable us to provide
    (or not provide) the price accessed by the customer if we add permissions or rules,
    for instance. What is important to see at this stage is that both the entities
    are in a relationship and that our application can visit this relationship for
    its business needs and trigger an implicit lazy loading of the relationship entities.
  prefs: []
  type: TYPE_NORMAL
- en: The data is injected into the system based on two external HTTP sources (CBOE
    and Yahoo). The first one provides a symbol dictionary of the quotes*,* and the
    second one, the prices.
  prefs: []
  type: TYPE_NORMAL
- en: The application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, the provisioning of the quote and prices is done asynchronously
    (not when a customer request is sent). It retrieves the data using a JAX-RS 2.1
    client and inserts it as fast as possible into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Access to the application is gained either through HTTP or WebSocket. In both
    cases, the application uses a JSON format for message exchange.
  prefs: []
  type: TYPE_NORMAL
- en: The application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE defines specifications and, therefore, you can find several different
    implementations. Each major vendor has its own server but, of course, for us and
    Java EE, a lot of servers are fully open source. As Java EE 8 is very recent,
    we will use GlassFish, which is the reference implementation and is therefore
    the first one to be compliant with the specification (it must be released with
    the specification). However, there are a lot of alternatives (such as Apache TomEE,
    Wildfly, Payara, Liberty Profile, and so on), which will probably follow in the
    coming months.
  prefs: []
  type: TYPE_NORMAL
- en: GlassFish can be downloaded from its website ([https://javaee.github.io/glassfish/download](https://javaee.github.io/glassfish/download)). We
    need the 5.x version to target Java EE 8, but due to its early release, a major
    part of this book will work with the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to integrate it with your development environment (and Maven),
    you can add the GlassFish repository to `pom.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the GlassFish plugin without forgetting to specify the version of the server
    in order to override the default one, which is now quite old:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, you can run the following command to package the application as
    `war` and deploy it in GlassFish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To shut down the server, type *X* and *ENTER*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting to work on our application from the performance window, let's
    get a bit familiar with it. We will not browse and test all the endpoints but
    just check how to get a price using the JAX-RS layer and WebSocket layer. In other
    words, we will define two customer use cases of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The goal here is to ensure that we know how to use the application to be able
    to write test scenarios later. To do so, we will execute some requests manually
    on both fronts (HTTP and WebSocket).
  prefs: []
  type: TYPE_NORMAL
- en: Get a quote price the JAX-RS way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The endpoint we saw previously has been deployed on `/<application_context>/api/quote/{quoteId}`
    with the context of the web application, `application_context`. If you used the
    previous setup, it is, most likely, the artifact ID of the Maven project. Let's
    consider from now on that it is `quote-manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what it returns for one of the quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This kind of application often needs a kind of index endpoint to be able to
    browse quotes (in a nice user interface or a command-line interface, for instance).
    In our case, it is our *find all* endpoint, which supports pagination through
    the query parameters. Here is how to use it and the kind of data it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Get the price, the WebSocket way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WebSocket endpoint is deployed on `/<application_context>/quote`, and some
    exchanges can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting to see in this communication dump is the fact that the connection
    lasts for more than one request, and it is based on the symbol more than the identifier
    (compared to the previous JAX-RS samples).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the previous parts will work transparently in Glassfish, as it can provide
    you with a default database if none is set since Java EE 7\. This default database is
    an Apache Derby one for Glassfish. Considering that we will work on the performance
    soon, we want a recent *production* database. To ensure this, we will set up MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you installed MySQL for your operating system and that it runs
    on `localhost:3306` (the default), we need to create a new database. Let''s call
    it `quote_manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a database, we can configure it in Glassfish and let JPA 2.2
    create the tables for us based on our model. For this, we need to create `glassfish-resources.xml`
    in the `WEB-INF` folder of the `war` package (put it in `src/main/webapp/WEB-INF`
    in the Maven project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also do it through code using the `@DataSourceDefinition`
    annotation, which is more portable than the specific descriptor of GlassFish (this
    is the solution we will rely on from now on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you recompile and restart the server, you will see that it has created the
    tables, thanks to our `persistence.xml` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are waiting for the server to start and have kept the provisioning activated,
    you will also see some data in the `QUOTE` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have our functional Quote Manager application, and we can deploy it in
    a Java EE 8 server (GlassFish here) and store our data in a *real* database (MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have mainly worked on making the application functional. Thanks
    to the high-level APIs of Java EE, this was not so hard, but it is important to
    understand what we used and what the performance implications of each element
    of our stack are, to be able to validate/invalidate the performance figures once
    you have them in your hands.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an application responsible for managing quote prices
    and enabling clients to access them through HTTP and WebSockets. The application
    uses plain Java EE code (no external dependencies). We also saw how to link the
    application to a database. We used MySQL as the database, which is a free and
    very common choice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper into the Java EE stack, and understand
    its role and what it implies for the application in terms of the application's
    performance.
  prefs: []
  type: TYPE_NORMAL
