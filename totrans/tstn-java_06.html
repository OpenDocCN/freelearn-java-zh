<html><head></head><body>
		<div id="_idContainer047">
			<h1 id="_idParaDest-113" class="chapter-number"><a id="_idTextAnchor128"/>6</h1>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor129"/>Methods, Interfaces, Records, and Their Relationships</h1>
			<p>In Java, how we define and organize our code is the cornerstone of the language. In this chapter, we will begin by examining the role that a method plays in Java. From here, we will examine the relationships afforded by inheritance and interface. The immutable <strong class="source-inline">record</strong> class is next up. Polymorphism, the ability to use objects in a hierarchy of classes, as it applies to inheritance and interface, is covered next. We will finish the chapter by looking at the relationships between objects and how they can call upon methods in <span class="No-Break">other objects.</span></p>
			<p>We will learn about the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Understanding methods</span></li>
				<li><span class="No-Break">Understanding inheritance</span></li>
				<li>Understanding the <span class="No-Break">class interface</span></li>
				<li>Understanding the <span class="No-Break"><strong class="source-inline">record</strong></span><span class="No-Break"> class</span></li>
				<li><span class="No-Break">Understanding polymorphism</span></li>
				<li>Understanding composition <span class="No-Break">in classes</span></li>
			</ul>
			<p>By understanding all the components and relationships available in Java, you’ll be able to read or write <span class="No-Break">Java code.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor130"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java <span class="No-Break">17 installed</span></li>
				<li>A <span class="No-Break">text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor131"/>Understanding methods</h1>
			<p>Now, I must admit that I have been coding since 1980, and since then, the term we use to describe discrete <a id="_idIndexMarker412"/>blocks of code has changed. When I started coding in 1980 using <strong class="bold">BASIC</strong>, an unstructured language, I quickly learned to break my code up into subroutines. From BASIC, I moved on to <strong class="bold">Pascal</strong>, where there is a formal designation for blocks of code. These were <strong class="bold">functions</strong> for blocks that returned a result and procedures for blocks that did not return a result. Next up was C, followed by C++. These languages name their blocks of code as functions, as they all, except for the constructor, must return a value. Moving on to Java, these blocks are called methods. Let us examine the components of <span class="No-Break">a method.</span></p>
			<p>When creating a method, you will need to consider some or even all of <span class="No-Break">these components:</span></p>
			<ul>
				<li>Access <span class="No-Break">control designation</span></li>
				<li>Static or non-static designation and the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> reference</span></li>
				<li><span class="No-Break">Override permission</span></li>
				<li><span class="No-Break">Override required</span></li>
				<li><span class="No-Break">Return type</span></li>
				<li><span class="No-Break">Method name</span></li>
				<li><span class="No-Break">Parameter variables</span></li>
				<li><span class="No-Break">Annotations</span></li>
				<li><span class="No-Break">Exception handling</span></li>
				<li><span class="No-Break">Thread setting</span></li>
				<li><span class="No-Break">Generic parameters</span></li>
			</ul>
			<p>Let’s discuss these, one <span class="No-Break">by one.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor132"/>Access control designation</h2>
			<p>In the previous chapter, I presented the concepts of access control, so let us examine how <a id="_idIndexMarker413"/>these concepts can be applied to a method, which <a id="_idIndexMarker414"/>may be private, public, protected, <span class="No-Break">or package:</span></p>
			<ul>
				<li>A private method, using the <strong class="source-inline">private</strong> designation, can only be accessed by non-static methods in the <span class="No-Break">same class:</span><pre class="source-code">
<strong class="source-inline">private void doSomething() { … }</strong></pre></li>
				<li>Public methods can be accessed by non-static methods in the same class. They can also be accessed from any other object in the program that has a reference variable to the object that contains the <span class="No-Break">public method:</span><pre class="source-code">
<strong class="source-inline">public void doSomething() { … }</strong></pre></li>
				<li>Protected methods can be accessed as if they were public from any subclass that inherits them. We will discuss inheritance later in this chapter. A protected member of a class also has package access. Without inheritance and with objects in a different package, <strong class="source-inline">protected</strong> behaves the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">private</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="source-inline">protected void doSomething() { … }</strong></pre></li>
				<li>Package methods in one object can be accessed by another object in the same package that has a reference to it as if it were public. Objects in other packages, if they have the appropriate reference, consider package methods private and cannot <span class="No-Break">access them:</span><pre class="source-code">
<strong class="source-inline">void doSomething() { … } // Package</strong></pre></li>
			</ul>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor133"/>Static or non-static designation and the this reference</h2>
			<p>A <a id="_idIndexMarker415"/>method <a id="_idIndexMarker416"/>is non-static <a id="_idIndexMarker417"/>by default. This means that when the method is invoked, there <a id="_idIndexMarker418"/>is always an undeclared first parameter. If other parameters exist, then this undeclared parameter always comes first. </p>
			<p>The undeclared parameter is a reference to the object invoking the method. Its type is the class, and the identifier <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break">.</span></p>
			<p>To understand this, let us look at some code fragments. Here is a partial class with just one method. Since the field and the method parameter have the same name, we will use the <strong class="source-inline">this</strong> reference to differentiate <span class="No-Break">between them:</span></p>
			<pre class="source-code">
public class StaticTest01 {
   private int value;
   public void nonStaticMethod(int value) {
      this.value = value;
   }
}</pre>
			<p>The <strong class="source-inline">this</strong> reference <a id="_idIndexMarker419"/>comes from the compiler adding it <a id="_idIndexMarker420"/>as the first parameter to the non-static method. Let <a id="_idIndexMarker421"/>us look at how the method appears after the compiler <a id="_idIndexMarker422"/>has added the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> reference:</span></p>
			<pre class="source-code">
public class StaticTest01 {
  private int value;
  public void nonStaticMethod(<strong class="bold">StaticTest01 this,</strong> int value){
     this.value = value;
  }
   …
}</pre>
			<p>We instantiate the object, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
var sTest = new StaticTest01();</pre>
			<p>Then, we call upon its method, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
sTest.nonStaticMethod(42);</pre>
			<p>Then, the method is converted by the compiler <span class="No-Break">as shown:</span></p>
			<pre class="source-code">
sTest.nonStaticMethod(sTest, 42);</pre>
			<p>The <strong class="source-inline">this</strong> reference allows just one block of code for methods regardless of how many instances you create of <span class="No-Break">a class.</span></p>
			<p>You can use the <strong class="source-inline">this</strong> reference in the body of the method, but you cannot declare it. As shown earlier, the most common use of <strong class="source-inline">this</strong> is to distinguish between a field identifier and a local method variable with the same <span class="No-Break">identifier name.</span></p>
			<p>A static <a id="_idIndexMarker423"/>method, the one which you have designated by <a id="_idIndexMarker424"/>adding the <strong class="source-inline">static</strong> keyword to the method, does <a id="_idIndexMarker425"/>not have the <strong class="source-inline">this</strong> reference. This means that you <a id="_idIndexMarker426"/>can call this method without instantiating the object it belongs to first. It also means that it cannot call non-static methods in the same class you declared it in, nor can it access any <span class="No-Break">non-static fields.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor134"/>Override permission – final</h2>
			<p>Inheritance is the creation of new classes derived from an existing class. We will look at this topic <a id="_idIndexMarker427"/>in detail later in this chapter. This means that a method in the derived class or subclass with the same name and the same type and number <a id="_idIndexMarker428"/>of parameters overrides the same method in the parent <span class="No-Break">or superclass.</span></p>
			<p>The <strong class="source-inline">nonStaticMethod</strong> method can be overridden if <strong class="source-inline">StaticTest</strong> is a superclass with an inheritance relationship, but we can prevent this if we add the <strong class="source-inline">final</strong> keyword to the method declaration. Now, we can no longer override <strong class="source-inline">nonStaticMethod</strong>, as shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
public class StaticTest {
   private int value;
   public <strong class="bold">final</strong> void nonStaticMethod(int value) {
      this.value = value;
   }
}</pre>
			<p>We can also use the <strong class="source-inline">final</strong> keyword when we declare the class. This will block this class from being used as a superclass. In other words, you cannot inherit from a <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public final class StaticTest {</pre>
			<p>Now, we cannot extend this class. This also means that all the methods in the class are effectively final, so it is not necessary to use the keyword in <span class="No-Break">method names.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor135"/>Override required – abstract</h2>
			<p>While using or not using the <strong class="source-inline">final</strong> keyword determines whether a method can be overridden <a id="_idIndexMarker429"/>when inheritance is involved, we can also require that the method is overridden. We have just discussed how we can control whether you <a id="_idIndexMarker430"/>can override a method or not. Another choice is to make subclassing mandatory so that you <em class="italic">must</em> override the method. We accomplish this by defining an <strong class="source-inline">abstract</strong> class and declaring abstract methods that do not have any code, as shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
public <strong class="bold">abstract</strong> class ForcedOverrideTest {
   private int value;
   public <strong class="bold">abstract</strong> void nonStaticMethod(int value);
   }
}</pre>
			<p>A class with one or more abstract methods cannot be instantiated. You can only use it as a superclass in inheritance. Therefore, we must also designate the class <span class="No-Break">as abstract.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor136"/>Return type</h2>
			<p>In Java, as with C, all methods return a result. When we declare a method, except for a constructor, we <a id="_idIndexMarker431"/>must show a return type. A return type may be either a <a id="_idIndexMarker432"/>primitive variable or a <span class="No-Break">reference variable.</span></p>
			<p>There is one special return type, and that is <strong class="source-inline">void</strong>. Using <strong class="source-inline">void</strong> means that this method does not have a <strong class="source-inline">return</strong> value and that there cannot be a <strong class="source-inline">return</strong> statement that returns a value in <span class="No-Break">the method:</span></p>
			<ul>
				<li>This method <span class="No-Break">returns nothing:</span><pre class="source-code">
public void doSomething() { … } //</pre></li>
				<li>This method returns <span class="No-Break">a primitive:</span><pre class="source-code">
public double doSomething() { … }</pre></li>
				<li>This method returns <span class="No-Break">a reference:</span><pre class="source-code">
public String doSomething() { … }</pre></li>
			</ul>
			<p>Depending <a id="_idIndexMarker433"/>on the logic you are employing in a method, there may <a id="_idIndexMarker434"/>be times when you wish to return or break out from a method early. In this case, when <strong class="source-inline">void</strong> is the return type, you may use <strong class="source-inline">return</strong> by itself. If the method is not <strong class="source-inline">void</strong>, then the early returns must also include the <span class="No-Break">appropriate value.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor137"/>Method name</h2>
			<p>The rules <a id="_idIndexMarker435"/>and conventions for naming a method are identical to that of naming a variable we discussed in <a href="B19088_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Language Fundamentals – Data Types and Variables</em>. One difference is that while variables are nouns, based on naming conventions, methods are expected to <span class="No-Break">be verbs.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor138"/>Parameter variables</h2>
			<p>After the method name comes an opening and closing parenthesis; if left empty, this method does <a id="_idIndexMarker436"/>not receive any data. As already pointed out, for non-static methods, there is an undeclared <strong class="source-inline">this</strong> reference added in the first <a id="_idIndexMarker437"/>position of the parameter list. A non-static method that we write without any parameters gets the reference. This effectively means that all non-static methods have at least <span class="No-Break">one parameter.</span></p>
			<p>Parameters can be any primitive type or a class reference type. A method can have no more than 255 parameters, although you are likely doing something wrong if you have anywhere near <span class="No-Break">255 parameters.</span></p>
			<p>When you call a method, all that is significant is the type of values you pass. The identifier is not significant. If you have a parameter of the <strong class="source-inline">int</strong> type named <strong class="source-inline">bob</strong>, you can pass any named <strong class="source-inline">int</strong> to <span class="No-Break">the method.</span></p>
			<p>Java does not have a way to set a default value for <span class="No-Break">a parameter.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor139"/>Annotations</h2>
			<p>An annotation is a hint. It can modify the behavior of your code at compile time or just be informative <a id="_idIndexMarker438"/>without any effect. An annotation for a method must appear before the method and any of <span class="No-Break">its components.</span></p>
			<p>An annotation <a id="_idIndexMarker439"/>is a phrase that follows the same naming conventions as a class and begins with the at symbol (<strong class="source-inline">@</strong>). It may have parameters within parentheses that follow the annotation, but these are not variable declarations as in method parameters. They <a id="_idIndexMarker440"/>can <span class="No-Break">be anything.</span></p>
			<p>Frameworks, such as <strong class="bold">Spring</strong> and <strong class="bold">Jakarta</strong>, to name just two, use numerous annotations. For <a id="_idIndexMarker441"/>example, if we were writing a <strong class="source-inline">Servlet</strong> class, a class instantiated and run by a web application server, we would annotate it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">@WebServlet</strong>(name = "AddToEmailList", 
                        urlPatterns = {"/AddToEmailList"})
public class AddToEmailListServlet extends HttpServlet{...}</pre>
			<p>In this example, the annotation defines this class as a <strong class="source-inline">WebServlet</strong> class called <strong class="source-inline">AddToEmailList</strong> rather than using the class <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">AddToEmailListServlet</strong></span><span class="No-Break">.</span></p>
			<p>You can use annotations anywhere, not just for <span class="No-Break">the web.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor140"/>Exception handling – throws</h2>
			<p>When we look at the syntax of Java code in the next chapter, we will come across situations <a id="_idIndexMarker442"/>where you can either predict or expect errors when the program is running. For example, you are trying to open a connection to a database server, but the operation fails. The code that tries to make the connection will throw <a id="_idIndexMarker443"/>an exception. An exception is just an object that contains the details of the error. </p>
			<p>In Java, the exception can either be checked or unchecked. A checked exception expects there to be code to deal with the exception; if you do not handle the exception, it is an error. An unchecked exception does not need to be handled and may or may not end <span class="No-Break">your program.</span></p>
			<p>You can also decide that when an exception occurs, it will not be handled in the method in which the exception occurred. Instead, you want to pass the exception back to the method’s caller. You do this with a <strong class="source-inline">throws</strong> clause. Here is a fragment of a method that connects to a database to retrieve a list of items in <span class="No-Break">the database.</span></p>
			<p>In the following code block, we have a method that opens a connection to <span class="No-Break">a database:</span></p>
			<pre class="source-code">
Connection connection;
private void openConnection(){
    connection = 
        DriverManager.getConnection(url, user, password);
}</pre>
			<p>If the connection fails, an exception of the <strong class="source-inline">SQLException</strong> class type, which is a checked exception, will occur. This code will result in a compile-time error because you are not <a id="_idIndexMarker444"/>handling the checked exception. You can decide to defer <a id="_idIndexMarker445"/>handling the exception in the method that called this one. To do this, we add a <strong class="source-inline">throws</strong> clause to the method as shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
Connection connection;
private void openConnection()<strong class="bold">throws SQLException</strong>{
    connection = 
        DriverManager.getConnection(url, user, password);
}</pre>
			<p>The compiler will now verify that this exception will be handled in the caller of this method. </p>
			<p>Why not handle the exception when it occurs? We have already seen our <strong class="source-inline">CompoundInterest</strong> program broken into a user interface class and a business calculation class. Imagine that you decided to handle the error where it happened by requesting new credentials from the user such as a username or password. How would you do this? Do you ask in the console, a GUI, or a web application? </p>
			<p>After asking the user for their database credentials in the user interface class, you pass this information to the <strong class="source-inline">openConnection</strong> method in the business class. If something goes wrong, we throw the exception and return to the calling method in the user interface class. The database class does not need to know what the user interface is. It just returns a result or an exception. This business class is now usable regardless of the user interface. We <a id="_idIndexMarker446"/>call this <strong class="bold">Separation of Concerns</strong>; we will explore this topic in <a href="B19088_10.xhtml#_idTextAnchor214"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Implementing Software Principles and Design Patterns </em><span class="No-Break"><em class="italic">in Java</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor141"/>Thread setting</h2>
			<p>Code blocks <a id="_idIndexMarker447"/>that run concurrently use threads, as we will see in <a href="B19088_09.xhtml#_idTextAnchor195"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Using Threads in Java</em>. In some cases, you want a block of code in a thread to finish before another thread can run the same block. One way we can force this to happen is to indicate that a method must run to completion before another thread can execute the same block. This is the role of the <strong class="source-inline">synchronized</strong> keyword, as shown in the following code block. This keyword is not foolproof but is a part of how we write <span class="No-Break">thread-safe code:</span></p>
			<pre class="source-code">
<strong class="bold">synchronized</strong> public int add(int num1, int num2) {
   return num1 + num2;
}</pre>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor142"/>Generic parameters</h2>
			<p>The concept of generics is present in many languages. This means that you can write code in <a id="_idIndexMarker448"/>which the data type of variables is determined <a id="_idIndexMarker449"/>by a generic parameter. We will look more closely into this in <a href="B19088_07.xhtml#_idTextAnchor154"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Java Syntax and Exceptions</em>, but for now, you should recognize the generic <span class="No-Break">parameter syntax.</span></p>
			<p>In the following code block, we have declared a method to return part of a larger list. A list is like an array, and we will look at it in detail when we discuss <strong class="bold">collections</strong> in <a href="B19088_08.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Arrays, Collections, Generics, Functions, and Streams</em>. While we do not know what the generic parameter, <strong class="source-inline">T</strong>, will be, this code ensures that the result returned is the same type as the parameters passed to <span class="No-Break">the method:</span></p>
			<pre class="source-code">
    public <strong class="bold">&lt;T&gt;</strong> List&lt;T&gt;getSubList(List&lt;T&gt; a, int b, int c) {
        return a.subList(b, c);
    }</pre>
			<p>This code fragment will return a list of objects of a type to be determined at compile time. The first <strong class="source-inline">&lt;T&gt;</strong>, the generic parameter, informs the compiler that <strong class="source-inline">T</strong> is a type parameter that will be determined by whatever code calls this method. In this example, it shows that the given <strong class="source-inline">List</strong> can be of any type of object, and this method will return a sub-list of the same type. </p>
			<p>Whatever <a id="_idIndexMarker450"/>language you are transitioning from, I don’t suspect you ever <a id="_idIndexMarker451"/>considered using at least 11 different concepts to declare a method. There is no requirement that you use all 11 when declaring a method. That we have as many as 11 pieces available is one of the aspects of Java that makes it the ideal language for a wide range <span class="No-Break">of applications.</span></p>
			<p>We will look at the basic syntax of the Java language as used in methods in the next chapter. Next up, let us understand the relationships that classes and objects can have with <span class="No-Break">each other.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor143"/>Understanding inheritance</h1>
			<p>What do you do when you have a class that does almost everything you need to get done? What do <a id="_idIndexMarker452"/>you do when you have methods in a class that don’t quite do what you need to get done? How do you deal with these two issues if you do not have access to the source code of the class and its methods? What if you do have access to the source code, but other parts of your program expect the original unchanged code? The answer <span class="No-Break">is </span><span class="No-Break"><strong class="bold">inheritance</strong></span><span class="No-Break">.</span></p>
			<p>Inheritance is described as a relationship between two classes in which one class is called the <strong class="bold">superclass</strong>. This class <a id="_idIndexMarker453"/>contains the fields and methods to handle a specific task. This superclass is a generalization, and sometimes you need to enhance this kind of class. In this case, rather than rewriting the original class, you can create a new <a id="_idIndexMarker454"/>class called the <strong class="bold">subclass</strong> that inherits or specializes the superclass by overriding methods in the superclass or adding additional methods and fields. The subclass is now made up of the public and protected methods of the superclass as well as what it has added. A subclass may also be called a derived or child class in <span class="No-Break">other languages.</span></p>
			<p>Imagine that you must write a program that manages bank accounts. All accounts, such as chequing and savings, have similar tasks they must perform. You must be able to deposit money and withdraw money. At the end of the defined period, such as monthly, there are tasks that must be carried out that are similar but not quite the same for our two account types. Here is where inheritance can <span class="No-Break">be useful.</span></p>
			<p>In this program, we define a superclass with common elements. We then create two subclasses that <a id="_idIndexMarker455"/>inherit the public and protected members of the superclass. This is commonly described as an <strong class="bold">is-a</strong> relationship, meaning that the subclass is a type of superclass. We will see how we use this relationship when we look <span class="No-Break">at </span><span class="No-Break"><strong class="bold">polymorphism</strong></span><span class="No-Break">.</span></p>
			<p>Here is a <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) diagram. This diagram style is useful for planning <a id="_idIndexMarker456"/>what classes you will need to solve a problem and what the relationship between these classes will be. We begin by simply creating a box for each class and then joining the boxes with lines. The line ending describes the relationship. The hollow triangle <span class="No-Break">signifies inheritance.</span></p>
			<p>In the following figure, we see that <strong class="source-inline">BankAccount</strong> will be the superclass while <strong class="source-inline">SavingsAccount</strong> and <strong class="source-inline">ChequingAccount</strong> <span class="No-Break">are subclasses:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B19088_06_01.jpg" alt="Figure 6.1 – The BankAccount inheritance hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The BankAccount inheritance hierarchy</p>
			<p>In this example, we use inheritance to share data and functionality between the superclass and the subclasses. There will never be an object of the <strong class="source-inline">BankAccount</strong> type, only objects of the <strong class="source-inline">SavingsAccount</strong> and <strong class="source-inline">ChequingAccount</strong> types. This will mean that <strong class="source-inline">BankAccount</strong> will be an abstract class. An abstract class, denoted by the class name being in italics, cannot be instantiated into an object; it can only be used as a superclass, so <strong class="source-inline">BankAccount</strong> will hold the data elements. These elements must be accessible to the subclasses but are private to any other classes in the system. To define access control in a UML diagram, we use the <span class="No-Break">following prefixes:</span></p>
			<ul>
				<li>An octothorpe (<strong class="source-inline">#</strong>) means the method or field <span class="No-Break">is protected</span></li>
				<li>The plus sign (<strong class="source-inline">+</strong>) means the class, method, or field <span class="No-Break">is public</span></li>
				<li>The minus sign (<strong class="source-inline">-</strong>) means the class, method, or field <span class="No-Break">is private</span></li>
				<li>The absence of a prefix means the method or field <span class="No-Break">is package</span></li>
			</ul>
			<p>Here, we are <a id="_idIndexMarker457"/>showing that all the fields in <strong class="source-inline">BankAccount</strong> are protected and available to the <span class="No-Break">two subclasses:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B19088_06_02.jpg" alt="Figure 6.2 –﻿ The BankAccount class fields"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The BankAccount class fields</p>
			<p>The last part of this inheritance design is to determine what methods will be required. Here we can see the methods in the superclass <span class="No-Break">and subclasses:</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B19088_06_03.jpg" alt="Figure 6.3 – Methods and their access control"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Methods and their access control</p>
			<p>In the case of <strong class="source-inline">BankAccount</strong>, the three tasks—deposit, withdrawal, and report—each have a method <a id="_idIndexMarker458"/>that performs the actions common to both account types. These methods will be called upon by <span class="No-Break">the subclasses.</span></p>
			<p><strong class="source-inline">SavingsAccount</strong>, by its nature, must override each of the <strong class="source-inline">BankAccount</strong> methods. To override means to have a method with the same name and the same parameters. The <strong class="source-inline">return</strong> type can be different but must be a subclass of the original <strong class="source-inline">return</strong> type. The methods in the subclass can call upon the overridden method in the superclass by prefixing the method call with the <strong class="source-inline">super</strong> reference, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">super.makeDeposit(amt)</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">ChequingAccount</strong> only overrides two of the superclass methods. It does not override <strong class="source-inline">makeDeposit</strong>, as how the superclass handles this is sufficient. </p>
			<p>Inheritance is a one-way street. The subclass can call upon public and protected members of the superclass, but the superclass is unaware of the subclass. </p>
			<p>The inheritance model that only overrides superclass methods in the subclass and does not add any additional public methods or variables in the subclass is referred to as <strong class="bold">pure inheritance</strong>. The inheritance model that adds additional methods and variables to the subclass and may or may not override any superclass methods is described as an <strong class="bold">is-like-a</strong> relationship and is <a id="_idIndexMarker459"/>called <span class="No-Break">an </span><span class="No-Break"><strong class="bold">extension</strong></span><span class="No-Break">.</span></p>
			<p>We code inheritance of both types using the <strong class="source-inline">extends</strong> keyword. Assuming we have defined the <strong class="source-inline">BankAccount</strong> superclass, then we code inheritance <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">public class SavingsAccount extends BankAccount { … }</strong></li>
				<li><strong class="source-inline">public class ChequingAccount extends BankAccount { … }</strong></li>
			</ul>
			<p>We will need to examine the code in the subclass to determine which approach, pure inheritance or extension, <span class="No-Break">is taken.</span></p>
			<p>When instantiated, each of these objects will have its own dataset from its superclass and, if the inheritance <a id="_idIndexMarker460"/>is an extension, then its <span class="No-Break">own fields.</span></p>
			<p>In the following example, the <strong class="source-inline">BankAccount</strong> class will be declared as abstract. This means that you cannot instantiate <strong class="source-inline">BankAccount</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var account = new BankAcount();</pre>
			<p>This will be flagged as an error by the compiler because <strong class="source-inline">BankAccount</strong> is abstract. If we had any abstract methods in <strong class="source-inline">BankAccount</strong>, we would be required to override them in <strong class="source-inline">SavingsAccount</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ChequingAccount</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The C++ language <a id="_idIndexMarker461"/>supports <strong class="bold">multiple inheritances</strong>. This means that a subclass can have more than one superclass. The designers of Java chose to only support single inheritance. You can only extend a class with a single superclass. </p>
			<p>If you do not want your class to be available for inheritance, you can add the <strong class="source-inline">final</strong> designation, as shown here: </p>
			<pre class="source-code">
public <strong class="bold">final</strong> AClass { … }</pre>
			<p>If we now attempt to create an inherited or derived class, we see the following: </p>
			<pre class="source-code">
public class AnotherClass extends AClass { … }</pre>
			<p>An error will be declared when we try and compile <span class="No-Break">this code.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor144"/>The superclass of all objects, the Object class </h2>
			<p>In Java, all classes extend a special <a id="_idIndexMarker462"/>class called <strong class="bold">Object</strong>. While we cannot extend more than one class, <strong class="source-inline">Object</strong> is always available. Why does the <strong class="source-inline">Object</strong> class exist? The <strong class="source-inline">Object</strong> class defines <a id="_idIndexMarker463"/>methods to support threading and object management in any class. This means that every class has these methods and may choose to override any of them or use them as is. There are three of these methods that are frequently overridden in a class. The first of these is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public boolean equals(Object obj)</pre>
			<p>The default <a id="_idIndexMarker464"/>implementation inherited from <strong class="source-inline">Object</strong> compares the address of the object that invokes <strong class="source-inline">equals</strong> to the object passed as a parameter. This means it can only be <strong class="source-inline">true</strong> if two references contain the same address in memory to an object. In most cases, you will likely want to compare the values in an object’s fields, and therefore you will frequently want to override it. For example, see <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class Stuff {
    private int x;
    public Stuff(int y){
        x = y;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Stuff other = (Stuff) obj;
        return this.x == other.x;
    }</pre>
			<p>The <strong class="source-inline">equals</strong> method performs four tests that must all be passed for one object to be equal to another. These are <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <strong class="source-inline">this</strong> reference and <strong class="source-inline">obj</strong> contain the same <span class="No-Break">memory address</span></li>
				<li>The comparative <strong class="source-inline">obj</strong> is <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">null</strong></span></li>
				<li>Both references are for the same <span class="No-Break">class type</span></li>
				<li>Finally, it compares the value of <span class="No-Break">the fields</span></li>
			</ul>
			<p>The next <a id="_idIndexMarker465"/>commonly overridden method <span class="No-Break">is this:</span></p>
			<pre class="source-code">
public int hashCode()</pre>
			<p>When comparing <a id="_idIndexMarker466"/>multiple fields in two objects, the necessary code can be quite time-consuming. If you need to compare two strings, it will be necessary to compare them one character at a time. You will need to compare each one for a <a id="_idIndexMarker467"/>class with many fields. There is an optimization, and that <span class="No-Break">is </span><span class="No-Break"><strong class="bold">hashCode</strong></span><span class="No-Break">.</span></p>
			<p>A hash is an integer computed from the fields in an object. Computing hash values is, in most cases, faster than comparing fields one at a time. The default value from this method, if it is not overridden, is the address in memory at which the object resides. What you will want to do is calculate a hash value based on the <span class="No-Break">object’s fields.</span></p>
			<p>Here is an example of a method that overrides the <strong class="source-inline">Object</strong> class’s <strong class="source-inline">hashCode</strong> method with <span class="No-Break">its own:</span></p>
			<pre class="source-code">
    @Override
    public int hashCode() {
        int hash = 5;
        hash = 79 * hash + this.x;
        return hash;
    }</pre>
			<p>The value generated is not a unique value. It is possible that two objects with different values would generate the same hash code. What we do know for certain is that if the hash codes <a id="_idIndexMarker468"/>of two objects are not the same, then the objects, based on the fields, are not equal. If the hash code is the same for two objects, then to be <a id="_idIndexMarker469"/>certain that they are equal, you must now use the <strong class="source-inline">equals</strong> method. This will, in almost all cases, speed up the process of comparing objects because the slower <strong class="source-inline">equals</strong> method is only called when the hash codes are <span class="No-Break">the same.</span></p>
			<p>One other application of <strong class="source-inline">hashCode</strong> is in data structures—structures that store data as a pair of values called the key and value, where the value is an object. The value that <strong class="source-inline">hashCode</strong> returns is an integer value that is used as the key. As the integer is processed faster than any of the other primitives, these data structures perform more efficiently as compared to structures that can use any type as the key. </p>
			<p>The last of the three commonly overridden methods <span class="No-Break">is this:</span></p>
			<pre class="source-code">
public String toString()</pre>
			<p>The implementation of this method in the <strong class="source-inline">Object</strong> class returns the object’s address as returned by the <strong class="source-inline">hashCode</strong> method and the name of the class. Overriding it to return the values of the fields as a String can be far more useful. By overloading it, you can inspect the state of an object, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
    @Override
    public String toString() {
        return "Stuff{" + "x=" + x + '}';
    }</pre>
			<p>Let us now look at an alternative to inheritance in Java, a <span class="No-Break"><strong class="bold">class interface</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor145"/>Understanding the class interface</h1>
			<p>In a programming language that has access control features, public methods are called the class <strong class="bold">interface</strong>. These are the methods that can be called from any other object in a system that has <a id="_idIndexMarker470"/>a reference to the object it wants to use. In Java, we can create a contract that will require any class that implements the contract, called an interface, to implement all the methods listed in the interface as <span class="No-Break">public methods.</span></p>
			<p>Here is an interface for reading and writing to a <span class="No-Break">relational database:</span></p>
			<pre class="source-code">
public interface GamingDAO {
    // Create
    int create(Gamer gamer) throws SQLException;
    int create(Games games) throws SQLException;
    // Read
    List&lt;Gamer&gt; findAll() throws SQLException;
    Gamer findID(int id) throws SQLException;
    // Update
    int update(Gamer gamer) throws SQLException;
    int update(Games games) throws SQLException;
    // Delete
    int deleteGamer(int ID) throws SQLException;
    int deleteGames(int ID) throws SQLException;
}</pre>
			<p>In this code block for an interface class, each method is declared as an abstract method, as it ends with a semicolon and does not have a code block. They are all public by default as well – hence, the lack of the <span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break"> keyword.</span></p>
			<p>We use an interface when we declare the class. The implementing class must now have public methods as described in the interface. The following are the first few lines of a class that implements <strong class="source-inline">GamingDAO</strong>. I have not included the implementation of <span class="No-Break">these methods:</span></p>
			<pre class="source-code">
public class GamingDAOImpl implements GamingDAO {
    @Override
    public List&lt;Gamer&gt; findAll() throws SQLException {…}
    @Override
    public int create(Gamer gamer) throws SQLException {…}
    @Override
    public Gamer findID(int id) throws SQLException {…}</pre>
			<p>Each method has the <strong class="source-inline">@Override</strong> annotation. This is an informative annotation and is optional in this case. Your code will be more easily understood by other developers if you use this annotation. You are also informing the compiler to watch out for any changes in the <a id="_idIndexMarker471"/>superclass methods and if they are found, the compiler will complain. This is the original application of a <span class="No-Break">Java interface.</span></p>
			<p>Java 8 and then Java 9 modified what can be contained in an interface. The changes to the original definition of an interface class are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Having the <strong class="source-inline">default</strong> interface method. This is a <strong class="source-inline">public</strong> method implemented in the interface rather than in the <span class="No-Break">implementing class.</span></li>
				<li>Having <strong class="source-inline">private</strong> methods implemented in the interface class. These <strong class="source-inline">private</strong> methods can only be called by a <strong class="source-inline">default</strong> method, or they can be called by other <strong class="source-inline">private</strong> methods declared in the interface. Therefore, as in the following code block, I can call <strong class="source-inline">write4()</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">write2()</strong></span><span class="No-Break">.</span></li>
				<li>Having <strong class="source-inline">static</strong> methods implemented in the interface class. As with all <strong class="source-inline">static</strong> methods, it does not have a <strong class="source-inline">this</strong> reference, so it cannot call upon other methods in the interface or class. It must be a public method, so the <strong class="source-inline">public</strong> keyword is <span class="No-Break">not required.</span></li>
			</ul>
			<p>Here is an example of these three types of methods that can exist in an <span class="No-Break">interface class:</span></p>
			<pre class="source-code">
public interface Pencil {
   void write1(); // Standard interface method
   default void write2() {
      System.out.printf("default%n");
      write4();
   }
   static void write3() {
      System.out.printf("static%n");
   }
   private void write4() {
      System.out.printf("private%n");
   }
   public void perform(); // Standard interface method
}</pre>
			<p>If we implement <a id="_idIndexMarker472"/>this interface, then the only method that we are under contract to implement <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">write1()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class WritingTool implements Pencil {
   @Override
   public void write1() {
      System.out.printf("standard interface");
   }
   @Override
   public void perform() {
       write1();
       write2();
       Pencil.write3();
   }
   public void write5() {
       System.out.printf("Method only in WritingTool");
   }
   public static void main(String[] args) {
       Pencil tool = new WritingTool();
       tool.perform();
       tool.write5(); 
   }
}</pre>
			<p>Notice that in the <strong class="source-inline">main</strong> method, the object we are creating, <strong class="source-inline">WritingTool</strong>, has its reference assigned <a id="_idIndexMarker473"/>to an object of the <strong class="source-inline">Pencil</strong> type. You cannot write <strong class="source-inline">new Pencil()</strong>, but you use <strong class="source-inline">Pencil</strong> as the reference type when you create <strong class="source-inline">WritingTool</strong>. This will restrict your use of the code in the <strong class="source-inline">WritingTool</strong> class to just the overridden methods. The last call in the <strong class="source-inline">main</strong> method, <strong class="source-inline">tool.write5()</strong>, will generate a compiler error because the <strong class="source-inline">write5</strong> method is not part of the <strong class="source-inline">Pencil</strong> interface. </p>
			<p>The implementing class, in this case, <strong class="source-inline">WritingTool</strong>, can have additional methods of any access control designation not listed in <span class="No-Break">the interface.</span></p>
			<p>It is considered a best practice to define the public methods of a class in an interface class. It is not necessary to list every public method and a class may have multiple interfaces so <a id="_idIndexMarker474"/>that what you can do with a class can be restricted to a specific set <span class="No-Break">of tasks.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor146"/>Abstract class versus interface</h2>
			<p>In an abstract superclass, you must implement every abstract method in the subclass. This might <a id="_idIndexMarker475"/>lead you to believe that an abstract <a id="_idIndexMarker476"/>class with every method abstract is the same as an interface. However, as mentioned here, there are significant differences between <span class="No-Break">the two.</span></p>
			<p>An abstract class may have <span class="No-Break">the following:</span></p>
			<ul>
				<li>Abstract <span class="No-Break">method declarations</span></li>
				<li>Class and instance <span class="No-Break">variables (fields)</span></li>
				<li><span class="No-Break">A constructor</span></li>
				<li>An additional non-abstract method of any <span class="No-Break">access control</span></li>
			</ul>
			<p>Whereas, an interface may <span class="No-Break">have these:</span></p>
			<ul>
				<li>Abstract <span class="No-Break">method declarations</span></li>
				<li>Default, private, or <span class="No-Break">static methods</span></li>
			</ul>
			<p>There is one other significant difference – as Java only supports a single inheritance model, you can only extend a single superclass. On the other hand, you can implement multiple interfaces for a single class, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public class SingleInheritance extends ASuperClass { ... }
public class MultiInterface implements IFace1,IFace2 {...}</pre>
			<p>You can also have a subclass with a single superclass and one or more interfaces, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public class MultiClass extends ASuperClass implements  
                                     IFace1,IFace2 {...}</pre>
			<p>However, one issue to keep an eye out for when using multiple interfaces is that it is a compile-time error, should there be the same abstract method in more than one interface. You may have an abstract method in a superclass identical to an abstract method in <span class="No-Break">an interface.</span></p>
			<p>Both interfaces <a id="_idIndexMarker477"/>and abstract classes can define what <a id="_idIndexMarker478"/>a class must implement. The fact that a class can only inherit from a single class makes an interface class more useful, as a class may have more than <span class="No-Break">one interface.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor147"/>Sealed classes and interfaces</h2>
			<p>By default, any <a id="_idIndexMarker479"/>class can be the superclass for any other class, just <a id="_idIndexMarker480"/>as any interface can be used with any class. However, you <a id="_idIndexMarker481"/>can restrict this behavior by using a <strong class="bold">sealed class</strong> or <strong class="bold">sealed interface</strong>. This <a id="_idIndexMarker482"/>means you can list the names of classes that may extend or implement it, as shown in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
public sealed class SealedClass permits SubClass{ }</pre>
			<p>Here, we have declared a class that can only be used as a superclass to a class whose name <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">SubClass</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have permitted <strong class="source-inline">SubClass</strong> to extend the <strong class="source-inline">Sealed</strong> class, we can <span class="No-Break">write this:</span></p>
			<pre class="source-code">
public final class SubClass extends SealedClass { }</pre>
			<p>Note that this subclass must be defined as <strong class="source-inline">final</strong>. This way, it is not possible to have <strong class="source-inline">SubClass</strong> as a superclass for some other class. Here is a similar syntax for a <span class="No-Break">sealed interface:</span></p>
			<pre class="source-code">
public sealed interface SealedInterface permits SubClass{ }
public final class SubClass implements SealedInterface { }</pre>
			<p>We have one more structure to examine, and that <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">record</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor148"/>Understanding the record class</h1>
			<p>A <strong class="bold">record class</strong> simplifies the <a id="_idIndexMarker483"/>creation of a class that can only have immutable fields. <strong class="bold">Immutability</strong> means <a id="_idIndexMarker484"/>that the fields of a class are all final and must have a value assigned to them when the <strong class="source-inline">record</strong> object <span class="No-Break">is instantiated.</span></p>
			<p>At its simplest, a record only needs the fields listed when the <strong class="source-inline">record</strong> class is declared, as shown here: </p>
			<pre class="source-code">
public record Employee(String name, double salary) { }</pre>
			<p>When we instantiate this record, we must provide the values for name <span class="No-Break">and salary:</span></p>
			<pre class="source-code">
var worker = new Employee("Bob", 43233.54);</pre>
			<p>All records have a default canonical constructor that expects a value for every field in the record. In a regular class, you would need to write a canonical constructor method to assign the values to the fields. You may add a compact constructor to a record that permits you to examine the value each field <span class="No-Break">was assigned.</span></p>
			<p>Here is a compact constructor. Notice that it does not have a parameter list, as it can only have a parameter for every field declared in the first line of <span class="No-Break">the class:</span></p>
			<pre class="source-code">
public record Employee(String name, double salary) { 
    public Employee {
        if (salary &lt; 50000) {
            // code if this is true
        }
    }
}</pre>
			<p>To access the value of a field, you can use the identifier as a method as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
var aSalary = worker.salary(); </pre>
			<p>You cannot change the value of a field in a record – you can only read its value. As a class, a record also extends <strong class="source-inline">Object</strong>. Furthermore, <strong class="source-inline">record</strong> provides default overrides for the <strong class="source-inline">equals</strong>, <strong class="source-inline">hashCode</strong>, and <strong class="source-inline">toString</strong> methods based on the fields. </p>
			<p>A record can implement an interface and so can be in the list of a sealed interface. As a record is <a id="_idIndexMarker485"/>implicitly final, it cannot extend any other classes, so it cannot be sealed for a class <span class="No-Break">or classes.</span></p>
			<p>Now, let us examine the concept of polymorphism and see how it allows us to <span class="No-Break">reuse code.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor149"/>Understanding polymorphism</h1>
			<p><strong class="bold">Polymorphism</strong> is one of <a id="_idIndexMarker486"/>the defining features of object-oriented languages. Java has expanded the concept by including interfaces. Let us begin with a simple hierarchy of classes as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public class SuperClass {
    
    protected int count;
    
    public void setCount(int count) {
       this.count = count;
    }
    
    public void displayCount() {
       System.out.printf("SuperClass count = %d%n", count);
    }
}</pre>
			<p>In this trivial class, we have a public method to assign a value to <strong class="source-inline">count</strong> and a second method that displays the value in <strong class="source-inline">count</strong> along with the name of the class. In the following code block, we have a class that <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">SuperClass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Polymorphism {
     private void show(SuperClass sc) {
        sc.setCount(42);
        sc.displayCount();
    }
    
    public void perform() {
        var superClass = new SuperClass();
        show(superClass);
    }
    public static void main(String[] args) {
        new Polymorphism().perform();
    }
}</pre>
			<p>When we <a id="_idIndexMarker487"/>run this, the result is as <span class="No-Break">we expected:</span></p>
			<pre class="source-code">
SuperClass count = 42</pre>
			<p>Now, let us create a subclass <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">SuperClass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class SubClass extends SuperClass {
    @Override
    public void displayCount() {
        System.out.printf("SubClass count = %d%n", count);
    }
}</pre>
			<p>This subclass only overrides the <strong class="source-inline">displayCount</strong> method. Classes are about creating new data types. When we create a class that is a subclass, we refer to the class type by the superclass name. In other words, we can state that <strong class="source-inline">SubClass</strong> is of the <strong class="source-inline">SuperClass</strong> type. If we added a <strong class="source-inline">subclass</strong> variable to <strong class="source-inline">SubClass</strong>, then that class is also of the <strong class="source-inline">SuperClass</strong> type. Now let us change the <strong class="source-inline">Polymorphism</strong> class to use a <span class="No-Break"><strong class="source-inline">SubClass</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
    public void perform() {
        var subClass = new SubClass();
        show(subClass);
    }
    private void show(SuperClass sc) {
        sc.setCount(42);
        sc.displayCount();
    }</pre>
			<p>While the <strong class="source-inline">show</strong> method is unchanged and still expects an object of the <strong class="source-inline">SuperClass</strong> type, we are <a id="_idIndexMarker488"/>creating an object of <strong class="source-inline">SubClass</strong> in <strong class="source-inline">perform</strong>, and then we call upon <strong class="source-inline">show</strong>, passing a reference to the subclass. As <strong class="source-inline">SubClass</strong> is of the <strong class="source-inline">SuperClass</strong> type, polymorphism permits any subclass of <strong class="source-inline">SuperClass</strong> to be passed to the <strong class="source-inline">show</strong> method. When we call <strong class="source-inline">sc.setCount</strong>, the runtime determines that it must use the <strong class="source-inline">superclass</strong> count method because there is no public method with that name in the subclass. When it calls upon <strong class="source-inline">sc.displayCount</strong>, it must decide whether to use the method that belongs to <strong class="source-inline">SuperClass</strong> that it is expecting or the method that belongs to the <strong class="source-inline">SubClass</strong> type that is passed. </p>
			<p>Polymorphism means that methods overridden in a subclass are called in favor of the superclass version even when the declared type of what is being passed is the <strong class="source-inline">SuperClass</strong> type. The result when running the code this time is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
SubClass count = 42</pre>
			<p>Classes that share the same interface are also subject to polymorphism. Here is a simple interface that only requires the method: </p>
			<pre class="source-code">
public interface Interface {
    void displayCount();
}</pre>
			<p>Any class that implements this interface must override the abstract <strong class="source-inline">displayCount</strong> method. Now, let us create a class that implements <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
public class Implementation implements Interface {
    protected int count;
    public void setCount(int count) {
        this.count = count;
    }
    @Override
    public void displayCount() {
        System.out.printf("Implement count = %d%n", count);
    }
}</pre>
			<p>Now, let us <a id="_idIndexMarker489"/>use polymorphism with <span class="No-Break">the interface:</span></p>
			<pre class="source-code">
public class PolyInterfaceExample {
    private void show(Interface face) {
        face.displayCount();
    }
    public void perform() {
        var implement = new Implementation();
        implement.setCount(42);
        show(implement);
    }
    public static void main(String[] args) {
        new PolyInterfaceExample().perform();
    }
}</pre>
			<p>In this class, we are passing the <strong class="source-inline">Implementation</strong> object to a method expecting the interface. When this runs, it produces the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
Implementation count = 42</pre>
			<p>Any class <a id="_idIndexMarker490"/>that implements the interface named <strong class="source-inline">Interface</strong> can be passed to any method that declares a parameter using the interface rather than <span class="No-Break">a class.</span></p>
			<p>Polymorphism is a powerful tool that allows you to write code that evolves over time but does not require changes to existing code that uses objects that share an interface or inherit from the <span class="No-Break">same superclass.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor150"/>Understanding composition in classes</h1>
			<p>When we create an application that employs numerous classes, we must decide how they will <a id="_idIndexMarker491"/>interact with each other. In object-oriented programming terminology, a method in one class that calls a method in another class is called messaging. Despite this, most developers describe this as calling a method, as I do. How objects send these messages or call methods in other objects is what <strong class="bold">composition</strong> <span class="No-Break">is about.</span></p>
			<p>There are two ways for objects to be connected – <strong class="bold">association</strong> and <strong class="bold">aggregation</strong>. Let’s discuss <span class="No-Break">these connections.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor151"/>Association</h2>
			<p>In association, the <a id="_idIndexMarker492"/>object reference we need to call or message <a id="_idIndexMarker493"/>a method is created outside the calling object. Let’s begin with a class that we will want <span class="No-Break">to call:</span></p>
			<pre class="source-code">
public class Receiver {
    public void displayName(String name) {
        System.out.printf("%s%n", name);
    }
}</pre>
			<p>This is a trivial method that has a method to display a String that is passed to it. Keep in mind that we are interested in the concepts here and not the task the class is responsible for. Now, let us create a class that will want to call or <span class="No-Break">message </span><span class="No-Break"><strong class="source-inline">Receiver</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Association {
    
    private final Receiver receiveString;
    
    public <strong class="bold">Association</strong>(Receiver receiveString) {
        this.receiveString = receiveString;
    }
    public void sendMessage() {
        receiveString.displayName("Bob");
    }
}</pre>
			<p>In this class, we declare a reference to the <strong class="source-inline">Receiver</strong> class. We do not plan for it to be changed when <a id="_idIndexMarker494"/>it is assigned an initial, so we designate it as <strong class="source-inline">final</strong>. We do not create an instance of this object using <strong class="source-inline">new</strong>. Rather, we expect <a id="_idIndexMarker495"/>this object to be created in another class and we will then pass that reference to the constructor. Put another way, this <strong class="source-inline">Association</strong> class does not own the reference <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Receiver</strong></span><span class="No-Break">.</span></p>
			<p>Here is an example of having an object declared in a class and then that object passed to <span class="No-Break">another class:</span></p>
			<pre class="source-code">
public class Composition {
    public void perform() {
        var receive = new Receiver();
        var associate = new Association(receive);
        associate.sendMessage();
    }
    public static void main(String[] args) {
        new Composition().perform();
    }
}</pre>
			<p>In the <strong class="source-inline">Composition</strong> class’s <strong class="source-inline">perform</strong> method, we are instantiating an object of the <strong class="source-inline">Receiver</strong> type. Following this, we instantiate an object of the <strong class="source-inline">Association</strong> type, passing to its constructor a reference to the <strong class="source-inline">Receiver</strong> object we just created. </p>
			<p>When the time <a id="_idIndexMarker496"/>comes to put an object of the <strong class="source-inline">Association</strong> type out for garbage collection, the <strong class="source-inline">Receiver</strong> object is untouched if it is also used <a id="_idIndexMarker497"/>in another object. Put another way, if the <strong class="source-inline">Receiver</strong> object is in scope, meaning visible and valid, in another object, then the <strong class="source-inline">Receiver</strong> object is not garbage-collected. Let’s see rewriting <strong class="source-inline">perform</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    public void perform() {
        var receive = new Receiver();
        var associate = new Association(receive);
        associate.sendMessage();
        associate = null;
        associate.sendMessage(); // ERROR       
        receive.displayName("Ken");
    }</pre>
			<p>To explicitly put an object out of scope and available for garbage collection, you can assign a special value named <strong class="source-inline">null</strong>. This will set the address this reference contains to zero, and the object will be made available for garbage collection. If we try to call <strong class="source-inline">sendMessage</strong> after assigning <strong class="source-inline">null</strong>, then this will be flagged as an error by the compiler. If we remove the error line, the final line where we call <strong class="source-inline">displayName</strong> in the <strong class="source-inline">Receiver</strong> object will work, as the <strong class="source-inline">Association</strong> class did not own the <strong class="source-inline">Receiver</strong> object. Ownership <a id="_idIndexMarker498"/>is defined as belonging to the object that <a id="_idIndexMarker499"/>created it. <strong class="source-inline">Association</strong> did not create <strong class="source-inline">Receiver</strong>. If the <strong class="source-inline">Association</strong> object’s <strong class="source-inline">receive</strong> reference is not in scope anywhere else in the program, it will go out for <span class="No-Break">garbage collection.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor152"/>Aggregation</h2>
			<p>Objects that are created in a class belong to or are owned by that class. When we create an object <a id="_idIndexMarker500"/>of the owning class, all the other objects in the class <a id="_idIndexMarker501"/>will be instantiated in the class. When this class goes out of scope, then everything it owns also goes out <span class="No-Break">of scope.</span></p>
			<p>Here is our program <span class="No-Break">employing aggregation:</span></p>
			<pre class="source-code">
public class Aggregation {
    
    private final Receiver receiveString;
    
    public Aggregation() {
        receiveString = new Receiver();
    }
    
    public void sendMessage() {
        receiveString.displayName("Bob");
    }
}</pre>
			<p>In this <strong class="source-inline">Aggregation</strong> class, an object of the <strong class="source-inline">Receiver</strong> type is created in the constructor. It is not coming from another object as it did with <strong class="source-inline">Association</strong>. This means that <strong class="source-inline">Aggregatio</strong>n owns the <strong class="source-inline">Receiver</strong> object and when the <strong class="source-inline">Aggregation</strong> object goes out of scope, so does the <strong class="source-inline">Receiver</strong> object that <span class="No-Break">it instantiated.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor153"/>Summary</h1>
			<p>In this chapter, we have finished examining the building blocks or concepts of organizing code in Java that we began in <a href="B19088_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Language Fundamentals – Classes</em>. We looked at methods and a range of issues that need to be considered when writing a method. From there, we examined inheritance, a way in which we can reuse or share code. </p>
			<p>The interface introduced the concept of a contract or list of methods that must be written by any class that implements the interface. The specialized class type called <strong class="source-inline">record</strong> for simplifying the creation of immutable objects was <span class="No-Break">next up.</span></p>
			<p>Inheritance and interfaces support the concept of polymorphism. This permits the creation of methods that expect an instance of a superclass or interface class but receive an instance of any class that either inherits or extends the superclass or implements <span class="No-Break">the interface.</span></p>
			<p>We ended the chapter by looking at how we connect objects to objects. Composition implies that the object is created outside of the object that has a reference. The reference must be passed to the object either through the constructor or another method. Aggregation implies that the object we need to use is created inside the object that wishes to use it. </p>
			<p>Next up, we will finally review the syntax of the <span class="No-Break">Java language.</span></p>
		</div>
	</body></html>