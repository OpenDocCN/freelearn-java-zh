- en: Chapter 3. Protocols – Abstract Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw a few basic data structures and some algorithms
    to manipulate them. However, sometimes we may want to hide the implementation
    details of a data structure and only want to know how they interact with other
    algorithms. We may want to specify a few operations that they must allow and forget
    about how they are achieved. This is not very different from abstraction of a
    part of a program in any large software application. For example, in Java, we
    create interfaces that only define the methods of an object that its class must
    implement, and then we use this interface type, being confident that they will
    be implemented properly. We do not want to think about how an implementation class
    would provide their implementation. Such interfaces of data structure are called
    abstract data types. To put this another way, an **abstract data type** (**ADT**)
    is a description of what a data structure should do for its user. It is a list
    of operations that any implementation must support and the complete description
    of what these operations are supposed to do. A few of these have very frequent
    usage and have names given to them. We will discuss a few of these here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of some common ADTs and their operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement these ADTs using both simple arrays and the data structures
    you learned in the last chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack** is a very commonly used ADT. It is so named because it resembles
    a stack of plates used in a restaurant. In such a stack, a plate that has been
    washed and put last would stay on top. This would be the first plate to be picked
    up when a plate is needed. The plate that went in first would be at the bottom
    of the stack and would be picked last. So, the last plate to be placed in the
    stack is the first plate to get out, we can also call this **last in first out**
    (**LIFO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a stack ADT has a protocol where the last value that is put in it
    must be returned on the first attempt to get a value out, and the value that went
    in first must come out last. The following figure will make it more clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The operation of putting a new value in a stack is called push, and the operation
    of retrieving a value from a stack is called pop. The element that was pushed
    last must be popped first. The operation that allows one to see what the next
    pop will return is called peek. The peek operation returns the top element without
    modifying the stack. We expect all stack implementations to have all operations
    implemented in the time complexity of *O(1)*. This is also part of our stack protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack ADT has the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This adds an element at the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop**: This removes the element at the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peek**: This checks the next value to be popped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we know that ADTs are to data structures what interfaces are to classes,
    we will code an ADT as an interface. The following is our interface for a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we will not leave it at this. We will see how a stack can actually
    be implemented. To this end, we will see both a fixed-sized stack using an array
    to store it's data, and a growing stack using a linked list for storing data.
    We will start with the first.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-sized stack using an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fixed-sized stack uses a pre-allocated array to store values, that is when
    this stack has used up the entire array, it can no longer accept new values until
    the old ones are popped. This is not very different from an actual stack of plates,
    which most certainly has a maximum height that it can handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we start with the basic structure of the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need an array to store the elements, and we need to remember where the top
    of the stack is in that array. The top always marks the index of the element that
    will be popped next. When there are no more elements to be popped, it is set to
    `-1`. Why `-1`? Because this is the natural choice as it does not require any
    special handling when the first element is inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push` operation in a stack can be to simply put the value in the array
    right next to the current `top` and then set the `top` to the new position, as
    illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We first check whether the stack is already full or the current `top` is equal
    to the maximum index possible, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set the `top` to the new position and put the value we need to store
    in there as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception we used is a custom exception for this purpose. The code of the
    exception is simple as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pop` operation is just the opposite. We need to first take the value of
    the current `top` and then update the `top` to the new position, which is one
    less than the current position, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We first check whether the stack is already empty, in which case we return
    a special value, `null`. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we update the `top` and return the value at the current `top` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `peek` operation does not change the state of the stack, and hence is even
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `pop` operation, we return `null` if the stack is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we return the `top` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is in fact possible to have a stack without an upper limit backed up by an
    array. What we really need to do is that whenever we run out of space, we can
    resize the array. Array actually cannot be resized, so the operation would be
    to create a new array with a higher size (maybe twice as much as the original
    size), and copy all the old elements into this array. Since this involves copying
    all the *n* elements to the new array one by one, the complexity of this operation
    is *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-sized stack using a linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with an array-based implementation is that since arrays are fixed
    in size, the stacks cannot grow beyond a fixed-size. To resolve this, we have
    to do what we did to fix the same problem for an array, that is, use a linked
    list instead. We start such an implementation with the following bare bone class.
    The linked list will store the values. Instead of assigning a new linked list
    to it, we do so using an overridable method `getNewLinkedList()`. This will be
    useful in the class that extends from this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which end of the linked list must be used as the top of the stack, we
    need to remember that our stack protocol expects the operations to be *O(1)*,
    so we must choose an end that allows both insertion and removal in *O(1)* time.
    That end is of course the front of the list as we saw in the last chapter. This
    makes the following code for the `push` operation self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that this time, we did not check whether the stack is full because this
    implementation of the stack is never full, it grows as it needs and the underlying
    linked list takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pop` operation, however, does need to check whether the stack is empty
    and return `null` at that point. The following code for the `pop` operation is
    also quite self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `peek` operation is, of course, the same, except it does not remove the
    top element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our linked list-based implementation of a stack. In the next
    section, we will check out another ADT called a **queue**.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the opposite of a stack? This may be a weird question. However, a stack
    follows LIFO, last in first out. The opposite of that is **first-in-first-out**
    (**FIFO**). So, in some sense, a FIFO ADT can be considered as the opposite of
    a stack. This is not very different from a queue of people waiting for a bus or
    at a doctor''s clinic. The first person to show up gets the first chance to get
    onto the bus or to get to see the doctor. The second person gets the second chance.
    No wonder, such an abstract data type is called a queue. Appending to the end
    of a queue is called **enqueuing** and removing from it is called **dequeuing**.
    The contract is, of course, that the first value that is enqueued would be the
    first to be dequeued. The following figure illustrates this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Queue](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The queue ADT has the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enqueue**: This adds an element at the back of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dequeue**: This removes an element from the front of the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peek**: This checks the element that would be dequeued next'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The queue will be represented by the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Fixed-sized queue using an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like the stack, we have an array-based implementation of a queue. However,
    since a queue receives new values and removes old values from opposite sides,
    the body of the queue moves as it does. The following figure will illustrate this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed-sized queue using an array](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This means that after a sequence of a few such operations, the end of the queue
    will reach the end of the array, and there will be space left at the beginning
    of the array. At this point, we don't want to stop receiving new values as there
    is space left, so we roll over to the beginning of the array. That is to say,
    we continue adding the new values at the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do all these manipulations, we must have separate variables storing the
    indexes of the beginning and the end of the queue. Also, since due to roll over,
    sometimes the end is smaller than the beginning, we store the length separately
    to avoid confusion. We start with the bare bone implementation of the class just
    as before. The start represents the index of the element that would be dequeued
    next and the end represents the position of the next value that would be enqueued.
    This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enqueue` operation does not change the start position. The new value is
    put at the end position of the array and the end is incremented by one. The end,
    of course, needs to be rolled over in case it goes beyond the maximum index of
    the array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The modulo operator will make sure that the index goes to the beginning of
    the array when it hits the `end` of the array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dequeue` operation does not change the end position. We read from the
    start index and then increment the start index with rollover, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `peek` operation lets us see the element that would be dequeued next, without
    removing it. It is, of course, simpler. We just return the next element to be
    dequeued. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A queue backed up by an array can be resized in a similar manner as described
    for the case of a stack, and this too will be *O(n)*, since we must copy all the
    old elements to the newly allocated array one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-sized queue using a linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like a stack, we want to implement a queue using a linked list. We need
    to remember that all operations must be *O(1)* in running time. If we enqueue
    by appending new elements at the beginning of the linked list, we will need to
    remove elements from the end of the list during dequeuing. This will not work
    as removal of an element from the end of a linked list is *O(n)*. But appending
    at the end of a linked list is *O(1)* and so is removing from the beginning of
    the list. Hence, the end of the queue, where new elements are enqueued, would
    be the end of the list. And the start of the queue, where the elements are dequeued
    from, would be the beginning of the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, the implementation of a queue using a linked list is straightforward.
    Again, we create an instance of the list only using a `getNewLinkedList()` method,
    which can be overridden by a subclass to use a different linked list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enqueue` operation simply appends at the end of the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dequeue` operation first checks if the list is empty so it can return
    `null`, and then it simply removes the first element from the list. It must also
    return the element that it just removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `dequeue` operation, the `peek` operation first needs to check
    whether the list is empty, in which case it has to return a `null` value, otherwise
    it simply returns the element at the beginning of the list that would be dequeued
    on the next `dequeue` operation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Double ended queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A double ended queue is a combination of a stack and a queue. The idea is that
    you are allowed to insert and remove elements at both ends of the queue. If you
    remove elements from the side you have inserted, it will behave like a stack.
    On the other hand, if you insert and remove on opposite ends, it will behave like
    a queue. You can mix these operations and use them in any order you like. The
    following figure shows a few operations to clarify this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Double ended queue](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A double ended queue has the following operations all with a complexity of
    *O(n)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: This inserts an element at the beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop**: This removes an element from the beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inject**: This inserts an element at the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eject**: This removes an element from the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peek**: This checks the first element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PeekLast**: This checks the last element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A double ended queue will be represented by the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that since a double ended queue has `push` and `pop` operations just like
    a stack and it preserves the same meaning, we create this interface extending
    the `Stack` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-length double ended queue using an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have created the double ended queue as an extension of a stack, one
    would expect its implementation to extend a stack implementation as well. However,
    remember that a double ended queue is both a stack and a queue. The array-based
    implementation for a queue was more complex than that for a stack due to rollover
    of the indexes. We don''t want to reprogram those, so we choose to extend a queue
    implementation instead of a stack implementation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the queue to the fixed length, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is appended at the end of the double ended queue, which is the same as
    the `enqueue` operation of a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eject` operation is the removal of an element from the end of the double
    ended queue. We don''t have an equivalent operation in a simple queue. So, we
    must code for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `end` has to decrement by one with a provision for rollover. But if the
    `end` is already at zero, it will become negative, which will not work well with
    the modulo operator, because it will return a negative value. To always keep it
    positive, we add the length of the array to it. Note that it does not change the
    remainder when divided by the length of the array. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `peekLast` operation simply needs to return the element that would have
    been returned by the `eject` operation without modifying anything, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `push` operation is the insertion of an element at the beginning of the
    double ended queue. There is no equivalent operation in a simple queue. Hence,
    we need to code for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation is very similar to updating the end index `eject` operation,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pop` operation is the removal of the element at the beginning of the queue,
    which is the same as the `dequeue` operation of an ordinary queue. This is illustrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't write any code for the peek operation, which should return
    the element at the beginning of the double ended queue, as it is the same as the
    peek operation for a simple queue.
  prefs: []
  type: TYPE_NORMAL
- en: The array-based implementation is, of course, fixed in size and cannot hold
    more elements than it's fixed size. Next, we develop a linked list-based implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-sized double ended queue using a linked list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We had earlier used a simple linked list to implement both a queue and a stack.
    However, remember again that all operations must be *O(1)*. Now, we must both
    add and remove elements at both ends of the underlying linked list. We know that
    removal from the end of a singly linked list is *O(n)* and we cannot use it. So,
    we must use a doubly linked list instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we do not have to worry about rollovers and so we will extend the
    linked list implementation of a stack, which is the natural choice. We will replace
    its singly linked list with a doubly linked list by overriding the `getLinkedList()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inject` operation inserts a new element at the end of the list as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eject` operation must remove and return the last element of the list.
    This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `peekLast()` method will just return the last element of the doubly
    linked list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We only had to implement the `inject()`, `eject()`, and `peekLast()` methods
    as the other methods are already implemented by the stack we extend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw that an abstract data type or ADT is an abstraction
    of a data structure. It is a contract that an underlying data structure is supposed
    to adhere to. The contract involves different operations on the data structure
    and their specific behavior. We then saw a few simple ADTs as examples. These
    ADTs are, however, extremely useful as we will see in the course of this book
    when we encounter other algorithms. Abstraction allows different implementations
    of the structures. We will also see more ADTs in the course of this book and their
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a detour into a new area of algorithms called
    **functional programming**. Remember that an algorithm is a sequence of steps
    that may be followed to achieve a desired processing; it turns out that there
    is another way of looking at it, which we will explore in the next chapter.
  prefs: []
  type: TYPE_NORMAL
