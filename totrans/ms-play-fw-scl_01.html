<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Play</h1></div></div></div><p>The World Wide Web has grown by leaps and bounds since its first appearance in August 1991. It has come a long way from line mode browsers and static websites to graphical browsers and highly interactive websites, such as search engines, online department stores, social networking, gaming, and so on.</p><p>Complex websites or applications are backed by one or more databases and several lines of code. In most cases, such web applications use a framework to simplify the development process. A framework provides a skeleton structure that handles most of the repetitive or common features. Ruby on Rails, Django, Grails, and Play are a few examples of this.</p><p>Play Framework was developed by Guillaume Bort while he was working at Zenexity (now Zengularity). Its <a id="id0" class="indexterm"/>first full release was in October 2009 for version 1.0. In 2011, Sadek Drobi joined Guillaume Bort to develop Play 2.0, which was adopted by Typesafe Stack 2.0. Play 2.0 was released on March 13, 2012.</p><p>In this chapter, we will be covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The reasons for choosing Play</li><li class="listitem" style="list-style-type: disc">Creating a sample Play application</li><li class="listitem" style="list-style-type: disc">Creating a TaskTracker application</li></ul></div><div class="section" title="Venturing into the world of Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Venturing into the world of Play</h1></div></div></div><p>Play's installation is <a id="id1" class="indexterm"/>hassle free. If you have Java JDK 6 or a later version, all you need to do to get Play working is an installation of <span class="strong"><strong>Typesafe Activator</strong></span> or <span class="strong"><strong>Simple Build Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>).</p><p>Play is fully RESTful! <span class="strong"><strong>Representational State Transfer </strong></span>(<span class="strong"><strong>REST</strong></span>) is an architectural style, which <a id="id2" class="indexterm"/>relies on a stateless, client-server, and <a id="id3" class="indexterm"/>cache-enabled communication protocol. It's a lightweight alternative to mechanisms such as <span class="strong"><strong>Remote Procedure Calls</strong></span> (<span class="strong"><strong>RPC</strong></span>) and web services (which include SOAP, WSDL, and so on). Here stateless means that the client state data is not stored on the server and every request should include all the data required for the server to process it successfully. The server does not rely on previous data to process the current request. The clients store their session state and the servers can service many more clients in a stateless fashion. The Play build system uses <span class="strong"><strong>Simple Build Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>), which is a build tool used for Scala and Java. It also has a <a id="id4" class="indexterm"/>plugin to allow native compilation of C and C++. SBT uses incremental recompilation to reduce the compilation time and can be run in triggered execution mode, which means that if specified by the user, required tasks will be run whenever the user saves changes in any of the source files. This feature in particular has been leveraged by the Play Framework so that developers need not redeploy after every change in development stage. This means that if a Play app is running from source on your local machine and you edit its code, you can view the updated app just by reloading the app in the browser.</p><p>It provides a default test framework along with helpers and application stubs to simplify both unit and functional <a id="id5" class="indexterm"/>testing of the application. <span class="strong"><strong>Specs2</strong></span> is the default testing framework used in Play.</p><p>Play comes with a Scala-based template engine, due to which it is possible to use Scala objects (<code class="literal">String</code>, <code class="literal">List</code>, <code class="literal">Map</code>, <code class="literal">Int</code>, user-defined objects, and so on) in the templates. This was not possible prior to 2.0 because earlier versions of Play relied on Groovy for the template engine.</p><p>It uses JBoss Netty as the default web server but any Play 2 application can be packaged as a WAR file and deployed on Servlet 2.5, 3.0, and 3.1 containers, if required. There is a plugin called <a id="id6" class="indexterm"/>
<span class="strong"><strong>play2-war-plugin</strong></span> (it can be found at <a class="ulink" href="https://github.com/play2war/play2-war-plugin/">https://github.com/play2war/play2-war-plugin/</a>), which can be used to generate the WAR file for any given Play2 app.</p><p>Play endorses the <a id="id7" class="indexterm"/>
<span class="strong"><strong>Model-View-Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) pattern. According to the MVC pattern, the components of an application can be divided into three categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model</strong></span>: This represents application data or activity</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View</strong></span>: This is the part of the application which is visible to the end user</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Controller</strong></span>: This is responsible for processing input from the end user</li></ul></div><p>The pattern also defines how these components are supposed to interact with one another. Let's consider an online store as our application. In this case, the products, brands, users, cart, and so on can be represented by a model each. The pages in the application where users can view the products are defined in the views (HTML pages). When a user adds a product to the cart, the transaction is handled by a controller. The view is unaware of the model and the model is unaware of the view. The controller sends commands to the model and view. The following figure shows how the models, views, and controllers interact:</p><div class="mediaobject"><img src="graphics/3803OS_01_07.jpg" alt="Venturing into the world of Play"/></div><p>Play also comes prepackaged with an easy to use Hibernate layer, and offers OpenID, Ehcache, and web service integration straight out of the box by adding a dependency on the individual modules.</p><p>In the following sections of this chapter, we'll make a simple app using Play. This is mainly for developers who are using Play earlier.</p><div class="section" title="A sample Play app"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>A sample Play app</h2></div></div></div><p>There are two ways of <a id="id8" class="indexterm"/>creating a new Play application: Activator, and without using Activator. It is simpler to create a Play project using Activator since the most minimalist app would require at least six files.</p><p>
<span class="strong"><strong>Typesafe Activator</strong></span> is <a id="id9" class="indexterm"/>a tool that can be used to create applications using the Typesafe stack. It relies on using predefined templates to create new projects. The <a id="id10" class="indexterm"/>instructions for setting up Activator can be found at <a class="ulink" href="http://typesafe.com/get-started">http://typesafe.com/get-started</a>.</p><div class="section" title="Building a Play application using Activator"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Building a Play application using Activator</h3></div></div></div><p>Let's build <a id="id11" class="indexterm"/>a new Play application using <a id="id12" class="indexterm"/>Activator and a simple template:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ activator new pathtoNewApp/sampleApp just-play-scala</strong></span>
</pre></div><p>Then, run the project using the <code class="literal">run</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sampleApp $ sbt run</strong></span>
</pre></div><p>This starts the application, which is accessible at <code class="literal">http://localhost:9000</code>, by default.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The <code class="literal">run</code> command starts the project in development mode. In this mode, the source code of the application is watched for changes, and if there are any changes the code is recompiled. We can then make changes to the models, views, or controllers and see them reflected in the application by reloading the browser.</p></div></div><p>Take a look at the <a id="id13" class="indexterm"/>project structure. It will be similar to <a id="id14" class="indexterm"/>the one shown here:</p><div class="mediaobject"><img src="graphics/3803OS_01_01.jpg" alt="Building a Play application using Activator"/></div><p>If we can't use Activator, we will probably have to create all these files. Now, let's dig into the files individually and see which is for what purpose.</p><div class="section" title="The build definition"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>The build definition</h4></div></div></div><p>Let's start with the <a id="id15" class="indexterm"/>crucial part of the project—its build definition, and in our case, the <code class="literal">build.sbt</code> file. The <code class="literal">.sbt</code> extension comes from the build tool used for Play applications. We will go through the key concepts of this for anyone who isn't familiar with SBT. The build definition is essentially a list of keys and their corresponding values, more or less like assignment statements with the <code class="literal">:=</code> symbol acting as the assignment operator.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>SBT version lower than 0.13.7 expects a new line as the delimiter between two different statements in the build definition.</p></div></div><p>The contents of the build file are:</p><div class="informalexample"><pre class="programlisting">name := "sampleApp"""

version := "1.0.0"

lazy val root = project.in(file(".")).enablePlugins(PlayScala)</pre></div><p>In the preceding build definition, the values for the project's <code class="literal">name</code>, <code class="literal">version</code>, and <code class="literal">root</code> are specified. Another <a id="id16" class="indexterm"/>way of specifying values is by updating the existing ones. We can append to the existing values using the <code class="literal">+=</code> symbol for individual items and <code class="literal">++=</code> for sequences. For example:</p><div class="informalexample"><pre class="programlisting">resolvers += Resolver.sonatypeRepo("snapshots")

scalacOptions ++= Seq("-feature", "-language:reflectiveCalls")</pre></div><p>
<code class="literal">resolvers</code> is the list of URLs from where the dependencies can be picked up and <code class="literal">scalacOptions</code> is the list of parameters passed to the Scala compiler.</p><p>Alternatively, an SBT project can also use a <code class="literal">.scala</code> build file. The structure for our application would then be:</p><div class="mediaobject"><img src="graphics/3803OS_01_02.jpg" alt="The build definition"/></div><p>The <code class="literal">.scala</code> build <a id="id17" class="indexterm"/>definition for <code class="literal">SimpleApp</code> will be:</p><div class="informalexample"><pre class="programlisting">import sbt._
import Keys._
import play.Play.autoImport._
import PlayKeys._

object ApplicationBuild extends Build {

  val appName = "SimpleApp"
  val appVersion = "1.0.0"


  val appDependencies = Seq(
    // Add your project dependencies here
  )

  val main = Project(appName, file(".")).enablePlugins(play.PlayScala).settings(
    version := appVersion,
    libraryDependencies ++= appDependencies
  )

}</pre></div><p>The <code class="literal">.scala</code> build definition comes in handy when we need to define custom tasks/settings for our application/plugin, since it uses Scala code. The <code class="literal">.sbt</code> definition is generally smaller and simpler than its corresponding <code class="literal">.scala</code> definition and is hence, more preferred.</p><p>Without the Play settings, which are imported by enabling the PlayScala plugin, SBT is clueless that our project is a Play application and is defined according to the semantics of a Play application.</p><p>So, is that statement sufficient for SBT to run a Play app correctly?</p><p>No, there is something else as well! SBT allows us to extend build definitions using plugins. Play-based projects make use of the Play SBT plugin and it is from this plugin that SBT gets the required settings. In order for SBT to download all the plugins that our project will be using, they should be added explicitly. This is done by adding them in <code class="literal">plugins.sbt</code> in the <code class="literal">projectRoot/project</code> directory.</p><p>Let's take a look at the <code class="literal">plugins.sbt</code> file. The file content will be:</p><div class="informalexample"><pre class="programlisting">resolvers += "Typesafe repository" at "http://repo.typesafe.com/typesafe/releases/"

addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.3.8")</pre></div><p>The parameter passed to <code class="literal">addSbtPlugin</code> is the Ivy module ID for the plugin. The resolver is helpful when the plugin is not hosted on Maven or Typesafe repositories.</p><p>The <code class="literal">build.properties</code> file is <a id="id18" class="indexterm"/>used to specify the SBT version to avoid incompatibility issues between the same build definitions compiled by using two or more different versions of SBT.</p><p>This covers all the build-related files of a Play application.</p></div><div class="section" title="The source code"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec02"/>The source code</h4></div></div></div><p>Now, let us look at the <a id="id19" class="indexterm"/>source code for our project. Most of the source is in the <code class="literal">app</code> folder. Generally, the model's code is within <code class="literal">app/models</code> or <code class="literal">app/com/projectName/models</code> and the controller's source code is in <code class="literal">app/co</code>
<code class="literal">ntrollers</code> or <code class="literal">app/com/projectName/controllers</code>, where <code class="literal">com.projectName</code> is the package. The code for the views should be in <code class="literal">app/views</code> or within a subfolder in <code class="literal">app/views</code>.</p><p>The <code class="literal">views/main.scala.html</code> file is the page we will be able to see when we run our application. If this file is missing, you can add it. If you are wondering why the file is named <code class="literal">main.scala.html</code> and not <code class="literal">main.html</code>, this is because it's a Twirl template; it facilitates using Scala code along with HTML to define views. We will delve deeper into this in <a class="link" href="ch04.html" title="Chapter 4. Exploring Views">Chapter 4</a>, <span class="emphasis"><em>Exploring Views</em></span>.</p><p>Now, update the <a id="id20" class="indexterm"/>content of <code class="literal">main.scala.html</code> to:</p><div class="informalexample"><pre class="programlisting">@(title: String)(content: Html)

&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;@title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    @content
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We can provide the title and content from our Scala code to display this view. A view can be bound to a specific request through the controllers. So, let's update the code for our controller <code class="literal">SampleAppController</code>, as follows:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._
import play.api.templates.Html

object SampleAppController extends Controller {
  def index = Action {
    val content = Html("&lt;div&gt;This is the content for the sample app&lt;div&gt;")
        Ok(views.html.main("Home")(content))
  }
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>
<code class="literal">Action</code> and <code class="literal">Ok</code> are methods made available by the <code class="literal">play.mvc.api</code> package. <a class="link" href="ch02.html" title="Chapter 2. Defining Actions">Chapter 2</a>, <span class="emphasis"><em>Defining Actions</em></span> covers them in detail.</p><p>On saving the changes and running the application, we will see the page hosted at <code class="literal">http://localhost:9000</code>, as shown in the screenshot:</p><div class="mediaobject"><img src="graphics/3803OS_01_03.jpg" alt="The source code"/></div></div><div class="section" title="Request handling process"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec03"/>Request handling process</h4></div></div></div><p>Let's see how the request was handled!</p><p>All requests that <a id="id21" class="indexterm"/>will be supported by the application must be defined in the <code class="literal">conf/routes</code> file. Each route definition has three parts. The first part is the request method. It can be any one of <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code>. The second part is the path and the third is the method, which returns a response. When a request is defined in the <code class="literal">conf/routes</code> file, the method to which it is mapped in the <code class="literal">conf/routes</code> file is called.</p><p>For example, an entry in the routes file would be:</p><div class="informalexample"><pre class="programlisting">GET         /                        controllers.SampleAppController.index</pre></div><p>This means that for a GET request on the <code class="literal">/</code> path, we have mapped the response to be the one returned from the <code class="literal">SampleController.index()</code> method.</p><p>A sample request would be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl 'http://localhost:9000/' </strong></span>
</pre></div><p>Go ahead and add a few more pages to the application to get more comfortable, maybe a FAQ, Contact Us, or About.</p><p>The request-response cycle for a Play app, explained in the preceding code is represented here:</p><div class="mediaobject"><img src="graphics/3803OS_01_08.jpg" alt="Request handling process"/></div><p>The <code class="literal">public</code> directory is essentially used to serve resources, such as stylesheets, JavaScript, and images that are independent of Play. To make these files accessible, the path to <code class="literal">public</code> is also added in routes by default:</p><div class="informalexample"><pre class="programlisting">GET         /assets/*file            controllers.Assets.at(path="/public", file)</pre></div><p>We will see routes <a id="id22" class="indexterm"/>in detail in <a class="link" href="ch03.html" title="Chapter 3. Building Routes">Chapter 3</a>, <span class="emphasis"><em>Building Routes</em></span>.</p><p>The file <code class="literal">conf/application.conf</code> is used to set application-level configuration properties.</p><p>The <code class="literal">target</code> directory is used by SBT for the files generated during compile, build, or other processes.</p></div></div></div><div class="section" title="Creating a TaskTracker application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Creating a TaskTracker application</h2></div></div></div><p>Let us create a simple <a id="id23" class="indexterm"/>
<span class="strong"><strong>TaskTracker</strong></span> application, which allows us to add pending tasks and delete them. We will continue by modifying <code class="literal">SampleApp</code>, built in the previous section. In this app, we will not be using a DB to store the tasks. It is possible to persist models in Play using <span class="strong"><strong>Anorm</strong></span> or other modules; this is discussed in more detail in <a class="link" href="ch05.html" title="Chapter 5. Working with Data">Chapter 5</a>, <span class="emphasis"><em>Working with Data</em></span>.</p><p>We need a view that has an input box to enter the task. Add another template file, <code class="literal">index.scala.html</code>, to the views, using the template generated in the preceding section as boilerplate:</p><div class="informalexample"><pre class="programlisting">@main("Task Tracker") {

    &lt;h2&gt;Task Tracker&lt;/h2&gt;

    &lt;div&gt;
        &lt;form&gt;
        &lt;input type="text" name="taskName" placeholder="Add a new Task" required&gt;

        &lt;input type="submit" value="Add"&gt;
        &lt;/form&gt;
    &lt;/div&gt;

}</pre></div><p>In order to use a template, we can call its generated method from our Scala code or refer to it in other templates by using its name. Using a main template can come in handy when we want to apply a change to <a id="id24" class="indexterm"/>all the templates. For example, if we want to add a style sheet for an application, just adding this in our main template will ensure that it's added for all the dependent views.</p><p>To view this template's content on loading, update the <code class="literal">index</code> method to:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._

object TaskController extends Controller {
  def index = Action {
    Ok(views.html.index())
  }
}</pre></div><p>Notice that we have also replaced all occurrences of <code class="literal">SampleAppController</code> to <code class="literal">TaskController</code>.</p><p>Run the application and view it in the browser; the page will look similar to this figure:</p><div class="mediaobject"><img src="graphics/3803OS_01_04.jpg" alt="Creating a TaskTracker application"/></div><p>Now, in order to work on the functionality, let's add a model called <code class="literal">Task</code>, which we'll use to represent the task in our app. Since we want to delete the functionality too, we will need to identify each task using <a id="id25" class="indexterm"/>a unique ID, which means that our model should have two properties: an ID and a name. The <code class="literal">Task</code> model will be:</p><div class="informalexample"><pre class="programlisting">package models

case class Task(id: Int, name: String)

object Task {

  private var taskList: List[Task] = List()

  def all: List[Task] = {
    taskList
  }

  def add(taskName: String) = {
    val newId: Int = taskList.last.id + 1
    taskList = taskList ++ List(Task(newId, taskName))
  }

  def delete(taskId: Int) = {
    taskList = taskList.filterNot(task =&gt; task.id == taskId)
  }
}</pre></div><p>In this model, we are using a <code class="literal">taskList</code> private variable to keep track of the tasks for the session.</p><p>In the <code class="literal">add</code> method, whenever a new task is added, we append it to this list. Instead of keeping another variable to keep count of the IDs, I choose to increment the ID of the last element in the list.</p><p>In the <code class="literal">delete</code> method, we simply filter out the task with the given ID and the <code class="literal">all</code> method returns the list for this session.</p><p>Now, we need to call these <a id="id26" class="indexterm"/>methods in our controller and then bind them to a request route. Now, update the controller in this way:</p><div class="informalexample"><pre class="programlisting">import models.Task
import play.api.mvc._

object TaskController extends Controller {

  def index = Action {
    Redirect(routes.TaskController.tasks)
  }

  def tasks = Action {
    Ok(views.html.index(Task.all))
  }

  def newTask = Action(parse.urlFormEncoded) {
    implicit request =&gt;
      Task.add(request.body.get("taskName").get.head)
      Redirect(routes.TaskController.index)
  }

  def deleteTask(id: Int) = Action {
    Task.delete(id)
    Ok
  }

}</pre></div><p>In the preceding code, <code class="literal">routes</code> refers to the helper that can be used to access the routes defined for the application in <a id="id27" class="indexterm"/>
<code class="literal">conf/routes</code>. Try running the app now!</p><p>It'll throw a compilation error, which says that values tasks is not a member of <code class="literal">controllers.ReverseTaskController</code>. This occurs because we haven't yet updated the routes.</p><div class="section" title="Adding a new task"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Adding a new task</h3></div></div></div><p>Now, let's bind <a id="id28" class="indexterm"/>actions to get tasks and add a new task:</p><div class="informalexample"><pre class="programlisting">GET           /                    controllers.TaskController.index

# Tasks
GET           /tasks               controllers.TaskController.tasks
POST          /tasks               controllers.TaskController.newTask</pre></div><p>We'll complete our application's view so that it can facilitate the following:</p><p>
<code class="literal">accept and render a List[Task]</code>
</p><div class="informalexample"><pre class="programlisting">@(tasks: List[Task])

@main("Task Tracker") {

    &lt;h2&gt;Task Tracker&lt;/h2&gt;
    &lt;div&gt;
        &lt;form action="@routes.TaskController.newTask()" method="post"&gt;
            &lt;input type="text" name="taskName" placeholder="Add a new Task" required&gt;
            &lt;input type="submit" value="Add"&gt;
        &lt;/form&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;ul&gt;
        @tasks.map { task =&gt;
            &lt;li&gt;
                @task.name
            &lt;/li&gt;
        }
        &lt;/ul&gt;
    &lt;/div&gt;
}</pre></div><p>We have now added a form in the view, which takes a text input with the <code class="literal">taskName</code> name and submits this <a id="id29" class="indexterm"/>data to a <code class="literal">TaskController.newTask</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Notice that we have now added a <code class="literal">tasks</code> argument for this template and are displaying it in the view. Scala elements and predefined templates are prepended with the <code class="literal">@</code> twirl symbol in the views.</p></div></div><p>Now, when running the app, we will be able to add tasks as well as view existing ones, as shown here:</p><div class="mediaobject"><img src="graphics/3803OS_01_05.jpg" alt="Adding a new task"/></div></div><div class="section" title="Deleting a task"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Deleting a task</h3></div></div></div><p>The only thing <a id="id30" class="indexterm"/>remaining in our app is the ability to delete a task. Update the index template so that each <code class="literal">&lt;li&gt;</code> element has a button, whose click results in a delete request to the server:</p><div class="informalexample"><pre class="programlisting">            &lt;li&gt;
                @task.name &lt;button onclick="deleteTask ( @task.id) ;"&gt;Remove&lt;/button&gt;
            &lt;/li&gt;</pre></div><p>Then, we would need to update the routes file to map the delete action:</p><div class="informalexample"><pre class="programlisting">DELETE        /tasks/:id         controllers.TaskController.deleteTask (id: Int).</pre></div><p>We also need to define <code class="literal">deleteTask</code> in our view. To do this, we can simply add a script:</p><div class="informalexample"><pre class="programlisting">    &lt;script&gt;
    function deleteTask ( id ) {
        var req = new XMLHttpRequest ( ) ;
        req.open ( "delete", "/tasks/" + id ) ;
        req.onload = function ( e ) {
            if ( req.status = 200 ) {
                document.location.reload ( true ) ;
            }
        } ;
        req.send ( ) ;

    }
    &lt;/script&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Ideally, we shouldn't be defining JavaScript methods in the window's global namespace. It has been done in this example, so as to keep it simple and it's not advised for any real-time application.</p></div></div><p>Now, when we run the <a id="id31" class="indexterm"/>app, we can add tasks as well as remove them, as shown here:</p><div class="mediaobject"><img src="graphics/3803OS_01_06.jpg" alt="Deleting a task"/></div><p>I am leaving the task of beautifying the app up to you. Add a style sheet in the public directory and declare it in the main template. For example, if the <code class="literal">taskTracker.css</code> file is located at <code class="literal">public/stylesheets</code>, the link to it in the <code class="literal">main.scala.html</code> file would be:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/taskTracker.css")"&gt;</pre></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Summary</h1></div></div></div><p>This chapter gives a basic introduction to the Play Framework. In this chapter, we have learned how to build simple applications using the Play Framework. We have gone through its project structure to understand how the framework plugs in required settings through the build file. We have also discussed the various bits and pieces of such applications: models, routes, views, controllers, and so on.</p><p>In the next chapter, we will cover actions in detail.</p></div></body></html>