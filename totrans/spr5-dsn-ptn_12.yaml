- en: Implementing Concurrency Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发模式
- en: In [Chapter 11](313a6506-6bc8-4785-a51b-1637f219bd00.xhtml), *Implementing Reactive
    Design Patterns*, we discussed the Reactive Design Pattern and how it fulfills
    the requirements of today's applications. Spring 5 Framework has introduced the
    Reactive Web Application Modules for the web application. In this chapter, we
    will explore some of the Concurrency Design Patterns and how these patterns solve
    the common problems of the multithreaded application. Spring 5 Framework's reactive
    modules also provide the solution for the multithreaded application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](313a6506-6bc8-4785-a51b-1637f219bd00.xhtml)《实现反应式设计模式》中，我们讨论了反应式设计模式及其如何满足当今应用的需求。Spring
    5框架为Web应用引入了反应式Web应用模块。在本章中，我们将探讨一些并发设计模式以及这些模式如何解决多线程应用中的常见问题。Spring 5框架的反应式模块也为多线程应用提供了解决方案。
- en: If you are a software engineer or are in the process of becoming one, you must
    be aware of the term *concurrency*. In geometric properties, concurrent circles
    or shapes are those shapes that have a common center point. These shapes can differ
    in dimensions but have a common center or midpoint.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名软件工程师或者正在成为软件工程师的过程中，你必须知道“并发”这个术语。在几何属性中，共点圆或形状是指那些具有共同中心点的形状。这些形状在尺寸上可能不同，但有一个共同的中心或中点。
- en: The concept is similar in terms of software programming as well. The term *concurrent
    programming* in the technical or programming means the ability of a program to
    carry out multiple computations in parallel and also the capability of a program
    to handle multiple external activities taking place in a single time interval.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件编程方面，这个概念是相似的。在技术或编程中，“并发编程”一词意味着程序执行多个并行计算的能力，以及程序在单个时间间隔内处理多个外部活动的能力。
- en: 'As we are talking in terms of software engineering and programming, concurrency
    patterns are those design patterns that help in dealing with multi-threaded programming
    models. Some of the concurrency patterns are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论软件工程和编程时，并发模式是那些帮助处理多线程编程模型的设计模式。以下是一些并发模式：
- en: Handling concurrency with concurrency patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发模式处理并发
- en: Active object pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃对象模式
- en: Monitor object pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视对象模式
- en: Half-Sync/Half-Async patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半同步/半异步模式
- en: Leader/followers pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领导/跟随模式
- en: Thread-specific storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程特定存储
- en: Reactor pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应器模式
- en: Best practices for concurrency module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模块的最佳实践
- en: Let's now explore each of these five concurrency design patterns in depth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨这五种并发设计模式。
- en: Active object pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活跃对象模式
- en: 'The active object type of concurrency design pattern differentiates/distinguishes
    the method execution from the method invocation. The job of this pattern is the
    enhancement of concurrency along with simplification in the synchronized access
    to objects that reside in separate and distinguishable threads of control. It
    is used for dealing with the multiple client requests that arrive all at once,
    and also for improving the quality of the service. Let''s see the following diagrams,
    which illustrates the active object design pattern in the concurrency and multithread-based
    application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发设计模式的活跃对象类型区分了方法执行与方法调用。这个模式的工作是增强并发性，同时简化对位于不同且可区分的控制线程中的对象的同步访问。它用于处理同时到达的多个客户端请求，并且也有助于提高服务质量。让我们看看以下图表，这些图表展示了并发和多线程应用中的活跃对象设计模式：
- en: '![](img/57d27554-470b-4014-8f1f-3aac617b382f.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57d27554-470b-4014-8f1f-3aac617b382f.jpg)'
- en: 'As you can see in the preceding diagram, the following components of this concurrency
    design pattern:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图中可以看到，以下是这个并发设计模式的组件：
- en: '**Proxy**: This is the active object that is visible to the client. The proxy
    advertises its interface.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：这是对客户端可见的活跃对象。代理宣传其接口。'
- en: '**Servant**: There is a method that is defined in the interface of the proxy.
    The servant is the provider of its implementation.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仆人**：在代理的接口中定义了一个方法。仆人是其实施的提供者。'
- en: '**Activation list**: This is a serialized list that contains method request
    objects that the proxy inserts. This list allows the servant to run concurrently.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活列表**：这是一个序列化的列表，包含代理插入的方法请求对象。这个列表允许仆人并发运行。'
- en: So, how does this design pattern work? Well, the answer to this is that every
    concurrent object belongs to or resides in a separate thread of control. This
    is also independent of the thread of control of the client. This invokes one of
    its methods, which means that both the method execution and method invocation
    take place in separate threads of control. However, the client sees this process
    as an ordinary method. In order for the proxy to pass the requests of the client
    to the servant at runtime, both must be run in separate threads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个设计模式是如何工作的呢？答案是，每个并发对象都属于或存在于一个单独的控制线程中。这也独立于客户端的控制线程。这意味着它会调用其方法，也就是说，方法执行和方法调用都在单独的控制线程中进行。然而，客户端将这个过程视为一个普通的方法。为了在运行时将客户端的请求传递给仆人，两者都必须在单独的线程中运行。
- en: In this design pattern, what the proxy does after receiving a request is that
    it sets up a method request object and inserts it in an activation list. This
    method carries out two jobs; holds the method request objects and keeps track
    of on which method request it can execute. Request parameters and any other information
    are contained in the method request object for executing the desired method later.
    This activation list in return helps the proxy and the servant to run concurrently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计模式中，代理在收到请求后所做的是设置一个方法请求对象并将其插入激活列表中。这个方法执行两个任务；保持方法请求对象并跟踪它可以在哪个方法请求上执行。请求参数和任何其他信息都包含在方法请求对象中，以便稍后执行所需的方法。这个激活列表反过来帮助代理和仆人并发运行。
- en: Let's see another concurrency design pattern in the upcoming section, which
    is the monitor object pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看另一个并发设计模式，即监控对象模式。
- en: Monitor object pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控对象模式
- en: The monitor object pattern is another concurrency design pattern that helps
    in the execution of multi-threaded programs. It is a design pattern implemented
    to make sure that at a single time interval, only one method runs in a single
    object, and for this purpose, it synchronizes concurrent method execution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 监控对象模式是另一种并发设计模式，有助于多线程程序的执行。它是一种设计模式，旨在确保在单个时间间隔内，只有一个方法在一个对象中运行，为此，它同步并发方法执行。
- en: Unlike the active object design pattern, the monitor object pattern does not
    have a separate thread of control. Every request received is executed in the thread
    of control of the client itself, and until the time the method returns, the access
    is blocked. At a single time interval, a single synchronized method can be executed
    in one monitor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动对象设计模式不同，监控对象模式没有单独的控制线程。每个接收到的请求都在客户端自己的控制线程中执行，并且直到方法返回，访问将被阻塞。在单个时间间隔内，一个同步方法可以在一个监控器中执行。
- en: 'The following solutions are offered by the monitor object pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由监控对象模式提供的解决方案：
- en: The synchronization boundaries are defined by the interface of the object, and
    it also makes sure that a single method is active in a single object.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步边界由对象的接口定义，并确保在单个对象中只有一个活动方法。
- en: It must be ensured that all the objects keep a check on every method that needs
    synchronization and serialize them transparently without letting the client know.
    Operations, on the other hand, are mutually exclusive, but they are invoked like
    ordinary method calls. Wait and signal primitives are used for the realization
    of condition synchronization.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须确保所有对象都检查需要同步的每个方法，并透明地序列化它们，而不让客户端知道。另一方面，操作是互斥的，但它们像普通方法调用一样被调用。等待和信号原语用于实现条件同步。
- en: To prevent the deadlock and use the concurrency mechanisms available, other
    clients must be allowed to access the object when the method of the object blocks
    during execution.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止死锁并使用可用的并发机制，当对象的方法在执行过程中阻塞时，必须允许其他客户端访问该对象。
- en: The invariants must always hold when the thread of control is interrupted voluntarily
    by the method.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当控制线程被方法自愿中断时，必须始终保持不变量。
- en: 'Let''s see the following diagram, which illustrates more about the monitor
    object design pattern in the concurrency application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图示，它展示了在并发应用程序中监控对象设计模式的更多内容：
- en: '![](img/ad5ee399-9e8f-4e4b-b51b-373ad439dbe3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad5ee399-9e8f-4e4b-b51b-373ad439dbe3.png)'
- en: 'In this preceding diagram, the client object calls the monitor object that
    has several synchronized methods and the monitor object associated with the monitor
    conditions and monitor locks. Let''s explore each component of this concurrency
    design pattern as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此前面的图中，客户端对象调用具有多个同步方法的监控对象，以及与监控条件和监控锁关联的监控对象。让我们如下探索此并发设计模式的每个组件：
- en: '**Monitor object**: This component exposes the methods that are synchronized
    to the clients'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控对象**: 此组件公开了同步到客户端的方法'
- en: '**Synchronized methods**: The thread-safe functions that are exported by the
    interface of the object are implemented by these methods'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步方法**: 这些方法实现了由对象接口导出的线程安全函数'
- en: '**Monitor conditions**: This component along with the monitor lock decides
    whether the synchronized method should resume its processing or suspend it'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控条件**: 此组件与监控锁一起决定同步方法是否应该继续其处理或挂起'
- en: The active object and the monitor object patterns are the branches of design
    patterns of concurrency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 活动对象和监控对象模式是并发设计模式的分支。
- en: Now, the other type of concurrency patterns that we will discuss are the branches
    of architectural patterns for concurrency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论的其他类型的并发模式是并发架构模式的分支。
- en: Half-Sync/Half-Async patterns
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 半同步/半异步模式
- en: The job of Half-Sync and Half-Async is to distinguish between the two types
    of processing called asynchronous and synchronous, for the simplification of the
    program without hindering its performance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 半同步和半异步的任务是区分两种处理类型（异步和同步），以简化程序而不影响其性能。
- en: The two layers intercommunicating are introduced for both asynchronous and synchronous
    services for the purpose of processing with a queuing layer in between.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在队列层之间进行处理，引入了两个相互通信的层，用于异步和同步服务。
- en: Every concurrent system contains both asynchronous and synchronous services.
    To enable these services to communicate with each other, the Half-Sync/Half-Async
    pattern decomposes the services in the system into layers. Using the queuing layer,
    both these services pass messages to each other for intercommunication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个并发系统都包含异步和同步服务。为了使这些服务能够相互通信，半同步/半异步模式将系统中的服务分解为层。使用队列层，这两个服务相互传递消息以进行交互通信。
- en: 'Let''s see the following diagram that illustrates these design patterns:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图，它说明了这些设计模式：
- en: '![](img/3ac500d9-772d-4adc-b337-c409fd5c7b19.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ac500d9-772d-4adc-b337-c409fd5c7b19.png)'
- en: As you can see in the preceding diagram, there are three layers--**Synchronous
    Service Layer**, **Queuing Layer**, and **Asynchronous Service Layer**. Synchronous
    layer contains the services that are working synchronously to the queue at the
    **Queuing Layer**, and this query performs asynchronously using Asynchronous services
    at the **Asynchronous Service Layer**. These Asynchronous Services at this layer
    are using the external event-based resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，有三个层--**同步服务层**、**队列层**和**异步服务层**。同步层包含与队列层同步工作的服务，并且此查询使用异步服务在**异步服务层**异步执行。此层的异步服务使用基于外部事件资源。
- en: 'As you can see in the preceding diagram, there are three layers included here.
    Let''s look at these layers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，这里包含三个层。让我们看看这些层：
- en: '**Synchronous Task Layer**: The tasks in this layer are active objects. High-level
    input and output operations are carried by these tasks, which transfer the data
    synchronously towards the queuing layer.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步任务层**: 此层中的任务是活动对象。高级输入和输出操作由这些任务执行，它们将数据同步地传输到队列层。'
- en: '**Queuing Layer**: This layer provides the synchronization and buffering required
    between the synchronous and asynchronous task layers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列层**: 此层提供了同步和缓冲，这是在同步和异步任务层之间所需的。'
- en: '**Asynchronous Task Layer**: The events from the external sources are handled
    by the tasks present in this layer. These tasks do not contain a separate thread
    of control.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步任务层**: 此层中的任务处理来自外部源的事件。这些任务不包含单独的控制线程。'
- en: We have discussed the Half-Sync and Half-Async design patterns of the concurrency
    pattern. Let's move to another concurrency pattern, that is, the leader/follower
    Pattern.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了并发模式的半同步和半异步设计模式。让我们转向另一种并发模式，即领导者/跟随者模式。
- en: Leader/follower pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领导者/跟随者模式
- en: 'Detection, demultiplexing, dispatching, and processing of service requests
    in the event sources is carried out in an efficient way in a concurrency model,
    in which many multiple threads process one by one to use the set on event sources.
    Another replacement for the Half-Sync/Half-Async is the leader/follower pattern.
    This pattern can be used instead of the Half-Sync/Half-Async and active object
    patterns for improvement in the performance. The condition of using this is that
    there must be neither ordering nor synchronization constraints while processing
    multiple threads of requests:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发模型中，对事件源中的服务请求的检测、解复用、调度和处理都是高效进行的，其中许多多个线程逐个处理以使用事件源上的集合。Half-Sync/Half-Async的另一种替代方案是领导者/跟随者模式。这种模式可以用作替代Half-Sync/Half-Async和主动对象模式以改进性能。使用此模式的条件是在处理多个线程的请求时，既没有排序也没有同步约束：
- en: '![](img/4a208fe3-b0fc-44b4-92f7-39a0d103bfd5.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a208fe3-b0fc-44b4-92f7-39a0d103bfd5.jpg)'
- en: The focused job of this pattern is to process multiple events concurrently or
    simultaneously. Due to concurrency-related overheads, it might not be possible
    to connect a separate thread with each single socket handle. The highlighted feature
    of this design is that by using this pattern, demultiplexing the associations
    between threads and event source becomes possible. When the events arrive on the
    event sources, this pattern builds up a pool of threads. This is done to share
    a set of event sources efficiently. These event sources demultiplex the arriving
    events turn by turn. Also, the events are synchronously dispatched to application
    services for processing. Out of the pool of threads structured by the leader/follower
    pattern, only a single thread waits for the occurrence of the event; other threads
    queue up waiting. A follower is promoted as the leader when a thread detects an
    event. It then processes the thread and dispatches the event to the application
    handler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的重点工作是并发或同时处理多个事件。由于与并发相关的开销，可能无法将每个单独的套接字句柄与单独的线程连接。此设计的高亮特点是，通过使用此模式，可以解复用线程和事件源之间的关联。当事件到达事件源时，此模式建立线程池。这是为了有效地共享一组事件源。这些事件源轮流解复用到达的事件。此外，事件被同步调度到应用程序服务进行处理。在由领导者/跟随者模式结构化的线程池中，只有一个线程等待事件的发生；其他线程排队等待。当一个线程检测到事件时，跟随者被提升为领导者。然后它处理该线程并将事件调度到应用程序处理器。
- en: In this type of pattern, processing threads can be run concurrently, but only
    one thread is allowed to wait for the upcoming new events.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，处理线程可以并发运行，但只允许一个线程等待即将发生的新事件。
- en: Let's see another concurrency-based design pattern in the upcoming section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中另一个基于并发的设计模式。
- en: Reactor pattern
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应器模式
- en: The reactor pattern is used to handle service requests that are received concurrently
    by a service handler from a single or multiple input sources. The received service
    requests are then demultiplexed by the service handler and dispatched to the associated
    request handlers. All the reactor systems are commonly found in single threads,
    but they are also said to exist in a multi-threaded environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器模式用于处理由单个或多个输入源并发接收到的服务请求。接收到的服务请求随后由服务处理器解复用，并调度到相关的请求处理器。所有反应器系统通常都发现于单线程中，但它们也被说存在于多线程环境中。
- en: The key benefit of using this pattern is that the application components can
    be divided into multiple parts such as modular or reusable. Furthermore, this
    allows simple coarse-grain concurrency without the additional complexity of multiple
    threads to the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式的关键好处是应用程序组件可以被划分为多个部分，例如模块化或可重用。此外，这允许系统在不增加多个线程的额外复杂性的情况下实现简单的粗粒度并发。
- en: 'Let''s see the following diagram about the reactor design pattern:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于反应器设计模式的图示：
- en: '![](img/134addef-7c54-433a-9106-abe5fd104dd4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/134addef-7c54-433a-9106-abe5fd104dd4.png)'
- en: 'As you can see in the preceding diagram, the dispatcher uses the demultiplexer
    to notify handler and the handler performs the actual work to be done with an
    I/O event. A reactor responds to I/O events by dispatching the appropriate handler.
    Handlers perform non-blocking actions. The preceding diagram has the following
    components of this design pattern:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，调度器使用解复用器来通知处理器，处理器通过I/O事件执行实际的工作。反应器通过调度适当的处理器来响应I/O事件。处理器执行非阻塞操作。前图展示了此设计模式的以下组件：
- en: '**Resources:** These are the resources through which input is provided or output
    is consumed.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：这些是通过它们提供输入或消耗输出的资源。'
- en: '**Synchronous event demultiplexer:** This blocks all resources via an event
    loop. When there is a possibility that a synchronous operation will start, the
    resource is sent to the dispatcher through the demultiplexer without blocking.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步事件解多路复用器**：通过事件循环阻塞所有资源。当有同步操作可能启动时，资源将通过解多路复用器发送到调度器，而不会阻塞。'
- en: '**Dispatcher:** The registering or unregistering of request handler is handled
    by this component. Resources are dispatched to the respective request handler
    through the dispatcher.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：此组件处理请求处理器的注册或注销。资源通过调度器分发到相应的请求处理器。'
- en: '**Request Handler:** This handles the request dispatched by the dispatcher.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求处理器**：此处理由调度器分发的请求。'
- en: Now, we are moving on to our next and the last concurrency pattern that is the
    thread-specific storage pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续到下一个也是最后一个并发模式，即线程特定存储模式。
- en: Thread-specific storage pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程特定存储模式
- en: A single logical global access point can be used to retrieve an object local
    to the thread. This concurrency design pattern allows multiple threads to carry
    this function out. This is done without incurring locking overhead on each access
    to the object. Sometimes, this particular pattern can be viewed as an antithesis
    among all the concurrency design patterns. This is due to the fact that several
    complexities are addressed by the thread-specific storage by prevention of sharing
    of the available resources among the threads.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单个逻辑全局访问点可以用来检索线程本地的对象。这种并发设计模式允许多个线程执行此功能。这样做无需在每个访问对象时产生锁定开销。有时，这种特定的模式可以被视为所有并发设计模式中的对立面。这是因为线程特定的存储通过防止线程间共享可用资源来解决了几个复杂性。
- en: The method appears to be invoked on an ordinary object by the application thread.
    Actually, it is invoked on a thread-specific object. A single thread-specific
    object proxy can be used by multiple application threads for accessing the unique
    thread-specific objects associated to each of them. The proxy to distinguish between
    the thread-specific object it encapsulates uses the application thread identifier.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法似乎由应用程序线程在普通对象上调用。实际上，它是在线程特定的对象上调用。多个应用程序线程可以使用单个线程特定的对象代理来访问与每个应用程序线程关联的唯一线程特定对象。代理使用应用程序线程标识符来区分它封装的线程特定对象。
- en: Best practices for concurrency module
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模块的最佳实践
- en: Here is a list of considerations that a programmer must look into when carrying
    out concurrency. Let's look at the following best practices to consider when you
    to get a chance to work with the concurrent application module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行并发时，程序员必须考虑以下列表中的考虑事项。让我们看看以下最佳实践，当有机会与并发应用程序模块一起工作时应该考虑。
- en: '**Obtaining an executor**: The Executor Framework for obtaining an executor
    supplies the executors utility class. Various types of executors offer specific
    thread executions policies. Here are three examples:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取执行器**：用于获取执行器的 Executor 框架提供了 executors 工具类。各种类型的执行器提供特定的线程执行策略。以下有三个示例：'
- en: '**ExecutorService newCachedThreadPool()**: This creates a thread pool using
    the previously constructed threads if available. The performance of the programs
    that make use of the short-lived asynchronous tasks is enhanced using this type
    of thread pool.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**newCachedThreadPool()**: 如果可用，此方法使用先前构建的线程创建一个线程池。通过使用此类线程池，增强了使用短暂异步任务的应用程序的性能。'
- en: '**ExecutorService newSingleThreadExecutor()**: A worker thread that is operating
    in an unbounded queue is used here to create an executor. In this type, the tasks
    are added to the queue that is then executed one by one. In case, this thread
    fails during the execution, a new thread will be created and replace the failed
    thread so that the tasks can be executed without interruption.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**newSingleThreadExecutor()**: 这里使用一个在无界队列中运行的工人线程来创建一个执行器。在这种类型中，任务被添加到队列中，然后依次执行。如果此线程在执行过程中失败，将创建一个新的线程来替换失败的线程，以便任务可以无中断地执行。'
- en: '**ExecutorService newFixedThreadPool(int nThreads)**: A fixed number of threads
    that are operating in a shared unbounded queue are reused in this case for the
    creation of a thread pool. At threads, the tasks are being actively processed.
    While all the threads in the pool are active and new tasks are submitted, the
    tasks will be added in the queue until a thread becomes available for the processing
    of the new task. If before the shutdown of the executor, the thread fails, a new
    thread will be created for carrying out the execution of the task. Note that these
    thread pools exist only when the executor is active or on.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExecutorService newFixedThreadPool(int nThreads)**：在这种情况下，固定数量的线程在共享的无界队列中操作，用于创建线程池。在线程中，任务正在被积极处理。当池中的所有线程都处于活动状态并且提交了新任务时，任务将添加到队列中，直到有线程可用于处理新任务。如果在执行器关闭之前线程失败，将创建一个新的线程来执行任务的执行。请注意，这些线程池仅在执行器处于活动状态或开启时存在。'
- en: '**Use of cooperative synchronized constructs**: It is recommended to use cooperative
    synchronized constructs when possible.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能使用协作同步构造**：建议尽可能使用协作同步构造。'
- en: '**No unnecessary lengthy tasks and oversubscription**: Lengthy tasks are known
    to cause deadlock, starvation, and even prevent other tasks from functioning properly.
    Larger tasks can be broken down into smaller tasks for proper performance. Oversubscription
    is also a way to avoid the deadlock, starvation, and so on. Using this, more threads
    than the available number of threads can be created. This is highly efficient
    when a lengthy task contains a lot of latency.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无必要冗长任务和过度订阅**：冗长任务众所周知会导致死锁、饥饿，甚至阻止其他任务正常工作。较大的任务可以被分解成较小的任务以实现良好的性能。过度订阅也是避免死锁和饥饿等方法之一。使用这种方法，可以创建比可用线程数更多的线程。当冗长任务包含大量延迟时，这非常高效。'
- en: '**Use of concurrent memory-management functions**: If in a situation, ensuing
    concurrent memory management functions can be used, it is highly recommended to
    use it. These can be used when objects with a short lifetime are used. The functions
    such as `Allot` and `Free` are used to free memory and allocate, without memory
    barriers or using locks.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并发内存管理函数**：如果在某种情况下，可以使用后续的并发内存管理函数，强烈建议使用它。这些可以在使用具有短生命周期的对象时使用。`Allot`和`Free`等函数用于释放内存和分配，无需内存屏障或使用锁。'
- en: '**Use of RAII to manage the lifetime of concurrency objects**: RAII is the
    abbreviation for **Resource Acquisition Is Initialization**. This is an efficient
    way to manage the lifetime of a concurrency object.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RAII管理并发对象的生命周期**：RAII是**资源获取即初始化**的缩写。这是管理并发对象生命周期的有效方法。'
- en: This was all about the concurrency and it's design patterns that can be used
    to handle and implement concurrency. These are the most common five design patterns
    for concurrency programs. Also, some of the best practices for carrying out concurrency
    modules were discussed. Hope this was an informative a piece and helped you understand
    how concurrency patterns work!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于并发及其设计模式的所有内容，这些设计模式可以用来处理和实现并发。这些是并发程序中最常见的五种设计模式。还讨论了一些执行并发模块的最佳实践。希望这能提供信息量，并帮助你理解并发模式是如何工作的！
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned several concurrency design patterns and also saw
    the use cases of these patterns. In this book, I have covered only the basic of
    the concurrency design patterns. We have included the active object, monitor object,
    Half-Sync/Half-Async, leader/followers, thread-specific storage, and reactor patterns.
    These all are the part of the concurrency design patterns in the multithreaded
    environment of the application. We also discussed some best practices consideration
    to use the concurrency design pattern in the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了几个并发设计模式，并看到了这些模式的使用案例。在这本书中，我只涵盖了并发设计模式的基础。我们包括了活动对象、监控对象、半同步/半异步、领导者/跟随者、线程特定存储和反应器模式。这些都是应用多线程环境中的并发设计模式的一部分。我们还讨论了一些在应用中使用并发设计模式时的最佳实践考虑。
