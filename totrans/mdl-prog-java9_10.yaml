- en: Preparing Your Code for Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we looked at several patterns and best practices to use
    when building Java 9 modular applications. They are an extremely handy set of
    rules to remember when building new applications. But it's not always that developers
    have the opportunity to work on greenfield projects where they have the freedom
    to think about and build application architecture from scratch. What if there's
    already a lot of code built using Java 8 or earlier? How do we migrate such code
    to Java 9?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Working on legacy code and getting it ready to be run in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling legacy code in Java 9 and executing pre-Java 9 compiled code in the
    Java 9 runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classpath behaviors in Java 9 and the unnamed module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors and non-standard API access and using the jdeps tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using override switches to work around tricky code and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning Java 9 migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably have some Java 8 (or earlier) code on your hands. And you are probably
    wondering what you'll need to do to get this to work with Java 9\. When the Java
    9 specification was going through the **Java Community Process** (**JCP**), there
    was some concerns in the developer community about just this. Will the legacy
    Java code work as-is in Java 9? If there are changes to be made, how much time
    and effort would they consume? Fortunately, Java has a great track record of maintaining
    backward compatibility, and that continues even with such major changes that have
    been brought into the language with the new modularity features. However, since
    Java 9 is one of the biggest overhauls to the Java internals, there might be some
    work that needs to be done. The amount of work depends primarily on two factors--the
    nature of migration you are trying to perform and the way the code itself is written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what do I mean by *nature of migration*? When tackling Java 9 migration,
    it''s useful to think about the effort in stages. At a high level, you could move
    your existing pre-Java 9 code through the following two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting your code to compile and execute in Java 9 as-is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactoring the structure of your code to use the modularity features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 1** involves using the `javac` and the `java` commands on your existing
    code base just like you have done all along, but with the new Java 9 version of
    the compiler and runtime. In this phase you''d like to make as little changes
    to the code as possible! **Step 2** involves refactoring or rewriting your code
    to use modularity features, including the things we''ve learned so far in this
    book--breaking down the code base into modular units, creating `module-info.java`
    for each of those modules and then establishing relationships between the modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Are both these steps necessary for migrating to Java 9? Well, **Step 1** is.
    For any application that you plan to run and use in the foreseeable future, it's
    worth getting it to at least work with the new Java 9 runtime. That way, you are
    ready for whenever Java 8 becomes *end-of-lifed* in the future. This type of migration
    should be relatively easy, except for a few things to look out for that we'll
    cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After you've done that, and your applications now work with Java 9 compiler
    and runtime, you do have an option of refactoring your code to use all the cool
    new modular features you've learned. But that may not always be valuable. If you
    have code that you don't plan to modify or enhance over time, and you just need
    to *maintain* it to run the business, you aren't going to get a lot of value by
    refactoring it to use Java 9 modules.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you anticipate making changes and actively working on the code base,
    there is benefit to refactoring the code to use modules. The next chapter deals
    with migrating code that involves using the rich JPMS features we now get with
    Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be covering **Step 1** in this chapter. **Step 2** is covered in [Chapter
    11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb), *Migrating Your Code
    to Java 9*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the sample Java 8 application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using a sample Java 8 code base to try migrating to Java 9\. It's
    a command-line `shopping bag` utility. When you run the application, it prompts
    you to add items to your shopping bag. Once you've added all the items and you
    are done, you type `end`. The application then displays a consolidated shopping
    list of items that you've added. The application is intentionally simple, but
    it gives us a good starting point to work through the migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the application in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application consists of three classes in three different packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShoppingBag` class: It contains a method to add items to a shopping bag,
    and one to pretty print the contents of the bag. The class uses the `Bag` data
    structure from the Apache Commons Collections library. Think of this data structure
    as something similar to a `Set`, but with duplicates allowed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserInputUtil` class: It contains a method to prompt the user for an input.
    It also contains a public `close` method to close the input stream when done:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` class: Putting it all together. This class has the `main` method.
    It uses the `UserInputUtil` to prompt the user to enter items into the shopping
    bag. It adds each item to a `ShoppingBag` instance, and it then prints the bag
    when done:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the application code, there's a `lib` folder with the Apache
    Commons Collection library JAR file--`commons-collections4-4.1.jar`. The code
    depends on this library JAR file. We'll need to add this JAR file to the classpath
    when compiling and running the code.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend looking at the included source code at the location -`10-migrating-application/01-legacy-app`and
    getting familiar with it. We'll be using this application as we work through the
    migration process.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Java 9 compiler and runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with the first step--compiling and running an old code base
    using the Java 9 compiler and runtime. It'll be great if things work as-is. If
    changes are required, we'd like to make as few of them as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you are using Java 9 using the following command. If you have
    a different version, you''ll need to switch, as covered in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the project folder, create a new out directory for our compiled classes
    and run the following Java compiler command to compile all the `.java` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `javac` command, we are adding the commons collections JAR
    file to the classpath using the `-cp` option, specifying the output directory
    for the compiled classes using the `-d` option and then specifying all the `.java`
    files in the following directories recursively using `$(find . -name '*.java')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compilation step should go through fine without any errors. Great! Let''s
    try to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `java` command, we are specifying two paths in the classpath
    `-cp` option--the `out` directory that contains the compiled classes and the common
    collections JAR file. Following that is the fully qualified class name of the
    class with the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are still using classpath and not the concept of module path.
    Java 9 still works with classpath, and with the same `-cp` option as did the previous
    Java versions. More on that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the command should result in success, with the prompt being displayed
    as expected. And there you have it! A Java 8 application has compiled and executed
    using Java 9, and not a single line of code needed to be changed! As much as I''d
    love to tell you that all legacy code will work just as easily as this, it is
    unfortunately not true. There are some cases that need more effort. However, the
    good thing is that in the majority of the cases, this process *should* be this
    effortless. We''ll look at some of the cases where you might run into problems,
    and how to address them in the next section. But first, knowing what we now know
    about Java 9, isn''t it surprising that everything worked well? If you think about
    it, both the compilation and execution should have failed! Why? Here are a couple
    of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned that Java 9 is moving to a module system and that *everything*, be
    it the application code or the platform, should be in a module! Our Java 8 code
    is obviously not in a predefined module. That's fine in Java 8, but shouldn't
    that have caused an error in Java 9?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that `App.java` is using the Java logging API. We've learned in [Chapter
    4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing the Modular
    JDK* that the logging APIs have been bundled into a separate platform module called
    `java.logging` . And all code that accesses any module that's not `java.base` should require it
    explicitly. That's clearly not happening in the code here, because this is Java
    8 code, and there's no `module-info.java` module definition to begin with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This begs the question--how did compiling and executing this code in Java 9
    still work? It all works thanks to some special features introduced in the language
    to support this very process--executing legacy code in Java 9\. The specific feature
    that's working for us here is called the **unnamed module**.
  prefs: []
  type: TYPE_NORMAL
- en: The unnamed module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we weren't wrong. All code in Java 9 *needs* to be in modules. And all
    modules need to have the right readability and accessibility relationships for
    applications to work. But that might be problematic! Because, as with every new
    Java release, there are thousands of developers trying to run their legacy Java
    code bases using the new Java version. If we were to expect each legacy Java code
    base to be wrapped into modules before it can even run in Java 9, which would
    introduce a significant cost of effort in the developer community. Thankfully,
    there's a way out. When you are using Java 9 to compile or run legacy module-less
    Java code in the classpath, you *don't* have to manually create module wrappers
    yourself. The platform automatically creates a single module that comprises of
    everything you have in your classpath. This module doesn't have a name and so,
    is referred to as the *unnamed module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the Java 9 code we''ve compiled and executed so far, we''ve not been
    using the classpath at all. Here''s a schematic of the modules in our Java 9 application
    as we''ve been running it so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve so far had the whole runtime work with built-in platform modules in
    the JRE along with your application modules from the module path. These together
    form the complete set of observable modules. Now what happens if you throw in
    the classpath in there? When running with the classpath option, here''s how the
    picture looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s where we would have violated the *all-code-needs-to-be-in-modules*
    rule. Thanks to the automatic module feature, we haven''t. The Java 9 platform
    automatically wraps all the classes and JARs in the classpath into one unnamed
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what''s happening to the shopping bag application. All the
    application code, including the common collections jar is a part of the single
    unnamed module. OK, that addresses one of the concerns. How about the second one?
    How did the code get access to the Java logging API? Shouldn''t the unnamed module
    declare requires `java.logging`? But how could it? The unnamed module doesn''t
    have a `module-info.java` file anyway! Because the platform cannot really tell
    for sure what the classpath code needs, the unnamed module is automatically given
    readability access to *all* observable modules. In other words, it mimics the
    *free-for-all* behavior of code in the classpath pre-Java 9--it `requires` everything,
    because that''s the only way the platform can maximize the chances of any legacy
    code working as-is in Java 9\. If you were to draw a module graph, it would look
    like the unnamed module has readability relationship to every module in the set
    of observable modules, as represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram is very messy, so we'll not draw this again. From now on, we'll
    just simplify all the readability edges coming out of the automatic module into
    a single arrow to keep things legible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automatic module feature was built into the platform specifically for migration
    purposes, and as you can see, it''s the reason why our Java 8 code was able to
    compile and run in Java 9 without any errors. To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you supply the `-classpath` option to compile or execute code in
    Java 9, the platform creates an unnamed module. All classes and jars in the supplied
    classpath are bundled into this unnamed module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unnamed module automatically *reads* every observable module. Thus, not
    only does it read all the Java 9 platform modules, it also reads all your application
    and library modules in the module path (if you've supplied the module path argument
    to the command, in addition to the classpath.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time you use the Java compiler without any module path options, you runs
    the compiler in what's referred to as a *single module mode*. In this mode, like
    we've seen, we are dealing with the single unnamed module. The code is expected
    to be organized into the traditional package-based directory structure, and there
    are no module folders.
  prefs: []
  type: TYPE_NORMAL
- en: Handling non-standard access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wait! There's a catch! The unnamed module reads all Java platform modules and
    because of that, I mentioned it mimics the *free-for-all* behavior of the pre-Java
    9 platform. But that's not exactly true. Pre-Java 9, the entire platform, and
    all the classes in it were accessible to your application code. With Java 9 platform
    modularization, there are several internal types in platform modules that are
    not exported, thus making them encapsulated. It's a good thing that the unnamed
    module automatically reads all platform modules by default, but is that enough?
    Not really, because it just enables the code in the classpath to access only the
    types *exported* from the modules. But what if your legacy code uses a type that
    is now encapsulated in a platform module in Java 9? Just having the unnamed module
    read all the platform modules is not enough, because the encapsulated types would
    still not be available. The same problem exists for code that accesses types that
    are removed. Yes, there are certain types in JDK 8 and earlier that are no longer
    available in Java 9\. And any legacy code that uses such types will fail to compile
    and run in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code at `10-migrating-application/02-non-standard-api` is an example of
    a code with such access of internal types. The class `App.java` uses two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Base64Encoder` that was available in previous versions of Java, but now with
    Java 9, has been completely removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalendarUtils`, which is encapsulated as an internal type in the`java.base` module
    in Java 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you were creating a new Java 9 module, there's no platform module that
    your code can require to access it. The type is not exported from the module and
    so is effectively sealed. Thus, even the unnamed module would not be able to access
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sample code. The code itself is completely non-functional as it
    is just an attempt to try using these two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to Java 8 compiler and compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that while the compilation goes through, you do see warnings!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For quite a while now, developers have been warned about such usages of internal
    types! For someone working on such code, it should not come as a surprise that
    these APIs don't work in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to Java 9 and compile this code. Use the following command on
    macOS or Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, follow the steps outlined in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After switching the Java version to 9, run the compile command on this code.
    This time, you don''t get warnings. You get errors and the code doesn''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that there are two different errors, one for each type:'
  prefs: []
  type: TYPE_NORMAL
- en: The error for `CalendarUtils` indicates that the type is now encapsulated (that
    is, not exported) from `java.base`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error for `BASE64Encoder` mentions that the compiler just doesn't find it.
    The type has been removed from Java 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When compiling and running legacy code in Java 9, these are two of the most
    likely errors you could get because of the modularity changes. Fixing either of
    these errors requires changing your code. You'll have to either find an equivalent
    class or API in the new platform that does what you need. Or find an external
    library that has the APIs you need. What's tricky is that the problematic code
    may not necessarily be in your application code. It could be in a library or a
    framework that you use. Even in that case, your application won't compile or run
    in Java 9, until you remove the dependency or the library is updated.
  prefs: []
  type: TYPE_NORMAL
- en: There is some help that the platform provides to help you identify such problems
    with your application and its dependencies. It's a tool called `jdeps`.
  prefs: []
  type: TYPE_NORMAL
- en: '`jdeps` was first shipped with Java 8 to help developers identify and fix internal
    API access. With Java 9, it''s much more helpful and detailed.'
  prefs: []
  type: TYPE_NORMAL
- en: The jdeps tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Dependency Analysis Tool** (**jdeps**) is a utility that can statically
    examine your application and library classes to identify if there are any uses
    of the JDK internal APIs that no longer work with Java 9\. You can run `jdeps`
    on your compiled class files or JARs, and have it list out all such references.
    For each reference, `jdeps` will highlight usages of internal types that are no
    longer available for your code to use. It even suggests replacement APIs if they
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a bunch of classes compiled and you want to run `jdeps` on them,
    you can even provide a classpath parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this with the `02-non-standard-api` project. We''ve already compiled
    the project (albeit with warnings) with the Java 8 compiler, and the classes now
    exist in the out directory. Running `jdeps` on them yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`sun.misc.BASE64Encoder` is indicated as a *JDK removed internal API* while
    `sun.util.calendar.CalendarUtils` is indicated as a JDK internal API from `java.base`.
    In the case of `BASE64Encoder`, the tool provides a helpful suggestion to use
    an alternative API (`java.util.Base64`) that has been available in Java since
    version 1.8.'
  prefs: []
  type: TYPE_NORMAL
- en: '`jdeps` can also be run on JARs as previously mentioned. If we were to run
    the tool on the included `01-app-migration` project for example, we''ll get no
    output. Which is a good thing because that means there are no JDK internals being
    used, and the JAR is good to use for Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`jdeps` is a *static* code analysis tool, with emphasis on the word *static*.
    It looks at the code to identify illegal API use. It cannot identify dynamic runtime
    use through reflection, for example. Thus, there is a chance that `jdeps` gives
    you the all-clear for a code base, but when you run it, you might still end up
    with an `IllegalAccessException` because the code uses reflection to access an
    internal type that''s no longer available.'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, `jdeps -jdkinternals` is a great tool to use to check your pre-compiled
    application and library classes and verify any incompatibilities with Java 9\.
    It is especially helpful that the tool recommends alternative options to use when
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding module behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jdeps` is great at identifying internal API access and suggesting fixes. They
    come in handy when fixing your own application code that contains such problems.
    But what if `jdeps` reports problems with some code in a library or a framework
    you are using? In such cases, you have lesser control over the code. Even if the
    framework itself is open source, the scale and complexity of the library may not
    make it feasible for you to implement the fix yourself. This does present a very
    clear risk for applications moving to Java 9--your app won''t run in Java 9 until
    all your libraries are updated to work in Java 9\. It''s very likely that most
    library developers have either already heeded to the scores of warnings in Java
    8 and fixed their code, or they will soon, because of their code breaking in Java
    9\. But if they don''t, this could mean that your migration plans are at the mercy
    of the library authors.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the platform comes with some override features to get around this
    problem. The override features we'll look at here apply not just to legacy Java
    code being compiled in Java 9, they also work on Java 9 modules. But since they
    are primarily designed to assist migration, they should be used in the context
    of migration only, and other uses should ideally be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: What are these override features? Remember that a Java 9 module has a *module
    definition* that specifies what it `requires` and what it `exports`. These individual
    module definitions that are specified in the `module-info.java` file at development
    time essentially control the accessibility relationship between modules during
    compilation and runtime. However, it turns out, both the compiler and runtime
    has override options for these module relationships that allow you to change what
    any given module `requires` or `exports` by specifying command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three command line flags to `javac` and `java` to override specific
    module configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add-reads`: The `--add-reads` option allows you to specify additional readability
    relationships that may not already be available for a module as per the module
    configuration. The syntax is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this option to the `javac` and `java` command line creates a new readability
    relationship only for that command execution you use the argument for. For example,
    let''s say you have modules `moduleA` and `moduleB`, and you want to have `moduleA`
    read `moduleB`. You can either edit the `module-info.java` file in `moduleA` and
    add the line requires `moduleB;`, or add the following argument to the compiler
    and runtime, as shown in this following truncated command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`add-exports`: The `--add-exports` option allows you to add additional exported
    packages from a module, thereby breaking or overriding encapsulation. The syntax
    is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if `moduleA` needs package `pack.internal` from `moduleB`, but
    `moduleB` does not export the package, you can add the following override to have
    `moduleB` export the required package for `moduleA`, as shown in this truncated
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`add-opens`: The `--add-opens` option lets you override the `opens` relationship
    between modules to allow reflective access. This is an override that simulates
    the `opens` keyword configuration in the module definition. The syntax is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same example, if `moduleA` needs runtime-only reflective access
    to the package `pack.internal` in `moduleB`, you would run the `javac` or `java`
    command with the following option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the overrides are always *qualified*, that is, you specify them for
    a specific target module. For example, you don't use the `--add-exports` flag
    to export a package to every other module. You explicitly specify one or more
    target modules that the override applies to from the source module. That's a good
    thing because every override is made consciously and it's easy to track what is
    needed to get the application to work.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to provide these overrides in addition to command line
    arguments. You can specify them inside JAR file manifests. Let's say you have
    an executable JAR file that needs some overrides to work with platform modules
    in Java 9\. To avoid having to specify these overrides everytime as command line
    arguments, you could just specify these as manifest attributes in the `MANIFEST.MF`
    file in your JAR file. As with all manifest attributes, the value should be specified
    following a space after the attribute name in the `MANIFEST.MF` file. The manifest
    attribute `Add-Exports` corresponds to the  `--add-exports` argument. The attribute  `Add-Opens`
    corresponds to `--add-opens`. There's no manifest attribute equivalent for `--add-reads`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these overrides, there's a master *kill switch* for any modularity
    related encapsulation for classes in the classpath--the `--permit-illegal-access`
    flag. Unlike the previous three options, this option works only on code in the
    classpath. This flag, when passed to `javac` or `java` effectively disables *all*
    readability and accessibility restrictions, thus making any type accessible to
    any other type in the classpath. It's almost as if there are no Java modularity
    features, and everything in the classpath works as if you are running in Java
    8 or earlier. As you'd expect, it's not a good idea to use this flag, especially
    if you are running code in production. This is provided to help developers migrate
    their classpath applications, and could very well be removed in the future. Think
    of this as a *last resort* option to get things to work as you work on migration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned these override options, how can you apply them to solve
    the problem we started discussing this section with libraries or classes in your
    Java 8 code that use encapsulated APIs, and thus no longer work in Java 9? If
    the code is not in your control and you cannot fix it to *avoid* using the encapsulated
    types, you could use the override switch to manually add the required `exports`!
    For example, our code in the `02-non-standard-api` used an internal non-exported
    type `CalendarUtils` from `java.base`. Since we obviously cannot change the module
    descriptor for the  `java.base` module, what we could instead do is pass the `--add-exports`
    option to the module and have it export the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'But here''s a problem. Note that the syntax needs the source and target module
    names. The source module name is `java.base` of course. What is the target module?
    It''s the unnamed module, because it''s the classes in the classpath that needs
    this package. This brings up an interesting question--what is the name of the
    unnamed module? The unnamed module doesn''t have a name (or indeed it wouldn''t
    be called that!), but there''s a special token called `ALL-UNNAMED` that you can
    pass to the override arguments that let the platform know that you are referring
    to the unnamed module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This command should solve the problem of the `CalendarUtils` access in our
    code. There''s still the missing `BASE64Encoder` type. There''s no command-line
    argument to fix that one. Like we''ve seen, the type simply doesn''t exist in
    Java 9\. We''ll have to replace it with something that does. Taking the suggestion
    provided by `jdeps`, the class `AppFixed.java` has the updated code that uses
    the `Base64class` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This time, you don't get errors and the compilation goes through. You still
    see the warning about using an internal type. The compiler still reminds you that
    it's not an ideal situation, but since you've added the override, it trusts that
    you know what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: If the code was complied in a previous version of Java and you were running
    it in Java 9 *and* the problem was only with accessing encapsulated types, you
    can add the same override arguments to the `java` command and have it run. However,
    if the compiled classes are referring to unavailable types, like the `BASE64Encoder`
    type we just looked at, you have no choice but to edit the code and recompile
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the impact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know what are the possible problems you could face when compiling
    or running legacy code in Java 9, as well as how to solve those problems when
    they occur, let's spend some time understanding the scope of these problems. How
    worried should you be about having to encounter and fix these issues in your legacy
    Java code?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can classify backward-incompatible APIs into the following broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**APIs with replacements**: This link (also the link provided in the output
    of `jdeps --jdk-internals`) provides a complete list of APIs that need replacements
    in Java 9: [https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool](https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulated APIs**: When you run `jdeps`, you might see errors about usage
    of internal JDK types that do not have replacement suggestions. They could just
    be types that were formerly available pre-Java 9 but are now encapsulated in a
    platform module. These are fixable by using the right command line overrides to
    the `javac` and `java` invocations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, there are certain APIs that were originally meant for removal,
    but they still happen to be available. While the intent has been to encapsulate
    all the internal JDK APIs, there have been a few APIs that have been so widely
    used in the Java developer community and for which there are no suitable replacements
    that encapsulating them would add so much more difficulty to the migration process.
    Remember the widely used `sun.misc.Unsafe` API we discussed in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*? Such APIs continue to be accessible in Java 9\.
    But in order to make these APIs easier to deprecate later, they have been moved
    into a separate module called `jdk.unsupported`, from which these types can be
    accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `java -d` on the `jdk.unsupported` module shows us the *unsupported*
    APIs that are still accessible for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A word of caution. The `jdk.unsupported` module and the APIs are very likely
    to be removed from the next versions of Java, so don't plan on relying on this
    module for too long.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s wrap up by outlining the recommended strategy for compiling and running
    your legacy code in Java 9\. Here are the steps you''d ideally follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `jdeps --jdk-internals` to verify if your code has any internal API access.
    If there are no errors, just try compiling and running your code in Java 9\. For
    the vast majority of cases, where there are no accesses to internal JDK APIs,
    the code should simply just work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are errors and they are caused by your application code that you can
    change, follow the `jdeps` recommendation and fix those errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the errors are caused by libraries that are not in your control, check if
    there are updates published by the library authors and get the latest versions.
    Many libraries that use internal APIs are being updated to work with Java 9, and
    the fix for your libraries might have already been done and published.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If none of the previous steps work, consider using the override options  `--add-exports`
    or  `--add-opens` to the platform APIs that you need internal access to. This
    is a short-term stop-gap arrangement until the offending code or library is fixed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If none of these work, as a last resort, turn off all modularity features with
    the `--permit-illegal-access` kill switch. While it is not recommended (and you
    certainly don't want to deploy an app with this switch in production), it's a
    handy way to get started if you are being overwhelmed with compatibility issues.
    A cool feature of this switch is that when you run your code that makes any *illegal
    access*, it prints out a warning message. It can be very helpful to consolidate
    this information and plan to fix them later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the first of the two phases of code migration to Java 9--
    the process of compiling or running your pre-Java 9 code in Java 9\. We used a
    sample Java 8 project (without any internal API access) in order to compile and
    execute it in Java 9\. We then looked at a class with a couple of deliberate internal
    API access instances and saw what the error we'll encounter looks like. We learned
    about the `jdeps` tool and how to use it to statically scan your code base and
    identify such instances.
  prefs: []
  type: TYPE_NORMAL
- en: Once the instances have been identified, we covered a couple of ways to solve
    the problem--using the suggested replacement APIs or using command-line flags
    to temporarily overcome the problem. We used both these options to get the previously
    failing code to compile and execute fine in Java 9\. We then looked at a high
    level strategy to follow in order to complete the process of getting your legacy
    code to run in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on code that you just need to maintain and are not likely
    to build on, this is where you could stop your migration journey. But, if you
    need to actively evolve the code, it's a good idea to go further than that. In
    the next chapter, we'll learn how to get it through the second phase of the Java
    9 migration--to refactor it to use the Java 9 modularity features.
  prefs: []
  type: TYPE_NORMAL
