- en: Getting Started with Spring Framework 5.0 and Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Spring Framework 5.0 和设计模式
- en: This chapter will help you gain a better understanding of the Spring Framework
    with modules, and use the design patterns that are responsible for the success
    of Spring. This chapter will cover every major module of the Spring Framework.
    We begin with an introduction to the Spring Framework. We will have a look at
    the new features and enhancement introduced in Spring 5\. We will also understand
    the design patterns used in the major modules of the Spring Framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你通过模块更好地理解 Spring Framework，并使用负责 Spring 成功的设计模式。本章将涵盖 Spring Framework
    的每一个主要模块。我们将从 Spring Framework 的介绍开始。我们将查看 Spring 5 中引入的新特性和增强功能。我们还将了解 Spring
    Framework 主要模块中使用的设计模式。
- en: At the end of this chapter, you will understand how Spring works, and how Spring
    solves the common problems of the design level of the enterprise application by
    using design patterns. You will know how to improve loose coupling between the
    components of applications and how to simplify application development by using
    Spring with design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解 Spring 的工作原理，以及 Spring 如何通过使用设计模式解决企业应用设计层面的常见问题。你将知道如何通过使用 Spring
    和设计模式来提高应用程序组件之间的松散耦合，以及如何通过使用 Spring 和其模式简化应用程序开发。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction of the Spring Framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Framework 简介
- en: Simplifying application development using Spring and its pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring 和其模式简化应用程序开发
- en: Using the power of the POJO pattern
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 POJO 模式的力量
- en: Injecting dependencies
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入依赖
- en: Applying aspects to address cross-cutting concerns
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方面应用于解决横切关注点
- en: Applying a template pattern to eliminate boilerplate code
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板模式消除样板代码
- en: Creating a Spring container for containing beans using the Factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂模式创建用于包含 bean 的 Spring 容器
- en: Creating a container with an application context
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序上下文创建容器
- en: The life of a bean in the container
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中 bean 的生命周期
- en: Spring modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 模块
- en: New features in Spring Framework 5.0
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Framework 5.0 中的新特性
- en: Introducing Spring Framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Spring Framework
- en: In the early days of Java, there were lots of heavier enterprise Java technologies
    for enterprise applications that provided enterprise solutions to programmers.
    However, it was not easy to maintain the applications because it was tightly coupled
    with the framework. A couple of years ago, apart from Spring, all Java technologies
    were heavier, like EJB. At the time, Spring was introduced as an alternative technology
    especially made for EJB because Spring provided a very simple, leaner, and lighter
    programming model compared with other existing Java technologies. Spring makes
    this possible by using many available design patterns, but it focused on the **Plain
    Old Java Object** (**POJO**) programming model. This model provided the simplicity
    to the Spring Framework. It also empowered ideas such as the **dependency injection**
    (**DI**) pattern and **Aspect-Oriented Programming** (**AOP**) by using the Proxy
    pattern and Decorator pattern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 的早期阶段，有许多为大型企业应用提供企业解决方案的重型企业 Java 技术。然而，由于与框架紧密耦合，维护这些应用并不容易。几年前，除了
    Spring 之外，所有 Java 技术都很重，就像 EJB 一样。当时，Spring 被引入作为一种替代技术，特别是为 EJB 设计的，因为与现有的其他
    Java 技术相比，Spring 提供了一个非常简单、更精简、更轻量级的编程模型。Spring 通过使用许多可用的设计模式来实现这一点，但它专注于**普通旧
    Java 对象**（**POJO**）编程模型。这种模型为 Spring Framework 提供了简单性。它还通过使用代理模式和装饰者模式，通过**依赖注入**（**DI**）模式和**面向切面编程**（**AOP**）模式赋予了这些想法力量。
- en: The Spring Framework is an open source application framework and a Java-based
    platform that provides comprehensive infrastructure support for developing enterprise
    Java applications. So developers don't need to care about the infrastructure of
    the application; they should be focused on the business logic of the application
    rather than handling the configuration of the application. All infrastructure,
    configuration, and meta-configuration files, either Java-based configuration or
    XML-based configuration, both are handled by the Spring Framework. So this framework
    makes you more flexible in building an application with a POJOs programming model
    rather than a non-invasive programming model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架是一个开源的应用程序框架，也是一个基于Java的平台，它为开发企业级Java应用程序提供了全面的基础设施支持。因此，开发者不需要关心应用程序的基础设施；他们应该专注于应用程序的业务逻辑，而不是处理应用程序的配置。所有基础设施、配置和元配置文件，无论是基于Java的配置还是基于XML的配置，都由Spring框架处理。因此，这个框架使你在使用POJOs编程模型而不是非侵入式编程模型构建应用程序时更加灵活。
- en: The Spring **Inversion of Control** (**IoC**) container is the heart of the
    entire framework. It helps glue together the different parts of the application,
    thus forming a coherent architecture. Spring MVC components can be used to build
    a very flexible web tier. The IOC container simplifies the development of the
    business layer with POJOs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的**控制反转**（**IoC**）容器是整个框架的核心。它有助于将应用程序的不同部分粘合在一起，从而形成一个连贯的架构。Spring MVC组件可以用来构建一个非常灵活的Web层。IoC容器简化了使用POJOs的业务层开发。
- en: 'Spring simplifies the application development and removes a lot of the dependency
    on the other APIs. Let''s see some examples of how you, as an application developer,
    can benefit from the Spring platform:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring简化了应用程序开发，减少了对外部API的依赖。让我们看看作为应用程序开发者，你如何从Spring平台中受益的一些例子：
- en: All application classes are simple POJO classes--Spring is not invasive. It
    does not require you to extend framework classes or implement framework interfaces
    for most use cases.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用程序类都是简单的POJO类--Spring不是侵入式的。它不需要你在大多数用例中扩展框架类或实现框架接口。
- en: Spring applications do not require a Java EE application server, but they can
    be deployed on one.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring应用程序不需要Java EE应用服务器，但它们可以部署在服务器上。
- en: You can execute a method in a database transaction by using transaction management
    in Spring Framework without having any third-party transactional API.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Spring框架中的事务管理来执行数据库中的方法，而不需要任何第三方事务API。
- en: Using Spring, you can use a Java method as a request handler method or remote
    method, like a `service()` method of a servlet API, but without dealing with the
    servlet API of the servlet container.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring，你可以将Java方法用作请求处理器方法或远程方法，就像servlet API中的`service()`方法一样，但无需处理servlet容器的servlet
    API。
- en: Spring enables you to use a local `java` method as a message handler method
    without using a **Java Message Service** (**JMS**) API in the application.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring允许你在应用程序中不使用**Java消息服务**（**JMS**）API的情况下，将本地`java`方法用作消息处理器方法。
- en: Spring also enables you to use the local `java` method as a management operation
    without using a **Java Management Extensions** (**JMX**) API in the application.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring还允许你在应用程序中不使用**Java管理扩展**（**JMX**）API的情况下，将本地`java`方法用作管理操作。
- en: Spring serves as a container for your application objects. Your objects do not
    have to worry about finding and *establishing* connections with each other.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring作为你的应用程序对象的容器。你的对象不必担心找到和*建立*彼此之间的连接。
- en: Spring instantiates the beans and injects the dependencies of your objects into
    the application--it serves as a life cycle manager of the beans.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring实例化bean并将你的对象的依赖注入到应用程序中--它作为bean的生命周期管理器。
- en: Simplifying application development using Spring and its pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring及其模式简化应用程序开发
- en: Developing an enterprise application using the traditional Java platform has
    a lot of limitations when it comes to organizing the basic building blocks as
    individual components for reusability in your application. Creating reusable components
    for basic and common functionality is best design practice, so you cannot ignore
    it. To address the reusability problem in your application, you can use various
    design patterns, such as the Factory pattern, Abstract Factory pattern, Builder
    pattern, Decorator pattern, and Service Locator pattern, to compose the basic
    building blocks into a coherent whole, such as class and object instances, to
    promote the reusability of components. These patterns address the common and recursive
    application problems. Spring Framework simply implements these patterns internally,
    providing you with an infrastructure to use in a formalized way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的Java平台开发企业应用程序时，在组织基本构建块作为独立组件以供应用程序重用时存在许多限制。为基本和通用功能创建可重用组件是最佳设计实践，因此你不能忽视它。为了解决应用程序中的可重用性问题，你可以使用各种设计模式，例如工厂模式、抽象工厂模式、建造者模式、装饰者模式和服务定位器模式，将这些基本构建块组合成一个连贯的整体，例如类和对象实例，以促进组件的可重用性。这些模式解决了常见的递归应用问题。Spring框架简单地内部实现这些模式，为你提供了一个以正式化方式使用的框架。
- en: There are lots of complexities in enterprise application development, but Spring
    was created to address these, and makes it possible to simplify the process for
    developers. Spring isn't only limited to server-side development--it also helps
    simplifies things regarding building projects, testability, and loose coupling.
    Spring follows the POJO pattern, that is, a Spring component can be any type of
    POJO. A component is a self-contained piece of code that ideally could be reused
    in multiple applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序开发中存在许多复杂性，但Spring的创建是为了解决这些问题，并使开发人员能够简化开发过程。Spring不仅限于服务器端开发，它还帮助简化了项目构建、可测试性和松耦合等方面。Spring遵循POJO模式，即Spring组件可以是任何类型的POJO。组件是一段自包含的代码，理想情况下可以在多个应用程序中重用。
- en: 'Since this book is focused on all **design patterns** that are adopted by the
    Spring Framework to simplify Java development, we need to discuss or at least
    provide some basic implementation and consideration of design patterns and the
    best practices to design the infrastructure for enterprise application development.
    Spring uses the following strategies to make java development easy and testable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书专注于Spring框架采用的简化Java开发的全部**设计模式**，我们需要讨论或至少提供一些基本的设计模式和最佳实践，以设计企业应用程序开发的基础设施。Spring使用以下策略使Java开发变得简单且可测试：
- en: Spring uses the power of the *POJO pattern* for lightweight and minimally invasive
    development of enterprise applications
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring利用*POJO模式*的力量，以轻量级和最小侵入式开发企业应用程序
- en: It uses the power of the **dependency injection pattern** (**DI pattern**) for
    loose coupling and makes a system interface oriented
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用**依赖注入模式（DI模式**）的力量，以松耦合的方式使系统接口面向对象
- en: It uses the power of the *Decorator and Proxy design pattern* for declarative
    programming through aspects and common conventions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用*装饰者和代理设计模式*的力量，通过方面和常见约定进行声明式编程
- en: It uses the power of the *Template Design pattern* for eliminating boilerplate
    code with aspects and templates
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它利用*模板设计模式*的力量，通过方面和模板消除样板代码
- en: In this chapter, I'll explain each of these ideas, and also show concrete examples
    of how Spring simplifies Java development. Let's start with exploring how Spring
    remains minimally invasive by encouraging POJO-oriented development by using the
    POJO pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释这些想法中的每一个，并展示Spring如何简化Java开发的具体示例。让我们从探索Spring如何通过使用POJO模式鼓励面向POJO的开发来保持最小侵入性开始。
- en: Using the power of the POJO pattern
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用POJO模式的力量
- en: There are many other frameworks for Java development that lock you in by forcing
    you to extend or implement one of their existing classes or interfaces; Struts,
    Tapestry, and earlier versions of EJB had this approach. The programming model
    of these frameworks is based on the invasive model. This makes it harder for your
    code to find bugs in the system, and sometimes it will render your code unintelligible.
    However, if you are working with Spring Framework, you don't need to implement
    or extend its existing classes and interfaces, so this is simply POJO-based implementation,
    following a non-invasive programming model. It makes it easier for your code to
    find bugs in the system, and keeps the code understandable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 开发，有许多其他框架通过强制你扩展或实现它们现有的类或接口来锁定你；Struts、Tapestry 和 EJB 的早期版本都采用了这种方法。这些框架的编程模型基于侵入式模型。这使得你的代码在系统中查找错误变得更加困难，有时甚至会使你的代码变得难以理解。然而，如果你正在使用
    Spring 框架，你不需要实现或扩展其现有的类和接口，因此这只是一个基于 POJO 的实现，遵循非侵入式编程模型。这使得你的代码更容易在系统中查找错误，并保持代码的可理解性。
- en: Spring allows you to do programming with very simple non Spring classes, which
    means there is no need to implement Spring-specific classes or interfaces, so
    all classes in the Spring-based application are simply POJOs. That means you can
    compile and run these files without dependency on Spring libraries; you cannot
    even recognize that these classes are being used by the Spring Framework. In Java-based
    configuration, you will use Spring annotations, which is the worst case of the
    Spring-based application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 允许你使用非常简单的非 Spring 类进行编程，这意味着不需要实现特定的 Spring 类或接口，所以基于 Spring 的应用程序中的所有类都是简单的
    POJO（Plain Old Java Objects）。这意味着你可以编译并运行这些文件，而无需依赖 Spring 库；甚至无法识别这些类正在被 Spring
    框架使用。在基于 Java 的配置中，你会使用 Spring 注解，这是基于 Spring 的应用程序的最坏情况。
- en: 'Let''s look at this with the help of the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来探讨这个问题：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding class is a simple POJO class with no special indication or implementation
    related to the framework to make it a Spring component. So this class could function
    equally well in a Spring application as it could in a non-Spring application.
    This is the beauty of Spring's non-invasive programming model. Another way that
    Spring empowers POJO is by collaborating with other POJOs using the DI pattern.
    Let's see how DI works to help decouple components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类是一个简单的 POJO 类，没有任何特殊指示或实现与框架相关，使其成为 Spring 组件。因此，这个类在 Spring 应用程序中可以像在非 Spring
    应用程序中一样正常工作。这是 Spring 非侵入式编程模型的美妙之处。Spring 使 POJO 更加强大的另一种方式是通过使用依赖注入模式与其他 POJO
    协作。让我们看看依赖注入是如何帮助解耦组件的。
- en: Injecting dependencies between POJOs
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 POJO 之间注入依赖关系
- en: The term *dependency injection* is not new-it is used by PicoContainer. Dependency
    injection is a design pattern that promotes loose coupling between the Spring
    components--that is, between the different collaborating POJOs. So by applying
    DI to your complex programming, your code will become simpler, easier to understand,
    and easier to test.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“依赖注入”（*dependency injection*）并不新鲜——它被 PicoContainer 所使用。依赖注入是一种设计模式，它促进了
    Spring 组件之间的松散耦合——也就是说，在不同的协作 POJO 之间。因此，通过将依赖注入应用于复杂的编程，你的代码将变得更加简单、易于理解，并且易于测试。
- en: In your application, many objects are working together for a particular functionality
    as per your requirement. This collaboration between the objects is actually known
    as dependency injection. Injecting dependency between the working components helps
    you to unit test every component in your application without tight coupling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，许多对象根据你的要求协同工作以实现特定的功能。这些对象之间的协作实际上被称为依赖注入。在工作组件之间注入依赖关系可以帮助你在没有紧密耦合的情况下对应用程序中的每个组件进行单元测试。
- en: In a working application, what the end user wants is to see the output. To create
    the output, a few objects in the application work together and are sometimes coupled.
    So when you are writing these complex application classes, consider the reusability
    of these classes and make these classes as independent as possible. This is a
    best practice of coding that will help you in unit testing these classes independently.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个运行中的应用程序中，最终用户想要看到的是输出。为了创建输出，应用程序中的几个对象协同工作，有时会相互耦合。因此，当你编写这些复杂的应用程序类时，请考虑这些类的可重用性，并尽可能使这些类保持独立。这是编码的最佳实践之一，将有助于你独立地对这些类进行单元测试。
- en: How DI works and makes things easy for development and testing
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的工作原理以及它如何使开发和测试变得容易
- en: 'Let''s look at DI pattern implementation in your application. It makes things
    easy to understand, loosely coupled, and testable across the application. Suppose
    we have a simple application (something more complex than a *Hello World* example
    that you might make in your college classes). Every class is working together
    to perform some business task and help build business needs and expectations.
    That means that each class in the application has its measure of responsibility
    for a business task, together with other collaborating objects (its dependencies).
    Let''s look at the following image. This dependency between the objects can create
    complexity and tight coupling between the dependent objects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看您应用程序中DI模式的实现。它使事情变得易于理解，松散耦合，并在整个应用程序中进行测试。假设我们有一个简单的应用程序（比你在大学课程中可能制作的*Hello
    World*示例更复杂）。每个类都在共同努力执行某些业务任务，并帮助构建业务需求和期望。这意味着应用程序中的每个类都有其业务任务的责任度量，以及其他协作对象（其依赖项）。让我们看看以下图像。这种对象之间的依赖关系可能会在依赖对象之间创建复杂性和紧密耦合：
- en: '![](img/b2c99bac-e188-4ce7-b22f-1a3a4c6219f4.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2c99bac-e188-4ce7-b22f-1a3a4c6219f4.png)'
- en: 'The TransferService component is traditionally dependent on two other components:
    TransferRepository and AccountRepository'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferService`组件传统上依赖于另外两个组件：`TransferRepository`和`AccountRepository`'
- en: A typical application system consists of several parts working together to carry
    out a use case. For example, consider the `TransferService` class, shown next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的应用程序系统由几个部分组成，它们共同执行一个用例。例如，考虑下面的`TransferService`类。
- en: '`TransferService` using direct instantiation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接实例化的`TransferService`：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TransferService` object needs an `AccountRepository` object to make money
    transfer from account `a` to account `b`. Hence, it creates an instance of the
    `AccountRepository` object directly and uses it. But direct instantiation increases
    coupling and scatters the object creation code across the application, making
    it hard to maintain and difficult to write a unit test for `TransferService`,
    because, in this case, whenever you want to test the `transferMoney()` method
    of the `TransferService` class by using the `assert` to unit test, then the `transfer()`
    method of the `AccountRepository` class is also called unlikely by this test.
    But the developer is not aware about the dependency of `AccountRepository` on
    the `TransferService` class; at least, the developer is not able to test the `transferMoney()`
    method of the `TransferService` class using unit testing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferService`对象需要一个`AccountRepository`对象来从账户`a`向账户`b`进行转账。因此，它直接创建了一个`AccountRepository`对象的实例并使用它。但是，直接实例化增加了耦合度，并将对象创建代码分散到应用程序中，这使得维护变得困难，并且难以为`TransferService`编写单元测试，因为在这种情况下，每当您想通过使用`assert`进行单元测试来测试`TransferService`类的`transferMoney()`方法时，`AccountRepository`类的`transfer()`方法也可能被意外调用。但是，开发者并不了解`AccountRepository`对`TransferService`类的依赖；至少，开发者无法使用单元测试来测试`TransferService`类的`transferMoney()`方法。'
- en: In enterprise applications, coupling is very dangerous, and it pushes you to
    a situation where you will not be able to do any enhancement in the application
    in the future, where any further changes in such an application can create a lot
    of bugs, and where fixing these bugs can create new bugs. Tightly coupled components
    are one of the reasons for major problems in these applications. Unnecessary tightly
    coupled code makes your application non-maintainable, and as time goes by, its
    code will not be reused, as it cannot be understood by other developers. But sometimes
    a certain amount of coupling is required for an enterprise application because
    completely uncoupled components are not possible in real-world cases. Each component
    in the application has some responsibility for a role and business requirement,
    to the extent that all components in the application have to be aware of the responsibility
    of the other components. That means coupling is necessary sometimes, but we have
    to manage the coupling between required components very carefully.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，耦合是非常危险的，它把你推向一个无法在未来对应用程序进行任何增强的情况，任何此类应用程序的进一步更改都可能产生大量错误，而修复这些错误可能会产生新的错误。紧密耦合的组件是这些应用程序中主要问题的原因之一。不必要的紧密耦合代码使你的应用程序难以维护，随着时间的推移，其代码将不会被重用，因为其他开发者无法理解它。但有时，企业应用程序需要一定程度的耦合，因为在现实世界的案例中，完全解耦的组件是不可能的。应用程序中的每个组件都对某个角色和业务需求承担一些责任，以至于应用程序中的所有组件都必须了解其他组件的责任。这意味着有时需要耦合，但我们必须非常小心地管理所需组件之间的耦合。
- en: Using factory helper pattern for dependent components
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂辅助模式处理依赖组件
- en: Let's try another method for dependent objects using the Factory pattern. This
    design pattern is based on the GOF factory design pattern to create object instances
    by using a factory method. So this method actually centralizes the use of the
    new operator. It creates the object instances based on the information provided
    by the client code. This pattern is widely used in the dependency injection strategy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用工厂模式来处理依赖对象的方法。这个设计模式基于GOF（GoF，即设计模式之父）的工厂设计模式，通过工厂方法创建对象实例。因此，这种方法实际上集中了新操作符的使用。它根据客户端代码提供的信息创建对象实例。这种模式在依赖注入策略中得到了广泛的应用。
- en: '`TransferService` using factory helper:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂辅助的`TransferService`：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we use the Factory pattern to create an object of `AccountRepository`.
    In software engineering, one of the best practices of application design and development
    is **program-to-interface** (**P2I**). According to this practice, concrete classes
    must implement an interface that is used in the client code for the caller rather
    than using a concrete class. By using P2I, you can improve the preceding code.
    Therefore, we can easily replace it with a different implementation of the interface
    with little impact on the client code. So programming-to-interface provides us
    with a method involving low coupling. In other words, there is no direct dependency
    on a concrete implementation leading to low coupling. Let''s look at the following
    code. Here, `AccountRepository` is an interface rather than a class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用工厂模式创建了一个`AccountRepository`对象。在软件工程中，应用程序设计和开发的最佳实践之一是**面向接口编程**（**P2I**）。根据这一实践，具体的类必须实现一个接口，该接口在客户端代码中被调用者使用，而不是使用具体的类。通过使用P2I，你可以改进前面的代码。因此，我们可以轻松地用接口的不同实现来替换它，而对客户端代码的影响很小。所以面向接口编程为我们提供了一种涉及低耦合的方法。换句话说，没有直接依赖于具体实现，导致低耦合。让我们看看下面的代码。在这里，`AccountRepository`是一个接口，而不是一个类：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So we can implement it as per our requirement, and it is dependent upon the
    client''s infrastructure. Suppose we want an `AccountRepository` during the development
    phase with JDBC API. We can provide a `JdbcAccountRepositry` concrete implementation
    of the `AccountRepositry` interface, as shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以根据我们的需求来实现它，并且它依赖于客户端的基础设施。假设我们在开发阶段需要一个`AccountRepository`，使用JDBC API。我们可以提供`JdbcAccountRepositry`接口的具体实现，如下所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this pattern, objects are created by factory classes to make it easy to maintain,
    and this avoids scattering the code of object creation across other business components.
    With a factory helper, it is also possible to make object creation configurable.
    This technique provides a solution for tight coupling, but we are still adding
    factory classes to the business component for fetching collaborating components.
    So let's see the DI pattern in the next section and look at how to solve this
    problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，对象由工厂类创建，以便于维护，并避免将对象创建的代码散布到其他业务组件中。使用工厂助手，还可以使对象创建可配置。这种技术为紧密耦合提供了解决方案，但我们仍然在业务组件中添加工厂类以获取协作组件。所以让我们在下一节看看依赖注入模式，并看看如何解决这个问题。
- en: Using DI pattern for dependent components
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入模式对依赖组件进行操作
- en: 'According to the DI pattern, dependent objects are given their dependencies
    at the time of the creation of the objects by some factory or third party. This
    factory coordinates each object in the system in such a way that each dependent
    object is not expected to create their dependencies. This means that we have to
    focus on defining the dependencies instead of resolving the dependencies of collaborating
    objects in the enterprise application. Let''s look at the following image. You
    will learn that dependencies are injected into the objects that need them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据依赖注入模式，依赖对象在由某个工厂或第三方在对象创建时提供其依赖项。这个工厂以这种方式协调系统中的每个对象，即每个依赖对象不需要创建它们的依赖项。这意味着我们必须专注于定义依赖项，而不是解决企业应用程序中协作对象的依赖项。让我们看看下面的图像。你会了解到依赖项被注入到需要它们的对象中：
- en: '![](img/6e7a8be2-2737-49b0-902d-4131797bb0d5.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e7a8be2-2737-49b0-902d-4131797bb0d5.png)'
- en: Dependency injection between the different collaborating components in the application
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中不同协作组件之间的依赖注入
- en: To illustrate this point, let's look at `TransferService` in the next section--a
    `TransferService` has dependency with `AccountRepository` and `TransferRepository`.
    Here, `TransferService` is capable of transferring money by any kind implementation
    of `TransferRepository`, that is, we can either use `JdbcTransferRepository` or
    `JpaTransferRepository`, depending on whichever comes along according to the deployment
    environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们在下一节看看`TransferService`--一个`TransferService`与`AccountRepository`和`TransferRepository`有关联。在这里，`TransferService`能够通过`TransferRepository`的任何实现方式来转账，也就是说，我们可以使用`JdbcTransferRepository`或`JpaTransferRepository`，具体取决于部署环境。
- en: '`TransferServiceImpl` is flexible enough to take on any `TransferRepository`
    it''s given:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferServiceImpl`足够灵活，可以接受任何它被提供的`TransferRepository`：'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here you can see that `TransferServiceImpl` doesn't create its own repositories
    implementation. Instead, we have given the implementation of repositories at the
    time of construction as a constructor argument. This is a type of DI known as
    *constructor injection*. Here we have passed the repository interface type as
    an argument of the constructor. Now `TransferServiceImpl` could use any implementation
    of repositories, either JDBC, JPA, or mock objects. The point is that `TransferServiceImpl`
    isn't coupled to any specific implementation of repositories. It doesn't matter
    what kind of repository is used to transfer an amount from one account to another
    account, as long as it implements the repositories interfaces. If you are using
    the DI pattern of the Spring Framework, loose coupling is one of the key benefits.
    The DI pattern always promotes P2I, so each object knows about its dependencies
    by their associated interface rather than associated implementation, so the dependency
    can easily be swapped out with another implementation of that interface instead
    of changing to its dependent class implementation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`TransferServiceImpl`没有创建它自己的存储库实现。相反，我们在构造时作为构造函数参数提供了存储库的实现。这是一种称为*构造函数注入*的依赖注入类型。在这里，我们将存储库接口类型作为构造函数的参数传递。现在`TransferServiceImpl`可以使用任何存储库的实现，无论是JDBC、JPA还是模拟对象。重点是`TransferServiceImpl`没有耦合到任何特定的存储库实现。使用什么类型的存储库从一个账户转账到另一个账户无关紧要，只要它实现了存储库接口。如果你使用Spring框架的依赖注入模式，松耦合是其关键好处之一。依赖注入模式始终促进P2I，因此每个对象通过其关联的接口而不是关联的实现来了解其依赖项，因此依赖项可以轻松地用该接口的另一个实现替换，而不是更改其依赖类实现。
- en: 'Spring provides support for assembling such an application system from its
    parts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了从其部分组装此类应用程序系统的支持：
- en: Parts do not worry about finding each other
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部件无需担心找到彼此
- en: Any part can easily be swapped out
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何部分都可以轻松替换
- en: The method for assembling an application system by creating associations between
    application parts or components is known as **wiring**. In Spring, there are many
    ways to wire collaborating components together to make an application system.
    For instance, we could use either an XML configuration file or a Java configuration
    file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用程序部分或组件之间创建关联来组装应用程序系统的方法被称为**连接**。在Spring中，有多种方法可以将协作组件连接起来，以形成一个应用程序系统。例如，我们可以使用XML配置文件或Java配置文件。
- en: 'Now let''s look at how to inject the dependencies of `TransferRepository` and
    `AccountRepository` into a `TransferService` with Spring:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Spring将`TransferRepository`和`AccountRepository`的依赖注入到`TransferService`中：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `TransferServiceImpl`, `JdbcAccountRepository`, and `JdbcTransferRepository`
    are declared as beans in Spring. In the case of the `TransferServiceImpl` bean,
    it's constructed, passing a reference to the `AccountRepository` and `TransferRepository`
    beans as constructor arguments. You might like to know that Spring also allows
    you to express the same configuration using Java.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TransferServiceImpl`、`JdbcAccountRepository`和`JdbcTransferRepository`被声明为Spring中的bean。对于`TransferServiceImpl`
    bean，它通过构造函数参数传递对`AccountRepository`和`TransferRepository` bean的引用来构建。你可能想知道Spring还允许你使用Java表达式来表示相同的配置。
- en: 'Spring offers Java-based configuration as an alternative to XML:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了基于Java的配置作为XML的替代方案：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The benefits of the dependency injection pattern are the same whether you are
    using an XML-based or a Java-based configuration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是使用基于XML的还是基于Java的配置，依赖注入模式的优点都是相同的：
- en: Dependency injection promotes loose coupling. You can remove hard-coded dependencies
    with best practice P2I*,* and you could provide dependencies from outside the
    application by using the Factory pattern and its built-in swappable and pluggable
    implementation
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入促进了松耦合。你可以使用最佳实践P2I*移除硬编码的依赖项，并且你可以通过使用工厂模式和其内置的可交换和可插拔实现来从应用程序外部提供依赖项。
- en: The DI pattern promotes the composition design of object-oriented programming
    rather than inheritance programming
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式促进面向对象编程的复合设计，而不是继承编程
- en: Although `TransferService` depends on an `AccountRepository` and `TransferRepository`,
    it doesn't care about what type (JDBC or JPA) of implementations of `AccountRepository`
    and `TransferRepository` are used in the application. Only Spring, through its
    configuration (XML- or Java-based), knows how all the components come together
    and are instantiated with their required dependencies using the DI pattern. DI
    makes it possible to change those dependencies with no changes to the dependent
    classes--that is, we could use either a JDBC implementation or a JPA implementation
    without changing the implementation of `AccountService`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`TransferService`依赖于`AccountRepository`和`TransferRepository`，但它并不关心在应用程序中使用的是哪种类型的实现（JDBC或JPA）。只有Spring，通过其配置（XML或Java），知道所有组件是如何结合在一起，以及如何使用DI模式实例化并带有所需依赖项的。DI使得在不更改依赖类的情况下更改这些依赖项成为可能--也就是说，我们可以使用JDBC实现或JPA实现，而无需更改`AccountService`的实现。
- en: In a Spring application, an implementation of the application context (Spring
    offers `AnnotationConfigApplicationContext` for Java-based and `ClassPathXmlApplicationContext`
    for XML-based implementations) loads bean definitions and wires them together
    into a Spring container. The application context in Spring creates and wires the
    Spring beans for the application at startup. Look into the implementation of the
    Spring application context with Java-based configuration--It loads the Spring
    configuration files (`AppConfig.java` for Java and `Sprig.xml` for XML) located
    in the application's classpath. In the following code, the `main()` method of
    the `TransferMain` class uses a `AnnotationConfigApplicationContext` class to
    load the configuration class `AppConfig.java` and get an object of the `AccountService`
    class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，应用程序上下文的一个实现（Spring为基于Java的提供了`AnnotationConfigApplicationContext`，为基于XML的提供了`ClassPathXmlApplicationContext`）加载bean定义并将它们连接到Spring容器中。Spring应用程序上下文在启动时创建和连接Spring
    beans。查看基于Java配置的Spring应用程序上下文实现--它加载位于应用程序类路径中的Spring配置文件（Java的`AppConfig.java`和XML的`Spring.xml`）。在下面的代码中，`TransferMain`类的`main()`方法使用`AnnotationConfigApplicationContext`类来加载配置类`AppConfig.java`并获取`AccountService`类的对象。
- en: 'Spring offers Java-based configuration as an alternative to XML:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了基于Java的配置作为XML的替代方案：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we have a quick introduction to the dependency injection pattern. You'll
    learn a lot more about the DI pattern in the coming chapters of this book. Now
    let's look at another way of simplifying Java development using Spring's declarative
    programming model through aspects and proxy patterns.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对依赖注入（DI）模式进行了简要介绍。您将在本书的后续章节中了解更多关于DI模式的内容。现在，让我们看看另一种使用Spring的声明性编程模型通过方面和代理模式简化Java开发的方法。
- en: Applying aspects for cross cutting concerns
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用横切关注点的方面
- en: In a Spring application, the DI pattern provides us with loose coupling between
    collaborating software components, but **Aspect-Oriented Programming** in Spring
    (Spring **AOP**) enables you to capture common functionalities that are repetitive
    throughout your application. So we can say that Spring AOP promotes loose coupling
    and allows cross-cutting concerns, listed as follows, to be separated in a most
    elegant fashion. It allows these services to be applied transparently through
    declaration. With Spring AOP, it is possible to write custom aspects and configure
    them declaratively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，依赖注入（DI）模式为我们提供了协作软件组件之间的松耦合，但Spring中的面向切面编程（Spring AOP）使您能够捕获在整个应用程序中重复出现的常见功能。因此，我们可以这样说，Spring
    AOP促进了松耦合，并允许以下列出的横切关注点以最优雅的方式分离。它允许通过声明方式透明地应用这些服务。使用Spring AOP，您可以编写自定义方面并声明性地配置它们。
- en: 'The generic functionalities that are needed in many places in your application
    are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序中许多地方都需要通用的功能：
- en: Logging and tracing
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和跟踪
- en: Transaction management
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理
- en: Security
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Caching
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Error handling
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Performance monitoring
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能监控
- en: Custom business rules
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义业务规则
- en: 'The components listed here are not part of your core application, but these
    components have some additional responsibilities, commonly referred to as cross-cutting
    concerns because they tend to cut across multiple components in a system beyond
    their core responsibilities. If you put these components with your core functionalities,
    thereby implementing cross-cutting concerns without modularization, it will have
    two major problems:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的组件不是您核心应用程序的一部分，但这些组件有一些额外的职责，通常被称为横切关注点，因为它们往往跨越多个组件的系统，而不仅仅是它们的内核职责。如果您将这些组件与您的核心功能放在一起，从而在不进行模块化的情况下实现横切关注点，这将有两个主要问题：
- en: '**Code tangling**: A coupling of concerns means that a cross-cutting concern
    code, such as a security concern, a transaction concern, and a logging concern,
    is coupled with the code for business objects in your application.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码纠缠**：关注点的耦合意味着横切关注点代码，如安全关注点、事务关注点和记录关注点，与您的应用程序中业务对象的代码耦合在一起。'
- en: '**Code scattering**: Code scattering refers to the same concern being spread
    across modules. This means that your concern code of security, transaction, and
    logging is spread across all modules of the system. In other words, you can say
    there is a duplicity of the same concern code across the system.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码分散**：代码分散指的是相同关注点在模块中分散。这意味着您的安全、事务和记录的关注点代码分散在系统的所有模块中。换句话说，您可以说系统中有相同关注点代码的重复。'
- en: 'The following diagram illustrates this complexity. The business objects are
    too intimately involved with the cross-cutting concerns. Not only does each object
    know that it''s being logged, secured, and involved in a transactional context,
    but each object is also responsible for performing those services assigned only
    to it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了这种复杂性。业务对象与横切关注点过于紧密地结合在一起。不仅每个对象都知道它正在被记录、被保护并参与事务上下文，而且每个对象还负责执行仅分配给它的那些服务：
- en: '![](img/1ae8b16e-1e89-4134-88ac-dd5741964a3e.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ae8b16e-1e89-4134-88ac-dd5741964a3e.png)'
- en: Cross-cutting concerns, such as logging, security and transaction, are often
    scattered about in modules where those tasks are not their primary concern
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 横切关注点，如记录、安全和事务，通常散布在那些任务不是其主要关注点的模块中
- en: Spring AOP enables the modularization of cross-cutting concerns to avoid tangling
    and scattering. You can apply these modularized concerns to the core business
    components of the application declaratively without affecting the aforementioned
    the above components. The aspects ensure that the POJOs remain plain. Spring AOP
    makes this magic possible by using the Proxy Design Pattern. We will discuss the
    Proxy Design pattern more in the coming chapters of this book.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP使横切关注点的模块化成为可能，以避免纠缠和分散。你可以通过声明性方式将这些模块化关注点应用于应用程序的核心业务组件，而不会影响上述组件。方面确保POJO保持简单。Spring
    AOP通过使用代理设计模式来实现这一魔法。我们将在本书的后续章节中进一步讨论代理设计模式。
- en: How Spring AOP works
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP是如何工作的
- en: 'The following points describe the work of Spring AOP:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点描述了Spring AOP的工作：
- en: '**Implement your mainline application logic**: Focusing on the core problem
    means that, when you are writing the application business logic, you don''t need
    to worry about adding additional functionalities, such as logging, security, and
    transaction, between the business codes-Spring AOP takes care of it.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现你的主线应用程序逻辑**：专注于核心问题意味着，当你编写应用程序业务逻辑时，你不需要担心在业务代码之间添加额外的功能，如日志记录、安全和事务——Spring
    AOP会处理这些。'
- en: '**Write aspects to implement your cross-cutting concerns**: Spring provides
    many aspects out of the box, which means you can write additional functionalities
    in the form of the aspect as independent units in Spring AOP. These aspects have
    additional responsibilities as cross-cutting concerns beyond the application logic
    codes.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写方面以实现你的横切关注点**：Spring提供了许多开箱即用的方面，这意味着你可以在Spring AOP中以独立单元的形式编写额外的功能作为方面。这些方面作为横切关注点具有额外的责任，超出了应用程序逻辑代码。'
- en: '**Weave the aspects into your application**: Adding the cross-cutting behaviors
    to the right places, that is, after writing the aspects for additional responsibilities,
    you could declaratively inject them into the right places in the application logic
    codes.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将方面织入你的应用程序**：将横切行为添加到正确的位置，即在编写方面以添加额外责任之后，你可以通过声明性方式将这些方面注入到应用程序逻辑代码的正确位置。'
- en: 'Let''s look at an illustration of AOP in Spring:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring中AOP的一个示例：
- en: '![](img/cc447143-bff6-4bd0-bc4a-705954178b5e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc447143-bff6-4bd0-bc4a-705954178b5e.png)'
- en: AOP-based system evolution--this leaves the application components to focus
    on their specific business functionalities
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于AOP的系统演进——这使应用程序组件能够专注于它们特定的业务功能
- en: In the preceding diagram, Spring AOP separates the cross-cutting concerns, for
    example, security, transaction, and logging, from the business modules, that is,
    `BankService`, `CustomerService`, and `ReportingService`. These cross-cutting
    concerns are applied to predefined points (stripes in the preceding diagram) of
    the business modules at the running time of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，Spring AOP将横切关注点（例如，安全、事务和日志记录）从业务模块（即`BankService`、`CustomerService`和`ReportingService`）中分离出来。这些横切关注点在应用程序运行时应用于业务模块的预定义点（前面图中的条纹）。
- en: Suppose that you want to log the messages before and after calling the `transferAmmount()`
    method of `TransferService` using the services of a `LoggingAspect`. The following
    listing shows the `LoggingAspect` class you might use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用`LoggingAspect`的服务在调用`TransferService`的`transferAmmount()`方法之前和之后记录消息。以下列表显示了你可能使用的`LoggingAspect`类。
- en: '`LoggingAspect` call is used for logging the system for `TransferService`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggingAspect`调用用于为`TransferService`记录系统：'
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To turn `LoggingAspect` into an aspect bean, all you need to do is declare it
    as one in the Spring configuration file. Also, to make it an aspect, you have
    to add the `@Aspect` annotation to this class. Here's the updated `AppConfig.java`
    file, revised to declare `LoggingAspect` as an aspect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将`LoggingAspect`转换为方面bean，你只需要在Spring配置文件中将其声明为一种即可。此外，为了使其成为一个方面，你必须向这个类添加`@Aspect`注解。以下是更新后的`AppConfig.java`文件，已修改为声明`LoggingAspect`为方面。
- en: 'Declaring `LoggingAspect` as an aspect and enabling the `Apsect` proxy feature
    of Spring AOP:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`LoggingAspect`为方面并启用Spring AOP的`Apsect`代理功能：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're using Spring's AOP configuration based on Java to declare the `LoggingAspect`
    bean as an aspect. First, we declare `LoggingAspect` as a bean. Then we annotate
    that bean with the `@Aspect` annotation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用基于Java的Spring AOP配置来声明`LoggingAspect` bean作为方面。首先，我们声明`LoggingAspect`为一个bean。然后，我们使用`@Aspect`注解标注这个bean。
- en: We annotate `logBeforeTransfer()` of `LoggingAspect` with the `@Before` annotation
    so that this method is called before the `transferAmount()` is executed. This
    is called **before advice**. Then, we annotate another method of `LoggingAspect`
    with the `@After` annotation to declare that the `logAfterTransfer()` method should
    be called after `transferAmount()` has executed. This is known as **after advice**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Before`注解注释`LoggingAspect`的`logBeforeTransfer()`方法，以便在执行`transferAmount()`之前调用此方法。这被称为**前置通知**。然后，我们使用`@After`注解注释`LoggingAspect`的另一个方法，声明应在`transferAmount()`执行之后调用`logAfterTransfer()`方法。这被称为**后置通知**。
- en: '`@EnableAspectJAutoProxy` is used to enable Spring AOP features in the application.
    This annotation actually forces you to apply proxy to some of the components that
    are defined in the spring configuration file. We''ll talk more about Spring AOP
    later, in [Chapter 6](64590e34-2cb4-498b-a576-7a328e683632.xhtml), *Spring Aspect
    Oriented Programming with Proxy and Decorator Pattern*. For now, it''s enough
    to know that you''ve asked Spring to call `logBeforeTransfer()` and `logAferTransfer()`
    of `LoggingAspect` before and after the `transferAmount()` method of the `TransferService`
    class. For now, there are two important points to take away from this example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@EnableAspectJAutoProxy`来启用应用中的Spring AOP功能。这个注解实际上强制你将对在spring配置文件中定义的一些组件应用代理。我们将在[第6章](64590e34-2cb4-498b-a576-7a328e683632.xhtml)中更详细地讨论Spring
    AOP，*使用代理和装饰器模式的Spring面向切面编程*。现在，只需知道你已经要求Spring在`TransferService`类的`transferAmount()`方法之前和之后调用`LoggingAspect`的`logBeforeTransfer()`和`logAfterTransfer()`方法。现在，从这个例子中我们可以提取出两个重要的点：
- en: '`LoggingAspect` is still a POJO (if you ignore the `@Aspect` annotation or
    are using XML-based configuration)--nothing about it indicates that it''s to be
    used as an aspect.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggingAspect`仍然是一个POJO（如果你忽略`@Aspect`注解或使用基于XML的配置）--它没有任何表明它应该用作方面的信息。'
- en: It is important to remember that `LoggingAspect` can be applied to `TransferService`
    without `TransferService` needing to explicitly call it. In fact, `TransferService`
    remains completely unaware of the existence of `LoggingAspect`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要记住，`LoggingAspect`可以应用于`TransferService`，而无需`TransferService`显式调用它。实际上，`TransferService`对`LoggingAspect`的存在一无所知。
- en: Let's move to another way that Spring simplifies Java development.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向另一种Spring简化Java开发的方式。
- en: Applying the template pattern to eliminate boilerplate code
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用模板模式以消除样板代码
- en: 'At one point in the enterprise application, we saw some code that looked like
    code we had already written before in the same application. That is actually boilerplate
    code. It is code that we often have to write again and again in the same application
    to accomplish common requirements in different parts of the application. Unfortunately,
    there are a lot of places where Java APIs involve a bunch of boilerplate code.
    A common example of boilerplate code can be seen when working with JDBC to query
    data from a database. If you''ve ever worked with JDBC, you''ve probably written
    something in code that deals with the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用的一个阶段，我们看到了一些看起来像我们在同一应用中之前已经编写过的代码。这实际上是样板代码。这是我们在同一应用中反复编写以实现不同部分应用中常见需求的代码。不幸的是，Java
    API中有许多地方涉及大量的样板代码。当使用JDBC从数据库查询数据时，可以看到一个常见的样板代码示例。如果你曾经使用过JDBC，你可能已经编写了一些处理以下内容的代码：
- en: Retrieving a connection from the connection pool
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从连接池中检索连接
- en: Creating a `PreparedStatement` object
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`PreparedStatement`对象
- en: Binding SQL parameters
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定SQL参数
- en: Executing the `PreparedStatement` object
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`PreparedStatement`对象
- en: Retrieving data from the `ResultSet` object and populating data container objects
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ResultSet`对象中检索数据并填充数据容器对象
- en: Releasing all database resources
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放所有数据库资源
- en: 'Let''s look at the following code, it contains boilerplate code with the JDBC
    API of the Java:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码，它包含Java JDBC API的样板代码：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we can see that the JDBC code queries the database for
    an account name and amount. For this simple task, we have to create a connection,
    then create a statement, and finally query for the results. We also have to catch
    `SQLException`, a checked exception, even though there's not a lot you can do
    if it's thrown. Lastly, we have to clean up the mess, closing down the connection
    statement and result set. This could also force it to handle JDBC's exception,
    so you must catch `SQLException` here as well. This kind of boilerplate code seriously
    hurts reusability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们可以看到JDBC代码查询数据库以获取账户名称和金额。对于这个简单的任务，我们必须创建一个连接，然后创建一个语句，最后查询结果。我们还需要捕获`SQLException`，这是一个检查型异常，尽管如果它被抛出，你实际上能做的事情并不多。最后，我们必须清理混乱，关闭连接、语句和结果集。这也可能迫使它处理JDBC的异常，所以你在这里也必须捕获`SQLException`。这种样板代码严重影响了可重用性。
- en: Spring JDBC solves the problem of boilerplate code by using the Template Design
    pattern, and it makes life very easy by removing the common code in templates.
    This makes the data access code very clean and prevents nagging problems, such
    as connection leaks, because the Spring Framework ensures that all database resources
    are released properly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Spring JDBC通过使用模板设计模式解决了样板代码的问题，通过从模板中移除常见代码，使得生活变得非常简单。这使得数据访问代码非常干净，并防止了诸如连接泄漏等令人烦恼的问题，因为Spring框架确保所有数据库资源都得到适当的释放。
- en: The Template Design pattern in Spring
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的模板设计模式
- en: 'Let''s see how to go about using the Template Design pattern in spring:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Spring中使用模板设计模式：
- en: Define the outline or skeleton of an algorithm
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义算法的轮廓或骨架
- en: Leave the details for specific implementations until later.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具体实现的细节留到以后再说。
- en: Hide away large amounts of boilerplate code.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐藏大量的样板代码。
- en: 'Spring provides many template classes:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring提供了许多模板类：
- en: '`JdbcTemplate`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JdbcTemplate`'
- en: '`JmsTemplate`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JmsTemplate`'
- en: '`RestTemplate`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RestTemplate`'
- en: '`WebServiceTemplate`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebServiceTemplate`'
- en: Most hide low-level resource management
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数隐藏了低级资源管理
- en: Let's look at the same code that we used earlier with Spring's `JdbcTemplate`
    and how it removes the boilerplate code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前使用Spring的`JdbcTemplate`的相同代码，以及它是如何移除样板代码的。
- en: 'Use `JdbcTemplates` to let your code the focus on the task:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`JdbcTemplates`让你的代码专注于任务：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding code, this new version of `getAccountById()`
    is much simpler as compared to the boiler plate code, and here the method is focused
    on selecting an account from the database rather than creating a database connection,
    creating a statement, executing the query, handling the SQL exception, and finally
    closing the connection as well. With the template, you have to provide the SQL
    query and a `RowMapper` used for mapping the resulting set data to the domain
    object in the template's `queryForObject()` method. The template is responsible
    for doing everything for this operation, such as database connection and so on.
    It also hides a lot of boilerplate code behind the framework.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，与样板代码相比，这个新的`getAccountById()`版本要简单得多，这里的方法专注于从数据库中选择账户，而不是创建数据库连接、创建语句、执行查询、处理SQL异常，最后还要关闭连接。使用模板，你需要在模板的`queryForObject()`方法中提供SQL查询和一个`RowMapper`，用于将结果集数据映射到模板的域对象。模板负责完成这个操作的所有事情，比如数据库连接等等。它还在框架后面隐藏了大量的样板代码。
- en: We have seen in this section how Spring attacks the complexities of Java development
    with the power of POJO-oriented development and patterns such as the DI pattern,
    the Aspect-using Proxy pattern, and the Template method design pattern.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了Spring如何利用面向POJO的开发和DI模式、使用代理模式的Aspect模式以及模板方法设计模式等模式的力量来攻击Java开发的复杂性。
- en: In the next section, we will look at how to use a Spring container to create
    and manage the Spring beans in the application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Spring容器来创建和管理应用程序中的Spring beans。
- en: Using a Spring container to manage beans with the Factory pattern
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂模式通过Spring容器管理beans
- en: 'Spring provides us with a container, and our application objects live in this
    Spring container. As shown in the following diagram, this container is responsible
    for creating and managing the objects:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为我们提供了一个容器，我们的应用程序对象就生活在这个Spring容器中。如图所示，这个容器负责创建和管理对象：
- en: '![](img/f104d80b-e7c3-4be5-8407-8f61d8d3dc87.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f104d80b-e7c3-4be5-8407-8f61d8d3dc87.png)'
- en: In a Spring application, our application objects live in this Spring container
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，我们的应用程序对象就生活在这个Spring容器中
- en: The **Spring Container** also wires the many **Object** together according to
    its configuration. It is configured with some initialized parameters, and manages
    their complete life cycle from start to finish.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring容器**还根据其配置将许多**对象**连接在一起。它配置了一些初始化参数，并管理它们的完整生命周期，从开始到结束。'
- en: 'Basically, there are two distinct types of Spring container:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Spring容器有两种不同的类型：
- en: Bean factory
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean工厂
- en: Application contexts
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序上下文
- en: Bean factory
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean工厂
- en: In the Spring Framework, the `org.springframework.beans.factory.BeanFactory`
    interface provides the bean factory, which is a Spring IoC container. `XmlBeanFactory`
    is an implementation class for this interface. This container reads the configuration
    metadata from an XML file. It is based on the GOF factory method design pattern--it
    creates, manages, caches, and wires the application objects in a sophisticated
    manner. The bean factory is merely an object pool where objects are created and
    managed by configuration. For small applications, this is sufficient, but enterprise
    applications demand more, so spring provides another version of the spring container
    with more features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，`org.springframework.beans.factory.BeanFactory`接口提供了bean工厂，这是Spring的IoC容器。`XmlBeanFactory`是这个接口的实现类。这个容器从XML文件读取配置元数据。它基于GOF工厂方法设计模式--以复杂的方式创建、管理、缓存和连接应用程序对象。bean工厂只是一个对象池，其中对象由配置创建和管理。对于小型应用程序来说，这已经足够了，但企业应用程序需要更多功能，因此Spring提供了具有更多功能的spring容器版本。
- en: In the next section, we will learn about the application context and how Spring
    creates it in the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解应用程序上下文以及Spring如何在应用程序中创建它。
- en: Application contexts
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序上下文
- en: In the Spring Framework, the `org.springframework.context.ApplicationContext`
    interface also provides Spring's IoC container. It is simply a wrapper of the
    bean factory, providing some extra application context services, such as support
    for AOP and, hence, declarative transaction, security, and instrumentation support
    such as support for message resources required for internationalization, and the
    ability to publish application events to interested event listeners.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中，`org.springframework.context.ApplicationContext`接口还提供了Spring的IoC容器。它只是一个bean工厂的包装，提供了额外的应用程序上下文服务，例如支持AOP，因此支持声明式事务、安全性和支持国际化所需的消息资源，以及将应用程序事件发布给感兴趣的事件监听器的能力。
- en: Creating a container with an application context
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有应用程序上下文的容器
- en: 'Spring provides several flavors of application context as a bean container.
    There are multiple core implementations of the `ApplicationContext` interface,
    as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了多种应用程序上下文的版本作为bean容器。`ApplicationContext`接口有多个核心实现，如下所示：
- en: '`FileSystemXmlApplicationContext`: This class is an implementation of `ApplicationContext`
    that loads application context bean definitions from the configuration files (XML)
    located in the file system.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemXmlApplicationContext`: 这个类是`ApplicationContext`的一个实现，它从文件系统中位于配置文件（XML）加载应用程序上下文bean定义。'
- en: '`ClassPathXmlApplicationContext`: This class is an implementation of `ApplicationContext`
    that loads application context bean definitions from the configuration files (XML)
    located in the classpath of the application.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassPathXmlApplicationContext`: 这个类是`ApplicationContext`的一个实现，它从应用程序类路径中位于配置文件（XML）加载应用程序上下文bean定义。'
- en: '`AnnotationConfigApplicationContext`: This class is an implementation of `ApplicationContext`
    that loads application context bean definitions from the configuration classes
    (Java based) from the class path of the application.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationConfigApplicationContext`: 这个类是`ApplicationContext`的一个实现，它从应用程序的类路径中的配置类（基于Java）加载应用程序上下文bean定义。'
- en: 'Spring provides you with a web-aware implementation of the `ApplicationContext`
    interface, as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为你提供了一个具有网络意识的`ApplicationContext`接口实现，如下所示：
- en: '`XmlWebApplicationContext`: This class is a web-aware implementation of `ApplicationContext`
    that loads application context bean definitions from the configuration files (XML)
    contained in a web application.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlWebApplicationContext`: 这个类是一个具有网络意识的`ApplicationContext`实现，它从包含在Web应用程序中的配置文件（XML）加载应用程序上下文bean定义。'
- en: '`AnnotationConfigWebApplicationContext`: This class is a web-aware implementation
    of `ApplicationContext` that loads Spring web application context bean definitions
    from one or more Java-based configuration classes.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationConfigWebApplicationContext`: 这个类是一个具有网络意识的`ApplicationContext`实现，它从基于一个或多个Java配置类加载Spring
    Web应用程序上下文bean定义。'
- en: 'We can use either one of these implementations to load beans into a bean factory.
    It depends upon our application configuration file locations. For example, if
    you want to load your configuration file `spring.xml` from the file system in
    a specific location, Spring provides you with a `FileSystemXmlApplicationContext`,
    class that looks for the configuration file `spring.xml` in a specific location
    within the file system:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些实现中的任何一个来将bean加载到bean工厂中。这取决于我们的应用程序配置文件的位置。例如，如果你想从文件系统中的特定位置加载你的配置文件`spring.xml`，Spring为你提供了一个`FileSystemXmlApplicationContext`类，该类在文件系统中的特定位置查找配置文件`spring.xml`：
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the same way, you can also load your application configuration file `spring.xml`
    from the classpath of your application by using a `ClassPathXmlApplicationContext`
    class provided by Spring. It looks for the configuration file `spring.xml` anywhere
    in the classpath (including JAR files):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以通过使用Spring提供的`ClassPathXmlApplicationContext`类从你的应用程序的类路径中加载你的应用程序配置文件`spring.xml`。它会在类路径的任何位置（包括JAR文件）查找配置文件`spring.xml`：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are using a Java configuration instead of an XML configuration, you
    can use `AnnotationConfigApplicationContext`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Java配置而不是XML配置，你可以使用`AnnotationConfigApplicationContext`：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After loading the configuration files and getting an application context, we
    can fetch beans from the Spring container by calling the `getBean()` method of
    the application context:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载配置文件并获取应用程序上下文后，我们可以通过调用应用程序上下文的`getBean()`方法从Spring容器中获取bean：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the following section, we will learn about the Spring bean life cycle, and
    how a Spring container reacts to the Spring bean to create and manage it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解Spring bean的生命周期以及Spring容器如何对Spring bean进行响应以创建和管理它。
- en: Life of a bean in the container
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器中bean的生命
- en: 'The Spring application context uses the Factory method design pattern to create
    Spring beans in the container in the correct order according to the given configuration.
    So the Spring container has the responsibility of managing the life cycle of the
    bean from creation to destruction. In the normal java application, Java''s `new`
    keyword is used to instantiate the bean, and it''s ready to use. Once the bean
    is no longer in use, it''s eligible for garbage collection. But in the Spring
    container, the life cycle of the bean is more elaborate. The following image shows
    the life cycle of a typical Spring bean:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序上下文使用工厂方法设计模式，根据给定的配置以正确的顺序在容器中创建Spring bean。因此，Spring容器有责任管理bean的生命周期，从创建到销毁。在正常的Java应用程序中，Java的`new`关键字用于实例化bean，并且它就绪可以使用。一旦bean不再使用，它就有资格进行垃圾回收。但在Spring容器中，bean的生命周期更为复杂。以下图像显示了典型Spring
    bean的生命周期：
- en: '![](img/4d82146c-4b42-40ac-be72-3de7fd446161.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d82146c-4b42-40ac-be72-3de7fd446161.png)'
- en: 'The life cycle of a Spring bean in the Spring container is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器中Spring bean的生命周期如下：
- en: Load all bean definitions, creating an ordered graph.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载所有bean定义，创建一个有序图。
- en: Instantiate and run `BeanFactoryPostProcessors` (you can update bean definitions
    here).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化和运行`BeanFactoryPostProcessors`（你可以在这里更新bean定义）。
- en: Instantiate each bean.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化每个bean。
- en: Spring injects the values and bean references into the beans' properties.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring将值和bean引用注入到bean的属性中。
- en: Spring passes the ID of the bean to the `setBeanName()` method of the `BeanNameAware`
    interface if any bean implements it.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何bean实现了它，Spring会将bean的ID传递给`BeanNameAware`接口的`setBeanName()`方法。
- en: Spring passes the reference of the bean factory itself to the `setBeanFactory()`
    method of `BeanFactoryAware` if any bean implements it.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何bean实现了它，Spring会将bean工厂本身的引用传递给`BeanFactoryAware`的`setBeanFactory()`方法。
- en: Spring passes the reference of the application context itself to the `setApplicationContext()`
    method of `ApplicationContextAware` if any bean implements it.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何bean实现了它，Spring会将应用程序上下文本身的引用传递给`ApplicationContextAware`的`setApplicationContext()`方法。
- en: '`BeanPostProcessor` is an interface, and Spring allows you to implement it
    with your bean, and modifies the instance of the bean before the initializer is
    invoked in the Spring bean container by calling its `postProcessBeforeInitialization()`.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BeanPostProcessor`是一个接口，Spring允许你使用你的bean实现它，并在Spring bean容器中初始化器调用之前通过调用其`postProcessBeforeInitialization()`方法修改bean的实例。'
- en: If your bean implements the `InitializingBean` interface, Spring calls its `afterPropertiesSet()`
    method to initialize any process or loading resource for your application. It's
    dependent on your specified initialization method. There are other methods to
    achieve this step, for example, you can use the `init-method` of the `<bean>`
    tag, the `initMethod` attribute of the `@Bean` annotation, and JSR 250's `@PostConstruct`
    annotation.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的bean实现了`InitializingBean`接口，Spring将调用其`afterPropertiesSet()`方法来初始化应用程序的任何过程或加载资源。这取决于您指定的初始化方法。还有其他方法可以实现这一步骤，例如，您可以使用`<bean>`标签的`init-method`，`@Bean`注解的`initMethod`属性，以及JSR
    250的`@PostConstruct`注解。
- en: '`BeanPostProcessor` is an interface, and spring allows you to implement it
    with your bean. It modifies the instance of the bean after the initializer is
    invoked in the spring bean container by calling its `postProcessAfterInitialization()`.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BeanPostProcessor`是一个接口，Spring允许您使用自己的bean来实现它。它通过调用其`postProcessAfterInitialization()`方法，在Spring
    bean容器中初始化器被调用后修改bean的实例。'
- en: Now your bean is ready to use in the step, and your application can access this
    bean by using the `getBean()` method of the application context. Your beans remain
    live in the application context until it is closed by calling the `close()` method
    of the application context.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的bean已经准备好在步骤中使用，并且您的应用程序可以通过使用应用程序上下文的`getBean()`方法来访问这个bean。您的bean在应用程序上下文中保持活跃，直到通过调用应用程序上下文的`close()`方法来关闭它。
- en: If your bean implements the `DisposibleBean` interface, Spring calls its `destroy()`
    method to destroy any process or clean up the resources of your application. There
    are other methods to achieve this step-for example, you can use the `destroy-method`
    of the `<bean>` tag, the `destroyMethod` attribute of the `@Bean` annotation,
    and JSR 250's `@PreDestroy` annotation.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的bean实现了`DisposibleBean`接口，Spring将调用其`destroy()`方法来销毁应用程序的任何过程或清理资源。还有其他方法可以实现这一步骤--例如，您可以使用`<bean>`标签的`destroy-method`，`@Bean`注解的`destroyMethod`属性，以及JSR
    250的`@PreDestroy`注解。
- en: These steps show the life cycle of Spring beans in the container.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些步骤展示了Spring容器中Spring bean的生命周期。
- en: The next section describes the modules that are provided by the Spring Framework.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分将描述Spring框架提供的模块。
- en: Spring modules
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring模块
- en: Spring Framework has several distinct modules for a specific set of functionalities,
    and they work more or less independently of the others. This system is very flexible,
    so the developer can choose only those required for the enterprise application.
    For example, a developer can just use the Spring DI module and build the rest
    of the application with non-Spring components. So, Spring provides integration
    points to work with other frameworks and APIs--for example, you can use the Spring
    Core DI pattern only with the Struts application. In case the development team
    is more proficient in using Struts, it can be used instead of Spring MVC while
    the rest of the application uses Spring components and features, such as JDBC
    and transactions. So while the developers need to deploy the required dependencies
    with the Struts application, there is no need to add a whole Spring Framework.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架为特定的一组功能提供了几个不同的模块，并且它们在某种程度上相互独立。这个系统非常灵活，因此开发者可以选择仅用于企业应用程序的模块。例如，开发者可以使用Spring
    DI模块，并用非Spring组件构建应用程序的其余部分。因此，Spring提供了与其他框架和API一起工作的集成点--例如，您只能使用Spring Core
    DI模式与Struts应用程序一起使用。如果开发团队更擅长使用Struts，那么在应用程序的其他部分使用Spring组件和功能（如JDBC和事务）的同时，可以使用Struts
    MVC而不是Spring MVC。因此，虽然开发人员需要与Struts应用程序一起部署所需的依赖项，但无需添加整个Spring框架。
- en: 'Here is an overview of the entire module structure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是整个模块结构的概述：
- en: '![](img/8ffd496c-8122-4b1c-8392-ec78d0961c87.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ffd496c-8122-4b1c-8392-ec78d0961c87.png)'
- en: The various modules of the Spring Framework
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架的各个模块
- en: Let's look at each of Spring's modules and see how each fits in to the bigger
    picture.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring的每个模块，并看看它们如何融入更大的图景。
- en: Core Spring container
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心Spring容器
- en: This module of the Spring Framework uses lot of the design pattern such as the
    Factory method design pattern, DI pattern, Abstract Factory Design pattern, Singleton
    Design pattern, Prototype Design pattern, and so on. All other Spring modules
    are dependent on this module. You'll implicitly use these classes when you configure
    your application. It is also called the IoC container and is central to Spring's
    support for dependency injection, which manages how the beans in a Spring application
    are created, configured, and managed. You can create Spring container either by
    using the implementations of `BeanFactory` or the implementations of the `ApplicationContext`.
    This module contains the Spring bean factory, which is the portion of Spring that
    provides the DI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'Spring 框架的这个模块使用了大量的设计模式，例如工厂方法设计模式、DI 模式、抽象工厂设计模式、单例设计模式、原型设计模式等。所有其他 Spring
    模块都依赖于此模块。当您配置应用程序时，您会隐式地使用这些类。它也被称为 IoC 容器，是 Spring 对依赖注入支持的核心，它管理着 Spring 应用程序中
    bean 的创建、配置和管理。您可以通过使用 `BeanFactory` 的实现或 `ApplicationContext` 的实现来创建 Spring 容器。此模块包含
    Spring bean 工厂，这是 Spring 提供 DI 的部分。 '
- en: Spring's AOP module
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 的 AOP 模块
- en: Spring AOP is a Java-based AOP Framework with AspectJ integration. It uses dynamic
    proxies for aspect weaving and focuses on using AOP to solve enterprise problems.
    This module is based on Proxy and Decorator Design patterns. This module enables
    the modularization of cross-cutting concerns to avoid tangling and eliminate scattering.
    Like DI, it supports loose coupling between the core business service and cross-cutting
    concerns. You can implement your custom aspects and configure them declaratively
    in your application without impacting on the code of business objects. It provides
    much flexibility in the code; you could remove or change the aspect logic without
    touching the code of the business objects. This is a very important module of
    the spring framework, so I will discuss it in detail in [Chapter 6](64590e34-2cb4-498b-a576-7a328e683632.xhtml),
    *Spring Aspect Oriented Programming with Proxy and Decorator Pattern* of this
    book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP 是一个基于 Java 的 AOP 框架，集成了 AspectJ。它使用动态代理进行方面织入，并专注于使用 AOP 解决企业级问题。本模块基于代理和装饰器设计模式。此模块使跨切面关注点的模块化成为可能，以避免纠缠和消除散布。类似于
    DI，它支持核心业务服务和跨切面之间的松耦合。您可以在应用程序中声明式地实现自定义方面并配置它们，而不会影响业务对象的代码。它在代码中提供了很大的灵活性；您可以在不触及业务对象代码的情况下删除或更改方面逻辑。这是
    Spring 框架中非常重要的一个模块，因此我将在本书的[第 6 章](64590e34-2cb4-498b-a576-7a328e683632.xhtml)，“使用代理和装饰器模式的
    Spring 面向切面编程”中详细讨论。
- en: Spring DAO - data access and integration
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring DAO - 数据访问和集成
- en: Spring DAO and Spring JDBC make life very easy by using templates to remove
    the common code. The templates implement the GOF template method design pattern
    and provide suitable extension points to plug in custom code. If you are working
    with a traditional JDBC application, you have to write lots of boilerplate code
    to, for example, create a database connection, create a statement, find a result
    set, handle SQLException, and finally close the connection. If you are working
    with a Spring JDBC Framework with a DAO layer, then you do not have to write boilerplate
    code, unlike a traditional JDBC application. That means that Spring allows you
    to keep your application code clean and simple.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Spring DAO 和 Spring JDBC 通过使用模板来移除通用代码，使得生活变得非常简单。这些模板实现了 GOF 模板方法设计模式，并提供了合适的扩展点以插入自定义代码。如果您正在使用传统的
    JDBC 应用程序，您必须编写大量的样板代码，例如创建数据库连接、创建语句、查找结果集、处理 SQLException，最后关闭连接。如果您正在使用具有 DAO
    层的 Spring JDBC 框架，那么您不需要编写样板代码，这与传统的 JDBC 应用程序不同。这意味着 Spring 允许您保持应用程序代码的清洁和简单。
- en: Spring's ORM
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 的 ORM
- en: Spring also provides support to ORM solutions, and it provides integration with
    ORM tools for easy persistence of POJO objects in relational databases. This module
    actually provides an extension to the Spring DAO module. Like JDBC-based templates,
    Spring provides ORM templates to work with leading ORM products, such as Hibernate,
    JPA, OpenJPA, TopLink, iBATIS, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还为 ORM 解决方案提供支持，并为 ORM 工具提供集成，以便在关系数据库中轻松持久化 POJO 对象。此模块实际上为 Spring DAO
    模块提供了一个扩展。类似于基于 JDBC 的模板，Spring 为与领先的 ORM 产品（如 Hibernate、JPA、OpenJPA、TopLink、iBATIS
    等）一起工作提供了 ORM 模板。
- en: Spring web MVC
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring web MVC
- en: Spring provides a web and remote module for the enterprise web application.
    This module helps build highly flexible web applications, leveraging the complete
    benefits of the Spring IOC container. This module of Spring uses the patterns
    such as the MVC architectural pattern, Front Controller pattern, and the DispatcherServlet
    Pattern, and it seamlessly integrates with the servlet API. The Spring web module
    is very pluggable and flexible. We can add any of the view technologies, such
    as JSP, FreeMarker, Velocity, and so on. We can also integrate it with other frameworks,
    such as Struts, Webwork, and JSF, using spring IOC and DI.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: New features in Spring Framework 5.0
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring 5.0 is the freshest release of Spring available. There are a lot of
    exciting new features in Spring 5.0, including the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for JDK 8 + 9 and Java EE 7 Baseline:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring 5 supports Java 8 as a minimum requirement, as the entire framework codebase
    is based on Java 8.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework required at least Java EE 7 to run Spring Framework 5.0 applications.
    That means it requires Servlet 3.1, JMS 2.0, JPA 2.1.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated and removed packages, classes, and methods:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Spring 5.0, some packages have been either removed or deprecated. It has
    had a package called `mock.static` removed from the spring-aspects module, and
    hence there is no support for `AnnotationDrivenStaticEntityMockingControl`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Packages such as `web.view.tiles2` and `orm.hibernate3/hibernate4` have also
    been removed as of Spring 5.0\. Now, in the latest spring framework, Tiles 3 and
    Hibernate 5 are being used.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The Spring 5.0 framework doesn't support Portlet, Velocity, JasperReports, XMLBeans,
    JDO, Guava (and so on) anymore.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Some deprecated classes and methods of earlier versions of Spring have been
    removed as of Spring 5.0.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the new reactive programming model:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This model of programming has been introduced in the Spring 5.0 Framework. Let's
    look at the following listed point about the reactive programming model.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Spring 5 introduced the Spring-core module `DataBuffer` and encoder/decoder
    abstractions with non-blocking semantics into the reactive programming model.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Using the reactive model, Spring 5.0 provides the Spring-web module for HTTP
    message codec implementations with **JSON** (**Jackson**) and **XML** (**JAXB**)
    support.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The Spring reactive programming model added a new `spring-web-reactive` module
    with reactive support for the `@Controller` programming model, adapting reactive
    streams to Servlet 3.1 containers, as well as non-Servlet runtimes, such as Netty
    and Undertow.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Spring 5.0 also introduced a new `WebClient` with reactive support on the client
    side to access services.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: As listed here, you can see that there are a lot of exciting new features and
    enhancements in the Spring Framework 5\. So in this book, we will look at many
    of these new features with examples and their adopted design patterns.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now have a good overview of the Spring
    Framework and its most-used design patterns. I highlighted the problem with the
    J2EE traditional application, and how Spring solves these problems and simplifies
    Java development by using lots of design patterns and good practices to create
    an application. Spring aims to make enterprise Java development easier and to
    promote loosely coupled code. We have also discussed Spring AOP for cross-cutting
    concerns and the DI pattern for use with loose coupling and pluggable Spring components
    so that the objects don't need to know where their dependencies come from or how
    they're implemented. Spring Framework is an enabler for best practices and effective
    object design. Spring Framework has two important features--First it has a Spring
    container to create and manage the life of beans and second it provides support
    to several modules and integration to help simplify Java development.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章之后，你现在应该对 Spring 框架及其最常用的设计模式有一个良好的概述。我指出了 J2EE 传统应用中存在的问题，以及 Spring 如何通过使用大量设计模式和良好实践来解决问题并简化
    Java 开发，创建一个应用。Spring 的目标是使企业级 Java 开发更加容易，并促进松耦合代码。我们还讨论了 Spring AOP 用于解决横切关注点，以及
    DI 模式用于与松耦合和可插拔的 Spring 组件一起使用，这样对象就不需要知道它们的依赖从何而来或如何实现。Spring 框架是最佳实践和有效对象设计的推动者。Spring
    框架有两个重要特性——首先，它有一个 Spring 容器来创建和管理 Bean 的生命周期；其次，它为几个模块和集成提供支持，以帮助简化 Java 开发。
