<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;The Java Persistence API"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. The Java Persistence API</h1></div></div></div><p>This chapter deals with the improvements in APIs for communicating with data sources. Although Java is object oriented, it is designed to handle data of relational models as objects, which might pose a serious problem because the two concepts are not theoretically compatible. In addition to introducing you to the world of object-relational mapping, this chapter will show you how to manipulate (create, delete, search, or edit) the data of relational models as objects transparently and transactional. Topics covered in this chapter are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Java Persistence API 2.1</li><li class="listitem" style="list-style-type: disc">Java Transaction API 1.2</li></ul></div><div class="section" title="Java Persistence API 2.1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Java Persistence API 2.1</h1></div></div></div><p>The Java Persistence API 2.1 <a id="id198" class="indexterm"/>Specification was developed under <span class="strong"><strong>JSR-338</strong></span>. <a id="id199" class="indexterm"/>This section just gives you an overview of the improvements in the API. The <a id="id200" class="indexterm"/>complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html</a>.</p><div class="section" title="JPA (Java Persistence API)"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>JPA (Java Persistence API)</h2></div></div></div><p><span class="strong"><strong>JPA</strong></span> (<span class="strong"><strong>Java Persistence API</strong></span>) is a Java <a id="id201" class="indexterm"/>specification that aims to define the standard features of <a id="id202" class="indexterm"/>
<span class="strong"><strong>ORM</strong></span>s (<span class="strong"><strong>Object-Relational Mappings</strong></span>). However, JPA is not a product but a set of interfaces that require implementations. The most well-known implementations are as follows: <span class="strong"><strong>Hibernate</strong></span>, <span class="strong"><strong>Toplink</strong></span>, <span class="strong"><strong>OpenJPA,</strong></span> and <span class="strong"><strong>EclipseLink</strong></span>, <a id="id203" class="indexterm"/>which is the reference implementation.</p><p>Briefly, we can say that an ORM is an API used to establish a correspondence between the object model and a relational database. It gives you the ability to handle the data of your database as if they were objects, without too much worry about the physical schema.</p></div><div class="section" title="JPA in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>JPA in action</h2></div></div></div><p>JPA is based on the concept of entities, <a id="id204" class="indexterm"/>in order to make object-relational mapping possible. An entity is a simple Java class (like <span class="strong"><strong>POJO</strong></span>) with <code class="literal">@Entity</code> annotation (or XML equivalent) whose name is by default associated with the table having the same name in the database. In addition to the <code class="literal">@Entity</code> annotation, an entity class must have at least one primary key equivalent attribute that is designated with the <code class="literal">@Id</code> annotation (or XML equivalent). For the other attributes of the entity, the provider associates each of them to the column having the same name in the table, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/9235OT_04_01.jpg" alt="JPA in action"/></div><p>The parameters that indicate the database that will be associated to a set of entities must be defined in the persistence unit within the <code class="literal">persistence.xml</code> file of your application.</p><p>The following code is an example of the persistence unit of a Java SE Application:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1" 
   
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence 
  http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
  &lt;persistence-unit name="chapter04PU"transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;com.packt.ch04.entities.Student&lt;/class&gt;
    &lt;properties&gt;
      &lt;property name="javax.persistence.jdbc.url"value="jdbc:derby://localhost:1527/ONLINEREGISTRATION"/&gt;
      &lt;property name="javax.persistence.jdbc.password"value="userapp"/&gt;
      &lt;property name="javax.persistence.jdbc.driver"value="org.apache.derby.jdbc.ClientDriver"/&gt;
      &lt;property name="javax.persistence.jdbc.user"value="userapp"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p>Concerning the manipulation of entities, JPA offers through the <code class="literal">EntityManager</code> interface a set of methods to create, read, update, and delete the data (see the following table).</p><p>The following table presents some <a id="id205" class="indexterm"/>methods for manipulating the entities:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">void persist(Object o)</code></p>
</td><td style="text-align: left" valign="top">
<p>This is used to <a id="id206" class="indexterm"/>save the entity passed as a parameter.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">T merge(T t)</code></p>
</td><td style="text-align: left" valign="top">
<p>This allows you to <a id="id207" class="indexterm"/>merge the entity passed as a parameter with the persistence context. It returns a managed version of the entity to be merged.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void remove(Object o)</code></p>
</td><td style="text-align: left" valign="top">
<p>This allows you <a id="id208" class="indexterm"/>to delete the entity passed as parameter in the database.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">T find(Class&lt;T&gt; type, Object o)</code></p>
</td><td style="text-align: left" valign="top">
<p>This allows you <a id="id209" class="indexterm"/>to search for an entity using its identifier.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">void detach(Object o)</code></p>
</td><td style="text-align: left" valign="top">
<p>This allows you to <a id="id210" class="indexterm"/>detach an entity from the persistence context so that the changes will not be saved</p>
</td></tr></tbody></table></div><p>The following code demonstrates how to save, read, update, and delete the data using JPA in a Java SE application:</p><div class="informalexample"><pre class="programlisting">public static void main( String[] args ) {
  EntityManagerFactory emf =Persistence.createEntityManagerFactory("chapter04PU");
  EntityManager em = emf.createEntityManager();
  //create entity manager
  
  Student student = createStudent();
  
  em.getTransaction().begin();//begin transaction
  em.persist(student);//save the student
  em.getTransaction().commit(); // commit transaction
  Student std = em.find(Student.class, student.getId());
  //find student
  
  System.out.println("ID : "+std.getId()+",last name : "+std.getLastname());       
  em.getTransaction().begin();//begin transaction
  std.setLastname("NGANBEL");//Update student's last name
  em.getTransaction().commit(); // commit transaction
  
  std = em.find(Student.class, student.getId());//find student
  System.out.println("ID : "+std.getId()+",last name : "+std.getLastname()); 
  
  em.getTransaction().begin();//begin transaction
  em.remove(std);//remove student
  em.getTransaction().commit(); // commit transaction
}</pre></div></div><div class="section" title="The latest improvements of JPA 2.1 in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The latest improvements of JPA 2.1 in action</h2></div></div></div><p>Since its last version (JPA 2.0), the <a id="id211" class="indexterm"/>JPA Specification has had many enhancements. The most important enhancements are in the following features: persistence context synchronization, Entities, <span class="strong"><strong>JPQL</strong></span>, <span class="strong"><strong>Criteria API</strong></span>, and <span class="strong"><strong>Data Definition Language</strong></span> (<span class="strong"><strong>DDL</strong></span>) generation.</p><div class="section" title="Persistence context synchronization"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec26"/>Persistence context synchronization</h3></div></div></div><p>Before JPA 2.1, the <a id="id212" class="indexterm"/>container-managed persistence context was <a id="id213" class="indexterm"/>automatically joined to the current transaction, and any update made to the persistence context was propagated to the underlying resource manager. With the new specification, it is now possible to have a persistence context that will not be automatically enlisted in any JTA transaction. This can be done by simply creating a container-managed entity manager of synchronization type <code class="literal">SynchronizationType.UNSYNCHRONIZED</code> as shown in the following code.</p><p>Creation and enlistment of a <a id="id214" class="indexterm"/>
<code class="literal">SynchronizationType.UNSYNCHRONIZED</code> persistence context:</p><div class="informalexample"><pre class="programlisting">@Stateless
@LocalBean
public class MySessionBean {

  /* Creation of an entity manager for 
   * unsynchronized persistence context
  */
  @PersistenceContext(synchronization = SynchronizationType.UNSYNCHRONIZED)
  EntityManager em;
  
  public void useUnsynchronizedEntityManager(){
      //enlisting of an unsynchronized persistence context
      em.joinTransaction();
      //...
  }
}</pre></div><p>In the preceding code, <a id="id215" class="indexterm"/>you will notice that we called the <code class="literal">EntityManager.joinTransaction()</code> method; this is justified by the fact that a persistence context of type <code class="literal">SynchronizationType.UNSYNCHRONIZED</code> is enlisted in a JTA transaction only after calling the <code class="literal">EntityManager.joinTransaction()</code> method, and after a commit or rollback, the <code class="literal">SynchronizationType.UNSYNCHRONIZED</code> persistence context will be <a id="id216" class="indexterm"/>dissociated from the transaction to which it was enlisted. You need to call the <code class="literal">EntityManager.joinTransaction()</code> method again to enlist the dissociated persistence context.</p></div><div class="section" title="Entity"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec27"/>Entity</h3></div></div></div><p>An entity listener is a <a id="id217" class="indexterm"/>simple Java class (not an entity), which allows you to define the lifecycle callback methods that can be invoked for the lifecycle events of one or many entities. <a id="id218" class="indexterm"/>The JPA 2.1 Specification adds to these classes the support of <a id="id219" class="indexterm"/>
<span class="strong"><strong>CDI injection</strong></span> and the ability to define <a id="id220" class="indexterm"/>
<code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> lifecycle callback methods. These methods are respectively <a id="id221" class="indexterm"/>called after the dependency injections and before the destruction of the entity listener. The following code presents an entity listener that has the post construct and pre destroy methods with an <a id="id222" class="indexterm"/>
<span class="strong"><strong>EJB injection</strong></span>. It is followed by code that shows how to associate an entity listener to an entity.</p><div class="informalexample"><pre class="programlisting">public class LogEntityListener {
  @EJB
  BeanLoggerLocal beanLogger;
  
  @PrePersist
  public void prePersistCallback(Object entity){
    beanLogger.logInformation(entity);
  }
  
  @PostConstruct
  public void init(){
    System.out.println("Dependency injected inLogEntityListener");
  }
  
  @PreDestroy
  public void destroy(){
    System.out.println("LogEntityListener will be destroy");
  }
}

@Entity
@EntityListeners(LogEntityListener.class)
public class Student implements Serializable {
  //
}</pre></div></div><div class="section" title="New annotations"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec28"/>New annotations</h3></div></div></div><p>JPA 2.1 added an <a id="id223" class="indexterm"/>annotation (<code class="literal">@Index</code>) to create indexes on tables when a schema is generated from entities <a id="id224" class="indexterm"/>and an annotation (<code class="literal">@ForeignKey</code>) to designate foreign keys of a table.</p><p>The <code class="literal">@Index</code> annotation has <a id="id225" class="indexterm"/>one mandatory parameter (<code class="literal">columnList</code>) <a id="id226" class="indexterm"/>to list the columns that make up the index with different sort orders. It also has two optional parameters: the <code class="literal">name</code> parameter, which allows you to change the default name of the index, and the <code class="literal">unique</code> parameter to set the index as unique or not unique. In parallel, <code class="literal">@Index</code> annotation was added as a part of <code class="literal">Table</code>, <code class="literal">SecondaryTable</code>, <code class="literal">CollectionTable</code>, <code class="literal">JoinTable</code>, and <code class="literal">TableGenerator</code> annotations.</p><p>The <code class="literal">@ForeignKey</code> can <a id="id227" class="indexterm"/>be used as element of <code class="literal">JoinColumn</code>, <code class="literal">JoinColumns</code>, <code class="literal">MapKeyJoinColumn</code>, <code class="literal">MapKeyJoinColumns</code>, <code class="literal">PrimaryKeyJoinColumn</code>, <a id="id228" class="indexterm"/>
<code class="literal">PrimaryKeyJoinColumns</code>, <code class="literal">CollectionTable</code>, <code class="literal">JoinTable</code>, <code class="literal">SecondaryTable</code>, and <code class="literal">AssociationOverride</code> annotations to either define or modify the foreign key constraints on a table. It takes three parameters: name, value for the constraint, and the definition of the foreign key. The three parameters are optional.</p><p>An example of an entity with a foreign key and indexed columns is shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Entity
@Table(indexes = @Index(columnList = "name ASC, id DESC"))
public class MyEntity implements Serializable {
  @Id
  private Long id;    
  private String name;
  @JoinColumn(foreignKey = @ForeignKey(name = "FK"))
  private Student student;

  //...    
}</pre></div></div><div class="section" title="Entity graphs"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec29"/>Entity graphs</h3></div></div></div><p>When we talk about an entity graph, <a id="id229" class="indexterm"/>we have to keep in mind a data structure involving several <a id="id230" class="indexterm"/>related entities. With the previous version of JPA, the efficient loading of data of an entity was essentially managed through the fetch setting. The consequence was that it was necessary to set the fetch attribute of some annotations before compiling the application (or before deployment in the case of XML configuration) in order to request that an entity attribute be loaded <span class="strong"><strong>eagerly</strong></span> <a id="id231" class="indexterm"/>(when entity is loaded) or <a id="id232" class="indexterm"/>
<span class="strong"><strong>lazily</strong></span> (when data is needed). Through entity graphs, you can now override or change the fetch setting at runtime.</p><p>An entity graph can be defined statically by using a vast <code class="literal">NamedEntityGraph</code>, <code class="literal">NamedEntityGraphs</code>, <code class="literal">NamedSubgraph</code>, and <code class="literal">NamedAttributeNode</code> annotations, or dynamically through <code class="literal">EntityGraph</code>, <code class="literal">subgraph</code>, and <code class="literal">AttributeNode</code> interfaces.</p><div class="section" title="Static or named entity graphs"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec14"/>Static or named entity graphs</h4></div></div></div><p>The <code class="literal">@NamedEntityGraph</code> annotation <a id="id233" class="indexterm"/>is used to define an entity graph that <a id="id234" class="indexterm"/>can be used at runtime when executing queries <a id="id235" class="indexterm"/>or <a id="id236" class="indexterm"/>using the <code class="literal">find()</code> method. <a id="id237" class="indexterm"/>The following code shows an example of the definition of a named entity graph with one field: <code class="literal">students</code>.</p><div class="informalexample"><pre class="programlisting">@Entity
@NamedEntityGraph(name="includeThis",attributeNodes={@NamedAttributeNode("students")})
public class Department implements Serializable {
  private static final long serialVersionUID = 1L;
  @Id
  @Basic(optional = false)
  private String id;
  private String name;
  private Integer nbrlevel;
  private String phone;    
  @OneToMany(mappedBy = "depart",fetch = FetchType.LAZY)
  private List&lt;Student&gt; students;
  
  /*getter and setter*/
}</pre></div><p>Once defined, we need to retrieve our <a id="id238" class="indexterm"/>named entity graph using the <a id="id239" class="indexterm"/>
<code class="literal">getEntityGraph()</code> method of <code class="literal">EntityManager</code> in order to use it as a property when searching with the find method or as a <span class="strong"><strong>query hint</strong></span><a id="id240" class="indexterm"/> with a query. After executing the following code, you will notice that in the first search, the <a id="id241" class="indexterm"/>
<code class="literal">students</code> attribute will not be loaded while in the second search it will be.</p><p>The following code <a id="id242" class="indexterm"/>is an <a id="id243" class="indexterm"/>example <a id="id244" class="indexterm"/>of using a named entity graph:</p><div class="informalexample"><pre class="programlisting">EntityManager em = emf.createEntityManager();
//create entity manager
PersistenceUnitUtil pUtil = emf.getPersistenceUnitUtil();

Department depart = (Department) em.createQuery("Select e from Department e")
.getResultList().get(0);
System.out.println("students Was loaded ? "+pUtil.isLoaded(depart, "students"));
  
EntityGraph includeThis = em.getEntityGraph("includeThis");
depart = (Department) em.createQuery("Select e from Department e")
.setHint("javax.persistence.fetchgraph", includeThis)
.getResultList().get(0);
System.out.println("students Was loaded ? "+pUtil.isLoaded(depart,"students"));</pre></div></div><div class="section" title="Dynamic entity graphs"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec15"/>Dynamic entity graphs</h4></div></div></div><p>Entity graphs can <a id="id245" class="indexterm"/>also be defined at runtime. To do this, we must use the <code class="literal">createEntityGraph()</code> <a id="id246" class="indexterm"/>method of the entity manager and not <code class="literal">getEntityGraph()</code> as with the <a id="id247" class="indexterm"/>named entity graphs. Once defined, the <span class="strong"><strong>dynamic entity graph</strong></span> is associated with the <a id="id248" class="indexterm"/>
<code class="literal">find()</code> method or a query in the same way as a named entity graph as shown in the following code.</p><p>The following code is an example of using a dynamic entity graph:</p><div class="informalexample"><pre class="programlisting">EntityManager em = emf.createEntityManager();
//create entity manager
PersistenceUnitUtil pUtil = emf.getPersistenceUnitUtil();

Department depart = (Department) em.createQuery("Select e from Department e")
.getResultList().get(0);
System.out.println("students Was loaded ? " + pUtil.isLoaded(depart, "students"));

EntityGraph includeThis = em.createEntityGraph(Department.class);
includeThis.addAttributeNodes("students");

depart = (Department) em.createQuery("Select e from Department e")
.setHint("javax.persistence.fetchgraph", includeThis)
.getResultList().get(0);
System.out.println("students Was loaded ? " +pUtil.isLoaded(depart, "students"));</pre></div></div></div><div class="section" title="JPQL"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec30"/>JPQL</h3></div></div></div><p><span class="strong"><strong>JPQL</strong></span> (<span class="strong"><strong>Java Persistence Query Language</strong></span>) is <a id="id249" class="indexterm"/>an object-oriented SQL-like query language. It is platform <a id="id250" class="indexterm"/>independent and allows you to access your data through entities instead of manipulating the physical structure of your database. The following code demonstrates how to query for all registered students whose ID is greater than 123.</p><p>The following code is an example of a JPQL query:</p><div class="informalexample"><pre class="programlisting">String queryString = "SELECT a FROM Student a WHERE a.id &gt; 123";
Query query = em.createQuery(queryString);
System.out.println("result : "+query.getResultList());</pre></div><p>Despite its power and its vastness, the JPQL continues to receive significant improvements. In JPA 2.1, it has among other enhancements integrated support for stored procedures, added new reserved identifiers, and the support for creation of named queries at runtime.</p><div class="section" title="Support for stored procedures"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec16"/>Support for stored procedures</h4></div></div></div><p>JPA 2.1 now allows you to execute <a id="id251" class="indexterm"/>stored procedures. Through the various API that it offers, you can define and execute named stored procedures or dynamically stored procedures.</p><p>The following script is an example of a <a id="id252" class="indexterm"/>script to create a stored procedure in MySQL:</p><div class="informalexample"><pre class="programlisting">DELIMITER $$
CREATE
  PROCEDURE `ONLINEREGISTRATION`.`getStudentsName`()    
  BEGIN
    SELECT ID,LASTNAME FROM STUDENT ORDER BY LASTNAME ASC;
  END$$
DELIMITER ;</pre></div><p>The following code demonstrates <a id="id253" class="indexterm"/>how to execute the stored procedure <code class="literal">getStudentsName</code> we just created:</p><div class="informalexample"><pre class="programlisting">EntityManagerFactory emf = Persistence.createEntityManagerFactory("chapter04PUM");
EntityManager em = emf.createEntityManager();
//create entity manager
StoredProcedureQuery spQuery = em.createStoredProcedureQuery("getStudentsName",Student.class);
List&lt;Student&gt; results = spQuery.getResultList();
for(Student std : results)
  System.out.println(std.getLastname());</pre></div></div><div class="section" title="New reserved identifiers"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec17"/>New reserved identifiers</h4></div></div></div><p>The JQPL has introduced the following new keywords:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ON</code>: This keyword allows <a id="id254" class="indexterm"/>us to make explicit joins as in SQL with the <code class="literal">ON</code> condition. <a id="id255" class="indexterm"/>Before, joins were made with the liaison attributes between the two entities, which required minimal configuration. The following code demonstrates the use of <code class="literal">ON</code>:<div class="informalexample"><pre class="programlisting">String queryString = "SELECT a FROM Student a "+" JOIN Department b ON a.departId = b.id";
Query query = em.createQuery(queryString);
System.out.println("result : "+query.getResultList());</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">FUNCTION</code>: This keyword <a id="id256" class="indexterm"/>allows you to invoke functions in your queries <a id="id257" class="indexterm"/>other than those originally intended by JPQL (such <code class="literal">SUBSTRING</code>, <code class="literal">LENGTH</code>, <code class="literal">ABS</code>, <code class="literal">TRIM</code>, and so on). With this keyword, you can use a database function or functions that you have defined yourself. The following query gives us the list of students born in July by using the <code class="literal">month()</code> method of <span class="strong"><strong>derby database</strong></span> in order to extract the month from a birth date:<div class="informalexample"><pre class="programlisting">String queryString= "SELECT a FROM Student a "+" WHERE FUNCTION('MONTH',a.birthdate) = 7 ";      
Query query = em.createQuery(queryString);
System.out.println("result : "+query.getResultList());</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">TREAT</code>: This keyword <a id="id258" class="indexterm"/>allows you <a id="id259" class="indexterm"/>to do the <span class="strong"><strong>downcasting</strong></span> of an entity in order to obtain a subclass state. It is used in the <code class="literal">FROM</code> and <code class="literal">WHERE</code> clauses. In the following code, the entity <code class="literal">Appuser</code> inherits from the entity <code class="literal">Person</code>; with the keyword <code class="literal">TREAT</code> we can put conditions on attributes that are not contained in the base entity (<code class="literal">Person</code>).<div class="informalexample"><pre class="programlisting">//Entity downcasting
String queryString = "SELECT  a FROM Person a "+" WHERE TYPE(a) = Appuser AND "+" TREAT(a AS Appuser).userLogin = 'adwiner'";
Query query = em.createQuery(queryString);
System.out.println("result : "+query.getResultList());</pre></div></li></ul></div></div><div class="section" title="Support for creating named queries at runtime"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec18"/>Support for creating named queries at runtime</h4></div></div></div><p>Before JPA 2.1, named queries <a id="id260" class="indexterm"/>were defined statically as metadata before compiling the program. Through the <code class="literal">addNamedQuery</code> method that was added to the <code class="literal">EntityManagerFactory</code> interface, you can now create a named query at runtime as shown in the following code:</p><div class="informalexample"><pre class="programlisting">EntityManagerFactory emf =Persistence.createEntityManagerFactory("chapter04PU");        
EntityManager em = emf.createEntityManager();
  
Query query = em.createQuery("SELECT a FROM Student a");
emf.addNamedQuery("runtimeNamedQuery", query);
  
System.out.println("result :"+em.createNamedQuery("runtimeNamedQuery").getResultList());</pre></div></div></div><div class="section" title="The Criteria API"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec31"/>The Criteria API</h3></div></div></div><p>JPA since Version 2.0 offers two <a id="id261" class="indexterm"/>options for defining queries on entities. The first option is the JPQL which is a query language based on SQL. The second option is the Criteria API where a query is constructed essentially with Java objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">EntityManagerFactory emf =Persistence.createEntityManagerFactory("chapter04PU");
EntityManager em = emf.createEntityManager();
//create entity manager
//criteria builder declaration
CriteriaBuilder cb = em.getCriteriaBuilder();
//declaration of the object that will be returned by the query
CriteriaQuery&lt;Student&gt; cq = cb.createQuery(Student.class);
//Declaration of the entity to which the request is made
Root&lt;Student&gt; student = cq.from(Student.class);
//Query construction
cq.select(student).where(cb.greaterThan(student.&lt;String&gt;get("id"), "123"));
TypedQuery&lt;Student&gt; tq = em.createQuery(cq);
//execution of the query
System.out.println("result : "+tq.getResultList());

//JPQL equivalent query
SELECT a FROM Student a WHERE a.id &gt; 123</pre></div><p>Given that the two solutions do not <a id="id262" class="indexterm"/>evolve at the same rate, the major changes in the Criteria API are support for bulk update/delete and new reserved identifiers.</p><div class="section" title="Support for bulk update/delete"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec19"/>Support for bulk update/delete</h4></div></div></div><p>The bulk update and delete <a id="id263" class="indexterm"/>in the Criteria API are respectively constructed with <code class="literal">javax.persistence.criteria.CriteriaUpdate</code> and <code class="literal">javax.persistence.criteria.CriteriaDelete</code> interfaces. The following code demonstrates how to update a lot of information with just one Criteria API request:</p><div class="informalexample"><pre class="programlisting">//bulk update
CriteriaUpdate cUpdate = cb.createCriteriaUpdate(Student.class);
Root root = cUpdate.from(Student.class);
cUpdate.set(root.get("departId"), "GT").where(cb.equal(root.get("departId"), "GI"));          
Query q = em.createQuery(cUpdate);
  
em.getTransaction().begin();//begin transaction
int num = q.executeUpdate();
em.getTransaction().commit();//commit transaction
System.out.println("number of update : "+num);
//JPQL equivalent query
UPDATE Student a SET a.departId = 'GT' WHERE a.departId = 'GI'</pre></div></div><div class="section" title="Support for new reserved identifiers"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec20"/>Support for new reserved identifiers</h4></div></div></div><p>Just like the JPQL, the Criteria API <a id="id264" class="indexterm"/>incorporates the possibility of making downcasts and defines joins using <code class="literal">ON</code> conditions. To do that, <a id="id265" class="indexterm"/>overloaded <a id="id266" class="indexterm"/>
<code class="literal">treat()</code> methods have been added to the <code class="literal">javax.persistence.criteria.CriteriaBuilder</code> interface for downcasting, while <a id="id267" class="indexterm"/>
<code class="literal">on()</code> and <a id="id268" class="indexterm"/>
<code class="literal">getOn()</code> methods have been added to some interfaces (such as <code class="literal">Join</code>, <code class="literal">ListJoin</code>, <code class="literal">SetJoin</code>, <code class="literal">MapJoin</code>, <code class="literal">CollectionJoin</code>,and <code class="literal">Fetch</code>) of the <code class="literal">javax.persistence.criteria</code> package for joins with <code class="literal">ON</code> conditions. The following query is equivalent to the JPQL downcasting shown in the preceding code:</p><div class="informalexample"><pre class="programlisting">//Downcasting
CriteriaQuery&lt;Person&gt; cqp = cb.createQuery(Person.class);
Root&lt;Person&gt; person = cqp.from(Person.class);
cqp.select(person).where(cb.equal(person.type(),Appuser.class),cb.equal(cb.treat(person, Appuser.class).get("userLogin"),"adwiner"));
TypedQuery&lt;Person&gt; tqp = em.createQuery(cqp);
System.out.println("result : " + tqp.getResultList());</pre></div></div></div><div class="section" title="DDL generation"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec32"/>DDL generation</h3></div></div></div><p>Since the previous version of the JPA Specification, it is possible to create or drop and create tables. However, the support for this feature was not required and the specification document made us understand that <a id="id269" class="indexterm"/>the use of this feature could reduce application portability. Well, with JPA 2.1, the <span class="strong"><strong>DDL</strong></span> (<span class="strong"><strong>Data Definition Language</strong></span>) <a id="id270" class="indexterm"/>generation was not only standardized but has been expanded and is now required.</p><p>In this case, new properties have been added. You have for example the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">javax.persistence.schema-generation.database.action</code>: This defines the action (none, create, drop-and-<a id="id271" class="indexterm"/>create, or drop) that should be taken by the provider.</li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.persistence.schema-generation.create-source</code>: This defines the source (entities, specific scripts, <a id="id272" class="indexterm"/>or both) to be used by the provider in the case of a DDL generation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.persistence.schema-generation.drop-source</code>: This defines the source (entities, specific <a id="id273" class="indexterm"/>scripts, or both) to be used by the provider in the case of drop table.</li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.persistence.schema-generation.connection</code>: This defines the <span class="strong"><strong>JDBC</strong></span> connection parameters to <a id="id274" class="indexterm"/>use for the DDL schema generation in order to take into account the management of privileges in some databases such as Oracle. This parameter was thought of for Java EE environments.</li></ul></div><p>The following persistence unit provides an example of configuration to generate tables at the creation of <code class="literal">EntityManagerFactory</code>. <a id="id275" class="indexterm"/>This generation will be based on entities' information (metadata) and it will take place if and only if the tables to be created do not exist, because we defined create instead of drop-and-create for the action of the provider.</p><div class="informalexample"><pre class="programlisting">&lt;persistence-unit name="chapter04PUM" transaction-type="RESOURCE_LOCAL"&gt;
  &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
  &lt;class&gt;com.packt.ch04.entities.Department&lt;/class&gt;
  &lt;class&gt;com.packt.ch04.entities.Person&lt;/class&gt;
  &lt;class&gt;com.packt.ch04.entities.Student&lt;/class&gt;
  &lt;properties&gt;
    &lt;property name="javax.persistence.jdbc.url"value="jdbc:mysql://localhost:3306/onlineregistration"/&gt;
    &lt;property name="javax.persistence.jdbc.password"value="onlineapp"/&gt;
    &lt;property name="javax.persistence.jdbc.driver"value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="javax.persistence.jdbc.user" value="root"/&gt;
    &lt;property name="javax.persistence.schema-generation.database.action" value="create"/&gt;
    &lt;property name="javax.persistence.schema-generation.create-source" value="metadata"/&gt;      
  &lt;/properties&gt;
&lt;/persistence-unit&gt;</pre></div><p>Another aspect of this standardization is the addition of a new method (<code class="literal">Persistence.generateSchema()</code>), which provides more opportunity for the generation. Before (in JPA 2.0), the DDL generation was done at the creation of the entity manager. Henceforth, you can generate your tables before, during, or after the creation of the <code class="literal">EntityManagerFactory</code>.</p><p>The following code demonstrates how to <a id="id276" class="indexterm"/>generate tables regardless of the creation of the <code class="literal">EntityManagerFactory</code>:</p><div class="informalexample"><pre class="programlisting">Map props = new HashMap();
props.put("javax.persistence.schema-generation.database.action", "create");
props.put("javax.persistence.schema-generation.create-source", "metadata");
Persistence.generateSchema("chapter04PUM", props);</pre></div><p>The following code demonstrates <a id="id277" class="indexterm"/>another way to generate the tables at the creation of the <code class="literal">EntityManagerFactory</code>:</p><div class="informalexample"><pre class="programlisting">Map props = new HashMap();
props.put("javax.persistence.schema-generation.database.action", "create");
props.put("javax.persistence.schema-generation.create-source", "metadata");
EntityManagerFactory emf = Persistence.createEntityManagerFactory("chapter04PUM", props);</pre></div></div></div></div></div>
<div class="section" title="Java Transaction API 1.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Java Transaction API 1.2</h1></div></div></div><p>The Java Transaction API 1.2 <a id="id278" class="indexterm"/>Specification was developed under JSR 907. This section just gives you an overview of improvement in the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html">http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html</a>.</p><div class="section" title="The Java Transaction API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>The Java Transaction API</h2></div></div></div><p>The <span class="strong"><strong>Java Transaction API</strong></span> (<span class="strong"><strong>JTA</strong></span>) is a <a id="id279" class="indexterm"/>standard Java API for managing transactions on one or more resources (distributed transactions) in server environments. It consist of three main APIs: <code class="literal">javax.transaction.UserTransaction</code> interface used by applications for explicit transaction demarcation, <code class="literal">javax.transaction.TransactionManager</code> interface used by application servers to demarcate transactions implicitly on behalf of the application, and <code class="literal">javax.transaction.xa.XAResource</code>, which is a Java mapping of the standard XA interface for distributed transaction processing.</p></div><div class="section" title="JTA in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>JTA in action</h2></div></div></div><p>As we said, JTA transactions are used in <a id="id280" class="indexterm"/>Java EE environments. In order to enable this transaction type, the <code class="literal">transaction-type</code> attribute of the persistence unit should be set to <code class="literal">JTA</code> instead of <code class="literal">RESOURCE_LOCAL</code> and the data source (if there is one), should be defined within the <code class="literal">&lt;jta-datasource&gt;</code> element. The following code gives an example of a persistence unit to manage transactions using JTA:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.1" 
   
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence 
  http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"&gt;
  
  &lt;persistence-unit name="chapter04PU" transaction-type="JTA"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;jta-data-source&gt;onlineRegDataSource&lt;/jta-data-source&gt;
  &lt;/persistence-unit&gt;
  
&lt;/persistence&gt;</pre></div><p>After declaring a <code class="literal">JTA</code> transaction type persistence unit, the developer can either leave the transaction management to the server (by default, the container considers a method as a transaction) or take control and define the transaction boundaries programmatically.</p><p>The following code is an example of a <a id="id281" class="indexterm"/>container-managed transaction:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class StudentServiceCMT {

  @PersistenceContext
  EntityManager em;  
  
  public void createStudent(){
    Student student = new Student();
    student.setBirthdate(new Date());
    student.setDepartid("GI");
    student.setId(""+ new Date().getTime());
    student.setFirstname("CMT - FIRST NAME");
    student.setLastname("CMT - Last name");
    
    em.persist(student);
  }
}</pre></div><p>The following code is an example of bean-managed transaction:</p><div class="informalexample"><pre class="programlisting">@Stateless
@TransactionManagement(TransactionManagementType.BEAN)
public class StudentServiceBMT {

  @PersistenceContext
  EntityManager em;
  
  @Resource
  UserTransaction userTx;
  
  public void createStudent() throws Exception {
    try {
      userTx.begin();//begin transaction
      
      Student student = new Student();
      student.setBirthdate(new Date());
      student.setDepartid("GI");
      student.setId(""+ new Date().getTime());
      student.setFirstname("BMT - FIRST NAME");
      student.setLastname("BMT - Last name");
      
      em.persist(student);
      
      userTx.commit(); // commit transaction
      } catch (Exception ex) {
      userTx.rollback();//rollback transaction
      throw ex;
    } 
  }
}</pre></div></div><div class="section" title="Innovations introduced by JTA 1.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Innovations introduced by JTA 1.2</h2></div></div></div><p>Unlike the JPA Specification, JTA has <a id="id282" class="indexterm"/>known only a few improvements that can be summarized in the following lines. First we have the addition of two new annotations. The first is <code class="literal">javax.transaction.Transactional</code>, which provides the possibility to demarcate <a id="id283" class="indexterm"/>transactions declaratively on CDI-managed beans or classes defined as managed beans by the Java EE Specification. The second annotation added is the <code class="literal">javax.transaction.TransactionScoped</code> annotation, which provides the possibility to define beans whose lifecycle is <a id="id284" class="indexterm"/>identical with the current transaction. The JTA API also added one exception class <code class="literal">javax.transaction.TransactionalException</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter we have, with examples, presented and analyzed the improvements provided by two APIs whose major objective is to facilitate interaction with your data base. The first presented was JPA API, which gives you the ability to create, read, update, and delete data from a database by using Java objects. The second was JTA API, which is an API designed for transparent management of transactions in one or more data sources.</p><p>In the next chapter, we'll talk about <span class="strong"><strong>EJB</strong></span>s and we will make a small example, which will consist of putting together most of the APIs that we have studied.</p></div></body></html>