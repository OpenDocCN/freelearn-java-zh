- en: Chapter 1. Basics of Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Play Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Play application using Typesafe Activator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Play console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with controllers and routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Action parameters in controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reverse routing and redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with View templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using helper tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using View layouts and Includes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with XML and text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ebean (Java) with MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Anorm (Scala) and database evolutions with MYSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a form template and web actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing form submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with JUnit (Java) and specs2 (Scala)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play is a developer-friendly and modern web application framework for both Java
    and Scala. This first chapter will take you through the steps in installing Play
    Framework for local development. This chapter will describe the Play application
    project directory structure, its various members and its function in a Play application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also introduce you to the `Activator` command, which replaces
    the old Play command. Activator is used for various stages during development,
    including compilation, downloading library dependencies, testing, and building.
    It is really quite similar to other build tools such as Ant or Maven.
  prefs: []
  type: TYPE_NORMAL
- en: This first chapter will also go about implementing **Model-View-Controller**
    (**MVC**) components available in Play Framework. This will be followed by source
    code to create controllers and routing actions using View templates and model
    components used to interface with an RDBMS (such as MySQL). This chapter will
    tackle basic HTTP forms, recognizing the importance of modern web applications
    being able to deal with user interactivity and data and how Play Framework provides
    various APIs to make life easier for developers.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have a good grasp of how to implement
    basic web application functionalities such as form submissions and data access
    with MySQL, create URL routes to web actions, and create views composed of smaller,
    modular, and reusable view components.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the recipes in this chapter assume that you have a level of familiarity
    with Java development, web application development, command-line interfaces, **Structured
    Query Language** (**SQL**), development build tools, third-party library usage,
    dependency management, and unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will guide you through installing Play Framework 2.3 for local development.
    This section will guide you on the prerequisite installations for Play Framework,
    such as the **Java Development Kit** (**JDK**), and the necessary steps to ensure
    that Play Framework has access to the JDK's binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Play Framework requires a JDK version of 6 or above. Head over to the Oracle
    website and download the appropriate JDK for your development machine at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded a suitable JDK, ensure that the binary folder is added
    to the system path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can also refer to Oracle's online documentation for more information regarding
    setting environment variables at [http://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/index.html](http://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can verify that the JDK is now accessible in the system path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of Play 2.3.x, Play is now distributed using a tool called Typesafe Activator
    ([http://typesafe.com/activator](http://typesafe.com/activator)), install it using
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the *Typesafe Reactive Platform* distribution at [https://typesafe.com/platform/getstarted](https://typesafe.com/platform/getstarted)
    and unzip it at your desired location that has write access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After downloading and unzipping the distribution, add the `Activator` installation
    directory to your system path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, verify that Activator is now accessible in the system path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now be able to create a Play application using the `activator` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a Play application using Typesafe Activator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a JDK and Activator installed and properly configured, you should
    be ready to create Play 2.3.x applications. Beginning with Play 2.0, developers
    are now able to create Java- or Scala-based Play applications. Activator provides
    many Play project templates for both Java and Scala. For the first project, let
    us use the basic project templates. We will also be using the command-line interface
    of Activator across all recipes in this cookbook.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following for creating the templates for both Java
    and Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java, let''s use the `play-java` template and call our first application
    `foo_java` by using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, let''s use the `play-scala` template and call our first application
    `foo_scala` by using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `Activator` command creates the project''s root directory (`foo_java`
    or `foo_scala`) and creates all the relevant subdirectories, config files, and
    class files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the root directory for `foo_java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/qUbtEvvV.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the root directory for `foo_scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Tbg8FVM3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you notice, both the Java and Scala project template generated an almost
    identical list of files, except for class files that are generated as `.java`
    files for the *play_java* template and as`.scala` files for the *play_scala* template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the project''s directory structure, one of the more important aspects of
    Play Framework is its adherence to the concept of convention over configuration.
    This is best reflected by the standard project directory structure of every Play
    application it follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1st Level
  prefs: []
  type: TYPE_NORMAL
- en: 2nd Level
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Level
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: '`app/`'
  prefs: []
  type: TYPE_NORMAL
- en: Application source files
  prefs: []
  type: TYPE_NORMAL
- en: '`assets`/'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled JavaScript or style sheets
  prefs: []
  type: TYPE_NORMAL
- en: '`stylesheets`/'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled style sheet (such as LESS or SASS)
  prefs: []
  type: TYPE_NORMAL
- en: '`javascripts`/'
  prefs: []
  type: TYPE_NORMAL
- en: Compiled JavaScript (such as CoffeeScript)
  prefs: []
  type: TYPE_NORMAL
- en: '`controllers`/'
  prefs: []
  type: TYPE_NORMAL
- en: Application request-response controllers
  prefs: []
  type: TYPE_NORMAL
- en: '`models`/'
  prefs: []
  type: TYPE_NORMAL
- en: Application domain objects
  prefs: []
  type: TYPE_NORMAL
- en: '`views`/'
  prefs: []
  type: TYPE_NORMAL
- en: Application presentation views
  prefs: []
  type: TYPE_NORMAL
- en: '`conf/`'
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration files
  prefs: []
  type: TYPE_NORMAL
- en: '`public`/'
  prefs: []
  type: TYPE_NORMAL
- en: Publicly available assets
  prefs: []
  type: TYPE_NORMAL
- en: '`stylesheets`/'
  prefs: []
  type: TYPE_NORMAL
- en: Publicly available style sheet files
  prefs: []
  type: TYPE_NORMAL
- en: '`javascripts`/'
  prefs: []
  type: TYPE_NORMAL
- en: Publicly available JavaScript files
  prefs: []
  type: TYPE_NORMAL
- en: '`project`/'
  prefs: []
  type: TYPE_NORMAL
- en: Build configuration files (such as `Build.scala` and `plugins.sbt)`
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`/'
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged libraries and packages
  prefs: []
  type: TYPE_NORMAL
- en: '`logs`/'
  prefs: []
  type: TYPE_NORMAL
- en: Log files
  prefs: []
  type: TYPE_NORMAL
- en: '`test`/'
  prefs: []
  type: TYPE_NORMAL
- en: Test source files
  prefs: []
  type: TYPE_NORMAL
- en: Source code, configuration files, and web assets are organized in a predefined
    directory structure, making it easy for the developer to navigate through the
    project directory tree and find relevant files in logical placements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to [http://typesafe.com/activator/templates](http://typesafe.com/activator/templates)
    for a comprehensive list of available project templates.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Play console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play console is a command-line interface tool used to build and run Play
    applications. It is important for every developer to be familiar with the available
    commands, such as `clean`, `compile`, `dependencies`, and `run`, to fully utilize
    the power of the Play console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following to use the Play console for both Java and
    Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: After Activator finishes setting up the Play project, you can enter the Play
    console of your Play application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Java:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command for Scala:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you have entered the Play console, you can run your application in the
    development mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Java:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command for Scala:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, open a web browser and head over to `http://localhost:9000`:![](img/OgbeLjyc.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command line to start your Play application with Hot-Reloading
    enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command line to start your Play application on a different
    port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running your application in development mode configures your application to
    run in auto-reload, where Play will attempt to recompile any recent changes to
    the project files, removing the need to manually restart your application for
    every code edit. You are now ready to view your application using your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use the Play console to manually compile class files using the
    `compile` command in the activator console (use the `activator` command):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command for Java:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command for Scala:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also run Play commands directly instead of using the Play console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command for Java:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command for Scala:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following command to generate an eclipse project file for your existing
    Play application using `Activator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to generate an IntelliJ IDEA project file for your
    existing Play application using `Activator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Working with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can utilize other Play Framework or third-party modules in your Play application.
    This is easily done by editing the build file (`build.sbt`) and declaring library
    dependencies in the style of `sbt` dependency declaration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to declare a module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `build.sbt` file and add the following lines, using the notation of
    the group ID `%` module name `%` version while declaring library dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the changes to `build.sbt` have been saved, head over to the command line
    and have Activator download the newly declared dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we declare what our Play application will need and reference
    the **Java Database Connectivity** (**JDBC**) module provided by Play Framework
    and the MySQL Java Connector module provided by MySQL. Once we have our modules
    declared, we can run the activator dependencies command to make Activator download
    all declared dependencies from the public Maven repositories and store them in
    the local development machine.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the Play Framework website for a complete list of official Play
    modules ([https://www.playframework.com/documentation/2.3.x/Modules](https://www.playframework.com/documentation/2.3.x/Modules)).
    You can also refer to the Typesafe official release repository for other useful
    plugins and modules at your disposal ([http://repo.typesafe.com/typesafe/releases/](http://repo.typesafe.com/typesafe/releases/)).
  prefs: []
  type: TYPE_NORMAL
- en: Working with controllers and routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play applications use controllers to handle HTTP requests and responses. Play
    controllers are composed of actions that have specific functionality. Play applications
    use a router to map HTTP requests to controller actions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new page, which prints out "Hello World" for a Play Java project,
    we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/app/controllers/Application.java` by adding the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new hello page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new hello page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we enumerated the steps necessary to create a new accessible
    page by creating a new web action in a controller and defined this new page's
    URL route by adding a new entry to the `conf/routes` file. We should now have
    a "Hello World" page, and all without having to reload the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Action parameters in controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications should be able to accept dynamic data as part of their canonical
    URL. An example of this is `GET` operations of RESTful API web services. Play
    makes it easy for developers to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `foo_java/app/controllers/Application.java` by adding the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new echo page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to see the text **Echoing foo**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new echo page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to see the text **Echoing bar**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we made edits to just two files, the application controller,
    `Application.java` and `Application.scala`, and `routes`. We added a new web action,
    which takes in a String argument `msg` in `Application.scala` and returns the
    contents of the message to the HTTP response. We then add a new entry in the `routes`
    file that declares a new URL route and declares the `:msg` route parameter as
    part of the canonical URL.
  prefs: []
  type: TYPE_NORMAL
- en: Using reverse routing and redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more essential tasks for a web application is to be able to redirect
    HTTP requests, and redirecting HTTP with Play Framework is quite straightforward.
    This recipe shows how developers can use reverse routing to refer to defined routes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `foo_java/app/controllers/Application.java` by adding the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new echo page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to see the text **Echoing HelloWorldv2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the URL in the web browser has also redirected to `http://localhost:9000/echo/HelloWorldv2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new echo page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to see the text **Echoing HelloWorldv2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the URL in the web browser has also redirected to `http://localhost:9000/echo/HelloWorldv2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we utilized reverse routes while referring to existing routes
    inside other action methods. This is handy, as we will not need to hard code rendered
    URL routes from within other action methods. We also utilized our first HTTP redirect,
    a very common web application function, by which we were able to issue a 302 HTTP
    redirect, a standard HTTP status code handled by all standard web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with View templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You expect to be able to send some data back to the View itself in web applications;
    this is quite straightforward with Play Framework. A Play View template is simply
    a text file that contains directives, web markup tags, and template tags. The
    `View Template` files also follow standard naming conventions and they are placed
    in predefined directories within the Play project directory, which makes it easier
    to manage template files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the view file `products.scala.html` in `foo_java/app/views/`. Add the
    contents of the view file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/app/controllers/Application.java` by adding the following action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the products page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the view file `products.scala.html` in `foo_scala/app/views/`. Add the
    contents of the view file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the products page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we were able to retrieve a collection of data from the server
    side and display the contents of the collection in our View template. For now,
    we use a static collection of String objects to display in the View template instead
    of retrieving some data set from a database, which we will tackle in the upcoming
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced declaring parameters in View templates by declaring them in the
    first line of code in our view template and passing data into our View templates
    from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Using helper tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View tags allow developers to create reusable view functions and components
    and make the management of views a lot simpler and easier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the tag file `productsIterator.scala.html` in `foo_java/app/views/tags`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the contents of the tag file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/app/views/products.scala.html` by adding the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the products page using a web browser to see the new product listing,
    using an unordered list HTML tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the tag file `productsIterator.scala.html` in `foo_scala/app/views/tags`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add contents of the tag file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/app/views/products.scala.html` by adding the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the products page using a web browser to see the new products listing,
    using an unordered list HTML tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we were able to create a new view tag in `app/views/tags`. We
    proceeded to use this tag in our View template.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created a new tag that receives a collection of product titles, from
    which it is then displayed in the template as an unordered list. We then imported
    the tag in our products View template and invoked the helper function by calling
    it using its filename (`@productsIterator(products)`).
  prefs: []
  type: TYPE_NORMAL
- en: Using View layouts and Includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will create a main layout View template that will include
    a defined header and footer view. This will allow our View template to inherit
    a consistent look and feel by including this main View template and manage all
    UI changes in a single file. Our Products view will utilize the main layout view
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the main layout view file `mainLayout.scala.html` in `foo_java/app/views/common`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the contents of the main layout view file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the header view file `header.scala.html` in `foo_java/app/views/common`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the footer view file `footer.scala.html` in `foo_java/app/views/common`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the products view file `foo_java/app/views/products.scala.html` to use
    the main layout View template by replacing all the file contents with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the updated products page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the main layout view file `mainLayout.scala.html` in `foo_scala/app/views/common`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the contents of the main layout view file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the header view file `header.scala.html` in `foo_scala/app/views/common`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the footer view file `footer.scala.html` in `foo_scala/app/views/common`
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the products view file `foo_scala/app/views/products.scala.html` to use
    the main layout view template by replacing all the file contents with following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the updated products page using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a main layout view template that can be reused throughout
    the Play application. A common layout view removes the need to duplicate the view
    logic in related views and makes it a lot easier to manage parent views and child
    views.
  prefs: []
  type: TYPE_NORMAL
- en: Working with XML and text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using View templates, we are also able to respond to HTTP requests in other
    content types such as text files and XML data formats. Play Framework has native
    handlers for XML and text file content type responses.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the text-based view template file `products.scala.txt` in `app/views/`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the XML-based view template file `products.scala.xml` in `app/views/`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/app/controllers/Application.java` by adding the following actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the new routes and actions using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:9000/products.txt` and,'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:9000/products.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the text-based view template file `products.scala.txt` in `app/views/`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the XML-based view template file `products.scala.xml` in `app/views/`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/app/controllers/Application.scala` by adding the following
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the new routes and actions using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:9000/products.txt` and'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:9000/products.xml`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we utilized build-in support for other content types in Play
    Framework. We created new URL routes and web actions to be able to respond to
    requests for data in XML or text file formats. By following file naming standards
    and convention for views, we were able to create view templates in HTML, XML,
    and text file formats, which Play automatically handles, and then adds the appropriate
    content type headers in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ebean (Java) with MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play Framework 2.x includes an object-relational mapping tool called **Ebean**
    for Java-based Play applications. To be able to use Ebean, ensure that Ebean and
    a suitable MySQL driver are declared as project dependencies in `foo_java/build.sbt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will be utilizing Ebean with database evolutions. Play
    Framework 2.x gives developers a way to manage database migrations. Database migrations
    are useful for tracking schema changes during the course of application development.
    Database evolutions are enabled by default but can be disabled in `conf/application.conf`
    with the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Evolution scripts are stored in the `conf/evolutions/default/` directory. For
    more information regarding database evolutions, please refer to Play's online
    documentation at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.playframework.com/documentation/2.3.x/Evolutions](https://www.playframework.com/documentation/2.3.x/Evolutions).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to utilize Ebean:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Ebean dependency in `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that Ebean and MySQL are configured properly in `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next recipes, we need to create our product table in our MySQL database.
    Create our first database evolution file `1.sql` in `conf/evolutions/default`
    and add the following SQL statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create the Ebean model for our entity `Product`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following displays various database-oriented operations using Ebean.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will create a new record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Updating a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will update a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Querying a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will query a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will retrieve a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Using Anorm (Scala) and database evolutions with MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play Framework 2.x includes Anorm, a useful data access library for Scala-based
    Play applications. To be able to use Anorm, ensure that Anorm and a suitable MySQL
    driver are declared as project dependencies in `foo_scala/build.sbt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will be utilizing Anorm with database evolutions. Play
    Framework 2.x gives developers a way to manage database migrations. Database migrations
    are useful for tracking schema changes during the course of application development.
    Database evolutions are enabled by default but can be disabled in `conf/application.conf`
    using the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Evolution scripts are stored in the `conf/evolutions/default/` directory. For
    more information regarding database evolutions, please refer to Play's online
    documentation at [https://www.playframework.com/documentation/2.3.x/Evolutions](https://www.playframework.com/documentation/2.3.x/Evolutions).
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to perform the following steps to utilize Anorm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Anorm dependency to `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that Anorm and MySQL are configured properly in `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next recipes, we need to create our products table in our MySQL database.
    Create our first database evolution file `1.sql` in `conf/evolutions/default`
    and add the following SQL statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following sections display various database-oriented operations using `Anorm`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will create a new record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Updating a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will update a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet will delete a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet will query a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet will retrieve a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can combine all of these functions in a companion object called
    Product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Using a form template and web action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the majority of web applications, there will always be a need to accept
    an HTTP form, be it a registration form or a login form. Play Framework provides
    helper classes to manage and process HTTP form submissions. In this recipe, we
    will go over the steps to create a simple form and map the web action assigned
    to handle this form submission. We will also utilize the flash scope, which allows
    us to use the flash object to send messages from the controller to the view template
    on a per-request basis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_java` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the form view template file `app/views/product/form.scala.html` and
    add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the products controller `foo_java/app/controllers/Products.java` and
    add the following import, action, and Play form blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_java/conf/routes` by adding the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new product form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fill in a name for your new product and hit **submit**. You should now receive
    the success message:![](img/z7nu00LC.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the form view template file `app/views/product/form.scala.html` and
    add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the products controller `foo_scala/app/controllers/Products.scala` and
    add the following import, action, and Play form blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `foo_scala/conf/routes` by adding the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View your new Product form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fill in a name for your new product and click on **submit**. You should now
    receive the following success message:![](img/W1P99Ysq.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we were able to create our first HTTP form using Play Framework.
    This recipe included steps in creating an HTML form view template and our Products
    controller. We declared two web actions and two URL routes and created the Play
    form object, which we used to bind request parameters to our model, Fruit. We
    were able to load the web form by accessing `http://localhost:9000/Products/new`
    on a web browser. After filling out our form details, we submitted the form itself
    and received a notification from the Products controller.
  prefs: []
  type: TYPE_NORMAL
- en: Using form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play Framework provides an easy way to validate form submissions. For Play Java,
    we will add the validation to the model, which will check for a submitted field's
    length and return an error message if the validate condition is not satisfied.
    For Play Scala, we will add the form validation to the form object itself and
    define the validation parameters for each form field there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the Product model, `foo_java/app/models/Product.java` and add the `validate()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the Product form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The product form should now accept only product names with a minimum of three
    characters and a maximum of 100, as shown in the following screenshot:![](img/JI0IYz2L.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the products controller `foo_scala/app/controllers/Products.scala` and
    modify how the form is declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the Products form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The product form should now accept only fruit names with a minimum of three
    characters and a maximum of 100, as shown in the following screenshot:![](img/dQy6FzHw.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added data validations for product name and the acceptable
    length submitted by users. For Java, we added a `validate()` method in the product
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Our Java model can be validated by using JSR-303 JavaBean validation annotations
    and by defining a `validate()` method that Play invokes if it is present in the
    model class.
  prefs: []
  type: TYPE_NORMAL
- en: For Scala, we added data validation directives to the `Form` object in the controller.
    We used Play form helpers to define the minimum and maximum character count for
    the name property of the product.
  prefs: []
  type: TYPE_NORMAL
- en: Securing form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play Framework has a CSRF filter module that developers can use to validate
    CSRF tokens during HTTP form submissions. This allows developers to be sure that
    the form was submitted with a valid session token and not tampered with in any
    way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Play filters module as a project dependency to `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Global.java` object file in the `app/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `Global.java` object in `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the template declaration by adding an implicit request object for the
    product form file `app/views/product/form.scala.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the CSRF token helper tag to the product form file `app/views/product/form.scala.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the product form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The product form should now contain a Play-generated CSRF token and should use
    this to validate form submissions, as shown in the following screenshot:![](img/mkHuCatJ.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Play filters module as a project dependency to `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Global.scala` object file in the `app/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `Global.scala` object in `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Play global CSRF filter by modifying the object declaration in `app/Global.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the template declaration by adding an implicit request object for the
    Product form file `app/views/product/form.scala.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the CSRF token helper tag to the product form file `app/views/product/form.scala.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reload the product form using a web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The product form should now contain a Play-generated CSRF token and should use
    this to validate form submissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added the Play Framework filters module, which includes CSRF
    helpers. We added global CSRF support by declaring the `CSRFFilter` in the Play
    application global settings class, `app/Global.java` and `app/Global.scala`. The
    last step was to insert a CSRF token helper tag in our tag that the filter uses
    to validate form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying or tampering with a valid CSRF token will now result in an error
    and will be rejected by Play, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bnb5nrda.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing with JUnit (Java) and specs2 (Scala)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite important for a web framework to integrate testing as seamlessly
    as possible with the web framework itself. This minimizes the friction developers
    encounter when coding functional specs and writing tests to validate their work.
    For Play Java projects, we will be utilizing the popular test framework JUnit.
    We will be using it to do a simple unit test and to test our model and controller
    action. For Play Scala projects, we will be using specs2 to do a simple unit test
    and to test our model, a controller action, and a route mapping.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new spec class, `ProductTest.java`, in `test/` and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the first spec using Activator by running the command `test-only ProductTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Spec class, `ProductSpec.scala`, in `test/` and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the first spec using Activator by running the command `test-only ProductSpec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a brand new spec file that will contain our test
    specifications. We placed this file inside the `test/` directory and ran the test
    using `activator` with the `test-only` command. The `test` command is used to
    run the test and it displays the results of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipe focuses on writing a test for our model objects. We will
    create a new record and add assertions to validate the object's creation. We will
    then use the `Activator` command to run our test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `ProductTest.java` file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the new spec by running the command `test-only ProductTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `ProductSpec.scala` file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the new spec by running the command `test-only ProductSpec`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we added a new spec, where we created a new product and invoked
    the `save()` method. We then added assertion statements to validate that the value
    returned by the `save()` method is not equal to none. The `test` command is used
    to run the test and displays the results of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipe focuses on writing a test for our controller objects. We
    will use a `FakeApplication` to create a mock HTTP request to the Product XML
    listing page and add assertions to validate that the response we receive is indeed
    an XML representing all of the products in our database. We will then use the
    `Activator` command to run our test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `ProductTest.java` file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the new spec by running the command `test-only ProductTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the Product`Spec.scala` file and add the following spec code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the new spec by running the `test-only ProductSpec` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a new spec to test a URL route we created earlier.
    Then, we validated the `/products.xml` URL route by making sure that the response
    content type is `application/xml` and that it contains our root element products.
    The `test` command is used to run the test and it displays the results of the
    test.
  prefs: []
  type: TYPE_NORMAL
