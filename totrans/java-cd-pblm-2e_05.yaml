- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Arrays, Collections, and Data Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、集合和数据结构
- en: This chapter includes 24 problems covering three main topics. We start with
    several problems related to the new Vector API dedicated to parallel data processing.
    We continue with several data structures, including Rope, Skip List, K-D Tree,
    Zipper, Binomial Heap, Fibonacci Heap, Pairing Heap, Huffman Coding, and so on.
    Finally, we discuss the three most popular join algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括涵盖三个主要主题的24个问题。我们首先讨论与专门用于并行数据处理的新的Vector API相关的一些问题。然后，我们继续讨论包括Rope、Skip
    List、K-D Tree、Zipper、Binomial Heap、Fibonacci Heap、Pairing Heap、Huffman编码等在内的几个数据结构。最后，我们讨论三种最流行的连接算法。
- en: At the end of this chapter, you’ll know how to write code for exploiting data
    parallel processing, exploiting a bunch of cool and lesser-known data structures,
    and how join operations work. And, as a bonus, you’ll be familiar with the JDK
    21 Sequenced Collections API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解如何编写利用数据并行处理的代码，了解一些酷且不太为人所知的数据结构，以及连接操作是如何工作的。此外，作为额外奖励，你将熟悉JDK
    21 Sequenced Collections API。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess on Java arrays,
    collections, and data structures. I strongly encourage you to give each problem
    a try before you turn to the solutions and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java数组、集合和数据结构方面的编程能力。我强烈建议你在查看解决方案并下载示例程序之前，尝试解决每个问题：
- en: '**Introducing parallel computations with arrays**: Explain in a few paragraphs
    what data parallel processing is and how it works.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过数组介绍并行计算**：用几段话解释数据并行处理是什么以及它是如何工作的。'
- en: '**Covering the Vector API’s structure and terminology**: Explain with examples
    the Vector API terminology. Cover notions such as element type, shape, species,
    lanes, and so on.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍向量API的结构和术语**：通过示例解释向量API的术语。涵盖诸如元素类型、形状、种类、通道等概念。'
- en: '**Summing two arrays via the Vector API**: Write an application that uses the
    Vector API for summing up two Java arrays.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过向量API求两个数组的和**：编写一个使用向量API对两个Java数组求和的应用程序。'
- en: '**Summing two arrays unrolled via the Vector API**: Write an application that
    uses the Vector API for summing two Java arrays using the *unrolled* technique.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过向量API展开求两个数组的和**：编写一个使用向量API通过*展开*技术对两个Java数组求和的应用程序。'
- en: '**Benchmarking the Vector API**: Given two arrays, `x[]` and `y[]`, write an
    application that benchmarks the computation `z[] = x[] + y[]`, `w[] = x[] * z[]
    * y[]`, `k[] = z[] + w[] * y[]` using plain Java and the Vector API.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基准测试向量API**：给定两个数组`x[]`和`y[]`，编写一个应用程序，使用纯Java和向量API来基准测试计算`z[] = x[] + y[]`、`w[]
    = x[] * z[] * y[]`、`k[] = z[] + w[] * y[]`。'
- en: '**Applying the Vector API to compute FMA**: Provide a Vector API implementation
    of the famous Fused Multiply Add (FMA).'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将向量API应用于计算FMA**：提供一个著名的融合乘加（Fused Multiply Add，FMA）的向量API实现。'
- en: '**Multiplying matrices via the Vector API**: Write a Vector API implementation
    for multiplying two matrices.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过向量API乘矩阵**：编写一个用于乘两个矩阵的向量API实现。'
- en: '**Hooking the image negative filter with the Vector API**: Write a program
    that uses the Vector API to apply the negative filter to an image.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用向量API钩接图像负过滤器**：编写一个使用向量API将负过滤器应用于图像的程序。'
- en: '**Dissecting factory methods for collections**: Exemplify several approaches
    for creating unmodifiable/immutable maps, lists, and sets in Java.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**剖析集合的工厂方法**：举例说明在Java中创建不可修改/不可变映射、列表和集合的几种方法。'
- en: '**Getting a list from a stream**: Provide several snippets of code useful for
    collecting `Stream` content into a Java `List`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从流中获取列表**：提供几个有用的代码片段，用于将`Stream`内容收集到Java `List`中。'
- en: '**Handling map capacity**: Explain what the capacity of a Java `Map` is and
    how it can be used to control the number of effective mappings.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理映射容量**：解释Java `Map`的容量是什么，以及如何用它来控制有效映射的数量。'
- en: '**Tackling Sequenced Collections**: Provide in-depth dive into the JDK 21 Sequenced
    Collections API. Exemplify this API on your favorite Java collections and explain
    what the alternatives before this API are.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理有序集合**：深入探讨JDK 21 Sequenced Collections API。以你最喜欢的Java集合为例，说明这个API，并解释在此API之前有哪些替代方案。'
- en: '**Introducing the Rope data structure**: Explain what the Rope data structure
    is and provide a Java implementation for its main operations (index, insert, delete,
    concatenation, and split).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Rope数据结构**：解释Rope数据结构是什么，并提供其主要操作（索引、插入、删除、连接和分割）的Java实现。'
- en: '**Introducing the Skip List data structure**: Explain and exemplify the Skip
    List data structure.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Skip List 数据结构**：解释并示例 Skip List 数据结构。'
- en: '**Introducing the K-D Tree data structure**: Provide a brief introduction of
    K-D Trees and a Java implementation for 2-D Trees.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 K-D Tree 数据结构**：简要介绍 K-D 树，并提供 2-D 树的 Java 实现。'
- en: '**Introducing the Zipper data structure**: Explain and exemplify on a tree
    the Zipper data structure.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Zipper 数据结构**：在树上解释并示例 Zipper 数据结构。'
- en: '**Introducing the Binomial Heap data structure**: Provide a deep coverage of
    a Binomial Heap data structure. Explain its main operations and exemplify them
    in a Java implementation.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Binomial Heap 数据结构**：深入探讨 Binomial Heap 数据结构。解释其主要操作并在 Java 实现中示例它们。'
- en: '**Introducing the Fibonacci Heap data structure**: Explain and exemplify the
    Fibonacci Heap data structure.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Fibonacci Heap 数据结构**：解释并示例 Fibonacci Heap 数据结构。'
- en: '**Introducing the Pairing Heap data structure**: Explain and exemplify the
    Pairing Heap data structure.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Pairing Heap 数据结构**：解释并示例 Pairing Heap 数据结构。'
- en: '**Introducing the Huffman Coding data structure**: The Huffman Coding algorithm
    was developed by David A. Huffman in 1950\. Explain its usage and exemplify it
    via a Java implementation.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Huffman 编码数据结构**：Huffman 编码算法由 David A. Huffman 在 1950 年开发。解释其用法并通过 Java
    实现进行示例。'
- en: '**Introducing the Splay Tree data structure**: A Splay Tree is a flavor of
    **Binary Search Tree** (**BST**). Explain what its particularities are and provide
    an implementation of its main operations.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Splay Tree 数据结构**：Splay Tree 是**二叉搜索树**（**BST**）的一种形式。解释其特性并提供其主要操作的实现。'
- en: '**Introducing the Interval Tree data structure**: An Interval Tree is another
    flavor of **Binary Search Tree** (**BST**). Highlight its usage and exemplify
    it via a Java implementation.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Interval Tree 数据结构**：Interval Tree 是另一种**二叉搜索树**（**BST**）的形式。突出其用法并通过
    Java 实现进行示例。'
- en: '**Introducing the Unrolled Linked List data structure**: Explain and exemplify
    the Unrolled Linked List data structure.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Unrolled Linked List 数据结构**：解释并示例 Unrolled Linked List 数据结构。'
- en: '**Implementing join algorithms**: There are three famous join algorithms: Nested
    Loop Join, Hash Join, and Sort Merge Join. Explain and exemplify each of them
    in two tables that are involved in a one-to-many relationship.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现连接算法**：有三种著名的连接算法：嵌套循环连接、哈希连接和排序归并连接。在涉及一对一关系的两个表中解释并示例每个算法。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里显示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05)。
- en: 107\. Introducing parallel computations with arrays
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 107. 使用数组介绍并行计算
- en: There was a time when CPUs were only capable of performing operations on data
    in the traditional mode known as **Single Instruction, Single Data** (**SISD**)
    or von Neumann architecture. In other words, one CPU cycle can process a single
    instruction and a single piece of data. The processor applies that instruction
    to that data and returns a result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，CPU 只能在传统模式**单指令单数据**（**SISD**）或冯·诺伊曼架构下对数据进行操作。换句话说，一个CPU周期可以处理一个指令和一个数据。处理器将这个指令应用于该数据，并返回一个结果。
- en: 'Modern CPUs are capable of performing parallel computations and working in
    a mode known as **Single Instruction, Multiple Data** (**SIMD**). This time, one
    CPU cycle can apply a single instruction on multiple pieces of data simultaneously,
    which theoretically should speed things up and improve performance. The following
    diagram highlights these statements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU能够执行并行计算，并以称为**单指令多数据**（**SIMD**）的模式工作。这次，一个CPU周期可以同时对多个数据应用单个指令，从理论上讲，这应该会加快速度并提高性能。以下图表突出了这些说法：
- en: '![Figure 5.1.png](img/B19665_05_01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1.png](img/B19665_05_01.png)'
- en: 'Figure 5.1: SISD vs. SIMD'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：SISD 与 SIMD
- en: If we add two arrays *X* and *Y* via an SISD-based CPU, then we expect that
    each CPU cycle will add an element from *X* with an element from *Y*. If we do
    the same task on a SIMD-based CPU, then each CPU cycle will simultaneously perform
    the addition on chunks from *X* and *Y*. This means that an SIMD CPU should complete
    the task faster than the SISD CPU.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过基于 SISD 的 CPU 对数组 *X* 和 *Y* 进行加法操作，那么我们期望每个 CPU 周期都会将 *X* 中的一个元素与 *Y*
    中的一个元素相加。如果我们在一个基于 SIMD 的 CPU 上执行相同的任务，那么每个 CPU 周期将同时从 *X* 和 *Y* 的块中进行加法操作。这意味着
    SIMD CPU 应该比 SISD CPU 更快地完成任务。
- en: This is the big picture! When we come closer, we see that CPU architectures
    come in many flavors, so it is quite challenging to develop an application capable
    of leveraging the best performance of a specific platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整体图景！当我们靠近时，我们看到 CPU 架构有很多种类，因此开发一个能够利用特定平台最佳性能的应用程序是非常具有挑战性的。
- en: The two big competitors in the market, Intel and AMD, come with different SIMD
    implementations. It is not our goal to dissect this topic in detail, but it can
    be useful to know that the first popular desktop SIMD was introduced in 1996 by
    Intel under the name MMX (x86 architecture). In response, the AIM alliance (made
    up of Apple, IBM, and Freescale Semiconductor) promoted AltiVec – an integer and
    single-precision floating-point SIMD implementation. Later on, in 1999, Intel
    introduced the new SSE system (using 128-bit registers).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上的两大竞争对手，英特尔和 AMD，提供了不同的 SIMD 实现。我们并不旨在详细剖析这个话题，但了解第一个流行的桌面 SIMD 是在 1996 年由英特尔以
    MMX（x86 架构）的名义引入的，这可能是有用的。作为回应，AIM 联盟（由苹果、IBM 和飞思卡尔半导体组成）推广了 AltiVec – 一种整数和单精度浮点
    SIMD 实现。后来，在 1999 年，英特尔引入了新的 SSE 系统（使用 128 位寄存器）。
- en: 'Since then, SIMD has evolved via extensions such as Advanced Vector Extensions
    (AVX, AVX2 (256-bit registers) and AVX-512 (512-bit registers)). While AVX and
    AVX2 are supported by Intel and AMD, the AVX-512 introduced in 2022 is supported
    only by the latest Intel processors. The following figure helps illustrate all
    of this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，SIMD 通过扩展如高级向量扩展（AVX、AVX2（256 位寄存器）和 AVX-512（512 位寄存器））而发展。虽然 AVX 和 AVX2
    都被英特尔和 AMD 支持，但 2022 年引入的 AVX-512 只被最新的英特尔处理器支持。以下图示有助于说明所有这些：
- en: '![Figure 5.2.png](img/B19665_05_02.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2.png](img/B19665_05_02.png)'
- en: 'Figure 5.2: SIMD implementation history'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：SIMD 实现历史
- en: '*Figure 5.2* is just the SIMD representation of a CPU structure. In reality,
    the platforms are much more complex and come in many flavors. There is no silver
    bullet and each platform has its strong and weak points. Trying to explore the
    strong points and avoid the weaknesses is a real challenge for any programming
    language trying to leverage the performance of a specific platform with high expectations.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 只是 CPU 结构的 SIMD 表示。实际上，平台要复杂得多，有多种类型。没有万能的解决方案，每个平台都有其优势和劣势。试图探索优势并避免劣势是任何试图利用特定平台性能的编程语言的真正挑战。'
- en: For instance, what is the proper set of instructions that JVM should generate
    in order to squeeze out the best performance from a specific platform on computations
    that involve vectors (arrays)? Well, starting with JDK 16 (JEP 338), Java provides
    an incubator module, `jdk.incubator.vector`, known as the Vector API. The goal
    of this API is to allow developers to express, in a very platform-agnostic way,
    vector computations that are transformed at runtime in optimal vector hardware
    instructions on supported CPU architectures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JVM 应该生成哪些适当的指令集，以便从涉及向量的特定平台计算中榨取最佳性能？嗯，从 JDK 16（JEP 338）开始，Java 提供了一个孵化器模块，`jdk.incubator.vector`，称为
    Vector API。这个 API 的目标是允许开发者以一种非常平台无关的方式表达向量计算，这些计算在运行时被转换为支持 CPU 架构上的最佳向量硬件指令。
- en: Starting with JDK 21 (JEP 448), the Vector API reached the sixth incubator,
    so we can try out some examples that take advantage of data-parallel accelerated
    code in contrast to scalar implementation. Running examples based on this incubator
    API can be done by adding the `--add-modules=jdk.incubator.vector` and `--enable-preview`
    VM options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 21（JEP 448）开始，Vector API 达到了第六个孵化阶段，因此我们可以尝试一些利用数据并行加速代码的示例，与标量实现相比。基于此孵化器
    API 运行示例可以通过添加 `--add-modules=jdk.incubator.vector` 和 `--enable-preview` 虚拟机选项来实现。
- en: But, before that, let’s cover the Vector API structure and terminology.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前，让我们先了解 Vector API 的结构和术语。
- en: 108\. Covering the Vector API’s structure and terminology
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 108. 涵盖 Vector API 的结构和术语
- en: The Vector API is mapped by the `jdk.incubator.vector` module (and a package
    with the same name). A `jdk.incubator.vector.Vector` instance starts from a generic
    abstract combination characterized by a *type* and a *shape*. A vector is an instance
    of the `Vector<E>` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 API 通过 `jdk.incubator.vector` 模块（以及具有相同名称的包）进行映射。一个 `jdk.incubator.vector.Vector`
    实例从一个由*类型*和*形状*表征的通用抽象组合开始。向量是 `Vector<E>` 类的一个实例。
- en: The vector element type
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量元素类型
- en: 'A `Vector<E>` has an *element type* (`ETYPE`), which is one of the Java primitive
    types: `byte`, `float`, `double`, `short`, `int`, or `long`. When we write `Vector<E>`,
    we say that `E` is the boxed version of `ETYPE` (for instance, when we write `Vector<Float>`,
    `E` is `Float`, and `ETYPE` is `float`). For more convenience, Java declares a
    specialized subtype for each *element type*, as shown in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector<E>` 有一个*元素类型*（`ETYPE`），它是 Java 原始类型之一：`byte`、`float`、`double`、`short`、`int`
    或 `long`。当我们写 `Vector<E>` 时，我们说 `E` 是 `ETYPE` 的装箱版本（例如，当我们写 `Vector<Float>` 时，`E`
    是 `Float`，而 `ETYPE` 是 `float`）。为了方便起见，Java 为每个*元素类型*声明了一个专门的子类型，如下图所示：'
- en: '![Figure 5.3.png](img/B19665_05_03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3.png](img/B19665_05_03.png)'
- en: 'Figure 5.3: Specialized vector subtypes'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：专用向量子类型
- en: Even if `E` is a boxed type, there is no boxing-unboxing overhead because `Vector<E>`
    works internally on `ETYPE` and thus on primitive types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `E` 是一个装箱类型，也没有装箱/拆箱开销，因为 `Vector<E>` 在内部使用 `ETYPE` 和原始类型进行操作。
- en: Besides the *element type*, a vector is also characterized by a *shape*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*元素类型*外，向量还由一个*形状*来表征。
- en: The vector shape
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量形状
- en: A vector is also characterized by a *shape* (also referred to as `VSHAPE`) representing
    the size or capacity in bits of the vector. It can be 64, 128, 256, or 512 bits.
    Each of these values is wrapped by the `VectorShape` enumeration (for instance,
    the `S_128_BIT` enum item represents a shape of length 128 bits) next to an extra
    enum item representing the maximum length supported on the platform (`S_Max_BIT`).
    This is determined automatically on the currently running Java platform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 向量还由一个*形状*（也称为 `VSHAPE`）表征，表示向量的位大小或容量。它可以是以 64、128、256 或 512 位。这些值中的每一个都被 `VectorShape`
    枚举（例如，`S_128_BIT` 枚举项代表长度为 128 位的形状）和一个表示平台支持的最大长度的额外枚举项（`S_Max_BIT`）所封装。这由当前运行的
    Java 平台自动确定。
- en: The vector species
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量种类
- en: 'A vector characterized by its *element type* and *shape* determines a unique
    *vector species,* which is a fixed instance of `VectorSpecies<E>`. This instance
    is shared by all vectors having the same shape and `ETYPE`. We can think of `VectorSpecies<E>`
    as a factory used to create vectors of the required *element type* and *shape*.
    For instance, we can define a factory for creating vectors of the `double` type
    having a size of 512 bits as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由其*元素类型*和*形状*表征的向量确定了一个唯一的*向量种类*，这是一个 `VectorSpecies<E>` 的固定实例。这个实例由所有具有相同形状和
    `ETYPE` 的向量共享。我们可以将 `VectorSpecies<E>` 视为一个工厂，用于创建所需*元素类型*和*形状*的向量。例如，我们可以定义一个工厂来创建具有
    512 位大小的 `double` 类型向量，如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you just need a factory for vectors of the maximal bit-size supported by
    the current platform independent of the element type, then rely on `S_Max_BIT`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个工厂来创建当前平台支持的最大位数的向量，而不考虑元素类型，那么请依赖 `S_Max_BIT`：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you just need the largest vector *species* for your *element type* (here,
    `double`) for the current platform, then rely on `ofLargestShape()`. This vector
    *species* is chosen by the platform and it has a *shape* with the largest possible
    bit-size for your *element type* (don’t confuse this with `S_Max_BIT`, which is
    independent of the *element type*):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要当前平台支持的最大向量*种类*（此处，`double`）来处理你的*元素类型*，那么请依赖 `ofLargestShape()`。这个向量*种类*由平台选择，并且具有为你的*元素类型*提供可能的最大位数的*形状*（不要与
    `S_Max_BIT` 混淆，它独立于*元素类型*）：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, maybe you need the vector *species* preferred by the current platform for
    your *element type*. This can be achieved via `ofPreferred()` as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能需要当前平台为你*元素类型*首选的向量*种类*。这可以通过 `ofPreferred()` 如下实现：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preferred *species* is the most convenient approach when you don’t want
    to bother specifying an explicit *shape*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最优*种类*是在你不想指定显式*形状*时的最方便的方法。
- en: '**Important note**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The preferred *species* is the most optimal *shape* for the given *element type*
    on the current platform (runtime).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最优*种类*是在当前平台（运行时）上给定*元素类型*的最优*形状*。
- en: 'Moreover, for convenience, each specialized vector (`IntVector`, `FloatVector`,
    and so on) defines a set of static fields for covering all possible *species*.
    For example, the static field `DoubleVector.SPECIES_512` can be used for *species*
    representing `DoubleVector` instances of 512-bit size (`VectorShape.S_512_BIT`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了方便起见，每个专用向量（`IntVector`、`FloatVector` 等）定义了一组静态字段，以覆盖所有可能的 *物种*。例如，静态字段
    `DoubleVector.SPECIES_512` 可以用于表示 512 位大小的 `DoubleVector` 实例的 *物种*（`VectorShape.S_512_BIT`）：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want the maximal *species*,then rely on `SPECIES_MAX`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要最大的 *物种*，则依靠 `SPECIES_MAX`：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, if you want the preferred *species*,then rely on `SPECIES_PREFERRED`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想选择首选的 *物种*，则依靠 `SPECIES_PREFERRED`：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can easily inspect the *element type* and *shape* of a `VectorSpecies`
    instance via the `elementType()` and `vectorShape()` methods as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `elementType()` 和 `vectorShape()` 方法轻松检查 `VectorSpecies` 实例的 *元素类型* 和
    *形状*，如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So far, you know how to create vector *species* (vector factories). But, before
    starting to create vectors and apply operations on them, let’s talk about vector
    *lanes*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道了如何创建向量 *物种*（向量工厂）。但在开始创建向量和在它们上应用操作之前，让我们先谈谈向量 *车道*。
- en: Vector lanes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量车道
- en: A `Vector<E>` is like a fixed-sized Java array made of *lanes*. The *lane count*
    is returned by the `length()` method and is called `VLENGTH`. The *lane count*
    is equal to the number of scalar elements stored in that vector.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector<E>` 就像由 *车道* 组成的固定大小的 Java 数组。*车道数* 由 `length()` 方法返回，称为 `VLENGTH`。*车道数*
    等于存储在该向量中的标量元素数量。'
- en: If you know the *element size* and the *shape* of the vector, then you can compute
    the number of *lanes* as (*shape*/*element size*). You should get the same result
    as returned by `length()`. The *element size* is returned by `elementSize()`,
    and the *shape* is returned by `vectorBitSize()` or `vectorShape().vectorBitSize()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道向量的 *元素大小* 和 *形状*，那么你可以通过 (*形状*/*元素大小*) 计算出 *车道数*。你应该得到与 `length()` 返回的结果相同的结果。*元素大小*
    由 `elementSize()` 返回，*形状* 由 `vectorBitSize()` 或 `vectorShape().vectorBitSize()`
    返回。
- en: 'For instance, a vector whose *shape* is 256 bits with an *element type* of
    `float` (which is 32 bits (4 bytes) in Java) holds 8 `float` scalar elements,
    so it has 8 *lanes*. The following figure illustrates this statement:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个形状为 256 位的向量，其 *元素类型* 为 `float`（在 Java 中为 32 位（4 字节）），包含 8 个 `float` 标量元素，因此它有
    8 个 *车道*。以下图示说明了这一点：
- en: '![Figure 5.4.png](img/B19665_05_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.4.png](img/B19665_05_04.png)'
- en: 'Figure 5.4: Computing the number of lanes'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：计算车道数
- en: Based on this example, you can easily compute the number of *lanes* for any
    other vector configuration. Next, let’s see why it is important to know about
    *lanes*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此示例，你可以轻松计算任何其他向量配置的 *车道数*。接下来，让我们看看了解 *车道* 为什么很重要。
- en: Vector operations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量操作
- en: Applying operations on vectors is the climax of our efforts. The number of *lanes*
    estimates the SIMD performance because vector operations operate on *lanes*. A
    single vector operation affects a *lane* as a unit of work. For instance, if our
    vector has 8 *lanes*, it means that SIMD will perform 8 *lanewise* operations
    at once.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量上应用操作是我们努力的顶点。*车道数* 估计了 SIMD 的性能，因为向量操作是在 *车道* 上进行的。单个向量操作作为一个工作单元影响一个 *车道*。例如，如果我们的向量有
    8 个 *车道*，这意味着 SIMD 将一次性执行 8 个 *车道级* 操作。
- en: 'In the following figure, you can see a comparison of SISD vs. SIMD in this
    context:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到在此上下文中 SISD 与 SIMD 的比较：
- en: '![Figure 5.5.png](img/B19665_05_05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.5.png](img/B19665_05_05.png)'
- en: 'Figure 5.5: SISD vs. SIMD'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：SISD 与 SIMD 对比
- en: While SISD has a single scalar as a unit of work, SIMD has 8 scalars (8 *lanes*),
    which explains why SIMD offers a significant performance bump over SISD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SISD 以单个标量作为工作单元，但 SIMD 有 8 个标量（8 个 *车道*），这也解释了为什么 SIMD 相比 SISD 提供了显著的性能提升。
- en: 'So, a `Vector<E>` is operated on *lanes*. Mainly, we have *lanewise* operations
    (such as addition, division, and bit shifts) and *cross-lane* operations that
    reduce all *lanes* to a single scalar (for instance, summing all *lanes*). The
    following figure depicts these statements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Vector<E>` 是在 *车道* 上操作的。主要来说，我们有 *车道级* 操作（如加法、除法和位移动）以及将所有 *车道* 减少到单个标量的
    *跨车道* 操作（例如，对所有 *车道* 进行求和）。以下图示展示了这些说明：
- en: '![Figure 5.6.png](img/B19665_05_06.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.6.png](img/B19665_05_06.png)'
- en: 'Figure 5.6: Lanewise and cross-lane operations'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：车道级和跨车道操作
- en: 'Moreover, a `Vector<E>` can be operated on with a `VectorMask<E>`. This is
    a sequence of `boolean` values that can be used by some vector operations to filter
    the selection and operation of lane elements of the given input vectors. Check
    out the following figure (the addition operation is applied only when the mask
    contains 1):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Vector<E>`可以用`VectorMask<E>`操作。这是一个`boolean`值的序列，可以被某些向量操作用来过滤给定输入向量的车道元素的选取和操作。查看以下图（只有当掩码包含1时才应用加法操作）：
- en: '![Figure 5.7.png](img/B19665_05_07.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.7.png](img/B19665_05_07.png)'
- en: 'Figure 5.7: Lanewise addition with mask'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：带有掩码的逐车道加法
- en: '**Important note**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Note that masks are not supported by all CPUs. A CPU that doesn’t support masks
    may face degradation in performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不是所有的CPU都支持掩码。不支持掩码的CPU可能会面临性能下降。
- en: Speaking about vector operations, you should definitely take a look at the `Vector`
    and `VectorOperators` documentation. In the `Vector` class, we have methods that
    apply operations between two vectors. For instance, we have methods for binary
    operations (such as `add()`, `div()`, `sub()`, and `mul()`), for comparisons (such
    as `eq()`, `lt()`, and `compare()`), for mathematical operations (such as `abs()`),
    and so on. Moreover, in `VectorOperators` we have a bunch of nested classes (for
    instance, `VectorOperators.Associative`) and several constants representing *lanewise*
    operations such as trigonometric functions (`SIN`, `COS`, and so on), bitwise
    shifting operations (`LSHL` and `LSHR`), mathematical operations (`ABS`, `SQRT`,
    and `POW`), and so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到向量操作，你绝对应该查看`Vector`和`VectorOperators`文档。在`Vector`类中，我们有在两个向量之间应用操作的方法。例如，我们有用于二元操作（如`add()`、`div()`、`sub()`和`mul()`）的方法，用于比较（如`eq()`、`lt()`和`compare()`）的方法，用于数学操作（如`abs()`）等等。此外，在`VectorOperators`中，我们有一系列嵌套类（例如，`VectorOperators.Associative`）和代表*逐车道*操作的几个常量，如三角函数（`SIN`、`COS`等），位移动操作（`LSHL`和`LSHR`），数学操作（`ABS`、`SQRT`和`POW`）等等。
- en: In the following problems, you’ll see a part of these operations at work, but
    for now let’s touch on the last essential topic, creating vectors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下问题中，你会看到这些操作的一部分正在运行，但到目前为止，让我们谈谈最后一个基本主题，创建向量。
- en: Creating vectors
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建向量
- en: We already know that having a `VectorSpecies` is like having a factory for creating
    vectors of the required *element type* and *shape*. Now, let’s see how we can
    use such a factory to effectively create vectors (fill them up with scalars) that
    get involved in solving real problems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，拥有一个`VectorSpecies`就像拥有一个创建所需*元素类型*和*形状*向量的工厂。现在，让我们看看我们如何使用这样的工厂有效地创建向量（用标量填充它们），这些向量将参与解决实际问题。
- en: 'Let’s assume the following *species* (a vector of 8 *lanes*, 32*8=256):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下*种类*（一个包含8个*车道*的向量，32*8=256）：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let’s create the most common types of vectors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建最常见的向量类型。
- en: Creating vectors of zeros
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建全零向量
- en: 'Let’s assume that we need a vector containing only zeros. A quick approach
    relies on the `zero()` method as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个只包含零的向量。一种快速的方法是使用`zero()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This produced a vector with 8 *lanes* of 0.0\. The same thing can be obtained
    from the specialized `IntVector` class as well via `zero(VectorSpecies<Integer>
    species)`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一个包含8个*车道*的0.0向量。同样，也可以通过专门的`IntVector`类通过`zero(VectorSpecies<Integer> species)`方法获得：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can easily extrapolate this example to `FloatVector`, `DoubleVector`, and
    so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地将这个例子推广到`FloatVector`、`DoubleVector`等等。
- en: Creating vectors of the same primitive value
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有相同原始值的向量
- en: 'Creating a vector and loading it up with a primitive value can quickly be accomplished
    via the `broadcast()` method as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`broadcast()`方法快速创建一个向量并加载原始值，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The same thing can be obtained from the specialized `IntVector` class as well
    via `broadcast(VectorSpecies<Integer> species, int e)` or `broadcast(VectorSpecies<Integer>
    species, long e)`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以通过专门的`IntVector`类通过`broadcast(VectorSpecies<Integer> species, int e)`或`broadcast(VectorSpecies<Integer>
    species, long e)`方法获得：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Of course, we can use it to broadcast a vector of zeros as well:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以用它来广播一个全零向量：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, let’s see the most common use case for creating a vector.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看创建向量的最常见用例。
- en: Creating vectors from Java arrays
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Java数组创建向量
- en: Creating vectors from Java arrays is the most common use case. Practically,
    we start from a Java array and call the `fromArray()` method name.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java数组创建向量是最常见的用例。实际上，我们从Java数组开始，调用`fromArray()`方法。
- en: Using fromArray() from VectorSpecies
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用VectorSpecies的fromArray()
- en: 'The `fromArray()` method is available in `VectorSpecies` as `fromArray(Object
    a, int offset)`. Here is an example of creating a vector from an array of integers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromArray()`方法在`VectorSpecies`中作为`fromArray(Object a, int offset)`提供。以下是从整数数组创建向量的示例：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since the `varr` length (8) is equal to the vector length and we start from
    index 0, the resulting vector will contain all the scalars from the array. This
    is no longer true in the following example where the last 4 scalars will not be
    part of the resulting vector:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`varr`长度（8）等于向量长度，并且我们从索引0开始，生成的向量将包含数组中的所有标量。在以下示例中，最后4个标量将不会是生成向量的一部分：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The scalars 8, 9, 10, and 11 are not present in the resulting array. Here is
    another example, using `offset` = 2:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 标量8、9、10和11不在生成的数组中。以下是一个使用`offset` = 2的另一个示例：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the scalars 0, 1, 10, and 11 are not present in the resulting array.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，标量0、1、10和11不在生成的数组中。
- en: 'Pay attention that the length of the Java array shouldn’t be less than the
    vector’s length. For instance, the following example will cause an exception:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java数组的长度不应小于向量的长度。例如，以下示例将导致异常：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the Java array length is 6 (less than 8), this will cause a `java.lang.IndexOutOfBoundsException`
    instance. So, the minimum accepted length for `varr` is 8.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java数组长度为6（小于8），这将导致`java.lang.IndexOutOfBoundsException`实例。因此，`varr`的最小接受长度为8。
- en: Using fromArray() from specialized vectors
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用来自特定向量的fromArray()方法
- en: 'Each specialized vector class provides a bunch of `fromArray()` flavors. For
    instance, the `IntVector` exposes the popular `fromArray(VectorSpecies<Integer>
    species, int[] a, int offset)` method, which can be used in a straightforward
    way:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定向量类都提供了一组`fromArray()`风味。例如，`IntVector`公开了流行的`fromArray(VectorSpecies<Integer>
    species, int[] a, int offset)`方法，它可以被直接使用：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we prefer the `fromArray(VectorSpecies<Integer> species, int[] a, int offset,
    VectorMask<Integer> m)` flavor, then we can filter the selected scalars from the
    Java array via `VectorMask`. Here is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢`fromArray(VectorSpecies<Integer> species, int[] a, int offset, VectorMask<Integer>
    m)`风味，那么我们可以通过`VectorMask`从Java数组中过滤选定的标量。以下是一个示例：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Based on a one-to-one match, we can easily observe that the resulting vector
    will fetch only the scalars 2, 5, and 6\. The resulting vector will be: [0, 0,
    2, 0, 0, 5, 6, 0].'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于一对一的匹配，我们可以轻松观察到生成的向量将只获取标量2、5和6。生成的向量将是：[0, 0, 2, 0, 0, 5, 6, 0]。
- en: 'Another flavor of `fromArray()` is `fromArray(VectorSpecies<Integer> species,
    int[] a, int offset, int[] indexMap, int mapOffset)`. This time, we use a map
    of indexes to filter the selected scalars:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromArray()`的另一种风味是`fromArray(VectorSpecies<Integer> species, int[] a, int
    offset, int[] indexMap, int mapOffset)`。这次，我们使用索引映射来过滤选定的标量：'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The resulting array will be: [11, 11, 11, 12, 12, 29, 29, 29]. We have 11 from
    index 0, 12 from index 1, and 29 from index 6.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数组将是：[11, 11, 11, 12, 12, 29, 29, 29]。我们有来自索引0的11，来自索引1的12，以及来自索引6的29。
- en: 'In addition, we can apply `VectorMask` to the previous index map via `fromArray(VectorSpecies<Integer>
    species, int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer>
    m)`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`fromArray(VectorSpecies<Integer> species, int[] a, int offset, int[]
    indexMap, int mapOffset, VectorMask<Integer> m)`将`VectorMask`应用于之前的索引映射：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting vector is: `[0, 0, 11, 0, 0, 29, 29, 0]`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的向量是：`[0, 0, 11, 0, 0, 29, 29, 0]`。
- en: Creating vectors from memory segments
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从内存段创建向量
- en: '*Memory segments* are a topic covered in detail in *Chapter 7* as part of the
    Foreign Function and Memory API, but as a quick teaser, here is an example of
    creating a vector from a memory segment via `IntVector.fromMemorySegment()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存段*是作为Foreign Function和Memory API的一部分在*第7章*中详细讨论的主题，但作为一个快速预告，以下是一个通过`IntVector.fromMemorySegment()`从内存段创建向量的示例：'
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The created vector is: [11, 21, 12, 7, 33, 1, 3, 6].'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的向量是：[11, 21, 12, 7, 33, 1, 3, 6]。
- en: In the bundled code, you can find several more examples for manipulating data
    across lane boundaries such as slicing, un-slicing, shuffling/rearranging, compressing,
    expanding, converting, casting, and reinterpreting shapes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到更多关于在通道边界操作数据的示例，例如切片、非切片、洗牌/重新排列、压缩、扩展、转换、类型转换和重新解释形状。
- en: In the next problem, we start creating complete examples that exploit what we’ve
    learned so far.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将开始创建完整的示例，以利用我们迄今为止所学的内容。
- en: 109\. Summing two arrays via the Vector API
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 109. 通过Vector API求两个数组的和
- en: 'Summing two arrays is the perfect start for applying what we’ve learned in
    the preceding two problems. Let’s assume that we have the following Java arrays:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个数组相加是应用前面两个问题中学到的知识的完美起点。假设我们有以下Java数组：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For computing `z=x+y` via the Vector API, we have to create two `Vector` instances
    and rely on the `add()` operation, `z=x.add(y)`. Since the Java arrays hold integer
    scalars, we can use the `IntVector` specialization as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Vector API计算`z=x+y`，我们必须创建两个`Vector`实例，并依赖于`add()`操作，`z=x.add(y)`。由于Java数组持有整数标量，我们可以使用`IntVector`特化如下：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In Java, an integer needs 4 bytes, so 32 bits. Since `x` and `y` hold 8 integers,
    we need 8*32=256 bits to represent them in our vector. So, relying on `SPECIES_256`
    is the right choice.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个整数需要4个字节，即32位。由于`x`和`y`存储了8个整数，因此我们需要8*32=256位来在我们的向量中表示它们。所以，依赖`SPECIES_256`是正确的选择。
- en: 'Next, we can apply the `add()` operation as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以按照以下方式应用`add()`操作：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Done! It is time for JVM to generate the optimal set of instructions (data-parallel
    accelerated code) that will compute our addition. The result will be a vector
    as [5, 7, 5, 9, 6, 9, 15, 15].
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！现在是时候让JVM生成最优的指令集（数据并行加速代码），以计算我们的加法。结果将是一个向量，如[5, 7, 5, 9, 6, 9, 15, 15]。
- en: This was a simple case but not quite realistic. Who would employ parallel computational
    capabilities for summing up two arrays having a couple of elements?! In the real
    world, `x` and `y` may have much more than 8 elements. Most probably, `x` and
    `y` have millions of items and are involved in multiple calculation cycles. That
    is exactly when we can leverage the power of parallel computation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但并不完全现实。谁会为了将只有几个元素的数组相加而使用并行计算能力呢？！在现实世界中，`x`和`y`可能包含比8个元素多得多的元素。最有可能的是，`x`和`y`有数百万个项，并且参与了多个计算周期。这正是我们可以利用并行计算力量的时刻。
- en: 'But, for now, let’s assume that `x` and `y` are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但，现在，让我们假设`x`和`y`如下：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we apply the previous code (based on `SPECIES_256`), the result will be the
    same because our vectors can accommodate only the first 8 scalars and will ignore
    the rest. If we apply the same logic but use `SPECIES_PREFERRED`, then the result
    is unpredictable since the vector’s shape is specific to the current platform.
    However, we can intuit that we will accommodate the first `n` (whatever that `n`
    is) scalars but not all.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用之前的代码（基于`SPECIES_256`），结果将相同，因为我们的向量只能容纳前8个标量，而忽略其余的。如果我们应用相同的逻辑但使用`SPECIES_PREFERRED`，那么结果是不可预测的，因为向量的形状特定于当前平台。然而，我们可以直观地认为我们将容纳前`n`个标量（无论`n`是多少），但不是所有的。
- en: 'This time, we need to chunk the arrays and use a loop to traverse the arrays
    and compute `z_chunk = x_chunk + y_chunk`. The result of summing two chunks is
    collected in a third array (`z`) until all chunks are processed. We define a method
    that starts as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要分块数组，并使用循环遍历数组，计算`z_chunk = x_chunk + y_chunk`。将两个分块相加的结果收集在第三个数组（`z`）中，直到所有分块都处理完毕。我们定义的方法如下：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But, how big should a chunk be? The first challenge is represented by the loop
    design. The loop should start from 0, but what are the upper bound and the step?
    Typically, the upper bound is the length of `x`, so 34\. But, using `x.length`
    is not exactly useful because it doesn’t guarantee that our vectors will accommodate
    as many scalars as possible from the arrays. What we are looking for is the largest
    multiple of `VLENGTH` (vector’s length) that is less than or equal to `x.length`.
    In our case, that is the largest multiple of 8 that is less than 34, so 32\. This
    is exactly what the `loopBound()` method returns, so we can write the loop as
    follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个块应该有多大呢？第一个挑战体现在循环设计上。循环应该从0开始，但上界和步长是多少？通常，上界是`x`的长度，即34。但是，使用`x.length`并不完全有用，因为它不能保证我们的向量可以容纳尽可能多的标量从数组中。我们正在寻找的是小于或等于`x.length`的最大`VLENGTH`（向量长度）的倍数。在我们的例子中，这是小于34的最大8的倍数，即32。这正是`loopBound()`方法返回的值，因此我们可以将循环写成如下：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The loop step is the vector’s length. The following diagram pre-visualizes
    the code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 循环步长是向量的长度。以下图表预先展示了代码：
- en: '![Figure 5.8.png](img/B19665_05_08.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.8.png](img/B19665_05_08.png)'
- en: 'Figure 5.8: Computing z = x + y in chunks'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：分块计算z = x + y
- en: 'So, at the first iteration, our vectors will accommodate the scalars from index
    0 to 7\. At the second iteration, the scalars are from index 8 to 15, and so on.
    Here is the complete code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第一次迭代中，我们的向量将容纳从索引0到7的标量。在第二次迭代中，标量是从索引8到15，依此类推。以下是完整的代码：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `intoArray(int[] a, int offset)` transfers the scalars from a vector to
    a Java array. This method comes in different flavors next to `intoMemorySegment()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting array will be: [7, 11, 7, 10, 2, 5, 11, 11, 6, 12, 9, 11, 4,
    8, 8, 9, 6, 8, 10, 12, 8, 12, 12, 13, 4, 8, 8, 9, 6, 8, 10, 12, **0**, **0**].
    Check out the last two items … they are equal to 0\. These are the items that
    result from `x.length - upperBound` = 34 – 32 = 2\. When the largest multiple
    of `VLENGTH` (vector’s length) is equal to `x.length`, this difference will be
    0, otherwise, we will have the rest of the items that have not been computed.
    So, the previous code will work as expected only in the particular case when `VLENGTH`
    (vector’s length) is equal to `x.length`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Covering the remaining items can be accomplished in at least two ways. First,
    we can rely on a `VectorMask` as in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `indexInRange()` computes a mask in the range `[i, x.length-1]`. Applying
    this mask will result in the following `z` array: [7, 11, 7, 10, 2, 5, 11, 11,
    6, 12, 9, 11, 4, 8, 8, 9, 6, 8, 10, 12, 8, 12, 12, 13, 4, 8, 8, 9, 6, 8, 10, 12,
    5, 12]. Now, the last two items are computed as expected.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, avoid using `VectorMask` in loops. They are quite expensive
    and may lead to a significant degradation in performance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach for dealing with these remaining items is to go for a piece
    of traditional Java code as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Practically, we sum up the remaining items in a Java traditional loop outside
    the vectors loop. You can check these examples in the bundled code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 110\. Summing two arrays unrolled via the Vector API
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we take the example of summing two arrays from the previous
    problem and re-write the loop in an *unrolled* fashion.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*Loop unrolling* can be applied manually (as we will do here) or by the compiler,
    and it stands for an optimization technique meant to reduce the loop iteration
    count.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, in order to reduce the loop iteration count, we use more vectors
    to repeat the sequence of loop body statements that are responsible for summing
    the items. If we know that our arrays are long enough to always require at least
    4 loop iterations, then rewriting the code as follows will reduce the loop iterations
    by 4 times:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Consider the following `x` and `y` vectors:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Calling the `sumPlus(x, y, z)` method written in the previous problem will require
    4 loop iterations to complete. Calling `sumUnrolled(x, y, z)` will require a single
    iteration to complete.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 111\. Benchmarking the Vector API
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Benchmarking the Vector API can be accomplished via JMH. Let’s consider three
    Java arrays (`x`, `y`, `z`) each of 50,000,000 integers, and the following computation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, the final result is stored in a Java array named `k`. And, let’s consider
    the following benchmark containing four different implementations of this computation
    (using a mask, no mask, *unrolled*, and plain scalar Java with arrays):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running this benchmark on an Intel(R) Core(TM) i7-3612QM CPU @ 2.10GHz machine
    running Windows 10 produced the following results:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9.png](img/B19665_05_09.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Benchmark results'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Overall, executing the computation using data-parallel capabilities gives the
    best performance, highest throughput, and best average time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 112\. Applying the Vector API to compute FMA
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell, **Fused Multiply Add** (**FMA**) is the mathematical computation
    (a*b) + c, which is heavily exploited in matrix multiplications. That’s all we
    need to cover for this problem, but if you need a primer on FMA, consider *Java
    Coding Problems, First Edition*, *Chapter 1*, *problem 38*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FMA via the Vector API can be done via the `fma(float b, float
    c)` or `fma(Vector<Float> b, Vector<Float> c)` operation, the latter is the one
    you’ll see in an example shortly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following two arrays:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Computing FMA(`x`, `y`) can be expressed as the following sequence: 4+0=4 →
    10+4=14 → 6+14=20 → 40+20=60 → 5+60=65 → 32+65=97\. So, FMA(`x`, `y`) = 97\. Expressing
    this sequence via the Vector API can be done as shown in the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Have you noticed the code line `sum = xVector.fma(yVector, sum)`? This is equivalent
    to `sum = xVector.mul(yVector).add(sum)`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The novelty here consists of the following line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is an associative *cross-lane* reduction operation (see *Figure 5.6*).
    Before this line, the sum vector looks as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By applying the `reduceLanes(VectorOperators.ADD)`, we sum the values of this
    vector and reduce it to the final result, 97.0\. Cool, right?!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 113\. Multiplying matrices via the Vector API
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider two matrices of 4x4 denoted as `X` and `Y`. `Z=X*Y` is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10.png](img/B19665_05_10.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Multiplying two matrices (X * Y = Z)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying `X` with `Y` means multiplying the first row from `X` with the first
    column from `Y`, the second row from `X` with the second column from `Y`, and
    so on. For instance, (1 x 3) + (2 x 7) + (5 x 5) + (4 x 5) = 3 + 14 + 25 + 20
    = 62\. Basically, we repeatedly apply FMA computation and fill up `Z` with the
    results.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, and based on the previous problem about computing FMA, we
    can produce the following code for multiplying `X` with `Y`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the bundled code, you can find this example next to another one using `SPECIES_512`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 114\. Hooking the image negative filter with the Vector API
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An image is basically a matrix of pixels represented in the **Alpha, Red, Green,
    Blue** (**ARGB**) spectrum. For instance, an image of 232x290 can be represented
    as a matrix of 67,280 pixels. Applying specific filters (sepia, negative, grayscale,
    and so on) to an image typically requires processing each pixel from this matrix
    and performing certain calculations. For instance, the algorithm for applying
    the negative filter to an image can be used as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11.png](img/B19665_05_11.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Apply the negative filter effect to an image'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel, we extract the color components A, R, G, and B. We subtract
    the R, G, and B values from 255, and finally, we set the new value to the current
    pixel.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we have an array (`pixel[]`) containing all pixels of an image.
    Next, we want to pass `pixel[]` as an argument to a method powered by the Vector
    API capable of applying the negative filter and setting the new values directly
    in `pixel[]`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a possible implementation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the first part, we extract A, R, G, and B into four vectors (`alphaVector`,
    `redVector`, `greenVector`, and `blueVector`) by applying the `LSHR` *lanewise*
    operation. Afterward, we subtract R, G, and B from 255 and compute the new R,
    G, and B by applying the `LSHL` *lanewise* operation. Next, we compute the new
    color by applying the bitwise logical disjunction (`|`) between the new A, R,
    G, and B values. Finally, we set the new color in the `pixel[]` array.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 115\. Dissecting factory methods for collections
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using factory methods for collections is a must-have skill. It is very convenient
    to be able to quickly and effortlessly create and populate unmodifiable/immutable
    collections before putting them to work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Factory methods for maps
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For instance, before JDK 9, creating an unmodifiable map could be accomplished
    like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is useful if, at some point in time, you need an unmodifiable map from
    a modifiable one. Otherwise, you can take a shortcut as follows (this is known
    as the *double-brace initialization* technique and, generally, an anti-pattern):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you need to return an unmodifiable/immutable map from a `Stream` of `java.util.Map.entry`
    then here you go:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Moreover, let’s not forget the empty and singleton maps (quite useful to return
    a map from a method instead of `null`):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Starting with JDK 9, we can rely on a more convenient approach for creating
    unmodifiable/immutable maps thanks to JEP 269: *Convenience Factory Methods for
    Collections*. This approach consists of `Map.of()`, which is available from 0
    to 10 mappings or, in other words, is overloaded to support 0 to 10 key-value
    pairs. Here, we use `Map.of()` for three mappings:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Maps created via `Map.of()` don’t allow `null` keys or values. Such attempts
    will end up in a `NullPointerException`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need more than 10 mappings then you can rely on `static <K,V> Map<K,V>
    ofEntries(Entry<? Extends K,? extends V>... entries)` as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, creating an unmodifiable/immutable map from an existing one can be
    done via `static <K,V> Map<K,V> copyOf(Map<? extends K,? extends V> map)`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the given map is unmodifiable then Java will most probably not create a copy
    and will return an existing instance. In other words, `imap == map` will return
    `true`. If the given map is modifiable then most probably the factory will return
    a new instance, so `imap == map` will return `false`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Factory methods for lists
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before JDK 9, a modifiable `List` could be used for creating an unmodifiable
    `List` with the same content as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A common approach for creating a `List` consists of using `Arrays.asList()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, keep in mind that this is a fixed-size list, not an unmodifiable/immutable
    list. In other words, operations that attempt to modify the list size (for instance,
    `ilist.add(…)`) will result in `UnsupportedOperationException`, while operations
    that modify the current content of the list (for instance, `ilist.set(…)`) are
    allowed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to return an unmodifiable/immutable `List` from a `Stream` then
    here you go:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Moreover, creating an empty/singleton list can be done as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Starting with JDK 9+, it is more convenient to rely on the `List.of()` factory
    methods available for 0 to 10 elements (`null` elements are not allowed):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you need a copy of an existing list then rely on `List.copyOf()`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the given list is unmodifiable then Java will most probably not create a
    copy and will return an existing instance. In other words, `ilist == list` will
    return `true`. If the given list is modifiable then the factory will most likely
    return a new instance, so `ilist == list` will return `false`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Factory methods for sets
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating `Set` instances follows the same path as `List` instances. However,
    note that there is no `singletonSet()`. To create a singleton set, simply call
    `singleton()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can find more examples in the bundled code. You may also be interested in
    *Problem 109* from *Java Coding Problems*, *First Edition*, which covers unmodifiable
    versus immutable collections. Moreover, please consider the next problem presented
    here as well, since it provides more info on this context.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 116\. Getting a list from a stream
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting a `Stream` into a `List` is a popular task that occurs all over the
    place in applications that manipulate streams and collections.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'In JDK 8, collecting a `Stream` into a `List` can be done via the `toList()`
    collector as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Starting with JDK 10, we can rely on the `toUnmodifiableList()` collector (for
    maps, use `toUnmodifiableMap()`, and for sets, `toUnmodifiableSet()`):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Obviously, the returned list is an unmodifiable/immutable list.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'JDK 16 has introduced the following `toList()` default method in the `Stream`
    interface:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using this method to collect a `Stream` into an unmodifiable/immutable list
    is straightforward (pay attention that this is not like `Collectors.toList()`,
    which returns a modifiable list):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the bundled code, you can also find an example of combining `flatMap()` and
    `toList()`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 117\. Handling map capacity
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we need a `List` capable of holding 260 items. We can do
    it as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The array underlying `ArrayList` is created directly to accommodate 260 items.
    In other words, we can insert 260 items without worrying about resizing or enlarging
    the list several times in order to hold these 260 items.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this logic, we can reproduce it for a map as well:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So, now we can assume that we have a map capable of accommodating 260 mappings.
    Actually, no, this assumption is not true! A `HashMap` works on the *hashing*
    principle and is initialized with an initial capacity (16 if no explicit initial
    capacity is provided) representing the number of internal buckets and a default
    *load factor* of 0.75\. What does that mean? It means that when a `HashMap` reaches
    75% of its current capacity, it is doubled in size and a rehashing takes place.
    This guarantees that the mappings are evenly distributed in the internal buckets.
    But, for significantly large maps, this is an expensive operation. Javadoc states
    that “*creating a HashMap with a sufficiently large capacity will allow the mappings
    to be stored more efficiently than letting it perform automatic rehashing as needed
    to grow the table*.”
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In our case, it means that a map can hold 260 x 0.75 = 195 mappings. In other
    words, when we insert the 195^(th) mapping, the map will be automatically resized
    to 260 * 2 = 520 mappings.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `HashMap` for 260 mappings, we have to calculate the initial capacity
    as the number of mappings/load factor: 260 / 0.75 = 347 mappings:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Or, if we want to express it as a formula, we can do it as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Starting with JDK 19, this formula has been hidden behind the `static <K,V>
    HashMap<K,V> newHashMap(int numMappings)` method. This time, `numMappings` represents
    the number of mappings, so we can write this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Analog methods exist for `HashSet`, `LinkedHashSet`, `LinkedHashMap`, and `WeakHashMap`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 118\. Tackling Sequenced Collections
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sequenced Collections API was added as a final feature in JDK 21 under JEP
    431\. Its main goal is to make the navigation of Java collections easier by providing
    a common API to all collections having a well-defined encounter order.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: A Java collection with a well-defined encounter order has a well-defined first
    element, second element, and so on, until the last element. The encounter order
    is the order in which an `Iterator` will iterate the elements of a collection
    (list, set, sorted set, map, and so on). The encounter order can take advantage
    of stability over time (lists) or not (sets).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'This API consists of 3 interfaces named `SequencedCollection` (valid for any
    collection that has a well-defined encounter order), `SequencedSet` (extends `SequencedCollection`
    and `Set` to provide support for Java sets), and `SequencedMap` (extends `Map`
    to give support to any Java map that has a well-defined encounter order). In the
    following diagram, you can see the locations of these 3 interfaces in the collections
    type hierarchy:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![aFigure1.png](img/B19665_05_12.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: The location of the Sequenced Collections API in the collections
    type hierarchy'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SequencedCollection` API targets four main operations on a collection:
    getting the first/last element, adding a new element in the first/last position,
    removing the first/last element, and reversing a collection.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SequencedCollection` API defines 7 methods, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '`getFirst()` gets the first element of the current collection'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLast()` gets the last element of the current collection'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addFirst(E e)` adds the given element `e` as the first element of the current
    collection'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addLast(E e)` adds the given element `e` as the last element of the current
    collection'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeFirst()` removes the first element of the current collection'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeLast()` removes the last element of the current collection'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed()` returns the reverse collection of the current collection'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequencedSet` extends `SequencedCollection` and overrides the `reversed()`
    method to return `SequencedSet`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '`SequencedMap` defines the following methods:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`firstEntry()` returns the first entry (first key-value mapping) from the current
    map'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastEntry()` returns the last entry (last key-value mapping) from the current
    map'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putFirst(K k, V v)` attempts to insert (or replace) the given key-value mapping
    as the first mapping in the current map'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putLast(K k, V v)` attempts to insert (or replace) the given key-value mapping
    as the last mapping in the current map'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollFirstEntry()` removes and returns the first entry (first key-value mapping)
    from the current map (if no entry is present then it returns `null`)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollLastEntry()` removes and returns the last entry (last key-value mapping)
    from the current map (if no entry is present then it returns `null`)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed()` returns the reverse map of the current map'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequencedEntrySet()` returns a `SequencedSet` view of the entry set (`entrySet()`)
    of the current map'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequencedKeySet()` returns a `SequencedSet` view of the key set (`keyset()`)
    of the current map'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequencedValues()` returns a `SequencedCollection` view of the values (`values()`)
    of the current map'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The well-defined encounter order is a property spread across the collections
    type hierarchy, so we have to consider that the Sequenced Collections API works
    completely with some collections, partially with others, and not at all with yet
    others. Let’s tackle a few common collections and try out this new API.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to lists
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java lists (implementations of `List`) rely on indexes to support a well-defined
    (stable) encounter order, so they are a perfect candidate for the Sequenced Collections
    API.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can exploit the Sequenced Collections API for two of
    the most popular implementations of `List`. Obviously, we are talking about `ArrayList`
    and `LinkedList`. `ArrayList` and `LinkedList` implement `SequencedCollection`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to ArrayList and LinkedList
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume that we have the following `ArrayList` and `LinkedList`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Getting the first element from `ArrayList` is quite simple. The first element
    is at index 0, so calling `get(0)` is all we need to do:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Getting the last element is a little trickier. We don’t know the index of the
    last element but we know the size of the list, so we can write this (it is not
    neat, but it works):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'On the other hand, if we rely on the JDK 21 Sequenced Collections API then
    we can get the first and last elements as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: That’s really neat and applies to the `LinkedList` as well! We don’t involve
    any explicit indexes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an element in the first position means adding an element at index 0
    via the well-known `add(index, element)`. Moreover, adding an element in the last
    position means calling the `add(element)` method without an explicit index as
    follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Adding the same elements via the Sequenced Collections API can be done as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Removing the first/last element can be done via the `remove()` method and the
    proper indexes as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we know the value of the last element then we can remove it without an explicit
    index as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Removing the same elements via the Sequenced Collections API can be done as
    follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: So, using the Sequenced Collections API is straightforward. No arguments are
    involved. And, this works for `LinkedList` as well.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Reversing the list can be done via the `Collections.reverse()` helper. This
    method reverses the given list:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'On the other hand, the Sequenced Collections API returns a new list representing
    the reverse of the given list as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Again, the same code works for `LinkedList` as well. So, the Sequenced Collections
    API works perfectly for lists.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to sets
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java sets (implementations of `Set`) can be split into two categories. We have
    sorted sets (implementations of `SortedSet`) that support a well-defined (stable)
    encounter order and sets that make no guarantees as to the iteration order (`HashSet`).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: A `SortedSet` has an order dictated by the logic of a comparator (*natural ordering*
    or `Comparator`). When we insert a new element in a sorted set, the comparator
    logic decides where this element will land, so we don’t know the index value of
    an element. However, a sorted set has the notion of first and last elements and
    an `Iterator` will iterate the elements in the order settled by the comparator.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a set such as `HashSet` has no guarantees as to the iteration
    order. The elements of a `HashSet` are ordered by its internal hashing algorithms.
    An `Iterator` over a `HashSet` iterates its elements in no particular order and,
    when we insert a new element, we have no idea where this element will land in
    the `HashSet`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can exploit the Sequenced Collections API for three of
    the most popular sets. We choose `HashSet` (an implementation of `Set`), `LinkedHashSet`
    (an extension of `HashSet`), and `TreeSet` (an implementation of `NavigableSet`
    that extends `SortedSet`).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to HashSet
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `HashSet` iterates its elements in no particular order, which means that a
    `HashSet` has no idea (stability) of the first, second, or last elements. Iterating
    the same `HashSet` multiple times may result in different outputs. In this context,
    we can add an element to a set via the `add(E e)` method. The element will be
    added only if it doesn’t exist already and will land in a position computed by
    the `HashSet` internal hashing algorithms. Moreover, we can remove an element
    by its value via `remove(Object o)`. Since the order of elements is not stable,
    it doesn’t make sense to reverse `HashSet`. In this context, the Sequenced Collections
    API doesn’t work at all, so `HashSet` doesn’t take advantage of this API.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to LinkedHashSet
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `LinkedHashSet` is a `HashSet` that relies on a doubly-linked list to maintain
    a well-defined encounter order. A `LinkedHashSet` implements `SequencedSet`, so
    it can take advantage of the Sequenced Collections API. Let’s deep dive into the
    following `LinkedHashSet`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `LinkedHashSet` doesn’t expose an API for getting the first/last elements.
    However, we can rely on the well-defined encounter order and on the `Iterator`
    (or `Stream`) API to get the first element as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is not neat, and for the last element it is even worse:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Fortunately, JDK 21 simplifies this task via the `getFirst()` and `getLast()`
    methods:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Adding an element into `LinkedHashSet` is possible only if that element doesn’t
    exist. This is normal since sets don’t accept doubles as lists. However, adding
    on the first position is not an easy task (we can do it if we transform `LinkedHashSet`
    into another collection, add the element on the first position, and convert back
    to `LinkedHashSet`) so we skipped that here. Adding an element to the last position
    is easy via the `add()` method:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'But if we rely on the Sequenced Collections API, then we can add on the first/last
    position via `addFirst()`/`addLast()`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Removing the first/last element is possible only if we know the values of those
    elements:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Obviously, this approach is not robust and safe and you’ll prefer to get the
    first/last elements as you saw earlier via `Iterator`/`Stream`, and call `remove()`
    on those elements afterward. However, the more appropriate option is to rely on
    the Sequenced Collections API:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There is no other straightforward solution to reverse `LinkedHashSet` than
    using the Sequenced Collections API:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: So, as you can see, the Sequenced Collections API really simplifies the usage
    of `LinkedHashSet`. Cool!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to TreeSet
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `TreeSet` is a sorted set that implements `NavigableSet` (an extension of
    `SortedSet`) so it takes advantage of all methods of a sorted set plus some navigation
    methods. It also implements `SequencedCollection` and `SequencedSet`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following `TreeSet`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Relying on the default comparator for strings (that is, natural ordering, which
    compares two strings lexicographically), the sorted set will be *five*, *four*,
    *one*, *three*, *two*. So, the first element is *five*, and the last element is
    *two*. Getting the first/last element of a sorted set can be done via the `first()`
    and `last()` methods:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'So, the Sequenced Collections API doesn’t bring significant value in this case:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Adding a new element to the first/last position in a sorted set is not possible.
    Since the order of elements is dictated by a comparator (natural ordering or an
    explicit `Comparator`), we cannot guarantee that an added element will land in
    the first or last position. For instance, the following code will not add the
    elements as we may expect (zero as the first element, and six as the last element):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: After applying the lexicographical criteria, the resulting sorted set will be
    *five*, *four*, *one*, *six*, *three*, *two*, *zero*. So, *zero* is actually the
    last element and *six* is the fourth element.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Trying to apply the Sequenced Collections API (`addFirst()`/`addLast()`) will
    throw an `UnsupportedOperationException` exception.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'How about removing the first/last elements from a sorted set? Since we can
    get the first/last elements of a tree set, we can also remove them as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The Sequenced Collections API implementation represents a shortcut of the previous
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Reversing a sorted set can be done via `descendingSet()` or `descendingIterator()`.
    Both of them are available in `TreeSet`, so here is the usage of `descendingSet()`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It is much neater to rely on the Sequenced Collections API as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Cool, right?!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to maps
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java maps (implementations of `Map`) may have a well-defined encounter order
    (for instance, `LinkedHashMap` (implementation of `Map` and `SequencedMap`), `TreeMap`
    (implementation of `SortedMap` and `SequencedMap`)) or an unstable order over
    time (for instance, `HashMap` implementation of `Map`). Exactly as in the case
    of `HashSet`, `HashMap` cannot take advantage of the Sequenced Collections API.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to LinkedHashMap
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`LinkedHashMap` is a map with a well-defined encounter order. Here is an example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Getting the first entry (`Map.Entry`) from a linked hash map can be done via
    the `Iterator`/`Stream` API as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The same logic can be applied to get the first key (via `keyset()`) or the
    first value (via `values()`):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Getting the last entry/key/value requires code that is even uglier than the
    previous code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In this case, the Sequenced Collections API is really useful for avoiding such
    painful and cumbersome code. For instance, getting the first element from `LinkedHashMap`
    via the Sequenced Collections API can be done via `firstEntry()`/`lastEntry()`
    as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'While there is no `firstKey()`/`lastKey()` or `firstValue()`/`lastValue()`,
    we can get the first key/value via `sequencedKeySet()` and `sequencedValues()`
    as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The same logic can be applied for entries as well via `sequencedEntrySet()`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: But, obviously, using `firsEntry()`/`lastEntry()` is neater.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new entry on the last position is possible by simply calling `put(K
    key, V value)`. However, adding a new entry to the first position cannot be done
    that easily. But, we can create a new `LinkedHashMap` and put the new entry into
    it. Afterwards, we copy the entries from the original `LinkedHashMap` as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The resulting `slinkedhashmap` will contain the following entries: *0=zero,
    1=one, 2=two, 3=three, 4=four, 5=five, 6=six*.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, this is far from an optimal and elegant approach. We would do better
    to rely on the Sequenced Collections API’s `putFirst()`/`putLast()` as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: That’s quite neat!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing the first/last entry can be done in two steps. First, we get the first/last
    entry from `LinkedHashMap` via the `Iterator`/`Stream` APIs. Second, we rely on
    the `remove()` method as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Wow! That’s ugly, right?! Fortunately, the Sequenced Collections API exposes
    `pollFirstEntry()`/`pollLastEntry()` precisely for this purpose:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Reversing `LinkedHashMap` is also tricky. There are multiple cumbersome approaches,
    one of which is to create a new `LinkedHashMap`. Then, employ the `descendingIterator()`
    API to iterate the original `LinkedHashMap` from end to start while adding to
    the new `LinkedHashMap`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This code is hard to digest! It would be better to use the Sequenced Collections
    API, which exposes the `reversed()` method:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: That’s simple!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Sequenced Collections API to SortedMap (TreeMap)
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SortedMap` extends `SequencedMap` and keeps its entries sorted by the natural
    ordering or by an explicit `Comparator`. Let’s give it a try on a `TreeMap` implementation
    of `SortedMap`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Getting the first/last entry from `TreeMap` can be done via the `firstKey()`
    and `lastKey()` methods respectively, like this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If we prefer the Sequenced Collections API, then we can use `firstEntry()`/`lastEntry()`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In addition, sorted maps can take advantage of `sequencedKeySet()`, `sequencedValues()`,
    and `sequencedEntrySet()` as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Since a sorted map keeps its entries ordered based on the natural ordering
    or an explicit `Comparator`, we cannot add an entry on the first/last position.
    In other words, what we want to insert on the first/last position may land anywhere
    in the sorted map depending on the `Comparator` logic. In this context, the Sequenced
    Collections API represented by `putFirst()`/`putLast()` will throw `UnsupportedOperationException`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Removing the first/last entry can be done via the `remove()` methods as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The Sequenced Collections API can significantly reduce this code via `pollFirstEntry()`
    and `pollLastEntry()`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Reversing a sorted map can be done via `descendingMap()` (or `descendingKeySet()`):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Or, we can keep things simple via the Sequenced Collections API, which exposes
    the `reversed()` method:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Done! As you have just seen, the Sequenced Collections API is quite useful and
    easy to use. Feel free to exploit it on other collections as well.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 119\. Introducing the Rope data structure
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prerequisite**: Starting with this problem, we will cover a bunch of complex
    data structures that require previous experience with binary trees, lists, heaps,
    queues, stacks, and so on. If you are a novice in the data structure field, then
    I strongly recommend you postpone the following problems until you manage to read
    *The Complete Coding Interview Guide in Java*, which provides deep coverage of
    these preliminary topics.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: When we need to handle large amounts of text (for instance, if we were developing
    a text editor or a powerful text search engine), we have to deal with a significant
    number of complex tasks. Among these tasks, we have to consider appending/concatenating
    strings and memory consumption.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rope data structure is a special binary tree that aims to improve string
    operations while using memory efficiently (which is especially useful for large
    strings). Its Big O goals are listed in the following figure:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12.png](img/B19665_05_13.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Big O for Rope'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a binary tree, a Rope can be shaped via the classical `Node` class as
    follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Each node holds pointers to its children (left and right) and the total weight
    of the nodes in its left subtree (`weight`). Leaf nodes store small chunks of
    the large string (`str`). Here is a Rope for the text *I am a very cool rope*:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13.png](img/B19665_05_14.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Rope sample'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s implement the main operations of a Rope, starting with searching
    by index. `Rope` is a static class containing all the following operations.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Implementing indexAt(Node node, int index)
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `indexAt(Node node, int index)` method attempts to find the character at
    the given `index`. This is a recursive process based on a simple rule, as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: If `index > (weight - 1)` then `index = index - weight` and move to the right
    node.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `index < weight` then just move to the left node.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two steps are repeated until we hit a leaf node and we return the character
    at the current `index`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to return the character from `index` 5, which is
    `e` (see *Figure 5.14*):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the root, we have `index` = 5, `index` < 8, so we move left.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `index` = 5, 5 > 3, so `index` = 5 – 3 = 2 and we move right.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `index` = 2, 2 > 1, so `index` = 2 – 1 = 1 and we move right.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right node is a leaf node, so we return `charAt(1)`, which is `e`.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.14.png](img/B19665_05_15.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Implementing indexAt()'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'In code form, this algorithm is quite simple:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Next, let’s talk about concatenating two Ropes.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Implementing concat(Node node1, Node node2)
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Concatenating two Ropes (`node1` and `node2`) is a straightforward step-by-step
    algorithm:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Create a new root node that has the weight of the leaf nodes in `node1`.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new root node has `node1` as its left child and `node2` as its right child.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional rebalancing (this isn’t implemented here, but takes the form of classic
    binary tree rebalancing).
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents the concatenation of two Ropes:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15.png](img/B19665_05_16.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Concatenating two Ropes'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'In code form, we have the following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Next, let’s insert a new node.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Implementing insert(Node node, int index, String str)
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to insert a piece of a string at a certain index in the original string,
    we have to split the original string and perform two concatenations. The algorithm
    has three steps, as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Split the original string at a given index into two strings, `s1` and `s2`.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate `s1` and the given `str` into `s3`.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate `s1` with the new `s3`.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In code form, we get the following implementation:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Next, let’s see how to delete a substring.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Implementing delete(Node node, int start, int end)
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a substring from the original string between `start` and `end` requires
    two splits and one concatenation. The algorithm consists of three steps, as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Split the original string at `start` into `s1` and `s2`.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split `s2` at `end` into `s3` and `s4`.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate `s1` and `s4`.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In code form, we have the following implementation:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Finally, let’s talk about splitting a Rope.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Implementing split(Node node, int index)
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Splitting a Rope into two Ropes is an operation that should come with two considerations:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The split should take place at the last character (index).
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The split should take place at the middle character (index).
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these cases are considered in the implementation listed in the bundled
    code. Since this code is simple but quite large, we skipped it here for brevity.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 120\. Introducing the Skip List data structure
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Skip List data structure is a probabilistic data structure built on top
    of a linked list. A Skip List uses an underlying linked list to keep a sorted
    list of items, but it also provides the capability to skip certain items in order
    to speed up operations such as insert, delete, and find. Its Big O goals are listed
    in the following figure:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16.png](img/B19665_05_17.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Big (O) for Skip List'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'A Skip List has two types of layers. The base layer (or the lower layer, or
    layer 0) consists of a regular linked list that holds the sorted list of all items.
    The rest of the layers contain sparse items and act as an “express line” meant
    to speed up the search, insert, and delete items. The following figure helps us
    to visualize a Skip List with three layers:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17.png](img/B19665_05_18.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Skip List sample'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: So, this Skip List holds on layer 0 the items 1, 2, 3, 4, 5, 8, 9, 10, 11, and
    34 and has two express lines (layer 1 and layer 2) containing sparse items. Next,
    let’s see how we can find a certain item.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Implementing contains(Integer data)
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching certain items starts on layer *n*, continues layer *n*-1, and so on
    until layer 0\. For instance, let’s assume that we want to find item 11.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: We start on layer 2 and continue running on this layer until we find a node
    >= 11\. Since the value 11 doesn’t exist on layer 2, we search for an item less
    than 11 and we find 10.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: We get down on layer 1 and continue searching. Based on the same logic we find
    item 10 again. Layer 1 doesn’t contain item 11 either. If it had contained it,
    then we would have stopped the search.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'We go down again, this time to layer 0 (the base layer containing all items),
    and continue searching until we find item 11\. The following figure depicts our
    search path:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18.png](img/B19665_05_19.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Finding an item in a Skip List'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: By following the highlighted path, we can see that we skipped a significant
    number of items until we found item 11.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'In code form, this operation can be implemented as follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Next, let’s see how we can insert a new item.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Implementing insert(Integer data)
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inserting a new item takes place on a randomly chosen layer. In other words,
    the layer of an item is chosen randomly at insertion time. We can insert it into
    an existing layer or create a new layer specially for this new item. We can create
    new layers until we hit an arbitrary chosen `MAX_NUMBER_OF_LAYERS` (we have `MAX_NUMBER_OF_LAYERS`
    = 10).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'During the insertion algorithm, we apply the following steps to search for
    the proper place for the item to insert:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: If the item of the next node is less than the item to insert, then we continue
    moving forward on the same layer.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the item of the next node is greater than the item to insert, then we save
    the pointer to the current node and continue by moving one layer down. The search
    continues from here.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, we will reach the base layer (layer 0). Since this layer holds
    all items, we know for sure that we will find a slot here for the new item.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, item 7 was inserted on Layer 1:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19.png](img/B19665_05_20.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Inserting an item in a Skip List'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is straightforward:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `incrementLayerNo()` is a method that randomly decides the layer on which
    the new item will be inserted.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Implementing delete(Integer data)
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting an item is a simple operation. We start from the top layer, find the
    item to delete, and then delete it. The challenge is to pay attention to only
    eliminating the item by correctly linking the remaining nodes. The implementation
    is simple:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Challenge yourself to implement a Skip List on top of the Java built-in `LinkedList`.
    It will be fun and give you the chance to explore the Skip List data structure
    a step further.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 121\. Introducing the K-D Tree data structure
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A K-D Tree (also referred to as a K-dimensional tree) is a data structure that
    is a flavor of **Binary Search Tree** (**BST**) dedicated to holding and organizing
    points/coordinates in a K-dimensional space (2-D, 3-D, and so on). Each node of
    a K-D Tree holds a point representing a multi-dimensional space. The following
    snippet shapes a node of a 2-D Tree:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Instead of a `double[]` array, you may prefer `java.awt.geom.Point2D`, which
    is dedicated to representing a location in *(x, y)* coordinate space.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'Commonly, K-D Trees are useful for performing different kinds of searches such
    as nearest-neighbor searches and range queries. For instance, let’s assume a 2-D
    space and a bunch of *(x, y)* coordinates in this space:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can represent these coordinates using the well-known X-Y coordinates system,
    but we can also store them in a K-2D Tree as in the following figure:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20.png](img/B19665_05_21.png)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: A 2D space represented in X-Y coordinates system and K-2D Tree'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: But, how did we build the K-D Tree?
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Inserting into a K-D Tree
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We insert our coordinates (`cords`) one by one starting with `coords[0]` = (3,5).
    The (3,5) pair becomes the root of the K-D Tree. The next pair of coordinates
    is (1,4). We compare *x* of the root with *x* of this pair and we notice that
    1 < 3, which means that (1,4) becomes the left child of the root. The next pair
    is (5,4). At the first level, we compare the *x* of the root with 5 and we see
    that 5 > 3, so (5,4) becomes the right child of the root. The following figure
    illustrates the insertion of (3,5), (1,4), and (5,4).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21.png](img/B19665_05_22.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Inserting (3,5), (1,4), and (5,4)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (2,3). We compare the *x* components of (2,3) and (3,5)
    and we see that 2 < 3, so (2,3) goes to the left of the root. Next, we compare
    the *y* component of (2,3) and (1,4) and we see that 3 < 4, so (2,3) goes to the
    left of (1,4).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (4,2). We compare the *x* components of (4,2) and (3,5)
    and we see that 4 > 3, so (4,2) goes to the right of the root. Next, we compare
    the *y* component of (4,2) and (5,4) and we see that 2 < 4, so (4,2) goes to the
    left of (5,4). The following figure illustrates the insertion of (2, 3), and (4,2).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22.png](img/B19665_05_23.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Inserting (2,3) and (4,2)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (3,2). We compare the *x* components of (3,2) and (3,5)
    and we see that 3 = 3, so (3,2) goes to the right of the root. Next, we compare
    the *y* component of (3,2) and (5,4) and we see that 2 < 4, so (3,2) goes to the
    left of (5,4). Next, we compare the *x* component of (3,2) and (4,2) and we see
    that 3 < 4, so (3,2) goes to the left of (4,2).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (5,2). We compare the *x* components of (5,2) and (3,5)
    and we see that 5 > 3, so (5,2) goes to the right of the root. Next, we compare
    the *y* component of (5,2) and (5,4) and we see that 2 < 4, so (5,2) goes to the
    left of (5,4). Next, we compare the *x* component of (5,2) and (4,2) and we see
    that 5 > 4, so (5,2) goes to the right of (4,2). The following figure outlines
    the insertion of (3,2), and (5,2).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23.png](img/B19665_05_24.png)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Inserting (3,2) and (5,2)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (2,1). We compare the *x* components of (2,1) and (3,5)
    and we see that 2 < 3, so (2,1) goes to the left of the root. Next, we compare
    the *y* component of (2,1) and (1,4) and we see that 1 < 4, so (2,1) goes to the
    left of (1,4). Next, we compare the *x* component of (2,1) and (2,3) and we see
    that 2 = 2, so (2,1) goes to the right of (2,3).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Next, we insert the pair (2,4). We compare the *x* components of (2,4) and (3,5)
    and we see that 2 < 3, so (2,4) goes to the left of the root. Next, we compare
    the *y* component of (2,4) and (1,4) and we see that 4 = 4, so (2,4) goes to the
    right of (1,4).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we insert the pair (2,5). We compare the *x* components of (2,5) and
    (3,5) and we see that 2 < 3, so (2,5) goes to the left of the root. Next, we compare
    the *y* component of (2,5) and (1,4) and we see that 5 > 4, so (2,5) goes to the
    right of (1,4). Next, we compare the *x* component of (2,5) and (2,4) and we see
    that 2 = 2, so (2,5) goes to the right of (2,4). The following figure illustrates
    the insertion of (2,1), (2,4), and (2,5).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24.png](img/B19665_05_25.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Inserting (2,1), (2,4), and (2,5)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'Done! So inserting has two simple rules:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: We compare components alternatively starting with *x*. At level one, we compare
    *x*, at level two, we compare *y*, at level three we compare *x*, at level four
    we compare *y*, and so on.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When comparing (*x1*, *y1*) with (*x2*, *y2*), if *x2*>= *x1* or *y2*>= *y1*
    (depending on which component is being compared) then the (*x2*,*y2*) node goes
    to the right (*x1*,*y1*), otherwise to the left.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these statements, the implementation of a 2-D model is straightforward:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Another approach for inserting in a K-D Tree relies on a sorting algorithm for
    sorting the coordinates. This implementation is not provided here.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Finding the nearest neighbor
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding the nearest neighbor is the classical operation performed on a K-D
    Tree. We have a given point (*x*,*y*), and we want to know what the nearest point
    is from the K-D Tree. For instance, we may want to find the nearest neighbor of
    (4,4) – check the following figure:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25.png](img/B19665_05_26.png)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Find the nearest neighbor of (4,4)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'The nearest neighbor of (4,4) is (5,4). In a nutshell, finding the nearest
    neighbor is about finding the shortest distance from the given point to any other
    point present in the K-D Tree. We start from the root and compute the distance
    between the given point (or target node) and the current node. The shortest distance
    wins. The implementation starts like this:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `nearest()` method is a recursive solution for finding the minimum distance:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the bundled code, you can find the missing parts of the preceding code, such
    as the method for computing the distance between two points.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Searching and deleting items from a K-D Tree is similar to performing these
    operations on a BST, so nothing new.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Challenge yourself to implement a 3-D Tree.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 122\. Introducing the Zipper data structure
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Zipper data structure is meant to facilitate cursor-like navigation capabilities
    over another data structure such as a tree. Moreover, it may provide capabilities
    for manipulating the tree like adding nodes, removing nodes, and so on.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: The Zipper is created on the top of a tree and is characterized by the current
    position of the cursor and the current range or the current visibility area. At
    any moment, the Zipper doesn’t see or act on the entire tree; its actions are
    available only on a subtree or a range of the tree relative to its current position.
    The modification accomplished via the Zipper is visible only in this range, not
    in the entire tree.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to navigate and determine the current range, a Zipper must be aware
    of the tree structure. For instance, it must be aware of all the children of each
    node, which is why we start from an interface that must be implemented by any
    tree that wants to take advantage of a Zipper:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'A tree that implements `Zippable` ensures that it exposes its children to the
    Zipper. For instance, a tree `Node` implementation can be done as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The following figure illustrates the characteristics of a Zipper at some moment
    in time:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26.png](img/B19665_05_27.png)'
  id: totrans-598
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: The Zipper position and range on an arbitrary tree'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: The Zipper’s current position is represented by the node labeled **55** – the
    Zipper cursor is on position 55\. The highlighted gray area is the zipper’s current
    range/visibility. Everything that happens in this area is invisible outside of
    it. From the current position, the Zipper can move `down()`, `up()`, `left()`,
    and `right()`. Every move will refine the Zipper range accordingly.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Zipper is applied to a tree, each node of the tree (`Node`) becomes
    a Zipper-node, represented here by the `ZipNode` class. As you can see in the
    following code, a `ZipNode` acts as a wrapper of a `Node` and represents the unit
    of work for the Zipper:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The remaining code handles the initialization of children in a lazy fashion
    (on demand):'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: All the Zipper operations act on a `ZipNode`, not on a `Node`.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the Zipper range implementation, which basically defines the
    gray part of *Figure 5.27*. We have the parent node and the left/right siblings
    of the current range:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`ZipperRange` works in tandem with `Cursor`, which contains the implementation
    of the Zipper actions (`down()`, `up()`, `left()`, `right()`, `rightMost()`, `leftMost()`,
    `clear()`, `add()`, `addAll()`, `insertLeft()`, `insertRight()`, `remove()`, `removeLeft()`,
    `removeRight()`, and so on):'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Since this code is significantly large, the remainder was skipped here. You
    can find it in the bundled code.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `Zipper` class. This class is used for creating a Zipper
    via the `createZipper()` method. It is also used for recreating/updating the tree
    based on the modifications done via the Zipper. This is done in the `unwrapZipper()`
    method as follows:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In the bundled code, you can find the complete implementation and an example
    of using the Zipper on a given tree.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 123\. Introducing the Binomial Heap data structure
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Binomial Heap data structure is a set composed of Binomial Trees. Each Binomial
    Tree is a Min Heap, which means that it follows the *min-heap* property. In a
    nutshell, a heap is a Min Heap if its items are in descending order, meaning that
    the minimum item is the root (more details are available in *The Complete Coding
    Interview Guide in Java* book).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, a Binomial Tree is ordered and typically defined in a recursive
    fashion. It is denoted as B[k], where k implies the following properties:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: A Binomial Tree has 2^k nodes.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of a Binomial Tree is equal to k.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root of a Binomial Tree has the degree k, which is the greatest degree.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A B[0] Binomial Tree has a single node. A B[1] Binomial Tree has two B[0] Trees,
    and one of them is a left subtree of the other one. A B[2] Tree has two B[1],
    one of which is the left subtree of the other. In general, a B[k] Binomial Tree
    contains two B[k-1] Binomial Trees, one of which is the left subtree of the other
    (two B[k-1] Trees are linked to the composed B[k]). In the following figure, you
    can see B[0], B[1], B[2], B[3], and B[4]:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27.png](img/B19665_05_28.png)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: B[0]-B[4] Binomial Trees'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of a Binomial Heap from a Big O perspective are listed in the following
    figure:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28.png](img/B19665_05_29.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: Big O for Binomial Heap'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, you can see a sample of a Binomial Heap. The roots
    of the Binomial Trees (here, 9, 1, and 7) within a Binomial Heap are represented
    via a linked list referred to as the *root list*.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27.png](img/B19665_05_30.png)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: Binomial Heap sample'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: In other words, as you can easily intuit from this figure, a Binomial Heap is
    an extension (or a flavor) of a Binary Heap, which provides high performance for
    merging or unioning two heaps and is a perfect fit for the task of implementing
    priority queues.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this figure, we can define the skeleton of a Binomial Heap as follows:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If we represent the relevant part of a `Node` as a diagram, we obtain the following
    figure (here, you can see the internal structure of a `Node` for items 11 and
    25):'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30.png](img/B19665_05_31.png)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Expanding a Node'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the main structure of a Binomial Heap, let’s cover several
    operations.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: Implementing insert(int key)
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inserting a new key into a Binomial Heap is a two-step operation. In the first
    step, we create a new heap containing only the given key (a `Node` wrapping the
    given key). Second, we union the current heap with this newly created heap as
    follows:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The union operation is depicted as the last operation of this problem.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Implementing findMin()
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding the minimum key of a Binomial Heap requires us to loop through the
    *root list* (which is a linked list) and find the smallest key. This can be optimized
    from *O(log n)* to *O(1)* if we decide to maintain a pointer to the minimum root.
    However, the *O(log n)* approach is listed here:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Since our Binomial Heap holds primitive integers, we use `Integer.MIN_VALUE`
    as an equivalent to “no value.” If you adjust the implementation to use `Integer`
    or generic `T`, then you can replace `Integer.MIN_VALUE` with `null`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Implementing extractMin()
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before extracting the minimum key, we have to find it. Afterward, we delete
    it. Finally, we have to union the resulting subtrees as follows:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `deleteTreeRoot()` is a helper method useful for deleting the given root
    and performing a union on the remaining sub-trees:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Implementing decreaseKey(int key, int newKey)
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decreasing a key value means replacing an existing key with a smaller one.
    When this operation happens, the new key may be smaller than the key of its parent,
    which means that the *min-heap* property is violated. This scenario requires us
    to swap the current node with its parent, its parent with its grandparent, and
    so on until we reestablish compliance with the *min-heap* property. The implementation
    starts as follows:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `goUp()` method is a helper method used to reestablish the *min-heap* property:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: As you will see next, this helper is useful for deleting a node as well.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Implementing delete(int key)
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deleting a key is done by first finding the corresponding `Node` and decreasing
    it to the minimum (`Integer.MIN_VALUE`). Next, we delete the minimum from the
    heap and connect the remaining sub-trees. The implementation relies on the `goUp()`
    and `deleteTreeRoot()` helpers listed in the previous sections:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Finally, let’s talk about union heaps.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Implementing unionHeap(BinomialHeap heap)
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider two Binomial Heaps (H1 and H2). The goal of the union operation is
    to create H3 by unifying H1 with H2\. Let’s assume that H1 (having a conventional
    string representation used by our application as 31 22 [ 40 ] 8 [ 13 [ 24 ] 11
    ]) and H2 (55 24 [ 45 ] 3 [ 7 [ 29 [ 40 ] 9 ] 5 [ 37 ] 18 ]) are those from the
    following figure:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31.png](img/B19665_05_32.png)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.32: Two Binomial Heaps, H1 and H2'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract of unification starts with an initial merging of H1 and H2 in
    the order of their degrees. In our case, the merge operation produces the following
    output:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32.png](img/B19665_05_33.png)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.33: Merging H1 and H2'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'This operation is performed by the following helper method:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Next, we need to combine the Binomial Trees of the same order. While we traverse
    the roots of the merged heaps (here, 31, 55, 22, 24, 8, and 3), we use three pointers
    denoted as PREV-X (the previous node of the current node), X (the current node),
    and NEXT-X (the next node of the current node). These pointers help us to solve
    the following four cases:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '*Case 1*: X and NEXT-X have different orders. In this case, we just move the
    X pointer ahead.'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Case 2*: X, NEXT-X, and NEXT-NEXT-X have the same order. In this case, we
    just move the X pointer ahead.'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Case 3*: X and NEXT-X have the same order, different from NEXT-NEXT-X. And
    if X.KEY<= NEXT-X.KEY, then NEXT-X becomes the child of X.'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Case 4*: X and NEXT-X have the same order, different from NEXT-NEXT-X. And
    if X.KEY>NEXT-X.KEY, then X becomes the child of NEXT-X.'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we apply these four cases to our example, we notice that after merging H1
    and H2, we are in *Case 3* since X and NEXT-X have the same order (B[0]), which
    is different from the order of NEXT-NEXT-X (which is B[1]) and X.KEY = 31 < 55
    = NEXT-X.KEY. So, NEXT-X becomes the child of X, as in the following figure:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33.png](img/B19665_05_34.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.34: Applying Case 3'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, we notice that X, NEXT-X, and NEXT-NEXT-X have the same order
    B[1]. This means that we are in *Case 2*, so we have to move the X pointer forward,
    as in the following figure:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34.png](img/B19665_05_35.png)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.35: Applying Case 2'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are in *Case 3* again. We see that X and NEXT-X have the same order
    (B[1]), which is different from the order of NEXT-NEXT-X (B[2]). And, we also
    see that X.KEY = 22 < 24 = NEXT-X.KEY, so NEXT-X becomes the child of X, as in
    the following figure:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35.png](img/B19665_05_36.png)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.36: Applying Case 3 again'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are in *Case 4*. We see that X and NEXT-X have the same order (B[2])
    which is different from the order of NEXT-NEXT-X (B[3]). And, we also see that
    X.KEY = 22 > 8 = NEXT-X.KEY, so X becomes the child of NEXT-X, as in the following
    figure:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36.png](img/B19665_05_37.png)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.37: Applying Case 4'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are in *Case 4* again. We see that X and NEXT-X have the same order
    (B[3]), which is different from the order of NEXT-NEXT-X (null). And, we also
    see that X.KEY = 8 > 3 = NEXT-X.KEY, so X becomes the child of NEXT-X, as in the
    following figure:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37.png](img/B19665_05_38.png)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.38: Applying Case 4 again'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: At this point, none of the four cases is valid so this is the final form of
    the Binomial Heap.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this example, we can implement the union operation as follows (notice
    the highlighted cases in the following code):'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `linkNodes()` method is a helper method that links the current node with
    the next node:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Done! You can find the complete application in the bundled code.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 124\. Introducing the Fibonacci Heap data structure
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Fibonacci Heap is a flavor of Binomial Heap with excellent performance in
    *amortized time* for operations such as insert, extract minimum, and merge. It
    is an optimal choice for implementing priority queues. A Fibonacci Heap is made
    of trees, and each tree has a single root and multiple children arranged in a
    heap-ordered fashion. The root node with the smallest key is always placed at
    the beginning of the list of trees.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: It is called a Fibonacci Heap because each tree of order *k* has at least F[k+2]
    nodes, where F[k+2] is the (*k*+2)^(th) Fibonacci number.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a Fibonacci Heap sample:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39.png](img/B19665_05_39.png)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.39: Fibonacci Heap sample'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'The main operations in a Fibonacci Heap are (Big O represents the *amortized
    time*): insert (O(1)), decrease key (O(1)), find the minimum (O(1)), extract minimum
    (O(log n)), deletion (O(log n)), and merge (O(1)). You can find an implementation
    of these operations in the bundled code.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 125\. Introducing the Pairing Heap data structure
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pairing Heap is a flavor of Binomial Heap with the capability of self-adjusting/rearranging
    to keep itself balanced. It has very good performance in *amortized time* and
    is a good fit for the task of implementing priority queues.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: A Pairing Heap is a pairing tree with a root and children. Each heap of a Pairing
    Heap represents a value and has a set of children that are also heaps. The value
    of a heap is always less than (*min-heap* property) or greater than (*max-heap*
    property) the value of its children heaps.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a Min Pairing Heap:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38.png](img/B19665_05_40.png)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.40: A Min Pairing Heap sample'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'The main operations in a Pairing Heap are: insert (O(1)), decrease key (actual
    time: O(1), amortized time O(log n)), find the minimum (O(1)), extract the minimum
    (actual time: O(n), amortized time (O (log n)), and merge (actual time: O(1),
    amortized time (O(log n)). You can find an implementation of these operations
    in the bundled code.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 126\. Introducing the Huffman Coding data structure
  id: totrans-708
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Huffman Coding algorithm was developed by David A. Huffman in 1950 and can
    easily be understood via an example. Let’s assume that we have the string shown
    in the following figure.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40.png](img/B19665_05_41.png)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.41: Initial string'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that each character needs 8 bits to be represented. Since we have
    14 characters, we can say that we need 8*14=112 bits to send this string over
    a network.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Encoding the string
  id: totrans-713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of Huffman Coding is to compress (shrink) such strings to a smaller
    size. For this, we create a tree of character frequencies. A `Node` of this tree
    can be shaped as follows:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'For instance, the following figure shows the calculation of the frequency of
    each character from our string in ascending order:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41.png](img/B19665_05_42.png)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.42: Calculating the frequency of each character'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'After sorting, these characters are stored in a **priority queue** (**PQ**).
    Each character will become a leaf node in a tree by following several steps:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1*: Create a node with two children (a partial tree). The left child
    holds the minimum frequency, and the right child holds the next minimum frequency.
    The node itself holds the sum of its left and right children.'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 2*: Remove these two frequencies from the PQ.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 3*: Insert this partial tree into the PQ.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Step 4*: Repeat steps 1-3 until the PQ is empty and we obtain a single tree
    from these partial trees.'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we apply *steps 1-3* twice, we obtain the following figure:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42.png](img/B19665_05_43.png)'
  id: totrans-725
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.43: Applying steps 1-3 twice'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'In code form, these steps appear as follows:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'By repeating these steps until the PQ is empty, we obtain the final tree. Next,
    for each node of this tree that is not a leaf, we assign the value 0 to the left
    edge and 1 to the right edge. This is the encoding step that can be coded as follows:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The final result looks like this:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.43.png](img/B19665_05_44.png)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.44: The final tree'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, sending this tree over the network will send the compressed string. The
    next figure gives us the new size of this string:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.44.png](img/B19665_05_45.png)'
  id: totrans-735
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.45: The size of the compressed string'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: So, we reduce the size of the string from 112 bits to 41 bits. This is the compressed
    or encoded string.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the string
  id: totrans-738
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decoding the string is a simple step. We take each code and traverse the tree
    to find the assigned character. For instance, we take *0111* and we find *d*,
    we take *110* and we find *a*, and so on. Decoding can be implemented as follows:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: After processing all of the code, we should obtain the decoded string.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 127\. Introducing the Splay Tree data structure
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Splay Tree is a flavor of **Binary Search Tree** (**BST**). Its particularity
    consists of the fact that it is a self-balancing tree that places the recently
    accessed items at the root level.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: The *splaying* operation or *splaying* an item is a process that relies on tree
    rotations meant to bring the item to the root position. Every operation on the
    tree is followed by *splaying*.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: So, the goal of *splaying* is to bring the most recently used item closer to
    the root. This means that subsequent operations on these items will be performed
    faster.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: 'The *splaying* operation relies on six rotations:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: Zig rotation – the tree rotates to the right (every node rotates to the right)
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zag rotation – the tree rotates to the left (every node rotates to the left)
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zig-Zig rotation – double Zig rotation (every node moves twice to the right)
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zag-Zag rotation – double Zag rotation (every node moves twice to the left)
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zig-Zag rotation – a Zig rotation followed by a Zag
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zag-Zig rotation – a Zag rotation followed by a Zig
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the bundled code, you can find an implementation of a Splay Tree. Moreover,
    you can use this visualizer: [https://www.cs.usfca.edu/~galles/visualization/SplayTree.html](https://www.cs.usfca.edu/~galles/visualization/SplayTree.html).'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 128\. Introducing the Interval Tree data structure
  id: totrans-754
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Interval Tree is a flavor of **Binary Search Tree** (**BST**). Its particularity
    consists of the fact that it holds intervals of values. Beside the interval itself,
    a `Node` of an Interval Tree holds the maximum value of the current interval and
    the maximum value of the subtree rooted with this `Node`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 'In code form, an Interval Tree is shaped as follows:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Let’s consider that we have the following intervals of integers: [4, 7], [1,
    10], [7, 23], [6, 8], [9, 13], and [2, 24].'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Implementing insert(Interval interval)
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first interval ([4, 7]) becomes the root of the tree. Next, we compare the
    interval [1, 10] to [4, 7] by comparing the left side of the interval. Since 1
    < 4, the interval [1, 10] goes to the left of the root.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compare the interval [7, 23] with [4, 7]. Since 7 > 4, the interval
    [7, 23] goes to the right of [4, 7]. Applying the same logic for the rest of the
    interval will result in the following tree:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.45.png](img/B19665_05_46.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.46: The interval tree'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous logic (insert operation, O(log n)) is materialized in code form
    as follows:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Other operations specific to an interval tree are searching the intervals that
    overlap the given interval (O(log n)) and deleting (O (log n)). You can find the
    implementations in the bundled code.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 129\. Introducing the Unrolled Linked List data structure
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Unrolled Linked List is a flavor of a linked list that stores arrays (multiple
    items). Each node of an Unrolled Linked List can store an array. It is like combining
    the powers of an array with those of a linked list. In other words, an Unrolled
    Linked List is a data structure with a low memory footprint and high performance
    on insertion and deletion.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: Insertion and deletion from an Unrolled Linked List have different implementations.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can insert arrays (`insert(int[] arr)`), which means that for
    each insertion, we create a new node and insert that array into it.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an item is equivalent to removing the item from the specified index
    in the proper array. If, after deletion, the array is empty, then it is removed
    from the list as well.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Another approach assumes that the Unrolled Linked List has a fixed capacity
    (each node holds an array of this capacity). Further, we insert items one by one
    by following a low-water mark of 50%. This means that if we insert an item that
    cannot be added to the current node (array), then we create a new node and insert
    into it half of the original node’s items plus this item.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an item uses the reverse logic. If the number of items in a node drops
    below 50%, then we move the items from the neighboring array over to get back
    to a low-water mark above 50%. If the neighboring array also drops below 50%,
    then we have to merge these two nodes.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find both approaches in the bundled code. On the other hand, you can
    challenge yourself to provide an Unrolled Linked List implementation that extends
    the JVM Collections API. You can start from either of the following two approaches:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Add this implementation to your GitHub portfolio and you’ll impress your interviewer.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 130\. Implementing join algorithms
  id: totrans-777
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join algorithms are typically used in databases, mainly when we have two tables
    in a one-to-many relationship and we want to fetch a result set containing this
    mapping based on a join predicate. In the following figure, we have the `author`
    and `book` tables. An author can have multiple books and we want to join these
    tables to obtain a result set as the third table.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.46.png](img/B19665_05_47.png)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.47: Joining two tables (author and book)'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three popular join algorithms for solving this problem: Nested Loop
    Join, Hash Join, and Sort Merge Join. While databases are optimized to choose
    the most appropriate join for the given query, let’s try to implement them in
    plain Java on the following two tables expressed as records:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Our goal is to join the `Author` and `Book` records by matching the `Author.authorId`
    and `Book.authorId` attributes. The result should be a projection (`ResultRow`)
    that contains `authorId`, `name`, `title`, and `bookId`:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Next, let’s talk about Nested Loop Join.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Nested Loop Join
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Nested Loop Join algorithm relies on two loops that traverse both relations
    to find records that match the joining predicate:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The time complexity of this algorithm is O(n*m) where *n* is the size of `authorsTable`
    and *m* is the size of `booksTable`. This is quadratic complexity, which makes
    this algorithm useful only for small datasets.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Hash Join
  id: totrans-790
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, Hash Join relies on *hashing*. So, we have to create
    a hash table from the authors table (the table with fewer records) and afterward
    we loop through the books table to find their authors in the created hash table
    as follows:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The time complexity of this algorithm is O(n+m), where *n* is the size of `authorsTable`
    and *m* is the size of `booksTable`. So, this is better than Nested Loop Join.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: Sort Merge Join
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, Sort Merge Join starts by sorting the two tables by the
    attribute of the join. Afterward, we loop the two tables and apply the join predicate
    as follows:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The time complexity of the Sort Merge Join algorithm is O(nlog(n) + mlog(m))
    where *n* is the size of `authorsTable` and *m* is the size of `booksTable`. So,
    this is better than Nested Loop Join and Hash Join.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of interesting topics. We started with the
    new Vector API for empowering parallel data processing, then we continued with
    a bunch of cool data structures like Zipper, K-D Trees, Skip List, Binomial Heap,
    and so on. We finished with a nice overview of the three main join algorithms.
    Moreover, we’ve covered the JDK 21 Sequenced Collections API.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
