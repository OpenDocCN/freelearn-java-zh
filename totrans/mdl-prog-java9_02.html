<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating Your First Java Module</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we took a detailed look at the problems associated with modularizing Java code pre-Java 9, as well as the new module construct in Java 9 and <em class="calibre22">Project Jigsaw</em>. Before we examine how Java modularity solves these problems, you'll need to first understand what a Java module looks like. In this chapter, you'll create your first Java 9 module and learn what it takes to build and execute code in a Java module. Here are the top-level topics you'll be learning in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">Setting up the JDK with Java 9</li>
<li class="calibre15">Creating a new Java 9 module</li>
<li class="calibre15">Defining a module (using <kbd class="calibre12">module-info.java</kbd>)</li>
<li class="calibre15">Compiling and executing a module</li>
<li class="calibre15">Handling possible errors</li>
</ul>
<p class="calibre2">You'll be building a sample Java 9 application throughout this book as you learn the different concepts related to modularity. The application you'll build is an address book viewer application that displays some contacts sorted by last name. We'll start simple and enhance this application as we go. When you are done with this chapter, you'll have built your first Java 9 module and learned how to compile and execute it. Let's start by first installing the JDK.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the JDK</h1>
                
            
            <article>
                
<p class="calibre2">In order to write Java 9 code, you'll first need to download and install the Java 9 SDK (referred to as the Java Development Kit or JDK). In this book, we'll be using the <strong class="calibre1">OpenJDK</strong> build available at <a href="http://jdk.java.net/9/" class="calibre4"><span>http://jdk.java.net/9/</span></a>. When you navigate to the URL, you'll see a list of available downloads based on the platform you are using, as shown here:</p>
<div class="packt_figure"><img class="image-border8" src="../images/00013.jpeg"/></div>
<p class="calibre2">Make sure you choose the download for your platform in the <strong class="calibre1">JDK</strong> column, not the <strong class="calibre1">JRE</strong> column. After accepting the license agreement, you should be able to download an installer for your platform. Run the installer and choose the defaults; after this, you should have JDK 9 installed in your machine:</p>
<div class="packt_figure"><img class="image-border9" src="../images/00014.jpeg"/></div>
<p class="calibre2">After the installation is complete, it's a good idea to verify that the JDK installation and configuration process completed successfully. You do that by opening a <strong class="calibre1"><span>Command Prompt</span></strong> or terminal window. Type the command <kbd class="calibre12">java -version</kbd> to output the version of the <kbd class="calibre12">java</kbd> command currently in the <kbd class="calibre12">PATH</kbd>:</p>
<div class="packt_infobox">Note that the installer adds the location of the installed Java binaries to your system <kbd class="calibre28">PATH</kbd> variable, which is why this command works.</div>
<div class="packt_figure"><img class="image-border10" src="../images/00015.jpeg"/></div>
<p class="calibre2">Additionally, you can also make sure that the <kbd class="calibre12">JAVA_HOME</kbd> value is set.</p>
<p class="calibre2">On macOS/Linux, type the command <kbd class="calibre12">echo $JAVA_HOME</kbd> and make sure the path to the JDK 9 installation is returned:</p>
<div class="packt_figure"><img class="image-border11" src="../images/00016.jpeg"/></div>
<p class="calibre2">On Windows, right-click on <span>My Computer</span>, click <span>Properties</span>, and switch to the <span>Advanced</span> tab. Here, click <span>Environment Variables</span> and view the value for the variable <kbd class="calibre12">JAVA_HOME</kbd>. It should point to the location you've chosen to install the JDK. For example, the location could be something like <kbd class="calibre12">C:\Program Files\Java\jdk9</kbd>.</p>
<p class="calibre2">With this, you've now successfully installed JDK 9 and you are all set to start coding in Java 9!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Switching between JDKs</h1>
                
            
            <article>
                
<p class="calibre2">Once you've installed a newer version of the JDK with an earlier version already installed, it is possible to switch what the currently selected version is.</p>
<p class="calibre2">On macOS and Linux, you do this by switching the value of <kbd class="calibre12">JAVA_HOME</kbd></p>
<p class="calibre2">The following command switches the current Java platform to Java 8:</p>
<pre class="calibre23"><strong class="calibre1">$ export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</strong></pre>
<p class="calibre2">To switch to Java 9, use the following command:</p>
<pre class="calibre23"><strong class="calibre1">$ export JAVA_HOME=$(/usr/libexec/java_home -v 9)</strong></pre>
<div class="packt_infobox">With this command, you are passing the Java version of choice to the <kbd class="calibre28">-v</kbd> parameter. But, note that the format is different between Java 8 and 9. With Java 8, the version string is <kbd class="calibre28">1.8</kbd>. With Java 9, the version string is just <kbd class="calibre28">9</kbd>. Traditionally, Java has been using the <kbd class="calibre28">1.X</kbd> version format, for example, Java version 7 had the version string <kbd class="calibre28">1.7</kbd>. This is being changed from Java 9 onward. The idea is that subsequent releases of Java will drop the <kbd class="calibre28">1.X</kbd> format and just use a single number to denote the format. So it's Java 9, not Java 1.9.<br class="calibre25"/>
<br class="calibre25"/>
It's about time this was changed! Imagine the confusion Java 10 would have caused!</div>
<p class="calibre2">On Windows, you switch JDK versions by changing the <kbd class="calibre12">JAVA_HOME</kbd> and <kbd class="calibre12">PATH</kbd> variables. Follow the same steps as earlier to get to the <span>Environment Variables</span> section. Update the value of <kbd class="calibre12">JAVA_HOME</kbd> to point to the location where the version you need is installed. Also, make sure the <kbd class="calibre12">PATH</kbd> is updated to point to the corresponding folder for the Java version you'd like to switch to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the NetBeans IDE</h1>
                
            
            <article>
                
<p class="calibre2">In order to write and follow the code in this book, you don't <em class="calibre22">have</em> to use any <strong class="calibre1">integrated development environments</strong> (<strong class="calibre1">IDEs</strong>). This book will cover writing, compiling, and executing code manually using the command line. You can write code using a text editor of your choice. The code samples accompanying this book also work with the steps and commands showcased in this book.</p>
<p class="calibre2">You could also follow along with an IDE. At the time of writing, NetBeans and IntelliJ Idea has growing support for Java modular projects, with Eclipse support under development. This chapter outlines the steps to create a modular project in NetBeans, should you choose to use the NetBeans IDE. To set it up, in addition to following the steps to set up Java, make sure you install the latest version of NetBeans with Java 9 module support by going to <a href="https://netbeans.org/downloads/" class="calibre4"><span>https://netbeans.org/downloads/</span></a> and choosing either the Java SE or the Java EE version to download:</p>
<div class="packt_figure"><img class="image-border12" src="../images/00017.jpeg"/></div>
<p class="calibre2">Note that if the release version of NetBeans does not yet support Java 9 when you read this, you might have to download an early access copy here: <a href="http://bits.netbeans.org/download/trunk/nightly/latest/" class="calibre4">http://bits.netbeans.org/download/trunk/nightly/latest/</a>. Once you download the installer and execute it, you should have a shiny new copy of NetBeans on your computer ready for you to use.</p>
<div class="packt_infobox">Most veteran Java programmers would acknowledge that it has been a while since they have created folder structures by hand for their Java projects. The Java language has benefitted from incredibly useful tooling support over the years. IDEs such as Eclipse, NetBeans, and IntelliJ IDEA make it such a breeze to create source and package folders that developers don't even tend to think about those aspects of code organization too often. However, in this chapter, and in fact in the rest of the book, we will learn how to build folders and files by hand, as well as compile and run the code by executing commands manually from the command line. This is because IDEs, as convenient as they might be, tend to hide the details and workings around the process of structuring and compiling code. We intend to examine how Java 9 modules work, and the fundamental workings of the code structure, as well as compiling and linking commands, are essential to mastering these concepts.<br class="calibre25"/>
<br class="calibre25"/>
While the prospect of writing Java code without an IDE might seem daunting, let me assure you that this is something you'll likely get used to very quickly. You'll learn the steps to build and execute modular Java 9 code in this chapter, and then it's just a matter of applying the same steps independent of the complexity of the code base itself.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java 9 modules</h1>
                
            
            <article>
                
<p class="calibre2">When writing an application in Java 9, you are ideally creating a modular application. It's important to note that a modular Java application isn't just a regular Java application (like those we've been building all these years) with just an extra module feature thrown in. It actually calls for a completely new way of thinking about writing and structuring your code base. Before we get into creating Java 9 modules, let's do a quick recap of the traditional Java code structure pre-Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Traditional Java code structure</h1>
                
            
            <article>
                
<p class="calibre2">Traditionally, writing a Java application starts with creating one or more source directories. These are special directories that serve two purposes--firstly, they act as root locations of your Java source code and secondly, the contents of these directories are added to the class path. So, the steps to organize source code have typically been:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Create one or more source folders.</li>
<li value="2" class="calibre15">In a source folder, create package folders to mirror the package name.</li>
<li value="3" class="calibre15">Place the <kbd class="calibre12">.java</kbd> files in the right package folders:</li>
</ol>
<div class="packt_figure"><img class="image-border13" src="../images/00018.jpeg"/></div>
<p class="calibre2">Many Java developers use the directory structure <kbd class="calibre12">src/main/java</kbd> for the source directory. So, for example, a class <kbd class="calibre12">Main.java</kbd> in the package <kbd class="calibre12">com.acme.app</kbd> would have the overall path <kbd class="calibre12">src/main/java/com/acme/app/Main.java</kbd>:</p>
<p class="calibre2"> </p>
<div class="packt_figure"><img class="image-border14" src="../images/00019.jpeg"/></div>
<p class="calibre2">This is how source code in Java has typically been organized by developers for many years now. With Java 9 modules, there's a change in the way we approach structuring and writing code. Let's switch gears and examine what a module in Java 9 looks like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is a module?</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre22">module</em> is a new construct that has been introduced into the Java 9 programming language. Think of modules as first-class citizens and as new program components in the language, just like classes or packages. A Java 9 module is a named, self-describing collection of code and data that you can create and use in Java applications. A module can contain any number of Java packages that in turn contain Java code elements, such as classes or interfaces. A Java module can also contain files such as resource files or property files. An application is built by bringing together a collection of these modules. The analogy of building blocks applies well here--a module is a building block that exists on its own, but can be a part of a bigger whole.</p>
<p class="calibre2">With Java 9 modular programming, we move away from building applications as monolithic code bases and instead look to break down the problem into modules. In other words, rather than having one big Java project, you create several modular units that work together to form an application.</p>
<p class="calibre2">This significantly influences how you design and code your application. In Java 8 and earlier, your design process involved breaking down the problem into classes and packages. In Java 9, you first break the problem down into modules. These modules are ideally components that are reusable with a clear interface (inputs and outputs) and solve a specific part of the problem. Inside each module, however, the process of designing and writing code is, more or less, business as usual with packages, classes, interfaces, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a module</h1>
                
            
            <article>
                
<p class="calibre2">Here are the steps to create a module in Java 9. Before you start with <em class="calibre22">step 1</em>, I should mention an obvious starting point--<em class="calibre22">step 0</em>: Know what the module's purpose is. Before you begin creating a module, you should have a clear idea of what the module is for. Remember the important tenet of modular development here! Rather than having one large code base for your application, you instead break the problem down into reusable subprojects. Think <em class="calibre22">reusable libraries</em>. The main difference is that rather than the libraries just being separate JARs that are nothing more than a collection of Java packages and types, we are leveraging the concept of Java modules to group those packages and types:</p>
<ol class="calibre17">
<li value="1" class="calibre15"><strong class="calibre1">Assign a module name</strong>: The first step to creating a module is to come up with a unique name for the module. The name should ideally describe what the module is about and the problem it solves. A Java module name should be a valid Java identifier, so you cannot use certain characters, such as hyphens and slashes. A valid package name is also a valid module name. But apart from that, any name will do as long as it is unique in an application. However, to avoid clashing names, you don't want to call a module something very generic, such as <kbd class="calibre12">util</kbd>.</li>
</ol>
<p class="calibre24">The recommended practice is to use the same convention that has worked well all these years for package names in Java--using the reverse domain name pattern. It's also recommended that you use all lowercase naming for modules, just like packages. So, for example, if you are writing a String utilities module for Acme Corp, the name of the module could be something such as <kbd class="calibre12">com.acme.stringutil</kbd>.</p>
<ol start="2" class="calibre17">
<li value="2" class="calibre15"><strong class="calibre1">Create a module root folder</strong>: Every Java module resides in its own folder, which acts as the top-level folder for the module and contains all the assets of the module. This folder is called the <strong class="calibre1">module root</strong> folder. The module root folder has the same name as the module. So, the root folder for the aforementioned example module has the name <kbd class="calibre12">com.acme.stringutil</kbd>. It is named exactly the same as the module name, including the periods, if any.</li>
</ol>
<ol start="3" class="calibre17">
<li value="3" class="calibre15"><strong class="calibre1">Add the module code</strong>: Inside the module root folder goes the code that belongs to the module. This begins with packages, so you start your package folders from the module root folder onward. So, if your module <kbd class="calibre12">com.acme.stringutil</kbd> has the class <kbd class="calibre12">StringUtil.java</kbd> in the package <kbd class="calibre12">com.acme.util</kbd>, the folder structure should look like this:
<div class="packt_figure"><img class="image-border15" src="../images/00020.jpeg"/></div>
</li>
</ol>
<p class="calibre24">Note the difference in the file structure from the pre-Java 9 structure that we looked at before. What used to go directly into the source folders in earlier versions of Java now goes into the module root folder. As you can see from the following table, with Java 9 there's just an additional folder level with the module root folders. From the module root folder onward, there's nothing new in the way Java types are organized:</p>
<table class="msotablegrid">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">The Java 8 (and earlier) way</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">The Java 9 way</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2">1. Create one or more source folders.</p>
<p class="calibre2">2. In a source folder, create package folders to mirror the package name.</p>
<p class="calibre2">3. Place the <kbd class="calibre12">.java</kbd> files in the right package folders.</p>
</td>
<td class="calibre8">
<p class="calibre2">1. Create one or more source folders.</p>
<p class="calibre2">2. In a source folder, create a module folder for each module.</p>
<p class="calibre2">3. In the module folders, create package folders to mirror the package name.</p>
<p class="calibre2">4. Place the <kbd class="calibre12">.java</kbd> files in the right package folders.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre24">Here's a diagram representing the code structure with the modules:</p>
<div class="packt_figure"><img class="image-border16" src="../images/00021.jpeg"/></div>
<ol start="4" class="calibre17">
<li value="4" class="calibre15"><strong class="calibre1">Create and configure the module descriptor</strong>: Here's the final step! Every module comes with a file that describes it and contains metadata about the module. This file is called the module descriptor. This file contains information about the module, such as what it requires (the inputs to the module) and what the module exports (the outputs from the module). The module descriptor is always located directly at the module root folder, and it is always given the name <kbd class="calibre12">module-info.java</kbd>. That's right! A module descriptor file is actually a <kbd class="calibre12">.java</kbd> file. What do the contents of this module descriptor file look like?</li>
</ol>
<p class="calibre24">Here is a barebones and minimal module descriptor for the example module--<kbd class="calibre12">com.acme.stringutil</kbd>:</p>
<pre class="calibre23">        module com.acme.stringutil { 
 
        } </pre>
<p class="calibre24">The file starts with the <kbd class="calibre12">module</kbd> keyword followed by the module name and curly braces. The curly brace structure resembles other Java type declarations you should be familiar with. Note that the name of the module (following the <kbd class="calibre12">module</kbd> keyword) should exactly match the name of the module root folder.</p>
<p class="calibre24">Within the curly braces, you can optionally specify the metadata (the inputs and outputs) of the module. In the preceding example, the module descriptor is essentially <em class="calibre22">empty</em>, with nothing between the curly braces. For any real-world module you create, you will more than likely add some metadata here to configure the behavior of the module. We'll cover this metadata in more detail in <a target="_blank" href="part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 3</span></a>, <em class="calibre22">Handling Inter-Module Dependencies</em>, but what you can see in the example is the bare minimum <em class="calibre22">necessary and sufficient</em> content needed for the module descriptor.</p>
<p class="calibre24">With the module descriptor file in the <strong class="calibre1">module root</strong>, this is the folder and file structure for our simple module:</p>
<div class="packt_figure"><img class="image-border17" src="../images/00022.jpeg"/></div>
<p class="calibre2">For someone used to writing Java classes, the name of the <kbd class="calibre12">module-info.java</kbd> file might seem a bit odd at first. This is because of a couple of reasons:</p>
<ul class="calibre14">
<li class="calibre15">The <kbd class="calibre12">-</kbd> character here isn't a valid identifier to be used in a Java type name, and nor is it valid for the name of a <kbd class="calibre12">.java</kbd> file</li>
<li class="calibre15">The name of the <kbd class="calibre12">.java</kbd> file usually matches the name of the public type contained in the file, but in this case, it doesn't</li>
</ul>
<p class="calibre24">However, some Java developers might also find this familiar, having used a similar-looking file name that has been used in Java since Java 1.5--<kbd class="calibre12">package-info.java</kbd>. The <kbd class="calibre12">package-info.java</kbd> file is used to specify package-level configuration and annotations, and has been used for many years now, although not very widely. Both <kbd class="calibre12">module-info.java</kbd> and <kbd class="calibre12">package-info.java</kbd> files have intentionally been given <em class="calibre22">invalid</em> Java type names in order to convey their special meaning and purpose, and to separate them from the other Java types and files you'd normally create in the process of building your application.</p>
<p class="calibre2">Steps <strong class="calibre1">1</strong> to <strong class="calibre1">4</strong> in the preceding method are the four necessary steps required to create a module. Let's put these steps into action by creating an addressbook viewer application using the Java 9 modular application approach. This is a simple application that helps you view a set of contact information. Nothing too complex, but just enough for us to put all the Java modularity concepts we learn in this book into practice!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating your first Java module</h1>
                
            
            <article>
                
<p class="calibre2">Let's start by creating our first Java 9 module and walk through the process of coding, compiling, and executing a module. Ideally, any application should consist of multiple modules, but in this chapter, we'll start small. In this chapter, we'll create just <strong class="calibre1">one</strong> module called <kbd class="calibre12">packt.addressbook</kbd>. This will be our first Java module. Over the next few chapters, we'll break this down into multiple modules.</p>
<p class="calibre2">We'll obviously need to start with the folder where all our code resides. In the screenshots in this book, I've chosen the path <kbd class="calibre12">&lt;home&gt;/code/java9</kbd>, but you can feel free to use any path of your preference. I'll be referring to this folder as the project root folder throughout this book.</p>
<p class="calibre2">We've just learned the four steps required to create any Java module. Let's run through those four steps for the <kbd class="calibre12">addressbook</kbd> module now:</p>
<ol class="calibre17">
<li value="1" class="calibre15"><strong class="calibre1">Name the module</strong>: We've already done this! The name of our <kbd class="calibre12">addressbook</kbd> module is <kbd class="calibre12">packt.addressbook</kbd>.</li>
</ol>
<ol start="2" class="calibre17">
<li value="2" class="calibre15"><strong class="calibre1">Create a module root folder</strong>: You'll now need to create one module folder for each module you intend to write. Since we are creating only one module called <kbd class="calibre12">packt.addressbook</kbd>, we create a folder with the same name. I recommend keeping all your Java source files in a separate folder called <kbd class="calibre12">src</kbd> in the project root folder. You'll then create all your module root folders in the <kbd class="calibre12">src</kbd> folder. Since my project root is <kbd class="calibre12">~/code/java9</kbd>, the module root folder resides at <kbd class="calibre12">~/code/java9/src/packt.addressbook</kbd>. This <kbd class="calibre12">packt.addressbook</kbd> folder is where all the packages and Java files of the module reside.</li>
<li value="3" class="calibre15"><strong class="calibre1">Add code to the module</strong>: This step is business as usual for Java developers. From the module root folder onward, your folder structure reflects your package. For our first attempt, let's write a simple <em class="calibre22">Hello World</em> application. Create a Java file called <kbd class="calibre12">Main.java</kbd> in the package <kbd class="calibre12">packt.addressbook</kbd>. The complete path for <kbd class="calibre12">Main.java</kbd> is <kbd class="calibre12">~/code/java9/src/packt.addressbook/packt/addressbook/Main.java</kbd>. Let's add a main method that just prints a message to the console:</li>
</ol>
<pre class="calibre23">        package packt.addressbook; 
        public class Main { 
          public static void main(String[] args) { 
            System.out.println("Hello World!"); 
          } 
        } </pre>
<div class="packt_infobox1">Note that the actual difference from the previous Java 8 directory structure is the introduction of the module root folder. It's helpful to think about each module as a <em class="calibre29">subproject</em> of sorts. The package structure begins from the module root folder onward.</div>
<ol start="4" class="calibre17">
<li value="4" class="calibre15"><strong class="calibre1">Create a module descriptor</strong>: Create a file called <kbd class="calibre12">module-info.java</kbd> and place it directly in the module root folder. We'll go over the details of what can be configured in this file in <a target="_blank" href="part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 3</span></a>, <em class="calibre22">Handling Inter-Module Dependencies</em>, but for now, create this file with the following contents:</li>
</ol>
<pre class="calibre23">        module packt.addressbook { 
 
        }</pre>
<p class="calibre24">The keyword <kbd class="calibre12">module</kbd> is followed by the name of the module, which in our case is <kbd class="calibre12">packt.addressbook</kbd>. There's nothing between the curly braces for now because we are not specifying any details about the module in this file yet, except for the module name. However, adding this file to the module directory is essential for the Java compiler to treat this as a module.</p>
<p class="calibre24"><span>With this, you are done! These four steps are what it takes to create a simple Java 9 module. Here's how the folder structure should look when you are done:</span></p>
<div class="packt_figure1"><img class="image-border18" src="../images/00023.jpeg"/></div>
<p class="calibre2">Now, let's move on to compiling and executing this module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Compiling your module</h1>
                
            
            <article>
                
<p class="calibre2">Compiling code in a Java 9 module requires the use of the <kbd class="calibre12">javac</kbd> command as always, but with a few different options this time. To compile modules in Java 9, you need to provide the <kbd class="calibre12">javac</kbd> command with the following information:</p>
<ol class="calibre17">
<li value="1" class="calibre15">The location of your modules. This is the directory that contains the module root folders for all the modules in your application. In our case, this is the <kbd class="calibre12">src</kbd> folder. In it, we just have one module root folder.</li>
<li value="2" class="calibre15">The paths and names of the Java files that need to be compiled. In our case, it's just one file--<kbd class="calibre12">Main.java</kbd>.</li>
<li value="3" class="calibre15">The destination location where the compiler needs to output the compiled <kbd class="calibre12">.class</kbd> files. This can be any location, but I recommend choosing a folder named <kbd class="calibre12">out</kbd> directly below the project root folder.</li>
</ol>
<p class="calibre24">To compile the module you've written, go to the project root (in our example, it's <kbd class="calibre12">~/code/java9</kbd>) and run the following command:</p>
<div class="packt_figure"><img class="image-border19" src="../images/00024.jpeg"/></div>
<p class="calibre24">Here, you are specifying the module source path (<strong class="calibre1">1</strong>) using the <kbd class="calibre12">--module-source-path</kbd> command option, the output directory for compiled classes (<strong class="calibre1">2</strong>) using the <kbd class="calibre12">-d</kbd> command option, and the list of Java source files (<strong class="calibre1">3</strong>) by specifying them directly in the command (in this case, <kbd class="calibre12">Main.java</kbd> and <kbd class="calibre12">module-info.java</kbd>).</p>
<p class="calibre24">If the compiler is successful, there is no output to the console. The <kbd class="calibre12">out</kbd> directory should contain the compiled classes:</p>
<div class="packt_figure"><img class="image-border20" src="../images/00025.jpeg"/></div>
<p class="calibre24">Note that there is a one-to-one mapping between the source and compiled classes. Even the module descriptor <kbd class="calibre12">module-info.java</kbd> has been compiled to a <kbd class="calibre12">.class</kbd> file--<kbd class="calibre12">module-info.class</kbd>. This is for a very important reason. The module configuration provides metadata information about the module not just to the compiler during compile time, but also to the JVM during runtime. Thanks to the <kbd class="calibre12">module-info.class</kbd>, the JVM also has all the information about every Java module, thus enabling the runtime to tap into many of the benefits of the module system during execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing your module</h1>
                
            
            <article>
                
<p class="calibre2">Executing your compiled code again uses the familiar <kbd class="calibre12">java</kbd> command, but with some new options. Here is the information you need to tell the <kbd class="calibre12">java</kbd> command in this case:</p>
<ol class="calibre17">
<li value="1" class="calibre15">The location of the compiled modules--also called the <strong class="calibre1">module path</strong>.<strong class="calibre1"><br class="title-page-name"/></strong></li>
<li value="2" class="calibre15">The module that contains the class with the <kbd class="calibre12">main</kbd> method that needs to start the execution.</li>
<li value="3" class="calibre15">The class with the <kbd class="calibre12">main</kbd> method in the preceding module that needs to start the execution.</li>
</ol>
<p class="calibre2">To execute the code you just compiled in the previous step, you'd need to run the following command in the same directory:</p>
<div class="packt_figure"><img class="image-border21" src="../images/00026.jpeg"/></div>
<p class="calibre2">Here, you are specifying the location of the compiled modules (<strong class="calibre1">1</strong>) using the <kbd class="calibre12">--module-path</kbd> flag. We've told the compiler in the previous step to place our compiled code in the <kbd class="calibre12">out</kbd> folder, and so that's the value we need to provide here. You specify the module (<strong class="calibre1">2</strong>) and the class with the main method (<strong class="calibre1">3</strong>) using the <kbd class="calibre12">--module</kbd> option. Note the format of the value--it's <kbd class="calibre12">&lt;module-name&gt;/&lt;fully-qualified-classname&gt;</kbd>. Here, our code consists of just one class, so it feels unnecessary to specify this, but you can imagine a code base with multiple modules and classes, many of which might have main methods. It's important for the runtime to know which main method of which class of which module it needs to start the execution on.</p>
<p class="calibre2">There are alternative option names for many of these options. For example, instead of using <kbd class="calibre12">--module-path</kbd>, you can simply use <kbd class="calibre12">-p</kbd>, and <kbd class="calibre12">--module</kbd> can be replaced with <kbd class="calibre12">-m</kbd>.</p>
<p class="calibre2">If the execution completed successfully, you should see the message <kbd class="calibre12">Hello World!</kbd> printed on the console.</p>
<div class="packt_infobox">You've learned about two new arguments, <kbd class="calibre28">--module-source-path</kbd> and <kbd class="calibre28">--module-path</kbd>. They roughly correspond to the <kbd class="calibre28">-sourcepath</kbd> and <kbd class="calibre28">-classpath</kbd> options that we've been using in Java for a while now.<br class="calibre25"/>
<br class="calibre25"/>
<strong class="calibre26">Java 8 and earlier</strong>:<br class="calibre25"/>
<br class="calibre25"/>
<kbd class="calibre28">sourcepath</kbd>: Tells the compiler where the source files are that need to be compiled.<br class="calibre25"/>
<br class="calibre25"/>
<kbd class="calibre28">classpath</kbd>: Tells the compiler/runtime where the compiled types are that need to be included in the <kbd class="calibre28">classpath</kbd> for compiling/running code.<br class="calibre25"/>
<br class="calibre25"/>
<strong class="calibre26">Java 9</strong>:<br class="calibre25"/>
<br class="calibre25"/>
<kbd class="calibre28">module-source-path</kbd>: Tells the compiler where the source files for the modules are.<br class="calibre25"/>
<br class="calibre25"/>
<kbd class="calibre28">module-path</kbd>: Tells the compiler/runtime where the compiled modules are that need to be considered for compiling/running code your code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a module using NetBeans</h1>
                
            
            <article>
                
<p class="calibre2">Now that you've learned how to create, compile, and execute a module using the <span>Command Prompt</span>, let's see how to do the same thing using the NetBeans IDE:</p>
<ol class="calibre17">
<li class="calibre15" value="1"><span>Create a new project in the NetBeans IDE by clicking</span> <span><img class="image-border22" src="../images/00027.jpeg"/></span> <span>in the toolbar or, through the menu</span> <span>File</span> | <span>New Project</span><span>, you'll see a</span> <span>New Project</span> <span>overlay with a new option in the</span> <kbd class="calibre12">Java</kbd> <span>category--</span><span>Java Modular Project</span>:</li>
</ol>
<div class="packt_figure1"><img class="image-border23" src="../images/00028.jpeg"/></div>
<ol start="2" class="calibre17">
<li value="2" class="calibre15"><span>Select that and click</span> <span>Next</span><span>. In the next dialog, you can specify the name of your project (I chose</span> <kbd class="calibre12">addressbookviewer</kbd><span>) and the location of your project and click</span> <span>Finish</span><span>:</span></li>
</ol>
<div class="packt_figure1">
<div class="packt_figure"><img class="image-border24" src="../images/00029.jpeg"/></div>
</div>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Once the new project is loaded onto your IDE, you can right-click on the name of the project in the <span>Projects</span> tab and choose the option to create a new module:</li>
</ol>
<div class="packt_figure"><img class="image-border25" src="../images/00030.jpeg"/></div>
<ol start="4" class="calibre17">
<li class="calibre15" value="4"><span>In the</span> <span>New Module</span> <span>dialog, enter the name of the module</span> <kbd class="calibre12">packt.addressbook</kbd> <span>and click</span> <span>Finish</span><span>:</span></li>
</ol>
<div class="packt_figure1"><img class="image-border5" src="../images/00031.jpeg"/></div>
<p class="calibre24">And just like that, you've created a new module! Note how NetBeans has automatically created the module descriptor for your module:</p>
<div class="packt_figure"><img class="image-border26" src="../images/00032.jpeg"/></div>
<ol start="5" class="calibre17">
<li value="5" class="calibre15">Now what's left is to add the <kbd class="calibre12">Main.java</kbd> class by right-clicking on the module and going through the wizard:
<div class="packt_figure"><img class="image-border27" src="../images/00033.jpeg"/></div>
</li>
<li value="6" class="calibre15">After adding the <kbd class="calibre12">Main.java</kbd> class, you can compile and execute it by right-clicking on the class and clicking <span>Run File</span>. You should see the message <kbd class="calibre12">Hello World</kbd> on the console panel at the bottom:</li>
</ol>
<div class="packt_figure"><img class="image-border28" src="../images/00034.jpeg"/></div>
<p class="calibre2">Congratulations! You've created, compiled, and executed your first Java module! This was a module with just one Java type, <kbd class="calibre12">Main.java</kbd>. Most of the code you'll be writing in this book will have you follow through the same steps that you just did. There will be several variations, of course, but we'll be examining the differences as we learn more about modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The address book viewer application</h1>
                
            
            <article>
                
<p class="calibre2">Now that you are comfortable creating, compiling, and executing a simple Java 9 module, let's update it and start adding address book viewer functionality.</p>
<p class="calibre2">The following informal class diagram shows how we'll design the application classes to begin with:</p>
<div class="packt_figure"><img class="image-border29" src="../images/00035.jpeg"/></div>
<p class="calibre2">The main class has the <kbd class="calibre12">main()</kbd> method that displays the list of contacts in ascending order, sorted by the <kbd class="calibre12">lastName</kbd> property. It gets the list of contacts by calling the <kbd class="calibre12">ContactUtil.getContacts()</kbd> method and it sorts it using <kbd class="calibre12">SortUtil.sortList()</kbd>. It then displays the list of contacts to the console.</p>
<p class="calibre2">We'll start with a new model class <kbd class="calibre12">Contact</kbd>, which represents a single piece of contact information. Apart from the obvious contact-related private member variables and getters and setters, this class also has a couple of additions that'll come in handy later:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">The constructor with arguments</strong>: This makes it easy for us to create contact objects. This is useful since we'll be hardcoding our contact list to begin with.</li>
<li class="calibre15"><strong class="calibre1">The toString() method</strong>: This provides readable output when we print <kbd class="calibre12">Contact</kbd> objects to the console.</li>
<li class="calibre15"><strong class="calibre1">The compareTo() method</strong>: Since we'll need to sort <kbd class="calibre12">Contact</kbd> objects, we'll have the <kbd class="calibre12">Contact</kbd> class, which implements <kbd class="calibre12">Comparable</kbd>, and the <kbd class="calibre12">compareTo()</kbd> method, which compares <kbd class="calibre12">Contact</kbd> instances by their <kbd class="calibre12">lastName</kbd> property.</li>
</ul>
<p class="calibre2">Here's what the <kbd class="calibre12">Contact</kbd> class looks like:</p>
<pre class="calibre23">    package packt.addressbook.model; 
    public class Contact implements Comparable { 
      private String id; 
      private String firstName; 
      private String lastName; 
      private String phoneNumber; 
      public Contact(String id, String firstName,<br class="title-page-name"/>       String lastName, String phoneNumber) { 
         this.id = id; 
         this.firstName = firstName; 
         this.lastName = lastName; 
        this. phoneNumber = phoneNumber; 
      } 
      // Getters and setters omitted for brevity 
      public String toString() { 
        return this.firstName + " " + this.lastName; 
      } 
      public int compareTo(Object other) {  
        Contact otherContact = (Contact)other; 
        return this.lastName.compareTo(otherContact.lastName); 
      } 
    } </pre>
<p class="calibre2">Let's move on to the <kbd class="calibre12">ContactUtil</kbd> class. We need a source of some contact data to start coding with, so for now, we'll hardcode a few <kbd class="calibre12">Contact</kbd> objects and add them to a list. The <kbd class="calibre12">ContactUtil.getContacts()</kbd> method just prepares this hard coded list for now:</p>
<pre class="calibre23">    package packt.addressbook.util; <br class="title-page-name"/>    public class ContactUtil { 
 <br class="title-page-name"/>      public List&lt;Contact&gt; getContacts() { 
        List&lt;Contact&gt; contacts = Arrays.asList( 
          new Contact("Edsger", "Dijkstra", "345-678-9012"), 
          new Contact("Alan", "Turing", "456-789-0123"), 
          new Contact("Ada", "Lovelace", "234-567-8901"), 
          new Contact("Charles", "Babbage", "123-456-7890"), 
          new Contact("Tim", "Berners-Lee", "456-789-0123")                 
        ); 
        return contacts; 
      } 
    } </pre>
<p class="calibre2">Next is the <kbd class="calibre12">SortUtil</kbd> class. You don't typically write sort methods, thanks to some good collection libraries that are available out of the box with Java. In this case, however, we will implement our own sorting algorithm for the purposes of learning about modules because it'll help us illustrate some important use cases throughout this book. Instead of creating a method specifically designed to sort <kbd class="calibre12">Contact</kbd> instances, we'll instead write a generic Bubble Sort method to sort any type that implements <kbd class="calibre12">Comparable</kbd>. Thanks to <kbd class="calibre12">Contact</kbd> implementing the <kbd class="calibre12">Comparable</kbd> interface, we should be able to use the <kbd class="calibre12">SortUtil</kbd> to sort its instances too:</p>
<pre class="calibre23">    public class SortUtil { 
      public &lt;T extends Comparable&gt; List&lt;T&gt; sortList(List&lt;T&gt; list) { 
        for (int outer = 0; outer &lt; list.size() - 1; outer++) {         
          for (int inner = 0; inner &lt; list.size()-outer-1; inner++) {<br class="title-page-name"/>            if (list.get(inner).compareTo(list.get(inner + 1)) &gt; 0) {  
              swap(list, inner); 
            } 
          } 
        } 
        return list; 
      } 
      private &lt;T&gt; void swap(List&lt;T&gt;list, int inner) { 
        T temp = list.get(inner); 
        list.set(inner, list.get(inner + 1)); 
        list.set(inner + 1, temp); 
      } 
    } </pre>
<p class="calibre2">Now let's bring it all together in <kbd class="calibre12">Main.java</kbd>. We'll first call the <kbd class="calibre12">getContacts()</kbd> method on an instance of <kbd class="calibre12">ContactUtil</kbd> to get the hardcoded <kbd class="calibre12">Contact</kbd> list. Then we'll pass it to the <kbd class="calibre12">sortList()</kbd> method on an instance of <kbd class="calibre12">SortList</kbd>. We will then print the sorted list on the console using <kbd class="calibre12">System.out.println()</kbd>:</p>
<pre class="calibre23">    package packt.addressbook; 
 
    public class Main {  
      public static void main(String args) { 
        ContactUtil contactUtil = new ContactUtil(); 
        SortUtil sortUtil = new SortUtil(); 
        List&lt;Contact&gt; contacts = contactUtil.getContacts(); 
        sortUtil.sortList(contacts); 
        System.out.println(contacts); 
      } 
    } </pre>
<p class="calibre2">With this, we are done and ready to compile our code. We've seen that the command to compile your code looks like this:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out &lt;all-java-classes-here&gt;</strong></pre>
<p class="calibre2">The part where we need to specify all Java classes can get tedious. We have a handful of classes at this time, and I already don't want to be bothered with typing all the class names (with paths!) in the command. This can get worse when we have multiple modules in the module source path and we want to compile them. Thankfully, there's a shortcut. The compiler also has the <kbd class="calibre12">--module</kbd> option that lets you specify the names of the modules that you need to compile. You can specify multiple module names here, separated by commas. The compiler looks for those modules in the module source path and compiles all classes in those modules. And as you can imagine, using this command is much easier!</p>
<p class="calibre2">Since we are compiling just one module here, that's what we'll specify as the value for the <kbd class="calibre12">--module</kbd> argument:</p>
<pre class="calibre23"><strong class="calibre1">$ javac -d out --module-source-path src --module packt.addressbook</strong>  </pre>
<p class="calibre2">The compilation should complete without any errors. Now, let's move on to execute your code. The command remains unchanged:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out --module packt.addressbook/packt.addressbook.Main</strong>  </pre>
<p class="calibre2">Here's the sorted output from the hardcoded contacts list:</p>
<pre class="calibre23"><strong class="calibre1">[Babbage 123-456-7890, Lovelace 234-567-8901, Dijkstra 345-678-9012,<br class="title-page-name"/> Turing 456-789-0123, Berners-Lee 456-789-0123]</strong> </pre>
<p class="calibre2">If you expand the out directory, you'll again notice the one-to-one mapping between the <kbd class="calibre12">.java</kbd> files and the <kbd class="calibre12">.class</kbd> files:</p>
<div class="packt_figure"><img class="image-border30" src="../images/00036.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling possible errors</h1>
                
            
            <article>
                
<p class="calibre2">Here are some possible errors you could run into when following the steps we previously outlined, along with some solutions:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Error during compilation:</li>
</ol>
<pre class="calibre23"><strong class="calibre1">      javac: invalid flag: --module-source-path </strong></pre>
<p class="calibre24">This is probably because you haven't switched to JDK 9 and are still using the Java 8 compiler. The <kbd class="calibre12">--module-source-path</kbd> option has been newly introduced to  <kbd class="calibre12">javac</kbd> as of version 9.</p>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">Error during compilation:</li>
</ol>
<pre class="calibre23"><strong class="calibre1">      error: module not found: packt.addressbook</strong> </pre>
<p class="calibre24">This error is because the Java compiler is unable to find the <kbd class="calibre12">module-info.java</kbd> file. Make sure it is in the right directory path.</p>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Error during runtime:</li>
</ol>
<pre class="calibre23"><strong class="calibre1">      Error occurred during initialization of VM 
      java.lang.module.ResolutionException: Module packt.addressbook<br class="title-page-name"/>      not found </strong></pre>
<p class="calibre24">This error indicates that the module file is not available in the module path provided. Make sure the path is correctly specified and that the <kbd class="calibre12">packt.addressbook</kbd> folder contains the compiled <kbd class="calibre12">module-info.class</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you have learned what the bare minimum steps to creating a Java 9 module are. You've created a simple module from scratch, as well as compiled and executed code in the module. You've also learned about a few possible error scenarios and how to handle them.</p>
<p class="calibre2">There is something missing though! Since we are dealing with a single module, we are not really leveraging the concepts of modularity here. The concepts of modularity come into play only when we have multiple modules interacting with each other. You'll see just that in action in the next chapter when you create your second Java module and set up inter-module dependency!</p>


            </article>

            
        </section>
    </body></html>