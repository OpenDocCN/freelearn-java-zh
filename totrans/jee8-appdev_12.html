<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Services with JAX-WS</h1>
                </header>
            
            <article>
                
<p>The Java EE specification includes the JAX-WS API as one of its technologies. JAX-WS is the standard way to develop <strong>SOAP</strong> (<strong>Simple Object Access Protocol</strong>) web services in the Java platform and stands for Java API for XML Web Services. JAX-WS is a high-level API; invoking web services via JAX-WS is done via remote procedure calls. JAX-WS is a very natural API for Java developers.</p>
<p>Web services are application programming interfaces that can be invoked remotely. Web services can be invoked from clients written in any language.</p>
<p>Some of the topics we will cover include:</p>
<ul>
<li>Developing web services with the JAX-WS API</li>
<li>Developing web service clients with the JAX-WS API</li>
<li>Adding attachments to web service calls</li>
<li>Exposing EJBs as web services</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing web services with JAX-WS</h1>
                </header>
            
            <article>
                
<p>JAX-WS is a high-level API that simplifies the development of SOAP-based web services. JAX-WS stands for <strong>Java API for XML Web Services</strong>. Developing a web service via JAX-WS consists of writing a class with public methods to be exposed as web services. The class needs to be decorated with the <kbd>@WebService</kbd> annotation. All public methods in the class are automatically exposed as web services. They can optionally be decorated with the <kbd>@WebService</kbd> annotation. The following example illustrates this process:</p>
<pre style="padding-left: 60px">package net.ensode.glassfishbook; 
 
import javax.jws.WebMethod; 
import javax.jws.WebService; 
 
<strong>@WebService</strong> 
public class Calculator { 
 
<strong>    @WebMethod</strong> 
    public int add(int first, int second) { 
        return first + second; 
    } 
 
<strong>    @WebMethod</strong> 
    public int subtract(int first, int second) { 
        return first - second; 
    } 
} </pre>
<p>The preceding class exposes its two methods as web services. The <kbd>add()</kbd> method simply adds the two <kbd>int</kbd> primitives it receives as parameters and returns the result; the <kbd>substract()</kbd> method subtracts its two parameters and returns the result.</p>
<p>We indicate that the class implements a web service by decorating it with the <kbd>@WebService</kbd> annotation. Any methods that we would like to expose as web services can be decorated with the <kbd>@WebMethod</kbd> annotation, but this isn't necessary; all public methods are automatically exposed as web services. We can still use the <kbd>@WebMethod</kbd> annotation for clarity, but it isn't strictly necessary to deploy our web service; we simply need to package it in a WAR file as usual.</p>
<p>Web service clients need a <strong>WSDL</strong> (<strong>Web Services Definition Language</strong>) file in order to generate executable code that they can use to invoke the web service. WSDL files are typically placed in a web server and accessed by the client via its URL.</p>
<p>When deploying web services developed using JAX-WS, a WSDL is automatically generated for us. The exact URL for the generated WSDL varies depending on the Java EE 8 application server we are using. When using GlassFish, URLs for JAX-WS WSDLs follow the following format:</p>
<p><kbd>[http|https]://[server]:[port]/[context root]/[service name]?wsdl</kbd></p>
<p>In our example, the URL for our web service's WSDL (when deployed to GlassFish) would be <kbd>http://localhost:8080/calculatorservice/CalculatorService?wsdl</kbd> (assuming GlassFish is running on our local workstation, and GlassFish is listening for HTTP connections on its default 8080 port).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a web service client</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier, executable code needs to be generated from a web service's WSDL. A web service client will then invoke this executable code to access the web service.</p>
<p>The <strong>Java Development Kit</strong> (<strong>JDK</strong>) includes a utility to generate Java code from a WSDL. The name of the utility is <kbd>wsimport</kbd>. It can be found under <kbd>$JAVA_HOME/bin</kbd>. The only required argument for <kbd>wsimport</kbd> is the URL of the WSDL corresponding to the web service, for example:</p>
<p><kbd>wsimport http://localhost:8080/calculatorservice/CalculatorService?wsdl</kbd></p>
<p>The preceding command will generate a number of compiled Java classes that allow client applications to access our web service:</p>
<ul>
<li><kbd>Add.class</kbd></li>
<li><kbd>AddResponse.class</kbd></li>
<li><kbd>Calculator.class</kbd></li>
<li><kbd>CalculatorService.class</kbd></li>
<li><kbd>ObjectFactory.class</kbd></li>
<li><kbd>package-info.class</kbd></li>
<li><kbd>Subtract.class</kbd></li>
<li><kbd>SubtractResponse.class</kbd></li>
</ul>
<div class="packt_tip"><span class="NormalPACKTChar"><span class="packt_screen">Keeping generated source code</span>:</span> <span class="NormalPACKTChar">By default, the source code for the generated class files is automatically deleted; it can be kept by passing the</span> <kbd>-keep</kbd> <span class="NormalPACKTChar">parameter to</span> <kbd>wsimport</kbd>.</div>
<p><span class="NormalPACKTChar">These classes need to be added to the client's <kbd>CLASSPATH</kbd> in order for them to be accessible to the client's code.</span></p>
<p><span class="InformationBoxPACKTChar">If we are using Apache Maven to build our code, we can take advantage of the JAX-WS Maven plugin to automatically invoke</span> <kbd>wsimport</kbd> <span class="InformationBoxPACKTChar">when building our client code. This approach is illustrated in the following</span> <kbd>pom.xml</kbd> <span class="InformationBoxPACKTChar">file:</span></p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
 
    &lt;groupId&gt;net.ensode.javaee8book&lt;/groupId&gt; 
    &lt;artifactId&gt;calculatorserviceclient&lt;/artifactId&gt; 
    &lt;version&gt;1.0&lt;/version&gt; 
    &lt;packaging&gt;war&lt;/packaging&gt; 
 
    &lt;name&gt;calculatorserviceclient&lt;/name&gt; 
 
    &lt;properties&gt; 
        &lt;endorsed.dir&gt;${project.build.directory}/endorsed&lt;/endorsed.dir&gt; 
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; 
    &lt;/properties&gt; 
     
    &lt;dependencies&gt; 
        &lt;dependency&gt; 
            &lt;groupId&gt;javax&lt;/groupId&gt; 
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; 
            &lt;version&gt;7.0&lt;/version&gt; 
            &lt;scope&gt;provided&lt;/scope&gt; 
        &lt;/dependency&gt; 
    &lt;/dependencies&gt; 
 
    &lt;build&gt; 
        &lt;plugins&gt; 
        <strong>    &lt;plugin&gt; 
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; 
                &lt;artifactId&gt;jaxws-maven-plugin&lt;/artifactId&gt; 
                &lt;version&gt;2.4.1&lt;/version&gt; 
                &lt;executions&gt; 
                    &lt;execution&gt; 
                        &lt;goals&gt; 
                            &lt;goal&gt;wsimport&lt;/goal&gt; 
                        &lt;/goals&gt; 
                        &lt;configuration&gt; 
                            &lt;vmArgs&gt; 
                            &lt;vmArg&gt;-Djavax.xml.accessExternalSchema=all&lt;/vmArg&gt; 
                            &lt;/vmArgs&gt; 
                            &lt;wsdlUrls&gt; 
                               &lt;wsdlUrl&gt; 
                     http://localhost:8080/calculatorservice/CalculatorService?wsdl 
                              &lt;/wsdlUrl&gt; 
                            &lt;/wsdlUrls&gt; 
                            &lt;keep&gt;true&lt;/keep&gt; 
                        &lt;/configuration&gt; 
                    &lt;/execution&gt; 
                &lt;/executions&gt; 
            &lt;/plugin&gt; </strong>
           &lt;!-- additional plugins removed for brevity --&gt; 
        &lt;/plugins&gt; 
    &lt;/build&gt; 
&lt;/project&gt; </pre>
<p><span class="NormalPACKTChar">The preceding</span> <kbd>pom.xml</kbd> M<span class="NormalPACKTChar">aven build file will automatically invoke the</span> <kbd>wsimport</kbd> <span class="NormalPACKTChar">utility whenever we build our code via the</span> <kbd>mvn package</kbd> or <kbd>mvn install</kbd> <span class="NormalPACKTChar">commands.</span></p>
<p><span class="NormalPACKTChar">At this point, we are ready to develop a simple client to access our web service. We will implement our client as a JSF application. The most relevant parts of our client application source code are shown as follows:</span></p>
<pre style="padding-left: 60px"><span class="NormalPACKTChar">package net.ensode.javaee8book.calculatorserviceclient;<br/></span><span class="NormalPACKTChar">import javax.enterprise.context.RequestScoped;<br/></span><span class="NormalPACKTChar">import javax.faces.event.ActionEvent;<br/></span><span class="NormalPACKTChar">import javax.inject.Inject;<br/></span><span class="NormalPACKTChar">import javax.inject.Named;<br/></span><span class="NormalPACKTChar">import javax.xml.ws.WebServiceRef;<br/></span><span class="NormalPACKTChar">import net.ensode.javaee8book.jaxws.Calculator;<br/></span><span class="NormalPACKTChar">import net.ensode.javaee8book.jaxws.CalculatorService;<br/></span><span class="NormalPACKTChar">@Named<br/></span><span class="NormalPACKTChar">@RequestScoped<br/></span><span class="NormalPACKTChar">public class CalculatorClientController {</span><strong>   <br/>    @WebServiceRef(wsdlLocation =<br/>          "http://localhost:8080/calculatorservice/CalculatorService?wsdl")</strong><strong>    <br/>    private CalculatorService calculatorService;</strong><span class="NormalPACKTChar">  <br/>    @Inject</span><span class="NormalPACKTChar">   <br/>    private CalculatorServiceClientModel<br/>    calculatorServiceClientModel;</span><span class="NormalPACKTChar">   <br/>    private Integer sum;</span><span class="NormalPACKTChar">  <br/>    private Integer difference;</span><span class="NormalPACKTChar">   <br/>    public void add(ActionEvent actionEvent) {</span><strong>    <br/>        Calculator calculator = <br/>         calculatorService.getCalculatorPort();</strong><span class="NormalPACKTChar">     <br/>        sum = calculator.add(calculatorServiceClientModel.getAddend1(),</span><span class="NormalPACKTChar">                           <br/>        calculatorServiceClientModel.getAddend2());</span><span class="NormalPACKTChar">   <br/>    }</span><span class="NormalPACKTChar">    <br/>    public void subtract(ActionEvent actionEvent) {</span><strong>    <br/>        Calculator calculator = <br/>         calculatorService.getCalculatorPort();</strong><span class="NormalPACKTChar">   <br/>        difference = <br/>         calculator.subtract(calculatorServiceClientModel.getMinuend(), </span><span class="NormalPACKTChar">                            <br/>         calculatorServiceClientModel.getSubtrahend());</span><span class="NormalPACKTChar">   <br/>    }</span><span class="NormalPACKTChar"> <br/>    public Integer getSum() {</span><span class="NormalPACKTChar">  <br/>        return sum;</span><span class="NormalPACKTChar">   <br/>    }</span><span class="NormalPACKTChar">   <br/>    public void setSum(Integer sum) {</span><span class="NormalPACKTChar"> <br/>        this.sum = sum;</span><span class="NormalPACKTChar">  <br/>    }</span><span class="NormalPACKTChar">    <br/>    public Integer getDifference() {</span><span class="NormalPACKTChar">    <br/>        return difference;</span><span class="NormalPACKTChar"> <br/>    }</span><span class="NormalPACKTChar">  <br/>    public void setDifference(Integer difference) {</span><span class="NormalPACKTChar">       <br/>        this.difference = difference;</span><span class="NormalPACKTChar"> <br/>    }</span> 
} </pre>
<p>The <kbd>@WebServiceRef</kbd> annotation injects an instance of the web service into our client application. Its <kbd>wsdlLocation</kbd> attribute contains the URL of the WSDL corresponding to the web service we are invoking.</p>
<p>Notice that the web service class is an instance of a class called <kbd>CalculatorService</kbd>. This class was created when we invoked the <kbd>wsimport</kbd> utility, as <kbd>wsimport</kbd> always generates a class whose name is the name of the class we implemented plus the service suffix. We use this service class to obtain an instance of the web "Service" class we developed. In our example, we do this by invoking the <kbd>getCalculatorPort()</kbd> method on the <kbd>CalculatorService</kbd> instance. In general, the method to invoke to get an instance of our web service class follows the pattern <kbd>getNamePort()</kbd>, where <kbd>Name</kbd> is the name of the class we wrote to implement the web service. Once we get an instance of our web service class, we can simply invoke its methods as with any regular Java object.</p>
<div class="packt_infobox">Strictly speaking, the <kbd>getNamePort()</kbd> method of the service class returns an instance of a class implementing an interface generated by <kbd>wsimport</kbd>. This interface is given the name of our web service class and declares all of the methods we declared to be web services. For all practical purposes, the object returned is equivalent to our web service class.</div>
<p>The user interface for our simple client application is developed using Facelets, as customary when developing JSF applications:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
       
      &gt; 
    &lt;h:head&gt; 
        &lt;title&gt;Calculator Service Client&lt;/title&gt; 
    &lt;/h:head&gt; 
    &lt;h:body&gt; 
        &lt;h3&gt;Simple JAX-WS Web Service Client&lt;/h3&gt; 
        &lt;h:messages/&gt; 
        &lt;h:form&gt; 
            &lt;h:panelGrid columns="4"&gt; 
                &lt;h:inputText id="addend1"
                   value="#{calculatorServiceClientModel.addend1}"/&gt; 
                &lt;h:inputText id="addend2" 
                  value="#{calculatorServiceClientModel.addend2}"/&gt; 
                &lt;h:commandButton value="Add" 
                  actionListener="#  <br/>                   {calculatorClientController.add}"&gt; 
                    &lt;f:ajax execute="addend1 addend2" <br/>                     render="sum"/&gt; 
                &lt;/h:commandButton&gt; 
                &lt;h:panelGroup&gt; 
                    Total: &lt;h:outputText id="sum"
                       value="#{calculatorClientController.sum}"/&gt; 
                &lt;/h:panelGroup&gt; 
            &lt;/h:panelGrid&gt; 
            &lt;br/&gt; 
            &lt;h:panelGrid columns="4"&gt; 
                &lt;h:inputText id="minuend" 
                   value="#{calculatorServiceClientModel.minuend}"/&gt; 
                &lt;h:inputText id="subtrahend" 
                  value="# <br/>                   {calculatorServiceClientModel.subtrahend}"/&gt; 
                &lt;h:commandButton value="Subtract" 
                   actionListener="#<br/>                    {calculatorClientController.subtract}"&gt; 
                    &lt;f:ajax execute="minuend subtrahend"  <br/>                     render="difference"/&gt; 
                &lt;/h:commandButton&gt; 
                &lt;h:panelGroup&gt; 
                    Difference: &lt;h:outputText id="difference" 
                      value="#<br/>                       {calculatorClientController.difference}"/&gt; 
                &lt;/h:panelGroup&gt; 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
    &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>The user interface uses Ajax to invoke the relevant methods on the <kbd>CalculatorClientController</kbd> CDI named bean (refer to <a href="9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>JavaServer Faces</em>, for details).</p>
<p>After deploying our code, our browser should render our page as follows (shown after entering some data and clicking the corresponding buttons):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c9383d7d-0b52-4b8c-b662-8388510477bf.png" style="width:31.67em;height:18.25em;"/></div>
<p>In this example, we passed <kbd>Integer</kbd> objects as parameters and return values. Of course, it is also possible to pass primitive types both as parameters and as return values. Unfortunately, not all standard Java classes or primitive types can be used as method parameters or return values when invoking SOAP-based web services implemented via JAX-WS. The reason for this is that, behind the scenes, method parameters and return types get mapped to XML definitions, and not all types can be properly mapped.</p>
<p>Valid types that can be used in JAX-WS web service calls are listed here:</p>
<ul>
<li><kbd>java.awt.Image</kbd></li>
<li><kbd>java.lang.Object</kbd></li>
<li><kbd>Java.lang.String</kbd></li>
<li><kbd>java.math.BigDecimal</kbd></li>
<li><kbd>java.math.BigInteger</kbd></li>
<li><kbd>java.net.URI</kbd></li>
<li><kbd>java.util.Calendar</kbd></li>
<li><kbd>java.util.Date</kbd></li>
<li><kbd>java.util.UUID</kbd></li>
<li><kbd><kbd>javax.activation.DataHandler</kbd></kbd></li>
<li><kbd>javax.xml.datatype.Duration</kbd></li>
<li><kbd>javax.xml.datatype.XMLGregorianCalendar</kbd></li>
<li><kbd>javax.xml.namespace.QName</kbd></li>
<li><kbd>javax.xml.transform.Source</kbd></li>
</ul>
<p>Additionally, the following primitive types can be used:</p>
<ul>
<li><kbd>Boolean</kbd></li>
<li><kbd>byte</kbd></li>
<li><kbd>byte[]</kbd></li>
<li><kbd>double</kbd></li>
<li><kbd>float</kbd></li>
<li><kbd>int</kbd></li>
<li><kbd>long</kbd></li>
<li><kbd>short</kbd></li>
</ul>
<p>We can also use our own custom classes as method parameters and/or return values forÂ web service methods, but member variables of our classes must be one of the listed types.</p>
<p>Additionally, it is legal to use arrays both as method parameters and return values; however, when executing <kbd>wsimport</kbd>, these arrays get converted to lists, generating a mismatch between the method signature in the web service and the method call invoked in the client. For this reason, it is preferred to use lists as method parameters and/or return values, since this is also legal and does not create a mismatch between the client and the server.</p>
<div class="packt_infobox">JAX-WS uses the Java Architecture for XML Binding (JAXB) internally to create SOAP messages from method calls. The types we are allowed to use for method calls and return values are the ones that JAXB supports. For more information on JAXB, see <a href="https://github.com/javaee/jaxb-v2"><span class="URLPACKT">https://github.com/javaee/jaxb-v2.</span></a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending attachments to web services</h1>
                </header>
            
            <article>
                
<p>In addition to sending and accepting the data types discussed in the previous sections, <kbd>web service</kbd> methods can send and accept file attachments. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook.jaxws; 
 
import java.io.FileOutputStream; 
import java.io.IOException; 
 
import javax.activation.DataHandler; 
import javax.jws.WebMethod; 
import javax.jws.WebService; 
 
@WebService 
public class FileAttachment { 
 
    @WebMethod 
<strong>    public void attachFile(DataHandler dataHandler) {</strong> 
        FileOutputStream fileOutputStream; 
        try { 
<strong>            fileOutputStream = <br/>              new FileOutputStream("/tmp/logo.png");<br/>            dataHandler.writeTo(fileOutputStream);</strong> 
 
            fileOutputStream.flush(); 
            fileOutputStream.close(); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
 
    } 
} </pre>
<p>In order to write a web service method that receives one or more attachments, all we need to do is add a parameter of type <kbd>javax.activation.DataHandler</kbd> for each attachment the method will receive. In the preceding example, the <kbd>attachFile()</kbd> method takes a single parameter of this type and simply writes it to the filesystem.</p>
<p>At this point, we need to package our code in a WAR file and deploy it as usual. Once deployed, a WSDL will automatically be generated. We then need to execute the <kbd>wsimport</kbd> utility to generate code that our web service client can use to access the web service. As previously discussed, the <kbd>wsimport</kbd> can be invoked directly from the command line or via an Apache Maven plugin.</p>
<p>Once we have executed <kbd>wsimport</kbd> to generate code to access the web service, we can write and compile our client code:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.fileattachmentserviceclient; 
 
import java.io.ByteArrayOutputStream; 
import java.io.IOException; 
import java.io.InputStream; 
import java.net.URL; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.xml.ws.WebServiceRef; 
import net.ensode.javaeebook.jaxws.FileAttachment; 
import net.ensode.javaeebook.jaxws.FileAttachmentService; 
 
@Named 
@RequestScoped 
public class FileAttachmentServiceClientController { 
 
    @WebServiceRef(wsdlLocation = "http://localhost:8080/fileattachmentservice/" 
            + "FileAttachmentService?wsdl") 
    private FileAttachmentService fileAttachmentService; 
 
    public void invokeWebService() { 
        try { 
            URL attachmentUrl = new URL( 
        "http://localhost:8080/fileattachmentserviceclient/resources/img/logo.png"); 
 
            FileAttachment fileAttachment = fileAttachmentService. 
                    getFileAttachmentPort(); 
 
            InputStream inputStream = attachmentUrl.openStream(); 
 
<strong>            byte[] fileBytes = inputStreamToByteArray(inputStream);</strong><strong>            <br/>            fileAttachment.attachFile(fileBytes);</strong> 
        } catch (IOException ioe) { 
            ioe.printStackTrace(); 
        } 
    } 
 
    private byte[] inputStreamToByteArray(InputStream inputStream) throws 
      IOException { 
        ByteArrayOutputStream byteArrayOutputStream =  
          new ByteArrayOutputStream(); 
        byte[] buffer = new byte[1024]; 
        int bytesRead = 0; 
        while ((bytesRead = inputStream.read(buffer, 0, buffer.length)) != -1) { 
            byteArrayOutputStream.write(buffer, 0, bytesRead); 
        } 
        byteArrayOutputStream.flush(); 
        return byteArrayOutputStream.toByteArray(); 
    } 
} </pre>
<p>Web service attachments need to be sent as a <kbd>byte</kbd> array to the web service, therefore, web service clients need to convert the file to attach to this type. In our example, we send an image as an attachment, we load the image into memory by creating an instance of <kbd>java.net.URL</kbd>, passing the URL of the image in question as a parameter to its constructor. We then obtain an <kbd>InputStream</kbd> instance corresponding to the image by invoking the <kbd>openStream()</kbd> method on our <kbd>URL</kbd> instance, convert our <kbd>InputStream</kbd> instance to a byte array, then <span class="NormalPACKTChar">pass this byte array to the <kbd>web service</kbd> method that expects an attachment.</span></p>
<p><span class="NormalPACKTChar">Notice that, unlike when passing standard parameters, the parameter type used when the client invokes a method expecting an attachment is different from the parameter type of the method in the web server code. The method in the web server code expects an instance of</span> <kbd>javax.activation.DataHandler</kbd> <span class="NormalPACKTChar">for each attachment; however, the code generated by</span> <kbd>wsimport</kbd> <span class="NormalPACKTChar">expects an array of bytes for each attachment. These arrays of bytes are converted to the right type (</span> <kbd>javax.activation.DataHandler</kbd> <span class="NormalPACKTChar">) behind the scenes by the</span> <kbd>wsimport</kbd> <span class="NormalPACKTChar">generated code. As application developers, we don't need to concern ourselves with the details of why this happens; we just need to keep in mind that, when sending attachments to a</span> web service <span class="NormalPACKTChar">method, parameter types will be different in the</span> web service <span class="NormalPACKTChar">code and in the client invocation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing EJBs as web services</h1>
                </header>
            
            <article>
                
<p>In addition to creating web services as described in the previous section, public methods of stateless session beans can easily be exposed as web services by simply adding an annotation to the EJB class. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.ejbws; 
 
import javax.ejb.Stateless; 
import javax.jws.WebService; 
 
@Stateless 
<strong>@WebService</strong> 
public class DecToHexBean { 
 
  public String convertDecToHex(int i) { 
    return Integer.toHexString(i); 
  } 
} </pre>
<p>As we can see, the only thing we need to do to expose a stateless session bean's public methods is to decorate its class declaration with the <kbd>@WebService</kbd> annotation. Needless to say, since the class is a session bean, it also needs to be decorated with the <kbd>@Stateless</kbd> annotation.</p>
<p>Just like regular stateless session beans, the ones whose methods are exposed as web services need to be deployed in a JAR file.</p>
<p>Just like standard web services, WSDL URLs for EJB web services depend on the application server being used. Consult your application server documentation for details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EJB web service clients</h1>
                </header>
            
            <article>
                
<p>The following class illustrates the procedure to be followed to access an EJB web service methods from a client application:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.ejbwsclient; 
 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Inject; 
import javax.inject.Named; 
import javax.xml.ws.WebServiceRef; 
import net.ensode.javaee8book.ejbws.DecToHexBeanService; 
 
@Named 
@RequestScoped 
public class EjbClientController { 
 
    @WebServiceRef(wsdlLocation =  <br/>    "http://localhost:8080/DecToHexBeanService/DecToHexBean?wsdl") 
    private DecToHexBeanService decToHexBeanService; 
 
    @Inject 
    private EjbClientModel ejbClientModel; 
 
    private String hexVal; 
 
    public void convertIntToHex() { 
        hexVal = decToHexBeanService.getDecToHexBeanPort(). 
                convertDecToHex(ejbClientModel.getIntVal()); 
    } 
 
    public String getHexVal() { 
        return hexVal; 
    } 
 
    public void setHexVal(String hexVal) { 
        this.hexVal = hexVal; 
    } 
} </pre>
<p>As we can see, nothing special needs to be done when accessing an EJB web service from a client. The procedure is the same as with standard web services.</p>
<p>The preceding class is a CDI named bean, and the following screenshot illustrates a simple JSF web-based user interface utilizing the preceding class to invoke our web service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/416a894e-7643-45a8-987e-b72fa1c2a24f.png" style="width:33.75em;height:14.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to develop web services and web service clients via the JAX-WS API. We explained how to incorporate web service code generation for web service clients when using ANT or Maven as a build tool. We also covered the valid types that can be used for remote method calls via JAX-WS. Additionally, we discussed how to send attachments to a web service. We also covered how to expose an EJB's methods as web services.</p>


            </article>

            
        </section>
    </body></html>