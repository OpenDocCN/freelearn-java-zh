- en: 10\. Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses Java's support for encryption. It does this first, by
    defining symmetric and asymmetric key encryption, then teaching you to implement
    those encryptions **Advanced Encryption Standard** (**AES**) and **Rivest-Shamir-Adleman**
    (**RSA**), respectively. You will further learn to differentiate between block
    and stream ciphers, so that you may utilize them appropriately when encrypting
    your files.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption is the process of scrambling data so that it can be sent in plain
    sight between two or more parties without anyone else being able to understand
    what was sent. Today, almost everything you do online is encrypted—be it reading
    an email, sending a photo to a popular social network, or downloading source code.
    Most serious websites today are also encrypted. Applying encryption to your software
    is vital for safeguarding your integrity, data, and business, as well as that
    of your customer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is a very complicated topic that gets more complex every year as
    we try to safeguard our applications from new malicious code and individuals.
    This chapter will not go into detail about how encryption should be implemented
    in software. Instead, we will explain how you can use the APIs that are available
    within Java.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we have a collection of classes and interfaces that have been specifically
    created for handling most security-related cases on the Java platform—they're
    all gathered in what is called the **Java Cryptography Architecture** (**JCA**).
    Within the JCA lies the foundation for building secure applications in Java. Several
    other secure libraries within Java use the JCA to implement their security. With
    the JCA, you can either create your own custom security providers or use the already
    available standard providers. In most cases, using the standard providers is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cryptographic terms, plaintext means the data that you wish to encrypt. Cleartext
    is another popular term that is used interchangeably with plaintext depending
    on who you ask.
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the encrypted version of plaintext. This is the data that is safe to
    send to the receiving party.
  prefs: []
  type: TYPE_NORMAL
- en: Ciphers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cipher is a mathematical function, or algorithm, that is used to encrypt plaintext
    data into ciphertext. However, a cipher is not enough to create ciphertext from
    plaintext – you also require a key that defines the unique way your encryption
    will work. All keys are generated uniquely. Depending on the type of cipher you
    make, you'll have one or two keys to encrypt and decrypt your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize a cipher in Java, you''ll need to know three things about it:
    the algorithm used, the mode, and the type of padding. Different ciphers work
    in different ways, so defining the correct transformation is critical to avoid
    causing exceptions or creating insecure applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The algorithms or ciphers are kept in what we call cryptographic providers (or
    just providers). Depending on the system in which the application is running,
    you may not have access to all kinds of ciphers out of the box. In some cases,
    you may even have to install additional providers to access the cipher you wish
    you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, every **Java Virtual Machine** (**JVM**) does come with a set of available
    ciphers with different transformations. At the very least, you''ll always find
    the following transformations available on any JVM today:'
  prefs: []
  type: TYPE_NORMAL
- en: AES/CBC/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES/CBC/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES/ECB/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES/ECB/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AES/GCM/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES/CBC/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES/CBC/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES/ECB/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES/ECB/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESede/CBC/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESede/CBC/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESede/ECB/NoPadding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DESede/ECB/PKCS5Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA/ECB/PKCS1Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA/ECB/OAEPWithSHA-1AndMGF1Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA/ECB/OAEPWithSHA-256AndMGF1Padding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every cipher requires at least one key to encrypt the plaintext and decrypt
    the ciphertext. Depending on the type of cipher, the key can be either symmetric
    or asymmetric. Usually, you''ll work with keys stored in non-volatile memory,
    but you can also generate keys from code. In the JCA, there is a simple command
    that is used to generate a key for a specific cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Symmetric Key Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symmetric encryption is usually considered less safe than asymmetric encryption.
    This is not because the algorithms are less secure than asymmetric encryption,
    but because the key that is used to unlock the content must be shared by more
    than one party. The following diagram illustrates how symmetric encryption works,
    in general terms.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Symmetric encryption](img/C13927_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Symmetric encryption'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create keys for symmetric encryption in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One of the most popular symmetric encryption methods today is the **Advanced
    Encryption Standard** (**AES**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Encrypting the String Using Advanced Encryption Standard'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will encrypt the "`My secret message`" string using AES:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project opened, then select `File` -> `New`
    -> `Project` from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `New Project Dialog`, select a Java project. Click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`.
    Then, click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Chapter10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location; if you wish to select your
    own, you can enter it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Finish`. IntelliJ will create your project called `Chapter10` with
    the standard folder structure. IntelliJ will also create the main entry point
    for your application, called `Main.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decide on the algorithm that you want to use for your encryption – in this
    example, we''re using AES –then, generate the key for the encryption. Generating
    the key may cause an exception if the selected algorithm isn''t supported by any
    of the providers on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we're using a variable to store the key. However, in most
    real-life scenarios, you'll likely use a less volatile form of storage—such as
    a file or database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to define the actual encryption transformation to use. As
    mentioned previously, the transformation contains information about how to handle
    the cipher. In this case, we''re using AES, which is a block cipher, so we need
    to define how to apply the key to each block of the plaintext data. Additionally,
    we need to define whether there should be any padding, and what that padding should
    look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We already chose AES as the algorithm, so we're starting the transformation
    with that. Following this, we've decided to go for the less-safe **Electronic
    Code Book** (**ECB**) transformation mode, which means we're applying the key
    in the same way for each block of plaintext data. Finally, we've defined that
    we'll use no padding if a block in the plaintext data is shorter than the cipher
    block length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Query the system for the cipher with the suggested transformation. This method
    can throw both `NoSuchAlgorithmException` and `NoSuchPaddingException.` Make sure
    to handle this if that is the case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Encrypting and decrypting is almost identical when compared to the Java API.
    When encrypting a plaintext file, you initiate the cipher in encryption mode,
    and when decrypting a ciphertext file, you initiate the cipher in decryption mode.
    This may cause `InvalidKeyException` if the key is wrong:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In fact, encrypting your text is a two-step process, and you always need to
    adjust your work depending on the actual bytes of the data. Since we''re working
    on a `String`, you will need to get the actual bytes of this `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you may have noticed, there are a lot of things that could go wrong when
    working with encryption. Usually, you should handle these exceptions gracefully,
    but in this case, we'll just print them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, the last thing to do is print the encrypted version of the text to verify
    that you''ve encrypted the data. You should see gibberish in the terminal. That''s
    fine; it just means you''ve succeeded in hiding the plaintext message in a ciphertext
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you change the transformation padding to `NoPadding`?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What happens if you keep the `PKCS5Padding` but change the plaintext message
    to "`This is 16 bytes`"?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to decrypt the message by instead initializing the cipher to `MODE_DECRYPT`,
    and then passing the ciphertext rather than the plaintext message. Remember, you
    need to use the same key for this process to work; otherwise, you'll see gibberish
    again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Block Ciphers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AES is a block cipher, meaning that encryption is handled on one block of plaintext
    at a time. A block size depends on the key size; that is, a larger key means a
    larger block.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the transformation modes for block ciphers require you to work with
    an initialization vector – it's an improvement that handles the obvious repeat
    pattern of the ECB mode. This is easily visualized by an image showing the difference
    in encryption using AES/ECB and AES/CBC.
  prefs: []
  type: TYPE_NORMAL
- en: CBC refers to **Cipher Block Chaining** and, in short, it scrambles the current
    block of data based on the previous block of data. Or, if it was the first block,
    it scrambles the data based on the initialization vector.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Ciphers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stream cipher, on the other hand, works by encrypting each byte at a time.
    There is a theoretical discussion about what is known as "the one-time pad," which
    represents the ideal stream encryption. These are, in theory, extremely secure,
    but are also very impractical, as the key must be the same length as the plaintext
    data. With large plaintext data, such keys are impossible to use.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Key Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In asymmetric key encryption, the private key is held by one party only—the
    receiver or owner of the data. The sender of the data, who is not considered the
    owner, uses what we call a public key to encrypt the data. The public key can
    be held by anyone without jeopardizing any previously encrypted messages. This
    is considered a more secure way of handling encryption, as only the receiver can
    decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Encrypting the String Using the RSA Asymmetric Key Encryption'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encrypt the "`My secret message`" message using the **Rivest–Shamir–Adleman**
    (**RSA**) asymmetric key encryption. This is a public/private key combination:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter10` project in IDEA if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class using the `File -> New -> Java Class` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Exercise2` as `Name`, and then select `OK`. You should now have an empty
    class in your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main` method—you''ll write all your code in that for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a plaintext `String` with the content "`My secret message`":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another string "RSA" in which you''ll write the algorithm for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because RSA is an asymmetric form of key encryption, you need to generate a
    key pair instead of a key. Catch the exception if the algorithm is not found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the transformation; we''ll go with electronic code block and `PKCS1Padding`
    for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a cipher for the algorithm and initialize it with the chosen transformation.
    Remember to always use the public key when encrypting with RSA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, encrypt the plaintext into ciphertext, you'll notice that the ciphertext
    is much larger when using RSA than AES. This is because of the key size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the decrypt logic for RSA. Remember to use the private key
    when decrypting; otherwise, it will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encrypting files is very much like encrypting strings. However, with large files,
    it may be wise to empty the cipher streams. However, if the file is too large,
    or if there are multiple files, then it may be wise to apply `CipherStreams`—not
    to be confused with Stream Cipher.
  prefs: []
  type: TYPE_NORMAL
- en: '`CipherStreams` inherit most of their behavior from `InputStream` and `OutputStream`
    of Java, with the modification that you can decrypt a file you read, or encrypt
    a file you write with the supplied cipher.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Encrypting a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following exercise displays how to encrypt a file. You can find this file
    in the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter10` project in IDEA if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class, using the `File` | `New` | `Java Class` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `Exercise3` as Name, and then select `OK`. You should now have an empty
    class in your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main` method in which you''ll write the code for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the algorithm to use for your encryption; we''ll go back to AES for
    this exercise and generate the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get an instance of the cipher and initialize it for encryption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file for the encryption; you can download the `plaintext.txt` file
    from the book''s GitHub repository if you wish. Alternatively, you can just create
    your own text file using lipsum—or even better, copy a document from your computer.
    We''re placing these files in the "`res`" folder of your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to this, create a file that will hold the encrypted contents. Make
    sure the file doesn''t already exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to add the cipher streams. In this instance, we need `FileInputStream`
    to read the contents of the `plaintext.txt` file, `FileOutputStream` to write
    an initialization vector, and `CipherOutputStream` to perform the encryption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the initialization vector; you will find it in the initialized cipher.
    Make sure to use `FileOutputStream` as we do not want to encrypt these bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, write the contents of `FileInputStream` to `CipherOutputStream`, allowing
    the contents to be encrypted in the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are numerous ways of working with files in Java, and this is just one
    way of encrypting the contents. If you have larger files, perhaps `BufferedReader`
    would be a good option to use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instead of encrypting a file, use the cipher streams to encrypt a whole folder.
    Perhaps the best practice here is to first compress the folder into a ZIP archive
    and then encrypt that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JCA contains everything you need to work with encryption. In this chapter,
    you've only really scratched the surface of this major framework. This is just
    enough to get you started, but if you intend to progress further into the complexities
    of this framework, you will first need to develop a greater understanding of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the launching of processes, as well as sending
    input and capturing the output of child processes.
  prefs: []
  type: TYPE_NORMAL
- en: XRB39
  prefs: []
  type: TYPE_NORMAL
