- en: Chapter 5. Combining Persistence with CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier chapters, we discussed Java EE, combining several technologies
    such as CDI. The examples so far, however, are based on a false assumption that
    all the information can be stored in memory. In this chapter, we will show how
    to use a persistent data store for our application in the form of a standard relational
    database.
  prefs: []
  type: TYPE_NORMAL
- en: The **Enterprise JavaBeans** (**EJB**) 3.2 specification includes a reference
    to a persistence specification called the **Java Persistence API** (**JPA**).
    It is an API to create, remove, and query Java objects called **entities** that
    can be used within both a compliant EJB 3.x container and a standard Java SE environment.
    In Java EE 7, it has been updated to Version 2.1\. You can check out the current
    version of the specification I the JSR 338 at [https://jcp.org/en/jsr/detail?id=338](https://jcp.org/en/jsr/detail?id=338).
  prefs: []
  type: TYPE_NORMAL
- en: We need to warn you that in this chapter, you have a lot of things to learn
    and hence concepts will be coming at you from every direction. However, at the
    end of it, you will be able to appreciate exactly how to create and deploy a complete
    Java EE 7 application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The key features of JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create your entities and database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate the entities using CDI Beans and EJBs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivering a frontend tier for our application using JSF and Facelets technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data persistence meets the standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The arrival of an Enterprise Java Persistence standard based on the **Plain
    Old Java Object** (**POJO**) development model fills a substantial gap in the
    Java EE platform. The previous attempt (the EJB 2.x specification) missed the
    mark and created a stereotype of EJB entity beans that was awkward to develop
    and too heavy for many applications. Therefore, it never achieved widespread adoption
    or general approval in many sectors of the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Software developers knew what they wanted, but many could not find it in the
    existing standards, so they decided to look elsewhere. What they found was lightweight
    persistence frameworks, both in the commercial and open source domains.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to EJB 2.x entity beans, the EJB 3.0 **Java Persistence API** (**JPA**)
    is a metadata driven POJO technology, that is, to save the data held in Java objects
    in a database, our objects are not required to implement an interface, extend
    a class, or fit into a framework pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Another key feature of JPA is the query language called the **Java Persistence
    Query Language** (**JPQL**), which gives you a way to define the queries in a
    portable way, independent of the particular database you use in an enterprise
    environment. JPA queries resemble SQL queries by syntax but operate against entity
    objects rather than directly with database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inspired by ORM frameworks such as Hibernate, JPA uses annotations to map objects
    to a relational database. JPA entities are POJOs that do not extend any class
    nor implement any interface. You don''t even need XML descriptors for your mapping.
    Actually, the JPA API is made up of annotations and only a few classes and interfaces.
    For example, we will mark the `Company` class as `@Entity`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code shows the minimal requirements for a class to be
    persistent, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be identified as an entity using the `@javax.persistence.Entity` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have an identifier attribute annotated with `@javax.persistence.Id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a no-argument constructor in at least the protected scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you will learn better with an example, we will show how to create and
    deploy a sample JPA application in WildFly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding persistence to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to persist data, JPA needs a relational database; we will use the PostgreSQL
    database, which is pretty popular among developers and can be downloaded for free
    from [http://www.postgresql.org/download/](http://www.postgresql.org/download/).
    It is recommended to download the latest stable release of PostgreSQL 9.x and
    install it using the simple installation wizard. If you don't need a full-blown
    database, then keep in mind that later we will also show you how to use an in-memory
    database provided by WildFly, which can be a really useful alternative during
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a database named `ticketsystem`; we will then add a user named
    `jboss` and assign him/her all privileges on the schemas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a shell under the `bin` folder of your PostgreSQL installation and launch
    the executable `psql –U postgres`. Once logged in with the password from your
    installation, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our simple schema will be made up of two tables: the `SEAT` table, which contains
    the list of all the available seats in the theatre, and the `SEAT_TYPE` table,
    which is used to categorize the seat types. The two tables are in a *1-n* relationship
    and the `SEAT` table hosts a foreign key that relates to the ID of the `SEAT_TYPE`
    table. We will, however, let JPA generate the schema for us, based on our class
    hierarchy, which we will model in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDBC driver in WildFly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database connectivity is carried out in Java using JDBC drivers, which are used
    either directly in your applications or behind the scenes in JPA. The PostgreSQL
    JDBC driver can be downloaded for free from [http://jdbc.postgresql.org/download.html](http://jdbc.postgresql.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once the download is complete, place the `postgresql-9.X-X.jdbc41.jar` file
    at a convenient location on your filesystem. We will now see how to install the
    JDBC driver in WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: In JBoss AS 5 and 6, you used to install the JDBC driver in the `common/lib`
    folder of your server distribution. In the new modular server architecture (introduced
    in JBoss AS 7), you have more than one option to install your JDBC driver. The
    recommended approach consists of installing the driver as a module.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to install a new module requires creating a module path under
    `JBOSS_HOME/modules` and placing the `.jar` libraries and the `module.xml` file
    (that declares the module name and its dependencies) there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will add the following units to our filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JBOSS_HOME/modules/org/postgresql/main/postgresql-9.3-1101.jdbc41.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JBOSS_HOME/modules/org/postgresql/main/module.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start by simply creating the required directories in your WildFly installation
    (to which the `JBOSS_HOME` variable points), and copying the downloaded JAR file
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the main folder, add a file named `module.xml`. This file contains the
    actual module definition; the most interesting part of it is the module name (`org.postgresql`),
    which corresponds to the module attribute defined in your data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to state the path to the JDBC driver resource and the module
    dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done with the module installation. Now we need to define a data source
    in our configuration that will use this module and hold a pool of connections
    in our PostgreSQL database. In order to do this, you can edit `standalone.xml/domain.xml`,
    adding a driver element to the data source''s subsystem (be sure to merge this
    configuration with any existing data sources in your configuration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new configuration file borrows the same XML schema definition
    from the earlier JBoss AS configurations, so it should not be difficult to migrate
    to the new schema. Basically, you will define the connection path to the database
    using the `connection-url` string and the JDBC driver class with the `driver`
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since JBoss AS 7.1.0, it's mandatory that the data source be bound to the `java:/`
    or `java:jboss/` JNDI namespace. This will standardize the resources definition
    among developers, avoiding bizarre JNDI bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Using the command-line interface to create a new data source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application server provides more than one option to add a data source to
    your configuration. We will just mention the command-line interface approach,
    which can be quite useful, especially if you plan to modify your configuration
    using script files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the `jboss-cli.sh` script (or `jboss-cli.bat`) and connect to the application
    server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now issue the following command, which actually creates a new data source,
    accomplishing the same goal we obtained by editing the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The CLI should respond with a `success` message if everything goes well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application that we're going to create in this chapter will require only
    standard Java EE 7 APIs from us. Having knowledge from previous chapters, you
    should be able to set up a project for this chapter by yourself! Just use your
    favorite IDE and create a Maven project with `war` type. Remember to include the
    configuration for Java SE 8, `beans.xml` and `faces-config.xml` files. If you
    face any problems, remember that code samples available with this book contain
    a full project based on this example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Maven configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that your Maven skeleton is set up, we will include the required dependencies
    so that Eclipse will be able to compile your classes as you code them. The only
    dependency you will need for this type is `javaee-api`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cooking entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're done with the configuration part, we will add our entities to
    the project. Some valuable options exist to autogenerate our entities, starting
    with the database schema. For example, the Eclipse's **File** menu includes an
    option **JPA Entities from Table** that (once a connection has been set up in
    the database) allows you to reverse your DB schema (or a part of it) into Java
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are willing to try this option, remember that you need to activate the
    **Eclipse JPA** facet in your project, from **Project Properties**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cooking entities](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One more option is mentioned in [Appendix](part0067_split_000.html#page "Appendix A. Rapid
    Development Using JBoss Forge"), *Rapid Development Using JBoss Forge*, which
    discusses JBoss Forge, a powerful, rapid application development (aimed at Java
    EE) and project comprehension tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on generating SQL scripts from Java classes.
    Whatever your strategy is, the expected outcome needs to conform to the following
    entities. Here is the first one, `SeatType`, which maps the table `SEAT_TYPE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first meaningful annotation is `@Entity [1]`, which declares the class `Entity`.
    The `@Table [2]` annotation is used to map the bean class with a database table.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation, `[3]`, is a mandatory one; it describes the primary key
    of the table. Along with `@Id`, there is the `@GeneratedValue` annotation. This
    is used to declare that the database is in charge of generating the value. You
    can check the Javadoc of this class to explore other strategies for value generation.
  prefs: []
  type: TYPE_NORMAL
- en: Moving along, the `@OneToMany` annotation `[4]` defines an association with
    one-to-many cardinality. Actually, the `SeatType` class has many seats. The corresponding
    `Seat` reference is contained in a list collection. We define the `mappedBy` attribute
    in order to set the field, which owns the relationship on the many side.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetch` attribute defines that JPA should fetch the list of seats whenever
    a `seat` type is loaded from the database. A lazy configuration for a relationship
    would cause the list to be fetched on the first call to that field.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that we have not included here, for the sake of brevity, the field
    getters and setters that have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Seat` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Seat` entity has the corresponding `@ManyToOne [1]` annotation,
    which naturally complements the `@OneToMany` relationship. The `@JoinColumn [2]`
    notifies the JPA engine that the `seatType` field is mapped through the foreign
    key of the database's seat ID.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Bean Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bean Validation (JSR-303)** is a validation model available as part of the
    Java EE 6 platform. The new 1.1 version (**JSR-349**) is a part of Java EE 7\.
    The Bean Validation model is supported by constraints in the form of annotations
    placed on a field, method, or class of a JavaBeans component, such as a managed
    bean.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `SeatType` entity will be created using an input form; therefore,
    we will need to validate the data that has been entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will place a `@javax.validation.constraints.NotNull` constraint
    in every field that is part of the `SeatType` entry form, and a more complex constraint
    in the `description` field, which will set the maximum size for the seat description
    to `25` (the `@javax.validation.constraints.Size` constraint) and allow just letters
    and spaces in it (the `@javax.validation.constraints.Pattern` constraint):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can also place a description on a constraint, which can be
    used to provide a customized error message to the JSF layer should the data fail
    to pass the constraint. You can check the Oracle documentation for a full list
    of constraints available at [http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ](http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have added a seat position information to our seat type. It is a simple
    enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When we save our `SeatType` entity in the database, we will also store the
    enum value with it. Earlier versions of JPA gave us two options to address it
    automatically (besides manually managing their status), `@Enumarated(EnumType.STRING)`
    and `@Enumarated(EnumType.ORDINAL)`; both had their flaws. The first one is sensitive
    towards enum renaming; the entities in the database will have the full name of
    the enum stored (which sometimes is also a waste of the storage space). The second
    one could create problems when the order of enums would be changed (because it
    stored the index of the enum value). From JPA 2.1, we can create a converter,
    which will automatically convert our enum attributes to specific entries in the
    database. We only need to create an annotated class, which implements the `AttributeConverter`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's all, no additional configuration is required. The `autoApply` attribute
    set to `true` signals JPA to take care of all of our `SeatPosition` enums in entities.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Entity API looks great and is very intuitive, but how does the server know
    which database is supposed to store/query the entity objects? The `persistence.xml`
    file, which will be placed under `src/main/resources/META-INF` of your project,
    is the standard JPA configuration file. By configuring this file, you can easily
    switch from one persistence provider to another and thus, also from one application
    server to another (believe it or not, this is a huge leap towards application
    server compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `persistence.xml` file, we will basically need to specify the persistence
    provider and the underlying data source used. Simply create the following file
    under `src/main/resources/persistence.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have highlighted the most important attributes in `persistence.xml`. The
    `name` attribute is a mandatory element, which will be used to reference the persistence
    unit from our Enterprise JavaBeans.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code, we use the WildFly built-in memory H2 database ([http://www.h2database.com/](http://www.h2database.com/))
    available by default at `java:jboss/datasources/ExampleDS` (so that it is possible
    to run the example without any setup). However, you can use a configured PostgreSQL
    connection here, `java:jboss/datasources/wflydevelopment`, which we created earlier.
    In Java EE 7, you could even omit the whole `jta-data-source` tag. Every container
    is now obliged to provide a default data source for applications to use. For WildFly,
    it would be the aforementioned H2 database.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the classes that should be considered as entities. This is an
    optional step; if the entities are in the same archive as the `persistence.xml`
    file, they will be autodiscovered.
  prefs: []
  type: TYPE_NORMAL
- en: In previous JPA versions, almost every configuration needed some provider-specific
    properties. In JPA 2.1, a number of standard properties were added, such as presented
    `javax.persistence.schema-generation.database.action`. The `drop-and-create` value
    can be used to create and drop your database tables each time you deploy your
    application. This can be an advantage if you want to start with a clean storage
    each time you deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is also possible to instruct JPA to generate SQL scripts for you,
    so you can manually apply them to the database. Simply add the following entries
    to your `persistence-unit` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you don't specify the location by specifying an additional property, then
    the generated scripts will be placed in the `JBOSS_HOME/bin` directory, with the
    names that you provided in the configuration. The names can be absolute paths,
    so you can get the scripts to any place in your filesystem (if WildFly is permitted
    to write them there of course).
  prefs: []
  type: TYPE_NORMAL
- en: Adding producer classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Producer classes have been introduced in the earlier chapter as a means of providing
    some resources through CDI to our application. In this example, we will use it
    to produce many resources, such as the JPA Entity Manager and the list of objects
    that are transferred to the JSF views. For this reason, we provided the `LoggerProducer`,
    `FacesContextProducer`, and `EntityManagerProducer` classes that contain some
    general-purpose resources and single instances of the `SeatProducer` and `SeatTypeProducer`
    classes, which will be used to produce collections of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the content of the three basic producer classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, these classes will be the factory for the following three kinds
    of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityManager`: This will resolve the primary persistence unit since there
    is just one persistence unit defined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Logger`: This will trace some information on the server console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FacesContext`: This will be used to output some JSF messages on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Producers versus the Java EE 5 @Resource injection**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have never used the dependency injections framework before, you might
    wonder what the benefit of adding an extra layer to produce some container resources
    is. The reason becomes evident once you need to change some configuration elements,
    such as the persistence unit. With the older Java EE 5 approach, you will be forced
    to change the `@Resource` injection's details wherever they are used; however,
    using a producer method for it will centralize resource creation, making changes
    trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add some entity producers; let''s add the `SeatTypeProducer`
    and `SeatProducer` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you have gone through our example in [Chapter 4](part0028_split_000.html#page
    "Chapter 4. Learning Context and Dependency Injection"), *Learning Context and
    Dependency Injection*, you will find nothing new here; as you can see, the class
    will merely produce a collection of `seatTypes`, which is tagged as `@Named` so
    that they can be accessed from JSF EL as well. Additionally, the class contains
    an `observer` handler method (`onListChanged`), which will be fired when data
    in the collection is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection data is filled using the `retrieveAllSeatTypes` method (loaded
    the first and only time when the class is constructed) of the `SeatTypeDao` CDI
    Bean. We will define this bean in a moment; right now, we will add the last producer
    class used in this example, the `SeatProducer` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding bean will be used to produce the list of `Seat` objects that will
    actually be available for booking.
  prefs: []
  type: TYPE_NORMAL
- en: Coding queries for your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see from the earlier code, the producer classes make use of beans
    named `SeatDao` and `SeatTypeDao` to fill their collections of data. These beans
    perform some simple finds on the `Seat` and `SeatType` objects, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both `SeatDao` and `SeatTypeDao` beans extend the generic `AbstractDao`
    class. It wraps `EntityManager` and provides basic type-safe CRUD operations such
    as `findAll`, `persist`, and so on using the JPA Criteria API. JPA allows execution
    of the following three types of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native SQL**: These queries use the standard SQL language. When using this
    type of queries, you have to remember queries can be incompatible when migrating
    between different databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Persistence Query Language** (**JPQL**): These queries can be formed
    using special language similar to SQL. In practice, this method is often hard
    to maintain without good IDE support, especially during refactoring. These queries
    can also be compiled at startup, which means that they are not resolved multiple
    times. Finally, they can be used by a caching mechanism to avoid unnecessary database
    operations for queries that are called frequently. You can define a query and
    its name in the entity in the `@NamedQuery(name="…", query="…")` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Criteria API**: These queries can be formed by simply executing Java methods
    and the usage of appropriate objects. Since JPA 2.1, it''s possible to perform
    bulk updates and deletions through this API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make a simple comparison of these three methods using an example. We
    want to just get all the objects of a given type. Using native SQL, this query
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it uses standard SQL in the form of a string. Now let''s look
    at JPQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to notice its similarity to SQL but a bit different. It uses, for
    example, class name instead of table name. However, again, it''s a query in a
    string. The last example is the Criteria API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it looks like the most complicated one, but it has some advantage,
    that is, it does not use any strings (which are usually error-prone and hard to
    refactor). Both JPQL and Criteria API have many improvements in the newest JPA
    version, concerning join operations using the `on` condition, database functions
    support, and arithmetic subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: You may ask yourself, "Which one should I use?" It's a hard question because
    all of them have their pros and cons so it depends on the specific case. Basically,
    Criteria query and named queries are normally a safe bet. Native SQL should have
    a really good justification, as it's usually not portable between different vendors
    and cannot be validated by JPA before the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Adding services to your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we coded all the information that will be visible to the user through
    the application screen. What is obviously missing here is all the business logic
    that translates ultimately into inserting data or updating the existing data.
    For this reason, we will now add two classes; first, under `com.packtpub.wflydevelopment.chapter5.control`
    package and second under `com.packtpub.wflydevelopment.chapter5.controller`. The
    first one is `TicketService`, which is a stateless EJB that will be used to perform
    the core business logic of this application, and the second one is our `stateful`
    EJB''s counterpart, the `BookerService` class. Let''s start with the stateless
    EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why has this component been coded as an EJB instead of a CDI Bean?**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of using EJBs is that they are inherently transactional
    components. However, in Java EE 7, we can use CDI Beans with an additional `@Transactional`
    annotation. The choice now is up to the developer, but EJBs can still prove useful
    in some cases, even for local calls; for example, we can easily demarcate security
    for them (which we will do in the future chapters).
  prefs: []
  type: TYPE_NORMAL
- en: This service is made up of four methods. The first is the `createSeatType` method,
    which will be used in the first application screen to add a new `SeatType` object
    to our theatre. The next method, `createTheatre`, will be invoked once we are
    done with setting up our theatre; so we create the list of seats that will be
    available for booking in the next screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next in the list is the `bookSeat` method, which, as you might have guessed,
    will be used to book a seat. Finally, the `doCleanUp` method is actually used
    to perform a cleanup if you want to restart the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of our puzzle is the `BookerService` class, which adds a tiny
    session layer to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class uses the view scope, which we already described in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a controller to drive user requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The link between the persistence layer and the user''s view falls on the `TheatreSetupService`
    bean, which will drive requests to the actual services exposed by our application.
    Since this bean will be bound to `RequestScope` and we need to expose it to our
    views as well (using `@Named`), we can use the convenient `@Model` annotation
    for it, which is a sum of the following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TheatreSetupService` class is expected to complete the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: At first, the `TheatreSetupService` class produces a `SeatType` object `[1]`
    and exposes it to the JSF View layer using the `@Named` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This technique is a great addition provided by CDI since it removes the need
    to create a boilerplate object, `SeatType`, to transport the information from
    the view to the services. The `SeatType` object is produced by the controller
    and will be populated by the JSF view and persisted by the `TheatreSetupService`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It then drives user navigation between the application screens by returning
    to the home page `[4]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are done with the Java classes. You should now check to make sure that your
    project structure matches the following screenshot:![Adding a controller to drive
    user requests](img/00046.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coding the JSF view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our middle tier is completed, we just need to add a couple of JSF views
    to our application in the `views` folder of our web app. The first view, named
    `setup.xhtml`, will set up our theatre and the second one, named `book.xhtml`,
    will be used to book tickets, borrowing some of its code from the earlier chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, this time we would like to make our application a little bit more graphically
    appealing. To keep it simple, we will use **Bootstrap**, a very popular frontend
    framework that will nicely integrate with our JSF views. It heavily relies on
    JavaScript and CSS, but we will only need to use basic HTML to get it up and running
    in our application. Incorporating a strict frontend framework to our application
    will be an opportunity to show how to use Java EE 7 with the newest web technologies.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the latest version of Bootstrap from [http://getbootstrap.com/](http://getbootstrap.com/)
    and just place all files in the resources directory; however, we won't do it here.
    We will use the WebJars, which are simply JARs that pack client-side web libraries.
    You can find dependencies at [http://www.webjars.org/](http://www.webjars.org/),
    which after adding to your `pom.xml` file will work just like manually adding
    static files to the project. However, thanks to WebJars, we get Maven to control
    our versions, and don't need to worry about polluting our codebase with external
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need Bootstrap and jQuery, so we will add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we have the Bootstrap''s libraries in place, we have to link them
    to our code. We will add them to our `WEB-INF/templates/default.xhtml` file along
    with a simple navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will move to the content in `setup.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding view contains a form to enter a new seat type
    in the topmost section. The highlighted input text will actually pass data to
    the `SeatType` object, which will be transferred to the `TheatreSetupService`
    CDI Bean and ultimately persisted when the user clicks on the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice many `class` attributes on the tags. These attributes refer
    to the CSS classes defined by Bootstrap; we use them to visualize our validation.
    If a user places some invalid data in a form input, a proper CSS class is assigned
    to it (Bootstrap's `has-error` method in our case). This is, however, a strictly
    frontend-related addition. The JSF validation message will be shown with or without
    it thanks to the `h:messages` tag and the Bean Validation constraints defined
    in the earlier part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting addition is the fact that we use one of the JSF 2.2 features,
    which eases integration with HTML5 frontend frameworks, the `pass-through` attributes.
    By using the `xmlns:p=http://xmlns.jcp.org/jsf/passthrough` namespacein `p:placeholder`,
    we instruct JSF to ignore an unknown attribute and pass it straight to the renderer.
    Then, Bootstrap's internal mechanisms can interpret the attribute, and provide
    our input controls with placeholder text, which disappears after a control gains
    focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the `setup.xhtml` file is available in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each time you add a new block of seats to your theatre, the `dataTable` method
    contained in the lower part of the screen will be updated. When you are done with
    your setup, click on the **Finish** button, which will recall the `finish` method
    of the `TheatreSetupService` CDI Bean, creating the list of seats.
  prefs: []
  type: TYPE_NORMAL
- en: 'This action will also redirect you to the next view, named `book.xhtml`, which
    is used to book seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a snapshot of the project, expanded at the **webapp** level (as you
    can see, we have also included a basic `index.html` screen and an `index.xhtml`
    screen to redirect the user to the initial screen, `setup.xhtml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the JSF view](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running the example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deploying the application requires, as usual, packaging it using the following
    Maven goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, provided that you have installed the WildFly Maven plugin, you can
    deploy your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment has successfully completed, visit `http://localhost:8080/ticket-agency-jpa/`
    to view the application''s welcome page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the example](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Congratulations! You''re done. By clicking on the **Setup Theatre** link, you
    can start creating places in the `setup.xhtml` page. Feel free to experiment with
    the inputs, and try to fill some letters in the price box or numbers in the description,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the example](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the **Finalize the theatre setup** button, you will be redirected
    to the last screen, which performs seat booking in `book.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the example](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of the new Java Persistence API is to simplify the development of persistent
    entities. It meets this objective through a simple POJO-based persistence model,
    which reduces the number of required classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground, starting with the database schema
    that we reverse engineered using the JBoss tools plugins for Eclipse. Next, we
    coded the set of layers (producers, services, and controllers) that are part of
    the application, along with the JSF Facelets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss developing applications using **JBoss Messaging
    Provider** (**HornetQ**) by introducing examples with message-driven beans using
    the new simplified Java EE 7 API.
  prefs: []
  type: TYPE_NORMAL
