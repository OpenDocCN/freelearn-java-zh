["```java\n    implementation 'org.springframework.boot:spring-boot-starter-security'\n    ```", "```java\n    @Configuration\n    @EnableWebSecurity\n    public class SecurityConfig {\n        @Bean\n        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n            http\n                    .csrf(AbstractHttpConfigurer::disable)\n                    .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                    .authorizeHttpRequests(authz -> authz\n                            .requestMatchers(\"/login\").permitAll()\n                            .anyRequest().authenticated()\n                    )\n                    .httpBasic(Customizer.withDefaults());\n            return http.build();\n        }\n    }\n    DENY response from this request because we have hidden the endpoints behind Spring Security.\n    ```", "```java\nversion: '3.1'\nservices:\n  db:\n    image: postgres\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: yourpassword\n      POSTGRES_DB: bookstore\n    ports:\n      - \"5432:5432\"\n  mongodb:\n    image: mongo\n    restart: always\n    ports:\n      - \"27017:27017\"\n    environment:\n      MONGO_INITDB_DATABASE: bookstore\n  keycloak_db:\n    image: postgres\n    restart: always\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloakpassword\n    ports:\n      - \"5433:5432\"\n  keycloak:\n    image: bitnami/keycloak:latest\n    restart: always\n    environment:\n      KEYCLOAK_USER: admin\n      KEYCLOAK_PASSWORD: admin\n      DB_VENDOR: POSTGRES\n      DB_ADDR: keycloak_db\n      DB_PORT: 5432\n      DB_DATABASE: keycloak\n      DB_USER: keycloak\n      DB_PASSWORD: keycloakpassword\n    ports:\n      - \"8180:8080\"\n    depends_on:\n      - keycloak_db\n```", "```java\n    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'\n    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'\n    ```", "```java\n    spring.security.oauth2.client.registration.keycloak.client-id=bookstore-client\n    spring.security.oauth2.client.registration.keycloak.client-secret=<Your-Client-Secret>\n    spring.security.oauth2.client.registration.keycloak.client-name=Keycloak\n    spring.security.oauth2.client.registration.keycloak.provider=keycloak\n    spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email\n    spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code\n    spring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/keycloak\n    spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm\n    spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm\n    ```", "```java\n     @Bean\n        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n            http\n                    .csrf(AbstractHttpConfigurer::disable)\n                    .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                    .authorizeHttpRequests(authz -> authz\n                            .requestMatchers(\"/login\").permitAll()\n                            .anyRequest().authenticated()\n                    )\n                    .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));\n            return http.build();\n        }\n    ```", "```java\n    public record LoginRequestDto(String username, String password) {}\n    ```", "```java\n    @Configuration\n    public class AppConfig {\n        @Bean\n        public RestTemplate restTemplate() {\n            return new RestTemplate();\n        }\n    }\n    ```", "```java\n    @RestController\n    public class LoginController {\n        @Value(\"${spring.security.oauth2.client.registration.keycloak.client-id}\")\n        private String clientId;\n    @Value(\"${spring.security.oauth2.client.registration.keycloak.client-secret}\")\n        private String clientSecret;\n    @Value(\"${spring.security.oauth2.resourceserver.jwt.issuer-uri}\")\n        private String baseUrl;\n        @PostMapping(\"/login\")\n        public ResponseEntity<?> login(@RequestBody LoginRequestDto loginRequestDto) {\n            String tokenUrl = baseUrl + \"/protocol/openid-connect/token\";\n            // Prepare the request body\n            MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>();\n            requestBody.add(\"client_id\", clientId);\n            requestBody.add(\"username\", loginRequestDto.username());\n            requestBody.add(\"password\", loginRequestDto.password());\n            requestBody.add(\"grant_type\", \"password\");\n            requestBody.add(\"client_secret\", clientSecret);\n            // Use RestTemplate to send the request\n            RestTemplate restTemplate = new RestTemplate();\n            ResponseEntity<String> response = restTemplate.postForEntity(tokenUrl, requestBody, String.class);\n            // Return the response from Keycloak\n            return ResponseEntity.ok(response.getBody());\n        }\n    }\n    ```", "```java\ncurl --location \"http://localhost:8080/login\"\n--header \"Content-Type: application/json\"\n--data \"{\n    \\\"username\\\":<username>,\n    \\\"password\\\":<password>\n}\"\n```", "```java\n{\n    \"access_token\": <JWT Token>\n    \"expires_in\": 300,\n    \"refresh_expires_in\": 1800,\n    \"refresh_token\": <JWT Token>,\n    \"token_type\": \"Bearer\",\n    \"not-before-policy\": 0,\n    \"session_state\": \"043d9823-7ef4-4778-b746-10dd8e75baa4\",\n    \"scope\": \"email profile\"\n}\n```", "```java\ncurl --location \"http://localhost:8080/books\"\n--header \"Authorization: Bearer <access_token>\"\n```", "```java\n    @EnableMethodSecurity\n    public class SecurityConfig {\n        @Bean\n        public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n            http\n                .csrf(AbstractHttpConfigurer::disable)\n                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .authorizeHttpRequests(authz -> authz\n                    .requestMatchers(\"/login\").permitAll()\n                    .requestMatchers(HttpMethod.POST, \"/books\", \"/authors\").hasAuthority(\"ROLE_ADMIN\")\n    .requestMatchers(HttpMethod.GET, \"/books/**\",\"/reviews/**\", \"/authors/**\", \"/publishers/**\").hasAnyAuthority(\"ROLE_USER\",\"ROLE_ADMIN\")\n                    .anyRequest().authenticated()\n                )\n                .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.jwtAuthenticationConverter(new KeycloakRoleConverter())));\n            return http.build();\n        }\n    }\n    ```", "```java\n    public class KeycloakRoleConverter implements Converter<Jwt, AbstractAuthenticationToken> {\n        @Override\n        public AbstractAuthenticationToken convert(Jwt jwt) {\n            // Default converter for scopes/authorities\n            JwtGrantedAuthoritiesConverter defaultAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();\n            Collection<GrantedAuthority> defaultAuthorities = defaultAuthoritiesConverter.convert(jwt);\n            // Extract realm_access roles and map them to GrantedAuthority objects\n            Collection<GrantedAuthority> realmAccessRoles = extractRealmAccessRoles(jwt);\n            // Combine authorities\n            Set<GrantedAuthority> combinedAuthorities = new HashSet<>();\n            combinedAuthorities.addAll(defaultAuthorities);\n            combinedAuthorities.addAll(realmAccessRoles);\n            return new AbstractAuthenticationToken(combinedAuthorities) {\n                @Override\n                public Object getCredentials() {\n                    return null;\n                }\n                @Override\n                public Object getPrincipal() {\n                    return jwt.getSubject();\n                }\n            };\n        }\n        public static List<GrantedAuthority> extractRealmAccessRoles(Jwt jwt) {\n            Map<String, Object> realmAccess = jwt.getClaimAsMap(\"realm_access\");\n            if (realmAccess == null) {\n                return Collections.emptyList();\n            }\n            List<String> roles = (List<String>) realmAccess.get(\"roles\");\n            if (roles == null) {\n                return Collections.emptyList();\n            }\n            return roles.stream()\n                    .map(roleName -> new SimpleGrantedAuthority(\"ROLE_\" + roleName.toUpperCase()))\n                    .collect(Collectors.toList());\n        }\n    }\n    ```", "```java\n    implementation 'org.springframework.security:spring-security-config'\n    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'\n    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'\n    ```", "```java\n    spring.security.oauth2.client.registration.keycloak.client-id=bookstore-client\n    spring.security.oauth2.client.registration.keycloak.client-secret=<Your-Client-Secret>\n    spring.security.oauth2.client.registration.keycloak.client-name=Keycloak\n    spring.security.oauth2.client.registration.keycloak.provider=keycloak\n    spring.security.oauth2.client.registration.keycloak.scope=openid,profile,email\n    spring.security.oauth2.client.registration.keycloak.authorization-grant-type=authorization_code\n    spring.security.oauth2.client.registration.keycloak.redirect-uri={baseUrl}/login/oauth2/code/keycloak\n    spring.security.oauth2.client.provider.keycloak.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm\n    spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/auth/realms/BookStoreRealm\n    ```", "```java\n    @Configuration\n    public class SecurityConfig {\n        @Bean\n        public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n            http\n                .csrf(ServerHttpSecurity.CsrfSpec::disable)\n                .authorizeExchange(exchanges -> exchanges\n                    .pathMatchers(\"/login\").permitAll()\n                    .pathMatchers(HttpMethod.POST, \"/users\").hasAuthority(\"ROLE_ADMIN\")\n                    .pathMatchers(HttpMethod.GET, \"/users/**\").hasAnyAuthority(\"ROLE_ADMIN\", \"ROLE_USER\")\n                    .anyExchange().authenticated()\n                )\n                .oauth2ResourceServer(oauth2ResourceServer ->\n                    oauth2ResourceServer.jwt(jwt ->\n                        jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))\n                );\n            return http.build();\n        }\n        private Converter<Jwt, ? extends Mono<? extends AbstractAuthenticationToken>> jwtAuthenticationConverter() {\n            ReactiveJwtAuthenticationConverter jwtConverter = new ReactiveJwtAuthenticationConverter();\n            jwtConverter.setJwtGrantedAuthoritiesConverter(new KeycloakRoleConverter());\n            return jwtConverter;\n        }\n    }\n    ```", "```java\n    public class KeycloakRoleConverter implements Converter<Jwt, Flux<GrantedAuthority>> {\n        @Override\n        public Flux<GrantedAuthority> convert(final Jwt jwt) {\n            // Extracting roles from realm_access\n            return Flux.fromIterable(getRolesFromToken(jwt))\n                    .map(roleName -> \"ROLE_\" + roleName.toUpperCase()) // Prefixing role with ROLE_\n                    .map(SimpleGrantedAuthority::new);\n        }\n        private List<String> getRolesFromToken(Jwt jwt) {\n            Map<String, Object> realmAccess = jwt.getClaimAsMap(\"realm_access\");\n            if (realmAccess == null) {\n                return Collections.emptyList();\n            }\n            List<String> roles = (List<String>) realmAccess.get(\"roles\");\n            if (roles == null) {\n                return Collections.emptyList();\n            }\n            return roles;\n        }\n    }\n    ```", "```java\n    @RestController\n    public class LoginController {\n        @Value(\"${spring.security.oauth2.client.registration.keycloak.client-id}\")\n        private String clientId;\n        @Value(\"${spring.security.oauth2.client.registration.keycloak.client-secret}\")\n        private String clientSecret;\n        @Value(\"${spring.security.oauth2.resourceserver.jwt.issuer-uri}\")\n        private String baseUrl;\n        @PostMapping(\"/login\")\n        public Mono<ResponseEntity<?>> login(@RequestBody LoginRequestDto loginRequestDto) {\n            // URL for Keycloak token endpoint\n            String tokenUrl = baseUrl + \"/protocol/openid-connect/token\";\n            // Prepare the request body\n            MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>();\n            requestBody.add(\"client_id\", clientId);\n            requestBody.add(\"username\", loginRequestDto.username());\n            requestBody.add(\"password\", loginRequestDto.password());\n            requestBody.add(\"grant_type\", \"password\");\n            requestBody.add(\"client_secret\", clientSecret);\n            // Use RestTemplate to send the request\n            RestTemplate restTemplate = new RestTemplate();\n            ResponseEntity<String> response = restTemplate.postForEntity(tokenUrl, requestBody, String.class);\n            // Return the response from Keycloak\n            return Mono.just(ResponseEntity.ok(response.getBody()));\n        }\n    }\n    ```"]