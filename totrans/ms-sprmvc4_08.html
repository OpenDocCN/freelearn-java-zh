<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Optimizing Your Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Optimizing Your Requests</h1></div></div></div><p>In this chapter, we will be looking at different techniques to improve our application's performance.</p><p>We will implement classical ways of optimizing a web application: cache control headers, Gzipping, an application cache, and ETags, as well as more reactive stuff, such as asynchronous method calls and WebSockets.</p><div class="section" title="A production profile"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>A production profile</h1></div></div></div><p>In the previous chapter, we saw how to define an application properties file that will only be read while launching the application with a specific profile. We will use the same approach and create an <code class="literal">application-prod.properties</code> file in <code class="literal">src/main/resources</code>, right next to the existing <code class="literal">application.properties</code> file. This way, we will be able to configure<a id="id507" class="indexterm"/> the production environment with optimized settings.</p><p>We will put a few properties in this file to get started. In <a class="link" href="ch03.html" title="Chapter 3. Handling Forms and Complex URL Mapping">Chapter 3</a>, <span class="emphasis"><em>Handling Forms and Complex URL Mapping</em></span>, we deactivated the Thymeleaf cache and forced translation bundles to reload on every access.</p><p>This is great for developing but is useless and time consuming in production. So let's fix that:</p><div class="informalexample"><pre class="programlisting">spring.thymeleaf.cache=true
spring.messages.cache-seconds=-1</pre></div><p>A cache period of <code class="literal">-1</code> means caching the bundle forever.</p><p>Now, if we launch our application with the "prod" profile, templates and bundles should be cached forever.</p><p>The properties coming from the "prod" profile will indeed overwrite the ones declared in our <code class="literal">application.properties</code> file.</p></div></div>
<div class="section" title="Gzipping"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Gzipping</h1></div></div></div><p>
<span class="strong"><strong>Gzipping</strong></span> is a <a id="id508" class="indexterm"/>compression algorithm widely understood by browsers. Your server will serve compressed responses, which will consume a few more CPU cycles but will save bandwidth.</p><p>The client browser will then be charged for unzipping the resources and displaying them to the user.</p><p>To leverage Tomcat's Gzipping abilities, simply add the following line to the <code class="literal">application-prod.properties</code> file:</p><div class="informalexample"><pre class="programlisting">server.tomcat.compression=on
server.tomcat.compressableMimeTypes=text/html,text/xml,text/css,text/plain,\
  application/json,application/xml,application/javascript</pre></div><p>This will enable Tomcat's Gzipping compression when serving any file matching the MIME types specified in the list, and whose length is greater than 2048 bytes. You can set <code class="literal">server.tomcat.compression</code> to <code class="literal">force</code> to enforce compression or set it to a numerical value if you want to change the value for the minimal length of Gzipped assets.</p><p>If you want more control over the compression, say over the level of compression, or want to exclude user agents from compression, you can use the <code class="literal">GzipFilter</code> class in Jetty by adding the <code class="literal">org.eclipse.jetty:jetty-servlets</code> dependency to your project.</p><p>This will automatically trigger the <code class="literal">GzipFilterAutoConfiguration</code> class, which can be configured with a handful of properties prefixed by <code class="literal">spring.http.gzip</code>. Have a look at <code class="literal">GzipFilterProperties</code> to understand its level of customization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Refer to<a id="id509" class="indexterm"/> the documentation at <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression">http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression</a> for additional information.</p></div></div></div>
<div class="section" title="Cache control"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Cache control</h1></div></div></div><p>Cache control is a set of HTTP headers sent by the server to control how the user's browser is<a id="id510" class="indexterm"/> allowed to cache resources.</p><p>In the previous chapter, we have seen that Spring Security automatically disables caching for secured resources.</p><p>If we want to benefit from cache control, we must first disable that feature:</p><div class="informalexample"><pre class="programlisting">security.headers.cache=false

# Cache resources for 3 days
spring.resources.cache-period=259200</pre></div><p>Now, launch the application, go to the main page, and check the Chrome developer console. You will see that our JavaScript files are Gzipped and cached, as marked in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_08_01.jpg" alt="Cache control"/></div><p>If you want <a id="id511" class="indexterm"/>more control over your cache, you could add handlers for your own resources in your configuration:</p><div class="informalexample"><pre class="programlisting">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    // This is just an example
    registry.addResourceHandler("/img/**")
            .addResourceLocations("classpath:/static/images/")
            .setCachePeriod(12);
}</pre></div><p>We could also override the Spring Security default settings. If we want to deactivate the "no cache control" policy for our API, we can change the <code class="literal">ApiSecurityConfiguration</code> class like this:</p><div class="informalexample"><pre class="programlisting">@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .antMatcher("/api/**")
// This is just an example – not required in our case
        <span class="strong"><strong>.headers().cacheControl().disable()</strong></span>
        .httpBasic().and()
        .csrf().disable()
        .authorizeRequests()
        .antMatchers(HttpMethod.GET).hasRole("USER")
        .antMatchers(HttpMethod.POST).hasRole("ADMIN")
        .antMatchers(HttpMethod.PUT).hasRole("ADMIN")
        .antMatchers(HttpMethod.DELETE).hasRole("ADMIN")
        .anyRequest().authenticated();
}</pre></div></div>
<div class="section" title="Application cache"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Application cache</h1></div></div></div><p>Now that our web requests have been compressed and cached, the next step we can take to reduce server load is to put the results of costly operations in a cache. The Twitter search takes some time and will consume our application request ratio on the Twitter API. With Spring, we can easily cache the search and return the same result each time the search is called with the <a id="id512" class="indexterm"/>same parameters.</p><p>The first thing that we need to do is activate Spring caching with the <code class="literal">@EnableCache</code> annotation. We also need to create a <code class="literal">CacheManager</code> that will resolve our caches. Let's create a <code class="literal">CacheConfiguration</code> class in the <code class="literal">config</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCache;
import org.springframework.cache.support.SimpleCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Arrays;

@Configuration
@EnableCaching
public class CacheConfiguration {

    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager simpleCacheManager = new SimpleCacheManager();
        simpleCacheManager.setCaches(Arrays.asList(
                new ConcurrentMapCache("searches")
        ));
        return simpleCacheManager;
    }
}</pre></div><p>In the previous example, we use the simplest possible cache abstraction. Other implementations are also available, such as <code class="literal">EhCacheCacheManager</code> or <code class="literal">GuavaCacheManager</code>, which we will use in a moment.</p><p>Now that we have configured our cache, we can use the <code class="literal">@Cacheable</code> annotation on our methods. When we do that, Spring will automatically cache the result of the method and associate it with the current parameters for retrieval.</p><p>Spring needs to create a proxy around beans whose methods are cached. This typically means that calling<a id="id513" class="indexterm"/> a cached method inside of the same bean will not fail to use Spring's cache.</p><p>In our case, in the <code class="literal">SearchService</code> class, the part where we call the search operations, would benefit greatly from caching.</p><p>As a preliminary step, it would be good to put the code responsible for creating the <code class="literal">SearchParameters</code> class in a dedicated object called <code class="literal">SearchParamsBuilder</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.social.twitter.api.SearchParameters;

import java.util.List;
import java.util.stream.Collectors;

public class SearchParamsBuilder {

    public static SearchParameters createSearchParam(String searchType, String taste) {
        SearchParameters.ResultType resultType = getResultType(searchType);
        SearchParameters searchParameters = new SearchParameters(taste);
        searchParameters.resultType(resultType);
        searchParameters.count(3);
        return searchParameters;
    }

    private static SearchParameters.ResultType getResultType(String searchType) {
        for (SearchParameters.ResultType knownType : SearchParameters.ResultType.values()) {
            if (knownType.name().equalsIgnoreCase(searchType)) {
                return knownType;
            }
        }
        return SearchParameters.ResultType.RECENT;
    }
}</pre></div><p>This will help us to create search parameters in our service.</p><p>Now we want to create a cache for our search results. We want each call to the Twitter API to be cached. Spring cache annotations rely on proxies to instrument the <code class="literal">@Cacheable</code> methods. We therefore need a new class with a method annotated with the <code class="literal">@Cacheable</code> annotation.</p><p>When you use<a id="id514" class="indexterm"/> the Spring abstraction API, you don't know about the underlying implementation of the cache. Many will require both the return type and the parameter types of the cached method to be Serializable.</p><p>
<code class="literal">SearchParameters</code> is not Serializable, that's why we will pass both the search type and the keyword (both strings) in the cached method.</p><p>Since we want to put the <code class="literal">LightTweets</code> object in cache, we want to make them <code class="literal">Serializable</code>; this will ensure that they can always be written and read from any cache abstraction:</p><div class="informalexample"><pre class="programlisting">public class LightTweet <span class="strong"><strong>implements Serializable</strong></span> {
    // the rest of the code remains unchanged
}</pre></div><p>Let's create a <code class="literal">SearchCache</code> class and put it in the <code class="literal">search.cache</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search.cache;

import masterSpringMvc.search.LightTweet;
import masterSpringMvc.search.SearchParamsBuilder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.social.TwitterProperties;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.social.twitter.api.SearchParameters;
import org.springframework.social.twitter.api.Twitter;
import org.springframework.social.twitter.api.impl.TwitterTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SearchCache {
    protected final Log logger = LogFactory.getLog(getClass());
    private Twitter twitter;

    @Autowired
    public SearchCache(TwitterProperties twitterProperties) {
        this.twitter = <span class="strong"><strong>new TwitterTemplate</strong></span>(twitterProperties.getAppId(), twitterProperties.getAppSecret());
    }

    @Cacheable("searches")
    public List&lt;LightTweet&gt; fetch(String searchType, String keyword) {
        logger.info("Cache miss for " + keyword);
        SearchParameters searchParam = SearchParamsBuilder.createSearchParam(searchType, keyword);
        return twitter.searchOperations()
                .search(searchParam)
                .getTweets().stream()
                .map(LightTweet::ofTweet)
                .collect(Collectors.toList());
    }
}</pre></div><p>It can't really <a id="id515" class="indexterm"/>get simpler than that. We used the <code class="literal">@Cacheable</code> annotation to specify the name of the cache that will be used. Different caches may have different policies.</p><p>Note that we manually created a new <code class="literal">TwitterTemplate</code> method rather than injecting it like before. That's because we will have to access the cache from other threads a little bit later. In Spring Boot's <code class="literal">TwitterAutoConfiguration</code> class, the <code class="literal">Twitter</code> bean is bound to the request scope and is therefore not available outside of a Servlet thread.</p><p>With those two new objects, the code of our <code class="literal">SearchService</code> class simply becomes this:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import masterSpringMvc.search.cache.SearchCache;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Profile("!async")
public class SearchService implements TwitterSearch {
    private SearchCache searchCache;

    @Autowired
    public SearchService(SearchCache searchCache) {
        this.searchCache = searchCache;
    }

    @Override
    public List&lt;LightTweet&gt; search(String searchType, List&lt;String&gt; keywords) {
        return keywords.stream()
                .flatMap(keyword -&gt; searchCache.fetch(searchType, keyword).stream())
                .collect(Collectors.toList());
    }
}</pre></div><p>Note that we annotated the service with <code class="literal">@Profile("!async")</code>. This means that we only create this<a id="id516" class="indexterm"/> bean if the profile <code class="literal">async</code> is not activated.</p><p>Later, we will create another implementation of the <code class="literal">TwitterSearch</code> class to be able to switch between the two.</p><p>Neat! Say we restart our application and try a big request such as the following:</p><p>
<code class="literal">http://localhost:8080/search/mixed;keywords=docker,spring,spring%20boot,spring%20mvc,groovy,grails</code>
</p><p>It will take a little time at first, but then our console will display the following log:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2015-08-03 16:04:01.958  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for docker</strong></span>
<span class="strong"><strong>2015-08-03 16:04:02.437  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for spring</strong></span>
<span class="strong"><strong>2015-08-03 16:04:02.728  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for spring boot</strong></span>
<span class="strong"><strong>2015-08-03 16:04:03.098  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for spring mvc</strong></span>
<span class="strong"><strong>2015-08-03 16:04:03.383  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for groovy</strong></span>
<span class="strong"><strong>2015-08-03 16:04:03.967  INFO 38259 --- [nio-8080-exec-8] m.search.cache.SearchCache               : Cache miss for grails</strong></span>
</pre></div><p>After that, if we hit refresh, the result will be displayed immediately and no cache miss will be seen in the console.</p><p>That's it for our cache, but there is much more to the cache API. You can annotate methods with the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@CachEvict</code>: This will remove an entry from the cache</li><li class="listitem" style="list-style-type: disc"><code class="literal">@CachePut</code>: This will put the result of a method into a cache without interfering with the method itself</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Caching</code>: This regroups the caching annotation</li><li class="listitem" style="list-style-type: disc"><code class="literal">@CacheConfig</code>: This points to different caching configurations</li></ul></div><p>The <code class="literal">@Cacheable</code> annotation <a id="id517" class="indexterm"/>can also be configured to cache results on certain conditions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>For more<a id="id518" class="indexterm"/> information on Spring cache, please see the following documentation:</p><p>
<a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html</a>
</p></div></div><div class="section" title="Cache invalidation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Cache invalidation</h2></div></div></div><p>Currently, search results will be cached forever. Using the default simple cache manager doesn't give us a lot of options. There is one more thing that we can do to improve our application<a id="id519" class="indexterm"/> caching. Since we have Guava in our classpath, we can replace the existing cache manager in the cache configuration with the following code:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import com.google.common.cache.CacheBuilder;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.guava.GuavaCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfiguration {

    @Bean
    public CacheManager cacheManager() {
        GuavaCacheManager cacheManager = new GuavaCacheManager("searches");
        cacheManager
                .setCacheBuilder(
                        CacheBuilder.newBuilder()
                                .softValues()
                                .expireAfterWrite(10, TimeUnit.MINUTES)
                );
        return cacheManager;
    }
}</pre></div><p>This will build a <a id="id520" class="indexterm"/>cache expiring after 10 minutes and using soft values, meaning that the entries will be cleaned up if the JVM runs low on memory.</p><p>Try to fiddle around with Guava's cache builder. You can specify a smaller time unit for your testing, and even specify different cache policies.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>See the documentation at <a class="ulink" href="https://code.google.com/p/guava-libraries/wiki/CachesExplained">https://code.google.com/p/guava-libraries/wiki/CachesExplained</a>.</p></div></div></div><div class="section" title="Distributed cache"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Distributed cache</h2></div></div></div><p>We already<a id="id521" class="indexterm"/> have a Redis profile. If Redis is available, we could also use it as our cache provider. It would allow us to distribute the cache across <a id="id522" class="indexterm"/>multiple servers. Let's change the <code class="literal">RedisConfig</code> class:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Profile;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

import java.util.Arrays;

@Configuration
@Profile("redis")
@EnableRedisHttpSession
public class RedisConfig {

    @Bean(name = "objectRedisTemplate")
    public RedisTemplate objectRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }

    @Primary @Bean
    public CacheManager cacheManager(@Qualifier("objectRedisTemplate") RedisTemplate template) {
        RedisCacheManager cacheManager = new RedisCacheManager(template);
        cacheManager.setCacheNames(Arrays.asList("searches"));
        cacheManager.setDefaultExpiration(36_000);
        return cacheManager;
    }
}</pre></div><p>With this <a id="id523" class="indexterm"/>configuration, if we run our application <a id="id524" class="indexterm"/>with the "Redis" profile, the Redis cache manager will be used instead of the one defined in the <code class="literal">CacheConfig</code> class since it is annotated with <code class="literal">@Primary</code>.</p><p>This will allow the cache to be distributed in case we want to scale on more than one server. The Redis template is used to serialize the cache return values and parameters, and will require objects to be <code class="literal">Serializable</code>.</p></div></div>
<div class="section" title="Async methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Async methods</h1></div></div></div><p>There is still a bottleneck in our application; when a user searches ten keywords, each search will be executed sequentially. We could easily improve the speed of our application by <a id="id525" class="indexterm"/>using different threads and launching all the searches at the same time.</p><p>To enable Spring's asynchronous capabilities, one must use the <code class="literal">@EnableAsync</code> annotation. This will transparently execute any method annotated with <code class="literal">@Async</code> using a <code class="literal">java.util.concurrent.Executor</code>.</p><p>It is possible to customize the default executor used by implementing the <code class="literal">AsyncConfigurer</code> interface. Let's create a new configuration class called <code class="literal">AsyncConfig</code> in the <code class="literal">config</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

@Configuration
@EnableAsync
public class AsyncConfiguration implements AsyncConfigurer {

    protected final Log logger = LogFactory.getLog(getClass());

    @Override
    public Executor getAsyncExecutor() {
        return Executors.newFixedThreadPool(10);
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -&gt; logger.error("Uncaught async error", ex);
    }
}</pre></div><p>With this <a id="id526" class="indexterm"/>configuration, we ensure that no more than 10 threads will be allocated to handle our asynchronous tasks in the whole application. This is very important in a web application where each client has a dedicated thread. The more threads you use and the longer they block, the fewer client requests you can process.</p><p>Let's annotate our search method and make it asynchronous. We will need to make it return a subtype of <code class="literal">Future</code>, a java concurrent class that represents an asynchronous result.</p><p>We will create a new implementation of the <code class="literal">TwitterSearch</code> class that will query the search API in different threads. The implementation is a bit tricky so I'll break it down into small parts.</p><p>First, we need to annotate the method that will query the API with the <code class="literal">@Async</code> annotation to tell Spring to schedule the task using our executor. Again, Spring will use proxy to do its magic so this method has to be in a different class to the service calling it. It would also be nice if this component could use our cache. That would lead us to create this component:</p><div class="informalexample"><pre class="programlisting">@Component
private static class AsyncSearch {
    protected final Log logger = LogFactory.getLog(getClass());
    private SearchCache searchCache;

    @Autowired
    public AsyncSearch(SearchCache searchCache) {
        this.searchCache = searchCache;
    }

    @Async
    public ListenableFuture&lt;List&lt;LightTweet&gt;&gt; asyncFetch(String searchType, String keyword) {
        logger.info(Thread.currentThread().getName() + " - Searching for " + keyword);
        return new AsyncResult&lt;&gt;(searchCache.fetch(searchType, keyword));
    }
}</pre></div><p>Don't create<a id="id527" class="indexterm"/> this class yet. Let's see what our service needs first.</p><p>The <code class="literal">ListenableFuture</code> abstraction allows us to add callbacks after the completion of the future, either in the case of correct results or if an exception occurs.</p><p>The algorithm to wait for a bunch of asynchronous tasks would look like this:</p><div class="informalexample"><pre class="programlisting">@Override
public List&lt;LightTweet&gt; search(String searchType, List&lt;String&gt; keywords) {
    CountDownLatch latch = new CountDownLatch(keywords.size());
    List&lt;LightTweet&gt; allTweets = Collections.synchronizedList(new ArrayList&lt;&gt;());
    keywords
            .stream()
            .forEach(keyword -&gt; asyncFetch(latch, allTweets, searchType, keyword));

    await(latch);
    return allTweets;
}</pre></div><p>If you don't know the <code class="literal">CountDownLatch</code> method, it is just a simple blocking counter.</p><p>The <code class="literal">await()</code> method will wait until the latch reaches 0 to unlock the thread.</p><p>The <code class="literal">asyncFetch</code> method, shown in the preceding code, will attach a callback to each of our <code class="literal">asynFetch</code> methods. The callback will add the results to the <code class="literal">allTweets</code> list and decrement the latch. Once each callback has been called, the method will return all the tweets.</p><p>Got it? Here is<a id="id528" class="indexterm"/> the final code:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import masterSpringMvc.search.cache.SearchCache;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.AsyncResult;
import org.springframework.social.twitter.api.SearchParameters;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.util.concurrent.ListenableFuture;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;

@Service
@Profile("async")
public class ParallelSearchService implements TwitterSearch {
    private final AsyncSearch asyncSearch;

    @Autowired
    public ParallelSearchService(AsyncSearch asyncSearch) {
        this.asyncSearch = asyncSearch;
    }

    @Override
    public List&lt;LightTweet&gt; search(String searchType, List&lt;String&gt; keywords) {
        CountDownLatch latch = new CountDownLatch(keywords.size());
        List&lt;LightTweet&gt; allTweets = Collections.synchronizedList(new ArrayList&lt;&gt;());

        keywords
                .stream()
                .forEach(keyword -&gt; asyncFetch(latch, allTweets, searchType, keyword));

        await(latch);
        return allTweets;
    }

    private void asyncFetch(CountDownLatch latch, List&lt;LightTweet&gt; allTweets, String searchType, String keyword) {
        asyncSearch.asyncFetch(searchType, keyword)
                .addCallback(
                        tweets -&gt; onSuccess(allTweets, latch, tweets),
                        ex -&gt; onError(latch, ex));
    }

    private void await(CountDownLatch latch) {
        try {
            latch.await();
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }

    private static void onSuccess(List&lt;LightTweet&gt; results, CountDownLatch latch, List&lt;LightTweet&gt; tweets) {
        results.addAll(tweets);
        latch.countDown();
    }

    private static void onError(CountDownLatch latch, Throwable ex) {
        ex.printStackTrace();
        latch.countDown();
    }

    @Component
    private static class AsyncSearch {
        protected final Log logger = LogFactory.getLog(getClass());
        private SearchCache searchCache;

        @Autowired
        public AsyncSearch(SearchCache searchCache) {
            this.searchCache = searchCache;
        }

        @Async
        public ListenableFuture&lt;List&lt;LightTweet&gt;&gt; asyncFetch(String searchType, String keyword) {
            logger.info(Thread.currentThread().getName() + " - Searching for " + keyword);
            return new AsyncResult&lt;&gt;(searchCache.fetch(searchType, keyword));
        }
    }
}</pre></div><p>Now, to use<a id="id529" class="indexterm"/> this implementation, we need to run the application with the <code class="literal">async</code> profile.</p><p>We can run it with multiple profiles active at the same time by separating them with commas, as follows:</p><p>
<code class="literal">--spring.profiles.active=redis,async</code>
</p><p>If we launch a search on multiple terms, we can see something like this:</p><div class="informalexample"><pre class="programlisting">pool-1-thread-3 - Searching groovy
pool-1-thread-1 - Searching spring
pool-1-thread-2 - Searching java</pre></div><p>This shows that the different searches are done in parallel.</p><p>Java 8 actually introduced a new type called <code class="literal">CompletableFuture</code>, which is a much better API to manipulate futures. The main problem with completable futures is that no executor can work with them without a bit of code. This is outside of the scope of the article, but you<a id="id530" class="indexterm"/> can check my blog for an article on the subject: <a class="ulink" href="http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html">http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>
<span class="strong"><strong>Disclaimer</strong></span>
</p><p>The following sections contains a lot of JavaScript. Obviously, I think you should have a look at the code, especially if JavaScript is not your favorite language. It is time to learn it. That being said, even if WebSocket is insanely cool, it is not a requirement. You can safely skip ahead to the last chapter and deploy your application right now.</p></div></div></div>
<div class="section" title="ETags"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>ETags</h1></div></div></div><p>Our Twitter results are neatly cached, so a user refreshing the result page will not trigger an additional <a id="id531" class="indexterm"/>search on the Twitter API. However, the response will be sent to this user multiple times even if the results do not change, which will waste bandwidth.</p><p>An ETag is a hash of the data of a web response and is sent as a header. The client can memorize the ETag of a resource and send the last known version to the server with the <code class="literal">If-None-Match</code> header. This allows the server to answer <code class="literal">304 Not Modified</code> if the request does not change in the meantime.</p><p>Spring has a special Servlet filter, called <code class="literal">ShallowEtagHeaderFilter</code>, to handle ETags. Simply add it as a bean in the <code class="literal">MasterSpringMvc4Application</code> configuration class:</p><div class="informalexample"><pre class="programlisting">@Bean
public Filter etagFilter() {
    return new ShallowEtagHeaderFilter();
}</pre></div><p>This will <a id="id532" class="indexterm"/>automatically generate ETags for your responses as long as the response has no cache control headers.</p><p>Now if we interrogate our RESTful API, we can see that an ETag is sent along with the server response:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; http GET 'http://localhost:8080/api/search/mixed;keywords=spring' -a admin:admin</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 1276</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Mon, 01 Jun 2015 11:29:51 GMT</strong></span>
<span class="strong"><strong>ETag: "00a66d6dd835b6c7c60638eab976c4dd7"</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Set-Cookie: JSESSIONID=662848E4F927EE9A1BA2006686ECFE4C; Path=/; HttpOnly</strong></span>
</pre></div><p>Now if we request the same resource one more time, specifying the last ETag that we know of in the <code class="literal">If-None-Match</code> headers, the server will automatically respond with a <code class="literal">304 Not Modified</code> status:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; http GET 'http://localhost:8080/api/search/mixed;keywords=spring' If-None-Match:'"00a66d6dd835b6c7c60638eab976c4dd7"' -a admin:admin</strong></span>
<span class="strong"><strong>HTTP/1.1 304 Not Modified</strong></span>
<span class="strong"><strong>Date: Mon, 01 Jun 2015 11:34:21 GMT</strong></span>
<span class="strong"><strong>ETag: "00a66d6dd835b6c7c60638eab976c4dd7"</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Set-Cookie: JSESSIONID=CA956010CF268056C241B0674C6C5AB2; Path=/; HttpOnly</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Due to the parallel nature of our search, the tweets fetched for different keywords might arrive in different orders, which will make the ETag change. If you want this technique to work for multiple searches, please consider ordering your search results before sending them to the client.</p></div></div><p>If we want to<a id="id533" class="indexterm"/> take advantage of that, we obviously need to rewrite our client code to handle them. We will see a simple solution to do that with jQuery, using the local storage of the browser to save the latest query of the user.</p><p>First, remove the <code class="literal">tweets</code> variable from our model; we won't do the search from the server anymore. You will have to modify a test or two to reflect this change.</p><p>Before going further, let's add lodash to our JavaScript libraries. If you don't know lodash, let's say it is the Apache Utils of JavaScript. You can add it to your project dependencies like so:</p><div class="informalexample"><pre class="programlisting">compile 'org.webjars.bower:lodash:3.9.3'</pre></div><p>Add it to the <code class="literal">default.html</code> layout, just under the materialize's JavaScript:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/webjars/lodash/3.9.3/lodash.js"&gt;&lt;/script&gt;</pre></div><p>We will modify the <code class="literal">resultPage.html</code> file and leave the part where the tweets should appear empty:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head lang="en"&gt;
    &lt;title&gt;Hello twitter&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="row" layout:fragment="content"&gt;

    &lt;h2 class="indigo-text center" th:text="|Tweet results for ${search}|"&gt;Tweets&lt;/h2&gt;

    <span class="strong"><strong>&lt;ul id="tweets" class="collection"&gt;</strong></span>
<span class="strong"><strong>    &lt;/ul&gt;</strong></span>
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Then, we will add a script element at the bottom of the page, just before closing the body:</p><div class="informalexample"><pre class="programlisting">&lt;script layout:fragment="script" th:inline="javascript"&gt;
    /*&lt;![CDATA[*/
    var baseUrl = /*[[@{/api/search}]]*/ "/";
    var currentLocation = window.location.href;
    var search = currentLocation.substr(currentLocation.lastIndexOf('/'));
    var url = baseUrl + search;
    /*]]&gt;*/
&lt;/script&gt;</pre></div><p>The preceding script will just be in charge of constructing the URL for our request. We will use it by<a id="id534" class="indexterm"/> issuing a simple jQuery AJAX call:</p><div class="informalexample"><pre class="programlisting">$.ajax({
    url: url,
    type: "GET",
    beforeSend: setEtag,
    success: onResponse
});</pre></div><p>We will use the <code class="literal">beforeSend</code> callback to have a chance to modify the request headers just before the call is made:</p><div class="informalexample"><pre class="programlisting">function getLastQuery() {
    return JSON.parse(localStorage.getItem('lastQuery')) || {};
}

function storeQuery(query) {
    localStorage.setItem('lastQuery', JSON.stringify(query));
}

function setEtag(xhr) {
    xhr.setRequestHeader('If-None-Match', getLastQuery().etag)
}</pre></div><p>As you can see, we can easily read and write from local storage. The gotcha here is that local storage only works with strings so we have to parse and serialize the query object to JSON.</p><p>We can handle the response by retrieving the content from local storage if the HTTP status is <code class="literal">304 Not Modified</code>:</p><div class="informalexample"><pre class="programlisting">function onResponse(tweets, status, xhr) {
  if (xhr.status == 304) {
      console.log('Response has not changed');
      tweets = getLastQuery().tweets
  }

  var etag = xhr.getResponseHeader('Etag');
  storeQuery({tweets: tweets, etag: etag});

  displayTweets(tweets);
}

function displayTweets(tweets) {
  $('#tweets').empty();
  $.each(tweets, function (index, tweet) {
      addTweet(tweet);
  })
}</pre></div><p>For the <code class="literal">addTweet</code> function that you will see next, I'm using lodash, a very useful JavaScript utility library, to generate templates. The function to add tweets to the page can be written<a id="id535" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">function addTweet(tweet) {
    var template = _.template('&lt;li class="collection-item avatar"&gt;' +
        '&lt;img class="circle" src="${tweet.profileImageUrl}" /&gt;' +
        '&lt;span class="title"&gt;${tweet.user}&lt;/span&gt;' +
        '&lt;p&gt;${tweet.text}&lt;/p&gt;' +
        '&lt;/li&gt;');

    $('#tweets').append(template({tweet: tweet}));
}</pre></div><p>That was a lot of JavaScript! It would make more sense to generalize this pattern in a Single Page Application using a library such as Backbone.js. Hopefully, though, this will serve as a simple example of how to implement ETags in your application.</p><p>If you try to refresh the search page multiple times, you will see that the contents do not change and will be displayed immediately:</p><div class="mediaobject"><img src="graphics/2117_08_02.jpg" alt="ETags"/></div><p>There are other uses for ETags, such as optimistic locking for transactions (it lets you know on which version of an object the client is supposed to be working on at any time). It is also extra work on the <a id="id536" class="indexterm"/>server side to hash the data before sending it across, but it will save bandwidth.</p></div>
<div class="section" title="WebSockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>WebSockets</h1></div></div></div><p>Another kind of optimization we can think about is sending the data to the client as it becomes available to the server. Since we fetch results of the search in multiple threads, the data will <a id="id537" class="indexterm"/>come in multiple chunks. We could send them bit by bit instead of waiting for all the results.</p><p>Spring has excellent support for WebSockets, which is a protocol that allows clients to maintain a long-running connection to the server. Data can be pushed in web sockets on both ends of the connection and consumers will get the data in real-time.</p><p>We will use a<a id="id538" class="indexterm"/> JavaScript library called SockJS to ensure compatibility with all browsers. Sockjs will transparently fall back on another strategy if our users have<a id="id539" class="indexterm"/> an outdated browser.</p><p>We will also use StompJS to connect to our message broker.</p><p>Add the following library to your build:</p><div class="informalexample"><pre class="programlisting">compile 'org.springframework.boot:spring-boot-starter-websocket'
compile 'org.springframework:spring-messaging'

compile 'org.webjars:sockjs-client:1.0.0'
compile 'org.webjars:stomp-websocket:2.3.3'</pre></div><p>Add the WebJars to our default Thymeleaf template:</p><div class="informalexample"><pre class="programlisting">&lt;script src="/webjars/sockjs-client/1.0.0/sockjs.js"&gt;&lt;/script&gt;
&lt;script src="/webjars/stomp-websocket/2.3.3/stomp.js"&gt;&lt;/script&gt;</pre></div><p>To configure WebSockets in our application, we need to add a bit of configuration as well:</p><div class="informalexample"><pre class="programlisting">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfiguration extends AbstractWebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic");
        config.setApplicationDestinationPrefixes("/ws");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/twitterSearch").withSockJS();
    }

}</pre></div><p>This will configure<a id="id540" class="indexterm"/> the different channels available in our application. SockJS clients will connect to the <code class="literal">twitterSearch</code> endpoint and will push data to the server on <code class="literal">/ws/ channel</code> and be able to listen to <code class="literal">/topic/</code> for changes.</p><p>This will allow us to inject a <code class="literal">SimpMessagingTemplate</code> in a new controller to push data to the client in the <code class="literal">/topic/searchResult</code> channel, as follows:</p><div class="informalexample"><pre class="programlisting">@Controller
public class SearchSocketController {
    private CachedSearchService searchService;
    private SimpMessagingTemplate webSocket;

    @Autowired
    public SearchSocketController(CachedSearchService searchService, SimpMessagingTemplate webSocket) {
        this.searchService = searchService;
        this.webSocket = webSocket;
    }

    @MessageMapping("/search")
    public void search(@RequestParam List&lt;String&gt; keywords) throws Exception {
        Consumer&lt;List&lt;LightTweet&gt;&gt; callback = tweet -&gt; webSocket.convertAndSend("/topic/searchResults", tweet);
        twitterSearch(SearchParameters.ResultType.POPULAR, keywords, callback);
    }

    public void twitterSearch(SearchParameters.ResultType resultType, List&lt;String&gt; keywords, Consumer&lt;List&lt;LightTweet&gt;&gt; callback) {
        keywords.stream()
            .forEach(keyword -&gt; {
                searchService.search(resultType, keyword)
                    .addCallback(callback::accept, Throwable::printStackTrace);
            });
    }
}</pre></div><p>In our <code class="literal">resultPage</code>, the JavaScript code is really simple:</p><div class="informalexample"><pre class="programlisting">var currentLocation = window.location.href;
var search = currentLocation.substr(currentLocation.lastIndexOf('=') + 1);

function connect() {
  var socket = new SockJS('/hello');
  stompClient = Stomp.over(socket);
  // stompClient.debug = null;
  stompClient.connect({}, function (frame) {
      console.log('Connected: ' + frame);

      stompClient.subscribe('/topic/searchResults', function (result) {
          displayTweets(JSON.parse(result.body));
      });

      stompClient.send("/app/search", {}, JSON.stringify(search.split(',')));
  });
}</pre></div><p>The <code class="literal">displayTweets</code> function<a id="id541" class="indexterm"/> remains essentially the same as before:</p><div class="informalexample"><pre class="programlisting">function displayTweets(tweets) {
    $.each(tweets, function (index, tweet) {
        addTweet(tweet);
    })
}

function addTweet(tweet) {
    var template = _.template('&lt;li class="collection-item avatar"&gt;' +
        '&lt;img class="circle" src="${tweet.profileImageUrl}" /&gt;' +
        '&lt;span class="title"&gt;${tweet.userName}&lt;/span&gt;' +
        '&lt;p&gt;${tweet.text}&lt;/p&gt;' +
        '&lt;/li&gt;');

    $('#tweets').append(template({tweet: tweet}));
}</pre></div><p>Here you go! The client will now receive the results of all the searches in the application-- live!</p><p>Before pushing this to production, it will require a little bit more work. Here are some ideas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create subchannels for clients to privately listen to changes</li><li class="listitem" style="list-style-type: disc">Close the channel when a client is done using it</li><li class="listitem" style="list-style-type: disc">Add CSS transitions<a id="id542" class="indexterm"/> to the new tweets so the user can feel that it's real-time</li><li class="listitem" style="list-style-type: disc">Use a real broker, such as RabbitMQ, to allow the backend to scale with connections</li></ul></div><p>There is much more to WebSocket than just this simple example. Don't forget to have a look at the <a id="id543" class="indexterm"/>documentation at <a class="ulink" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html</a> for more information.</p></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>The check point</h1></div></div></div><p>In this chapter, we created two new configurations: <code class="literal">AsyncConfiguration</code>, which will allow us to use the <code class="literal">@Async</code> annotation to submit tasks to an executor, and <code class="literal">CacheConfiguration</code>, which will create a <code class="literal">CacheManager</code> interface and allow us to use the <code class="literal">@Cacheable</code> annotation. Since we can use Redis as a cache manager, we also amended the <code class="literal">RedisConfig</code> class.</p><p>We created a <code class="literal">SearchCache</code> class, which contained a cache of tweets, and we now have two <code class="literal">TwitterSearch</code> implementations to choose from: good old <code class="literal">SearchService</code>, which will fetch each result synchronously, and <code class="literal">ParallelSearchService</code>, which will issue each query in a different thread:</p><div class="mediaobject"><img src="graphics/2117_08_03.jpg" alt="The check point"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Summary</h1></div></div></div><p>In this chapter, we have seen two different philosophies relating to performance improvement. At the beginning, we tried to reduce the bandwidth used by our clients by caching data and using as few connections to our server as possible.</p><p>In the second part, though, we began to do something more advanced by allowing searches to be run in parallel and each client to remain in sync with a persistent connection to the server through web sockets. This will allow clients to receive updates in real time, and our application will feel more reactive but consume more threads.</p><p>I strongly encourage you to polish the result before we move on to the next chapter and deploy our application for good!</p></div></body></html>