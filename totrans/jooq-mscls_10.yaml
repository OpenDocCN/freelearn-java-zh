- en: '*Chapter 8*: Fetching and Mapping'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetching result sets and mapping them in the shape and format expected by the
    client is one of the most important tasks of querying a database. jOOQ excels
    in this area and provides a comprehensive API for fetching data and mapping it
    to scalars, arrays, lists, sets, maps, POJO, Java 16 records, JSON, XML, nested
    collections, and more. As usual, the jOOQ API hides the friction and challenges
    raised by different database dialects along with the boilerplate code necessary
    to map the result set to different data structures. In this context, our agenda
    covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple fetching/mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching one record, a single record, or any record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching arrays, lists, sets, and maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching via JDBC `ResultSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching multiple result sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking POJOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ record mapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mighty SQL/JSON and SQL/XML support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested collections via the astonishing `MULTISET`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy fetching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous fetching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive fetching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Simple fetching/mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By *simple* fetching/mapping, we refer to the jOOQ fetching techniques that
    you learned earlier in this book (for instance, the ubiquitous `into()` methods)
    but also to the new jOOQ utility, `org.jooq.Records`. This utility is available
    from jOOQ 3.15 onward, and it contains two types of utility methods, as we will
    discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Collector methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The collector methods are named `intoFoo()`, and their goal is to create a
    collector (`java.util.stream.Collector`) for collecting records (`org.jooq.Record[N]`)
    into arrays, lists, maps, groups, and more. These collectors can be used in `ResultQuery.collect()`
    as any other collector. `ResultQuery<R>` implements `Iterable<R>` and comes with
    convenience methods such as `collect()` on top of it. Besides the fact that `collect()`
    handles resources internally (there is no need to use try-with-resources), you
    can use it for any collectors such as standard JDK collectors, jOOλ collectors,
    `Records` collectors, or your own collectors. For instance, here is an example
    of collecting into `List<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is an example of collecting into `Map<Long, String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that, while the ubiquitous `into()` methods use reflection, these utilities
    are a pure declarative mapping of jOOQ results/records without using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mapping methods are actually multiple flavors of the mapping (`Function[N]`)
    method. A mapping method creates a `RecordMapper` parameter that can map from
    `Record[N]` to another type (for instance, POJO and Java 16 records) in a type-safe
    way. For instance, you can map to a Java record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When mapping nested rows (for instance, `LEFT JOIN`) you can achieve `null`
    safety by combining `mapping()` with `Functions.nullOnAllNull(Function1)` or `Functions.nullOnAnyNull(Function1)`.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, how does this work? For instance, when an employee has no sale (or you have
    an orphan sale), you'll obtain a `null` value instead of an instance of `SalarySale`
    having the sale as `null`, `SalarySale[salary=120000, sale=null]`.
  prefs: []
  type: TYPE_NORMAL
- en: Many more examples are available for MySQL/PostgreSQL in the bundle code, *Records*.
  prefs: []
  type: TYPE_NORMAL
- en: Simple fetching/mapping continues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s see other techniques of fetching/mapping data that can be used
    quite intuitively and effortlessly. Since the jOOQ manual is filled to the brim
    with examples, let''s try to niche several things in this section. For instance,
    a simple fetch can be done via `DSLContext.resultQuery()` and plain SQL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach might rely on `DSLContext.fetch()` and plain SQL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So, the idea is quite simple. Whenever you have to execute a plain SQL that
    you can't (or don't want to) express via a jOOQ-generated Java-based schema, then
    simply rely on `ResultQuery.collect(collector)` or the `resultQuery() … fetch()`/`fetchInto()`
    combination. Alternatively, simply pass it to the `fetch()` method and call the
    proper `into()` method or the `intoFoo()` method to map the result set to the
    necessary data structure. There are plenty of such methods that can map a result
    set to scalars, arrays, lists, sets, maps, POJO, XML, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, using the Java-based schema (which is, of course, the recommended
    way to go) leads to the following less popular but handy query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is a shortcut for fetching a single field and obtaining the mapped result
    (values) without explicitly calling an `into()` method or an `intoFoo()` method.
    Essentially, jOOQ automatically maps the fetched field to the Java type associated
    with it when the Java-based schema was generated by the jOOQ generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you need to fetch a single value, you can rely on `fetchValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `<T> T fetchValue(Field<T> field)` and `<T> List<T> fetchValues(TableField<?,T>
    tf)` methods are just two of the many flavors of methods that are available. Check
    out the jOOQ documentation to see the rest of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since you have made it this far in this book, I''m sure that you think
    of this query as a shortcut for the following four, more popular, approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And you are right, as long as you don''t also think of the following, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'All six of these queries project the same result, but they are not the same.
    As a jOOQ novice, it is understandable that you might a bad choice and go for
    the last two queries. Therefore, let''s clarify this concern by looking at the
    generated SQLs. The first four queries produce the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the last two queries produce the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is obvious that the last two queries perform unnecessary work. We only
    need the `CUSTOMER_NAME` field, but these queries will fetch all fields, and this
    is pointless work that negatively impacts performance. In such cases, don't blame
    jOOQ or the database because both of them did exactly what you asked!
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, when you don't need to fetch all fields, rely on the first
    four approaches from earlier and enlist the necessary fields in the `SELECT` statement.
    In this context, allow me to reiterate the *SelectOnlyNeededData* application
    from [*Chapter 5*](B16833_05.xhtml#_idTextAnchor076), *Tackling Different Kinds
    of SELECT, INSERT, UPDATE, DELETE, and MERGE Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you fetch more than one field, but not all fields, you should write something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider another simple fetching method based on the following
    two POJOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Populating these POJOs can be done via two `SELECT` statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'However, here, jOOQ allows us to map `Result<Record>` into multiple results.
    In other words, we can obtain the same result and trigger a single `SELECT` statement,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Nice! Of course, this doesn't only apply when mapping result sets to POJOs.
    In the code bundle of this book, *SimpleFetch* (which is available for MySQL),
    you can see a result set produced by a single `SELECT` statement formatted entirely
    as JSON, while a part of it is mapped to a Java `Set`. Next, let's dive into the
    `fetchOne()`, `fetchSingle()`, and `fetchAny()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching one record, a single record, or any record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ has come with three handy methods named `fetchOne()`, `fetchSingle()`,
    and `fetchAny()`. All three are capable of returning a resulting record, but each
    of them will do this under certain coordinates. So, let's go through each method
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using fetchOne()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For instance, the `fetchOne()` method returns, at most, one resulting record.
    In other words, if the fetched result set has more than one record, then `fetchOne()`
    throws a jOOQ-specific `TooManyRowsException` exception. But if the result set
    has no records, then `fetchOne()` returns `null`. In this context, `fetchOne()`
    can be useful for fetching a record by a primary key, other unique keys, or a
    predicate that guarantees uniqueness, while you prepare to handle potentially
    `null` results. Here is an example of using `fetchOne()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can fetch directly into the `Employee` POJO via `fetchOneInto()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'However, pay attention. Remember that `fetchOneInto(Employee.class)` is not
    the same thing as `fetchOne().into(Employee.class)` since the latter is prone
    to throw `NullPointerException` exceptions. So, it is better to avoid writing
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If there is no `EMPLOYEE` POJO with a primary key of *1370*, then this code
    throws an NPE exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, avoid chaining the `component`[`N`]`()` and `value`[`N`]`()` methods,
    as follows (this code is also prone to throw `NullPointerException`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, prefer fetching into a proper type (here, it is `String`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, an NPE check is still needed before using `result`, but you can
    wrap this check via `Objects.requireNonNullElseGet()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, simply wrap it into an `Optional` type via the jOOQ''s `fetchOptional()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may prefer `fetchOptionalInto()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, `fetchOne()` comes in many flavors, all of which are available in
    the documentation. For instance, you can use `DSLContext.fetchOne()`as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can fetch a record and convert it based on a user-defined converter
    (this converter was introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Many other examples are available in the bundled code for MySQL, *FetchOneAnySingle*.
  prefs: []
  type: TYPE_NORMAL
- en: Using fetchSingle()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fetchSingle()` method returns exactly one resulting record. In other words,
    if the fetched result set contains more than one record, then `fetchSingle()`
    throws the jOOQ-specific `TooManyRowsException` error. And if it doesn't contain
    any records, then it throws the jOOQ-specific `NoDataFoundException` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, `fetchSingle()` is similar to `fetchOne()`, except that it throws
    an exception instead of returning `null` when the fetched result set doesn''t
    contain any records. This means that `fetchSingle()` is useful for fetching a
    record by a primary key, other unique keys, or a predicate that guarantees uniqueness
    when you are not expecting `null` results. For example, see the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you might only fetch the email of this employee, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Many other examples are available in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Using fetchAny()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fetchAny()` method returns the first resulting record. In other words,
    if the fetched result set contains more than one record, then `fetchAny()` returns
    the first one. And, if it doesn''t contain any records, then it returns `null`.
    This is similar to `…limit(1).fetchOne();`. So, pay attention to avoid any usages
    that are prone to throw a `NullPointerException` exception. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Many other examples are available for MySQL in *FetchOneAnySingle*.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching arrays, lists, sets, and maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ reduces the code that is needed for fetching `Result<Record>` as an array,
    list, set, or map down to a simple call of its amazing API.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetching arrays can be done via a comprehensive set of jOOQ methods, including
    `fetchArray()` (along with its flavors), `fetchOneArray()`, `fetchSingleArray()`,
    `fetchAnyArray()`, `fetchArrays()`, and `intoArray()`. For instance, fetching
    all the `DEPARTMENT` fields as an array of `Record` can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison, you can just fetch `DEPARTMENT.NAME` as a `String[]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, fetching all `CUSTOMER.FIRST_BUY_DATE` fields as an array of
    the `YearMonth` type can be done via `fetchArray(Field<T> field, Converter<? super
    T,? extends U> cnvrtr)`, as follows (note that the `INTEGER_YEARMONTH_CONVERTER`
    converter was introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110), *Types,
    Converters, and Bindings*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think about fetching a database array into a Java array, such as
    the `DEPARTMENT.TOPIC` field that was defined in our PostgreSQL schema? Well,
    the result, in this case, is `String[][]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'If we return this `String[][]` from a Spring Boot REST controller, the result
    will be a JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'What about fetching a UDT type into a Java array? In our PostgreSQL schema,
    we have the `MANAGER.MANAGER_EVALUATION` UDT type, so let''s give it a try and
    fetch it as an array next to the `MANAGER_NAME` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print out the first manager name and their evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output (the `format()` method formats `EvaluationCriteriaRecord`
    as a tabular text):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1– Printing the first manager and their evaluation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1– Printing the first manager and their evaluation
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s try fetching an embeddable type as an array, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example from this section relies on `fetchArrays()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'If we return this `Object[][]` from a Spring Boot REST controller, then the
    result will be a JSON array of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can find over 15 examples of fetching jOOQ results
    as arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching lists and sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, most examples fetch the result set in `java.util.List` or `org.jooq.Result`
    (that is, the jOOQ wrappers of `List`), so there is no mystery regarding how the
    following examples work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s focus on more interesting cases, such as how to fetch the `DEPARTMENT.TOPIC`
    array field defined in our PostgreSQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Instead of calling `fetch()`, which will return `Result<Record1<String[]>>`,
    we prefer to call `fetch(Field<?> field, Class<? extends U> type)`. This allow
    us to return a `List<String[]>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to fetch `DEPARTMENT.TOPIC` as a `Set<String[]>` can be done via the
    jOOQ `fetchSet()` method (check out the documentation to see all the flavors of
    this method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Consider the bundled code, which contains more examples of fetching lists and
    sets, including fetching UDT and embeddable types.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jOOQ comes with a set of `fetchMap()`/`intoMap()` methods that allow us to split
    a result set into key-value pairs of a `java.util.Map` wrapper. There are more
    than 20 such methods, but we can primarily distinguish between the `fetchMap(key)`/`intoMap(Function
    keyMapper)` methods. These methods allow us to specify the field(s) representing
    the key, while the value is inferred from the `SELECT` result, and the `fetchMap(key,
    value)`/`intoMap(Function keyMapper, Function valueMapper)` methods in which we
    specify the field(s) that represents the key and the value, respectively. The
    `Records.intoMap()` method without any arguments is only useful if you have a
    two-column `ResultQuery` and you want to map the first column as a key and the
    second column as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s fetch a `Map` that has `DEPARTMENT_ID` as the key (so,
    the `DEPARTMENT` primary key) and `DepartmentRecord` as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, let''s instruct jOOQ that the map value should be a `Department`
    POJO (generated by jOOQ) instead of `DepartmentRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you think this is impressive? How about mapping a one-to-one relationship
    between the `CUSTOMER` and `CUSTOMERDETAIL` tables? Here is the magical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: In order to obtain a correct mapping, you have to provide explicit `equals()`
    and `hashCode()` methods for the involved POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply returning this `Map` from a REST controller will result in the following
    JSON code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Alterantively, you might want to fetch this one-to-one relationship by only
    using a subset of fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, *ArrListMap* (which is available for PostgreSQL), you can
    see more examples, including mapping a flattened one-to-many relationship, mapping
    arrays, UDTs and embeddable types, and using `fetchMaps()`, `fetchSingleMap()`,
    `fetchOneMap()`, and `fetchAnyMap()`. Next, let's talk about fetching groups.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jOOQ fetching groups feature is similar to fetching maps, except that it
    allows us to fetch a list of records as the value of each key-value pair. There
    are over 40 flavors of the `fetchGroups()`, `intoGroups()`, and `intoResultGroup()`
    methods; therefore, take your time to practice (or, at the very least, read about)
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: We can distinguish between the `fetchGroups(key)` and `intoGroups(Function keyMapper)`
    methods that allow us to specify the field(s) representing the key, while the
    value is inferred from the `SELECT` result as the `Result<Record>`/`List<Record>`
    and `fetchGroups(key, value)`/`intoGroups(Function keyMapper, Function valueMapper)`
    methods in which we specify the field(s) that represents the key and the value,
    respectively, which could be `Result<Record>`, `List<POJO>`, `List<scalar>`, and
    more. The `Records.intoGroups()` method without any arguments is only useful if
    you have a two-column `ResultQuery`, and you want to map the first column as a
    key and the second column as a value. Additionally, the `intoResultGroup()` method
    returns a collector that collects a jOOQ `Record`, which results from a `ResultQuery`
    in a `Map` using the result of the `RecordMapper` parameter as a key to collect
    the records themselves into a jOOQ `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can fetch all the `OrderRecord` values and group them by
    customer (`CUSTOMER_NUMBER`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can group all bank transfers (`BANK_TRANSACTION.TRANSFER_AMOUNT`) by
    customer (`BANK_TRANSACTION.CUSTOMER_NUMBER`) into `Map<Long, List<BigDecimal>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'You can group them into `Map<Long, List<Record2<Long, BigDecimal>>>` or `Map<Long,
    Result<Record2<Long, BigDecimal>>>`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''ve probably intuited already, `fetchGroups()` is very handy for fetching
    and mapping one-to-many relationships. For instance, each product line (`PRODUCTLINE`)
    has multiple products (`PRODUCT`), and we can fetch this data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning this map from a REST controller results in the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, relying on user-defined POJOs/Java records is also possible. For
    instance, let''s say you just need the code and name of each product line, along
    with the product ID and buy price of each product. Having the proper POJOs named
    `SimpleProductline` and `SimpleProduct`, we can map the following one-to-many
    relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to obtain a correct mapping, you have to provide explicit `equals()`
    and `hashCode()` methods for the involved POJOs. For the jOOQ-generated POJO,
    this is a configuration step that can be accomplished via `<pojosEqualsAndHashCode/>`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that using `fetchGroups()` works as expected for `INNER JOIN`, but not
    for `LEFT JOIN`. If the fetched parent doesn''t have children, then instead of
    an empty list, you''ll get a list containing a single `NULL` item. So, if you
    want to use `LEFT JOIN` (at least until [https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888)
    is resolved), you can rely on the mighty `ResultQuery.collect()`collector, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: This time, a parent with no children produces an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching and mapping a many-to-many relationship is also possible. We can do
    it elegantly via `CROSS APPLY` (for additional details, check out [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093),
    *Tackling Different Kinds of JOIN Statements*). For instance, we have a many-to-many
    relationship between `OFFICE` and `MANAGER` via the `OFFICE_HAS_MANAGER` junction
    table, and we can map it via `fetchGroups()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Passing this map through a REST controller produces the necessary JSON. Of course,
    mapping a one-to-many relationship with a junction table is quite obvious based
    on the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, please consider Lukas Eder''s note:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"When talking about* *fetchGroups(), I think it''s always worth pointing out
    that RDBMS can often do this natively as well, using ARRAY_AGG(), JSON_ARRAYAGG(),
    or XMLAGG(). Chances are (to be verified), that this may be faster, as less data
    has to be transferred over the wire."*'
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can practice many more examples of how to use `fetchGroups()`.
    The application is named *FetchGroups* (and is available for PostgreSQL).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching via JDBC ResultSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jOOQ is an extremely versatile and transparent tool. For instance, jOOQ acts
    as a wrapper for JDBC `ResultSet` but also allows us to access it directly and
    even provide support to do this smoothly and *painlessly*. Practically, we can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute a `ResultQuery` with jOOQ, but return a JDBC `ResultSet` (this relies
    on the `fetchResultSet()` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform the jOOQ `Result` object into a JDBC `ResultSet` (this relies on the
    `intoResultSet()` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch data from a legacy `ResultSet` using jOOQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these bullets are exemplified in the bundled code. However, here,
    let''s consider the second bullet that starts with the following jOOQ query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'We understand that the returned result is a jOOQ-specific `Result` that was
    built automatically from the underlying `ResultSet`. So, can we reverse this operation
    and obtain the `ResultSet` from the jOOQ `Result`? Yes, we can! We can do this
    via `intoResultSet()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing to note is that this magic happens without an active connection
    to the database. By default, jOOQ closes the database connection after the jOOQ
    `Result` is fetched. This means that, when we call `intoResultSet()` to obtain
    this in-memory `ResultSet`, there is no active connection to the database. jOOQ
    mirrors the `Result` object back into a `ResultSet` without interacting with the
    database. Next, processing this `ResultSet` is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: This matters because, typically, operating on a JDBC `ResultSet` can be done
    as long as you hold an open connection to your database. Check out the complete
    code next to the other two bullets in the bundled application named *ResultSetFetch*
    (which is available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching multiple result sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some RDBMSs (for instance, SQL Server and MySQL after appending the `allowMultiQueries=true`
    property to the JDBC URL) can return multiple result sets. Here is such a jOOQ
    query for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch multiple result sets in jOOQ, call `fetchMany()`. This method returns
    an object of the `org.jooq.Results` type, as shown in the following snippet (notice
    the pluralization to avoid any confusion with `org.jooq.Result`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can map each result set to its POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Lukas Eder says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Perhaps out of scope, but the Results type also allows for accessing interleaved
    update counts and exceptions, which is something that is done frequently in T-SQL
    databases, like SQL Server or Sybase."*'
  prefs: []
  type: TYPE_NORMAL
- en: Done! In the *FetchMany* application (which is available for MySQL and SQL Server),
    you can check out this example next to another one that returns two result sets
    from a query that combines `DELETE` and `SELECT`.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m pretty sure that you''re familiar with the one-to-one, one-to-many, and
    many-to-many relationships. An emblematic mapping of unidirectional one-to-many
    roughly looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, when `SimpleProduct` contains a reference to `SimpleProductLine`,
    this is considered a bidirectional one-to-many relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: If we have this POJO model, can we map the corresponding result set to it via
    the jOOQ API? The answer is definitely yes, and this can be done in several ways.
    From the `fetchInto()`, `fetchMap()`, and `fetchGroups()` methods that you already
    saw to the record mappers, the mighty SQL JSON/XML mapping, and the astonishing
    MULTISET value constructor operator, jOOQ provides so many fetching modes that
    it is almost impossible to not find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, let''s not deviate too much from the subject. Let''s consider the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Map<Record, Result<Record>>` (which, most of the time, is all you need),
    we can populate our bidirectional domain model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to avoid passing through `fetchGroups()`, then you can rely on
    `ResultQuery.collect()` and `Collectors.groupingBy()`. This is especially useful
    if you want to run a `LEFT JOIN` statement since `fetchGroups()` has the following
    issue: [https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888).
    Another approach is to map from `ResultSet`. You can see these approaches along
    with other approaches for unidirectional/bidirectional one-to-one and many-to-many
    relationships in the bundled code in the *OneToOne*, *OneToMany*, and *ManyToMany*
    applications (which are available for MySQL).'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking POJOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know that jOOQ can generate POJOs on our behalf and it can handle
    user-defined POJOs, too. Moreover, you saw a significant number of mappings of
    a jOOQ result into POJOs (typically, via `fetchInto()`); therefore, this is not
    a brand new topic for you. However, in this section, let's take a step further
    and really focus on different types of POJOs that are supported by jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all we configure is `<pojos>true</pojos>` (here, Maven), then jOOQ generates
    POJOs with `private` fields, empty constructors, constructors with arguments,
    getters and setters, and `toString()`. However, jOOQ can also handle a very simple
    user-defined POJO such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a query that populates this POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the `as("customerPhone")` alias. This is needed to map `CUSTOMER.PHONE`
    to POJO''s `customerPhone` field; otherwise, this POJO field will be left `null`
    since jOOQ cannot find the proper match. Another approach is to add a constructor
    with arguments, as shown in the following POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if none of the POJO''s field names match the names of the fetched fields,
    the POJO is correctly populated by jOOQ based on this constructor with arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'User-defined POJOs are useful for mapping jOOQ results that contain fields
    from multiple tables. For example, a POJO can be used to flatten a one-to-many
    relationship, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here''s the jOOQ query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can map UDTs and/or embeddable types. For instance, here
    is a user-defined POJO that fetches a String and an embeddable type containing
    a UDT. For the embeddable type, we relied on the jOOQ-generated POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the jOOQ query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundled code (that is, in the *PojoTypes*
    application, which is available for PostgreSQL). Next, let's talk about the different
    types of POJOs supported by jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Types of POJOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the typical POJOs from the previous section, jOOQ also supports several
    other types of POJOs. For instance, it supports immutable POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable POJOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A user-defined immutable POJO can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'And a jOOQ query that maps to this POJO is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: To work as expected, immutable POJOs require an exact match between the fetched
    fields and the POJO's fields (the constructor arguments). However, you can explicitly
    relax this match via `@ConstructorProperties` (`java.beans.ConstructorProperties`).
    Please check the bundled code (*Example 2.2*) for a meaningful example.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ can generate immutable POJOs on our behalf via the following configuration
    in the `<generate/>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it can generate `@ConstructorProperties` via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, next to the other examples, you can also practice mapping
    UDTs and embeddable types via user-defined immutable POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: POJOs decorated with @Column (jakarta.persistence.Column)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'jOOQ can map a `Result` object to a POJO as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, jOOQ recognizes the `@Column` annotation and uses it as the
    primary source for mapping metainformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ can generate such POJOs via the following configuration in `<generate/>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Check out more examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 16 records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following JDK 16 record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'And the jOOQ query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, here is a user-defined JDK 16 record along with a UDT type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'And the jOOQ query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use a user-defined JDK 16 record with an embeddable type (here,
    we are using the POJO generated by jOOQ for the embeddable type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the jOOQ query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ can generate JDK 16 records on our behalf via the following configuration
    in `<generate/>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can practice JDK 16 records for UDT, embeddable types,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces and abstract classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, jOOQ can map a result into interfaces (abstract classes) known as "proxyable"
    types. You can find examples in the bundled code and in the jOOQ manual at [https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/](https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, jOOQ can generate interfaces on our behalf via this configuration
    in the `<generate/>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: If POJOs are also generated, then they will implement these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Useful configurations for POJOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Among POJO's configurations, we can ask jOOQ to not generate the `toString()`
    method for the POJO via the `<pojosToString/>` flag, to not generate serializable
    POJOs (to not implement `Serializable`) via the `<serializablePojos/>` flag, and
    to generate fluent setters via the `<fluentSetters/>` flag. Moreover, besides
    POJOs for Java, we can ask jOOQ to generate POJOs for Kotlin via the `<pojosAsKotlinDataClasses/>`
    flag or for Scala via the `<pojosAsScalaCaseClasses/>` flag.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, under the `<database/>` tag, we can force `LocalDateTime` into
    POJOs via `<dateAsTimestamp/>` and use unsigned types via `<unsignedTypes/>`.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code is named *PojoTypes* (which is available for PostgreSQL (Maven/Gradle)).
    In the next section, let's talk about record mappers.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ record mappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we need a custom mapping that cannot be achieved via the `fetchInto()`
    method, the `fetchMap()` method, the `fetchGroups()` method, or the `Records`
    utility. A simple approach relies on `Iterable.forEach(Consumer)`, as shown in
    the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example for MySQL in *ForEachConsumer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, especially for such cases, jOOQ provides a functional interface that
    allows us to express the custom mappings of a jOOQ result. In this context, we
    have `org.jooq.RecordMapper`, which returns the result produced after applying
    a custom mapping to the jOOQ result. For instance, let''s consider a legacy POJO
    that was implemented via the `Builder` pattern and is named `LegacyCustomer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'Mapping a jOOQ result into `LegacyCustomer` can be done via a `RecordMapper`
    parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: This example is available in the bundled code, *RecordMapper* (which is available
    for PostgreSQL), next to other examples such as using a `RecordMapper` parameter
    to map a jOOQ result into a max-heap. Moreover, in [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338),
    *jOOQ SPI (Providers and Listeners)*, you'll see how to configure record mappers
    via `RecordMapperProvider` so that jOOQ will automatically pick them up.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you need more generic mapping algorithms, then we have to check
    out some third-party libraries that work with jOOQ. In the top three such libraries,
    we have ModelMapper, SimpleFlatMapper, and Orika Mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is beyond the scope of this book to deep dive into all these libraries.
    Therefore, I decided to go with the SimpleFlatMapper library ([https://simpleflatmapper.org/](https://simpleflatmapper.org/)).
    Let''s assume the following one-to-many mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, SimpleFlatMapper can map a jOOQ result via `SelectQueryMapper`,
    as shown in the following self-explanatory example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: In this code, SimpleFlatMapper maps the jOOQ result, so it acts directly on
    the jOOQ records. This code is available in the *SFMOneToManySQM* application
    (available for MySQL). However, as you can see in the *SFMOneToManyJM* application,
    this library can also take advantage of the fact that jOOQ allows us to manipulate
    the `ResultSet` object itself, so it can act directly on the `ResultSet` object
    via an API named `JdbcMapper`. This way, SimpleFlatMapper bypasses the jOOQ mapping
    to `Record`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the bundled code includes applications for mapping one-to-one and
    many-to-many relationships next to *SFMOneToManyTupleJM*, which is an application
    that combines SimpleFlatMapper and the jOOL `Tuple2` API to map a one-to-many
    relationship without using POJOs. For brevity, we cannot list this code in the
    book, so you need to reserve some time to explore it by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'From another perspective, via the same `SelectQueryMapper` and `JdbcMapper`
    APIs, the SimpleFlatMapper library can co-work with jOOQ to map chained and/or
    nested `JOIN` statements. For instance, consider this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the SimpleFlatMapper and jOOQ combination, we can populate this model
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is named *SFMMultipleJoinsSQM*. The version of this code that
    uses `JdbcMapper` is named *SFMMultipleJoinsJM*. Moreover, in the bundled code,
    you can find an example of mapping a deep hierarchical JOIN of type (`EMPLOYEE`
    has `CUSTOMER` has `ORDER` has `ORDERDETAIL` has `PRODUCT`). This JOIN is also
    mapped in *SFMMultipleJoinsInnerLevelsTupleJM* using jOOL `Tuple2` and no POJOs.
    Anyway, even if such things work, I don't recommend you to do it in real applications.
    You better rely on the SQL/JSON/XML operators or MULTISET, as you'll do later.
  prefs: []
  type: TYPE_NORMAL
- en: Again, for brevity, we cannot list this code in the book, so you need to reserve
    some time to explore it by yourself. At this point, we have reached the climax
    of this chapter. It's time to beat the drums because the next section covers the
    outstanding mapping support of jOOQ SQL/JSON and SQL/XML.
  prefs: []
  type: TYPE_NORMAL
- en: The mighty SQL/JSON and SQL/XML support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with jOOQ 3.14, we have support for mapping a result set to any kind
    of hierarchical/nested structure that can be shaped via JSON or XML into, practically,
    almost anything. For instance, if you develop a REST API, you can return JSON/XML
    data in the exact desired shape without mapping anything to your domain model.
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know, most RDBMSs support SQL/JSON (standard or vendor-specific),
    and some of them support SQL/XML, too.
  prefs: []
  type: TYPE_NORMAL
- en: Handling SQL/JSON support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, for SQL/JSON, we can talk about the following operators that
    have a jOOQ implementation in the `org.jooq.impl.DSL` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSON_OBJECT` (`DSL.jsonObject()`, `DSL.jsonEntry()`), `JSON_ARRAY` (`DSL.jsonArray()`),
    and `JSON_VALUE` (`DSL.jsonValue()`) to construct JSON data from values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON_ARRAYAGG` (`DSL.jsonArrayAgg()`) and `JSON_OBJECTAGG` (`DSL.jsonObjectAgg()`)
    to aggregate data into nested JSON documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON_EXISTS` (`DSL.jsonExists()`) to query documents with the JSON path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON_TABLE` (`DSL.jsonTable()`) to transform JSON values into SQL tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server's `FOR JSON` syntax (including `ROOT`, `PATH`, `AUTO`, and `WITHOUT_ARRAY_WRAPPER`);
    the jOOQ commercial edition emulates the `FOR JSON` syntax for the databases that
    don't support it (in this book, you can see this for SQL Server and Oracle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see some introductory examples of these operators via the jOOQ DSL API.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and aggregating JSON data from the values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructing JSON data from values can be done via the `JSON_OBJECT` operator.
    This is implemented in jOOQ via different flavors of the `DSL.jsonObject()` method.
    For instance, you can map the `CUSTOMER.CUSTOMER_NAME` and `CUSTOMER.CREDIT_LIMIT`
    fields to an `org.jooq.JSON` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to the `key().value()` construction, we can use `jsonObject(JSON
    Entry<?>... entries)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned `Result` object (remember that this is a wrapper of `java.util.List`)
    has a size equal to the number of fetched customers. Each `Record1` object wraps
    an `org.jooq.JSON` instance representing a customer name and credit limit. If
    we just want to format this `Result` object as a JSON, we can call the `formatJSON()`
    method (this will be presented in the next chapter). This will return a simple
    formatted representation such as the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this response is too verbose to send to the client. For instance,
    you might only need the `"records"` key. In such cases, we can rely on the `formatJSON(JSONFormat)`
    flavor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: 'Supposing that you just want to send the first JSON array, you can extract
    it from the `Result` object as `result.get(0).value1().data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'However, perhaps you are planning to send all these JSONs as a `List<String>`
    to the client. Then, rely on `fetchInto(String.class)`, which will return all
    of the JSONs as a `List<String>`. Note that each `String` is a JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can send the response as a list of JSON arrays. Just wrap each JSON
    object into an array via `jsonArray()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the first JSON array (at index 0 in the list) is *[{"creditLimit":
    21000.00, "customerName": "Australian Home"}]*, the second one (at index 1 in
    the list) is *[{"creditLimit": 21000, "customerName": "Joliyon"}]*, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is more practical to aggregate all of these JSONs into a single
    array. This is possible via `jsonArrayAgg()`, which will return a single JSON
    array containing all of the fetched data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: 'The aggregated JSON array is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also aggregate the fetched data as a single JSON object that
    has `CUSTOMER_NAME` as the key and `CREDIT_LIMIT` as the value. This can be done
    via the `jsonObjectAgg()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the resulting JSON is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are a SQL Server fan, then you know that fetching data as JSON can be
    done via the non-standard `FOR JSON` syntax. jOOQ supports this syntax via the
    `forJson()` API. It also supports clauses such as `ROOT` via `root()`, `PATH`
    via `path()`, `AUTO` via `auto()`, and `WITHOUT_ARRAY_WRAPPER` via `withoutArrayWrapper()`.
    Here is an example that produces nested results by using dot-separated column
    names via `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of using `AUTO`, which automatically produces the output
    based on the structure of the `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples in the bundled code for *SimpleJson* and get
    familiar with the produced JSONs. For now, let's talk about ordering and limiting
    the content of the resulting JSON when using SQL-standard JSON operators (for
    SQL Server's `FOR JSON` syntax, consider the previous two examples).
  prefs: []
  type: TYPE_NORMAL
- en: Using ORDER BY and LIMIT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we don''t use aggregation operators, ordering and limiting are quite similar
    to regular queries. For instance, you can order by `CUSTOMER_NAME` and limit the
    result to three JSONs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when the aggregation operators (`jsonArrayAgg()` and `jsonObjectAgg()`)
    are involved, limiting should be done before the aggregation (for instance, in
    a subquery, `JOIN`, and more). Otherwise, this operation will be applied to the
    resulted aggregation itself, not to the aggregated data. During aggregation, ordering
    can be done before limiting, respectively. For instance, in the following example,
    the subquery orders the customers by `CUSTOMER_NAME` and limits the returned result
    to 3, while the aggregation orders this result by `CREDIT_LIMIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting aggregation is ordered by `CREDIT_LIMIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundled code for *SimpleJson*. Note that,
    in the applications that uses PostgreSQL and Oracle, you can see the SQL standard's
    `NULL ON NULL` (`nonOnNull()`) and `ABSENT ON NULL` (`absentOnNull()`) syntax
    at work. For now, let's query documents with the JSON path.
  prefs: []
  type: TYPE_NORMAL
- en: Querying JSON documents with the JSON path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Via `JSON_EXISTS` and `JSON_VALUE`, we can query and construct JSON documents
    that rely on the JSON path. In order to practice jOOQ's `jsonExists()` and `jsonValue()`
    queries, let's consider the `MANAGER.MANAGER_DETAIL` field, which stores data
    in JSON format. Please take a quick look at this JSON so that you can become familiar
    with its structure and content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, selecting the `MANAGER.MANAGER_ID` and `MANAGER.MANAGER_NAME` fields of
    the managers that are also shareholders(with the `"shareholder"` key in JSON)
    can be done via `jsonExists()` and the JSON path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: 'If the fetched JSON is constructed from JSON values, then we should rely on
    `jsonValue()` and the JSON path. For instance, fetching the cities of all managers
    can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining `jsonExists()` and `jsonValue()` allows us to query and construct
    JSON results from JSON documents. For instance, in PostgreSQL and Oracle, we can
    select the emails of the managers that had the role of *Principal Manager* by
    exploiting the JSON path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundled code, *SimpleJson*. Next, let's tackle
    `JSON_TABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming JSON values into SQL tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transforming JSON values into SQL tables can be done via the `JSON_TABLE` operator,
    which, in jOOQ, is equivalent to the `jsonTable()` method. For instance, let''s
    build a SQL table containing all projects of the development type via the `jsonTable(Field<JSON>
    json, Field<String> path)` flavor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will produce a table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The result of the previous query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The result of the previous query
  prefs: []
  type: TYPE_NORMAL
- en: Once you fetch a SQL table, you can think and act on it in the same way as any
    other database table. For brevity, I simply used `VARCHAR`, but it is better to
    specify a size in order to avoid defaulting to `VARCHAR(max)`.
  prefs: []
  type: TYPE_NORMAL
- en: More examples, including how to use `JSON_TABLE` with aggregates, `ORDER BY`,
    `LIMIT`, and how to transform back into JSON from a SQL table, are available in
    the bundled code, *SimpleJson*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling relationships via SQL/JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The well-known one-to-one, one-to-many, and many-to-many relationships can be
    easily shaped via SQL/JSON support.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping relationships to JSON
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So, if by any chance you had a feeling that there is a shortcoming in jOOQ
    regarding mapping relationships, then you''ll be very happy to see that a one-to-many
    relationship can be easily fetched directly into JSON as follows (in this case,
    we''re looking at the relationship between `PRODUCTLINE` and `PRODUCT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: As you can infer from the preceding code, expressing the one-to-one and many-to-many
    relationships is just a matter of juggling with the SQL/JSON operators. You can
    find these examples, including how to use `JOIN` instead of a `SELECT` subquery,
    in the bundled code for *JsonRelationships*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think that `Result<Record1<JSON>>` is not ready to be sent to the client
    (for instance, via a REST controller), then decorate it a little bit more by aggregating
    all the product lines under a JSON array and relying on `fetchSingleInto()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL Server, we can obtain a similar result via `forJson()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can obtain a `String` via `formatJSON(JSONformat)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Both examples will produce a JSON, as follows (as you can see, altering the
    default JSON keys inferred from the field names can be done with aliases via `as("alias")`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code for *JsonRelationships*, you can find a lot of examples
    to do with one-to-one, one-to-many, and many-to-many relationships. Moreover,
    you can check out several examples of how to map arrays and UDTs into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping JSON relationships to POJOs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you just saw, jOOQ can fetch and map a relationship directly into JSON.
    However, that''s not all! jOOQ can go even further and map the resulted JSON to
    the domain model (POJOs). Yes, you read that right; as long as we have Gson, Jackson
    (Spring Boot has this by default), or JAXB in the classpath, jOOQ can automatically
    map the query results to our nested data structures. This is quite useful when
    you don''t actually need the JSON itself – you can just rely on JSON to facilitate
    the nesting data structures and map them back to Java. For instance, let''s assume
    the following domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we populate this model from jOOQ `Result` by just using jOOQ? Yes, we can
    do it via SQL/JSON support, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: That's so cool, right?! The same thing can be accomplished for one-to-one and
    many-to-many relationships, as you can see in the bundled code. All examples are
    available in *JsonRelationshipsInto*.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping arbitrary models
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you think that what you''ve just seen is impressive, then get ready for
    more because jOOQ can fetch and map almost any kind of arbitrary model, not just
    the well-known 1:1,1:n, and n:n relationships. Let''s consider the following three
    arbitrary models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Arbitrary domain models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Arbitrary domain models
  prefs: []
  type: TYPE_NORMAL
- en: 'Which one do you choose to be exemplified in the book? The second one (`jsonObject()`
    and `jsonArrayAgg()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: 'Lukas Eder states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"What I always like to mention in this regard is that there are no accidental
    Cartesian Products or costly de-duplication* *going on (as with JPA), because
    all the data is already nested correctly in SQL, and transferred optimally. This
    approach should be the first choice when nesting collections with SQL or producing
    JSON/XML for some frontend. Never use ordinary joins, which should be used only
    for flat results or aggregations."*'
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to dissect this query and check out the bundled code to see the
    output. Moreover, in the bundled code, you can practice **Model 1** and **Model
    3**, too. For each of these models, you have the JSON result and the corresponding
    mapping to POJOs. The application is named *NestedJson*.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure that, as a SQL Server fan, you are impatient to see the version of
    the previous query expressed via `forJson()`, so here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can check out these examples in the bundled code next to the
    examples for **Model 1** and **Model 3**.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Next to SQL/JSON support, jOOQ also provides SQL/JSONB support. You can explicitly
    use JSONB via `org.jooq.JSONB` and the operators such as `jsonbObject()`, `jsonbArrayAgg()`,
    and `jsonbTable()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to talk about SQL/XML support.
  prefs: []
  type: TYPE_NORMAL
- en: Handling SQL/XML support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, for SQL/XML, we can talk about the following operators that
    have a jOOQ implementation in the `org.jooq.impl.DSL` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XMLELEMENT` (`DSL.xmlelement()`), `XMLATTRIBUTES` (`DSL.xmlattributes()`),
    `XMLFOREST` (`DSL.xmlforest()`), `XMLCONCAT` (`DSL.xmlconcat()`), and `XMLCOMMENT`
    (`DSL.xmlcomment()`) to construct XML data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLAGG` (`DSL.xmlagg()`) to aggregate data into nested XML documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLEXISTS` (`DSL.xmlexists()`) and `XMLQUERY` (`DSL.xmlquery()`) to query
    XML documents with `XPath`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLPARSE` (`DSL.xmlparseContent()` and `DSL.xmlparseDocument()`) for parsing
    XML content and documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLPI` (`DSL.xmlpi()`) for producing XML processing instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLTABLE` (`DSL.xmltable()`) to transform XML values into SQL tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server's `FOR XML` syntax (including `ROOT`, `PATH`, `ELEMENTS`, `RAW`,
    and `AUTO`, and `EXPLICIT (jOOQ 3.17.x +)`) – jOOQ's commercial editions emulate
    the `FOR XML` syntax for databases that don't support it (in this book, you can
    practice this for SQL Server and Oracle).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some introductory examples of these operators via the jOOQ DSL API.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and aggregating XML data from values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good start for constructing XML data from values relies on the `XMLELEMENT`
    operator. In jOOQ, `XMLELEMENT` is rendered via the `xmlelement()` method. For
    instance, the following snippet of code fetches the `CUSTOMER_NAME` field of each
    customer and uses it as the text of an XML element named `<name/>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned `Result` has a size that is equal to the number of fetched customers.
    Each `Record1` wraps an `org.jooq.XML` instance representing a `<name/>` element.
    If we just want to format this `Result` as an XML, we can call the `formatXML()`
    method (this will be presented in the next chapter). This will return a simple
    formatted representation such as the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this response is too verbose to send to the client. For instance,
    you might only need the `"records"` element. In such cases, we can rely on the
    `formatXML(XMLFormat)` flavor, as you''ll see in the bundled code. Supposing that
    you want to just send the first `<name/>` element, you can extract it from the
    `Result` object as `result.get(0).value1().data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: 'However, perhaps you are planning to send all of these `<name/>` tags as a
    `List<String>` to the client. Then, rely on `fetchInto(String.class)` to return
    all the `<name/>` elements as a `List<String>`. Note that each `String` is a `<name/>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it would be more practical to aggregate all these `<name/>`
    elements as a single `String`. This is possible via `xmlagg()`, which returns
    a single XML containing all of the fetched data (for convenience, let''s aggregate
    everything under the `<names/>` tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: 'The aggregated XML is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: 'What about adding attributes to the XML elements? This can be done via `xmlattributes()`,
    as shown in the following intuitive example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected XML will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: 'A relatively useful XML operator is `xmlforest()`. This operator converts its
    parameters into XML and returns an XML fragment obtained by the concatenation
    of these converted arguments. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of `xmlforest()` can be seen in the resulting XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are a SQL Server fan, then you know that fetching data as XML can be
    done via the non-standard `FOR XML` syntax. jOOQ supports this syntax via the
    `forXml()` API. It also supports clauses such as `ROOT` via `root()`, `PATH` via
    `path()`, `AUTO` via `auto()`, `RAW` via `raw()`, and `ELEMENTS` via `elements()`,
    as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: 'The produced XML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: Note that missing tags (check the second `<office/>` instance, which does not
    have `<city/>` or `<country/>`) represent missing data.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, allow me to mention that jOOQ can also transform XML into an
    `org.w3c.dom.Document` by calling a flavor of `intoXML()` on `Record1<XML>`. Moreover,
    you'll love jOOX, or object-oriented XML ([https://github.com/jOOQ/jOOX](https://github.com/jOOQ/jOOX)),
    which can be used to XSL transform or navigate the resulting XML document in a
    jQuery style.
  prefs: []
  type: TYPE_NORMAL
- en: 'I totally agree (sharing his enthusiasm) with Lukas Eder, who states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"I don''t know about you, but when I see these examples, I just want to write
    a huge application using jOOQ :) I mean, how else would anyone ever want to query
    databases and produce JSON or XML documents??"*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see these examples (alongside many others) in the bundled code for *SimpleXml*
    and get familiar with the produced XMLs. For now, let's talk about how to order
    and limit the content of the resulting XML.
  prefs: []
  type: TYPE_NORMAL
- en: Using ORDER BY and LIMIT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we don''t use the `xmlagg()` aggregation operator, ordering and limiting
    is the same as for regular queries. For instance, you can order by `CUSTOMER_NAME`
    and limit the result to three XMLs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when the `xmlagg()` aggregation operator is used, then limiting
    should be done before the aggregation (for instance, in a subquery, `JOIN`, and
    more). Otherwise, this operation will be applied to the resulting aggregation
    itself. During aggregation, ordering can be done before limiting, respectively.
    For instance, in the following example, the subquery orders the customers by `CONTACT_LAST_NAME`
    and limits the returned results to 3, while the aggregation orders this result
    by `CONTACT_FIRST_NAME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulted aggregation is ordered by `CUSTOMER_FIRST_NAME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundle code for *SimpleXml*. For now, let's
    learn how to query XML documents with XPath.
  prefs: []
  type: TYPE_NORMAL
- en: Querying XML documents with XPath
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Querying XML documents can be done via the XPath expressions, and we can distinguish
    between queries that check for the existence of an element/attribute via `XMLEXISTS`
    (`xmlexists()`) and queries that fetches certain data from an XML document via
    `XMLQUERY` (`xmlquery()`). For instance, in `PRODUCTLINE`, we have a field named
    `HTML_DESCRIPTION` that holds the description of a product line in XML format.
    If a product line has a description, then this description starts with the `<productline/>`
    tag. So, fetching all product lines that have a description can be done via `xmlexists()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: In `xmlexists("/productline").passing(…)`,`/productline` represents the XPath
    that should be searched, and the argument of the `passing()` method represents
    the XML document (or fragment) in which this XPath is searched.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following snippet of code relies on `xmlquery()` to
    fetch an XML containing certain data from `HTML_DESCRIPTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the argument of `passing()` can be an XML build from certain fields,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: This query fetches all the `<phone/>` tags from the given XML (for instance,
    `<phone>(26) 642-7555</phone>`). More examples are available in *SimpleXml*. Next,
    let's tackle `XMLTABLE`.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming XML values into SQL tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transforming XML values into SQL tables can be done via the `XMLTABLE` operator,
    which, in jOOQ, is equivalent to `xmltable()`. For instance, let''s build a SQL
    table containing the details of each product line extracted from `HTML_DESCRIPTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will produce a table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The result of the previous query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – The result of the previous query
  prefs: []
  type: TYPE_NORMAL
- en: Once you fetch a SQL table, you can think and act on it in the same way as any
    other database table. For brevity, I simply used `VARCHAR`, but it is better to
    specify a size in order to avoid defaulting to `VARCHAR(max)`.
  prefs: []
  type: TYPE_NORMAL
- en: More examples, including how to use `XMLTABLE` with aggregates, `ORDER BY`,
    `LIMIT`, and how to transform back into XML from a SQL table, are available in
    *SimpleXml*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling relationships via SQL/XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handling the typical 1:1, 1:n, and n:n relationships can be done via jOOQ SQL/XML
    support. Let's go through a quick rundown of it.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping relationships to XML
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of the time, such relationships can be materialized into XML via a thoughtful
    combination of `xmlelement()`, `xmlagg()`, and `xmlforest()`. Since you are already
    familiar with the one-to-many relationship between `PRODUCTLINE` and `PRODUCT`,
    let''s shape it into XML via SQL/XML support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: As you can infer from the preceding code, expressing the one-to-one and many-to-many
    relationships is just a matter of juggling with the SQL/XML operators. You can
    find these examples, including how to use `JOIN` instead of a `SELECT` subquery,
    in the bundled code for *XmlRelationships*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think that `Result<Record1<XML>>` is not ready to be sent to the client
    (for instance, via a REST controller), then decorate it a little bit more by aggregating
    all the product lines under a XML element (root) and relying on `fetchSingleInto()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL Server, we can obtain a similar result via `forXml()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can obtain a `String` via `formatXML(XMLformat)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: 'Both examples will produce almost an identical XML, as follows (as you can
    see, altering the default XML tags inferred from the field names can be done with
    aliases via `as("alias")`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples in the *XmlRelationships* application.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping arbitrary nested models
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'jOOQ allows us to map arbitrarily nested models, not just the well-known 1:1,1:n,
    and n:n relationships, via SQL/XML support. Remember **Model 2** (see *Figure
    8.3*)? Well, you already know how to fetch and map that model via SQL/JSON support,
    so this time, let''s see how it can be done via SQL/XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: This is the power of example; there is not much else to say. Take your time
    to dissect this query, and check out the bundled code to see the output. Moreover,
    in the bundled code, you can see **Model 1** and **Model 3**, too. The application
    is named *NestedXml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a SQL Server fan, you might be more interested in the previous query expressed
    via `forXML()`, so here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, *NestedXml*, you can practice many more examples that,
    for brevity reasons, couldn't be listed here. Remember that, especially for this
    chapter, I beat the drums. Now, it is time to bring in an entire orchestra and
    pay tribute to the coolest feature of jOOQ mapping. Ladies and gentlemen, allow
    me to introduce the MULTISET!
  prefs: []
  type: TYPE_NORMAL
- en: Nested collections via the astonishing MULTISET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MULTISET value constructor (or MULTISET for short) is a SQL standard future
    that shapes nested subqueries (except scalar subqueries) into a single nested
    collection value. jOOQ 3.15+ provides marvelous and glorious support for MULTISET.
    It's marvelous because despite its tremendous power, it is quite easy (effortless)
    and intuitive to use via jOOQ, and it is glorious because it can produce any nested
    collection value of jOOQ `Record` or DTO (POJO/Java records) in a fully type-safe
    manner, with 0 reflections, no N+1 risks, no deduplications. This allows the database
    to perform nesting and to optimize the query execution plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the well-known one-to-many relationship between `PRODUCTLINE` and
    `PRODUCT`. We can fetch and map this relationship via jOOQ''s `<R extends Record>
    Field<Result<R>> multiset(Select<R> select)`, in jOOQ before 3.17.x, and `Field<Result<R>>`
    `multiset(TableLike<R> table)` starting with jOOQ 3.17.x as follows (later, we
    will refer to this example as *Exhibit A*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the usage is quite simple! The jOOQ `multiset()` constructor gets a `SELECT`
    statement as an argument(or, a table-like object, starting with jOOQ 3.17.x).
    Formally speaking, the result set of this `SELECT` statement represents a collection
    that will be nested in the outer collection (the result set produced by the outer
    `SELECT` statement). By nesting/mixing `multiset()` and `select()` (or `selectDistinct()`),
    we can achieve any level or shape/hierarchy of nested collections. Previously,
    we used the Java 10 `var` keyword as the type of result, but the real type is
    `Result<Record3<String, String, Result<Record3<String, String, Integer>>>>`. Of
    course, more nesting will produce a really hard-to-digest `Result` object, so
    using `var` is the recommended way to go. As you already intuited, `Result<Record3<String,
    String, Integer>>` is produced by the `SELECT` statement from `multiset()`, while
    `Result<Record3<String, String, nested_result>>` is produced by the outer `SELECT`
    statement. The following diagram will help you to better understand this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The type returned by the previous query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The type returned by the previous query
  prefs: []
  type: TYPE_NORMAL
- en: 'Since MULTISET has quite poor native support in databases, jOOQ has to emulate
    it via the SQL/JSON or SQL/XML operators. For instance, the previous query renders
    the following SQL in MySQL (check out how jOOQ uses `json_merge_preserve()` and
    `json_array()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: At any moment, you can transform this collection of `Record` into plain JSON
    or XML via `formatJSON()`/`formatXML()`. However, allow me to take this opportunity
    to highlight that if all you want is to fetch a JSON/XML (since this is what your
    client needs), then it is better to use the SQL/JSON and SQL/XML operators directly
    (as you saw in the previous section) instead of passing through MULTISET. You
    can find examples in the bundled code, *MultisetRelationships*, alongside examples
    of how to use MULTISET for one-to-one and many-to-many relationships. In the example
    for many-to-many relationships, you can see how well the jOOQ type-safe implicit
    (one-to-one) join feature fits with MULTISET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember **Model 2** (see *Figure 8.3*)? Well, you already know how to fetch
    and map that model via SQL/JSON and SQL/XML support, so let''s see how to do it
    via MULTISET, too (later on, we will refer to this example as *Exhibit B*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the returned type is quite verbose: `Result<Record4<String, BigDecimal,
    Result<Record4<Long, BigDecimal, LocalDateTime, Result<Record2<String, BigDecimal>>>>,
    Result<Record3<String, String, String>>>>`. The following diagram explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The type returned by the previous query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – The type returned by the previous query
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example next to Model 1 and Model 3 in the application named
    *NestedMultiset*. Next, let's see how we can map MULTISET to DTO (for instance,
    POJO and Java 16 records).
  prefs: []
  type: TYPE_NORMAL
- en: Mapping MULTISET to DTO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the result of a MULTISET as a generic structural type is cool, but most
    probably, you''ll love to have a `List` of POJO/Java records instead. For instance,
    if we think of *Exhibit A*, then you''ll probably write the following Java records
    as the mapping model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you''re expecting that `Result<Record3<String, String, Integer>>` will
    be fetched via MULTISET to be mapped to `List<RecordProduct>` and the whole query
    result to `List<RecordProductLine>`. The first part can be accomplished via the
    new ad hoc `Field.convertFrom()` converter, which was introduced in [*Chapter
    7*](B16833_07.xhtml#_idTextAnchor110), *Types, Converters, and Bindings*. With
    `Field.convertFrom()`, we convert the given `Field<T>` (here, `Field<Result<Record3<String,
    String, Integer>>>` is returned by `multiset()`) into a read-only `Field<U>` (here,
    `Field<List<RecordProduct>>`) for ad hoc usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: The `r` parameter from `r -> r.map(mapping(RecordProduct::new))` is `Result<Record3<String,
    String, Integer>>`, so this lambda can be seen as `Result<Record3<String, String,
    Integer>> -> RecordProduct`. The `r.map(…)` part is the `Result.map(RecordMapper<R,
    E>)` method. Finally, the `Records.mapping()` method (introduced earlier in this
    chapter) turns the constructor reference of the `Function3<String, String, Integer,
    RecordProduct>` type into a `RecordMapper` parameter, which is further used to
    turn a `Result<Record3<String, String, Integer>>` into a `List<RecordProduct>`.
    The resulting `Field<List<SimpleProduct>>` (which is like any other jOOQ `Field`)
    is now part of the outer `SELECT` next to `PRODUCTLINE.PRODUCT_LINE` (which is
    a `String`), and `PRODUCTLINE.TEXT_DESCRIPTION` (which is also a `String`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our last mission is to convert the outer-most `Result3<String, String,
    List<RecordProduct>>` into `List<RecordProductLine>`. For this, we rely only on
    `mapping()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, we can manipulate the `List<RecordProductLine>`. You can find this
    example in *MultisetRelationshipsInto*. By applying what we''ve learned here to
    the more complex *Exhibit B*, we obtain the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: 'And the *Exhibit B* query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: This example, next to the examples for Model 1 and Model 3 from *Figure 8.3*,
    is available in *NestedMultiset*. Next, let's tackle the `MULTISET_AGG()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The MULTISET_AGG() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The jOOQ `MULTISET_AGG()` function is a synthetic aggregate function that can
    be used as an alternative to MULTISET. Its goal is to aggregate data into a nested
    collection represented as a jOOQ `Result` in a type-safe manner. The `MULTISET_AGG()`
    function is a convenient solution when we need to order by some aggregate value
    or create a `WHERE` statement based on result of not-deeply nested collection.
    For instance, the well-known one-to-many `PRODUCTLINE`:`PRODUCT` relationship
    can be aggregated as a nested collection as follows (the result type is `Result<Record3<String,
    String, Result<Record3<String, String, Integer>>>>`):'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with jOOQ 3.17.x, we can turn an expression of type `String`, `Name`,
    `Field`, and so in, into a multiset via `DSL.asMultiset()` methods. Check out
    the jOOQ documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: This example is available, along with more examples, in *MultisetAggRelationships*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping the `Result` object to a DTO (for instance, POJO and Java 16 records)
    is accomplished by following the same principles as in the case of MULTISET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: This example is available alongside other examples in *MultisetAggRelationshipsInto*.
    Next, let's try to compare MULTISETs.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing MULTISETs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MULTISETs can be used in predicates, too. Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: 'But when we can say that two MULTISETs are equal? Check out the following examples
    that are meant to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: So, which of A, B, C, and D will return 1? The correct answer is A and C. This
    means that two MULTISETs are equal if they have the exactly same number of elements
    in the same order. The application is named *MultisetComparing*. Feel free to
    determine when a MULTISET X is greater/lesser/contained … than a MULTISET Y.
  prefs: []
  type: TYPE_NORMAL
- en: Also, don't forget to read [https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/](https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/)
    and [https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/](https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/).
    It looks as though jOOQ 3.17 will enrich MULTISET support with even more cool
    features, [https://twitter.com/JavaOOQ/status/1493261571103105030](https://twitter.com/JavaOOQ/status/1493261571103105030),
    so stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since `MULTISET` and `MULTISET_AGG()` are such hot topics you should
    constantly update your skills from real scenarios exposed at [https://stackoverflow.com/search?q=%5Bjooq%5D+multiset](https://stackoverflow.com/search?q=%5Bjooq%5D+multiset).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about lazy fetching.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hibernate JPA guy: So, how do you handle huge result sets in jOOQ?'
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ guy (me): jOOQ supports lazy fetching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hibernate JPA guy: And how do you manage `LazyInitializationException`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ guy (me): For Hibernate JPA users that have just got here, I''d like to
    stress this right from the start – don''t assume that jOOQ lazy fetching is related
    to or similar to Hibernate JPA lazy loading. jOOQ doesn''t have and doesn''t need
    a Persistence Context and doesn''t rely on a `Session` object and proxy objects.
    Your code is not prone to any kind of lazy loading exceptions!'
  prefs: []
  type: TYPE_NORMAL
- en: Then, what is jOOQ lazy fetching?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, most of the time, fetching the entire result set into memory is the best
    way to exploit your RDBMS (especially in web applications that face high traffic
    by optimizing small result sets and short transactions). However, there are cases
    (for instance, you might have a huge result set) when you''ll like to fetch and
    process the result set in small chunks (for example, one by one). For such scenarios,
    jOOQ comes with the `org.jooq.Cursor` API. Practically, jOOQ holds a reference
    to an open result set and allows you to iterate (that is, load and process into
    memory) the result set via a number of methods such as `fetchNext()`, `fetchNextOptional()`,
    `fetchNextInto()`, and `fetchNextOptionalInto()`. However, to get a reference
    to an open result set, we have to call the `fetchLazy()` method, as shown in the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are relying on the try-with-resources wrapping to ensure that
    the underlying result set is closed at the end of the iterating process. In this
    snippet of code, jOOQ fetches the records from the underlying result set into
    memory one by one via `fetchNext()`, but this doesn't mean that the JDBC driver
    does the same thing. JDBC drivers act differently across different database vendors
    and even across different versions of the same database. For instance, MySQL and
    PostgreSQL pre-fetches all records in a single database round-trip, SQL Server
    uses adaptive buffering (in the JDBC URL, we have `selectMethod = direct; responseBuffering
    = adaptive;`) and a default fetch size of 128 to avoid out-of-memory errors, and
    Oracle JDBC fetches a result set of 10 rows at a time from the database cursor
    (on the JDBC URL level, this can be altered via the `defaultRowPrefetch` property).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the fetch size is just a JDBC hint trying to instruct the
    driver about the number of rows to fetch in one go from the database. However,
    the JDBC driver is free to ignore this hint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, configuring the fetch size can be done via `ResultQuery.fetchSize(int
    size)` or `Settings.withFetchSize(int size)`. jOOQ uses this configuration to
    set the underlying `Statement.setFetchSize(int size)` JDBC. Most JDBC drivers
    only apply this setting in certain contexts. For instance, MySQL should only apply
    this setting if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set a forward-only result set (this can be set via jOOQ, `resultSetType()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a concurrency read-only result set (via jOOQ, `resultSetConcurrency()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fetch size is either set to `Integer.MIN_VALUE` for fetching records one
    by one or to the desired size while adding `useCursorFetch=true` to the JDBC URL
    for relying on cursor-based streaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet of code that takes advantage of these settings for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named *LazyFetching*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, PostgreSQL uses the fetch size if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set forward-only result set (can be set via jOOQ, `resultSetType()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable the *auto-commit* mode (in Spring Boot with the default Hikari CP connection
    pool, this can be done in `application.properties` via the following flag-property,
    `spring.datasource.hikari.auto-commit=false`, or in jOOQ via `<autoCommit>false</autoCommit>`
    in the `<jdbc/>` tag of your configuration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the code for PostgreSQL can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, in PostgreSQL, the fetch size can be altered via `defaultRowFetchSize`
    and added to the JDBC URL. The complete example is also named *LazyFetching*.
  prefs: []
  type: TYPE_NORMAL
- en: For SQL Server and Oracle, we can rely on the default fetch size since both
    of them prevent out-of-memory errors. Nevertheless, enabling the fetch size in
    SQL Server is quite challenging while using the Microsoft JDBC driver (as in this
    book). It is much simpler if you rely on the jTDS driver.
  prefs: []
  type: TYPE_NORMAL
- en: Our examples for SQL Server and Oracle (*LazyFetching*) rely on the default
    fetching size; therefore, 128 for SQL Server and 10 for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can combine `ResultSet` and the Cursor API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's talk about lazy fetching via streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy featching via fetchStream()/fetchStreamInto()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In jOOQ, lazy fetching can also be achieved via `fetchStream()`/`fetchStreamInto()`.
    This method keeps an open JDBC result set internally and allows us to stream its
    content (that is, lazy fetching the result set into memory). For example, plain
    SQL can take advantage of `DSLContext.fetchStream()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the generated Java-based schema, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works in the same way as the next one, which uses `stream()`, not
    `fetchStream()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: 'However, pay attention as this code is not the same as the next one (the previous
    example uses `org.jooq.ResultQuery.stream()`, while the next example uses `java.``util.``Collection.stream()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `fetch()` method fetches the whole result set into memory and closes
    the database connection – this time, we don't need the try-with-resources wrapping
    since we are, essentially, streaming a list of records. Next, the `stream()` method
    opens a stream over the in-memory result set and no database connection is kept
    open. So, pay attention to how you write such snippets of code since you will
    be prone to accidental mistakes – for instance, you might need lazy fetching but
    accidentally add `fetch()`, or you might want eager fetching but accidentally
    forget to add `fetch()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using org.jooq.ResultQuery.collect()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we need the stream pipeline to apply specific operations (for instance,
    `filter()`), and to collect the results, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we don''t actually need the stream pipeline (for instance, we don''t
    need the `filter()` call or any other operation), and all we want is to lazily
    collect the result set, then it is pointless calling `fetchStream()`. But if we
    remove `fetchStream()`, how can we still collect in a lazy fashion? The answer
    is the jOOQ `collect()` method, which is available in `org.``jooq.``ResultQuery`.
    This method is very handy because it can handle resources internally and bypass
    the intermediate `Result` data structure. As you can see, there is no need to
    use try-with-resources after removing the `fetchStream()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: However, please bear in mind the following note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a good practice to ensure that streaming is really needed. If
    your stream operations have SQL counterparts (for example, `filter()` can be replaced
    with a `WHERE` clause and `summingDouble()` can be replaced with the SQL''s `SUM()`
    aggregate function), then go for the SQL. This will be much faster due to the
    significantly lower data transfer. So, always ask yourself: "*Can I translate
    this streaming operation into my SQL?*" If yes, then do it! If not, then go for
    streaming, as we will do in the following example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that lazy fetches groups. jOOQ doesn''t fetch everything
    in memory thanks to `collect()`, and since we also set the fetch size, the JDBC
    driver fetches the result set in small chunks (here, a chunk has five records).
    The PostgreSQL version is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named *LazyFetchingWithStreams*. Next, let's talk
    about asynchronous fetching.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you consider that you need asynchronous fetching (for instance, a
    query takes too long to wait for it or multiple queries can run independently
    of each other (non-atomically)) you can rely on the jOOQ + `CompletableFuture`
    combination. For instance, the following asynchronous operation chains an `INSERT`
    statement, an `UPDATE` statement, and a `DELETE` statement using the `CompletableFuture`
    API and the threads obtained from the default `ForkJoinPool` API (if you are not
    familiar with this API, then you can consider purchasing the *Java Coding Problems*
    book from Packt, which dives deeper into this topic):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: This example is available for MySQL next to another one in the application named
    *SimpleAsync*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can exploit `CompletableFuture` and jOOQ, as demonstrated in the previous
    example. However, you can also rely on two jOOQ shortcuts, `fetchAsync()` and
    `executeAsync()`. For instance, let''s suppose that we want to fetch managers
    (`MANAGER`), offices (`OFFICE`), and employees (`EMPLOYEE`) and serve them to
    the client in HTML format. Fetching managers, offices, and employees can be done
    asynchronously since these three queries are not dependent on each other. In this
    context, the jOOQ `fetchAsync()` method allows us to write the following three
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we wait for these three asynchronous methods to complete via the `CompletableFuture.allOf()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: The `String` returned by this method (for instance, from a REST controller)
    represents a piece of HTML produced by jOOQ via the `formatHTML()` method. Curious
    about what this HTML looks like? Then, simply run the *FetchAsync* application
    under MySQL and use the provided controller to fetch the data in a browser. You
    might also like to practice the *ExecuteAsync* (which is available for MySQL)
    application that uses the jOOQ `executeAsync()` method as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder mentions that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Perhaps worth mentioning that there''s an ExecutorProvider SPI that allows
    for routing these async executions elsewhere when the default ForkJoinPool is
    not the correct place? jOOQ''s own CompletionStage implementations also make sure
    that everything is always executed on the Executor provided by ExecutorProvider,
    unlike the JDK APIs, which always defaults back to the ForkJoinPool again (unless
    that has changed, recently)."*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's tackle reactive fetching.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive fetching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive fetching refers to the use of a reactive API in combination with jOOQ.
    Since you are using Spring Boot, there is a big chance that you are already familiar
    with the Project Reactor reactive library ([https://projectreactor.io/](https://projectreactor.io/))
    or the `Mono` and `Flux` APIs. So, without going into further detail, let''s take
    an example of combining `Flux` and jOOQ in a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: So, jOOQ is responsible for fetching some data from `EMPLOYEE`, and `Flux` is
    responsible for publishing the fetched data. You can practice this example in
    *SimpleReactive* (which is available for MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'What about a more complex example? One of the important architectures that
    can be applied to mitigate data loss in a streaming pipeline is **Hybrid Message
    Logging** (**HML**). Imagine a streaming pipeline for meetup RSVPs. In order to
    ensure that we don''t lose any RSVPs, we can rely on **Receiver-Based Message
    Logging** (**RBML**) to write every received RSVP to stable storage (for instance,
    PostgreSQL) before any action is performed on it. Moreover, we can rely on **Sender-Based
    Message Logging** (**SBML**) to write each RSVP in the stable storage right before
    we send it further on in the pipeline (for example, to a message queuing). This
    is the RSVP that was processed by the application business logic, so it might
    not the same as the received RSVP. The following diagram represents data flowing
    through an HML implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Data flow through HML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_8.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – Data flow through HML
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding diagram, we can implement the processing and recovery
    of data asynchronously. For instance, the RBML part can be expressed in jOOQ as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the SBML part can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: What about deleting or updating an RSVP? For the complete code, check out the
    *HML* application, which is available for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a big chapter that covered one of the most powerful capabilities of
    jOOQ, fetching and mapping data. As you learned, jOOQ supports a wide range of
    approaches for fetching and mapping data, from simple fetching to record mappers,
    to the fancy SQL/JSON and SQL/XML, to the marvelous and glorious MULTISET support,
    and finally, to lazy, asynchronous, and reactive fetching. In the next chapter,
    we will talk about how to batch and bulk data.
  prefs: []
  type: TYPE_NORMAL
