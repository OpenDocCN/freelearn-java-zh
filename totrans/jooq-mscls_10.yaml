- en: '*Chapter 8*: Fetching and Mapping'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：获取和映射'
- en: 'Fetching result sets and mapping them in the shape and format expected by the
    client is one of the most important tasks of querying a database. jOOQ excels
    in this area and provides a comprehensive API for fetching data and mapping it
    to scalars, arrays, lists, sets, maps, POJO, Java 16 records, JSON, XML, nested
    collections, and more. As usual, the jOOQ API hides the friction and challenges
    raised by different database dialects along with the boilerplate code necessary
    to map the result set to different data structures. In this context, our agenda
    covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 获取结果集并将它们映射成客户端期望的形状和格式是查询数据库时最重要的任务之一。jOOQ在这一领域表现出色，并提供了一个全面的API来获取数据并将其映射到标量、数组、列表、集合、映射、POJO、Java
    16记录、JSON、XML、嵌套集合等。像往常一样，jOOQ API隐藏了由不同的数据库方言引起的摩擦和挑战，以及将结果集映射到不同数据结构所需的样板代码。在此背景下，我们的议程包括以下主题：
- en: Simple fetching/mapping
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单获取/映射
- en: Fetching one record, a single record, or any record
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个记录、单个记录或任何记录
- en: Fetching arrays, lists, sets, and maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数组、列表、集合和映射
- en: Fetching groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取组
- en: Fetching via JDBC `ResultSet`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JDBC `ResultSet`获取
- en: Fetching multiple result sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取多个结果集
- en: Fetching relationships
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关系
- en: Hooking POJOs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将POJO连接起来
- en: jOOQ record mapper
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ记录映射器
- en: The mighty SQL/JSON and SQL/XML support
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的SQL/JSON和SQL/XML支持
- en: Nested collections via the astonishing `MULTISET`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过惊人的`MULTISET`进行嵌套集合
- en: Lazy fetching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载获取
- en: Asynchronous fetching
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步获取
- en: Reactive fetching
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式获取
- en: Let's get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter08)。
- en: Simple fetching/mapping
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单获取/映射
- en: By *simple* fetching/mapping, we refer to the jOOQ fetching techniques that
    you learned earlier in this book (for instance, the ubiquitous `into()` methods)
    but also to the new jOOQ utility, `org.jooq.Records`. This utility is available
    from jOOQ 3.15 onward, and it contains two types of utility methods, as we will
    discuss next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*简单*的获取/映射，我们指的是你在本书中较早前学到的jOOQ获取技术（例如无处不在的`into()`方法），同时也指新的jOOQ实用工具`org.jooq.Records`。这个实用工具从jOOQ
    3.15版本开始可用，并包含两种类型的实用方法，正如我们接下来将要讨论的。
- en: Collector methods
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集器方法
- en: 'The collector methods are named `intoFoo()`, and their goal is to create a
    collector (`java.util.stream.Collector`) for collecting records (`org.jooq.Record[N]`)
    into arrays, lists, maps, groups, and more. These collectors can be used in `ResultQuery.collect()`
    as any other collector. `ResultQuery<R>` implements `Iterable<R>` and comes with
    convenience methods such as `collect()` on top of it. Besides the fact that `collect()`
    handles resources internally (there is no need to use try-with-resources), you
    can use it for any collectors such as standard JDK collectors, jOOλ collectors,
    `Records` collectors, or your own collectors. For instance, here is an example
    of collecting into `List<String>`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 收集器方法被命名为`intoFoo()`，其目标是创建一个收集器（`java.util.stream.Collector`），用于将记录（`org.jooq.Record[N]`）收集到数组、列表、映射、组等中。这些收集器可以在`ResultQuery.collect()`中使用，就像任何其他收集器一样。`ResultQuery<R>`实现了`Iterable<R>`，并提供了如`collect()`等便利方法。除了`collect()`内部处理资源（无需使用try-with-resources）的事实之外，你还可以使用它进行任何收集器，如标准JDK收集器、jOOλ收集器、`Records`收集器或你自己的收集器。例如，以下是将数据收集到`List<String>`的示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And, here is an example of collecting into `Map<Long, String>`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将数据收集到`Map<Long, String>`的示例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that, while the ubiquitous `into()` methods use reflection, these utilities
    are a pure declarative mapping of jOOQ results/records without using reflection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然无处不在的`into()`方法使用反射，但这些实用工具是纯声明式映射jOOQ结果/记录，而不使用反射。
- en: Mapping methods
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射方法
- en: 'The mapping methods are actually multiple flavors of the mapping (`Function[N]`)
    method. A mapping method creates a `RecordMapper` parameter that can map from
    `Record[N]` to another type (for instance, POJO and Java 16 records) in a type-safe
    way. For instance, you can map to a Java record as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 映射方法实际上是映射（`Function[N]`）方法的多种风味。映射方法创建一个`RecordMapper`参数，可以以类型安全的方式将`Record[N]`映射到另一种类型（例如POJO和Java
    16记录）。例如，你可以按如下方式映射到Java记录：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When mapping nested rows (for instance, `LEFT JOIN`) you can achieve `null`
    safety by combining `mapping()` with `Functions.nullOnAllNull(Function1)` or `Functions.nullOnAnyNull(Function1)`.
    Here is an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射嵌套行（例如，`LEFT JOIN`）时，你可以通过将`mapping()`与`Functions.nullOnAllNull(Function1)`或`Functions.nullOnAnyNull(Function1)`结合使用来实现`null`安全性。以下是一个示例：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, how does this work? For instance, when an employee has no sale (or you have
    an orphan sale), you'll obtain a `null` value instead of an instance of `SalarySale`
    having the sale as `null`, `SalarySale[salary=120000, sale=null]`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？例如，当一个员工没有销售（或者你有一个孤儿销售）时，你会得到一个`null`值，而不是一个`SalarySale`实例，其中销售为`null`，`SalarySale[salary=120000,
    sale=null]`。
- en: Many more examples are available for MySQL/PostgreSQL in the bundle code, *Records*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑代码的*Records*中，还有许多MySQL/PostgreSQL的示例。
- en: Simple fetching/mapping continues
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的获取/映射继续
- en: 'Next, let''s see other techniques of fetching/mapping data that can be used
    quite intuitively and effortlessly. Since the jOOQ manual is filled to the brim
    with examples, let''s try to niche several things in this section. For instance,
    a simple fetch can be done via `DSLContext.resultQuery()` and plain SQL, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看其他一些可以非常直观和轻松使用的获取/映射数据的技术。由于jOOQ手册充满了示例，让我们在本节中尝试突出一些内容。例如，简单的获取可以通过`DSLContext.resultQuery()`和纯SQL完成，如下所示：
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another approach might rely on `DSLContext.fetch()` and plain SQL, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能依赖于`DSLContext.fetch()`和纯SQL，如下所示：
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, the idea is quite simple. Whenever you have to execute a plain SQL that
    you can't (or don't want to) express via a jOOQ-generated Java-based schema, then
    simply rely on `ResultQuery.collect(collector)` or the `resultQuery() … fetch()`/`fetchInto()`
    combination. Alternatively, simply pass it to the `fetch()` method and call the
    proper `into()` method or the `intoFoo()` method to map the result set to the
    necessary data structure. There are plenty of such methods that can map a result
    set to scalars, arrays, lists, sets, maps, POJO, XML, and more.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个想法非常简单。每次你需要执行一个无法（或不想）通过jOOQ生成的基于Java的架构表达的纯SQL时，只需简单地依靠`ResultQuery.collect(collector)`或`resultQuery()
    ... fetch()`/`fetchInto()`组合。或者，简单地将其传递给`fetch()`方法，并调用适当的`into()`方法或`intoFoo()`方法，将结果集映射到必要的数据结构。有大量这样的方法可以将结果集映射到标量、数组、列表、集合、映射、POJO、XML等等。
- en: 'On the other hand, using the Java-based schema (which is, of course, the recommended
    way to go) leads to the following less popular but handy query:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用基于Java的架构（当然，这是推荐的方式）会导致以下不太受欢迎但实用的查询：
- en: '[PRE34]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a shortcut for fetching a single field and obtaining the mapped result
    (values) without explicitly calling an `into()` method or an `intoFoo()` method.
    Essentially, jOOQ automatically maps the fetched field to the Java type associated
    with it when the Java-based schema was generated by the jOOQ generator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取单个字段并获取映射结果（值）的快捷方式，而不需要显式调用`into()`方法或`intoFoo()`方法。本质上，当基于Java的架构由jOOQ生成器生成时，jOOQ会自动将获取的字段映射到与之关联的Java类型。
- en: 'Whenever you need to fetch a single value, you can rely on `fetchValue()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你需要获取单个值时，你可以依靠`fetchValue()`：
- en: '[PRE35]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `<T> T fetchValue(Field<T> field)` and `<T> List<T> fetchValues(TableField<?,T>
    tf)` methods are just two of the many flavors of methods that are available. Check
    out the jOOQ documentation to see the rest of them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T> T fetchValue(Field<T> field)`和`<T> List<T> fetchValues(TableField<?,T>
    tf)`方法只是众多可用方法中的一种。查看jOOQ文档以了解其余的方法。'
- en: 'However, since you have made it this far in this book, I''m sure that you think
    of this query as a shortcut for the following four, more popular, approaches:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，既然你已经阅读到这本书的这一部分，我敢肯定你认为这个查询是以下四种更受欢迎的方法的快捷方式：
- en: '[PRE36]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And you are right, as long as you don''t also think of the following, too:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的，只要你也不考虑以下内容：
- en: '[PRE45]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'All six of these queries project the same result, but they are not the same.
    As a jOOQ novice, it is understandable that you might a bad choice and go for
    the last two queries. Therefore, let''s clarify this concern by looking at the
    generated SQLs. The first four queries produce the following SQL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个查询都投影了相同的结果，但它们并不相同。作为一个jOOQ新手，你可能会做出错误的选择，选择最后两个查询。因此，让我们通过查看生成的SQL来澄清这个疑虑。前四个查询生成以下SQL：
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In contrast, the last two queries produce the following SQL:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，最后两个查询生成以下SQL：
- en: '[PRE51]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, it is obvious that the last two queries perform unnecessary work. We only
    need the `CUSTOMER_NAME` field, but these queries will fetch all fields, and this
    is pointless work that negatively impacts performance. In such cases, don't blame
    jOOQ or the database because both of them did exactly what you asked!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显，最后两个查询执行了不必要的操作。我们只需要`CUSTOMER_NAME`字段，但这些查询会检索所有字段，这是毫无意义的工作，会负面影响性能。在这种情况下，不要责怪jOOQ或数据库，因为它们都正好做了你要求的事情！
- en: Important Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a rule of thumb, when you don't need to fetch all fields, rely on the first
    four approaches from earlier and enlist the necessary fields in the `SELECT` statement.
    In this context, allow me to reiterate the *SelectOnlyNeededData* application
    from [*Chapter 5*](B16833_05.xhtml#_idTextAnchor076), *Tackling Different Kinds
    of SELECT, INSERT, UPDATE, DELETE, and MERGE Statements*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，当你不需要检索所有字段时，依赖于前面提到的四种方法，并在`SELECT`语句中列出必要的字段。在这个背景下，让我再次强调[*第5章*](B16833_05.xhtml#_idTextAnchor076)中的*SelectOnlyNeededData*应用程序，*处理不同类型的SELECT、INSERT、UPDATE、DELETE和MERGE语句*。
- en: 'When you fetch more than one field, but not all fields, you should write something
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检索多个字段，但不是所有字段时，您应该编写如下代码：
- en: '[PRE56]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s consider another simple fetching method based on the following
    two POJOs:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个基于以下两个POJOs的简单检索方法：
- en: '[PRE64]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Populating these POJOs can be done via two `SELECT` statements, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个`SELECT`语句填充这些POJOs，如下所示：
- en: '[PRE66]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'However, here, jOOQ allows us to map `Result<Record>` into multiple results.
    In other words, we can obtain the same result and trigger a single `SELECT` statement,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里，jOOQ允许我们将`Result<Record>`映射到多个结果。换句话说，我们可以获得相同的结果并触发单个`SELECT`语句，如下所示：
- en: '[PRE72]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Nice! Of course, this doesn't only apply when mapping result sets to POJOs.
    In the code bundle of this book, *SimpleFetch* (which is available for MySQL),
    you can see a result set produced by a single `SELECT` statement formatted entirely
    as JSON, while a part of it is mapped to a Java `Set`. Next, let's dive into the
    `fetchOne()`, `fetchSingle()`, and `fetchAny()` methods.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！当然，这不仅仅适用于将结果集映射到POJOs的情况。在这本书的代码包中，*SimpleFetch*（适用于MySQL），您可以看到一个由单个`SELECT`语句生成的结果集，格式完全为JSON，其中一部分映射到Java
    `Set`。接下来，让我们深入了解`fetchOne()`、`fetchSingle()`和`fetchAny()`方法。
- en: Fetching one record, a single record, or any record
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索一个记录、单个记录或任何记录
- en: jOOQ has come with three handy methods named `fetchOne()`, `fetchSingle()`,
    and `fetchAny()`. All three are capable of returning a resulting record, but each
    of them will do this under certain coordinates. So, let's go through each method
    in detail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ提供了三个方便的方法，名为`fetchOne()`、`fetchSingle()`和`fetchAny()`。这三个方法都能返回一个结果记录，但每个方法都会在特定的坐标下执行此操作。所以，让我们详细地了解每个方法。
- en: Using fetchOne()
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fetchOne()
- en: 'For instance, the `fetchOne()` method returns, at most, one resulting record.
    In other words, if the fetched result set has more than one record, then `fetchOne()`
    throws a jOOQ-specific `TooManyRowsException` exception. But if the result set
    has no records, then `fetchOne()` returns `null`. In this context, `fetchOne()`
    can be useful for fetching a record by a primary key, other unique keys, or a
    predicate that guarantees uniqueness, while you prepare to handle potentially
    `null` results. Here is an example of using `fetchOne()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`fetchOne()`方法最多返回一个结果记录。换句话说，如果检索到的结果集有多条记录，则`fetchOne()`会抛出jOOQ特定的`TooManyRowsException`异常。但如果结果集没有记录，则`fetchOne()`返回`null`。在这种情况下，`fetchOne()`可以用于通过主键、其他唯一键或保证唯一性的谓词检索记录，同时您准备处理可能为`null`的结果。以下是一个使用`fetchOne()`的示例：
- en: '[PRE78]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Alternatively, you can fetch directly into the `Employee` POJO via `fetchOneInto()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过`fetchOneInto()`直接将数据检索到`Employee` POJO中：
- en: '[PRE81]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, pay attention. Remember that `fetchOneInto(Employee.class)` is not
    the same thing as `fetchOne().into(Employee.class)` since the latter is prone
    to throw `NullPointerException` exceptions. So, it is better to avoid writing
    something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意。记住`fetchOneInto(Employee.class)`与`fetchOne().into(Employee.class)`并不相同，因为后者容易抛出`NullPointerException`异常。因此，最好避免编写如下代码：
- en: '[PRE84]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If there is no `EMPLOYEE` POJO with a primary key of *1370*, then this code
    throws an NPE exception.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有具有主键*1370*的`EMPLOYEE` POJO，则此代码会抛出NPE异常。
- en: 'Also, avoid chaining the `component`[`N`]`()` and `value`[`N`]`()` methods,
    as follows (this code is also prone to throw `NullPointerException`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，避免链式调用`component`[`N`]`()`和`value`[`N`]`()`方法，如下所示（此代码也容易抛出`NullPointerException`）：
- en: '[PRE87]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Also, prefer fetching into a proper type (here, it is `String`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，建议将数据检索到适当的数据类型中（在这里，它是`String`类型）：
- en: '[PRE90]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Of course, an NPE check is still needed before using `result`, but you can
    wrap this check via `Objects.requireNonNullElseGet()`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在使用`result`之前，仍然需要进行NPE检查，但你可以通过`Objects.requireNonNullElseGet()`来包装这个检查，如下所示：
- en: '[PRE93]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Alternatively, simply wrap it into an `Optional` type via the jOOQ''s `fetchOptional()`
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过jOOQ的`fetchOptional()`方法将其包装成`Optional`类型：
- en: '[PRE97]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Alternatively, you may prefer `fetchOptionalInto()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能更喜欢`fetchOptionalInto()`：
- en: '[PRE100]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As usual, `fetchOne()` comes in many flavors, all of which are available in
    the documentation. For instance, you can use `DSLContext.fetchOne()`as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，`fetchOne()`有多种形式，所有这些都在文档中提供。例如，你可以使用`DSLContext.fetchOne()`如下所示：
- en: '[PRE103]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Or you can fetch a record and convert it based on a user-defined converter
    (this converter was introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110),
    *Types, Converters, and Bindings*):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以根据用户定义的转换器检索记录并进行转换（此转换器在[*第7章*](B16833_07.xhtml#_idTextAnchor110)，*类型、转换器和绑定*）中介绍）：
- en: '[PRE105]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Many other examples are available in the bundled code for MySQL, *FetchOneAnySingle*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL捆绑代码中的*FetchOneAnySingle*提供了许多其他示例。
- en: Using fetchSingle()
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`fetchSingle()`
- en: The `fetchSingle()` method returns exactly one resulting record. In other words,
    if the fetched result set contains more than one record, then `fetchSingle()`
    throws the jOOQ-specific `TooManyRowsException` error. And if it doesn't contain
    any records, then it throws the jOOQ-specific `NoDataFoundException` error.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchSingle()`方法返回确切的一个结果记录。换句话说，如果检索到的结果集包含多个记录，则`fetchSingle()`会抛出jOOQ特定的`TooManyRowsException`错误。如果没有记录，则抛出jOOQ特定的`NoDataFoundException`错误。'
- en: 'Essentially, `fetchSingle()` is similar to `fetchOne()`, except that it throws
    an exception instead of returning `null` when the fetched result set doesn''t
    contain any records. This means that `fetchSingle()` is useful for fetching a
    record by a primary key, other unique keys, or a predicate that guarantees uniqueness
    when you are not expecting `null` results. For example, see the following code
    block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`fetchSingle()`与`fetchOne()`类似，只是在检索到的结果集不包含任何记录时抛出异常而不是返回`null`。这意味着`fetchSingle()`在你不期望`null`结果时，用于通过主键、其他唯一键或保证唯一性的谓词检索记录是有用的。例如，请参阅以下代码块：
- en: '[PRE110]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Or you might only fetch the email of this employee, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能只想检索这个员工的电子邮件，如下所示：
- en: '[PRE113]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Many other examples are available in the bundled code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑代码中还提供了许多其他示例。
- en: Using fetchAny()
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`fetchAny()`
- en: 'The `fetchAny()` method returns the first resulting record. In other words,
    if the fetched result set contains more than one record, then `fetchAny()` returns
    the first one. And, if it doesn''t contain any records, then it returns `null`.
    This is similar to `…limit(1).fetchOne();`. So, pay attention to avoid any usages
    that are prone to throw a `NullPointerException` exception. Here''s an example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchAny()`方法返回第一个结果记录。换句话说，如果检索到的结果集包含多个记录，则`fetchAny()`返回第一个。如果没有记录，则返回`null`。这与`…limit(1).fetchOne();`类似。因此，请注意避免任何可能导致抛出`NullPointerException`异常的使用。以下是一个示例：'
- en: '[PRE116]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let''s see another example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例：
- en: '[PRE119]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Many other examples are available for MySQL in *FetchOneAnySingle*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*FetchOneAnySingle*中，MySQL提供了许多其他示例。
- en: Fetching arrays, lists, sets, and maps
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索数组、列表、集合和映射
- en: jOOQ reduces the code that is needed for fetching `Result<Record>` as an array,
    list, set, or map down to a simple call of its amazing API.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ将检索`Result<Record>`作为数组、列表、集合或映射所需的代码简化为对其惊人的API的简单调用。
- en: Fetching arrays
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索数组
- en: 'Fetching arrays can be done via a comprehensive set of jOOQ methods, including
    `fetchArray()` (along with its flavors), `fetchOneArray()`, `fetchSingleArray()`,
    `fetchAnyArray()`, `fetchArrays()`, and `intoArray()`. For instance, fetching
    all the `DEPARTMENT` fields as an array of `Record` can be done as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一组全面的jOOQ方法可以检索数组，包括`fetchArray()`（及其变体）、`fetchOneArray()`、`fetchSingleArray()`、`fetchAnyArray()`、`fetchArrays()`和`intoArray()`。例如，将所有`DEPARTMENT`字段作为一个`Record`数组检索可以如下进行：
- en: '[PRE122]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In comparison, you can just fetch `DEPARTMENT.NAME` as a `String[]` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，你可以直接将`DEPARTMENT.NAME`作为一个`String[]`来检索，如下所示：
- en: '[PRE123]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Alternatively, fetching all `CUSTOMER.FIRST_BUY_DATE` fields as an array of
    the `YearMonth` type can be done via `fetchArray(Field<T> field, Converter<? super
    T,? extends U> cnvrtr)`, as follows (note that the `INTEGER_YEARMONTH_CONVERTER`
    converter was introduced in [*Chapter 7*](B16833_07.xhtml#_idTextAnchor110), *Types,
    Converters, and Bindings*):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过 `fetchArray(Field<T> field, Converter<? super T,? extends U> cnvrtr)`
    方法将所有 `CUSTOMER.FIRST_BUY_DATE` 字段作为 `YearMonth` 类型的数组检索，如下所示（注意，`INTEGER_YEARMONTH_CONVERTER`
    转换器是在 [*第 7 章*](B16833_07.xhtml#_idTextAnchor110)，*类型、转换器和绑定*）中引入的）：
- en: '[PRE127]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'What do you think about fetching a database array into a Java array, such as
    the `DEPARTMENT.TOPIC` field that was defined in our PostgreSQL schema? Well,
    the result, in this case, is `String[][]`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为将数据库数组检索到 Java 数组中会怎样，比如我们 PostgreSQL 架构中定义的 `DEPARTMENT.TOPIC` 字段？在这种情况下，结果是
    `String[][]`：
- en: '[PRE131]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'If we return this `String[][]` from a Spring Boot REST controller, the result
    will be a JSON array:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Spring Boot REST 控制器返回这个 `String[][]`，结果将是一个 JSON 数组：
- en: '[PRE133]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'What about fetching a UDT type into a Java array? In our PostgreSQL schema,
    we have the `MANAGER.MANAGER_EVALUATION` UDT type, so let''s give it a try and
    fetch it as an array next to the `MANAGER_NAME` type:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么将一个 UDT 类型检索到 Java 数组中会怎样呢？在我们的 PostgreSQL 架构中，我们有一个 `MANAGER.MANAGER_EVALUATION`
    UDT 类型，所以让我们试一试，将它作为数组与 `MANAGER_NAME` 类型一起检索：
- en: '[PRE138]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s print out the first manager name and their evaluation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出第一个经理的姓名及其评估：
- en: '[PRE142]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Here is the output (the `format()` method formats `EvaluationCriteriaRecord`
    as a tabular text):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出（`format()` 方法将 `EvaluationCriteriaRecord` 格式化为表格文本）：
- en: '![Figure 8.1– Printing the first manager and their evaluation'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1– 打印第一个经理及其评估'
- en: '](img/B16833_Figure_8.1.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_8.1.jpg)'
- en: Figure 8.1– Printing the first manager and their evaluation
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1– 打印第一个经理及其评估
- en: 'Finally, let''s try fetching an embeddable type as an array, too:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试将一个可嵌入的类型作为数组检索：
- en: '[PRE144]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The last example from this section relies on `fetchArrays()`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一个示例依赖于 `fetchArrays()`：
- en: '[PRE150]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'If we return this `Object[][]` from a Spring Boot REST controller, then the
    result will be a JSON array of arrays:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Spring Boot REST 控制器返回这个 `Object[][]`，那么结果将是一个 JSON 数组：
- en: '[PRE153]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In the bundled code, you can find over 15 examples of fetching jOOQ results
    as arrays.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到超过 15 个将 jOOQ 结果作为数组检索的示例。
- en: Fetching lists and sets
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索列表和集合
- en: 'So far, most examples fetch the result set in `java.util.List` or `org.jooq.Result`
    (that is, the jOOQ wrappers of `List`), so there is no mystery regarding how the
    following examples work:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数示例都是将结果集检索为 `java.util.List` 或 `org.jooq.Result`（即 `List` 的 jOOQ 包装器），所以关于以下示例如何工作并没有什么神秘之处：
- en: '[PRE159]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'So, let''s focus on more interesting cases, such as how to fetch the `DEPARTMENT.TOPIC`
    array field defined in our PostgreSQL schema:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们关注一些更有趣的案例，比如如何检索我们 PostgreSQL 架构中定义的 `DEPARTMENT.TOPIC` 数组字段：
- en: '[PRE166]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Instead of calling `fetch()`, which will return `Result<Record1<String[]>>`,
    we prefer to call `fetch(Field<?> field, Class<? extends U> type)`. This allow
    us to return a `List<String[]>`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于调用 `fetch()`，它将返回 `Result<Record1<String[]>>`，而不是调用 `fetch(Field<?> field,
    Class<? extends U> type)`。这允许我们返回 `List<String[]>`。
- en: 'Trying to fetch `DEPARTMENT.TOPIC` as a `Set<String[]>` can be done via the
    jOOQ `fetchSet()` method (check out the documentation to see all the flavors of
    this method):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 `DEPARTMENT.TOPIC` 作为 `Set<String[]>` 检索可以通过 jOOQ 的 `fetchSet()` 方法完成（查看文档以了解此方法的全部功能）：
- en: '[PRE169]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Consider the bundled code, which contains more examples of fetching lists and
    sets, including fetching UDT and embeddable types.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑捆绑的代码，其中包含更多检索列表和集合的示例，包括检索 UDT 和可嵌入类型。
- en: Fetching maps
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索映射
- en: jOOQ comes with a set of `fetchMap()`/`intoMap()` methods that allow us to split
    a result set into key-value pairs of a `java.util.Map` wrapper. There are more
    than 20 such methods, but we can primarily distinguish between the `fetchMap(key)`/`intoMap(Function
    keyMapper)` methods. These methods allow us to specify the field(s) representing
    the key, while the value is inferred from the `SELECT` result, and the `fetchMap(key,
    value)`/`intoMap(Function keyMapper, Function valueMapper)` methods in which we
    specify the field(s) that represents the key and the value, respectively. The
    `Records.intoMap()` method without any arguments is only useful if you have a
    two-column `ResultQuery` and you want to map the first column as a key and the
    second column as a value.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了一套 `fetchMap()`/`intoMap()` 方法，允许我们将结果集拆分为 `java.util.Map` 包装器的键值对。这类方法超过
    20 种，但我们主要可以区分 `fetchMap(key)`/`intoMap(Function keyMapper)` 方法。这些方法允许我们指定代表键的字段，而值则从
    `SELECT` 结果中推断出来，以及 `fetchMap(key, value)`/`intoMap(Function keyMapper, Function
    valueMapper)` 方法，其中我们分别指定代表键和值的字段。不带任何参数的 `Records.intoMap()` 方法仅在你有一个两列的 `ResultQuery`，并且你想将第一列作为键、第二列作为值进行映射时才有用。
- en: 'For instance, let''s fetch a `Map` that has `DEPARTMENT_ID` as the key (so,
    the `DEPARTMENT` primary key) and `DepartmentRecord` as the value:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取一个以 `DEPARTMENT_ID` 作为键（因此是 `DEPARTMENT` 主键）和 `DepartmentRecord` 作为值的
    `Map`：
- en: '[PRE171]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Alternatively, let''s instruct jOOQ that the map value should be a `Department`
    POJO (generated by jOOQ) instead of `DepartmentRecord`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们指示 jOOQ 将映射值指定为 `Department` POJO（由 jOOQ 生成）而不是 `DepartmentRecord`：
- en: '[PRE177]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Do you think this is impressive? How about mapping a one-to-one relationship
    between the `CUSTOMER` and `CUSTOMERDETAIL` tables? Here is the magical code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这很令人印象深刻吗？那么，如何映射 `CUSTOMER` 表和 `CUSTOMERDETAIL` 表之间的一对一关系？以下是神奇的代码：
- en: '[PRE179]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: In order to obtain a correct mapping, you have to provide explicit `equals()`
    and `hashCode()` methods for the involved POJOs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得正确的映射，你必须为涉及的 POJO 提供显式的 `equals()` 和 `hashCode()` 方法。
- en: 'Simply returning this `Map` from a REST controller will result in the following
    JSON code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从 REST 控制器返回这个 `Map` 将导致以下 JSON 代码：
- en: '[PRE185]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Alterantively, you might want to fetch this one-to-one relationship by only
    using a subset of fields:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能只想使用字段子集来获取这个一对一关系：
- en: '[PRE194]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In the bundled code, *ArrListMap* (which is available for PostgreSQL), you can
    see more examples, including mapping a flattened one-to-many relationship, mapping
    arrays, UDTs and embeddable types, and using `fetchMaps()`, `fetchSingleMap()`,
    `fetchOneMap()`, and `fetchAnyMap()`. Next, let's talk about fetching groups.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，*ArrListMap*（适用于 PostgreSQL）可以查看更多示例，包括映射扁平化的多对一关系、映射数组、UDTs 和可嵌入类型，以及使用
    `fetchMaps()`、`fetchSingleMap()`、`fetchOneMap()` 和 `fetchAnyMap()`。接下来，让我们谈谈获取组。
- en: Fetching groups
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取组
- en: The jOOQ fetching groups feature is similar to fetching maps, except that it
    allows us to fetch a list of records as the value of each key-value pair. There
    are over 40 flavors of the `fetchGroups()`, `intoGroups()`, and `intoResultGroup()`
    methods; therefore, take your time to practice (or, at the very least, read about)
    each of them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 的获取组功能与获取映射类似，但它允许我们将记录列表作为每个键值对的值。`fetchGroups()`、`intoGroups()` 和 `intoResultGroup()`
    方法有超过 40 种变体；因此，请花时间练习（或者至少阅读关于）它们中的每一个。
- en: We can distinguish between the `fetchGroups(key)` and `intoGroups(Function keyMapper)`
    methods that allow us to specify the field(s) representing the key, while the
    value is inferred from the `SELECT` result as the `Result<Record>`/`List<Record>`
    and `fetchGroups(key, value)`/`intoGroups(Function keyMapper, Function valueMapper)`
    methods in which we specify the field(s) that represents the key and the value,
    respectively, which could be `Result<Record>`, `List<POJO>`, `List<scalar>`, and
    more. The `Records.intoGroups()` method without any arguments is only useful if
    you have a two-column `ResultQuery`, and you want to map the first column as a
    key and the second column as a value. Additionally, the `intoResultGroup()` method
    returns a collector that collects a jOOQ `Record`, which results from a `ResultQuery`
    in a `Map` using the result of the `RecordMapper` parameter as a key to collect
    the records themselves into a jOOQ `Result`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分 `fetchGroups(key)` 和 `intoGroups(Function keyMapper)` 方法，允许我们指定表示键的字段，而值从
    `SELECT` 结果推断为 `Result<Record>`/`List<Record>`，以及 `fetchGroups(key, value)`/`intoGroups(Function
    keyMapper, Function valueMapper)` 方法，在这些方法中我们指定表示键和值的字段，这些字段可以是 `Result<Record>`、`List<POJO>`、`List<scalar>`
    等。没有参数的 `Records.intoGroups()` 方法仅在你有一个两列的 `ResultQuery`，并且你想将第一列映射为键，第二列映射为值时才有用。此外，`intoResultGroup()`
    方法返回一个收集器，它收集一个 jOOQ `Record`，该 `Record` 来自 `ResultQuery`，在 `Map` 中使用 `RecordMapper`
    参数的结果作为键来收集记录本身到一个 jOOQ `Result`。
- en: 'For instance, you can fetch all the `OrderRecord` values and group them by
    customer (`CUSTOMER_NUMBER`) as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以获取所有 `OrderRecord` 的值，并按客户（`CUSTOMER_NUMBER`）进行分组，如下所示：
- en: '[PRE205]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Or you can group all bank transfers (`BANK_TRANSACTION.TRANSFER_AMOUNT`) by
    customer (`BANK_TRANSACTION.CUSTOMER_NUMBER`) into `Map<Long, List<BigDecimal>>`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以按客户（`BANK_TRANSACTION.CUSTOMER_NUMBER`）将所有银行转账（`BANK_TRANSACTION.TRANSFER_AMOUNT`）分组到
    `Map<Long, List<BigDecimal>>` 中：
- en: '[PRE209]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'You can group them into `Map<Long, List<Record2<Long, BigDecimal>>>` or `Map<Long,
    Result<Record2<Long, BigDecimal>>>`, respectively:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们分组到 `Map<Long, List<Record2<Long, BigDecimal>>>` 或 `Map<Long, Result<Record2<Long,
    BigDecimal>>>` 中，分别：
- en: '[PRE224]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'As you''ve probably intuited already, `fetchGroups()` is very handy for fetching
    and mapping one-to-many relationships. For instance, each product line (`PRODUCTLINE`)
    has multiple products (`PRODUCT`), and we can fetch this data as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经直觉到的，`fetchGroups()` 对于获取和映射一对多关系非常有用。例如，每个产品线（`PRODUCTLINE`）有多个产品（`PRODUCT`），我们可以如下获取这些数据：
- en: '[PRE236]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Returning this map from a REST controller results in the following JSON:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 从 REST 控制器返回此映射将产生以下 JSON：
- en: '[PRE241]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Of course, relying on user-defined POJOs/Java records is also possible. For
    instance, let''s say you just need the code and name of each product line, along
    with the product ID and buy price of each product. Having the proper POJOs named
    `SimpleProductline` and `SimpleProduct`, we can map the following one-to-many
    relationship:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，依赖用户定义的 POJOs/Java 记录也是可能的。例如，假设你只需要每个产品线的代码和名称，以及每个产品的产品 ID 和购买价格。拥有名为 `SimpleProductline`
    和 `SimpleProduct` 的适当 POJO，我们可以映射以下一对多关系：
- en: '[PRE259]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'In order to obtain a correct mapping, you have to provide explicit `equals()`
    and `hashCode()` methods for the involved POJOs. For the jOOQ-generated POJO,
    this is a configuration step that can be accomplished via `<pojosEqualsAndHashCode/>`,
    as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得正确的映射，你必须为涉及的 POJO 提供显式的 `equals()` 和 `hashCode()` 方法。对于 jOOQ 生成的 POJO，这是一个可以通过
    `<pojosEqualsAndHashCode/>` 完成的配置步骤，如下所示：
- en: '[PRE266]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Notice that using `fetchGroups()` works as expected for `INNER JOIN`, but not
    for `LEFT JOIN`. If the fetched parent doesn''t have children, then instead of
    an empty list, you''ll get a list containing a single `NULL` item. So, if you
    want to use `LEFT JOIN` (at least until [https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888)
    is resolved), you can rely on the mighty `ResultQuery.collect()`collector, as
    follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `fetchGroups()` 对于 `INNER JOIN` 是按预期工作的，但对于 `LEFT JOIN` 则不是。如果获取的父项没有子项，那么你将得到一个包含单个
    `NULL` 项的列表。所以，如果你想使用 `LEFT JOIN`（至少直到 [https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888)
    被解决），你可以依赖强大的 `ResultQuery.collect()` 收集器，如下所示：
- en: '[PRE269]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: This time, a parent with no children produces an empty list.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，没有子项的父项将产生一个空列表。
- en: 'Fetching and mapping a many-to-many relationship is also possible. We can do
    it elegantly via `CROSS APPLY` (for additional details, check out [*Chapter 6*](B16833_06.xhtml#_idTextAnchor093),
    *Tackling Different Kinds of JOIN Statements*). For instance, we have a many-to-many
    relationship between `OFFICE` and `MANAGER` via the `OFFICE_HAS_MANAGER` junction
    table, and we can map it via `fetchGroups()`, as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和映射多对多关系也是可能的。我们可以通过 `CROSS APPLY`（有关更多详细信息，请参阅 [*第6章*](B16833_06.xhtml#_idTextAnchor093)，*处理不同类型的JOIN语句*）优雅地完成它。例如，我们通过
    `OFFICE_HAS_MANAGER` 连接表在 `OFFICE` 和 `MANAGER` 之间存在多对多关系，并且我们可以通过 `fetchGroups()`
    来映射它，如下所示：
- en: '[PRE283]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Passing this map through a REST controller produces the necessary JSON. Of course,
    mapping a one-to-many relationship with a junction table is quite obvious based
    on the previous examples.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 将此映射通过REST控制器产生必要的JSON。当然，根据之前的示例，使用连接表映射一对一关系是非常明显的。
- en: 'However, please consider Lukas Eder''s note:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请考虑Lukas Eder的注意事项：
- en: '*"When talking about* *fetchGroups(), I think it''s always worth pointing out
    that RDBMS can often do this natively as well, using ARRAY_AGG(), JSON_ARRAYAGG(),
    or XMLAGG(). Chances are (to be verified), that this may be faster, as less data
    has to be transferred over the wire."*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*"在谈论* *fetchGroups() 时，我认为总是值得指出，RDBMS通常也可以使用 ARRAY_AGG()、JSON_ARRAYAGG()
    或 XMLAGG() 本地执行此操作。可能性（需要验证）是，这可能会更快，因为需要通过网络传输的数据更少。"*'
- en: In the bundled code, you can practice many more examples of how to use `fetchGroups()`.
    The application is named *FetchGroups* (and is available for PostgreSQL).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑代码中，你可以练习更多关于如何使用 `fetchGroups()` 的示例。该应用程序名为 *FetchGroups*（适用于PostgreSQL）。
- en: Fetching via JDBC ResultSet
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过JDBC `ResultSet` 获取数据
- en: 'jOOQ is an extremely versatile and transparent tool. For instance, jOOQ acts
    as a wrapper for JDBC `ResultSet` but also allows us to access it directly and
    even provide support to do this smoothly and *painlessly*. Practically, we can
    do the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ是一个极其灵活且透明的工具。例如，jOOQ充当JDBC `ResultSet` 的包装器，但也允许我们直接访问它，甚至提供支持以平滑且无痛苦地完成此操作。实际上，我们可以做以下事情：
- en: Execute a `ResultQuery` with jOOQ, but return a JDBC `ResultSet` (this relies
    on the `fetchResultSet()` method).
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jOOQ执行 `ResultQuery`，但返回一个JDBC `ResultSet`（这依赖于 `fetchResultSet()` 方法）。
- en: Transform the jOOQ `Result` object into a JDBC `ResultSet` (this relies on the
    `intoResultSet()` method).
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将jOOQ `Result` 对象转换为JDBC `ResultSet`（这依赖于 `intoResultSet()` 方法）。
- en: Fetch data from a legacy `ResultSet` using jOOQ.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jOOQ从遗留 `ResultSet` 中获取数据。
- en: 'All three of these bullets are exemplified in the bundled code. However, here,
    let''s consider the second bullet that starts with the following jOOQ query:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个项目都在捆绑代码中得到了示例。然而，在这里，让我们考虑以下jOOQ查询开始的第二个项目：
- en: '[PRE290]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'We understand that the returned result is a jOOQ-specific `Result` that was
    built automatically from the underlying `ResultSet`. So, can we reverse this operation
    and obtain the `ResultSet` from the jOOQ `Result`? Yes, we can! We can do this
    via `intoResultSet()`, as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解返回的结果是一个由底层 `ResultSet` 自动构建的jOOQ特定 `Result`。那么，我们能否反转这个操作，从jOOQ `Result`
    中获取 `ResultSet`？是的，我们可以！我们可以通过 `intoResultSet()` 来做，如下所示：
- en: '[PRE293]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'The important thing to note is that this magic happens without an active connection
    to the database. By default, jOOQ closes the database connection after the jOOQ
    `Result` is fetched. This means that, when we call `intoResultSet()` to obtain
    this in-memory `ResultSet`, there is no active connection to the database. jOOQ
    mirrors the `Result` object back into a `ResultSet` without interacting with the
    database. Next, processing this `ResultSet` is straightforward:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这个魔法在没有数据库活动连接的情况下发生。默认情况下，jOOQ在获取jOOQ `Result` 后关闭数据库连接。这意味着，当我们调用
    `intoResultSet()` 来获取这个内存中的 `ResultSet` 时，没有数据库的活动连接。jOOQ将 `Result` 对象镜像回 `ResultSet`
    而不与数据库交互。接下来，处理这个 `ResultSet` 是直接的：
- en: '[PRE294]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: This matters because, typically, operating on a JDBC `ResultSet` can be done
    as long as you hold an open connection to your database. Check out the complete
    code next to the other two bullets in the bundled application named *ResultSetFetch*
    (which is available for MySQL).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为通常情况下，只要保持与数据库的开放连接，就可以在JDBC `ResultSet`上操作。查看名为 *ResultSetFetch* 的捆绑应用程序中其他两个项目旁边的完整代码（该应用程序适用于MySQL）。
- en: Fetching multiple result sets
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取多个结果集
- en: 'Some RDBMSs (for instance, SQL Server and MySQL after appending the `allowMultiQueries=true`
    property to the JDBC URL) can return multiple result sets. Here is such a jOOQ
    query for MySQL:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 RDBMS（例如，在 JDBC URL 后附加 `allowMultiQueries=true` 属性的 SQL Server 和 MySQL）可以返回多个结果集。以下是一个针对
    MySQL 的 jOOQ 查询：
- en: '[PRE297]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'To fetch multiple result sets in jOOQ, call `fetchMany()`. This method returns
    an object of the `org.jooq.Results` type, as shown in the following snippet (notice
    the pluralization to avoid any confusion with `org.jooq.Result`):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 jOOQ 中获取多个结果集，请调用 `fetchMany()`。此方法返回 `org.jooq.Results` 类型的对象，如下面的代码片段所示（注意复数形式以避免与
    `org.jooq.Result` 产生混淆）：
- en: '[PRE300]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'Next, you can map each result set to its POJO:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以将每个结果集映射到其 POJO：
- en: '[PRE304]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Lukas Eder says:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder 表示：
- en: '*"Perhaps out of scope, but the Results type also allows for accessing interleaved
    update counts and exceptions, which is something that is done frequently in T-SQL
    databases, like SQL Server or Sybase."*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*"也许超出了范围，但 Results 类型还允许访问交错更新的计数和异常，这在 T-SQL 数据库（如 SQL Server 或 Sybase）中经常这样做。"*'
- en: Done! In the *FetchMany* application (which is available for MySQL and SQL Server),
    you can check out this example next to another one that returns two result sets
    from a query that combines `DELETE` and `SELECT`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！在 *FetchMany* 应用程序（适用于 MySQL 和 SQL Server）中，你可以查看这个示例，它旁边还有一个示例，该示例从一个结合
    `DELETE` 和 `SELECT` 的查询中返回两个结果集。
- en: Fetching relationships
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取关系
- en: 'I''m pretty sure that you''re familiar with the one-to-one, one-to-many, and
    many-to-many relationships. An emblematic mapping of unidirectional one-to-many
    roughly looks like this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确信你已经熟悉一对一、一对多和多对多关系。单向一对多的典型映射大致如下：
- en: '[PRE306]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Moreover, when `SimpleProduct` contains a reference to `SimpleProductLine`,
    this is considered a bidirectional one-to-many relationship:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当 `SimpleProduct` 包含对 `SimpleProductLine` 的引用时，这被视为一个双向的一对多关系：
- en: '[PRE311]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: If we have this POJO model, can we map the corresponding result set to it via
    the jOOQ API? The answer is definitely yes, and this can be done in several ways.
    From the `fetchInto()`, `fetchMap()`, and `fetchGroups()` methods that you already
    saw to the record mappers, the mighty SQL JSON/XML mapping, and the astonishing
    MULTISET value constructor operator, jOOQ provides so many fetching modes that
    it is almost impossible to not find a solution.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这个 POJO 模型，能否通过 jOOQ API 将相应的结果集映射到它？答案是肯定的，并且可以通过几种方式完成。从你已看到的 `fetchInto()`、`fetchMap()`
    和 `fetchGroups()` 方法，到强大的 SQL JSON/XML 映射，以及惊人的 MULTISET 值构造器运算符，jOOQ 提供了如此多的获取模式，几乎不可能找不到解决方案。
- en: 'Anyway, let''s not deviate too much from the subject. Let''s consider the following
    query:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们不要偏离主题太远。让我们考虑以下查询：
- en: '[PRE315]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'With `Map<Record, Result<Record>>` (which, most of the time, is all you need),
    we can populate our bidirectional domain model, as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Map<Record, Result<Record>>`（这通常是所有你需要的东西），我们可以填充我们的双向领域模型，如下所示：
- en: '[PRE328]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'If you want to avoid passing through `fetchGroups()`, then you can rely on
    `ResultQuery.collect()` and `Collectors.groupingBy()`. This is especially useful
    if you want to run a `LEFT JOIN` statement since `fetchGroups()` has the following
    issue: [https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888).
    Another approach is to map from `ResultSet`. You can see these approaches along
    with other approaches for unidirectional/bidirectional one-to-one and many-to-many
    relationships in the bundled code in the *OneToOne*, *OneToMany*, and *ManyToMany*
    applications (which are available for MySQL).'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要避免通过 `fetchGroups()` 传递，那么你可以依赖 `ResultQuery.collect()` 和 `Collectors.groupingBy()`。这在你想运行
    `LEFT JOIN` 语句时特别有用，因为 `fetchGroups()` 有以下问题：[https://github.com/jOOQ/jOOQ/issues/11888](https://github.com/jOOQ/jOOQ/issues/11888)。另一种方法是来自
    `ResultSet` 的映射。你可以在 *OneToOne*、*OneToMany* 和 *ManyToMany* 应用程序（适用于 MySQL）捆绑的代码中看到这些方法以及其他用于单向/双向一对一和多对多关系的其他方法。
- en: Hooking POJOs
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接 POJO
- en: You already know that jOOQ can generate POJOs on our behalf and it can handle
    user-defined POJOs, too. Moreover, you saw a significant number of mappings of
    a jOOQ result into POJOs (typically, via `fetchInto()`); therefore, this is not
    a brand new topic for you. However, in this section, let's take a step further
    and really focus on different types of POJOs that are supported by jOOQ.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道 jOOQ 可以代表我们生成 POJO，它也可以处理用户定义的 POJO。此外，你看到了许多将 jOOQ 结果映射到 POJO 的示例（通常是通过
    `fetchInto()`）；因此，这不是一个全新的话题。然而，在本节中，让我们更进一步，真正关注 jOOQ 支持的不同类型的 POJO。
- en: 'If all we configure is `<pojos>true</pojos>` (here, Maven), then jOOQ generates
    POJOs with `private` fields, empty constructors, constructors with arguments,
    getters and setters, and `toString()`. However, jOOQ can also handle a very simple
    user-defined POJO such as this one:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们配置的是 `<pojos>true</pojos>`（此处为 Maven），那么 jOOQ 会生成具有 `private` 字段、空构造函数、带有参数的构造函数、getter
    和 setter 以及 `toString()` 的 POJO。然而，jOOQ 也可以处理一个非常简单的用户定义 POJO，如下所示：
- en: '[PRE340]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'Here is a query that populates this POJO:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个填充此 POJO 的查询：
- en: '[PRE344]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'Pay attention to the `as("customerPhone")` alias. This is needed to map `CUSTOMER.PHONE`
    to POJO''s `customerPhone` field; otherwise, this POJO field will be left `null`
    since jOOQ cannot find the proper match. Another approach is to add a constructor
    with arguments, as shown in the following POJO:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `as("customerPhone")` 别名。这是将 `CUSTOMER.PHONE` 映射到 POJO 的 `customerPhone`
    字段所必需的；否则，此 POJO 字段将保留为 `null`，因为 jOOQ 找不到合适的匹配项。另一种方法是添加一个带有参数的构造函数，如下面的 POJO
    所示：
- en: '[PRE347]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Even if none of the POJO''s field names match the names of the fetched fields,
    the POJO is correctly populated by jOOQ based on this constructor with arguments:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 POJO 的字段名称与获取的字段名称不匹配，jOOQ 也会根据此带有参数的构造函数正确填充 POJO：
- en: '[PRE359]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'User-defined POJOs are useful for mapping jOOQ results that contain fields
    from multiple tables. For example, a POJO can be used to flatten a one-to-many
    relationship, as shown here:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的 POJO 对于映射包含来自多个表的字段的 jOOQ 结果非常有用。例如，可以使用 POJO 来扁平化一对一关系，如下所示：
- en: '[PRE366]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'And, here''s the jOOQ query:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有一个 jOOQ 查询：
- en: '[PRE374]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Alternatively, you can map UDTs and/or embeddable types. For instance, here
    is a user-defined POJO that fetches a String and an embeddable type containing
    a UDT. For the embeddable type, we relied on the jOOQ-generated POJO:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以映射 UDTs 和/或可嵌入类型。例如，这里是一个用户定义的 POJO，它获取一个 String 和一个包含 UDT 的可嵌入类型。对于可嵌入类型，我们依赖于
    jOOQ 生成的 POJO：
- en: '[PRE383]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'And, the jOOQ query is as follows:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ 查询如下：
- en: '[PRE389]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: More examples are available in the bundled code (that is, in the *PojoTypes*
    application, which is available for PostgreSQL). Next, let's talk about the different
    types of POJOs supported by jOOQ.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（即 *PojoTypes* 应用程序，适用于 PostgreSQL）中还有更多示例。接下来，让我们谈谈 jOOQ 支持的不同类型的 POJO。
- en: Types of POJOs
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POJO 的类型
- en: Besides the typical POJOs from the previous section, jOOQ also supports several
    other types of POJOs. For instance, it supports immutable POJOs.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中的典型 POJO 之外，jOOQ 还支持几种其他类型的 POJO。例如，它支持不可变 POJO。
- en: Immutable POJOs
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变 POJO
- en: 'A user-defined immutable POJO can be written as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的不可变 POJO 可以编写如下：
- en: '[PRE392]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'And a jOOQ query that maps to this POJO is shown next:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个映射到此 POJO 的 jOOQ 查询：
- en: '[PRE397]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: To work as expected, immutable POJOs require an exact match between the fetched
    fields and the POJO's fields (the constructor arguments). However, you can explicitly
    relax this match via `@ConstructorProperties` (`java.beans.ConstructorProperties`).
    Please check the bundled code (*Example 2.2*) for a meaningful example.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按预期工作，不可变 POJO 需要获取的字段与 POJO 的字段（构造函数参数）之间完全匹配。但是，您可以通过 `@ConstructorProperties`
    (`java.beans.ConstructorProperties`) 显式放宽此匹配。请检查捆绑代码（*示例 2.2*）中的有意义的示例。
- en: 'jOOQ can generate immutable POJOs on our behalf via the following configuration
    in the `<generate/>` tag:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 可以通过 `<generate/>` 标签中的以下配置为我们生成不可变 POJO：
- en: '[PRE403]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'Also, it can generate `@ConstructorProperties` via the following:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还可以通过以下方式生成 `@ConstructorProperties`：
- en: '[PRE404]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: In the bundled code, next to the other examples, you can also practice mapping
    UDTs and embeddable types via user-defined immutable POJOs.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，与其他示例相邻，您还可以通过用户定义的不可变 POJO 练习映射 UDTs 和可嵌入类型。
- en: POJOs decorated with @Column (jakarta.persistence.Column)
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰有 @Column 的 POJO（jakarta.persistence.Column）
- en: 'jOOQ can map a `Result` object to a POJO as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 可以将 `Result` 对象映射到 POJO，如下所示：
- en: '[PRE407]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'As you can see, jOOQ recognizes the `@Column` annotation and uses it as the
    primary source for mapping metainformation:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，jOOQ 识别 `@Column` 注解，并将其用作映射元信息的首选来源：
- en: '[PRE413]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'jOOQ can generate such POJOs via the following configuration in `<generate/>`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 可以通过 `<generate/>` 中的以下配置生成此类 POJO：
- en: '[PRE416]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Check out more examples in the bundled code.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中查看更多示例。
- en: JDK 16 records
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDK 16 记录
- en: 'Consider the following JDK 16 record:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 JDK 16 记录：
- en: '[PRE417]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'And the jOOQ query is as follows:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 查询如下：
- en: '[PRE419]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'Alternatively, here is a user-defined JDK 16 record along with a UDT type:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里有一个用户定义的 JDK 16 记录以及一个 UDT 类型：
- en: '[PRE424]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'And the jOOQ query is as follows:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 查询如下：
- en: '[PRE429]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'Or you can use a user-defined JDK 16 record with an embeddable type (here,
    we are using the POJO generated by jOOQ for the embeddable type):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用用户定义的JDK 16记录，其中包含可嵌入的类型（在这里，我们使用jOOQ生成的POJO作为可嵌入的类型）：
- en: '[PRE432]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: 'And here is the jOOQ query:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是jOOQ查询：
- en: '[PRE435]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'jOOQ can generate JDK 16 records on our behalf via the following configuration
    in `<generate/>`:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ可以通过以下`<generate/>`中的配置为我们生成JDK 16记录：
- en: '[PRE438]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: In the bundled code, you can practice JDK 16 records for UDT, embeddable types,
    and more.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以练习JDK 16记录用于UDT、可嵌入类型等。
- en: Interfaces and abstract classes
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口和抽象类
- en: Finally, jOOQ can map a result into interfaces (abstract classes) known as "proxyable"
    types. You can find examples in the bundled code and in the jOOQ manual at [https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/](https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/).
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，jOOQ可以将结果映射到称为“可代理”类型的接口（抽象类）。你可以在捆绑代码和jOOQ手册[https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/](https://www.jooq.org/doc/latest/manual/sql-execution/fetching/pojos/)中找到示例。
- en: 'Moreover, jOOQ can generate interfaces on our behalf via this configuration
    in the `<generate/>` tag:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ可以通过`<generate/>`标签中的此配置为我们生成接口：
- en: '[PRE439]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: If POJOs are also generated, then they will implement these interfaces.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果也生成了POJO，那么它们将实现这些接口。
- en: Useful configurations for POJOs
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POJO的有用配置
- en: Among POJO's configurations, we can ask jOOQ to not generate the `toString()`
    method for the POJO via the `<pojosToString/>` flag, to not generate serializable
    POJOs (to not implement `Serializable`) via the `<serializablePojos/>` flag, and
    to generate fluent setters via the `<fluentSetters/>` flag. Moreover, besides
    POJOs for Java, we can ask jOOQ to generate POJOs for Kotlin via the `<pojosAsKotlinDataClasses/>`
    flag or for Scala via the `<pojosAsScalaCaseClasses/>` flag.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在POJO的配置中，我们可以通过`<pojosToString/>`标志让jOOQ不要为POJO生成`toString()`方法，通过`<serializablePojos/>`标志不要生成可序列化的POJO（即不实现`Serializable`），以及通过`<fluentSetters/>`标志生成流畅的setter方法。此外，除了为Java生成POJO，我们还可以通过`<pojosAsKotlinDataClasses/>`标志让jOOQ为Kotlin生成POJO，或者通过`<pojosAsScalaCaseClasses/>`标志为Scala生成POJO。
- en: In addition, under the `<database/>` tag, we can force `LocalDateTime` into
    POJOs via `<dateAsTimestamp/>` and use unsigned types via `<unsignedTypes/>`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`<database/>`标签下，我们可以通过`<dateAsTimestamp/>`强制将`LocalDateTime`放入POJO中，并通过`<unsignedTypes/>`使用无符号类型。
- en: The complete code is named *PojoTypes* (which is available for PostgreSQL (Maven/Gradle)).
    In the next section, let's talk about record mappers.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码命名为*PojoTypes*（适用于PostgreSQL（Maven/Gradle））。在下一节中，让我们讨论记录映射器。
- en: jOOQ record mappers
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ记录映射器
- en: 'Sometimes, we need a custom mapping that cannot be achieved via the `fetchInto()`
    method, the `fetchMap()` method, the `fetchGroups()` method, or the `Records`
    utility. A simple approach relies on `Iterable.forEach(Consumer)`, as shown in
    the following mapping:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个自定义映射，这个映射无法通过`fetchInto()`方法、`fetchMap()`方法、`fetchGroups()`方法或`Records`实用工具来实现。一个简单的方法是使用`Iterable.forEach(Consumer)`，如下面的映射所示：
- en: '[PRE440]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: You can check out this example for MySQL in *ForEachConsumer*.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ForEachConsumer*中查看这个MySQL示例。
- en: 'However, especially for such cases, jOOQ provides a functional interface that
    allows us to express the custom mappings of a jOOQ result. In this context, we
    have `org.jooq.RecordMapper`, which returns the result produced after applying
    a custom mapping to the jOOQ result. For instance, let''s consider a legacy POJO
    that was implemented via the `Builder` pattern and is named `LegacyCustomer`:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，特别是对于这类情况，jOOQ提供了一个功能接口，允许我们表达jOOQ结果的自定义映射。在这个上下文中，我们有`org.jooq.RecordMapper`，它返回在将自定义映射应用于jOOQ结果后产生的结果。例如，让我们考虑一个通过`Builder`模式实现的遗留POJO，其名称为`LegacyCustomer`：
- en: '[PRE452]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: 'Mapping a jOOQ result into `LegacyCustomer` can be done via a `RecordMapper`
    parameter, as follows:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`RecordMapper`参数将jOOQ结果映射到`LegacyCustomer`可以通过以下方式完成：
- en: '[PRE469]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: This example is available in the bundled code, *RecordMapper* (which is available
    for PostgreSQL), next to other examples such as using a `RecordMapper` parameter
    to map a jOOQ result into a max-heap. Moreover, in [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338),
    *jOOQ SPI (Providers and Listeners)*, you'll see how to configure record mappers
    via `RecordMapperProvider` so that jOOQ will automatically pick them up.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在捆绑代码中的*RecordMapper*（适用于PostgreSQL）中可用，旁边还有其他示例，例如使用`RecordMapper`参数将jOOQ结果映射到最大堆。此外，在[*第18章*](B16833_18.xhtml#_idTextAnchor338)
    *jOOQ SPI（提供者和监听器）*中，你将看到如何通过`RecordMapperProvider`配置记录映射器，以便jOOQ可以自动获取它们。
- en: However, if you need more generic mapping algorithms, then we have to check
    out some third-party libraries that work with jOOQ. In the top three such libraries,
    we have ModelMapper, SimpleFlatMapper, and Orika Mapper.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要更通用的映射算法，那么我们必须检查一些与 jOOQ 一起工作的第三方库。在排名前三的此类库中，我们有 ModelMapper、SimpleFlatMapper
    和 Orika Mapper。
- en: 'It is beyond the scope of this book to deep dive into all these libraries.
    Therefore, I decided to go with the SimpleFlatMapper library ([https://simpleflatmapper.org/](https://simpleflatmapper.org/)).
    Let''s assume the following one-to-many mapping:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围之外，无法深入探讨所有这些库。因此，我决定选择 SimpleFlatMapper 库 ([https://simpleflatmapper.org/](https://simpleflatmapper.org/))。让我们假设以下一对多映射：
- en: '[PRE481]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: 'Essentially, SimpleFlatMapper can map a jOOQ result via `SelectQueryMapper`,
    as shown in the following self-explanatory example:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，SimpleFlatMapper 可以通过 `SelectQueryMapper` 映射 jOOQ 结果，如下面的自解释示例所示：
- en: '[PRE493]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: In this code, SimpleFlatMapper maps the jOOQ result, so it acts directly on
    the jOOQ records. This code is available in the *SFMOneToManySQM* application
    (available for MySQL). However, as you can see in the *SFMOneToManyJM* application,
    this library can also take advantage of the fact that jOOQ allows us to manipulate
    the `ResultSet` object itself, so it can act directly on the `ResultSet` object
    via an API named `JdbcMapper`. This way, SimpleFlatMapper bypasses the jOOQ mapping
    to `Record`.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，SimpleFlatMapper 映射 jOOQ 结果，因此它直接作用于 jOOQ 记录。此代码位于 *SFMOneToManySQM* 应用程序中（适用于
    MySQL）。然而，正如你在 *SFMOneToManyJM* 应用程序中所见，这个库也可以利用 jOOQ 允许我们操作 `ResultSet` 对象本身的事实，因此它可以通过名为
    `JdbcMapper` 的 API 直接作用于 `ResultSet` 对象。这样，SimpleFlatMapper 就绕过了对 `Record` 的 jOOQ
    映射。
- en: Moreover, the bundled code includes applications for mapping one-to-one and
    many-to-many relationships next to *SFMOneToManyTupleJM*, which is an application
    that combines SimpleFlatMapper and the jOOL `Tuple2` API to map a one-to-many
    relationship without using POJOs. For brevity, we cannot list this code in the
    book, so you need to reserve some time to explore it by yourself.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，捆绑的代码包括与 *SFMOneToManyTupleJM* 一起映射一对一和多对多关系的应用程序，这是一个结合 SimpleFlatMapper
    和 jOOL `Tuple2` API 来映射一对多关系而不使用 POJOs 的应用程序。为了简洁，我们无法在书中列出此代码，因此你需要留出一些时间自己探索。
- en: 'From another perspective, via the same `SelectQueryMapper` and `JdbcMapper`
    APIs, the SimpleFlatMapper library can co-work with jOOQ to map chained and/or
    nested `JOIN` statements. For instance, consider this model:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，通过相同的 `SelectQueryMapper` 和 `JdbcMapper` API，SimpleFlatMapper 库可以与
    jOOQ 协同工作，以映射链式和/或嵌套的 `JOIN` 语句。例如，考虑以下模型：
- en: '[PRE513]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'Using the SimpleFlatMapper and jOOQ combination, we can populate this model
    as follows:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SimpleFlatMapper 和 jOOQ 的组合，我们可以如下填充此模型：
- en: '[PRE523]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: The complete code is named *SFMMultipleJoinsSQM*. The version of this code that
    uses `JdbcMapper` is named *SFMMultipleJoinsJM*. Moreover, in the bundled code,
    you can find an example of mapping a deep hierarchical JOIN of type (`EMPLOYEE`
    has `CUSTOMER` has `ORDER` has `ORDERDETAIL` has `PRODUCT`). This JOIN is also
    mapped in *SFMMultipleJoinsInnerLevelsTupleJM* using jOOL `Tuple2` and no POJOs.
    Anyway, even if such things work, I don't recommend you to do it in real applications.
    You better rely on the SQL/JSON/XML operators or MULTISET, as you'll do later.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码命名为 *SFMMultipleJoinsSQM*。使用 `JdbcMapper` 的此代码版本命名为 *SFMMultipleJoinsJM*。此外，在捆绑的代码中，你可以找到一个映射深层次
    JOIN 的示例，该 JOIN 类型为 (`EMPLOYEE` has `CUSTOMER` has `ORDER` has `ORDERDETAIL` has
    `PRODUCT`)。此 JOIN 还在 *SFMMultipleJoinsInnerLevelsTupleJM* 中使用 jOOL `Tuple2` 和没有
    POJOs 进行映射。无论如何，即使这些事情可行，我也不建议你在实际应用程序中这样做。你最好依靠 SQL/JSON/XML 操作符或 MULTISET，就像你稍后将要做的那样。
- en: Again, for brevity, we cannot list this code in the book, so you need to reserve
    some time to explore it by yourself. At this point, we have reached the climax
    of this chapter. It's time to beat the drums because the next section covers the
    outstanding mapping support of jOOQ SQL/JSON and SQL/XML.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了简洁，我们无法在书中列出此代码，因此你需要留出一些时间自己探索。到目前为止，我们已经达到了本章的高潮。现在是时候敲锣打鼓了，因为下一节将涵盖
    jOOQ SQL/JSON 和 SQL/XML 的出色映射支持。
- en: The mighty SQL/JSON and SQL/XML support
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的 SQL/JSON 和 SQL/XML 支持
- en: Starting with jOOQ 3.14, we have support for mapping a result set to any kind
    of hierarchical/nested structure that can be shaped via JSON or XML into, practically,
    almost anything. For instance, if you develop a REST API, you can return JSON/XML
    data in the exact desired shape without mapping anything to your domain model.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 从 jOOQ 3.14 版本开始，我们支持将结果集映射到任何可以通过 JSON 或 XML 塑造的层次/嵌套结构。例如，如果您开发 REST API，您可以在不映射任何内容到您的领域模型的情况下返回所需形状的
    JSON/XML 数据。
- en: As you probably know, most RDBMSs support SQL/JSON (standard or vendor-specific),
    and some of them support SQL/XML, too.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，大多数 RDBMS 支持 SQL/JSON（标准或供应商特定），其中一些还支持 SQL/XML。
- en: Handling SQL/JSON support
  id: totrans-743
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 SQL/JSON 支持
- en: 'In a nutshell, for SQL/JSON, we can talk about the following operators that
    have a jOOQ implementation in the `org.jooq.impl.DSL` class:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于 SQL/JSON，我们可以讨论以下在 `org.jooq.impl.DSL` 类中有 jOOQ 实现的操作符：
- en: '`JSON_OBJECT` (`DSL.jsonObject()`, `DSL.jsonEntry()`), `JSON_ARRAY` (`DSL.jsonArray()`),
    and `JSON_VALUE` (`DSL.jsonValue()`) to construct JSON data from values'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON_OBJECT` (`DSL.jsonObject()`、`DSL.jsonEntry()`), `JSON_ARRAY` (`DSL.jsonArray()`),
    和 `JSON_VALUE` (`DSL.jsonValue()`) 用于从值构建 JSON 数据'
- en: '`JSON_ARRAYAGG` (`DSL.jsonArrayAgg()`) and `JSON_OBJECTAGG` (`DSL.jsonObjectAgg()`)
    to aggregate data into nested JSON documents'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON_ARRAYAGG` (`DSL.jsonArrayAgg()`) 和 `JSON_OBJECTAGG` (`DSL.jsonObjectAgg()`)
    用于将数据聚合到嵌套的 JSON 文档中'
- en: '`JSON_EXISTS` (`DSL.jsonExists()`) to query documents with the JSON path'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON_EXISTS` (`DSL.jsonExists()`) 用于通过 JSON 路径查询文档'
- en: '`JSON_TABLE` (`DSL.jsonTable()`) to transform JSON values into SQL tables'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON_TABLE` (`DSL.jsonTable()`) 用于将 JSON 值转换为 SQL 表'
- en: SQL Server's `FOR JSON` syntax (including `ROOT`, `PATH`, `AUTO`, and `WITHOUT_ARRAY_WRAPPER`);
    the jOOQ commercial edition emulates the `FOR JSON` syntax for the databases that
    don't support it (in this book, you can see this for SQL Server and Oracle)
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 的 `FOR JSON` 语法（包括 `ROOT`、`PATH`、`AUTO` 和 `WITHOUT_ARRAY_WRAPPER`）；jOOQ
    商业版模拟了不支持该语法的数据库的 `FOR JSON` 语法（在本章中，您可以查看 SQL Server 和 Oracle 的示例）
- en: Let's see some introductory examples of these operators via the jOOQ DSL API.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 jOOQ DSL API 看一些这些操作符的入门示例。
- en: Constructing and aggregating JSON data from the values
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从值构建和聚合 JSON 数据
- en: 'Constructing JSON data from values can be done via the `JSON_OBJECT` operator.
    This is implemented in jOOQ via different flavors of the `DSL.jsonObject()` method.
    For instance, you can map the `CUSTOMER.CUSTOMER_NAME` and `CUSTOMER.CREDIT_LIMIT`
    fields to an `org.jooq.JSON` object as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `JSON_OBJECT` 操作符可以从值构建 JSON 数据。这在 jOOQ 中通过 `DSL.jsonObject()` 方法的不同变体实现。例如，您可以将
    `CUSTOMER.CUSTOMER_NAME` 和 `CUSTOMER.CREDIT_LIMIT` 字段映射到 `org.jooq.JSON` 对象，如下所示：
- en: '[PRE536]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: 'In contrast to the `key().value()` construction, we can use `jsonObject(JSON
    Entry<?>... entries)`, as follows:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `key().value()` 构造相比，我们可以使用 `jsonObject(JSON Entry<?>... entries)`，如下所示：
- en: '[PRE541]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: 'The returned `Result` object (remember that this is a wrapper of `java.util.List`)
    has a size equal to the number of fetched customers. Each `Record1` object wraps
    an `org.jooq.JSON` instance representing a customer name and credit limit. If
    we just want to format this `Result` object as a JSON, we can call the `formatJSON()`
    method (this will be presented in the next chapter). This will return a simple
    formatted representation such as the one here:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `Result` 对象（请记住，这是一个 `java.util.List` 的包装器）的大小等于获取的客户的数量。每个 `Record1` 对象包装了一个
    `org.jooq.JSON` 实例，代表客户名称和信用额度。如果我们只想将此 `Result` 对象格式化为 JSON，我们可以调用 `formatJSON()`
    方法（这将在下一章中介绍）。这将返回一个简单的格式化表示，如下所示：
- en: '[PRE546]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'However, this response is too verbose to send to the client. For instance,
    you might only need the `"records"` key. In such cases, we can rely on the `formatJSON(JSONFormat)`
    flavor as follows:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个响应太冗长了，不适合发送给客户端。例如，您可能只需要 `"records"` 键。在这种情况下，我们可以依赖 `formatJSON(JSONFormat)`
    变体，如下所示：
- en: '[PRE557]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: 'Supposing that you just want to send the first JSON array, you can extract
    it from the `Result` object as `result.get(0).value1().data()`:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您只想发送第一个 JSON 数组，您可以从 `Result` 对象中提取它作为 `result.get(0).value1().data()`：
- en: '[PRE565]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'However, perhaps you are planning to send all these JSONs as a `List<String>`
    to the client. Then, rely on `fetchInto(String.class)`, which will return all
    of the JSONs as a `List<String>`. Note that each `String` is a JSON:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也许您计划将所有这些 JSON 作为 `List<String>` 发送到客户端。那么，依赖 `fetchInto(String.class)`，它将返回所有
    JSON 作为 `List<String>`。请注意，每个 `String` 都是一个 JSON：
- en: '[PRE569]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: 'Also, you can send the response as a list of JSON arrays. Just wrap each JSON
    object into an array via `jsonArray()`, as follows:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以将响应作为 JSON 数组的列表发送。只需通过 `jsonArray()` 将每个 JSON 对象包装到数组中，如下所示：
- en: '[PRE574]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: 'This time, the first JSON array (at index 0 in the list) is *[{"creditLimit":
    21000.00, "customerName": "Australian Home"}]*, the second one (at index 1 in
    the list) is *[{"creditLimit": 21000, "customerName": "Joliyon"}]*, and so on.'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，第一个 JSON 数组（在列表中的索引 0）是 *[{"creditLimit": 21000.00, "customerName": "Australian
    Home"}]*，第二个（在列表中的索引 1）是 *[{"creditLimit": 21000, "customerName": "Joliyon"}]*，依此类推。'
- en: 'However, it is more practical to aggregate all of these JSONs into a single
    array. This is possible via `jsonArrayAgg()`, which will return a single JSON
    array containing all of the fetched data:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将这些 JSON 聚合到一个单独的数组中更为实用。这可以通过 `jsonArrayAgg()` 实现，它将返回一个包含所有获取数据的单个 JSON
    数组：
- en: '[PRE579]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: 'The aggregated JSON array is given here:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的 JSON 数组如下所示：
- en: '[PRE584]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: 'However, we can also aggregate the fetched data as a single JSON object that
    has `CUSTOMER_NAME` as the key and `CREDIT_LIMIT` as the value. This can be done
    via the `jsonObjectAgg()` method, as follows:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以将获取的数据聚合为一个单独的 JSON 对象，其中 `CUSTOMER_NAME` 作为键，`CREDIT_LIMIT` 作为值。这可以通过
    `jsonObjectAgg()` 方法完成，如下所示：
- en: '[PRE589]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: 'This time, the resulting JSON is as follows:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的 JSON 结果如下：
- en: '[PRE593]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: 'If you are a SQL Server fan, then you know that fetching data as JSON can be
    done via the non-standard `FOR JSON` syntax. jOOQ supports this syntax via the
    `forJson()` API. It also supports clauses such as `ROOT` via `root()`, `PATH`
    via `path()`, `AUTO` via `auto()`, and `WITHOUT_ARRAY_WRAPPER` via `withoutArrayWrapper()`.
    Here is an example that produces nested results by using dot-separated column
    names via `PATH`:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 SQL Server 的粉丝，那么您知道可以通过非标准的 `FOR JSON` 语法将数据作为 JSON 获取。jOOQ 通过 `forJson()`
    API 支持这种语法。它还支持 `ROOT` 通过 `root()`，`PATH` 通过 `path()`，`AUTO` 通过 `auto()`，以及 `WITHOUT_ARRAY_WRAPPER`
    通过 `withoutArrayWrapper()` 等子句。以下是一个通过 `PATH` 使用点分隔的列名生成嵌套结果的示例：
- en: '[PRE599]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'And here is an example of using `AUTO`, which automatically produces the output
    based on the structure of the `SELECT` statement:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `AUTO` 的示例，它将自动根据 `SELECT` 语句的结构生成输出：
- en: '[PRE609]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: You can check out these examples in the bundled code for *SimpleJson* and get
    familiar with the produced JSONs. For now, let's talk about ordering and limiting
    the content of the resulting JSON when using SQL-standard JSON operators (for
    SQL Server's `FOR JSON` syntax, consider the previous two examples).
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *SimpleJson* 的捆绑代码中查看这些示例，并熟悉生成的 JSON。现在，让我们谈谈使用 SQL 标准的 JSON 运算符（对于 SQL
    Server 的 `FOR JSON` 语法，请考虑前两个示例）对结果 JSON 的内容进行排序和限制。
- en: Using ORDER BY and LIMIT
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ORDER BY 和 LIMIT
- en: 'When we don''t use aggregation operators, ordering and limiting are quite similar
    to regular queries. For instance, you can order by `CUSTOMER_NAME` and limit the
    result to three JSONs as follows:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不使用聚合运算符时，排序和限制与常规查询非常相似。例如，您可以按 `CUSTOMER_NAME` 排序，并将结果限制为三个 JSON，如下所示：
- en: '[PRE617]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'On the other hand, when the aggregation operators (`jsonArrayAgg()` and `jsonObjectAgg()`)
    are involved, limiting should be done before the aggregation (for instance, in
    a subquery, `JOIN`, and more). Otherwise, this operation will be applied to the
    resulted aggregation itself, not to the aggregated data. During aggregation, ordering
    can be done before limiting, respectively. For instance, in the following example,
    the subquery orders the customers by `CUSTOMER_NAME` and limits the returned result
    to 3, while the aggregation orders this result by `CREDIT_LIMIT`:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当涉及聚合运算符（`jsonArrayAgg()` 和 `jsonObjectAgg()`）时，应该在聚合之前进行限制（例如，在子查询、`JOIN`
    等）。否则，此操作将应用于结果聚合本身，而不是聚合数据。在聚合过程中，排序可以在限制之前进行。例如，在以下示例中，子查询按 `CUSTOMER_NAME`
    对客户进行排序，并将返回的结果限制为 3，而聚合则按 `CREDIT_LIMIT` 对此结果进行排序：
- en: '[PRE624]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'The resulting aggregation is ordered by `CREDIT_LIMIT`:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合结果按 `CREDIT_LIMIT` 排序：
- en: '[PRE631]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: More examples are available in the bundled code for *SimpleJson*. Note that,
    in the applications that uses PostgreSQL and Oracle, you can see the SQL standard's
    `NULL ON NULL` (`nonOnNull()`) and `ABSENT ON NULL` (`absentOnNull()`) syntax
    at work. For now, let's query documents with the JSON path.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在 *SimpleJson* 的捆绑代码中找到。请注意，在使用 PostgreSQL 和 Oracle 的应用程序中，您可以看到 SQL 标准的
    `NULL ON NULL` (`nonOnNull()`) 和 `ABSENT ON NULL` (`absentOnNull()`) 语法在起作用。现在，让我们使用
    JSON 路径查询文档。
- en: Querying JSON documents with the JSON path
  id: totrans-872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 JSON 路径查询 JSON 文档
- en: Via `JSON_EXISTS` and `JSON_VALUE`, we can query and construct JSON documents
    that rely on the JSON path. In order to practice jOOQ's `jsonExists()` and `jsonValue()`
    queries, let's consider the `MANAGER.MANAGER_DETAIL` field, which stores data
    in JSON format. Please take a quick look at this JSON so that you can become familiar
    with its structure and content.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`JSON_EXISTS`和`JSON_VALUE`，我们可以查询和构建依赖于JSON路径的JSON文档。为了练习jOOQ的`jsonExists()`和`jsonValue()`查询，让我们考虑存储在JSON格式的`MANAGER.MANAGER_DETAIL`字段，以便您熟悉其结构和内容。
- en: 'Now, selecting the `MANAGER.MANAGER_ID` and `MANAGER.MANAGER_NAME` fields of
    the managers that are also shareholders(with the `"shareholder"` key in JSON)
    can be done via `jsonExists()` and the JSON path, as follows:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择既是经理又是股东（在JSON中有`"shareholder"`键）的经理的`MANAGER.MANAGER_ID`和`MANAGER.MANAGER_NAME`字段可以通过`jsonExists()`和JSON路径完成，如下所示：
- en: '[PRE636]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: 'If the fetched JSON is constructed from JSON values, then we should rely on
    `jsonValue()` and the JSON path. For instance, fetching the cities of all managers
    can be done like this:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取的JSON是由JSON值构建的，那么我们应该依赖于`jsonValue()`和JSON路径。例如，获取所有经理的城市可以通过以下方式完成：
- en: '[PRE641]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: 'Combining `jsonExists()` and `jsonValue()` allows us to query and construct
    JSON results from JSON documents. For instance, in PostgreSQL and Oracle, we can
    select the emails of the managers that had the role of *Principal Manager* by
    exploiting the JSON path:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合`jsonExists()`和`jsonValue()`，我们可以从JSON文档中查询和构建JSON结果。例如，在PostgreSQL和Oracle中，我们可以通过利用JSON路径选择担任*Principal
    Manager*角色的经理的电子邮件：
- en: '[PRE645]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: More examples are available in the bundled code, *SimpleJson*. Next, let's tackle
    `JSON_TABLE`.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在附带代码*SimpleJson*中找到。接下来，让我们处理`JSON_TABLE`。
- en: Transforming JSON values into SQL tables
  id: totrans-893
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将JSON值转换为SQL表
- en: 'Transforming JSON values into SQL tables can be done via the `JSON_TABLE` operator,
    which, in jOOQ, is equivalent to the `jsonTable()` method. For instance, let''s
    build a SQL table containing all projects of the development type via the `jsonTable(Field<JSON>
    json, Field<String> path)` flavor:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`JSON_TABLE`运算符可以将JSON值转换为SQL表，在jOOQ中，这相当于`jsonTable()`方法。例如，让我们通过`jsonTable(Field<JSON>
    json, Field<String> path)`方式构建一个包含所有开发类型项目的SQL表：
- en: '[PRE651]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: 'This query will produce a table, as follows:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将生成一个表，如下所示：
- en: '![Figure 8.2 – The result of the previous query'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 上一个查询的结果'
- en: '](img/B16833_Figure_8.2.jpg)'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_8.2.jpg)'
- en: Figure 8.2 – The result of the previous query
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 上一个查询的结果
- en: Once you fetch a SQL table, you can think and act on it in the same way as any
    other database table. For brevity, I simply used `VARCHAR`, but it is better to
    specify a size in order to avoid defaulting to `VARCHAR(max)`.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获取了一个SQL表，您就可以像处理任何其他数据库表一样思考和行动。为了简洁，我简单地使用了`VARCHAR`，但最好指定一个大小，以避免默认为`VARCHAR(max)`。
- en: More examples, including how to use `JSON_TABLE` with aggregates, `ORDER BY`,
    `LIMIT`, and how to transform back into JSON from a SQL table, are available in
    the bundled code, *SimpleJson*.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 包含如何使用`JSON_TABLE`进行聚合、`ORDER BY`、`LIMIT`以及如何从SQL表转换回JSON的更多示例可以在附带代码*SimpleJson*中找到。
- en: Handling relationships via SQL/JSON
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SQL/JSON处理关系
- en: The well-known one-to-one, one-to-many, and many-to-many relationships can be
    easily shaped via SQL/JSON support.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SQL/JSON支持，可以轻松地构建已知的单一到单一、单一到多和多变多的关系。
- en: Mapping relationships to JSON
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射关系到JSON
- en: 'So, if by any chance you had a feeling that there is a shortcoming in jOOQ
    regarding mapping relationships, then you''ll be very happy to see that a one-to-many
    relationship can be easily fetched directly into JSON as follows (in this case,
    we''re looking at the relationship between `PRODUCTLINE` and `PRODUCT`):'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您有任何关于jOOQ在映射关系方面存在不足的感觉，那么您将非常高兴地看到一对一关系可以轻松地直接转换为JSON，如下所示（在这种情况下，我们正在查看`PRODUCTLINE`和`PRODUCT`之间的关系）：
- en: '[PRE659]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: As you can infer from the preceding code, expressing the one-to-one and many-to-many
    relationships is just a matter of juggling with the SQL/JSON operators. You can
    find these examples, including how to use `JOIN` instead of a `SELECT` subquery,
    in the bundled code for *JsonRelationships*.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中可以推断出，表达一对一和多对多关系只是简单地使用SQL/JSON运算符的问题。您可以在*JsonRelationships*的附带代码中找到这些示例，包括如何使用`JOIN`代替`SELECT`子查询。
- en: 'If you think that `Result<Record1<JSON>>` is not ready to be sent to the client
    (for instance, via a REST controller), then decorate it a little bit more by aggregating
    all the product lines under a JSON array and relying on `fetchSingleInto()`:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为 `Result<Record1<JSON>>` 还没有准备好发送到客户端（例如，通过 REST 控制器），那么通过聚合所有产品行到一个 JSON
    数组并依赖 `fetchSingleInto()` 来稍微装饰一下：
- en: '[PRE672]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'In SQL Server, we can obtain a similar result via `forJson()`:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中，我们可以通过 `forJson()` 获取类似的结果：
- en: '[PRE677]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: 'Or we can obtain a `String` via `formatJSON(JSONformat)`:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以通过 `formatJSON(JSONformat)` 获取一个 `String`：
- en: '[PRE689]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Both examples will produce a JSON, as follows (as you can see, altering the
    default JSON keys inferred from the field names can be done with aliases via `as("alias")`):'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都将生成一个 JSON，如下所示（如你所见，可以通过 `as("alias")` 使用别名来更改从字段名推断出的默认 JSON 键）：
- en: '[PRE695]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: In the bundled code for *JsonRelationships*, you can find a lot of examples
    to do with one-to-one, one-to-many, and many-to-many relationships. Moreover,
    you can check out several examples of how to map arrays and UDTs into JSON.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *JsonRelationships* 的捆绑代码中，你可以找到很多关于一对一、一对多和多对多关系的示例。此外，你还可以查看如何将数组和 UDT 映射到
    JSON 的几个示例。
- en: Mapping JSON relationships to POJOs
  id: totrans-977
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 JSON 关系映射到 POJOs
- en: 'As you just saw, jOOQ can fetch and map a relationship directly into JSON.
    However, that''s not all! jOOQ can go even further and map the resulted JSON to
    the domain model (POJOs). Yes, you read that right; as long as we have Gson, Jackson
    (Spring Boot has this by default), or JAXB in the classpath, jOOQ can automatically
    map the query results to our nested data structures. This is quite useful when
    you don''t actually need the JSON itself – you can just rely on JSON to facilitate
    the nesting data structures and map them back to Java. For instance, let''s assume
    the following domain model:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，jOOQ 可以直接将关系提取并映射到 JSON。然而，这还不是全部！jOOQ 可以更进一步，将生成的 JSON 映射到领域模型（POJOs）。是的，你没听错；只要我们在类路径上有
    Gson、Jackson（Spring Boot 默认包含）或 JAXB，jOOQ 就可以自动将查询结果映射到我们的嵌套数据结构。这在实际上不需要 JSON
    本身时非常有用——你只需依赖 JSON 来促进嵌套数据结构的构建，并将它们映射回 Java。例如，假设以下领域模型：
- en: '[PRE717]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: 'Can we populate this model from jOOQ `Result` by just using jOOQ? Yes, we can
    do it via SQL/JSON support, as follows:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否仅使用 jOOQ 从 `Result` 中填充这个模型？是的，我们可以通过 SQL/JSON 支持来实现，如下所示：
- en: '[PRE727]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: That's so cool, right?! The same thing can be accomplished for one-to-one and
    many-to-many relationships, as you can see in the bundled code. All examples are
    available in *JsonRelationshipsInto*.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太酷了，对吧？！对于一对一和多对多关系，你也可以在捆绑代码中看到同样的效果。所有示例都可在 *JsonRelationshipsInto* 中找到。
- en: Mapping arbitrary models
  id: totrans-1004
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射任意模型
- en: 'If you think that what you''ve just seen is impressive, then get ready for
    more because jOOQ can fetch and map almost any kind of arbitrary model, not just
    the well-known 1:1,1:n, and n:n relationships. Let''s consider the following three
    arbitrary models:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你刚刚看到的是令人印象深刻的，那么准备好更多，因为 jOOQ 可以获取并映射几乎任何类型的任意模型，而不仅仅是众所周知的 1:1、1:n 和
    n:n 关系。让我们考虑以下三个任意模型：
- en: '![Figure 8.3 – Arbitrary domain models'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 任意领域模型'
- en: '](img/B16833_Figure_8.3.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_8.3.jpg)'
- en: Figure 8.3 – Arbitrary domain models
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 任意领域模型
- en: 'Which one do you choose to be exemplified in the book? The second one (`jsonObject()`
    and `jsonArrayAgg()`, as follows:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 你会选择哪一个在书中作为示例？第二个（`jsonObject()` 和 `jsonArrayAgg()`，如下所示）：
- en: '[PRE740]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '[PRE749]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '[PRE760]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '[PRE764]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: '[PRE765]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '[PRE766]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: 'Lukas Eder states that:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder 表示：
- en: '*"What I always like to mention in this regard is that there are no accidental
    Cartesian Products or costly de-duplication* *going on (as with JPA), because
    all the data is already nested correctly in SQL, and transferred optimally. This
    approach should be the first choice when nesting collections with SQL or producing
    JSON/XML for some frontend. Never use ordinary joins, which should be used only
    for flat results or aggregations."*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '*"关于这一点，我总是喜欢提到的是，没有偶然的笛卡尔积或昂贵的去重操作（如 JPA），因为所有数据已经正确嵌套在 SQL 中，并且以最佳方式传输。这种方法应该是使用
    SQL 嵌套集合或为某些前端生成 JSON/XML 的首选方法。永远不要使用普通的连接，这些连接应该仅用于扁平结果或聚合。"*'
- en: Take your time to dissect this query and check out the bundled code to see the
    output. Moreover, in the bundled code, you can practice **Model 1** and **Model
    3**, too. For each of these models, you have the JSON result and the corresponding
    mapping to POJOs. The application is named *NestedJson*.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细分析这个查询，并查看捆绑代码以查看输出。此外，在捆绑代码中，你还可以练习 **模型 1** 和 **模型 3**。对于这些模型中的每一个，你都有 JSON
    结果和相应的 POJO 映射。应用程序名为 *NestedJson*。
- en: 'I''m sure that, as a SQL Server fan, you are impatient to see the version of
    the previous query expressed via `forJson()`, so here it is:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，作为一个 SQL Server 粉丝，您迫不及待地想看到通过 `forJson()` 表达的先前查询版本，所以这就是它：
- en: '[PRE770]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '[PRE775]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: '[PRE776]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: '[PRE777]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: '[PRE778]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: '[PRE779]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '[PRE780]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '[PRE781]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: '[PRE783]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: '[PRE785]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '[PRE786]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '[PRE787]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: '[PRE788]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: '[PRE789]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '[PRE790]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[PRE791]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[PRE792]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: Of course, you can check out these examples in the bundled code next to the
    examples for **Model 1** and **Model 3**.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在与 **模型 1** 和 **模型 3** 的示例并排的捆绑代码中查看这些示例。
- en: Important Note
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Next to SQL/JSON support, jOOQ also provides SQL/JSONB support. You can explicitly
    use JSONB via `org.jooq.JSONB` and the operators such as `jsonbObject()`, `jsonbArrayAgg()`,
    and `jsonbTable()`.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SQL/JSON 支持，jOOQ 还提供了 SQL/JSONB 支持。您可以通过 `org.jooq.JSONB` 和如 `jsonbObject()`、`jsonbArrayAgg()`
    和 `jsonbTable()` 等运算符显式使用 JSONB。
- en: Now, it is time to talk about SQL/XML support.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候讨论 SQL/XML 支持了。
- en: Handling SQL/XML support
  id: totrans-1072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 SQL/XML 支持
- en: 'In a nutshell, for SQL/XML, we can talk about the following operators that
    have a jOOQ implementation in the `org.jooq.impl.DSL` class:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于 SQL/XML，我们可以讨论以下在 `org.jooq.impl.DSL` 类中有 jOOQ 实现的运算符：
- en: '`XMLELEMENT` (`DSL.xmlelement()`), `XMLATTRIBUTES` (`DSL.xmlattributes()`),
    `XMLFOREST` (`DSL.xmlforest()`), `XMLCONCAT` (`DSL.xmlconcat()`), and `XMLCOMMENT`
    (`DSL.xmlcomment()`) to construct XML data'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLELEMENT` (`DSL.xmlelement()`), `XMLATTRIBUTES` (`DSL.xmlattributes()`),
    `XMLFOREST` (`DSL.xmlforest()`), `XMLCONCAT` (`DSL.xmlconcat()`), 和 `XMLCOMMENT`
    (`DSL.xmlcomment()`) 用于构建 XML 数据'
- en: '`XMLAGG` (`DSL.xmlagg()`) to aggregate data into nested XML documents'
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLAGG` (`DSL.xmlagg()`) 用于将数据聚合到嵌套的 XML 文档中'
- en: '`XMLEXISTS` (`DSL.xmlexists()`) and `XMLQUERY` (`DSL.xmlquery()`) to query
    XML documents with `XPath`'
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLEXISTS` (`DSL.xmlexists()`) 和 `XMLQUERY` (`DSL.xmlquery()`) 用于使用 `XPath`
    查询 XML 文档'
- en: '`XMLPARSE` (`DSL.xmlparseContent()` and `DSL.xmlparseDocument()`) for parsing
    XML content and documents'
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLPARSE` (`DSL.xmlparseContent()` 和 `DSL.xmlparseDocument()`) 用于解析 XML 内容和文档'
- en: '`XMLPI` (`DSL.xmlpi()`) for producing XML processing instructions'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLPI` (`DSL.xmlpi()`) 用于生成 XML 处理指令'
- en: '`XMLTABLE` (`DSL.xmltable()`) to transform XML values into SQL tables'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLTABLE` (`DSL.xmltable()`) 用于将 XML 值转换为 SQL 表'
- en: SQL Server's `FOR XML` syntax (including `ROOT`, `PATH`, `ELEMENTS`, `RAW`,
    and `AUTO`, and `EXPLICIT (jOOQ 3.17.x +)`) – jOOQ's commercial editions emulate
    the `FOR XML` syntax for databases that don't support it (in this book, you can
    practice this for SQL Server and Oracle).
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 的 `FOR XML` 语法（包括 `ROOT`、`PATH`、`ELEMENTS`、`RAW`、`AUTO` 和 `EXPLICIT
    (jOOQ 3.17.x +)`）—— jOOQ 的商业版本模拟了不支持 `FOR XML` 语法的数据库的语法（在这本书中，您可以为此 SQL Server
    和 Oracle 练习）。
- en: Let's see some introductory examples of these operators via the jOOQ DSL API.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 jOOQ DSL API 看一些这些运算符的入门示例。
- en: Constructing and aggregating XML data from values
  id: totrans-1082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从值构建和聚合 XML 数据
- en: 'A good start for constructing XML data from values relies on the `XMLELEMENT`
    operator. In jOOQ, `XMLELEMENT` is rendered via the `xmlelement()` method. For
    instance, the following snippet of code fetches the `CUSTOMER_NAME` field of each
    customer and uses it as the text of an XML element named `<name/>`:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 从值构建 XML 数据的良好起点依赖于 `XMLELEMENT` 运算符。在 jOOQ 中，`XMLELEMENT` 通过 `xmlelement()`
    方法呈现。例如，以下代码片段检索每个客户的 `CUSTOMER_NAME` 字段，并将其用作名为 `<name/>` 的 XML 元素的文本：
- en: '[PRE794]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[PRE796]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: 'The returned `Result` has a size that is equal to the number of fetched customers.
    Each `Record1` wraps an `org.jooq.XML` instance representing a `<name/>` element.
    If we just want to format this `Result` as an XML, we can call the `formatXML()`
    method (this will be presented in the next chapter). This will return a simple
    formatted representation such as the one here:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `Result` 的大小等于检索到的客户数量。每个 `Record1` 包裹一个代表 `<name/>` 元素的 `org.jooq.XML`
    实例。如果我们只想将此 `Result` 格式化为 XML，我们可以调用 `formatXML()` 方法（这将在下一章中介绍）。这将返回一个简单的格式化表示，如下所示：
- en: '[PRE797]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: '[PRE798]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: '[PRE800]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '[PRE801]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: '[PRE802]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '[PRE803]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '[PRE804]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '[PRE806]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '[PRE807]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '[PRE808]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '[PRE809]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: 'However, this response is too verbose to send to the client. For instance,
    you might only need the `"records"` element. In such cases, we can rely on the
    `formatXML(XMLFormat)` flavor, as you''ll see in the bundled code. Supposing that
    you want to just send the first `<name/>` element, you can extract it from the
    `Result` object as `result.get(0).value1().data()`:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个响应太冗长了，不适合发送到客户端。例如，您可能只需要 `"records"` 元素。在这种情况下，我们可以依靠 `formatXML(XMLFormat)`
    风味，正如您将在捆绑代码中看到的那样。假设您只想发送第一个 `<name/>` 元素，您可以从 `Result` 对象中提取它作为 `result.get(0).value1().data()`：
- en: '[PRE813]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: '[PRE814]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '[PRE815]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: '[PRE816]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: 'However, perhaps you are planning to send all of these `<name/>` tags as a
    `List<String>` to the client. Then, rely on `fetchInto(String.class)` to return
    all the `<name/>` elements as a `List<String>`. Note that each `String` is a `<name/>`:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也许您计划将这些 `<name/>` 标签作为 `List<String>` 发送到客户端。然后，依靠 `fetchInto(String.class)`
    返回所有 `<name/>` 元素作为 `List<String>`。请注意，每个 `String` 都是一个 `<name/>`：
- en: '[PRE817]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '[PRE818]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '[PRE819]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: 'Alternatively, it would be more practical to aggregate all these `<name/>`
    elements as a single `String`. This is possible via `xmlagg()`, which returns
    a single XML containing all of the fetched data (for convenience, let''s aggregate
    everything under the `<names/>` tag):'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将所有这些 `<name/>` 元素聚合为一个单一的 `String` 会更实用。这可以通过 `xmlagg()` 实现，它返回一个包含所有获取数据的单个
    XML（为了方便，让我们将所有内容聚合在 `<names/>` 标签下）：
- en: '[PRE820]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '[PRE821]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[PRE822]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: 'The aggregated XML is shown here:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的 XML 如此显示：
- en: '[PRE823]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[PRE824]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '[PRE825]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: '[PRE826]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '[PRE827]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: 'What about adding attributes to the XML elements? This can be done via `xmlattributes()`,
    as shown in the following intuitive example:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么给 XML 元素添加属性怎么办？这可以通过 `xmlattributes()` 实现，如下面的直观示例所示：
- en: '[PRE828]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '[PRE829]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: '[PRE830]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '[PRE831]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: 'The expected XML will look like this:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的 XML 将看起来像这样：
- en: '[PRE832]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: '[PRE833]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: 'A relatively useful XML operator is `xmlforest()`. This operator converts its
    parameters into XML and returns an XML fragment obtained by the concatenation
    of these converted arguments. Here is an example:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相对有用的 XML 操作符是 `xmlforest()`。这个操作符将其参数转换为 XML，并返回通过这些转换参数的连接获得的 XML 片段。以下是一个示例：
- en: '[PRE834]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '[PRE835]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: '[PRE836]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: '[PRE837]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '[PRE838]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '[PRE839]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: 'The effect of `xmlforest()` can be seen in the resulting XML:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmlforest()` 的效果可以在生成的 XML 中看到：'
- en: '[PRE840]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: '[PRE841]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: '[PRE842]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: '[PRE843]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '[PRE844]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: '[PRE845]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: '[PRE846]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '[PRE847]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: 'If you are a SQL Server fan, then you know that fetching data as XML can be
    done via the non-standard `FOR XML` syntax. jOOQ supports this syntax via the
    `forXml()` API. It also supports clauses such as `ROOT` via `root()`, `PATH` via
    `path()`, `AUTO` via `auto()`, `RAW` via `raw()`, and `ELEMENTS` via `elements()`,
    as you can see in the following example:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 SQL Server 粉丝，那么你知道可以通过非标准的 `FOR XML` 语法来以 XML 格式获取数据。jOOQ 通过 `forXml()`
    API 支持这种语法。它还支持诸如 `ROOT` 通过 `root()`，`PATH` 通过 `path()`，`AUTO` 通过 `auto()`，`RAW`
    通过 `raw()`，以及 `ELEMENTS` 通过 `elements()` 等子句，如下面的示例所示：
- en: '[PRE848]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: '[PRE849]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '[PRE850]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: '[PRE851]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: '[PRE852]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: 'The produced XML looks like this:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 XML 看起来像这样：
- en: '[PRE853]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '[PRE854]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '[PRE855]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: '[PRE856]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: '[PRE857]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: '[PRE858]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: '[PRE859]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '[PRE860]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: '[PRE861]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: '[PRE862]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: '[PRE863]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: '[PRE864]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: '[PRE865]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: '[PRE866]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: '[PRE867]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: '[PRE868]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: Note that missing tags (check the second `<office/>` instance, which does not
    have `<city/>` or `<country/>`) represent missing data.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，缺失的标签（检查第二个 `<office/>` 实例，它没有 `<city/>` 或 `<country/>`）表示缺失的数据。
- en: As a side note, allow me to mention that jOOQ can also transform XML into an
    `org.w3c.dom.Document` by calling a flavor of `intoXML()` on `Record1<XML>`. Moreover,
    you'll love jOOX, or object-oriented XML ([https://github.com/jOOQ/jOOX](https://github.com/jOOQ/jOOX)),
    which can be used to XSL transform or navigate the resulting XML document in a
    jQuery style.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，让我提一下，jOOQ 还可以通过在 `Record1<XML>` 上调用 `intoXML()` 的某个版本将 XML 转换为 `org.w3c.dom.Document`。此外，你还会喜欢
    jOOX，或面向对象的 XML ([https://github.com/jOOQ/jOOX](https://github.com/jOOQ/jOOX))，它可以用来进行
    XSL 转换或以 jQuery 风格导航生成的 XML 文档。
- en: 'I totally agree (sharing his enthusiasm) with Lukas Eder, who states:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全同意（分享他的热情），Lukas Eder 表示：
- en: '*"I don''t know about you, but when I see these examples, I just want to write
    a huge application using jOOQ :) I mean, how else would anyone ever want to query
    databases and produce JSON or XML documents??"*'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '*"我不知道你，但当我看到这些示例时，我只想写一个使用 jOOQ 的巨大应用程序 :) 我的意思是，除了查询数据库并生成 JSON 或 XML 文档，还有其他什么人会有这样的需求？？"*'
- en: You can see these examples (alongside many others) in the bundled code for *SimpleXml*
    and get familiar with the produced XMLs. For now, let's talk about how to order
    and limit the content of the resulting XML.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SimpleXml* 的捆绑代码中看到这些示例（以及许多其他示例），并熟悉生成的 XML。现在，让我们谈谈如何对生成的 XML 内容进行排序和限制。
- en: Using ORDER BY and LIMIT
  id: totrans-1175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ORDER BY 和 LIMIT
- en: 'When we don''t use the `xmlagg()` aggregation operator, ordering and limiting
    is the same as for regular queries. For instance, you can order by `CUSTOMER_NAME`
    and limit the result to three XMLs as follows:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不使用 `xmlagg()` 聚合操作符时，排序和限制与常规查询相同。例如，你可以按 `CUSTOMER_NAME` 排序，并将结果限制为三个 XML，如下所示：
- en: '[PRE869]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: '[PRE870]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: '[PRE871]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: '[PRE872]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: 'On the other hand, when the `xmlagg()` aggregation operator is used, then limiting
    should be done before the aggregation (for instance, in a subquery, `JOIN`, and
    more). Otherwise, this operation will be applied to the resulting aggregation
    itself. During aggregation, ordering can be done before limiting, respectively.
    For instance, in the following example, the subquery orders the customers by `CONTACT_LAST_NAME`
    and limits the returned results to 3, while the aggregation orders this result
    by `CONTACT_FIRST_NAME`:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用 `xmlagg()` 聚合操作符时，限制应该在聚合之前进行（例如，在子查询、`JOIN` 等）。否则，此操作将应用于生成的聚合本身。在聚合过程中，排序可以在限制之前进行。例如，在以下示例中，子查询按
    `CONTACT_LAST_NAME` 排序客户，并将返回的结果限制为 3，而聚合按 `CONTACT_FIRST_NAME` 排序这个结果：
- en: '[PRE873]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: '[PRE874]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: '[PRE875]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: '[PRE876]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: '[PRE877]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: '[PRE878]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: '[PRE879]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: '[PRE880]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: '[PRE881]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: 'The resulted aggregation is ordered by `CUSTOMER_FIRST_NAME`:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果聚合按 `CUSTOMER_FIRST_NAME` 排序：
- en: '[PRE882]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: '[PRE883]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: '[PRE884]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: '[PRE885]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: '[PRE886]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: '[PRE887]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '[PRE888]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: '[PRE889]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: '[PRE890]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: '[PRE891]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: '[PRE892]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: '[PRE893]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: '[PRE894]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: '[PRE895]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: '[PRE896]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: '[PRE897]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: '[PRE898]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: More examples are available in the bundle code for *SimpleXml*. For now, let's
    learn how to query XML documents with XPath.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 *SimpleXml* 的示例可以在捆绑代码中找到。现在，让我们学习如何使用 XPath 查询 XML 文档。
- en: Querying XML documents with XPath
  id: totrans-1210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 XPath 查询 XML 文档
- en: 'Querying XML documents can be done via the XPath expressions, and we can distinguish
    between queries that check for the existence of an element/attribute via `XMLEXISTS`
    (`xmlexists()`) and queries that fetches certain data from an XML document via
    `XMLQUERY` (`xmlquery()`). For instance, in `PRODUCTLINE`, we have a field named
    `HTML_DESCRIPTION` that holds the description of a product line in XML format.
    If a product line has a description, then this description starts with the `<productline/>`
    tag. So, fetching all product lines that have a description can be done via `xmlexists()`,
    as follows:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 XPath 表达式来查询 XML 文档，我们可以区分通过 `XMLEXISTS` (`xmlexists()`) 检查元素/属性存在性的查询和通过
    `XMLQUERY` (`xmlquery()`) 从 XML 文档中获取特定数据的查询。例如，在 `PRODUCTLINE` 中，有一个名为 `HTML_DESCRIPTION`
    的字段，它以 XML 格式保存产品线的描述。如果一个产品线有描述，那么这个描述以 `<productline/>` 标签开始。因此，可以通过 `xmlexists()`
    获取所有有描述的产品线，如下所示：
- en: '[PRE899]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: '[PRE900]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: '[PRE901]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: '[PRE902]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: '[PRE903]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: In `xmlexists("/productline").passing(…)`,`/productline` represents the XPath
    that should be searched, and the argument of the `passing()` method represents
    the XML document (or fragment) in which this XPath is searched.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `xmlexists("/productline").passing(…)` 中，`/productline` 代表要搜索的 XPath，而 `passing()`
    方法的参数代表搜索此 XPath 的 XML 文档（或片段）。
- en: 'On the other hand, the following snippet of code relies on `xmlquery()` to
    fetch an XML containing certain data from `HTML_DESCRIPTION`:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码片段依赖于 `xmlquery()` 从 `HTML_DESCRIPTION` 中获取包含某些数据的 XML：
- en: '[PRE904]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '[PRE905]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: '[PRE906]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: '[PRE907]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: 'Of course, the argument of `passing()` can be an XML build from certain fields,
    too:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`passing()` 的参数也可以是从某些字段构建的 XML：
- en: '[PRE908]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: '[PRE909]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: '[PRE910]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: '[PRE911]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: '[PRE912]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: '[PRE913]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: '[PRE914]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: This query fetches all the `<phone/>` tags from the given XML (for instance,
    `<phone>(26) 642-7555</phone>`). More examples are available in *SimpleXml*. Next,
    let's tackle `XMLTABLE`.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询从给定的 XML 中获取所有 `<phone/>` 标签（例如，`<phone>(26) 642-7555</phone>`）。更多示例可以在
    *SimpleXml* 中找到。接下来，让我们处理 `XMLTABLE`。
- en: Transforming XML values into SQL tables
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 XML 值转换为 SQL 表
- en: 'Transforming XML values into SQL tables can be done via the `XMLTABLE` operator,
    which, in jOOQ, is equivalent to `xmltable()`. For instance, let''s build a SQL
    table containing the details of each product line extracted from `HTML_DESCRIPTION`:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 将 XML 值转换为 SQL 表可以通过 `XMLTABLE` 操作符来完成，在 jOOQ 中，它等同于 `xmltable()`。例如，让我们构建一个包含从
    `HTML_DESCRIPTION` 中提取的每个产品线详细信息的 SQL 表：
- en: '[PRE915]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: '[PRE916]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: '[PRE917]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: '[PRE918]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: '[PRE919]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: '[PRE920]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: '[PRE921]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: '[PRE922]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: '[PRE923]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: 'This query will produce a table as follows:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将生成以下表格：
- en: '![Figure 8.4 – The result of the previous query'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 上一个查询的结果'
- en: '](img/B16833_Figure_8.4.jpg)'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 上一个查询的结果](img/B16833_Figure_8.4.jpg)'
- en: Figure 8.4 – The result of the previous query
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 上一个查询的结果
- en: Once you fetch a SQL table, you can think and act on it in the same way as any
    other database table. For brevity, I simply used `VARCHAR`, but it is better to
    specify a size in order to avoid defaulting to `VARCHAR(max)`.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了 SQL 表，你就可以像处理任何其他数据库表一样思考和操作它。为了简洁，我简单地使用了 `VARCHAR`，但最好指定一个大小，以避免默认为
    `VARCHAR(max)`。
- en: More examples, including how to use `XMLTABLE` with aggregates, `ORDER BY`,
    `LIMIT`, and how to transform back into XML from a SQL table, are available in
    *SimpleXml*.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，包括如何使用 `XMLTABLE` 与聚合、`ORDER BY`、`LIMIT` 以及如何将 SQL 表转换回 XML，可以在 *SimpleXml*
    中找到。
- en: Handling relationships via SQL/XML
  id: totrans-1249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 SQL/XML 处理关系
- en: Handling the typical 1:1, 1:n, and n:n relationships can be done via jOOQ SQL/XML
    support. Let's go through a quick rundown of it.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 jOOQ SQL/XML 支持处理典型的 1:1、1:n 和 n:n 关系。让我们快速了解一下。
- en: Mapping relationships to XML
  id: totrans-1251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将关系映射到 XML
- en: 'Most of the time, such relationships can be materialized into XML via a thoughtful
    combination of `xmlelement()`, `xmlagg()`, and `xmlforest()`. Since you are already
    familiar with the one-to-many relationship between `PRODUCTLINE` and `PRODUCT`,
    let''s shape it into XML via SQL/XML support:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这些关系可以通过 `xmlelement()`、`xmlagg()` 和 `xmlforest()` 的深思熟虑的组合来实体化为 XML。由于你已经熟悉
    `PRODUCTLINE` 和 `PRODUCT` 之间的一对多关系，让我们通过 SQL/XML 支持将其塑造成 XML：
- en: '[PRE924]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: '[PRE925]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: '[PRE926]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: '[PRE927]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: '[PRE928]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: '[PRE929]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: '[PRE930]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: '[PRE931]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: '[PRE932]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '[PRE933]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: '[PRE934]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: '[PRE935]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: '[PRE936]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: As you can infer from the preceding code, expressing the one-to-one and many-to-many
    relationships is just a matter of juggling with the SQL/XML operators. You can
    find these examples, including how to use `JOIN` instead of a `SELECT` subquery,
    in the bundled code for *XmlRelationships*.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以推断出表达一对一和多对多关系只是通过 SQL/XML 操作符进行操作的问题。你可以在 *XmlRelationships* 的捆绑代码中找到这些示例，包括如何使用
    `JOIN` 而不是 `SELECT` 子查询。
- en: 'If you think that `Result<Record1<XML>>` is not ready to be sent to the client
    (for instance, via a REST controller), then decorate it a little bit more by aggregating
    all the product lines under a XML element (root) and relying on `fetchSingleInto()`,
    as follows:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为 `Result<Record1<XML>>` 还没有准备好发送给客户端（例如，通过 REST 控制器），那么可以通过将所有产品行聚合到一个
    XML 元素（根元素）下并依赖 `fetchSingleInto()` 来稍微装饰一下，如下所示：
- en: '[PRE937]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: '[PRE938]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: '[PRE939]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: '[PRE940]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '[PRE941]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: 'In SQL Server, we can obtain a similar result via `forXml()`:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中，我们可以通过 `forXml()` 获取类似的结果：
- en: '[PRE942]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: '[PRE943]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: '[PRE944]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: '[PRE945]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: '[PRE946]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: '[PRE947]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: '[PRE948]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: '[PRE949]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: '[PRE950]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: '[PRE951]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: '[PRE952]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: '[PRE953]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: 'Or we can obtain a `String` via `formatXML(XMLformat)`:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过 `formatXML(XMLformat)` 获取一个 `String`：
- en: '[PRE954]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: '[PRE955]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: '[PRE956]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: '[PRE957]'
  id: totrans-1290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: '[PRE958]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: '[PRE959]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: 'Both examples will produce almost an identical XML, as follows (as you can
    see, altering the default XML tags inferred from the field names can be done with
    aliases via `as("alias")`):'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例将产生几乎相同的 XML，如下所示（正如你所见，可以通过别名 `as("alias")` 来更改从字段名推断出的默认 XML 标签）：
- en: '[PRE960]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: '[PRE961]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: '[PRE962]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: '[PRE963]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: '[PRE964]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: '[PRE965]'
  id: totrans-1299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: '[PRE966]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '[PRE967]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: '[PRE968]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: '[PRE969]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: '[PRE970]'
  id: totrans-1304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: '[PRE971]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: '[PRE972]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: '[PRE973]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: '[PRE974]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: '[PRE975]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: '[PRE976]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: '[PRE977]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: '[PRE978]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: '[PRE979]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: '[PRE980]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: You can check out these examples in the *XmlRelationships* application.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *XmlRelationships* 应用程序中查看这些示例。
- en: Mapping arbitrary nested models
  id: totrans-1316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射任意嵌套模型
- en: 'jOOQ allows us to map arbitrarily nested models, not just the well-known 1:1,1:n,
    and n:n relationships, via SQL/XML support. Remember **Model 2** (see *Figure
    8.3*)? Well, you already know how to fetch and map that model via SQL/JSON support,
    so this time, let''s see how it can be done via SQL/XML:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 允许我们通过 SQL/XML 支持，将任意嵌套的模型映射，而不仅仅是众所周知的 1:1、1:n 和 n:n 关系。还记得 **模型 2**（见
    *图 8.3*）吗？好吧，你已经知道如何通过 SQL/JSON 支持来获取和映射该模型，所以这次，让我们看看它是如何通过 SQL/XML 来实现的：
- en: '[PRE981]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: '[PRE982]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: '[PRE983]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: '[PRE984]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: '[PRE985]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: '[PRE986]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: '[PRE987]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: '[PRE988]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: '[PRE989]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: '[PRE990]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: '[PRE991]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: '[PRE992]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: '[PRE993]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: '[PRE994]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: '[PRE995]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: '[PRE996]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: '[PRE997]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: '[PRE998]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: '[PRE999]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: '[PRE1000]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: '[PRE1001]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: '[PRE1002]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: '[PRE1003]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: '[PRE1004]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: '[PRE1005]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: '[PRE1006]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: '[PRE1007]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: This is the power of example; there is not much else to say. Take your time
    to dissect this query, and check out the bundled code to see the output. Moreover,
    in the bundled code, you can see **Model 1** and **Model 3**, too. The application
    is named *NestedXml*.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是示例的力量；没有太多其他可说的。花点时间剖析这个查询，并查看捆绑的代码以查看输出。此外，在捆绑的代码中，你还可以看到 **模型 1** 和 **模型
    3**。应用程序名为 *NestedXml*。
- en: 'As a SQL Server fan, you might be more interested in the previous query expressed
    via `forXML()`, so here it is:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 SQL Server 的粉丝，你可能对通过 `forXML()` 表达的先前查询更感兴趣，所以这里就是：
- en: '[PRE1008]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: '[PRE1009]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: '[PRE1010]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: '[PRE1011]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: '[PRE1012]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: '[PRE1013]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: '[PRE1014]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: '[PRE1015]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: '[PRE1016]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: '[PRE1017]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: '[PRE1018]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: '[PRE1019]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: '[PRE1020]'
  id: totrans-1359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: '[PRE1021]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: '[PRE1022]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: '[PRE1023]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: '[PRE1024]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: '[PRE1025]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: '[PRE1026]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: '[PRE1027]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: '[PRE1028]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: '[PRE1029]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: '[PRE1030]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: In the bundled code, *NestedXml*, you can practice many more examples that,
    for brevity reasons, couldn't be listed here. Remember that, especially for this
    chapter, I beat the drums. Now, it is time to bring in an entire orchestra and
    pay tribute to the coolest feature of jOOQ mapping. Ladies and gentlemen, allow
    me to introduce the MULTISET!
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码 *NestedXml* 中，你可以练习更多示例，由于篇幅原因，这里没有列出。记住，特别是对于这一章，我已经敲响了鼓。现在，是时候引入一个完整的乐团，向
    jOOQ 映射的最酷特性致敬了。女士们，先生们，请允许我介绍 MULTISET！
- en: Nested collections via the astonishing MULTISET
  id: totrans-1371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过惊人的 MULTISET 实现嵌套集合
- en: The MULTISET value constructor (or MULTISET for short) is a SQL standard future
    that shapes nested subqueries (except scalar subqueries) into a single nested
    collection value. jOOQ 3.15+ provides marvelous and glorious support for MULTISET.
    It's marvelous because despite its tremendous power, it is quite easy (effortless)
    and intuitive to use via jOOQ, and it is glorious because it can produce any nested
    collection value of jOOQ `Record` or DTO (POJO/Java records) in a fully type-safe
    manner, with 0 reflections, no N+1 risks, no deduplications. This allows the database
    to perform nesting and to optimize the query execution plan.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: MULTISET 值构造器（或简称 MULTISET）是 SQL 标准的未来，它将嵌套子查询（除了标量子查询）塑造成单个嵌套集合值。jOOQ 3.15+
    提供了令人惊叹和辉煌的 MULTISET 支持。它之所以令人惊叹，是因为尽管它拥有巨大的力量，但通过 jOOQ 使用它却非常简单（轻松）且直观；它之所以辉煌，是因为它可以以完全类型安全的方式，无需反射、无
    N+1 风险、无重复地产生 jOOQ `Record` 或 DTO（POJO/Java 记录）的任何嵌套集合值。这允许数据库执行嵌套并优化查询执行计划。
- en: 'Consider the well-known one-to-many relationship between `PRODUCTLINE` and
    `PRODUCT`. We can fetch and map this relationship via jOOQ''s `<R extends Record>
    Field<Result<R>> multiset(Select<R> select)`, in jOOQ before 3.17.x, and `Field<Result<R>>`
    `multiset(TableLike<R> table)` starting with jOOQ 3.17.x as follows (later, we
    will refer to this example as *Exhibit A*):'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下`PRODUCTLINE`和`PRODUCT`之间众所周知的一对多关系。我们可以通过jOOQ的`<R extends Record> Field<Result<R>>
    multiset(Select<R> select)`在jOOQ 3.17.x之前获取和映射这个关系，以及从jOOQ 3.17.x开始的`Field<Result<R>>
    multiset(TableLike<R> table)`，如下所示（稍后我们将把这个示例称为*展示A*）：
- en: '[PRE1031]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: '[PRE1032]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: '[PRE1033]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: '[PRE1034]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: '[PRE1035]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: '[PRE1036]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: '[PRE1037]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: '[PRE1038]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: '[PRE1039]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: '[PRE1040]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: '[PRE1041]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1041]'
- en: '[PRE1042]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1042]'
- en: 'So, the usage is quite simple! The jOOQ `multiset()` constructor gets a `SELECT`
    statement as an argument(or, a table-like object, starting with jOOQ 3.17.x).
    Formally speaking, the result set of this `SELECT` statement represents a collection
    that will be nested in the outer collection (the result set produced by the outer
    `SELECT` statement). By nesting/mixing `multiset()` and `select()` (or `selectDistinct()`),
    we can achieve any level or shape/hierarchy of nested collections. Previously,
    we used the Java 10 `var` keyword as the type of result, but the real type is
    `Result<Record3<String, String, Result<Record3<String, String, Integer>>>>`. Of
    course, more nesting will produce a really hard-to-digest `Result` object, so
    using `var` is the recommended way to go. As you already intuited, `Result<Record3<String,
    String, Integer>>` is produced by the `SELECT` statement from `multiset()`, while
    `Result<Record3<String, String, nested_result>>` is produced by the outer `SELECT`
    statement. The following diagram will help you to better understand this type:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用方法非常简单！jOOQ的`multiset()`构造函数接受一个`SELECT`语句作为参数（或者，从jOOQ 3.17.x开始，一个类似表的对象）。从形式上来说，这个`SELECT`语句的结果集代表一个将在外部集合（由外部`SELECT`语句产生的结果集）中嵌套的集合。通过嵌套/混合`multiset()`和`select()`（或`selectDistinct()`），我们可以实现任何级别或形状/层次结构的嵌套集合。之前，我们使用了Java
    10的`var`关键字作为结果类型的类型，但实际类型是`Result<Record3<String, String, Result<Record3<String,
    String, Integer>>>>`。当然，更多的嵌套会产生一个真正难以理解的`Result`对象，所以使用`var`是推荐的做法。如您所直觉到的，`Result<Record3<String,
    String, Integer>>`是由`multiset()`中的`SELECT`语句产生的，而`Result<Record3<String, String,
    nested_result>>`是由外部`SELECT`语句产生的。以下图表将帮助您更好地理解这个类型：
- en: '![Figure 8.5 – The type returned by the previous query'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 上一个查询返回的类型](img/B16833_Figure_8.5.jpg)'
- en: '](img/B16833_Figure_8.5.jpg)'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5](img/B16833_Figure_8.5.jpg)'
- en: Figure 8.5 – The type returned by the previous query
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 上一个查询返回的类型
- en: 'Since MULTISET has quite poor native support in databases, jOOQ has to emulate
    it via the SQL/JSON or SQL/XML operators. For instance, the previous query renders
    the following SQL in MySQL (check out how jOOQ uses `json_merge_preserve()` and
    `json_array()`):'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库中MULTISET的原生支持相当差，jOOQ必须通过SQL/JSON或SQL/XML运算符来模拟它。例如，前面的查询在MySQL中渲染出以下SQL（查看jOOQ如何使用`json_merge_preserve()`和`json_array()`）：
- en: '[PRE1043]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1043]'
- en: '[PRE1044]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1044]'
- en: '[PRE1045]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1045]'
- en: '[PRE1046]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1046]'
- en: '[PRE1047]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1047]'
- en: '[PRE1048]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1048]'
- en: '[PRE1049]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1049]'
- en: '[PRE1050]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1050]'
- en: '[PRE1051]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1051]'
- en: '[PRE1052]'
  id: totrans-1400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1052]'
- en: '[PRE1053]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1053]'
- en: '[PRE1054]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1054]'
- en: '[PRE1055]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1055]'
- en: '[PRE1056]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1056]'
- en: '[PRE1057]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1057]'
- en: '[PRE1058]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1058]'
- en: '[PRE1059]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1059]'
- en: '[PRE1060]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1060]'
- en: At any moment, you can transform this collection of `Record` into plain JSON
    or XML via `formatJSON()`/`formatXML()`. However, allow me to take this opportunity
    to highlight that if all you want is to fetch a JSON/XML (since this is what your
    client needs), then it is better to use the SQL/JSON and SQL/XML operators directly
    (as you saw in the previous section) instead of passing through MULTISET. You
    can find examples in the bundled code, *MultisetRelationships*, alongside examples
    of how to use MULTISET for one-to-one and many-to-many relationships. In the example
    for many-to-many relationships, you can see how well the jOOQ type-safe implicit
    (one-to-one) join feature fits with MULTISET.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，您都可以通过`formatJSON()`/`formatXML()`将这个`Record`集合转换成普通的JSON或XML格式。然而，请允许我借此机会强调，如果您只想获取JSON/XML（因为这是您的客户端需要的），那么直接使用SQL/JSON和SQL/XML运算符（如前文所述）比通过MULTISET传递更好。您可以在捆绑的代码中找到示例，例如在`MultisetRelationships`中，以及如何使用MULTISET进行一对一和多对多关系的示例。在多对多关系的示例中，您可以看到jOOQ类型安全的隐式（一对一）连接功能与MULTISET配合得多么好。
- en: 'Remember **Model 2** (see *Figure 8.3*)? Well, you already know how to fetch
    and map that model via SQL/JSON and SQL/XML support, so let''s see how to do it
    via MULTISET, too (later on, we will refer to this example as *Exhibit B*):'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 记得**模型2**（见*图8.3*）吗？好吧，您已经知道如何通过SQL/JSON和SQL/XML支持获取和映射该模型，那么让我们看看如何通过MULTISET来做这件事（稍后我们将把这个示例称为*展示B*）：
- en: '[PRE1061]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1061]'
- en: '[PRE1062]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1062]'
- en: '[PRE1063]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1063]'
- en: '[PRE1064]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1064]'
- en: '[PRE1065]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1065]'
- en: '[PRE1066]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1066]'
- en: '[PRE1067]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1067]'
- en: '[PRE1068]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1068]'
- en: '[PRE1069]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1069]'
- en: '[PRE1070]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1070]'
- en: '[PRE1071]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1071]'
- en: '[PRE1072]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1072]'
- en: '[PRE1073]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1073]'
- en: '[PRE1074]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1074]'
- en: '[PRE1075]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1075]'
- en: '[PRE1076]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1076]'
- en: '[PRE1077]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1077]'
- en: '[PRE1078]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1078]'
- en: '[PRE1079]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1079]'
- en: '[PRE1080]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1080]'
- en: '[PRE1081]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1081]'
- en: '[PRE1082]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1082]'
- en: '[PRE1083]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1083]'
- en: '[PRE1084]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1084]'
- en: '[PRE1085]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1085]'
- en: 'This time, the returned type is quite verbose: `Result<Record4<String, BigDecimal,
    Result<Record4<Long, BigDecimal, LocalDateTime, Result<Record2<String, BigDecimal>>>>,
    Result<Record3<String, String, String>>>>`. The following diagram explains this:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，返回的类型相当冗长：`Result<Record4<String, BigDecimal, Result<Record4<Long, BigDecimal,
    LocalDateTime, Result<Record2<String, BigDecimal>>>>, Result<Record3<String, String,
    String>>>>`。以下图表解释了这一点：
- en: '![Figure 8.6 – The type returned by the previous query'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 上一个查询返回的类型'
- en: '](img/B16833_Figure_8.6.jpg)'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_8.6.jpg)'
- en: Figure 8.6 – The type returned by the previous query
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 上一个查询返回的类型
- en: You can find this example next to Model 1 and Model 3 in the application named
    *NestedMultiset*. Next, let's see how we can map MULTISET to DTO (for instance,
    POJO and Java 16 records).
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为 *NestedMultiset* 的应用程序中找到这个例子，与模型 1 和模型 3 一起。接下来，让我们看看如何将 MULTISET 映射到
    DTO（例如，POJO 和 Java 16 记录）。
- en: Mapping MULTISET to DTO
  id: totrans-1441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 MULTISET 映射到 DTO
- en: 'Having the result of a MULTISET as a generic structural type is cool, but most
    probably, you''ll love to have a `List` of POJO/Java records instead. For instance,
    if we think of *Exhibit A*, then you''ll probably write the following Java records
    as the mapping model:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MULTISET 的结果作为通用结构类型是很有趣的，但很可能是你更喜欢有一个 POJO/Java 记录的 `List`。例如，如果我们考虑 *展示
    A*，那么你可能会编写以下 Java 记录作为映射模型：
- en: '[PRE1086]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1086]'
- en: '[PRE1087]'
  id: totrans-1444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1087]'
- en: '[PRE1088]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1088]'
- en: '[PRE1089]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1089]'
- en: 'So, you''re expecting that `Result<Record3<String, String, Integer>>` will
    be fetched via MULTISET to be mapped to `List<RecordProduct>` and the whole query
    result to `List<RecordProductLine>`. The first part can be accomplished via the
    new ad hoc `Field.convertFrom()` converter, which was introduced in [*Chapter
    7*](B16833_07.xhtml#_idTextAnchor110), *Types, Converters, and Bindings*. With
    `Field.convertFrom()`, we convert the given `Field<T>` (here, `Field<Result<Record3<String,
    String, Integer>>>` is returned by `multiset()`) into a read-only `Field<U>` (here,
    `Field<List<RecordProduct>>`) for ad hoc usage:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你期望 `Result<Record3<String, String, Integer>>` 将通过 MULTISET 获取并映射到 `List<RecordProduct>`，整个查询结果到
    `List<RecordProductLine>`。第一部分可以通过新引入的 ad hoc `Field.convertFrom()` 转换器完成，该转换器在
    [*第 7 章*](B16833_07.xhtml#_idTextAnchor110) 中介绍，*类型、转换器和绑定*。使用 `Field.convertFrom()`，我们将给定的
    `Field<T>`（在这里，`Field<Result<Record3<String, String, Integer>>>` 由 `multiset()`
    返回）转换为只读 `Field<U>`（在这里，`Field<List<RecordProduct>>`），用于 ad hoc 使用：
- en: '[PRE1090]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1090]'
- en: '[PRE1091]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1091]'
- en: '[PRE1092]'
  id: totrans-1450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1092]'
- en: '[PRE1093]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1093]'
- en: '[PRE1094]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1094]'
- en: '[PRE1095]'
  id: totrans-1453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1095]'
- en: '[PRE1096]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1096]'
- en: The `r` parameter from `r -> r.map(mapping(RecordProduct::new))` is `Result<Record3<String,
    String, Integer>>`, so this lambda can be seen as `Result<Record3<String, String,
    Integer>> -> RecordProduct`. The `r.map(…)` part is the `Result.map(RecordMapper<R,
    E>)` method. Finally, the `Records.mapping()` method (introduced earlier in this
    chapter) turns the constructor reference of the `Function3<String, String, Integer,
    RecordProduct>` type into a `RecordMapper` parameter, which is further used to
    turn a `Result<Record3<String, String, Integer>>` into a `List<RecordProduct>`.
    The resulting `Field<List<SimpleProduct>>` (which is like any other jOOQ `Field`)
    is now part of the outer `SELECT` next to `PRODUCTLINE.PRODUCT_LINE` (which is
    a `String`), and `PRODUCTLINE.TEXT_DESCRIPTION` (which is also a `String`).
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '`r -> r.map(mapping(RecordProduct::new))` 中的 `r` 参数是 `Result<Record3<String,
    String, Integer>>`，因此这个 lambda 可以看作是 `Result<Record3<String, String, Integer>>
    -> RecordProduct`。`r.map(…)` 部分是 `Result.map(RecordMapper<R, E>)` 方法。最后，本章前面介绍的
    `Records.mapping()` 方法将 `Function3<String, String, Integer, RecordProduct>` 类型的构造器引用转换为
    `RecordMapper` 参数，该参数进一步用于将 `Result<Record3<String, String, Integer>>` 转换为 `List<RecordProduct>`。结果
    `Field<List<SimpleProduct>>`（类似于任何其他 jOOQ `Field`）现在是外层 `SELECT` 中 `PRODUCTLINE.PRODUCT_LINE`（它是一个
    `String`）和 `PRODUCTLINE.TEXT_DESCRIPTION`（它也是一个 `String`）的一部分。'
- en: 'So, our last mission is to convert the outer-most `Result3<String, String,
    List<RecordProduct>>` into `List<RecordProductLine>`. For this, we rely only on
    `mapping()`, as follows:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最后的任务是转换最外层的 `Result3<String, String, List<RecordProduct>>` 到 `List<RecordProductLine>`。为此，我们仅依赖于
    `mapping()`，如下所示：
- en: '[PRE1097]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1097]'
- en: '[PRE1098]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1098]'
- en: '[PRE1099]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1099]'
- en: '[PRE1100]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1100]'
- en: '[PRE1101]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1101]'
- en: '[PRE1102]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1102]'
- en: '[PRE1103]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1103]'
- en: '[PRE1104]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1104]'
- en: '[PRE1105]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1105]'
- en: '[PRE1106]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1106]'
- en: '[PRE1107]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1107]'
- en: '[PRE1108]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1108]'
- en: 'Done! Now, we can manipulate the `List<RecordProductLine>`. You can find this
    example in *MultisetRelationshipsInto*. By applying what we''ve learned here to
    the more complex *Exhibit B*, we obtain the following model:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以操作 `List<RecordProductLine>`。你可以在 *MultisetRelationshipsInto* 中找到这个例子。通过将我们在这里学到的知识应用到更复杂的
    *展示 B* 中，我们得到以下模型：
- en: '[PRE1109]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1109]'
- en: '[PRE1110]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1110]'
- en: '[PRE1111]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1111]'
- en: '[PRE1112]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1112]'
- en: '[PRE1113]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1113]'
- en: '[PRE1114]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1114]'
- en: '[PRE1115]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1115]'
- en: '[PRE1116]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1116]'
- en: '[PRE1117]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1117]'
- en: '[PRE1118]'
  id: totrans-1479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1118]'
- en: 'And the *Exhibit B* query is as follows:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 而 *展示 B* 查询如下：
- en: '[PRE1119]'
  id: totrans-1481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1119]'
- en: '[PRE1120]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1120]'
- en: '[PRE1121]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1121]'
- en: '[PRE1122]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1122]'
- en: '[PRE1123]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1123]'
- en: '[PRE1124]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1124]'
- en: '[PRE1125]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1125]'
- en: '[PRE1126]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1126]'
- en: '[PRE1127]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1127]'
- en: '[PRE1128]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1128]'
- en: '[PRE1129]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1129]'
- en: '[PRE1130]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1130]'
- en: '[PRE1131]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1131]'
- en: '[PRE1132]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1132]'
- en: '[PRE1133]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1133]'
- en: '[PRE1134]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1134]'
- en: '[PRE1135]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1135]'
- en: '[PRE1136]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1136]'
- en: '[PRE1137]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1137]'
- en: '[PRE1138]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1138]'
- en: '[PRE1139]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1139]'
- en: '[PRE1140]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1140]'
- en: '[PRE1141]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1141]'
- en: '[PRE1142]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1142]'
- en: '[PRE1143]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1143]'
- en: '[PRE1144]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1144]'
- en: '[PRE1145]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1145]'
- en: '[PRE1146]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1146]'
- en: '[PRE1147]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1147]'
- en: This example, next to the examples for Model 1 and Model 3 from *Figure 8.3*,
    is available in *NestedMultiset*. Next, let's tackle the `MULTISET_AGG()` function.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子，与 *图 8.3* 中的模型 1 和模型 3 的例子一起，可以在 *NestedMultiset* 中找到。接下来，让我们解决 `MULTISET_AGG()`
    函数。
- en: The MULTISET_AGG() function
  id: totrans-1511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MULTISET_AGG() 函数
- en: 'The jOOQ `MULTISET_AGG()` function is a synthetic aggregate function that can
    be used as an alternative to MULTISET. Its goal is to aggregate data into a nested
    collection represented as a jOOQ `Result` in a type-safe manner. The `MULTISET_AGG()`
    function is a convenient solution when we need to order by some aggregate value
    or create a `WHERE` statement based on result of not-deeply nested collection.
    For instance, the well-known one-to-many `PRODUCTLINE`:`PRODUCT` relationship
    can be aggregated as a nested collection as follows (the result type is `Result<Record3<String,
    String, Result<Record3<String, String, Integer>>>>`):'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 的 `MULTISET_AGG()` 函数是一个合成聚合函数，可以用作 MULTISET 的替代品。其目标是以类型安全的方式将数据聚合到一个表示为
    jOOQ `Result` 的嵌套集合中。当我们需要按某些聚合值排序或基于非深层嵌套集合的结果创建 `WHERE` 语句时，`MULTISET_AGG()`
    函数是一个方便的解决方案。例如，众所周知的一对多 `PRODUCTLINE`:`PRODUCT` 关系可以如下聚合为一个嵌套集合（结果类型为 `Result<Record3<String,
    String, Result<Record3<String, String, Integer>>>>`）：
- en: Starting with jOOQ 3.17.x, we can turn an expression of type `String`, `Name`,
    `Field`, and so in, into a multiset via `DSL.asMultiset()` methods. Check out
    the jOOQ documentation for more details.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 从 jOOQ 3.17.x 版本开始，我们可以通过 `DSL.asMultiset()` 方法将类型为 `String`、`Name`、`Field`
    等的表达式转换为多重集。查看 jOOQ 文档以获取更多详细信息。
- en: '[PRE1148]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1148]'
- en: '[PRE1149]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1149]'
- en: '[PRE1150]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1150]'
- en: '[PRE1151]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1151]'
- en: '[PRE1152]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1152]'
- en: '[PRE1153]'
  id: totrans-1519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1153]'
- en: '[PRE1154]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1154]'
- en: '[PRE1155]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1155]'
- en: '[PRE1156]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1156]'
- en: '[PRE1157]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1157]'
- en: '[PRE1158]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1158]'
- en: This example is available, along with more examples, in *MultisetAggRelationships*.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例与其他更多示例一起在 *MultisetAggRelationships* 中提供。
- en: 'Mapping the `Result` object to a DTO (for instance, POJO and Java 16 records)
    is accomplished by following the same principles as in the case of MULTISET:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Result` 对象映射到 DTO（例如，POJO 和 Java 16 记录）是通过遵循与 MULTISET 相同的原则来完成的：
- en: '[PRE1159]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1159]'
- en: '[PRE1160]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1160]'
- en: '[PRE1161]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1161]'
- en: '[PRE1162]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1162]'
- en: '[PRE1163]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1163]'
- en: '[PRE1164]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1164]'
- en: '[PRE1165]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1165]'
- en: '[PRE1166]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1166]'
- en: '[PRE1167]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1167]'
- en: '[PRE1168]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1168]'
- en: '[PRE1169]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1169]'
- en: '[PRE1170]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1170]'
- en: This example is available alongside other examples in *MultisetAggRelationshipsInto*.
    Next, let's try to compare MULTISETs.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例与其他示例一起在 *MultisetAggRelationshipsInto* 中提供。接下来，让我们尝试比较多重集。
- en: Comparing MULTISETs
  id: totrans-1540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较多重集（MULTISETs）
- en: 'MULTISETs can be used in predicates, too. Check out the following example:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 多重集也可以用于谓词中。查看以下示例：
- en: '[PRE1171]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1171]'
- en: '[PRE1172]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1172]'
- en: '[PRE1173]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1173]'
- en: '[PRE1174]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1174]'
- en: '[PRE1175]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1175]'
- en: '[PRE1176]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1176]'
- en: '[PRE1177]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1177]'
- en: '[PRE1178]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1178]'
- en: '[PRE1179]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1179]'
- en: 'But when we can say that two MULTISETs are equal? Check out the following examples
    that are meant to clarify this:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们何时可以说两个多重集是相等的？查看以下旨在阐明此点的示例：
- en: '[PRE1180]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1180]'
- en: '[PRE1181]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1181]'
- en: '[PRE1182]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1182]'
- en: '[PRE1183]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1183]'
- en: '[PRE1184]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1184]'
- en: '[PRE1185]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1185]'
- en: '[PRE1186]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1186]'
- en: '[PRE1187]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1187]'
- en: '[PRE1188]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1188]'
- en: '[PRE1189]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1189]'
- en: '[PRE1190]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1190]'
- en: '[PRE1191]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1191]'
- en: '[PRE1192]'
  id: totrans-1564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1192]'
- en: '[PRE1193]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1193]'
- en: '[PRE1194]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1194]'
- en: '[PRE1195]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1195]'
- en: '[PRE1196]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1196]'
- en: '[PRE1197]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1197]'
- en: '[PRE1198]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1198]'
- en: '[PRE1199]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1199]'
- en: '[PRE1200]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1200]'
- en: '[PRE1201]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1201]'
- en: '[PRE1202]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1202]'
- en: So, which of A, B, C, and D will return 1? The correct answer is A and C. This
    means that two MULTISETs are equal if they have the exactly same number of elements
    in the same order. The application is named *MultisetComparing*. Feel free to
    determine when a MULTISET X is greater/lesser/contained … than a MULTISET Y.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，A、B、C 和 D 中哪一个会返回 1？正确答案是 A 和 C。这意味着如果两个多重集具有相同顺序的相同元素数量，则这两个多重集是相等的。该应用程序名为
    *MultisetComparing*。请随意确定当多重集 X 大于/小于/包含…多重集 Y 的时间。
- en: Also, don't forget to read [https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/](https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/)
    and [https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/](https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/).
    It looks as though jOOQ 3.17 will enrich MULTISET support with even more cool
    features, [https://twitter.com/JavaOOQ/status/1493261571103105030](https://twitter.com/JavaOOQ/status/1493261571103105030),
    so stay tuned!
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了阅读 [https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/](https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/)
    和 [https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/](https://blog.jooq.org/the-performance-of-various-to-many-nesting-algorithms/)。看起来
    jOOQ 3.17 将通过更多酷炫的功能丰富 MULTISET 支持，[https://twitter.com/JavaOOQ/status/1493261571103105030](https://twitter.com/JavaOOQ/status/1493261571103105030)，所以请保持关注！
- en: Moreover, since `MULTISET` and `MULTISET_AGG()` are such hot topics you should
    constantly update your skills from real scenarios exposed at [https://stackoverflow.com/search?q=%5Bjooq%5D+multiset](https://stackoverflow.com/search?q=%5Bjooq%5D+multiset).
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 `MULTISET` 和 `MULTISET_AGG()` 是如此热门的话题，你应该从 [https://stackoverflow.com/search?q=%5Bjooq%5D+multiset](https://stackoverflow.com/search?q=%5Bjooq%5D+multiset)
    中公开的实际场景不断更新你的技能。
- en: Next, let's talk about lazy fetching.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈延迟加载。
- en: Lazy fetching
  id: totrans-1579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载
- en: 'Hibernate JPA guy: So, how do you handle huge result sets in jOOQ?'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate JPA 人员：那么，你是如何处理 jOOQ 中的大量结果集的？
- en: 'jOOQ guy (me): jOOQ supports lazy fetching.'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 人员（我）：jOOQ 支持延迟加载。
- en: 'Hibernate JPA guy: And how do you manage `LazyInitializationException`?'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate JPA 人员：那么你是如何管理 `LazyInitializationException` 的？
- en: 'jOOQ guy (me): For Hibernate JPA users that have just got here, I''d like to
    stress this right from the start – don''t assume that jOOQ lazy fetching is related
    to or similar to Hibernate JPA lazy loading. jOOQ doesn''t have and doesn''t need
    a Persistence Context and doesn''t rely on a `Session` object and proxy objects.
    Your code is not prone to any kind of lazy loading exceptions!'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 的人（就是我）：对于刚刚加入 Hibernate JPA 的新用户，我想从一开始就强调这一点——不要假设 jOOQ 懒加载与 Hibernate
    JPA 懒加载相关或类似。jOOQ 没有也不需要 Persistence Context，也不依赖于 `Session` 对象和代理对象。你的代码不会受到任何类型的懒加载异常的影响！
- en: Then, what is jOOQ lazy fetching?
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，jOOQ 懒加载是什么？
- en: 'Well, most of the time, fetching the entire result set into memory is the best
    way to exploit your RDBMS (especially in web applications that face high traffic
    by optimizing small result sets and short transactions). However, there are cases
    (for instance, you might have a huge result set) when you''ll like to fetch and
    process the result set in small chunks (for example, one by one). For such scenarios,
    jOOQ comes with the `org.jooq.Cursor` API. Practically, jOOQ holds a reference
    to an open result set and allows you to iterate (that is, load and process into
    memory) the result set via a number of methods such as `fetchNext()`, `fetchNextOptional()`,
    `fetchNextInto()`, and `fetchNextOptionalInto()`. However, to get a reference
    to an open result set, we have to call the `fetchLazy()` method, as shown in the
    following examples:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，大多数情况下，将整个结果集加载到内存中是充分利用 RDBMS 的最佳方式（尤其是在通过优化小结果集和短事务来应对高流量的 Web 应用程序中）。然而，在某些情况下（例如，你可能有一个巨大的结果集），你可能希望分小块（例如，逐个）获取和处理结果集。对于此类场景，jOOQ
    提供了 `org.jooq.Cursor` API。实际上，jOOQ 持有一个打开的结果集的引用，并允许你通过 `fetchNext()`、`fetchNextOptional()`、`fetchNextInto()`
    和 `fetchNextOptionalInto()` 等多种方法迭代（即加载并处理到内存中）结果集。然而，要获取一个打开的结果集的引用，我们必须调用 `fetchLazy()`
    方法，如下面的示例所示：
- en: '[PRE1203]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1203]'
- en: '[PRE1204]'
  id: totrans-1587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1204]'
- en: '[PRE1205]'
  id: totrans-1588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1205]'
- en: '[PRE1206]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1206]'
- en: '[PRE1207]'
  id: totrans-1590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1207]'
- en: '[PRE1208]'
  id: totrans-1591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1208]'
- en: '[PRE1209]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1209]'
- en: Notice that we are relying on the try-with-resources wrapping to ensure that
    the underlying result set is closed at the end of the iterating process. In this
    snippet of code, jOOQ fetches the records from the underlying result set into
    memory one by one via `fetchNext()`, but this doesn't mean that the JDBC driver
    does the same thing. JDBC drivers act differently across different database vendors
    and even across different versions of the same database. For instance, MySQL and
    PostgreSQL pre-fetches all records in a single database round-trip, SQL Server
    uses adaptive buffering (in the JDBC URL, we have `selectMethod = direct; responseBuffering
    = adaptive;`) and a default fetch size of 128 to avoid out-of-memory errors, and
    Oracle JDBC fetches a result set of 10 rows at a time from the database cursor
    (on the JDBC URL level, this can be altered via the `defaultRowPrefetch` property).
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们依赖于 try-with-resources 包装来确保在迭代过程结束时关闭底层的结果集。在这个代码片段中，jOOQ 通过 `fetchNext()`
    方法逐个将记录从底层结果集提取到内存中，但这并不意味着 JDBC 驱动程序会做同样的事情。不同的数据库供应商以及同一数据库的不同版本之间，JDBC 驱动程序的行为可能不同。例如，MySQL
    和 PostgreSQL 在单个数据库往返中预取所有记录，SQL Server 使用自适应缓冲（在 JDBC URL 中，我们有 `selectMethod
    = direct; responseBuffering = adaptive;`）和默认的 fetch size 为 128 以避免内存溢出错误，而 Oracle
    JDBC 从数据库游标中每次获取 10 行结果集（在 JDBC URL 级别，这可以通过 `defaultRowPrefetch` 属性来更改）。
- en: Important Note
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Bear in mind that the fetch size is just a JDBC hint trying to instruct the
    driver about the number of rows to fetch in one go from the database. However,
    the JDBC driver is free to ignore this hint.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，fetch size 只是一个 JDBC 提示，旨在指导驱动程序从数据库一次性获取的行数。然而，JDBC 驱动程序可以自由忽略这个提示。
- en: 'In jOOQ, configuring the fetch size can be done via `ResultQuery.fetchSize(int
    size)` or `Settings.withFetchSize(int size)`. jOOQ uses this configuration to
    set the underlying `Statement.setFetchSize(int size)` JDBC. Most JDBC drivers
    only apply this setting in certain contexts. For instance, MySQL should only apply
    this setting if we do the following:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，可以通过 `ResultQuery.fetchSize(int size)` 或 `Settings.withFetchSize(int
    size)` 来配置 fetch size。jOOQ 使用此配置来设置底层的 `Statement.setFetchSize(int size)` JDBC。大多数
    JDBC 驱动程序仅在特定上下文中应用此设置。例如，MySQL 应该只在以下情况下应用此设置：
- en: Set a forward-only result set (this can be set via jOOQ, `resultSetType()`).
  id: totrans-1597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单向结果集（这可以通过 jOOQ 的 `resultSetType()` 来设置）。
- en: Set a concurrency read-only result set (via jOOQ, `resultSetConcurrency()`).
  id: totrans-1598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置并发只读结果集（通过 jOOQ 的 `resultSetConcurrency()`）。
- en: The fetch size is either set to `Integer.MIN_VALUE` for fetching records one
    by one or to the desired size while adding `useCursorFetch=true` to the JDBC URL
    for relying on cursor-based streaming.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 获取大小设置为`Integer.MIN_VALUE`以逐条获取记录，或者设置为所需的大小，同时在JDBC URL中添加`useCursorFetch=true`以依赖基于游标的流式传输。
- en: 'Here is a snippet of code that takes advantage of these settings for MySQL:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个利用这些设置的MySQL代码片段：
- en: '[PRE1210]'
  id: totrans-1601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1210]'
- en: '[PRE1211]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1211]'
- en: '[PRE1212]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1212]'
- en: '[PRE1213]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1213]'
- en: '[PRE1214]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1214]'
- en: '[PRE1215]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1215]'
- en: '[PRE1216]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1216]'
- en: '[PRE1217]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1217]'
- en: '[PRE1218]'
  id: totrans-1609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1218]'
- en: The complete example is named *LazyFetching*.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例命名为*LazyFetching*。
- en: 'On the other hand, PostgreSQL uses the fetch size if we do the following:'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们这样做，PostgreSQL将使用fetch size：
- en: Set forward-only result set (can be set via jOOQ, `resultSetType()`)
  id: totrans-1612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单向结果集（可以通过jOOQ的`resultSetType()`设置）
- en: Disable the *auto-commit* mode (in Spring Boot with the default Hikari CP connection
    pool, this can be done in `application.properties` via the following flag-property,
    `spring.datasource.hikari.auto-commit=false`, or in jOOQ via `<autoCommit>false</autoCommit>`
    in the `<jdbc/>` tag of your configuration)
  id: totrans-1613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用*自动提交*模式（在Spring Boot中使用默认的Hikari CP连接池，这可以通过`application.properties`中的以下标志属性完成，`spring.datasource.hikari.auto-commit=false`，或者在jOOQ中通过配置中的`<jdbc/>`标签的`<autoCommit>false</autoCommit>`实现）
- en: 'So, the code for PostgreSQL can be as follows:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PostgreSQL的代码可以如下所示：
- en: '[PRE1219]'
  id: totrans-1615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1219]'
- en: '[PRE1220]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1220]'
- en: '[PRE1221]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1221]'
- en: '[PRE1222]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1222]'
- en: '[PRE1223]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1223]'
- en: '[PRE1224]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1224]'
- en: '[PRE1225]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1225]'
- en: '[PRE1226]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1226]'
- en: Moreover, in PostgreSQL, the fetch size can be altered via `defaultRowFetchSize`
    and added to the JDBC URL. The complete example is also named *LazyFetching*.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在PostgreSQL中，可以通过`defaultRowFetchSize`更改fetch size并将其添加到JDBC URL。完整的示例也命名为*LazyFetching*。
- en: For SQL Server and Oracle, we can rely on the default fetch size since both
    of them prevent out-of-memory errors. Nevertheless, enabling the fetch size in
    SQL Server is quite challenging while using the Microsoft JDBC driver (as in this
    book). It is much simpler if you rely on the jTDS driver.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQL Server和Oracle，我们可以依赖默认的fetch size，因为它们都防止内存溢出错误。然而，在使用Microsoft JDBC驱动程序（如本书中所述）时，在SQL
    Server中启用fetch size相当具有挑战性。如果你依赖jTDS驱动程序，这会简单得多。
- en: Our examples for SQL Server and Oracle (*LazyFetching*) rely on the default
    fetching size; therefore, 128 for SQL Server and 10 for Oracle.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为SQL Server和Oracle的示例（*LazyFetching*）依赖于默认的获取大小；因此，SQL Server为128，Oracle为10。
- en: 'Finally, you can combine `ResultSet` and the Cursor API as follows:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以如下组合`ResultSet`和Cursor API：
- en: '[PRE1227]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1227]'
- en: '[PRE1228]'
  id: totrans-1628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1228]'
- en: '[PRE1229]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1229]'
- en: 'Additionally, you can do it like this:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以这样做：
- en: '[PRE1230]'
  id: totrans-1631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1230]'
- en: '[PRE1231]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1231]'
- en: '[PRE1232]'
  id: totrans-1633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1232]'
- en: '[PRE1233]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1233]'
- en: '[PRE1234]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1234]'
- en: '[PRE1235]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1235]'
- en: Next, let's talk about lazy fetching via streaming.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈通过流式传输的延迟获取。
- en: Lazy featching via fetchStream()/fetchStreamInto()
  id: totrans-1638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过fetchStream()/fetchStreamInto()进行延迟获取
- en: 'In jOOQ, lazy fetching can also be achieved via `fetchStream()`/`fetchStreamInto()`.
    This method keeps an open JDBC result set internally and allows us to stream its
    content (that is, lazy fetching the result set into memory). For example, plain
    SQL can take advantage of `DSLContext.fetchStream()`, as follows:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，延迟获取也可以通过`fetchStream()`/`fetchStreamInto()`实现。此方法在内部保持一个打开的JDBC结果集，并允许我们流式传输其内容（即延迟将结果集加载到内存中）。例如，纯SQL可以利用`DSLContext.fetchStream()`，如下所示：
- en: '[PRE1236]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1236]'
- en: '[PRE1237]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1237]'
- en: '[PRE1238]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1238]'
- en: '[PRE1239]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1239]'
- en: '[PRE1240]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1240]'
- en: 'Or we can use the generated Java-based schema, as follows:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用生成的基于Java的架构，如下所示：
- en: '[PRE1241]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1241]'
- en: '[PRE1242]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1242]'
- en: '[PRE1243]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1243]'
- en: '[PRE1244]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1244]'
- en: '[PRE1245]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1245]'
- en: 'This code works in the same way as the next one, which uses `stream()`, not
    `fetchStream()`:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与下一个使用`stream()`而不是`fetchStream()`的代码以相同的方式工作：
- en: '[PRE1246]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1246]'
- en: '[PRE1247]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1247]'
- en: '[PRE1248]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1248]'
- en: '[PRE1249]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1249]'
- en: '[PRE1250]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1250]'
- en: 'However, pay attention as this code is not the same as the next one (the previous
    example uses `org.jooq.ResultQuery.stream()`, while the next example uses `java.``util.``Collection.stream()`):'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，此代码与下一个代码不同（前一个示例使用`org.jooq.ResultQuery.stream()`，而下一个示例使用`java.util.Collection.stream()`）：
- en: '[PRE1251]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1251]'
- en: '[PRE1252]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1252]'
- en: '[PRE1253]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1253]'
- en: '[PRE1254]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1254]'
- en: '[PRE1255]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1255]'
- en: '[PRE1256]'
  id: totrans-1663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1256]'
- en: '[PRE1257]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1257]'
- en: Here, the `fetch()` method fetches the whole result set into memory and closes
    the database connection – this time, we don't need the try-with-resources wrapping
    since we are, essentially, streaming a list of records. Next, the `stream()` method
    opens a stream over the in-memory result set and no database connection is kept
    open. So, pay attention to how you write such snippets of code since you will
    be prone to accidental mistakes – for instance, you might need lazy fetching but
    accidentally add `fetch()`, or you might want eager fetching but accidentally
    forget to add `fetch()`.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fetch()`方法将整个结果集加载到内存中并关闭数据库连接——这次，我们不需要try-with-resources包装，因为我们本质上是在流式传输记录列表。接下来，`stream()`方法在内存结果集上打开一个流，并且不会保持数据库连接打开。因此，请注意如何编写这样的代码片段，因为你很容易犯错误——例如，你可能需要延迟获取，但意外地添加了`fetch()`，或者你可能想要立即获取，但意外地忘记了添加`fetch()`。
- en: Using org.jooq.ResultQuery.collect()
  id: totrans-1666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用org.jooq.ResultQuery.collect()
- en: 'Sometimes, we need the stream pipeline to apply specific operations (for instance,
    `filter()`), and to collect the results, as shown in the following example:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要流管道来应用特定的操作（例如，`filter()`），并收集结果，如下面的例子所示：
- en: '[PRE1258]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1258]'
- en: '[PRE1259]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1259]'
- en: '[PRE1260]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1260]'
- en: '[PRE1261]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1261]'
- en: '[PRE1262]'
  id: totrans-1672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1262]'
- en: '[PRE1263]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1263]'
- en: '[PRE1264]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1264]'
- en: '[PRE1265]'
  id: totrans-1675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1265]'
- en: '[PRE1266]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1266]'
- en: 'However, if we don''t actually need the stream pipeline (for instance, we don''t
    need the `filter()` call or any other operation), and all we want is to lazily
    collect the result set, then it is pointless calling `fetchStream()`. But if we
    remove `fetchStream()`, how can we still collect in a lazy fashion? The answer
    is the jOOQ `collect()` method, which is available in `org.``jooq.``ResultQuery`.
    This method is very handy because it can handle resources internally and bypass
    the intermediate `Result` data structure. As you can see, there is no need to
    use try-with-resources after removing the `fetchStream()` call:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们实际上不需要流管道（例如，我们不需要`filter()`调用或任何其他操作），而我们只想懒加载地收集结果集，那么调用`fetchStream()`是没有意义的。但如果我们移除了`fetchStream()`，我们如何还能以懒加载的方式收集呢？答案是jOOQ的`collect()`方法，它在`org.jooq.ResultQuery`中可用。这个方法非常方便，因为它可以内部处理资源并绕过中间的`Result`数据结构。正如你所看到的，在移除`fetchStream()`调用后，没有必要使用try-with-resources：
- en: '[PRE1267]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1267]'
- en: '[PRE1268]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1268]'
- en: '[PRE1269]'
  id: totrans-1680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1269]'
- en: '[PRE1270]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1270]'
- en: '[PRE1271]'
  id: totrans-1682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1271]'
- en: However, please bear in mind the following note.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意以下注意事项。
- en: Important Note
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It is always a good practice to ensure that streaming is really needed. If
    your stream operations have SQL counterparts (for example, `filter()` can be replaced
    with a `WHERE` clause and `summingDouble()` can be replaced with the SQL''s `SUM()`
    aggregate function), then go for the SQL. This will be much faster due to the
    significantly lower data transfer. So, always ask yourself: "*Can I translate
    this streaming operation into my SQL?*" If yes, then do it! If not, then go for
    streaming, as we will do in the following example.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 确保流操作确实需要，总是一个好的实践。如果你的流操作有SQL对应项（例如，`filter()`可以用`WHERE`子句替换，`summingDouble()`可以用SQL的`SUM()`聚合函数替换），那么就使用SQL。这将由于显著降低的数据传输而更快。所以，总是问问自己：“*我能将这个流操作转换成我的SQL吗？*”如果可以，那么就去做！如果不能，那么就使用流，就像我们在下面的例子中所做的那样。
- en: 'Here is another example that lazy fetches groups. jOOQ doesn''t fetch everything
    in memory thanks to `collect()`, and since we also set the fetch size, the JDBC
    driver fetches the result set in small chunks (here, a chunk has five records).
    The PostgreSQL version is as follows:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，展示了懒加载地获取分组。由于`collect()`，jOOQ不会在内存中获取所有内容，因为我们还设置了获取大小，JDBC驱动程序会以小块（这里，一个块有五条记录）的形式获取结果集。PostgreSQL版本如下：
- en: '[PRE1272]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1272]'
- en: '[PRE1273]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1273]'
- en: '[PRE1274]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1274]'
- en: '[PRE1275]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1275]'
- en: '[PRE1276]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1276]'
- en: '[PRE1277]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1277]'
- en: '[PRE1278]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1278]'
- en: '[PRE1279]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1279]'
- en: The complete application is named *LazyFetchingWithStreams*. Next, let's talk
    about asynchronous fetching.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为*LazyFetchingWithStreams*。接下来，让我们谈谈异步获取。
- en: Asynchronous fetching
  id: totrans-1696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步获取
- en: 'Whenever you consider that you need asynchronous fetching (for instance, a
    query takes too long to wait for it or multiple queries can run independently
    of each other (non-atomically)) you can rely on the jOOQ + `CompletableFuture`
    combination. For instance, the following asynchronous operation chains an `INSERT`
    statement, an `UPDATE` statement, and a `DELETE` statement using the `CompletableFuture`
    API and the threads obtained from the default `ForkJoinPool` API (if you are not
    familiar with this API, then you can consider purchasing the *Java Coding Problems*
    book from Packt, which dives deeper into this topic):'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你考虑需要异步获取（例如，一个查询需要太长时间等待或者多个查询可以独立运行（非原子性）），你都可以依赖jOOQ + `CompletableFuture`的组合。例如，以下异步操作使用`CompletableFuture`
    API和从默认的`ForkJoinPool` API获取的线程链式连接了一个`INSERT`语句、一个`UPDATE`语句和一个`DELETE`语句（如果你不熟悉这个API，那么你可以考虑购买Packt出版的*Java
    Coding Problems*这本书，它深入探讨了这一主题）：
- en: '[PRE1280]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1280]'
- en: '[PRE1281]'
  id: totrans-1699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1281]'
- en: '[PRE1282]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1282]'
- en: '[PRE1283]'
  id: totrans-1701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1283]'
- en: '[PRE1284]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1284]'
- en: '[PRE1285]'
  id: totrans-1703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1285]'
- en: '[PRE1286]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1286]'
- en: '[PRE1287]'
  id: totrans-1705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1287]'
- en: '[PRE1288]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1288]'
- en: '[PRE1289]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1289]'
- en: '[PRE1290]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1290]'
- en: '[PRE1291]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1291]'
- en: '[PRE1292]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1292]'
- en: '[PRE1293]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1293]'
- en: '[PRE1294]'
  id: totrans-1712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1294]'
- en: '[PRE1295]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1295]'
- en: This example is available for MySQL next to another one in the application named
    *SimpleAsync*.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在名为*SimpleAsync*的应用程序旁边，可供MySQL使用。
- en: 'You can exploit `CompletableFuture` and jOOQ, as demonstrated in the previous
    example. However, you can also rely on two jOOQ shortcuts, `fetchAsync()` and
    `executeAsync()`. For instance, let''s suppose that we want to fetch managers
    (`MANAGER`), offices (`OFFICE`), and employees (`EMPLOYEE`) and serve them to
    the client in HTML format. Fetching managers, offices, and employees can be done
    asynchronously since these three queries are not dependent on each other. In this
    context, the jOOQ `fetchAsync()` method allows us to write the following three
    methods:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用 `CompletableFuture` 和 jOOQ，如前一个示例所示。然而，你也可以依赖两个 jOOQ 快捷方式，`fetchAsync()`
    和 `executeAsync()`。例如，假设我们想要获取经理（`MANAGER`）、办公室（`OFFICE`）和员工（`EMPLOYEE`），并以 HTML
    格式将它们提供给客户端。由于这三个查询之间没有相互依赖，因此获取经理、办公室和员工可以异步进行。在这种情况下，jOOQ 的 `fetchAsync()` 方法允许我们编写以下三个方法：
- en: '[PRE1296]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1296]'
- en: '[PRE1297]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1297]'
- en: '[PRE1298]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1298]'
- en: '[PRE1299]'
  id: totrans-1719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1299]'
- en: '[PRE1300]'
  id: totrans-1720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1300]'
- en: '[PRE1301]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1301]'
- en: '[PRE1302]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1302]'
- en: '[PRE1303]'
  id: totrans-1723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1303]'
- en: '[PRE1304]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1304]'
- en: '[PRE1305]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1305]'
- en: '[PRE1306]'
  id: totrans-1726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1306]'
- en: '[PRE1307]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1307]'
- en: '[PRE1308]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1308]'
- en: '[PRE1309]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1309]'
- en: '[PRE1310]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1310]'
- en: '[PRE1311]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1311]'
- en: '[PRE1312]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1312]'
- en: '[PRE1313]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1313]'
- en: 'Next, we wait for these three asynchronous methods to complete via the `CompletableFuture.allOf()`
    method:'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过 `CompletableFuture.allOf()` 方法等待这三个异步方法完成：
- en: '[PRE1314]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1314]'
- en: '[PRE1315]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1315]'
- en: '[PRE1316]'
  id: totrans-1737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1316]'
- en: '[PRE1317]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1317]'
- en: '[PRE1318]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1318]'
- en: '[PRE1319]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1319]'
- en: '[PRE1320]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1320]'
- en: '[PRE1321]'
  id: totrans-1742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1321]'
- en: '[PRE1322]'
  id: totrans-1743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1322]'
- en: '[PRE1323]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1323]'
- en: '[PRE1324]'
  id: totrans-1745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1324]'
- en: '[PRE1325]'
  id: totrans-1746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1325]'
- en: '[PRE1326]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1326]'
- en: '[PRE1327]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1327]'
- en: '[PRE1328]'
  id: totrans-1749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1328]'
- en: '[PRE1329]'
  id: totrans-1750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1329]'
- en: '[PRE1330]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1330]'
- en: '[PRE1331]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1331]'
- en: '[PRE1332]'
  id: totrans-1753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1332]'
- en: The `String` returned by this method (for instance, from a REST controller)
    represents a piece of HTML produced by jOOQ via the `formatHTML()` method. Curious
    about what this HTML looks like? Then, simply run the *FetchAsync* application
    under MySQL and use the provided controller to fetch the data in a browser. You
    might also like to practice the *ExecuteAsync* (which is available for MySQL)
    application that uses the jOOQ `executeAsync()` method as an example.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回的 `String`（例如，来自 REST 控制器）代表 jOOQ 通过 `formatHTML()` 方法生成的 HTML 片段。好奇这个
    HTML 的样子吗？那么，只需在 MySQL 下运行 *FetchAsync* 应用程序，并使用提供的控制器在浏览器中获取数据。你可能还喜欢练习 *ExecuteAsync*（适用于
    MySQL）应用程序，该应用程序使用 jOOQ 的 `executeAsync()` 方法作为示例。
- en: 'Lukas Eder mentions that:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder 提到：
- en: '*"Perhaps worth mentioning that there''s an ExecutorProvider SPI that allows
    for routing these async executions elsewhere when the default ForkJoinPool is
    not the correct place? jOOQ''s own CompletionStage implementations also make sure
    that everything is always executed on the Executor provided by ExecutorProvider,
    unlike the JDK APIs, which always defaults back to the ForkJoinPool again (unless
    that has changed, recently)."*'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '*"也许值得提一下，有一个 ExecutorProvider SPI 允许在默认的 ForkJoinPool 不是正确的地方时将这些异步执行路由到其他地方？jOOQ
    自身的 CompletionStage 实现也确保一切总是在 ExecutorProvider 提供的 Executor 上执行，与 JDK API 不同，JDK
    API 总是默认回到 ForkJoinPool（除非最近有所改变）。"*'
- en: Next, let's tackle reactive fetching.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决反应式获取。
- en: Reactive fetching
  id: totrans-1758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式获取
- en: 'Reactive fetching refers to the use of a reactive API in combination with jOOQ.
    Since you are using Spring Boot, there is a big chance that you are already familiar
    with the Project Reactor reactive library ([https://projectreactor.io/](https://projectreactor.io/))
    or the `Mono` and `Flux` APIs. So, without going into further detail, let''s take
    an example of combining `Flux` and jOOQ in a controller:'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式获取是指结合使用反应式 API 和 jOOQ。由于你正在使用 Spring Boot，你很可能已经熟悉 Project Reactor 反应式库（[https://projectreactor.io/](https://projectreactor.io/)）或
    `Mono` 和 `Flux` API。所以，不深入细节，让我们举一个在控制器中结合 `Flux` 和 jOOQ 的例子：
- en: '[PRE1333]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1333]'
- en: '[PRE1334]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1334]'
- en: '[PRE1335]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1335]'
- en: '[PRE1336]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1336]'
- en: '[PRE1337]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1337]'
- en: '[PRE1338]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1338]'
- en: '[PRE1339]'
  id: totrans-1766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1339]'
- en: '[PRE1340]'
  id: totrans-1767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1340]'
- en: '[PRE1341]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1341]'
- en: '[PRE1342]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1342]'
- en: '[PRE1343]'
  id: totrans-1770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1343]'
- en: So, jOOQ is responsible for fetching some data from `EMPLOYEE`, and `Flux` is
    responsible for publishing the fetched data. You can practice this example in
    *SimpleReactive* (which is available for MySQL).
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，jOOQ 负责从 `EMPLOYEE` 获取一些数据，而 `Flux` 负责发布获取到的数据。你可以在 *SimpleReactive*（适用于
    MySQL）中练习这个示例。
- en: 'What about a more complex example? One of the important architectures that
    can be applied to mitigate data loss in a streaming pipeline is **Hybrid Message
    Logging** (**HML**). Imagine a streaming pipeline for meetup RSVPs. In order to
    ensure that we don''t lose any RSVPs, we can rely on **Receiver-Based Message
    Logging** (**RBML**) to write every received RSVP to stable storage (for instance,
    PostgreSQL) before any action is performed on it. Moreover, we can rely on **Sender-Based
    Message Logging** (**SBML**) to write each RSVP in the stable storage right before
    we send it further on in the pipeline (for example, to a message queuing). This
    is the RSVP that was processed by the application business logic, so it might
    not the same as the received RSVP. The following diagram represents data flowing
    through an HML implementation:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 那更复杂的例子呢？可以应用于减轻流式管道中数据丢失的重要架构之一是**混合消息记录**（**HML**）。想象一下一个用于Meetup RSVP的流式管道。为了确保我们不丢失任何RSVP，我们可以依赖**基于接收器的消息记录**（**RBML**）在对其进行任何操作之前将其写入稳定的存储（例如，PostgreSQL）。此外，我们可以依赖**基于发送器的消息记录**（**SBML**）在将RSVP发送到管道的下一部分之前将其写入稳定的存储（例如，到消息队列）。这是由应用程序业务逻辑处理过的RSVP，所以它可能和接收到的RSVP不同。以下图表示了通过HML实现的数据流：
- en: '![Figure 8.7 – Data flow through HML'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 通过HML的数据流'
- en: '](img/B16833_Figure_8.7.jpg)'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_8.7.jpg]'
- en: Figure 8.7 – Data flow through HML
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 通过HML的数据流
- en: 'Based on the preceding diagram, we can implement the processing and recovery
    of data asynchronously. For instance, the RBML part can be expressed in jOOQ as
    follows:'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的图，我们可以异步地实现数据的处理和恢复。例如，RBML部分可以用jOOQ表示如下：
- en: '[PRE1344]'
  id: totrans-1777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1344]'
- en: '[PRE1345]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1345]'
- en: '[PRE1346]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1346]'
- en: '[PRE1347]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1347]'
- en: '[PRE1348]'
  id: totrans-1781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1348]'
- en: '[PRE1349]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1349]'
- en: '[PRE1350]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1350]'
- en: '[PRE1351]'
  id: totrans-1784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1351]'
- en: '[PRE1352]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1352]'
- en: '[PRE1353]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1353]'
- en: '[PRE1354]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1354]'
- en: '[PRE1355]'
  id: totrans-1788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1355]'
- en: 'On the other hand, the SBML part can be expressed as follows:'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，SBML部分可以表示如下：
- en: '[PRE1356]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1356]'
- en: '[PRE1357]'
  id: totrans-1791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1357]'
- en: '[PRE1358]'
  id: totrans-1792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1358]'
- en: '[PRE1359]'
  id: totrans-1793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1359]'
- en: '[PRE1360]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1360]'
- en: '[PRE1361]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1361]'
- en: '[PRE1362]'
  id: totrans-1796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1362]'
- en: '[PRE1363]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1363]'
- en: '[PRE1364]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1364]'
- en: What about deleting or updating an RSVP? For the complete code, check out the
    *HML* application, which is available for PostgreSQL.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 那删除或更新一个RSVP呢？对于完整的代码，请查看*HML*应用程序，该应用程序适用于PostgreSQL。
- en: Summary
  id: totrans-1800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a big chapter that covered one of the most powerful capabilities of
    jOOQ, fetching and mapping data. As you learned, jOOQ supports a wide range of
    approaches for fetching and mapping data, from simple fetching to record mappers,
    to the fancy SQL/JSON and SQL/XML, to the marvelous and glorious MULTISET support,
    and finally, to lazy, asynchronous, and reactive fetching. In the next chapter,
    we will talk about how to batch and bulk data.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章大章节，涵盖了jOOQ最强大的功能之一，即获取和映射数据。正如你所学的，jOOQ支持广泛的获取和映射数据的方法，从简单的获取到记录映射器，再到花哨的SQL/JSON和SQL/XML，再到令人惊叹的多集支持，最后到懒加载、异步和响应式获取。在下一章中，我们将讨论如何批量处理和批量数据。
