<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Connecting to SQL Databases Using ORM Frameworks</h1>
                </header>
            
            <article>
                
<p>The <strong>Vaadin Framework</strong> is a <em>web frameworkâ€”a</em> library,<span> </span>if you wish, that helps with<span> </span><em>web development</em>. You, as a developer, have the opportunity to integrate it with any other Java technology, and in particular, with any persistence technology. Since the most popular technology for persisting data is SQL, this chapter is dedicated to exploring several alternatives to connecting to SQL databases from Vaadin applications.</p>
<p>We will start by studying the concept of<span> o</span><em>bject-relational mapping</em>, a technique that allows developers to use an object-oriented programming language to consume and manipulate data in an otherwise incompatible system. We'll then move on to explore three of the most popular Java frameworks used to connect to SQL databases:<span> </span><em>JPA</em>,<span> </span><em>MyBatis</em>, and<span> </span><em>jOOQ</em>. These technologies are widely used in the industry, and it's important that you understand at least the philosophy and fundamentals of each one in order to select the best options for your projects.</p>
<p>Throughout the sections in this chapter, we will develop very simple web UIs that list data from a database (using the<span> </span><kbd>Grid</kbd><span> </span>class), and present a simple form to add data to it. The purpose of the examples is to show you the very fundamentals of data binding with Vaadin. The next chapter will focus on more advanced data binding to develop sophisticated<span> </span><strong>CRUD</strong><span> </span>(<strong>Create, Read, Update, and Delete</strong>) user interfaces.</p>
<p class="p1"><span class="s1">This chapter covers the following topics:</span></p>
<ul>
<li><strong>Object-relational mapping</strong> (<strong>ORM</strong>) frameworks</li>
<li><strong>Java Persistence API</strong> (<strong>JPA</strong>)</li>
<li>MyBatis</li>
<li><strong>Java Object Oriented Querying</strong> (<strong>jOOQ</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have <span>Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. </span><span>Finally, to use the Git repository of this book, you need to install Git.</span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-06</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/p1CGkr">https://goo.gl/p1CGkr</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using object-relational mapping frameworks</h1>
                </header>
            
            <article>
                
<p>In a relational database, data is represented as <em>tables</em>. In a Java program, data is represented as <em>objects</em>. For example, if you have data related to customers, you can store this data in a<span> </span><kbd>customers</kbd><span> </span>table. Similarly, you can store this data in objects which are instances of the<span> </span><kbd>Customer</kbd> class.<span> </span><em>Object-relational mapping</em><span> </span>frameworks allow you to convert the data between these two systems.</p>
<p>We already learned how to fetch data via JDBC and the<span> </span><kbd>ResultSet</kbd><span> </span>interface in the previous chapter. You could take an instance of this interface, iterate over the rows, and manually set the fields of a Java class such as<span> </span><kbd>Customer</kbd>. When you do so, you are doing the job of an ORM framework. Why reinvent the wheel? The Java ecosystem offers several options to fix the<span> </span><em>object-relational impedance mismatch</em>. In the following sections, we'll examine three of the most popular alternatives to solve this impedance mismatch.</p>
<div class="packt_infobox">The Object Oriented paradigm is based on software engineering principles, while the Relational paradigm is based on mathematical principles. <span>The <em>object-relational impedance mismatch</em> refers to the incompatibility between these two paradigms.</span></div>
<p>The examples developed in the following sections use the H2 database instance we initialized during the introduction to JDBC in the previous chapter. Make sure that the H2 server is running and that the<span> </span><kbd>messages</kbd><span> </span>table exists (see the<span> </span><kbd>packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization</kbd><span> </span>class for details). You can use any other database if you want. If so, make sure your database server is running, create the<span> </span><kbd>messages</kbd><span> </span>table, and configure your application to point to your new database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to SQL databases using JPA</h1>
                </header>
            
            <article>
                
<p>The first thing you need to know about the JPA is that it is a specification, not an implementation. There are several implementations, <em>Hibernate</em><span> </span>and<span> </span><em>EclipseLink</em><span> </span>arguably being the most popular ones. In this book, we'll use Hibernate. The other things you need to learn about JPA are better learned by coding! Let's see how to create a simple Vaadin application that shows a<span> </span><kbd>Grid</kbd><span> </span>with the messages in the database.</p>
<p>What do you think is the first thing you need to do to start using JPA, or more specifically, Hibernate? It's, of course, adding the dependencies. Create a Vaadin project and add the following dependencies to your<span> </span><kbd>pom.xml</kbd><span> </span>file:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.hibernate<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>hibernate-core<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>5.2.10.Final<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<div class="packt_infobox">You can find all the code developed in this section in the<span> </span><kbd>Data-centric-Applications-with-Vaadin-8/chapter-06/jpa-example</kbd><span> </span>Maven project.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a persistence unit</h1>
                </header>
            
            <article>
                
<p>So, JPA is ready in the classpath. What could be the next logical step? It makes sense to define a connection to the database next. The simplest way of doing this is by creating a <kbd>persistence.xml</kbd><span> </span>file. JPA will automatically read this file in the<span> </span><kbd>META-INF</kbd><span> </span>directory in your classpath. In a Maven project, the location is <kbd>resources/META-INF/persistence.xml</kbd>. Inside this file, you can define one or more<span> </span><em>persistence units</em><span> </span>(database connections) and its connection properties. The following is an example of a minimal<span> </span><kbd>persistence.xml</kbd>  file you can use to connect to the H2 database:</p>
<pre><span>&lt;persistence </span><span>xmlns</span><span>="http://java.sun.com/xml/ns/persistence"<br/></span><span>            </span><span>xmlns:</span><span>xsi</span><span>="http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>            </span><span>xsi</span><span>:schemaLocation</span><span>="http://java.sun.com/xml/ns/persistence   <br/>           http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"<br/></span><span>             </span><span>version</span><span>="2.0"</span><span>&gt;<br/></span><span>        &lt;persistence-unit </span><span>name</span><span>="<strong>jpa-example-pu</strong>"</span><span>&gt;<br/></span><span>          &lt;properties&gt;<br/></span><span>            &lt;property </span><span>name</span><span>="<strong>javax.persistence.jdbc.url</strong>" <br/></span><span>            value</span><span>="<strong>jdbc:h2:tcp://localhost/~/h2-databases/demo</strong>" </span><span>/&gt;<br/></span><span>           &lt;property </span><span>name</span><span>="<strong>javax.persistence.jdbc.user</strong>" </span><span>value</span><span>="<strong>sa</strong>" </span><span>/&gt;<br/></span><span>           &lt;property </span><span>name</span><span>="<strong>javax.persistence.jdbc.password</strong>" </span><span>value</span><span>=<strong>"" </strong></span><span>/&gt;<br/></span><span>          &lt;/properties&gt;<br/></span><span>        &lt;/persistence-unit&gt;<br/></span><span>&lt;/persistence&gt;<br/></span></pre>
<p>Since you can define multiple persistence units (when your application needs to connect to multiple databases, for example), each persistence unit must have a name that identifies it. We have used<span> </span><kbd>jpa-example-pu</kbd><span> </span>for ours. Notice how we used the same connection properties (URL, user, password) we used previously with plain JDBC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an EntityManagerFactory</h1>
                </header>
            
            <article>
                
<p>We have<span> </span><em>defined</em><span> </span>a connection through a persistence unit, but the application is not actually<span> </span><em>using</em><span> </span>it yet. The way applications make use of JPA is through the<span> </span><kbd>EntityManagerFactory</kbd>. You can think of the<span> </span><kbd>EntityManagerFactory</kbd><span> </span>as the<span> </span><em>entry point to JPA</em>. An<span> </span><kbd>EntityManagerFactory</kbd><span> </span>allows you to interact with a specific persistence unit. It's almost, but not precisely, like the connection pool, if you like.</p>
<div class="packt_tip">JPA implementations, like Hibernate or EclipseLink, offer built-in connection pooling mechanisms which are handled internally. You can usually adjust the pool configuration by using additional properties in the persistence unit definition. Consult the documentation of the JPA implementation you use for more details.</div>
<p>In our case, there's only one persistence unit,<span> </span><kbd>jpa-example-pu</kbd>, so it<span> </span>makes<span> </span>sense to have only one<span> </span><kbd>EntityManagerFactory</kbd><span> instance </span>per instance of the application. As with plain JDBC, we can use<span> </span><kbd>ServletContextListener</kbd><span> </span>to create the<span> </span><kbd>EntityManagerFactory</kbd>, but once again, let's delegate this to a different class to encapsulate JPA-related stuff:</p>
<pre><span>public class </span><strong>JPAService</strong> {<br/><br/>    <span>private static </span><strong>EntityManagerFactory factory</strong><span>;<br/></span><span><br/></span><span>    public static void </span><strong>init()</strong> {<br/>        <span>if </span>(<span>factory </span>== <span>null</span>) {<br/>            <span>factory </span>= <strong>Persistence.createEntityManagerFactory("jpa-<br/>             example-pu")</strong><span>;<br/></span><span>        </span>}<br/>    }<br/><br/>    <span>public static void </span><strong>close()</strong> {<br/>        <span>factory</span>.<strong>close()</strong><span>;<br/></span><span>    </span>}<br/><br/>    <span>public static </span>EntityManagerFactory <strong>getFactory()</strong> {<br/>        <span>return </span><span>factory</span><span>;<br/></span><span>    </span>}<br/> }</pre>
<p>We have defined the<span> </span><kbd>init</kbd><span> </span>and<span> </span><kbd>close</kbd><span> </span>methods to initialize and close the<span> </span><kbd>EntityManagerFactory</kbd><span>, </span>respectively.<span> </span>These methods<span> </span>can be used in a<span> </span><kbd>ServletContextListener</kbd>:</p>
<pre><span>@WebListener<br/></span><span>public class </span>JpaExampleContextListener <span>implements </span>ServletContextListener {<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>contextInitialized</span>(ServletContextEvent sce) {<br/>        <strong>JPAService.init()</strong><span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>contextDestroyed</span>(ServletContextEvent sce) {<br/>        <strong>JPAService.close()</strong><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The<span> </span><kbd>JPAService</kbd><span> </span>method also exposes the<span> </span><kbd>EntityManagerFactory</kbd><span> </span>instance<span> </span>though<span> </span>the<span> </span><kbd>getFactory</kbd><span> </span>method. This is where things start to get more functional. With JPA, you use an<span> </span><kbd>EntityManagerFactory</kbd><span> </span>to create<span> </span><kbd>EntityManager</kbd><span> </span>instances. Think of an<span> </span><kbd>EntityManager</kbd><span> </span>as a<span> </span><em>working unit</em>, a concrete interaction you need to perform with the database, for example, saving data or reading it. Some class could use the<span> </span><kbd>JPAService.getFactory</kbd><span> </span>method to, for example, get all the messages from the database. Omitting the code that actually queries the database and exception handling, the following is the<span> </span><em>general infrastructure</em><span> </span>code to interact with the database with JPA:</p>
<pre>EntityManager entityManager = JPAService.<strong>getFactory().createEntityManager()</strong><span>;<br/></span>entityManager.<strong>getTransaction().begin()</strong><span>;<br/></span><span><br/>... run queries ...<br/><br/></span>entityManager.<strong>getTransaction().commit()</strong><span>;<br/>entityManager<strong>.close()</strong>;</span></pre>
<p>This code gets the<span> </span><kbd>EntityManagerFactory</kbd><span> </span>to create a new<span> </span><kbd>EntityManager</kbd>. With it, a new database transaction can be started. After this, you can put the code that actually runs queries against the database, but <span>before we unveil the </span><kbd>... run queries ...</kbd><span> code, we need to implement an important class we are missing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing Entity classes</h1>
                </header>
            
            <article>
                
<p>JPA is an ORM framework. It<span> </span><em>maps</em><span> </span>SQL tables to Java objects. We already have the SQL table, <kbd>messages</kbd>, but what about the Java counterpart? We need to define a<span> </span><kbd>Message</kbd> class. If you had a look at the code for the JDBC section, you probably saw the SQL code to create the messages table. If not, here it is:</p>
<pre><span>CREATE TABLE <strong>messages</strong>(<strong>id</strong> BIGINT auto_increment, <strong>content</strong> VARCHAR(255))</span></pre>
<p>We want that table to be represented on the Java side as:</p>
<pre><span>public class </span><strong>Message</strong> {<br/><br/>    <span>private </span>Long <strong>id</strong><span>;</span><span><br/></span><span>    private </span>String <strong>content</strong><span>;<br/></span><span><br/></span><span>    ... getters and setters ...</span><br/>}</pre>
<p>This class is going to be what JPA calls an<span> </span>Entity<span> </span>class, a <strong>POJO</strong> class (<strong>Plain Old Java Object</strong>) that is annotated to match an SQL table. You can use annotations to <em>tell</em> JPA how to<span> </span><em>map</em><span> </span>the objects to the tables. The code speaks<span> </span>by<span> </span>itself:</p>
<pre><strong>@Entity<br/>@Table(name = "messages")</strong><br/><span>public class </span>Message {<br/><br/><strong>    @Id<br/></strong>    <span>private </span>Long <span>id</span><span>;<br/></span><span><br/></span><span>    private </span>String <span>content</span><span>;<br/><br/></span>    ... getters and setters ...<br/>}</pre>
<p>We are using the<span> </span><kbd>@Entity</kbd><span> </span>annotation to mark the class as an Entity.<span> </span><kbd>@Table</kbd><span> </span>tells JPA which SQL table to map to.<span> </span><kbd>@Id</kbd> marks the property that corresponds to the primary key in the SQL table. How about the <kbd>auto_increment</kbd><span> </span>definition for the<span> </span><kbd>id</kbd><span> </span>column in the messages table? We don't want to worry about<span> </span><em>counting</em><span> </span>IDs<span> </span>to keep track of which value to use next, right? We can tell JPA that this column is generated by the database as follows:</p>
<pre><span>@Id<br/></span><strong>@GeneratedValue(strategy = GenerationType.IDENTITY)</strong><br/><span>private </span>Long <span>id</span><span>;<br/></span></pre>
<div class="packt_tip">Depending on your database, you may want to use a different strategy. For example,<span> </span>with PostgreSQL<span>, </span>you would most likely use<span> </span><kbd>GenerationType.SEQUENCE</kbd><span> </span>instead.</div>
<p>The<span> </span><kbd>id</kbd><span> </span>column in the messages table defines the<span> </span><em>identity</em><span> </span>of a row. It has to be the same<span> </span>as<span> </span>its Java counterpart. We can do this by overriding the<span> </span><kbd>equals</kbd><span> </span>method, and because of the<span> </span><kbd>Object.hashCode</kbd><span> </span>method contract, we also need to override the<span> </span><kbd>hashCode</kbd><span> </span>method:</p>
<pre><span>  public class </span>Message {<br/><span>     ...<br/><br/></span><span>     </span><span>@Override<br/></span><span>     </span><span>public boolean </span><span>equals</span>(Object o) {<br/>         <span>if </span>(<span>this </span>== o) <span>return true;<br/></span><span>         if </span>(o == <span>null </span>|| getClass() != o.getClass()) <span>return false;<br/></span><span><br/></span><span>         </span>Message message = (Message) o<span>;<br/></span><span><br/></span><span>        return </span><span>id </span>!= <span>null </span>? <span>id</span>.equals(message.<span>id</span>) : message.<span>id </span>== <span>null;<br/></span><span>     </span>}<br/><br/>     <span>@Override<br/></span><span>     </span><span>public int </span><span>hashCode</span>() {<br/>         <span>return </span><span>id </span>!= <span>null </span>? <span>id</span>.hashCode() : <span>0</span><span>;<br/></span><span>     </span>}<br/><br/>     ...<br/> }</pre>
<div class="packt_infobox">According to the JavaDocs for the<span> </span><kbd>Object.equals</kbd><span> </span>method: "...it is generally necessary<span> </span>to override the<span> </span><kbd>hashCode</kbd><span> </span>method whenever this method is overridden, so as to maintain the general contract for the<span> </span><kbd>hashCode</kbd><span> </span>method, which states that equal objects must have equal hash codes". Most IDEs include a feature to generate this code for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing queries</h1>
                </header>
            
            <article>
                
<p>The connection properties are ready, the<span> </span><kbd>EntityManagerFactory</kbd><span> </span>is ready, and the Entity class is ready. Time to unveil the<span> </span><kbd>... run queries ...</kbd><span> </span>part:</p>
<pre>Query query = entityManager.<strong>createQuery("select m from Message m")</strong><span>;<br/></span><strong>List&lt;Message&gt;</strong> messages = query.<strong>getResultList()</strong><span>;<br/></span></pre>
<p>At first, you might think<span> </span><kbd>select m from Message m</kbd><span> </span>is SQL code. But it's not! First of all, there's no<span> </span><kbd>Messages</kbd><span> </span>table in the database (it's<span> </span><kbd>messages</kbd>). Second of all, this query is a<span> </span><strong>Java Persistence Query Language</strong> (<strong>JPQL</strong>) query.</p>
<div class="packt_infobox">JPQL is a platform-independent language similar to SQL. JPA converts JPQL queries to corresponding SQL queries that can be sent to the database. <span>There's not enough space in this chapter to cover all the features of JPQL.</span><span> </span>There are plenty of resources online about it if you want to learn more.</div>
<p>The previous code looks exactly like something you would encapsulate in a repository class. Let's do so and implement a<span> </span><kbd>MessageRepository</kbd><span> </span>class as follows:</p>
<pre><span>public class </span><strong>MessageRepository</strong> {<br/><br/>    public static List&lt;Message&gt; <strong>findAll()</strong> {<br/>        EntityManager entityManager = null;<br/>        try {<br/>            entityManager =    <br/>            JPAService.getFactory().createEntityManager();<br/>            entityManager.getTransaction().begin();<br/><br/><strong>           Query query = entityManager.createQuery("select m from   <br/>            Message m");</strong><br/><strong>            List&lt;Message&gt; messages = query.getResultList();</strong><br/><br/>            entityManager.getTransaction().commit();<br/>            return messages;<br/><br/>        } finally {<br/>            if (entityManager != null) {<br/>                entityManager.close();<br/>            }<br/>        }<br/>     }<br/><br/> }</pre>
<p>There's a lot of boilerplate code. Repository classes like to have many methods, and most of them will need the same kind of infrastructure code to run a single query. Fortunately, we can use some Java constructs to encapsulate the logic for creating an<span> </span><kbd>EntityManager</kbd>, opening and closing a transaction, and closing the<span> </span><kbd>EntityManager</kbd>. The<span> </span><kbd>JPAService</kbd><span> </span>class looks like the perfect candidate for this:</p>
<pre><span>public class </span>JPAService {<br/>    ...<br/><br/>    <span>public static </span>&lt;<span>T</span>&gt; <span>T </span><strong><span>runInTransaction</span></strong>(Function&lt;EntityManager<span>, </span><span>T</span>&gt; <br/>      function) {<br/>        EntityManager entityManager = <span>null;<br/></span><span><br/></span><span>        try </span>{<br/>            entityManager = <br/>            JPAService.<span>getFactory</span>().createEntityManager()<span>;<br/></span><span>            </span>entityManager.getTransaction().begin()<span>;<br/></span><span><br/></span><strong>            T result = function.apply(entityManager);<br/></strong><span><br/></span><span>            </span>entityManager.getTransaction().commit()<span>;<br/></span><span>            return </span>result<span>;<br/></span><span><br/></span><span>        </span>} <span>finally </span>{<br/>            <span>if </span>(entityManager != <span>null</span>) {<br/>                entityManager.close()<span>;<br/></span><span>            </span>}<br/>        }<br/>     }<br/><br/> }</pre>
<p>The<span> </span><kbd>runInTransaction</kbd><span> </span>method is a generic method that uses a Java<span> </span><kbd>Function</kbd><span> which</span> delegates the actual query logic to clients. Thanks to Java lambda expressions, we can clean up the code in the<span> </span><kbd>MessagesService</kbd><span> </span>class as follows:</p>
<pre><span>public class </span>MessageRepository {<br/><br/>    <span>public static </span>List&lt;Message&gt; <span>findAll</span>() {<br/><strong>        return JPAService.runInTransaction(em -&gt;</strong><br/><strong>              em.createQuery("select m from Message m").getResultList()</strong><br/><strong>        );<br/></strong><span>    </span>}<br/>}</pre>
<p>We can also add a method to save new messages. With JPA, this is pretty simple:</p>
<pre><span>public class </span>MessageRepository {<br/>    ...<br/><br/>    <span>public static void </span><strong>save(Message message)</strong> {<br/>        JPAService.<span>runInTransaction</span>(em -&gt; {<br/>            <strong>em.persist(message)</strong><span>;<br/></span><span>            return null;<br/></span><span>        </span>})<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>Notice how the<span> </span><kbd>EntityManager.persist</kbd><span> </span>method directly accepts an instance of the<span> </span><kbd>Message</kbd><span> </span>Entity class.</p>
<div class="packt_infobox"><span>Note that the configuration and code examples in this chapter are valid in the context of web applications that use the Servlet specification only. When using the full Jakarta EE (previously Java EE) specification or Spring Framework, the configuration and code have subtle variations and practices. For example, you should use JNDI discoverable data sources configured in the server instead of specifying usernames and passwords for database connections with Jakarta EE. Also, transaction boundaries can be automatically managed with Jakarta EE and Spring Framework, which means that you don't need to implement and use the </span><kbd>runInTransaction</kbd><span> method.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a Vaadin UI to list and save Entities</h1>
                </header>
            
            <article>
                
<p>How can we use this from a Vaadin UI? Not a mystery at all, right? Just use Vaadin components and call the<span> </span><kbd>MessageRepository</kbd><span> </span>class when needed. Let's see it in action! Start by implementing a basic UI that shows a<span> </span><kbd>Grid</kbd><span>, </span>a<span> </span><kbd>TextField</kbd><span>, </span>and a<span> </span><kbd>Button</kbd>, something like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-203 image-border" src="assets/bd012df3-2e97-4e2e-b752-7107257bd394.png" style=""/></div>
<p>Feel free to implement a different layout for it. The following is the implementation corresponding to the previous screenshot:</p>
<pre><span>public class </span>VaadinUI <span>extends </span>UI {<br/><br/>    <span>private </span><strong>Grid&lt;Message&gt; grid</strong><span>;<br/></span><span>    private </span><strong>TextField textField</strong><span>;<br/></span><span>    private </span><strong>Button button</strong><span>;<br/></span><span><br/></span><span>    </span><span>@Override<br/></span><span>    </span><span>protected void </span><span>init</span>(VaadinRequest request) {<br/>        <strong>initLayout()</strong><span>;<br/></span><span>        </span><strong>initBehavior()</strong><span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><strong>initLayout()</strong> {<br/>        <span>grid </span>= <span>new </span>Grid&lt;&gt;(Message.<span>class</span>)<span>;<br/></span><span>        </span><span>grid</span>.setSizeFull()<span>;<br/></span><span>        </span><span>grid</span>.getColumn(<span>"id"</span>).setWidth(<span>100</span>)<span>;<br/></span><span><br/></span><span>        </span><span>textField </span>= <span>new </span>TextField()<span>;<br/></span><span>        </span><span>textField</span>.setPlaceholder(<span>"Enter a new message..."</span>)<span>;<br/></span><span>        </span><span>textField</span>.setSizeFull()<span>;<br/></span><span><br/></span><span>        </span><span>button </span>= <span>new </span>Button(<span>"Save"</span>)<span>;<br/></span><span><br/></span><span>        </span>HorizontalLayout formLayout = <span>new </span>HorizontalLayout(<span>textField</span><span>, </span><span>button</span>)<span>;<br/></span><span>        </span>formLayout.setWidth(<span>"100%"</span>)<span>;<br/></span><span>        </span>formLayout.setExpandRatio(<span>textField</span><span>, </span><span>1</span>)<span>;<br/></span><span><br/></span><span>        </span>VerticalLayout layout = <span>new </span>VerticalLayout(<span>grid</span><span>, </span>formLayout)<span>;<br/></span><span>        </span>layout.setWidth(<span>"600px"</span>)<span>;<br/></span><span>        </span>setContent(layout)<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><strong>initBehavior()</strong> {<br/>        // not yet implemented! Stay tuned!<br/><span>    </span>}<br/>}</pre>
<p>The previous implementation shows a good practice: separating the code that builds up the UI from the code that adds behavior to it. The behavior, in this case, means adding a<span> </span><kbd>ClickListener</kbd><span> </span>that saves the message in the<span> </span><kbd>TextField</kbd> and showing messages from the database in the grid. The following completes the implementation of the behavior for the UI:</p>
<pre><span>public class </span>VaadinUI <span>extends </span>UI {<br/>    ...<br/><br/>    <span>private void </span><span>initBehavior</span>() {<br/><strong>        button.addClickListener(e -&gt; saveCurrentMessage());<br/></strong><span>        </span>update()<span>;<br/></span><span>    </span>}<br/><br/>    <span>private void </span><span>saveCurrentMessage</span>() {<br/>        Message <strong>message = new Message()</strong><span>;<br/></span><span>        </span>message.<strong>setContent(textField.getValue())</strong><span>;<br/></span><span>        </span><strong>MessageRepository.save(message)</strong><span>;<br/></span><span><br/></span><span>        </span>update()<span>;<br/></span><span>        </span><span>grid</span>.select(message)<span>;<br/></span><span>        </span><span>grid</span>.scrollToEnd()<span>;<br/></span><span>    </span>}<br/><br/>    private void update() {<br/><strong>        grid.setItems(MessageRepository.findAll());</strong><br/>        textField.clear();<br/>        textField.focus();<br/>    }<br/>}</pre>
<p>We are directly using the<span> </span><kbd>MessageRepository</kbd><span> </span>class to invoke persistence-related logic. Notice how the<span> </span><em>data binding</em> is done in the<span> </span><kbd>saveCurrentMessage</kbd><span> </span>method. This binding goes in only one direction: from the UI to the Entity. This is the most basic form of data binding you can use with Vaadin. In the case of the <kbd>Grid</kbd>, the data binding goes in the other direction: from the Entities to the UI. We'll see more advanced data binding techniques in the next chapter.</p>
<div class="packt_infobox">When should you use JPA? In general, JPA is good for RDBMS portability. JPA is widely used in the industry and there are many tools and resources available for it. JPA is an official Java specification with several vendors offering implementations (such as Hibernate and EclipseLink). JPA is not the only official Java specification for persistence. <strong>Java Data Objects</strong> (<strong>JDO</strong>) is another Java specification you may want to, at least, consider.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to SQL databases using MyBatis</h1>
                </header>
            
            <article>
                
<p>MyBatis is a persistence framework that maps SQL to Java objects. The MyBatis learning curve is flatter than JPA's and leverages on SQL, which makes it a good match if you have good knowledge about SQL or have many complex SQL queries you want to reuse.</p>
<p>As usual, you first need to add the dependency. Here is how to do it with Maven:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.mybatis<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>mybatis<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>3.4.5<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p> </p>
<div class="packt_infobox"><span>You can find the full implementation of the example developed in this section in the</span><span> </span><span><kbd>Data-centric-Applications-with-Vaadin-8/chapter-06/mybatis-example</kbd> Maven project.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a database connection</h1>
                </header>
            
            <article>
                
<p>With MyBatis, you can define a database connection using a Java API or a configuration XML file. The easiest way is to put an XML file in the classpath (the<span> </span><kbd>resources</kbd><span> </span>directory, when using Maven). The following is an example of such a configuration file:</p>
<pre><span>&lt;?</span><span>xml version</span><span>="1.0" </span><span>encoding</span><span>="UTF-8" </span><span>?&gt;<br/></span><span>&lt;!DOCTYPE </span><span>configuration<br/></span><span>PUBLIC </span><span>"-//mybatis.org//DTD Config 3.0//EN"<br/></span><span>        "http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span>&gt;<br/></span><span>&lt;configuration&gt;<br/></span><span>    &lt;environments </span><span>default</span><span>="development"</span><span>&gt;<br/></span><span>        &lt;environment </span><span>id</span><span>="development"</span><span>&gt;<br/></span><span>            &lt;transactionManager </span><span>type</span><span>="JDBC"</span><span>/&gt;<br/></span><span>            &lt;dataSource </span><span>type</span><span>="POOLED"</span><span>&gt;<br/></span><span>                &lt;property </span><span>name</span><span>="driver" </span><span>value</span><span>="org.h2.Driver"</span><span>/&gt;<br/></span><span>                &lt;property </span><span>name</span><span>="url" <br/></span><span>                 value</span><span>="jdbc:h2:tcp://localhost/~/h2-databases/demo"</span><span>/&gt;<br/></span><span>                &lt;property </span><span>name</span><span>="username" </span><span>value</span><span>="sa"</span><span>/&gt;<br/></span><span>                &lt;property </span><span>name</span><span>="password" </span><span>value</span><span>=""</span><span>/&gt;<br/></span><span>            &lt;/dataSource&gt;<br/></span><span>        &lt;/environment&gt;<br/></span><span>    &lt;/environments&gt;<br/></span><span>    &lt;mappers&gt;<br/></span><span>        &lt;mapper  <br/></span><span>     class</span><span>="packt.vaadin.datacentric.chapter06.mybatis.MessageMapper"</span><span>/&gt;<br/></span><span>    &lt;/mappers&gt;<br/></span><span>&lt;/configuration&gt;<br/></span></pre>
<p>You can use any name for this file. The example for this section uses<span> </span><kbd>mybatis-config.xml</kbd>.</p>
<p>As you can see, we used the same connection properties we used for JDBC and JPA, but we added a<span> </span><kbd>driver</kbd><span> </span>property. Its value should correspond to the name of JDBC driver which you are going to use for the database connection.</p>
<p>How do we use this file? Once again, we can use a <kbd>ServletContextListener</kbd> to initialize MyBatis. Moreover, the <kbd>ServletContextListener</kbd> can delegate to a service class like the following:</p>
<pre><span>public class </span>MyBatisService {<br/><br/>    <span>private static </span><strong>SqlSessionFactory sqlSessionFactory</strong><span>;<br/></span><span><br/></span><span>    public static void </span><span>init</span>() {<br/>        InputStream inputStream = MyBatisService.<span>class</span>.getResourceAsStream(<span>"<strong>/mybatis-config.xml</strong>"</span>)<span>;<br/></span><span>        </span><span>sqlSessionFactory </span>= <strong>new SqlSessionFactoryBuilder().build(inputStream)</strong><span>;<br/></span><span>    </span>}<br/><br/>    <span>public static </span>SqlSessionFactory <strong>getSqlSessionFactory()</strong> {<br/>        <span>return </span><strong>sqlSessionFactory</strong><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The<span> </span><kbd>SqlSessionFactory</kbd><span> </span>class is the<span> </span><em>entry point</em><span> </span>to MyBatis. The previous class provides the init method that can be called from a<span> </span><kbd>ServletContextListener</kbd>, which creates one<span> </span><kbd>SqlSessionFactory</kbd><span> </span>per instance of the<span> </span>application,<span> </span>and exposes it through a getter. This is<span> a pattern </span>similar to the one we previously used with JPA.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing mapper classes</h1>
                </header>
            
            <article>
                
<p>MyBatis uses<span> </span><em>mapper classes</em> (actually, interfaces) to define the methods that will map SQL queries to Java objects. These are almost the equivalent of the repository classes we have developed so far. However, it makes sense to use MyBatis terminology when using it. Also, as we'll see later, we need to add transaction or session management code around the calls to the mapper class, but let's start with the mapper class. If you were observant, the<span> </span><kbd>mybatis-config.xml</kbd> file defined a mapper class in the<span> </span><kbd>mappers</kbd> section. Go back and have a look at it. The following is the definition of such a mapper:</p>
<pre><span>public <strong>interface </strong></span><strong>MessageMapper</strong> {<br/><br/><strong>    @Select("SELECT id, content FROM messages")</strong><br/>    List&lt;Message&gt; <span>findAll</span>()<span>;<br/></span><span><br/></span><strong>    @Insert("INSERT INTO messages(content) VALUES (#{content})")</strong></pre>
<pre>    <span>@Options</span>(<span>useGeneratedKeys </span>= <span>true, </span><span>keyProperty </span>= <span>"id"</span>)<br/>    <span>void </span><span>save</span>(Message message)<span>;<br/></span><span><br/></span>}</pre>
<p>As you can see,<span> </span><kbd>MessageMapper</kbd><span> </span>is an interface. You don't have to implement this interface; MyBatis will provide the implementation for you at runtime. We have defined two methods: one to return a<span> </span><kbd>List</kbd><span> </span>of<span> </span>Messages, and another to save a<span> </span><kbd>Message</kbd>. Notice the<span> </span><kbd>@Select</kbd><span> </span>and<span> </span><kbd>@Insert</kbd><span> </span>annotations. These are used to define the SQL that will run when these methods are called. Also, notice how you can pass values from the arguments to the SQL query. The save method accepts a<span> </span><kbd>Message</kbd><span> </span>instance. In the SQL query defined by the<span> </span><kbd>@Insert</kbd><span> </span>annotation, we use<span> </span><kbd>#{content}</kbd><span> </span> to <em>pass</em><span> </span>the value of the<span> </span><kbd>Message.content</kbd><span> </span>property to the query. You could have passed a <kbd>String</kbd> with the value too. In that case, you can use the name of the parameter directly. However, we want MyBatis to set the value of the <kbd>id</kbd><span> </span>property after the row has been inserted. This value is <span>autogenerated in the database, so we have to use the <kbd>@Options</kbd> annotation to configure this behavior.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a service class</h1>
                </header>
            
            <article>
                
<p>As mentioned before, we need to add some transaction and session handling code in order to use mapper classes. This can be done in<span> </span><em>service classes</em>. A service class is simply a class that performs some kind of business logic (in contrast, a mapper class performs persistence-only logic). The following is an example of a class that encapsulates session handling in order to avoid coupling the UI with MyBatis-related logic:</p>
<pre><span>public class </span><strong>MessageService</strong> {<br/><br/>    <span>public static </span>List&lt;Message&gt; <span>findAll</span>() {<br/>        <span>try </span>(<strong>SqlSession session =   <br/>          MyBatisService.getSqlSessionFactory().openSession()</strong>) {<br/>            <strong>MessageMapper mapper = <br/>             session.getMapper(MessageMapper.class)</strong><span><strong>;</strong><br/></span><span>            return </span><strong>mapper.findAll()</strong><span>;<br/></span><span>        </span>}<br/>    }<br/><br/>    <span>public static void </span><span>save</span>(Message message) {<br/>        <span>try </span>(SqlSession session = MyBatisService.<span>getSqlSessionFactory</span>().openSession()) {<br/>            MessageMapper mapper = session.getMapper(MessageMapper.<span>class</span>)<span>;<br/></span><span>            </span>mapper.save(message)<span>;<br/></span><strong>            session.commit();<br/></strong><span>        </span>}<br/>    }<br/>}</pre>
<p>Each persistence unit of work should be enclosed by an active session. Additionally, for insert or updates, we need to commit the transaction to the database.</p>
<p>MyBatis is a powerful and mature framework you should keep in mind when deciding<span> </span>on<span> </span>technologies. There are many other features, such as the possibility to map methods to SQL stored procedures or using XML files (or even the Apache Velocity scripting language) to define the SQL queries, which is useful when the queries require multiple lines or need to be formed dynamically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to SQL databases using jOOQ</h1>
                </header>
            
            <article>
                
<p>jOOQ is a persistence framework that allows you to define SQL queries using the Java Programming Language. It has many capabilities and this section, we will only show a few of them.</p>
<p>As always, you can start by adding the required dependencies to start using jOOQ:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.jooq<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>jooq<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>3.9.5<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.jooq<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>jooq-codegen<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>3.9.5<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<div class="packt_infobox"><span>You can find all the code developed in this section in the </span><kbd>Data-centric<span>-Applications-with-Vaadin-8/c</span>hapter-06/jooq-example</kbd><span> Maven project.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a database connection</h1>
                </header>
            
            <article>
                
<p>You can use jOOQ with any connection pool you prefer. The example for this section uses the same approach we used with plain JDBC, so the connection properties can be defined in a<span> </span><kbd>datasource.properties</kbd><span> </span>file:</p>
<pre><span>datasource.url</span><span>=</span><span>jdbc:h2:tcp://localhost/~/h2-databases/demo<br/></span><span>datasource.username</span><span>=</span><span>sa<br/></span><span>datasource.password</span><span>=<br/></span></pre>
<p>At this point, you should be familiar with how to use a<span> </span><kbd>ServletContextListener</kbd><span> </span>to initialize a database connection pool. Let's omit that part (see the section about JDBC for details) and jump directly to more specific topics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reverse-engineering the database schema</h1>
                </header>
            
            <article>
                
<p>Let's say you have a database schema to manage books and authors. A possible SQL query for such a database could look like the following:</p>
<pre>SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME<br/>FROM AUTHOR<br/>ORDER BY AUTHOR.LAST_NAME ASC</pre>
<p>jOOQ allows you to write this same SQL query, but in Java:</p>
<pre class="prettyprint lang-java prettyprinted"><span class="kwd">dslContext</span><span class="pun">.</span><span class="kwd">select</span><span class="pun">(</span><span class="pln">AUTHOR</span><span class="pun">.</span><span class="pln">FIRST_NAME</span><span class="pun">,</span><span class="pln"> AUTHOR</span><span class="pun">.</span><span class="pln">LAST_NAME</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="kwd">from</span><span class="pun">(</span><span class="pln">AUTHOR</span><span class="pun">)</span><span class="pln">
</span><span class="pln">      </span><span class="pun">.</span><span class="kwd">orderBy</span><span class="pun">(</span><span class="pln">AUTHOR</span><span class="pun">.</span><span class="pln">LAST_NAME</span><span class="pun">.</span><span class="kwd">asc</span><span class="pun">()</span><span class="pln">
</span></pre>
<p>As you can see, the syntax is quite close to actual SQL. You might be wondering where the<span> </span><kbd>AUTHOR</kbd><span> </span>object and its properties come from. They come from code generated by jOOQ. The code generation process can be automated with Maven. The following code shows how to configure the<span> </span><kbd><span>jooq-</span>codegen<span>-maven</span></kbd> plugin in your<span> </span><kbd>pom.xml</kbd>:</p>
<pre><span>&lt;plugin&gt;<br/></span><span>    &lt;groupId&gt;</span>org.jooq<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>jooq-codegen-maven<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>3.9.5<span>&lt;/version&gt;<br/></span><span>    &lt;executions&gt;<br/></span><span>        &lt;execution&gt;<br/></span><span>            &lt;goals&gt;<br/></span><span>                &lt;goal&gt;</span>generate<span>&lt;/goal&gt;<br/></span><span>            &lt;/goals&gt;<br/></span><span>        &lt;/execution&gt;<br/></span><span>    &lt;/executions&gt;<br/></span><span>    &lt;configuration&gt;<br/></span><span>        &lt;jdbc&gt;<br/></span><span>            &lt;url&gt;</span><strong>${datasource.url}</strong><span>&lt;/url&gt;<br/></span><span>            &lt;user&gt;</span><strong>${datasource.username}</strong><span>&lt;/user&gt;<br/></span><span>            &lt;password&gt;</span><strong>${datasource.password}</strong><span>&lt;/password&gt;<br/></span><span>        &lt;/jdbc&gt;<br/></span><span>        &lt;generator&gt;<br/></span><span>            &lt;database&gt;<br/></span><span>                &lt;name&gt;</span><strong>org.jooq.util.h2.H2Database</strong><span>&lt;/name&gt;<br/></span><span>            &lt;/database&gt;<br/></span><span>            &lt;target&gt;<br/></span><span>               &lt;packageName&gt;<strong>packt.vaadin.datacentric.chapter06</strong></span><strong>.jooq<br/></strong><span>               &lt;/packageName&gt;<br/></span><span>                &lt;directory&gt;</span><strong>target/generated-sources/jooq</strong><span>&lt;/directory&gt;<br/></span><span>            &lt;/target&gt;<br/></span><span>        &lt;/generator&gt;<br/></span><span>    &lt;/configuration&gt;<br/></span><span>&lt;/plugin&gt;<br/></span></pre>
<p>You have to configure the connection properties so that the generator can scan the database schema. You also have to configure the database to use it (<kbd>H2</kbd>, in this example). Finally, you have to configure the package to be used for the generated code and the directory inside your project where this package is going to reside.</p>
<p>There's one small detail, though. We are using expressions (such as<span> </span><kbd>${datasource.url}</kbd>) to specify the database connection properties. How can you use values coming from a<span> </span><kbd>.properties</kbd><span> </span>file inside the<span> </span><kbd>pom.xml</kbd><span> </span>file? By using the <kbd>properties-maven-plugin</kbd><span> </span>Maven plugin:</p>
<pre><span>&lt;plugin&gt;<br/></span><span>    &lt;groupId&gt;</span>org.codehaus.mojo<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>properties-maven-plugin<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>1.0.0<span>&lt;/version&gt;<br/></span><span>    &lt;executions&gt;<br/></span><span>        &lt;execution&gt;<br/></span><span>            &lt;phase&gt;</span>initialize<span>&lt;/phase&gt;<br/></span><span>            &lt;goals&gt;<br/></span><span>                &lt;goal&gt;</span>read-project-properties<span>&lt;/goal&gt;<br/></span><span>            &lt;/goals&gt;<br/></span><span>            &lt;configuration&gt;<br/></span><span>                &lt;files&gt;<br/></span><span>                     <br/>                &lt;file&gt;</span><strong>src/main/resources/datasource.properties</strong><span>&lt;/file&gt;<br/></span><span>                &lt;/files&gt;<br/></span><span>            &lt;/configuration&gt;<br/></span><span>        &lt;/execution&gt;<br/></span><span>    &lt;/executions&gt;<br/></span><span>&lt;/plugin&gt;<br/></span></pre>
<p>With the previous configuration, Maven will be able to read the properties in the<span> </span><kbd>datasource.properties</kbd><span> </span>file and replace the corresponding expressions in the<span> </span><kbd>pom.xml</kbd><span> </span>file.</p>
<p>After configuring this two Maven plugins, you can run<span> </span><kbd>mvn<span> </span>clean package</kbd><span> </span>to reverse-engineer the database schema and generate the corresponding code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running queries</h1>
                </header>
            
            <article>
                
<p>You can run queries with jOOQ by creating a <kbd>DSLContext</kbd> instance. One way of getting this instance is with the <kbd>DSL.using</kbd><span> </span>method:</p>
<pre>Connection <strong>connection</strong> = <span>pool</span>.getConnection()<span>;<br/></span>DSLContext <strong>dslContext</strong> = <strong>DSL.using(connection)</strong>;</pre>
<p>With this, you can easily run queries using the fluent API offered by jOOQ. For example, to get all the rows in the messages table, you can use the following:</p>
<pre><strong>List&lt;MessagesRecord&gt;</strong> messages = dslContext.select()<br/>        .from(<span>MESSAGES</span>)<br/>        .<strong>fetchInto(MessagesRecord.class);</strong></pre>
<p>The<span> </span><kbd>MessagesRecord</kbd><span> </span>class and<span> </span><kbd>MESSAGES</kbd><span> </span>instance<span> </span>are<span> </span>provided by the code<span> </span>generated<span> </span>by jOOQ. This makes the previous query type-safe.</p>
<div class="packt_tip">If, for some reason, your database schema changes, you'll get a compilation error and will have the chance to fix the problem before deploying it to production. This is one of the strengths of jOOQ.</div>
<p>From here, you can imagine how to implement a<span> </span><kbd>MessageRepository</kbd><span> </span>class using jOOQ. Here's the solution to such a puzzle, though:</p>
<div>
<pre><span>public class </span>MessageRepository {<br/><br/>    <span>public static </span>List&lt;MessagesRecord&gt; <span>findAll</span>() {<br/>        <span>try </span>{<br/>            <span>return </span>JooqService.<span>runWithDslContext</span>(context -&gt;<br/>                    context.select()<br/>                            .from(<span>MESSAGES</span>)<br/>                            .fetchInto(MessagesRecord.<span>class</span>)<br/>            )<span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(SQLException e) {<br/>            e.printStackTrace()<span>;<br/></span><span>            return </span>Collections.<span>emptyList</span>()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>    <span>public static void </span><span>save</span>(MessagesRecord message) {<br/>        <span>try </span>{<br/>            JooqService.<span>runWithDslContext</span>(context -&gt;<br/>                    context.insertInto(<span>MESSAGES</span><span>, </span><span>MESSAGES</span>.<span>CONTENT</span>)<br/>                            .values(<span>message</span>.getContent())<br/>                            .execute()<br/>            )<span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(SQLException e) {<br/>            e.printStackTrace()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>}</pre></div>
<div>And the convenient <kbd>JooqService.runWithDslContext</kbd><span> </span>method:</div>
<div>
<pre><span>public class </span>JooqService {<br/>    ...<br/><br/>    <span>public static </span>&lt;<span>T</span>&gt; <span>T </span><strong>runWithDslContext</strong>(Function&lt;DSLContext<span>, </span><span>T</span>&gt; <br/><strong>     function</strong>) <span>throws </span>SQLException {<br/>        <span>try </span>(Connection <strong>connection</strong> = <span>pool</span>.getConnection()<span>; </span>DSLContext <br/><strong>          dslContext</strong> = DSL.<span>using</span>(connection)) {<br/>            <span>T </span>t = <strong>function.apply(dslContext)</strong><span>;<br/></span><span>            return </span>t<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre></div>
<div class="packt_infobox">If you are interested in jOOQ, you might want to evaluate <em>Ebean</em> (<a href="http://ebean-orm.github.io" target="_blank">http://ebean-orm.github.io</a>) and<span> </span><em>Querydsl</em> (<a href="http://www.querydsl.com">http://www.querydsl.com</a>), which are both ORM frameworks that also allow you to implement type-safe queries in Java.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter was full of new technologies! We discussed what an object-relational mapping framework is, and studied practical examples on how to use three popular persistence technologies for Java: JPA, MyBatis, and jOOQ. We saw how Vaadin<span> </span>Framework allows us to consume any kind of Java API directly, usually through custom abstractions that encapsulate details (such as service and repository classes). We learned the most basic form of data binding in Vaadin, which consists of setting and getting the values directly from domain objects to UI components. We also learned how to separate code that builds up the UI from the code, which adds behavior to it in order to improve its<span> </span>maintainability.</p>
<p>In <a href="8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml" target="_blank">Chapter 7</a>, <em>Implementing CRUD User Interfaces</em>, we are going to see more Vaadin-related topics and discuss data binding in more depth.</p>


            </article>

            
        </section>
    </body></html>