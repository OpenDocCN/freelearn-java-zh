<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Optimizing the Sort - Making Code Professional</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will develop the sorting code and make it more general. We want to sort not only an array of Strings. Essentially, we will write a program that can sort anything that is sortable. That way, we will bring the coding to its full extent toward one of the major strengths of Java: <em class="calibre12">abstraction</em>.</p>
<p class="calibre2">Abstraction, however, does not come without a price tag. When you have a class that sorts strings and you accidentally mix an integer or something else, which is not a string, into the sortable data, then the compiler will complain about it: Java does not allow you to put an <kbd class="calibre11">int</kbd> into a <kbd class="calibre11">String</kbd> array. When the code is more abstract, such programming errors may slip in. We will look at how to handle such exceptional cases catching and throwing Exceptions.</p>
<p class="calibre2">To identify the bugs, we will use unit testing, applying the industry standard JUnit version 4. As JUnit heavily uses annotation, and because annotations are important, you will learn about it a bit.</p>
<p class="calibre2">After that, we will modify the code to use the <em class="calibre12">generics</em> feature of Java that was introduced into the language in version 5. Using that possibility, we will catch the coding error during compilation time, which is better than during run time. The earlier a bug is identified, the cheaper it is to fix.</p>
<p class="calibre2">For the build, we will still use Maven, but this time, we will split the code into small modules. Thus, we will have a multi-module project. We will have separate modules for the definition of a sorting module and for the different implementations. That way, we will look at how classes can extend each other and implement interfaces, and, generally, we will really start to program in the object-oriented way.</p>
<p class="calibre2">We will also discuss <strong class="calibre1">Test Driven Development</strong> (<strong class="calibre1">TDD</strong>), and at the end of the section, we will start using the brand new feature of Java 9: module support.</p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre14">
<li class="calibre15">Object-oriented programming principles</li>
<li class="calibre15">Unit testing practices</li>
<li class="calibre15">Algorithmic complexity and quick sort</li>
<li class="calibre15">Exception handling</li>
<li class="calibre15">Recursive methods</li>
<li class="calibre15">Module support</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The general sorting program</h1>
            

            <article>
                
<p class="calibre2">In the previous chapter, we implemented a simple sort algorithm. The code can sort elements of a <kbd class="calibre11">String</kbd> array. We did this to learn. For practical use, there is a ready cooked sort solution in the JDK that can sort members of <kbd class="calibre11">collections</kbd>, which are comparable.</p>
<p class="calibre2">The JDK contains a utility class called <kbd class="calibre11">Collections</kbd>. This class contains a static <kbd class="calibre11">Collections.sort</kbd> method that is capable of sorting any <kbd class="calibre11">List</kbd> that has members that are <kbd class="calibre11">Comparable</kbd>. <kbd class="calibre11">List</kbd> and <kbd class="calibre11">Comparable</kbd> are interfaces defined in the JDK. Thus, if we want to sort a list of Strings, the simplest solution is as follows:</p>
<pre class="calibre20">
public class SimplestStringListSortTest { <br class="title-page-name"/>    @Test <br class="title-page-name"/>    public void canSortStrings() { <br class="title-page-name"/>        ArrayList actualNames = new ArrayList(Arrays.asList( <br class="title-page-name"/>                "Johnson", "Wilson", <br class="title-page-name"/>                "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>        )); <br class="title-page-name"/>        Collections.sort(actualNames); <br class="title-page-name"/>        Assert.assertEquals(new ArrayList&lt;String&gt;(Arrays.&lt;String&gt;asList( <br class="title-page-name"/>                "Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson")), actualNames); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This code fragment is from a sample JUnit test, which is the reason we have the <kbd class="calibre11">@Test</kbd> annotation in front of the method. We will discuss that in detail later. To execute that test, you can issue the following command:</p>
<pre class="calibre20">
<strong class="calibre1">$ mvn -Dtest=SimplestStringListSortTest test</strong>
</pre>
<p class="calibre2">This sort implementation, however, does not fit our needs. First of all, because it is there ready (no need to code) and using it does not need anything new that you have not learned in the previous chapters. Except for the annotation in front of the method, there is nothing new in the code that you cannot understand. You may refresh BY turning some pages back, or else consult the oracle online documentation of the JDK (<a href="https://docs.oracle.com/javase/8/docs/api/" class="calibre6"><span>https://docs.oracle.com/javase/8/docs/api/</span></a>), but that is all. You already know these things.</p>
<div class="packttip">You may wonder why I wrote the URL for the Java version 8 API to the link. Well, then this is the moment of honesty and truth-when I wrote this book, the Java 9 JDK was not available in its final form. I created most of the examples on my Mac Book using Java 8 and I only tested the features that are Java 9 specific. Support at the moment for Java 9 in the IDEs is not perfect. When you read this book, Java 9 will be available, so you can try and change that one single digit from 8 to 9 in the URL and get to the documentation of the version 9. At the moment, I get <span class="URLPACKT">HTTP ERROR 404</span>.<br class="calibre23"/>
Sometimes, you may need the documentation of older versions. You can use 3, 4, 5, 6, or 7 instead of 8 in the URL. Documentation for 3 and 4 is not available to read online, but it can be downloaded. Hopefully, you will never need that anymore. Version 5, perhaps. Version 6 is still widely used at large corporations.</div>
<p class="calibre2">Although you can learn a lot from reading code that was written by other programmers, I do not recommend trying to learn from the JDK source code at this early stage of your studies. These blocks of code are heavily optimized, not meant to be tutorial codes, and old. They do not get rusted during the years, but they were not refactored to follow the coding styles of Java as it matured. At some places, you can find really ugly code in the JDK.</p>
<p class="calibre2">Okay, saying that we need to develop a new sort code because we can learn from it, is a bit contrived. The real reason why we need a sort implementation is that we want something that can sort not only <kbd class="calibre11">List</kbd> data types and a  <kbd class="calibre11">List</kbd> of something that implements the <kbd class="calibre11">Comparable</kbd> interface. We want to sort a bunch of objects. All we require is that the <em class="calibre12">bunch</em> containing the objects provides simple methods that are just enough to sort them and have a sorted <em class="calibre12">bunch</em>.</p>
<div class="packtinfobox">Originally I wanted to use the word <em class="calibre27">collection</em> instead of <em class="calibre27">bunch</em>, but there is a <kbd class="calibre22">Collection</kbd> interface in Java and I wanted to emphasize that we are not talking about <kbd class="calibre22">java.util.Collection</kbd> of objects.</div>
<p class="calibre2">We also do not want the objects to implement the <kbd class="calibre11">Comparable</kbd> interface. If we require the object to implement the <kbd class="calibre11">Comparable</kbd> interface, it may violate the <strong class="calibre1">Single Responsibility Principle</strong> (<strong class="calibre1">SRP</strong>).</p>
<p class="calibre2">When we design a class, it should model some object class of the real world. We will model the problem space with classes. The class should implement the features that represent the behavior of the objects that it models. If we look at the example of students from the second chapter, then a <kbd class="calibre11">Student</kbd> class should represent the features that all students share, and is <em class="calibre12">important from the modeling point of view</em>. A <kbd class="calibre11">Student</kbd> object should be able to tell the name of the student, the age, the average scores of the last year, and so on. All students have feet, and certainly each of those feet have size so we may think that a <kbd class="calibre11">Student</kbd> class should also implement a method that returns the size of the student's foot (one for the left and one for the right just to be precise), but we do not. We do not, because the size of the foot is irrelevant from the model point of view. If we want to sort a list containing <kbd class="calibre11">Student</kbd> objects, the <kbd class="calibre11">Student</kbd> class has to implement the <kbd class="calibre11">Comparable</kbd> interface. But wait! How do you compare two students? By names, by age. or by the average score of them?</p>
<p class="calibre2">Comparing a student to another is not a feature of the <kbd class="calibre11">Student</kbd>. Every class, or for that matter, package, library, or programming unit should have one responsibility and it should implement only that and nothing else. It is not exact. This is not mathematics. Sometimes, it is hard to tell if a feature fits into the responsibility or not. There are simple techniques. For example, in case of a student, you can ask the real person about his name and age, and probably they can also tell you their average score. If you ask one of them to <kbd class="calibre11">compareTo</kbd> (another student), as the <kbd class="calibre11">Comparable</kbd> interface requires this method, they will probably ask back, but by what attribute? Or how? Or just, what? In such a case, you can suspect that implementing the feature is probably not in the area of that class and this concern; the comparison should be segregated from the implementation of the original class. This is also called <strong class="calibre1">Segregation of Concerns</strong>, which is closely related to SRP.</p>
<p class="calibre2">JDK developers were aware of this. <kbd class="calibre11">Collections.sort</kbd> that sorts a <kbd class="calibre11">List</kbd> of <kbd class="calibre11">Comparable</kbd> elements is not the only sorting method in this class. There is another that just sorts any <kbd class="calibre11">List</kbd> if you pass a second argument and object that implements the <kbd class="calibre11">Comparator</kbd> interface and is capable of comparing two elements of <kbd class="calibre11">List</kbd>. This is a clean pattern to separate the concerns. In some cases, separating the comparison is not needed. In other cases, it is desirable. The <kbd class="calibre11">Comparator</kbd> interface declares one single method that the implementing classes have to provide: <kbd class="calibre11">compare</kbd>. If the two arguments are equal, then this method returns <kbd class="calibre11">0</kbd>. If they are different, it should return a negative or a positive <kbd class="calibre11">int</kbd> depending on which argument precedes which one.</p>
<p class="calibre2">There are also <kbd class="calibre11">sort</kbd> methods in the JDK class, <kbd class="calibre11">java.util.Arrays</kbd>. They sort arrays, or only a slice of an array. The method is a good example of method overloading. There are methods with the same name, but with different arguments to sort a whole array for each primitive type, for a slice of each, and also two for object array implementing the <kbd class="calibre11">Comparable</kbd> interface, and also for object array to be sorted using <kbd class="calibre11">Comparator</kbd>. As you see, there is a whole range of sort implementations available in the JDK, and in 99 percent of the cases, you will not need to implement a sort yourself. The sorts use the same algorithm, a stable merge sort with some optimization.</p>
<p class="calibre2">What we will implement is a general approach that can be used to sort lists, arrays, or just anything that has elements and it is possible to swap any two elements of it; the solution will be able to use the bubble sort that we have already developed and also other algorithms.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A brief overview of various sorting algorithms</h1>
            

            <article>
                
<p class="calibre2">There are many different sorting algorithms. As I said, there are simpler and more complex algorithms and, in many cases, more complex algorithms are the ones that run faster. In this chapter, we will implement the bubble sort and quick sort. We have already implemented the bubble sort for strings in the previous chapter, so in this case, the implementation will mainly focus on the recoding for general sortable object sorting. Implementing quick sort will involve a bit of algorithmic interest.</p>
<div class="packttip">Be warned that this section is here to give you only a taste of algorithmic complexity. It is far from precise and I am in the vain hope that no mathematician reads this and puts a curse on me. Some of the explanations are vague. If you want to learn computer science in depth, then after reading this book, find some other books or visit online courses.</div>
<p class="calibre2">When we talk about the general sorting problem, we will think about some general set of objects that can be compared and any two of them can be swapped while we sort. We will also assume that this is an in-place sort; thus, we do not create another list or array to collect the original objects in sorted order. When we talk about the speed of an algorithm, we are talking about some abstract thing and not milliseconds. When we want to talk about milliseconds, actual real-world duration, we should already have some implementation in some programming language running on a real computer.</p>
<p class="calibre2">Algorithms, in their abstract form, don't do that without implementation. Still, it is worth talking about the time and memory need of an algorithm. When we do that, we will usually investigate how the algorithm behaves for a large set of data. For a small set of data, most algorithms are just fast. Sorting two numbers is usually not an issue, is it?</p>
<p class="calibre2">In case of sorting, we will usually examine how many comparisons are needed to sort a collection of <em class="calibre12">n</em> elements. Bubble sort needs approximately n<sup class="calibre29">2</sup> (n times <em class="calibre12">n</em>) comparisons. We cannot say that this is exactly <em class="calibre12">n</em><sup class="calibre29">2</sup> because in case of <em class="calibre12">n=2</em>, the result is 1, for <em class="calibre12">n=3</em> it is 3, for <em class="calibre12">n=4</em> it is 6, and so on. However, as <em class="calibre12">n</em> starts to get larger, the actual number of comparisons needed and <em class="calibre12">n</em><sup class="calibre29">2</sup> will asymptotically be of the same value. We say that the algorithmic complexity of the bubble sort is <em class="calibre12">O(n<sup class="calibre29">2</sup>)</em>. This is also called the big-O notation. If you have an algorithm that is <em class="calibre12">O(n<sup class="calibre29">2</sup>)</em> and it works just fine for 1,000 elements finishing in a second, then you should expect the same algorithm finishing for 1 million elements in around ten days or in a month. If the algorithm is linear, say <em class="calibre12">O(n)</em>, then finishing 1,000 element in one second should make you expect 1 million to be finished in 1,000 seconds. That is a bit longer than a coffee break and too short for lunch.</p>
<p class="calibre2">This makes it feasible that if we want some serious business sorting objects, we will need something better than bubble sort. That many unnecessary comparisons are not only wasting our time, but also CPU power, consuming energy, and polluting the environment. The question, however, is: how fast can a sort be? Is there a provable minimum that we cannot overcome?</p>
<p class="calibre2">The answer is yes.</p>
<p class="calibre2">When we implement any sorting algorithm, the implementation will execute comparisons and element swaps. That is the only way to sort a collection of objects. The outcome of a comparison can have two values. Say, these values are <em class="calibre12">0</em> or <em class="calibre12">1</em>. This is one bit of information. If the result of the comparison is <em class="calibre12">1</em>, then we swap, if the result is <em class="calibre12">0</em>, then we do not swap.</p>
<p class="calibre2">We can have the objects in different orders before we start the comparison and the number of different orders is <em class="calibre12">n!</em> (<em class="calibre12">n</em> factorial). That is, the numbers multiplied from 1 to <em class="calibre12">n</em>, in other words <em class="calibre12">n!</em>=1*2*3*...*(<em class="calibre12">n</em>-1)*<em class="calibre12">n</em>.</p>
<p class="calibre2">Let's assume that we stored the result of the individual comparisons in a number as a series of bits for each possible input for the sort. Now, if we reverse the execution of the sort and run the algorithm starting from the sorted collection, control the swapping using the bits that described the results of the comparison, and we use the bits the other way around doing the last swap first and the one that was done first during the sorting first, we should get back the original order of the objects. This way, each original order is uniquely tied to a number expressed as an array of bits.</p>
<p class="calibre2">Now, we can express the original question this way: how many bits are needed to describe <em class="calibre12">n</em> factorial different numbers? That is exactly the number of comparisons we will need to sort <em class="calibre12">n</em> elements. The number of bits is <em class="calibre12">log<sub class="calibre30">2</sub>(n!)</em> . Using some mathematics, we will know that <em class="calibre12">log<sub class="calibre30">2</sub>(n!)</em> is the same as <em class="calibre12">log<sub class="calibre30">2</sub>(1)+ log<sub class="calibre30">2</sub>(2)+...+ log<sub class="calibre30">2</sub>(n)</em>. If we look at this expression's asymptotic value, then we can say that this is the same <em class="calibre12">O(n*log n)</em>. We should not expect any general sorting algorithm to be faster.</p>
<p class="calibre2">For special cases, there are faster algorithms. For example, if we want to sort 1 million numbers that are each between one and 10, then we only need to count the number of the different numbers and then create a collection that contains that many ones, twos, and so on. This is an <em class="calibre12">O(n)</em> algorithm, but this is not applicable for the general case.</p>
<p class="calibre2">Again, this was not a formal mathematical proof.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Quick sort</h1>
            

            <article>
                
<p class="calibre2">Sir Charles Antony Richard Hoare developed the quick sort algorithm in 1959. It is a typical divide and conquer algorithm. To sort a long array, pick an element from the array that will be the pivot element. Then, partition the array so that the left side will contain all the elements that are smaller than the pivot and the right side will contain all the elements that are larger than, or equal to the pivot. When this is done, the left side and the right side of the array can be sorted by calling the sort recursively. To stop the recursion, when we have one single element in the array, we will declare it sorted.</p>
<div class="packtinfobox">We talk about a recursive algorithm when the algorithm is defined partially using itself. The most famous recursive definition is the Fibonacci series that is 0 and 1 for the first two elements and any later element the <em class="calibre27">n</em><sup class="calibre31">th</sup> element is the sum of the (<em class="calibre27">n-1)</em><sup class="calibre31">th</sup> and the (<em class="calibre27">n-2)</em><sup class="calibre31">th</sup> element. Recursive algorithms are many times implemented in modern programming languages implementing a method that does some calculation but sometimes calls itself. When designing recursive algorithms, it is of utmost importance to have something that stops the recursive calls; otherwise, recursive implementation will allocate all memory available for the program stack and stop the program with error.</div>
<p class="calibre2">The partitioning algorithm goes the following way: we will start to read the array using two indices from the start and end. We will first start with the index that is small and increase the index until it is smaller than the large index, or until we find an element that is greater than or equal to the pivot. After this, we will start to decrease the larger index so long as it is greater than the small index and the element indexed is greater than or equal to the pivot. When we stop, we swap the two elements pointed by the two indices, if the indices are not the same, and we will start increasing and decreasing the small and large indices, respectively. If the indices are the same, then we are finished with the partitioning. The left side of the array is from the start to the index where the indices met minus one; the right side starts with the index and lasts until the end of the to-be-sorted array.</p>
<p class="calibre2">This algorithm is usually <em class="calibre12">O(n log n)</em>, but in some cases it can degrade to be <em class="calibre12">O(n<sup class="calibre29">2</sup>)</em>, depending on how the pivot is chosen. There are different approaches for the selection of the pivot. In this book, we will use the simplest: we will select the first element of the sortable collection as a pivot.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Project structure and build tools</h1>
            

            <article>
                
<p class="calibre2">The project this time will contain many modules. We will still use Maven in this chapter. We will set up a so-called multi-module project in Maven. In such a project, the directory contains the directories of the modules and <kbd class="calibre11">pom.xml</kbd>. There is no source code in this top-level directory. The <kbd class="calibre11">pom.xml</kbd> file in this directory serves the following two purposes:</p>
<ul class="calibre14">
<li class="calibre15">It references the modules and can be used to compile, install, and deploy all the modules together</li>
<li class="calibre15">It defines parameters for the modules that are the same for all of them</li>
</ul>
<p class="calibre2">Every <kbd class="calibre11">pom.xml</kbd> has a parent and this <kbd class="calibre11">pom.xml</kbd> is the parent of the <kbd class="calibre11">pom.xml</kbd> files in the module directories. To define the modules, the <kbd class="calibre11">pom.xml</kbd> file contains the following lines:</p>
<pre class="calibre20">
&lt;project&gt; <br class="title-page-name"/>... <br class="title-page-name"/>    &lt;modules&gt; <br class="title-page-name"/>        &lt;module&gt;SortInterface&lt;/module&gt; <br class="title-page-name"/>        &lt;module&gt;bubble&lt;/module&gt; <br class="title-page-name"/>        &lt;module&gt;quick&lt;/module&gt; <br class="title-page-name"/>    &lt;/modules&gt; <br class="title-page-name"/>&lt;/project&gt;
</pre>
<p class="calibre2">These are the names of the modules. These names are used as directory names and also as <kbd class="calibre11">artifactId</kbd> in the <kbd class="calibre11">pom.xml</kbd> module. The directories in this setup look as follows:</p>
<pre class="calibre20">
$ tree <br class="title-page-name"/>   |-SortInterface <br class="title-page-name"/>   |---src/main/java/packt/java9/by/example/ch03 <br class="title-page-name"/>   |-bubble <br class="title-page-name"/>   |---src <br class="title-page-name"/>   |-----main/java/packt/java9/by/example/ch03/bubble <br class="title-page-name"/>   |-----test/java/packt/java9/by/example/ch03/bubble <br class="title-page-name"/>   |-quick/src/ <br class="title-page-name"/>   |-----main/java <br class="title-page-name"/>   |-----test/java
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Maven dependency management</h1>
            

            <article>
                
<p class="calibre2">Dependencies are also important in the POM file. The previous project did not have any dependency, but this time we will use JUnit. Dependencies are defined in <kbd class="calibre11">pom.xml</kbd> using the <kbd class="calibre11">dependencies</kbd> tag. For example, the bubble sort module contains the following piece of code:</p>
<pre class="calibre20">
&lt;dependencies&gt; <br class="title-page-name"/>    &lt;dependency&gt; <br class="title-page-name"/>        &lt;groupId&gt;packt.java9.by.example&lt;/groupId&gt; <br class="title-page-name"/>        &lt;artifactId&gt;SortInterface&lt;/artifactId&gt; <br class="title-page-name"/>    &lt;/dependency&gt; <br class="title-page-name"/>    &lt;dependency&gt; <br class="title-page-name"/>        &lt;groupId&gt;junit&lt;/groupId&gt; <br class="title-page-name"/>        &lt;artifactId&gt;junit&lt;/artifactId&gt; <br class="title-page-name"/>    &lt;/dependency&gt; <br class="title-page-name"/>&lt;/dependencies&gt;
</pre>
<div class="packtinfobox">The actual <kbd class="calibre22">pom.xml</kbd> in the code set you can download will contain more code than this. In print, we often present a version or only a fraction that helps the understanding of the topic that we are discussing at that point.</div>
<p class="calibre2">It tells Maven that the module code uses classes, interfaces, and <kbd class="calibre11">enum</kbd> types that are defined in these modules that are available from some repository.</p>
<p class="calibre2">When you use Maven to compile the code, the libraries that are used by your code are available from repositories. When Ant was developed, the notion of repositories was not invented. At that time, the developers copied the used version of the library into a folder in the source code structure. Usually, the directory <kbd class="calibre11">lib</kbd> was used for the purpose. There were two problems with this approach. One is the size of the source code repository. If, for example, 100 different projects used JUnit, then the JAR file of the JUnit library was copied there 100 times. The other problem was to gather all the libraries. When a library used another library, the developers had to read the documentation of the library that described (many times outdated and not precise) what other libraries are needed to use this library. Those libraries had to be downloaded and installed the same way. This was time consuming and error prone. When a library was missing and the developers just did not notice it, the error was manifested during compile time when the compiler could not find the class or even only at runtime when the JVM was not able to load the class.</p>
<p class="calibre2">To solve this issue, Maven comes with a built-in repository manager client. The repository is a storage that contains the libraries. As there can be other types of files in a repository, not only libraries, Maven terminology is artifact. The <kbd class="calibre11">groupId</kbd>, the <kbd class="calibre11">artifactId</kbd>, and the <kbd class="calibre11">version</kbd> number identify an artifact. There is a very strict requirement that an artifact can only be put into a repository once. Even if there is an error during the release process that is identified after the erroneous release was uploaded, the artifact cannot be overwritten. For the same <kbd class="calibre11">groupId</kbd>, <kbd class="calibre11">artifactId</kbd>, and <kbd class="calibre11">version</kbd>, there can only be one single file that will never change. If there was an error, then a new artifact is to be created with new version number and the erroneous artifact may be deleted but not replaced.</p>
<p class="calibre2">If the version number ends with <kbd class="calibre11">-SNAPSHOT</kbd>, then this uniqueness is not guaranteed or required. Snapshots are usually stored in separate repository and are not published for the world.</p>
<p class="calibre2">Repositories contain the artifacts in directories that are organized in a defined way. When Maven runs, it can access different repositories using <kbd class="calibre11">https</kbd> protocol.</p>
<div class="packttip">Formerly, the <kbd class="calibre22">http</kbd> protocol was also used, and for non-paying customers, the central repository was available via <kbd class="calibre22">http</kbd> only. However, it was discovered that modules downloaded from the repository could be targets for men-in-the-middle security attacks and Sonatype (<a href="http://www.sonatype.com" class="calibre25"><span class="URLPACKT">http://www.sonatype.com</span></a>) changed the policy and used <kbd class="calibre22">https</kbd> protocol only. Never configure or use a repository with the <kbd class="calibre22">http</kbd> protocol. Never trust a file that you downloaded from HTTP.</div>
<p class="calibre2">There is a local repository on the developer machine, usually under the <kbd class="calibre11">~/.m2/repository</kbd> directory. When you issue the <kbd class="calibre11">mvn install</kbd> command, Maven stores the created artifact here. Maven also stores an artifact here when it is downloaded from a repository via HTTPS. This way, subsequent compilations do not need to go out to the network for the artifacts.</p>
<p class="calibre2">Companies usually set up their own repository manager (the one that Sonatype, the company backing Maven, is providing Nexus). These applications can be configured to communicate with several other repositories and collect the artifacts from there on demand, essentially implementing proxy functionality. Artifacts travel to the build from the far end repositories to the closer ones in a hierarchical structure to the local repo and essentially to the final artifact if the packaging type of the project is <kbd class="calibre11">war</kbd>, <kbd class="calibre11">ear</kbd>, or some other format that encloses the dependent artifacts. This is essentially file caching without revalidation and cache eviction. This can be done because of the strict rules of artifact uniqueness. This is the reason for such a strict rule.</p>
<p class="calibre2">If the project bubble were a standalone project, and not part of a multi-module one, then the dependency would look like this:</p>
<pre class="calibre20">
&lt;dependencies&gt; <br class="title-page-name"/>    &lt;dependency&gt; <br class="title-page-name"/>        &lt;groupId&gt;packt.java9.by.example&lt;/groupId&gt; <br class="title-page-name"/>        &lt;artifactId&gt;SortInterface&lt;/artifactId&gt; <br class="title-page-name"/>        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; <br class="title-page-name"/>    &lt;/dependency&gt; <br class="title-page-name"/>    &lt;dependency&gt; <br class="title-page-name"/>        &lt;groupId&gt;junit&lt;/groupId&gt; <br class="title-page-name"/>        &lt;artifactId&gt;junit&lt;/artifactId&gt; <br class="title-page-name"/>        &lt;version&gt;4.12&lt;/version&gt; <br class="title-page-name"/>    &lt;/dependency&gt; <br class="title-page-name"/>&lt;/dependencies&gt;
</pre>
<p class="calibre2">If <kbd class="calibre11">version</kbd> is not defined for a dependency, Maven will not be able to identify which artifact to use. In the case of a multi-module project, <kbd class="calibre11">version</kbd> can be defined in the parent and the modules can inherit the version. As the parent is not dependent on the actual dependency, it only defines the version attached to the <kbd class="calibre11">groupId</kbd> and <kbd class="calibre11">artifactId</kbd>; the XML tag is not <kbd class="calibre11">dependencies</kbd>, but <kbd class="calibre11">dependencyManagement/dependencies</kbd> under the top-level <kbd class="calibre11">project</kbd> tag as in the following example:</p>
<pre class="calibre20">
&lt;dependencyManagement&gt; <br class="title-page-name"/>    &lt;dependencies&gt; <br class="title-page-name"/>        &lt;dependency&gt; <br class="title-page-name"/>            &lt;groupId&gt;packt.java9.by.example&lt;/groupId&gt; <br class="title-page-name"/>            &lt;artifactId&gt;SortInterface&lt;/artifactId&gt; <br class="title-page-name"/>            &lt;version&gt;${project.version}&lt;/version&gt; <br class="title-page-name"/>        &lt;/dependency&gt; <br class="title-page-name"/>        &lt;dependency&gt; <br class="title-page-name"/>            &lt;groupId&gt;junit&lt;/groupId&gt; <br class="title-page-name"/>            &lt;artifactId&gt;junit&lt;/artifactId&gt; <br class="title-page-name"/>            &lt;version&gt;4.12&lt;/version&gt; <br class="title-page-name"/>            &lt;scope&gt;test&lt;/scope&gt; <br class="title-page-name"/>        &lt;/dependency&gt; <br class="title-page-name"/>    &lt;/dependencies&gt; <br class="title-page-name"/>&lt;/dependencyManagement&gt;
</pre>
<p class="calibre2">If the parent POM uses the dependencies tag directly, Maven is not able to decide if the parent depends on that artifact or some modules. When the modules want to use <kbd class="calibre11">junit</kbd>, they need not specify the version. They will get it from the parent project defined as 4.12, which is the latest from <em class="calibre12">JUnit 4</em>. If ever there will be a new version 4.12.1, with some serious bugs fixed, then the only place to modify the version number is the parent POM, and the modules will use the new version starting with the next execution of the Maven compilation.</p>
<p class="calibre2">When the new version, <em class="calibre12">JUnit 5</em>, comes out, however, the modules will all have to be modified because <em class="calibre12">JUnit</em> is not just a new version. Version 5 of JUnit is split into several modules and, this way, <kbd class="calibre11">groupId</kbd> and <kbd class="calibre11">artifactId</kbd> will also change.</p>
<p class="calibre2">It is also worth noting that the modules that implement the interfaces from the <kbd class="calibre11">SortInterface</kbd> module are eventually dependent on this module. In this case, the version is defined as follows:</p>
<pre class="calibre20">
&lt;version&gt;${project.version}&lt;/version&gt;
</pre>
<p class="calibre2">That seems to be a bit tautological (it is, actually). The <kbd class="calibre11">${project.version}</kbd> property is the version of the project and it is inherited by the <kbd class="calibre11">SortInterface</kbd> module. This is the version of the artifact that the other modules depend on. In other words, the modules always depend on the version that we are currently developing.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Code the sort</h1>
            

            <article>
                
<p class="calibre2">To implement the sort, first, we will define the interfaces that a sort library should implement. Defining the interface before the actual coding is a good practice. When there are many implementations, it is sometimes recommended to first create a simple one and start using it so that the interface may evolve during the phase, and when the more complex implementations are due, then the interface to be implemented is already fixed, more or less.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating the interfaces</h1>
            

            <article>
                
<p class="calibre2">The interface in our case is very simple.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/><br class="title-page-name"/>public interface Sort { <br class="title-page-name"/>    void sort(SortableCollection collection); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The interface should do only one thing—sort something that is sortable. As we wanted to be very general in this approach, we also have to define what sortable is. To do so, we will need another interface.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/><br class="title-page-name"/>public interface SortableCollection { <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating BubbleSort</h1>
            

            <article>
                
<p class="calibre2">Now, we can start creating the bubble sort that implements the <kbd class="calibre11">Sort</kbd> interface:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.ch03.*; <br class="title-page-name"/>import java.util.Comparator; <br class="title-page-name"/><br class="title-page-name"/>public class BubbleSort implements Sort { <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void sort(SortableCollection collection) { <br class="title-page-name"/>        int n = collection.size(); <br class="title-page-name"/>        while (n &gt; 1) { <br class="title-page-name"/>            for (int j = 0; j &lt; n - 1; j++) { <br class="title-page-name"/>                if (comparator.compare(collection.get(j), <br class="title-page-name"/>                        collection.get(j + 1)) &gt; 0) { <br class="title-page-name"/>                    swapper.swap(j, j + 1); <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>            n--; <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">Normally, the algorithm to execute needs two operations that we implemented in the code last time specific to a <kbd class="calibre11">String</kbd> array: comparing two elements and swapping two elements. As this time the sort implementation itself does not know what type the elements are used and also does not know if the something it sorts is an array, a lists or something else, it needs something that does it for the sort when needed. More precisely, it needs a <kbd class="calibre11">comparator</kbd> object capable of comparing two elements and it needs a <kbd class="calibre11">swapper</kbd> object that is capable of swapping two elements in the collection.</p>
<p class="calibre2">To get those, we can implement two setter methods that can set the objects for the purpose before sort is invoked. As this is not specific to the bubble sort algorithm but is rather general, these two methods should also be made a part of the interface, so the implementation is overriding it.</p>
<pre class="calibre20">
    private Comparator comparator = null; <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void setComparator(Comparator comparator) { <br class="title-page-name"/>        this.comparator = comparator; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    private Swapper swapper = null; <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void setSwapper(Swapper swapper) { <br class="title-page-name"/>        this.swapper = swapper; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre11">@Override</kbd> annotation signals for the Java compiler that the method is overriding a method of the parent class, or, as in this case, of the interface. A method can override a parent method without this annotation; however, if we use the annotation, the compilation fails if the method does actually not override something. This helps you discover during compile time that something was changed in the parent class or in the interface and we did not follow that change in the implementation, or that we just made some mistake thinking that we will override a method when we actually do not. As annotations are heavily used in unit tests, we will talk about annotations in a bit more detail later.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Amending the interfaces</h1>
            

            <article>
                
<p class="calibre2">The modified <kbd class="calibre11">Sort</kbd> interface will look like this:</p>
<pre class="calibre20">
public interface Sort { <br class="title-page-name"/>    void sort(SortableCollection collection); <br class="title-page-name"/>    void setSwapper(Swapper swap); <br class="title-page-name"/>    void setComparator(Comparator compare); <br class="title-page-name"/>}
</pre>
<p class="calibre2">This also means that we will need two new interfaces: <kbd class="calibre11">Swapper</kbd> and <kbd class="calibre11">Comparator</kbd>. We are lucky that the Java runtime already defines a <kbd class="calibre11">Comparator</kbd> interface that just fits the purpose. You may have guessed that from the following import statement:</p>
<pre class="calibre20">
import java.util.Comparator;
</pre>
<p class="calibre2">When you need something very basic, like a <kbd class="calibre11">comparator</kbd> interface, it is most probably defined in the runtime. It is advisable to consult the runtime before writing your own version. The <kbd class="calibre11">Swapper</kbd> interface, however, we will have to create.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/><br class="title-page-name"/>public interface Swapper { <br class="title-page-name"/>    void swap(int i, int j); <br class="title-page-name"/>}
</pre>
<p class="calibre2">As it is used to swap two elements specified by the indices in <kbd class="calibre11">SortableCollection</kbd>, there is a method, quite trivially named <kbd class="calibre11">swap</kbd> for the purpose. But, we are not ready yet. If you try to compile the preceding code, the compiler will complain about the <kbd class="calibre11">get</kbd> and <kbd class="calibre11">size</kbd> methods. They are needed by the algorithm to implement the sort, but they are not inherently part of the sorting itself. This is a responsibility that should not be implemented in the sort. As we do not know what type of collections we will sort, it is not only unadvisable but also impossible to implement these functionalities inside the sort. It seems that we just cannot sort anything. There are some restrictions we will have to set. The sorting algorithm must know the size of the collection we sort and also should have access to an element by index so that it can pass it on to the comparator.</p>
<p class="calibre2">These restrictions are expressed in the <kbd class="calibre11">SortableCollection</kbd> interface that we just left empty not knowing before the first sort implementation what is required to be there.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/><br class="title-page-name"/>public interface SortableCollection { <br class="title-page-name"/>    Object get(int i); <br class="title-page-name"/>    int size(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">Now, we are ready with the interfaces and the implementation and we can go on testing the code. But, before that, we will briefly reiterate what we did and why we did that.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Architectural considerations</h1>
            

            <article>
                
<p class="calibre2">We created an interface and a simple implementation of it. During the implementation, we discovered that the interface needs other interfaces and methods that are needed to support the algorithm. This usually happens during the architectural design of the code, before implementation. For didactical reasons, I followed the build-up of the interfaces while we developed the code. In real life, when I created the interfaces, I created them all in one step as I have enough experience. I wrote my first quick sort code around 1983 in Fortran. However, it does not mean that I hit the bull's eye with just any problem and come out with the final solution. It just happens that sort is a too well known problem. If you need to modify the interfaces or other aspects of your design during development, do not feel embarrassed. It is a natural consequence and a proof that you understand things better and better as time goes by. If the architecture needs change, it is better to be done than not, and the sooner it is, the better. In real life enterprise environments, we will design interfaces just to learn during development that there were some aspects that we forgot. They are very true and bit more complex operations than sorting a collection.</p>
<p class="calibre2">In the case of the sorting problem, we abstracted the <em class="calibre12">something</em> we want to sort to the most possible extreme. The Java build in sort can sort arrays or lists. If you want to sort something that is not a list or an array, you have to create a class that implements the <kbd class="calibre11">java.util.List</kbd> interface with more than 24 methods it requires to wrap your sortable object to make it sortable by the JDK sort. To be honest, that is not too many, and in a real-world project, I would consider that as an option.</p>
<p class="calibre2">However, we do not, and cannot know, what methods of the interface the built-in sort uses. Those that are used should be functionally implemented and those that are not, can contain a simple <kbd class="calibre11">return</kbd> statement because they are just never invoked. A developer can consult the source code of the JDK and see what methods are actually used, but that is not the contract of the search implementation. It is not guaranteed that a new version will still use <em class="calibre12">only</em> those methods. If a new version starts to use a method that we implemented with a single <kbd class="calibre11">return</kbd> statement, the sort will magically fail.</p>
<p class="calibre2">It is also an interesting performance question how the swapping of two elements is implemented by the search using only the <kbd class="calibre11">List</kbd> interface. There is no <kbd class="calibre11">put(int, Object)</kbd> method in the <kbd class="calibre11">List</kbd> interface. There is <kbd class="calibre11">add(int Object)</kbd>, but that inserts a new element and it may be extremely costly (burning CPU, disk, energy) to push all elements of the list up if the objects are stored, for example, on disk. Furthermore, the next step may be removing the element after the one we just inserted, doing the costly process of moving the tail of the list again. That is, the trivial implementation of <kbd class="calibre11">put(int,Object)</kbd> that the sort may or may not follow. Again, this is something that should not be assumed.</p>
<p class="calibre2">When developers use libraries, classes, and methods from the JDK, open source, or commercial libraries, the developers may consult the source code but they should not rely on the implementation. You should rely only on the contract and the definition of the API that the library comes with. When you implement an interface from some external library, and you do not need to implement some part of it, and create some dummy methods, feel the danger in the air. It is an ambush. It is likely that either the library is poor quality or you did not understand how to use it.</p>
<p class="calibre2">In our case, we separated the swapping and the comparison from the sort. The collection should implement these operations and provide them for the sort. The contract is the interface, and to use the sort, you have to implement all methods of the interfaces we defined.</p>
<p class="calibre2">The interface of <kbd class="calibre11">Sort</kbd> defines setters that set <kbd class="calibre11">Swapper</kbd> and <kbd class="calibre11">Comparator</kbd>. Having dependencies set that way may lead to a code that creates a new instance of a class implementing the <kbd class="calibre11">Sort</kbd> interface, but does not set <kbd class="calibre11">Swapper</kbd> and <kbd class="calibre11">Comparator</kbd> before invoking <kbd class="calibre11">Sort</kbd>. This will lead to <kbd class="calibre11">NullPointerException</kbd> the first time the <kbd class="calibre11">Comparator</kbd> is invoked (or when the <kbd class="calibre11">Swapper</kbd> is invoked in case the implementation invokes that first, which is not likely, but possible). The calling method should inject the dependencies before using the class. When it is done through setters, it is called <strong class="calibre1">setter injection</strong>. This <span>terminology </span> is heavily used when we use frameworks such as Spring, Guice, or some other container. Creating these service classes and injecting the instance into our classes is fairly similar all the time.</p>
<p class="calibre2">Container implementations contain the functionality in a general way and provide configuration options to configure what instances are to be injected into what other objects. Usually, this leads to shorter, more flexible, and more readable code. However, dependency injection is not exclusive to containers. When we write the testing code in the next section, and invoke the setters, we actually do dependency injection.</p>
<p class="calibre2">There is another way of dependency injection that avoids the problem of dependencies not being set. This is called <strong class="calibre1">constructor injection</strong>. The dependencies are <kbd class="calibre11">final private</kbd> fields with no values. Remember that these fields should get their final values by the time the constructor finishes. Constructor injection passes the injected values to the constructor as arguments and the constructor sets the fields. This way, the fields are guaranteed to be set by the time the object was constructed. This injection, however, cannot be defined in an interface.</p>
<p class="calibre2">Now, we already have the code, and we know the considerations of how the interfaces were created. This is the time to do some testing.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating unit tests</h1>
            

            <article>
                
<p class="calibre2">When we write code, we should test it. No code has ever gone into production before at least doing some test runs. There are different levels of tests having different aims, technologies, industry practices, and names.</p>
<p class="calibre2">Unit tests, as the name suggests, test a unit of code. Integration tests test how the units integrate together. Smoke tests test a limited set of the features just to see that the code is not totally broken. There are other tests, until the final test, which is the proof of the work: user acceptance test. Proof of the pudding is eating it. A code is good if the user accepts it.</p>
<div class="packtinfobox">Many times, I tell juniors that the name user acceptance test is a bit misleading, because it is not the user who accepts the result of a project, but the customer. By definition, the customer is the person who pays the bill. Professional development is paid; otherwise, it is not professional. The terminology is, however, user acceptance test. It just happens that customers accept the project only if the users can use the program.</div>
<p class="calibre2">When we develop in Java, unit test is testing standalone classes. In other words, in Java development, a unit is a class when we talk about unit tests. To furnish unit tests, we usually use the JUnit library. There are other libraries, such as TestNG, but JUnit is the most widely used, so we will use <em class="calibre12">JUnit</em>. To use it as a library, first, we will have to add it to the Maven POM as a dependency.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Adding JUnit as dependency</h1>
            

            <article>
                
<p class="calibre2">Recall that we have a multi-module project, and the dependency versions are maintained in the parent POM under the <kbd class="calibre11">dependencyManagement</kbd> tag.</p>
<pre class="calibre20">
&lt;dependencyManagement&gt; <br class="title-page-name"/>    &lt;dependencies&gt; <br class="title-page-name"/>        ... <br class="title-page-name"/>        &lt;dependency&gt; <br class="title-page-name"/>            &lt;groupId&gt;junit&lt;/groupId&gt; <br class="title-page-name"/>            &lt;artifactId&gt;junit&lt;/artifactId&gt; <br class="title-page-name"/>            &lt;version&gt;4.12&lt;/version&gt; <br class="title-page-name"/>            &lt;scope&gt;test&lt;/scope&gt; <br class="title-page-name"/>        &lt;/dependency&gt; <br class="title-page-name"/>    &lt;/dependencies&gt; <br class="title-page-name"/>&lt;/dependencyManagement&gt;
</pre>
<p class="calibre2">The scope of the dependency is test, which means that this library is needed only to compile the test code and during the execution of the test. The JUnit library will not make its way to the final released product; there is no need for it. If you find the JUnit library in some deployed production <strong class="calibre1">Web Archive</strong> (<strong class="calibre1">WAR</strong>) file, suspect that somebody was not properly managing the scopes of the libraries.</p>
<p class="calibre2">Maven supports the compilation and the execution of JUnit tests in the lifecycle of the project. If we want to execute the tests, only we can issue the <kbd class="calibre11">mvn test</kbd> command. The IDEs also support the execution of the unit tests. Usually, the same menu item that can be used to execute a class that has a <kbd class="calibre11">public static main</kbd> method can be used. If the class is a unit test utilizing JUnit, the IDE will recognize it and execute the tests and usually give a graphical feedback on what test was executing fine and which ones failed, and how.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Writing the BubbleSortTest class</h1>
            

            <article>
                
<p class="calibre2">The test classes are separated from the production classes. They go into the <kbd class="calibre11">src/test/java</kbd> directory. When we have a class named, for example, <kbd class="calibre11">BubbleSort</kbd>, then the test will be named <kbd class="calibre11">BubbleSortTest</kbd>. This convention helps the executing environment to separate the tests from those classes that do not contain tests but are needed to execute the tests. To test the sort implementation we have just created, we can furnish a class that contains, for now, a single <kbd class="calibre11">canSortStrings</kbd> method.</p>
<p class="calibre2">Unit test method names are used to document the functionality being tested. As the JUnit framework invokes each and every method that has the <kbd class="calibre11">@Test</kbd> annotation, the name of the test is not referenced anywhere in our code. We can bravely use arbitrary long method names; it will not hinder readability at the place where the method is invoked.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>// imports deleted from print <br class="title-page-name"/><br class="title-page-name"/>public class BubbleSortTest { <br class="title-page-name"/><br class="title-page-name"/>    @Test <br class="title-page-name"/>    public void canSortStrings() { <br class="title-page-name"/>        ArrayList actualNames = new ArrayList(Arrays.asList( <br class="title-page-name"/>                "Johnson", "Wilson", <br class="title-page-name"/>                "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>        ));
</pre>
<p class="calibre2">The method contains <kbd class="calibre11">ArrayList</kbd> with the actual names that we have already gotten familiar with. As we have a sort implementation and interface that needs <kbd class="calibre11">SortableCollection</kbd>, we will create one backed up by <kbd class="calibre11">ArrayList</kbd>.</p>
<pre class="calibre20">
        SortableCollection namesCollection = new SortableCollection() { <br class="title-page-name"/><br class="title-page-name"/>            @Override <br class="title-page-name"/>            public Object get(int i) { <br class="title-page-name"/>                return actualNames.get(i); <br class="title-page-name"/>            } <br class="title-page-name"/><br class="title-page-name"/>            @Override <br class="title-page-name"/>            public int size() { <br class="title-page-name"/>                return actualNames.size(); <br class="title-page-name"/>            } <br class="title-page-name"/>        };
</pre>
<p class="calibre2">We declared a new object that has the <kbd class="calibre11">SortableCollection</kbd> type, which is an interface. To instantiate something that implements <kbd class="calibre11">SortableCollection</kbd>, we will need a class. We cannot instantiate an interface. In this case, define the class in the place of the instantiation. This is called an anonymous class in Java. The name comes from the fact that the name of the new class is not defined in the source code. The Java compiler will automatically create a name for the new class, but that is not interesting for the programmers. We will simply write <kbd class="calibre11">new SortableCollection()</kbd> and provide the needed implementation immediately following between <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd>. It is very convenient to define this anonymous class inside the method as, this way, it can access <kbd class="calibre11">ArrayList</kbd> without passing a reference to <kbd class="calibre11">ArrayList</kbd> in the class.</p>
<p class="calibre2">As a matter of fact, the reference is needed, but the Java compiler automatically does this. The Java compiler, in this case, also takes care that automatic reference passing this way can only be done using variables that were initialized and will not change during the execution of the code after the instantiation of the anonymous class. The variable <kbd class="calibre11">actualNames</kbd> was set and it should not be changed in the method later. As a matter of fact, we can even define <kbd class="calibre11">actualNames</kbd> to be final and this would have been a requirement if we used Java 1.7 or earlier. Starting with 1.8, the requirement is that the variable is effectively final, but you need not declare it to be final.</p>
<p class="calibre2">The next thing that we need is a <kbd class="calibre11">Swapper</kbd> implementation for <kbd class="calibre11">ArrayList</kbd>. In this case, we will define a whole class inside the method. It can also be an anonymous class, but this time I decided to use a named class to demonstrate that a class can be defined inside a method. Usually, we do not do that in production projects.</p>
<pre class="calibre20">
        class SwapActualNamesArrayElements implements Swapper { <br class="title-page-name"/>            @Override <br class="title-page-name"/>            public void swap(int i, int j) { <br class="title-page-name"/>                final Object tmp = actualNames.get(i); <br class="title-page-name"/>                actualNames.set(i,actualNames.get(j)); <br class="title-page-name"/>                actualNames.set(j, tmp); <br class="title-page-name"/><br class="title-page-name"/>            } <br class="title-page-name"/>        }
</pre>
<p class="calibre2">Last, but not least, we will need a comparator before we can invoke the sort. As we have <kbd class="calibre11">String</kbd>s to compare, this is easy and straightforward.</p>
<pre class="calibre20">
        Comparator stringCompare = new Comparator() { <br class="title-page-name"/>            @Override <br class="title-page-name"/>            public int compare(Object first, Object second) { <br class="title-page-name"/>                final String f = (String) first; <br class="title-page-name"/>                final String s = (String) second; <br class="title-page-name"/>                return f.compareTo(s); <br class="title-page-name"/>            } <br class="title-page-name"/>        };
</pre>
<p class="calibre2">Having everything prepared for the sorting, we will finally need an instance of the Sort implementation, set the <kbd class="calibre11">comparator</kbd> and the <kbd class="calibre11">swapper</kbd>, and invoke the sort.</p>
<pre class="calibre20">
        Sort sort = new BubbleSort(); <br class="title-page-name"/>        sort.setComparator(stringCompare); <br class="title-page-name"/>        sort.setSwapper(new SwapActualNamesArrayElements()); <br class="title-page-name"/>        sort.sort(namesCollection);
</pre>
<p class="calibre2">The last, but most important part of the test is to assert that the result is the one that we expect. JUnit helps us do that with the aid of the <kbd class="calibre11">Assert</kbd> class.</p>
<pre class="calibre20">
        Assert.assertEquals(Arrays.asList("Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson"), actualNames); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>}
</pre>
<p class="calibre2">The call to <kbd class="calibre11">assertEquals</kbd> checks that the first argument, the expected result, equals the second argument, the sorted <kbd class="calibre11">actualNames</kbd>. If they differ, then <kbd class="calibre11">AssertionError</kbd> is thrown; otherwise, the test just finishes fine.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Good unit tests</h1>
            

            <article>
                
<p class="calibre2">Is this a good unit test? If you read it in a tutorial book like this, it has to be. Actually, it is not. It is a good code to demonstrate some of the tools that JUnit provides and some Java language features, but as a real JUnit test, I will not use it in a real life project.</p>
<p class="calibre2">What makes a unit test good? To answer this question, we will have to find what the unit test is good for and what it is that we use it for.</p>
<div class="packtinfobox">We will create unit tests to validate the operation of the units and to document.</div>
<p class="calibre2">Unit tests are not to find bugs. Developers eventually use unit tests during debugging sessions but, many times, the testing code created for the debugging is a temporary one. When the bug is fixed, the code used to find it will not get into the source code. For every new bug, there should be a new test created that covers the functionality that was not properly working, but it is hardly the test code that is used to find the bug. This is because unit tests are mainly for documentation. You can document a class using <em class="calibre12">JavaDoc</em>, but the experience shows that the documentation often becomes outdated. The developers modify the code, but they do not modify the documentation, and the documentation becomes obsolete and misleading. Unit tests, however, are executed by the build system and if <strong class="calibre1">Continuous Integration</strong> (<strong class="calibre1">CI</strong>) is in use (and it should be, in a professional environment), then the build will be broken if a test fails, all developers will get mail notification about it, and it will drive the developer breaking the build to fix the code or the test. This way, the tests verify that continuous development did not break anything in the code or, at least, not something that can be discovered using unit tests.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A good unit test is readable</h1>
            

            <article>
                
<p class="calibre2">Our test is far from being readable. A test case is readable if you look at it and in 15 seconds you can tell what it does. It assumes, of course, some experience in Java on behalf of the reader, but you get the point. Our test is cluttered with support classes that are not core to the test.</p>
<p class="calibre2">Our test also hardly validates that the code is working properly. It actually does not. There are some bugs in it that I put there deliberately, which we will locate and zap in the following sections. One single test that sorts a single <kbd class="calibre11">String</kbd> array is far from validating a sort implementation. If I were to extend this test to a real-world test, we would need methods that would have the name <kbd class="calibre11">canSortEmptyCollection</kbd>, <kbd class="calibre11">canSortOneElementCollection</kbd>, <kbd class="calibre11">canSortTwoElements</kbd>, <kbd class="calibre11">canSortReverseOrder</kbd>, or <kbd class="calibre11">canSortAlreadySorted</kbd>. If you look at the names, you will see what tests we need. Coming from the nature of the sort problem, an implementation may be reasonably sensitive to errors in these special cases.</p>
<p class="calibre2">What are the good points in our unit test, in addition to it being an acceptable demonstration tool?</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Unit tests are fast</h1>
            

            <article>
                
<p class="calibre2">Our unit test runs fast. As we execute unit tests each time, the CI fires up a build and the execution of the tests should not last long. You should not create a unit test sorting billions of elements. That is a kind of stability or load test and they should run in separate test periods and not every time the build is running. Our unit test sorts five elements that are reasonable.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Unit tests are deterministic</h1>
            

            <article>
                
<p class="calibre2">Our unit test is deterministic. Non-deterministic unit tests are the nightmare of the developers. If you are in a group where some builds break on the CI server, and when a build breaks, your fellow developer says that you just have to try it again; no way! If a unit test runs, it should run all times. If it fails, it should fail no matter how many times you start it. A non-deterministic unit test, in our case, will be to render random numbers and have them sorted. We will end up with different arrays in each test run and, in case there is some bug in the code that manifests for some array, we will not be able to reproduce it. Not to mention that the assertion that the code was running fine is also difficult.</p>
<p class="calibre2">If we sorted a random array in a unit test (something we do not), we could, hypothetically, assert that the array is sorted, comparing the elements one after the other checking that they are in ascending order. It would also be a totally wrong practice.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Assertions should be as simple as possible</h1>
            

            <article>
                
<p class="calibre2">If the assertion is complex, the risk of introducing bugs in the assertion is higher. The more complex the assertion, the higher the risk. We will write the unit tests to ease our lives and not to have more code to debug.</p>
<p class="calibre2">Additionally, one test should assert only one thing. This one assertion may be coded with multiple <kbd class="calibre11">Assert</kbd> class methods, one after the other. Still, the aim of these is to assert the correctness of one single feature of the unit. Remember the SRP: one test, one feature. A good test is like a good sniper: one shot, one kill.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Unit tests are isolated</h1>
            

            <article>
                
<p class="calibre2">When we test a unit <em class="calibre12">A</em>, any change in another unit <em class="calibre12">B</em>, or a bug in a different unit should not affect our unit test that is for the unit <em class="calibre12">A</em>. In our case, it was easy because we have only one unit. Later, when we develop the test for the quick sort, we will see that this separation is not that simple.</p>
<p class="calibre2">If the unit tests are properly separated, a failing unit test clearly points out the location of the problem. It is in the unit where the unit test failed. If tests do not separate the units, then a failure in one test may be caused by a bug in a different unit than we expect. In this case, these tests are not really unit tests.</p>
<p class="calibre2">In practice, you should make a balance. If the isolation of the units will be too costly, you can decide to create integration tests; and, if they still run fast, have them executed by the <em class="calibre12">CI system</em>. At the same time, you should also try to find out why the isolation is hard. If you cannot easily isolate the units in the tests, it means that the units are too strongly coupled, which may not be a good design.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Unit tests cover the code</h1>
            

            <article>
                
<p class="calibre2">Unit tests should test all usual and also all special cases of the functionality. If there is a special case of code that is not covered by the unit test, the code is in danger. In case of a sort implementation, the general case is sorting, say five elements. The special cases are much more numerous usually. How does our code behave if there is only one element or if there are no elements? What if there are two? What if the elements are in reverse order? What if they are already sorted?</p>
<p class="calibre2">Usually, the special cases are not defined in the specification. The programmer has to think about it before coding, and some special cases are discovered during coding. The hard thing is that you just cannot tell if you covered all special cases and the functionality of the code.</p>
<p class="calibre2">What you can tell is if all the lines of code were executed during the testing or not. If 90% of the code lines are executed during the tests, then the code coverage is 90%, which is fairly good in real life, but you should never be content with anything less than 100%.</p>
<p class="calibre2">Code coverage is not the same as functional coverage, but there is a correlation. If the code coverage is less than 100%, then at least one of the following two statements is true:</p>
<ul class="calibre14">
<li class="calibre15">The functional coverage is not 100%</li>
<li class="calibre15">There is unused code in the tested unit, which can just be deleted</li>
</ul>
<p class="calibre2">The code coverage can be measured, the functional coverage cannot. The tools and IDEs support code coverage measurement. These measurements are integrated into the editor so you will not only get the percentage of the coverage, but the editor will show you exactly which lines are not covered by the coverage coloring the lines (in Eclipse, for example) or the gutter on the left side of the editor window (IntelliJ). The picture shows that in IntelliJ, the tests cover the lines indicated by a green color on the gutter. (In the print version this is just a grey rectangle).</p>
<div class="packtfigure"><img class="image-border25" src="../images/00037.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Refactor the test</h1>
            

            <article>
                
<p class="calibre2">Now that we have discussed what a good unit test is, let's improve our test. The first thing is to move the supporting classes to separate files. We will create <kbd class="calibre11">ArrayListSortableCollection</kbd>:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.ch03.SortableCollection; <br class="title-page-name"/><br class="title-page-name"/>import java.util.ArrayList; <br class="title-page-name"/><br class="title-page-name"/>public class ArrayListSortableCollection implements SortableCollection { <br class="title-page-name"/>    final private ArrayList actualNames; <br class="title-page-name"/><br class="title-page-name"/>    ArrayListSortableCollection(ArrayList actualNames) { <br class="title-page-name"/>        this.actualNames = actualNames; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public Object get(int i) { <br class="title-page-name"/>        return actualNames.get(i); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public int size() { <br class="title-page-name"/>        return actualNames.size(); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This class encapsulates <kbd class="calibre11">ArrayList</kbd> and then implements the <kbd class="calibre11">get</kbd> and <kbd class="calibre11">size</kbd> methods to <kbd class="calibre11">ArrayList</kbd> access. <kbd class="calibre11">ArrayList</kbd> itself is declared as <kbd class="calibre11">final</kbd>. Recall that a <kbd class="calibre11">final</kbd> field has to be defined by the time the constructor finishes. This guarantees that the field is there when we start to use the object and that it does not change during the object lifetime. Note, however, that the content of the object, in this case, the elements of <kbd class="calibre11">ArrayList</kbd>, may change. If it were not the case, we would not be able to sort it.</p>
<p class="calibre2">The next class is <kbd class="calibre11">StringComparator</kbd>. This is so simple that I will not list it here; I will leave it to you to implement the <kbd class="calibre11">java.util.Comparator</kbd> interface that can compare two Strings. It should not be difficult, especially as this class was already a part of the previous version of the <kbd class="calibre11">BubbleSortTest</kbd> class (hint: it was an anonymous class that we stored in the variable named <kbd class="calibre11">stringCompare</kbd>).</p>
<p class="calibre2">We also have to implement <kbd class="calibre11">ArrayListSwapper</kbd>, which also should not be a big surprise.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.ch03.Swapper; <br class="title-page-name"/><br class="title-page-name"/>import java.util.ArrayList; <br class="title-page-name"/><br class="title-page-name"/>public class ArrayListSwapper implements Swapper { <br class="title-page-name"/>    final private ArrayList actualNames; <br class="title-page-name"/><br class="title-page-name"/>    ArrayListSwapper(ArrayList actualNames) { <br class="title-page-name"/>        this.actualNames = actualNames; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void swap(int i, int j) { <br class="title-page-name"/>        Object tmp = actualNames.get(i); <br class="title-page-name"/>        actualNames.set(i, actualNames.get(j)); <br class="title-page-name"/>        actualNames.set(j, tmp); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Finally, our test will look this:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>// ... imports deleted from print ... <br class="title-page-name"/>public class BubbleSortTest { <br class="title-page-name"/>    @Test <br class="title-page-name"/>    public void canSortStrings() { <br class="title-page-name"/>        ArrayList actualNames = new ArrayList(Arrays.asList( <br class="title-page-name"/>                "Johnson", "Wilson", <br class="title-page-name"/>                "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>        )); <br class="title-page-name"/>        ArrayList expectedResult = new ArrayList(Arrays.asList( <br class="title-page-name"/>                "Abraham", "Dagobert", <br class="title-page-name"/>                "Johnson", "Wilkinson", "Wilson" <br class="title-page-name"/>        )); <br class="title-page-name"/>        SortableCollection names = <br class="title-page-name"/>                new ArrayListSortableCollection(actualNames); <br class="title-page-name"/>        Sort sort = new BubbleSort(); <br class="title-page-name"/>        sort.setComparator( <br class="title-page-name"/>                new StringComparator()); <br class="title-page-name"/>        sort.setSwapper( <br class="title-page-name"/>                new ArrayListSwapper(actualNames)); <br class="title-page-name"/>        sort.sort(names); <br class="title-page-name"/>        Assert.assertEquals(expectedResult, actualNames); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Now this is already a test that can be understood in 15 seconds. It documents well how to use a sort implementation that we defined. It still works and does not reveal any bug, as I promised.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Collections with wrong elements</h1>
            

            <article>
                
<p class="calibre2">The bug is not trivial, and as usual, this is not in the implementation of the algorithm, but rather in the definition, or the lack of it. What should the program do if there are not only strings in the collection that we sort?</p>
<p class="calibre2">If I create a new test that starts with the following lines, it will throw <kbd class="calibre11">ClassCastException</kbd>:</p>
<pre class="calibre20">
@Test <br class="title-page-name"/>public void canNotSortMixedElements() { <br class="title-page-name"/>    ArrayList actualNames = new ArrayList(Arrays.asList( <br class="title-page-name"/>            42, "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    )); <br class="title-page-name"/>... the rest of the code is the same as the previous test
</pre>
<p class="calibre2">The problem here is that Java collections can contain any type of elements. You cannot ever be sure that a collection, such as <kbd class="calibre11">ArrayList</kbd>, contains only the types that you expect. Even if you use generics (we have not learned that, but we will in this chapter), the chances of a bug somehow conjuring up some object of an inappropriate type into a collection, are smaller but are still there. Don't ask me how; I cannot tell you. This is the nature of the bugs—you cannot tell how they work until you zap them. The thing is that you have to be prepared for such an exceptional case.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Handling exceptions</h1>
            

            <article>
                
<p class="calibre2">Exceptional cases should be handled in Java using exceptions. The <kbd class="calibre11">ClassCastException</kbd> is there and it happens when the sort tries to compare <kbd class="calibre11">String</kbd> to <kbd class="calibre11">Integer</kbd> using <kbd class="calibre11">StringComparator</kbd>, and to do that, it tries to cast an <kbd class="calibre11">Integer</kbd> to <kbd class="calibre11">String</kbd>.</p>
<p class="calibre2">When an exception is thrown by the program using the <kbd class="calibre11">throw</kbd> command, or by the Java runtime, the execution of the program stops at that point, and instead of executing the next command, it continues where the exception is caught. It can be in the same method, or in some calling method up in the call chain. To catch an exception, the code throwing the exception should be inside a <kbd class="calibre11">try</kbd> block, and the catch statement following the <kbd class="calibre11">try</kbd> block should specify an exception that is compatible with the exception thrown.</p>
<p class="calibre2">If the exception is not caught, then the Java runtime will print out the message of the exception along with a stack trace that will contain all the classes, methods, and line numbers on the call stack at the time of the exception. In our case, the <kbd class="calibre11">mvn test</kbd> command will produce the following trace in the output:</p>
<pre class="calibre20">
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String <br class="title-page-name"/>    at packt.java9.by.example.ch03.bubble.StringComparator.compare(StringComparator.java:9) <br class="title-page-name"/>    at packt.java9.by.example.ch03.bubble.BubbleSort.sort(BubbleSort.java:13) <br class="title-page-name"/>    at packt.java9.by.example.ch03.bubble.BubbleSortTest.canNotSortMixedElements(BubbleSortTest.java:49) <br class="title-page-name"/>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) <br class="title-page-name"/>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) <br class="title-page-name"/>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) <br class="title-page-name"/>    at java.lang.reflect.Method.invoke(Method.java:498) <br class="title-page-name"/>... some lines deleted from the print <br class="title-page-name"/>    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141) <br class="title-page-name"/>    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112) <br class="title-page-name"/>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) <br class="title-page-name"/>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) <br class="title-page-name"/>... some lines deleted from the print <br class="title-page-name"/>    at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85) <br class="title-page-name"/>    at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115) <br class="title-page-name"/>    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)
</pre>
<p class="calibre2">This stack trace is not really long. In the production environment in an application that runs on an application server, the stack trace may contain a few hundred elements. In this trace, you can see that Maven was starting the test execution, involved Maven surefire plugin, and then the JUnit executor, until we get through the test to the comparator, where the actual exception was thrown.</p>
<p class="calibre2">This exception was not printed by the Java runtime to the console. This exception is caught by the JUnit library code and the stack trace is logged out to the console using Maven logging facility.</p>
<p class="calibre2">The problem with this approach is that the real issue is not the class casting failure. The real issue is that the collection contains mixed elements. It is only realized by the Java runtime when it tries to cast two incompatible classes. Our code can be smarter. We can amend the comparator.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/>import java.util.Comparator; <br class="title-page-name"/>public class StringComparator implements Comparator { <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public int compare(Object first, Object second) { <br class="title-page-name"/>        try { <br class="title-page-name"/>            final String f = (String) first; <br class="title-page-name"/>            final String s = (String) second; <br class="title-page-name"/>            return f.compareTo(s); <br class="title-page-name"/>        } catch (ClassCastException cce) { <br class="title-page-name"/>            throw new NonStringElementInCollectionException ( <br class="title-page-name"/>                    "There are mixed elements in the collection.", cce); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This code catches the <kbd class="calibre11">ClassCastException</kbd> and throws a new one. The advantage of throwing a new exception is that you can be sure that this exception is thrown from the comparator and that the problem really is that there are mixed elements in the collection. Class casting problems may happen at other places of the code as well, inside some of the sort implementations. Some application code may want to catch the exception and want to handle the case; for example, sending an application-specific error message and not dumping only a stack trace to the user. This code can catch <kbd class="calibre11">ClassCastException</kbd> as well, but it cannot be sure what the real cause of the exception is. On the other hand, <kbd class="calibre11">NonStringElementInCollectionException</kbd> is definite.</p>
<p class="calibre2">The <kbd class="calibre11">NonStringElementInCollectionException</kbd> is an exception that does not exist in the JDK. We will have to create it. Exceptions are Java classes and our exception looks as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/><br class="title-page-name"/>public class NonStringElementInCollectionException extends RuntimeException { <br class="title-page-name"/>    public NonStringElementInCollectionException (String message, Throwable cause) { <br class="title-page-name"/>        super(message, cause); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Java has the notion of checked exceptions. It means that any exception that is not extending <kbd class="calibre11">RuntimeException</kbd> should be declared in the method definition. Suppose our exception was declared as follows:</p>
<pre class="calibre20">
public class NonStringElementInCollectionException extends Exception
</pre>
<p class="calibre2">Then, we will have to declare the <kbd class="calibre11">compare</kbd> method as follows:</p>
<pre class="calibre20">
public int compare(Object first, Object second) throws NonStringElementInCollectionException
</pre>
<p class="calibre2">The problem is that the exception a method throws is part of the method signature, and this way <kbd class="calibre11">compare</kbd> will not override the <kbd class="calibre11">compare</kbd> method of the interface, and, that way, the class will not implement the <kbd class="calibre11">Comparator</kbd> interface. Thus, our exception has to be a runtime exception.</p>
<p class="calibre2">There can be a hierarchy of exceptions in an application, and often, novice programmers create huge hierarchies of them. If there is something you can do, it does not mean that you should do it. Hierarchies should be kept as flat as possible, and this is especially true for exceptions. If there is an exception in the JDK that describes the exceptional case, then use the readymade exception. Just as well as for any other class: if it is ready, do not implement it again.</p>
<p class="calibre2">It is also important to note that throwing an exception should only be done in exceptional cases. It is not to signal some normal operational condition. Doing that hinders readability of the code and also eats CPU. Throwing an exception is not an easy task for the JVM.</p>
<p class="calibre2">It is not only the exception that can be thrown. The <kbd class="calibre11">throw</kbd> command can throw, and the <kbd class="calibre11">catch</kbd> command can catch anything that extends the <kbd class="calibre11">Throwable</kbd> class. There are two subclasses of <kbd class="calibre11">Throwable</kbd>: <kbd class="calibre11">Error</kbd>, and <kbd class="calibre11">Exception</kbd>. The <kbd class="calibre11">Error</kbd> exception is thrown if some error happened during the execution of the Java code. The two most infamous errors are <kbd class="calibre11">OutOfMemoryError</kbd> and <kbd class="calibre11">StackOverflowError</kbd>. If any of these happens, you cannot do anything reliably to catch the error.</p>
<div class="packttip">There is also <kbd class="calibre22">InternalError</kbd> and <kbd class="calibre22">UnknownError</kbd> in the JVM, but since JVM is fairly stable, you will hardly ever meet these errors.</div>
<p class="calibre2">When any of those errors happen, try to debug the code and try to find out why you use that much memory or such deep method calls and try to optimize your solution. What I have just said about creating exception hierarchies is true again to catch errors. The fact that you can catch errors does not mean that you should. On the contrary, you should never catch an error and, especially, never ever catch a <kbd class="calibre11">Throwable</kbd>.</p>
<p class="calibre2">This way, we handled this special case when some programmer accidentally writes 42 among the names, but will it be nicer if the error was identified during compile time? To do that, we will introduce generics.</p>
<p class="calibre2">Just a last thought before we go there. What class behavior do we test with the <kbd class="calibre11">canNotSortMixedElements</kbd> unit test? The test is inside the <kbd class="calibre11">BubbleSortTest</kbd> test class, but the functionality is in the comparator implementation, <kbd class="calibre11">StringComparator</kbd>. This test checks something that is out of the scope of the unit test class. I can use it for demonstration purposes, but this is not a unit test. The real functionality of the sort implementation can be formulized this way: whatever exception the comparator throws is thrown by the sort implementation. You can try to write this unit test, or read on; we will have it in the next section.</p>
<p class="calibre2">The <kbd class="calibre11">StringComparator</kbd> class does not have a test class because <kbd class="calibre11">StringComparator</kbd> is part of the test and we will never write a test for a test. Otherwise, we will sink into an endless rabbit hole.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Generics</h1>
            

            <article>
                
<p class="calibre2">The generics feature was introduced into Java in version 5. To start with an example, our <kbd class="calibre11">Sortable</kbd> interface until now was this:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/>public interface SortableCollection { <br class="title-page-name"/>    Object get(int i); <br class="title-page-name"/>    int size(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">After introducing generics, it will be as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/><br class="title-page-name"/>public interface SortableCollection&lt;E&gt; { <br class="title-page-name"/>    E get(int i); <br class="title-page-name"/>    int size(); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre11">E</kbd> identifier denotes a type. It can be any type. It says that a class is a sortable collection if it implements the interface, namely the two methods— <kbd class="calibre11">size</kbd> and <kbd class="calibre11">get</kbd>. The <kbd class="calibre11">get</kbd> method should return something that is of type <kbd class="calibre11">E</kbd>, whatever <kbd class="calibre11">E</kbd> is. This may not make too much sense up until now, but you will soon get the point. After all, generics is a difficult topic.</p>
<p class="calibre2">The <kbd class="calibre11">Sort</kbd> interface will become the following:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03; <br class="title-page-name"/>import java.util.Comparator; <br class="title-page-name"/>public interface Sort&lt;E&gt; { <br class="title-page-name"/>    void sort(SortableCollection&lt;E&gt; collection); <br class="title-page-name"/>    void setSwapper(Swapper swap); <br class="title-page-name"/>    void setComparator(Comparator&lt;E&gt; compare); <br class="title-page-name"/>}
</pre>
<p class="calibre2">This still does not provide much more value than the previous version without generics, but, at least, it does something. In the actual class implementing the <kbd class="calibre11">Sort</kbd> interface, <kbd class="calibre11">Comparator</kbd> should accept the same type that <kbd class="calibre11">SortableCollection</kbd> uses. It is not possible that <kbd class="calibre11">SortableCollection</kbd> works on strings and we inject a comparator for integers.</p>
<p class="calibre2">The implementation of <kbd class="calibre11">BubbleSort</kbd> is as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.bubble; <br class="title-page-name"/>import packt.java9.by.example.ch03.*; <br class="title-page-name"/>import java.util.Comparator; <br class="title-page-name"/>public class BubbleSort&lt;E&gt; implements Sort&lt;E&gt; { <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void sort(SortableCollection&lt;E&gt; collection) { <br class="title-page-name"/>        ... sort code same as before <br class="title-page-name"/>    } <br class="title-page-name"/>    private Comparator&lt;E&gt; comparator = null; <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void setComparator(Comparator&lt;E&gt; comparator) { <br class="title-page-name"/>        this.comparator = comparator; <br class="title-page-name"/>    } <br class="title-page-name"/>        ... method swapper same as before <br class="title-page-name"/>}
</pre>
<p class="calibre2">The real power of generics will come when we will write the tests. The first test does not change much, although with the generics, it is more definite.</p>
<pre class="calibre20">
@Test <br class="title-page-name"/>public void canSortStrings() { <br class="title-page-name"/>    ArrayList&lt;String&gt; actualNames = new ArrayList&lt; &gt;(Arrays.asList( <br class="title-page-name"/>            "Johnson", "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    )); <br class="title-page-name"/>    ArrayList&lt;String&gt; expectedResult = new ArrayList&lt;&gt;(Arrays.asList( <br class="title-page-name"/>            "Abraham", "Dagobert", <br class="title-page-name"/>            "Johnson", "Wilkinson", "Wilson" <br class="title-page-name"/>    )); <br class="title-page-name"/>    SortableCollection&lt;String&gt; names = <br class="title-page-name"/>            new ArrayListSortableCollection&lt;&gt;(actualNames); <br class="title-page-name"/>    Sort&lt;String&gt; sort = new BubbleSort&lt;&gt;(); <br class="title-page-name"/>    sort.setComparator(String::compareTo); <br class="title-page-name"/>    sort.setSwapper(new ArrayListSwapper&lt;&gt;(actualNames)); <br class="title-page-name"/>    sort.sort(names); <br class="title-page-name"/>    Assert.assertEquals(expectedResult, actualNames); <br class="title-page-name"/>}
</pre>
<p class="calibre2">When we define <kbd class="calibre11">ArrayList</kbd>, we will also declare that the elements of the list will be strings. When we allocate the new <kbd class="calibre11">ArrayList</kbd>, there is no need to specify again that the elements are strings because it comes from the actual elements there. Each of them is a string; therefore, the compiler knows that the only thing that can come between the <kbd class="calibre11">&lt;</kbd> and <kbd class="calibre11">&gt;</kbd> character is <kbd class="calibre11">String</kbd>.</p>
<p class="calibre2">The two characters <kbd class="calibre11">&lt;</kbd> and <kbd class="calibre11">&gt;</kbd>, without the type definition in between, is called <strong class="calibre1">diamond operator</strong>. The type is inferred. If you get used to generics, this code brings you more information on the types that the collections work on and the code becomes more readable. The readability and the extra information is not the only point.</p>
<p class="calibre2">As we know that the <kbd class="calibre11">Comparator</kbd> argument is <kbd class="calibre11">Comparator&lt;String&gt;</kbd> now, we can use advanced features of Java available since Java 8 and can pass the <kbd class="calibre11">String::compareTo</kbd> method reference to the comparator setter.</p>
<p class="calibre2">The second test is the important one for us now. This is the test which ensures that <kbd class="calibre11">Sort</kbd> does not interfere with the exception that the comparator throws.</p>
<pre class="calibre20">
@Test(expected = RuntimeException.class) <br class="title-page-name"/>public void throwsWhateverComparatorDoes () { <br class="title-page-name"/>    ArrayList&lt;String&gt; actualNames = new ArrayList&lt;&gt;(Arrays.asList( <br class="title-page-name"/>            42, "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    )); <br class="title-page-name"/>    SortableCollection&lt;String&gt; names = <br class="title-page-name"/>            new ArrayListSortableCollection&lt;&gt;(actualNames); <br class="title-page-name"/>    Sort&lt;String&gt; sort = new BubbleSort&lt;&gt;(); <br class="title-page-name"/>    sort.setComparator((String a, String b) -&gt; { <br class="title-page-name"/>        throw new RuntimeException(); <br class="title-page-name"/>    }); <br class="title-page-name"/>    final Swapper neverInvoked = null; <br class="title-page-name"/>    sort.setSwapper(neverInvoked);  <br class="title-page-name"/>    sort.sort(names); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The thing is, that it does not even compile. The compiler says that it cannot infer the type of <kbd class="calibre11">ArrayList&lt;&gt;</kbd> on the third line. When all the arguments of the <kbd class="calibre11">asList</kbd> method were strings, the method returned a list of <kbd class="calibre11">String</kbd> elements and therefore the new operator was known to generate <kbd class="calibre11">ArrayList&lt;String&gt;</kbd>. This time, there is an integer, and thus, the compiler cannot infer that <kbd class="calibre11">ArrayList&lt;&gt;</kbd> is for <kbd class="calibre11">String</kbd> elements.</p>
<p class="calibre2">To change the type definition from <kbd class="calibre11">ArrayList&lt;&gt;</kbd> to <kbd class="calibre11">ArrayList&lt;String&gt;</kbd> is not a cure. In that case, the compiler will complain about the value <kbd class="calibre11">42</kbd>. This is the power of generics. When you use classes that have type parameters, the compiler can detect when you provide a value of the wrong type. To get the value into <kbd class="calibre11">ArrayList</kbd> to check that the implementation really throws an exception, we will have to conjure the value into it. We can try to replace the value <kbd class="calibre11">42</kbd> with an empty <kbd class="calibre11">String</kbd> and then add the following line which will still not compile:</p>
<pre class="calibre20">
actualNames.set(0,42);
</pre>
<p class="calibre2">The compiler will still know that the value you want to set in <kbd class="calibre11">ArrayList</kbd> is supposed to be <kbd class="calibre11">String</kbd>. To get the array with the <kbd class="calibre11">Integer</kbd> element, you will have to explicitly unlock the safety handle and pull the trigger, shooting yourself:</p>
<pre class="calibre20">
((ArrayList)actualNames).set(0,42);
</pre>
<p class="calibre2">Now, the test looks like this:</p>
<pre class="calibre20">
@Test(expected = RuntimeException.class) <br class="title-page-name"/>public void throwsWhateverComparatorDoes() { <br class="title-page-name"/>    ArrayList&lt;String&gt; actualNames = new ArrayList&lt;&gt;(Arrays.asList( <br class="title-page-name"/>            "", "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    )); <br class="title-page-name"/>    ((ArrayList) actualNames).set(0, 42); <br class="title-page-name"/>    SortableCollection&lt;String&gt; names = <br class="title-page-name"/>            new ArrayListSortableCollection&lt;&gt;(actualNames); <br class="title-page-name"/>    Sort&lt;String&gt; sort = new BubbleSort&lt;&gt;(); <br class="title-page-name"/>    sort.setComparator((a, b) -&gt; { <br class="title-page-name"/>        throw new RuntimeException(); <br class="title-page-name"/>    }); <br class="title-page-name"/>    final Swapper neverInvoked = null; <br class="title-page-name"/>    sort.setSwapper(neverInvoked); <br class="title-page-name"/>    sort.sort(names); <br class="title-page-name"/>}
</pre>
<div class="packttip">We will set the Swapper to be null because it is never invoked. When I first wrote this code, it was evident to me. A few days later, I read the code and I stopped. <em class="calibre27">Why is swapper null?</em> Then I remembered in a second or two. But any time, when reading and understanding the code hicks up, I tend to think about refactoring.<br class="calibre23"/>
I can add a comment to the line saying <kbd class="calibre22">//never invoked</kbd>, but comments tend to remain there even when functionality changes. I learned it the hard way in 2006, when a wrong comment prevented me from seeing how the code was executing. I was reading the comment while debugging, instead of the code, and bug fixing took two days while the system was down.<br class="calibre23"/>
Instead of a comment, I tend to use constructs that make the code express what happens. The extra variable may make the class file a few bytes bigger, but it is optimized out by the JIT compiler so the final code does not run slower.</div>
<p class="calibre2">The comparator that throws an exception was provided as a lambda expression. Lambda expressions can be used in cases where an anonymous class or named class will be used having only one simple method. Lambda expressions are anonymous methods stored in variables or passed in argument for later invocation. We will discuss the details of lambda expressions in <a href="part0233.html" class="calibre6"><span>Chapter 8</span></a>, <em class="calibre12">Extending our E-Commerce Application</em>.</p>
<p class="calibre2">For now, we will go on implementing <kbd class="calibre11">QuickSort</kbd>, and to do that, we will use the TDD methodology.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Test Driven Development</h1>
            

            <article>
                
<p class="calibre2">Test Driven Development (TDD) is a code writing approach when the developers first write a test based on the specification and then write the code. This is just the opposite that the developer community got used to. The conventional approach that we followed was to write the code and then write tests for it. To be honest, the real practice many times was to write the code and test it with ad-hoc tests and no unit tests at all. Being a professional, you will never do that, by the way. You always write tests. (And now, write it down a hundred times: I will always write tests.)</p>
<p class="calibre2">One of the advantages of TDD is that the tests do not depend on the code. As the code does not exist at the creation of the test, developers cannot rely on the implementation of the unit and, thus, it cannot influence the test creation process. This is generally good. Unit tests should be black box tests as much as possible.</p>
<div class="packtinfobox">Black box test is a test that does not take into account the implementation of the tested system. If a system is refactored, implemented in a different way, but the interface it provides toward the external world is the same, then the black box tests should run just fine.<br class="calibre23"/>
A white box test depends on the internal working of the system tested. When the code changes the white box test, the code may also need tuning to follow the change. The advantage of a white box test can be the simpler test code. Not always.<br class="calibre23"/>
Gray box test is a mixture of the two.</div>
<p class="calibre2">Unit tests should be black box tests, but, many times, it is not simple to write a black box test. Developers will write a test that they think is black box, but many times, this belief proves to be false. When the implementation changes, something is refactored and the test does not work anymore and it needs to be corrected. It just happens that knowing the implementation, the developers, especially those who wrote the unit, will write a test that depends on the internal working of the code. Writing the test before the code is a tool to prevent this. If there is no code, you cannot depend on it.</p>
<p class="calibre2">TDD also says that the development should be an iterative approach. You write only one test at the start. If you run, it fails. Of course it fails! As there is no code yet, it has to fail. Then, you will write the code that fulfills this test. Nothing more, only the code that makes this test pass. Then, you will go on writing a new test for another part of the specification. You will run it and it fails. This proves that the new test does test something that was not developed yet. Then, you will develop the code to satisfy the new test and, possibly, you will also modify a block of code that you have already written in the previous iterations. When the code is ready, the tests will pass.</p>
<p class="calibre2">Many times, developers are reluctant to modify the code. This is because they are afraid of breaking something that was already working. When you follow TDD, you should not, and at the same time, you need not be afraid of this. There are tests for all features that were already developed. If some of the code modification breaks some functionality, the tests will immediately signal the error. The key is that you run the tests as often as possible when the code is modified.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing QuickSort</h1>
            

            <article>
                
<p class="calibre2">Quick sort, as we have already discussed, is made of two major parts. One is partitioning and the other one is doing the partitioning recursively until the whole array is sorted. To make our code modular and ready to demonstrate the Java 9 module-handling feature, we will develop the partitioning and the recursive sorting into separate classes and in a separate package. The complexity of the code will not justify this separation.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The partitioning class</h1>
            

            <article>
                
<p class="calibre2">The partitioning class should provide a method that moves the elements of the collection based on a pivot element, and we will need to know the position of the pivot element after the method finishes. The signature of the method should look something like this:</p>
<pre class="calibre20">
public int partition(SortableCollection&lt;E&gt; sortable, int start, int end, E pivot);
</pre>
<p class="calibre2">The class should also have access to <kbd class="calibre11">Swapper</kbd> and <kbd class="calibre11">Comparator</kbd>. In this case, we defined a class and not an interface; therefore, we will use constructor injection.</p>
<div class="packttip">These constructs, like setters and constructor injectors, are so common and happen so frequently that IDEs support the generation of these. You will need to create the <kbd class="calibre22">final</kbd> fields in the code and use the <em class="calibre27">code generation</em> menu to create the constructor.</div>
<p class="calibre2">The partitioning class will look like the following:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.qsort; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.ch03.SortableCollection; <br class="title-page-name"/>import packt.java9.by.example.ch03.Swapper; <br class="title-page-name"/><br class="title-page-name"/>import java.util.Comparator; <br class="title-page-name"/><br class="title-page-name"/>public class Partitioner&lt;E&gt; { <br class="title-page-name"/><br class="title-page-name"/>    private final Comparator&lt;E&gt; comparator; <br class="title-page-name"/>    private final Swapper swapper; <br class="title-page-name"/>    public Partitioner(Comparator&lt;E&gt; comparator, Swapper swapper){ <br class="title-page-name"/>        this.comparator = comparator; <br class="title-page-name"/>        this.swapper = swapper; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public int partition(SortableCollection&lt;E&gt; sortable, int start, int end, E pivot){ <br class="title-page-name"/>        return 0; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This code does nothing, but that is how TDD starts. We will create the definition of a requirement providing the skeleton of the code and the test that will call it. To do that, we will need something that we can partition. The simplest choice is an <kbd class="calibre11">Integer</kbd> array. The <kbd class="calibre11">partition</kbd> method needs a object of type <kbd class="calibre11">SortableCollection&lt;E&gt;</kbd>, and we will need something that wraps the array and implements this interface. We name that class <kbd class="calibre11">ArrayWrapper</kbd>. This class serves a general purpose and it is not only for the test. Because of that, we create it as production code and as such we put it in the directory <kbd class="calibre11">main</kbd> and not in the directory <kbd class="calibre11">test</kbd>. As this wrapper is independent from the implementation of <kbd class="calibre11">Sort</kbd>, the proper position of this class is in a new <kbd class="calibre11">SortSupportClasses</kbd> module. We will create the new module as it is not part of the interface. Implementations depend on the interface, but not on the support classes. There can also be some application that uses our libraries and may need the interface module and some of the implementation but still does not need the support classes when they deliver the wrapping functionality themselves. After all, we cannot implement all possible wrapping functionality. The SRP also holds for the modules.</p>
<p class="calibre2">Java libraries tend to contain unrelated functionalities. For the short run, it makes the use of the library simpler. You will only need to specify one dependency in your POM file and you will have all the classes and APIs that you need. In the long run, the application gets bigger, carrying a lot of classes that are part of some of the libraries but the application never uses them.</p>
<p class="calibre2">To add the new module, the module directory has to be created along with the source directories and the POM file. The module has to be added to the parent POM and it also has to be added to the <kbd class="calibre11">dependencyManagement</kbd> section so that the test code of the <kbd class="calibre11">QuickSort</kbd> module can use it without specifying the version. The new module depends on the interface module, so this dependency has to be added to the POM of the support classes.</p>
<p class="calibre2">The <kbd class="calibre11">ArrayWrapper</kbd> class is simple and general.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.support; <br class="title-page-name"/>import packt.java9.by.example.ch03.SortableCollection; <br class="title-page-name"/>public class ArrayWrapper&lt;E&gt; implements SortableCollection&lt;E&gt; { <br class="title-page-name"/>    private final E[] array; <br class="title-page-name"/>    public ArrayWrapper(E[] array) { <br class="title-page-name"/>        this.array = array; <br class="title-page-name"/>    } <br class="title-page-name"/>    public E[] getArray() { <br class="title-page-name"/>        return array; <br class="title-page-name"/>    } <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public E get(int i) { <br class="title-page-name"/>        return array[i]; <br class="title-page-name"/>    } <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public int size() { <br class="title-page-name"/>        return array.length; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre11">ArraySwapper</kbd> class, which we also need, comes into the same module. It is just as simple as the wrapper.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.support; <br class="title-page-name"/>import packt.java9.by.example.ch03.Swapper; <br class="title-page-name"/>public class ArraySwapper&lt;E&gt; implements Swapper { <br class="title-page-name"/>    private final E[] array; <br class="title-page-name"/>    public ArraySwapper(E[] array) { <br class="title-page-name"/>        this.array = array; <br class="title-page-name"/>    } <br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void swap(int k, int r) { <br class="title-page-name"/>        final E tmp = array[k]; <br class="title-page-name"/>        array[k] = array[r]; <br class="title-page-name"/>        array[r] = tmp; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Having these classes, we can create our first test.</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.qsort; <br class="title-page-name"/><br class="title-page-name"/>// imports deleted from print <br class="title-page-name"/><br class="title-page-name"/>public class PartitionerTest {
</pre>
<p class="calibre2">Before creating the <kbd class="calibre11">@Test</kbd> method, we will need two helper methods that make assertions. Assertions are not always simple, and in some cases, they may involve some coding. The general rule is that the test and the assertions in it should be as simple as possible; otherwise, they are just possible source of programming errors. Additionally, we created them to avoid programming errors, not to create new ones.</p>
<p class="calibre2">The <kbd class="calibre11">assertSmallElements</kbd> method asserts that all elements before <kbd class="calibre11">cutIndex</kbd> are smaller than <kbd class="calibre11">pivot</kbd>.</p>
<pre class="calibre20">
    private void assertSmallElements(Integer[] array, int cutIndex, Integer pivot) { <br class="title-page-name"/>        for (int i = 0; i &lt; cutIndex; i++) { <br class="title-page-name"/>            Assert.assertTrue(array[i] &lt; pivot); <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The <kbd class="calibre11">assertLargeElements</kbd> method makes sure that all elements following <kbd class="calibre11">cutIndex</kbd> are at least as large as <kbd class="calibre11">pivot</kbd>.</p>
<pre class="calibre20">
    private void assertLargeElemenents(Integer[] array, int cutIndex, Integer pivot) { <br class="title-page-name"/>        for (int i = cutIndex; i &lt; array.length; i++) { <br class="title-page-name"/>            Assert.assertTrue(pivot &lt;= array[i]); <br class="title-page-name"/>        } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The test uses a constant array of <kbd class="calibre11">Integers</kbd> and wraps it into an <kbd class="calibre11">ArrayWrapper</kbd> class.</p>
<pre class="calibre20">
    @Test <br class="title-page-name"/>    public void partitionsIntArray() { <br class="title-page-name"/>        Integer[] partitionThis = new Integer[]{0, 7, 6}; <br class="title-page-name"/>        Swapper swapper = new ArraySwapper&lt;&gt;(partitionThis); <br class="title-page-name"/>        Partitioner&lt;Integer&gt; partitioner = <br class="title-page-name"/>                new Partitioner&lt;&gt;((a, b) -&gt; a &lt; b ? -1 : a &gt; b ? +1 : 0, swapper); <br class="title-page-name"/>        final Integer pivot = 6; <br class="title-page-name"/>        final int cutIndex = partitioner.partition(new ArrayWrapper&lt;&gt;(partitionThis), 0, 2, pivot); <br class="title-page-name"/>        Assert.assertEquals(1, cutIndex); <br class="title-page-name"/>        assertSmallElements(partitionThis, cutIndex, pivot); <br class="title-page-name"/>        assertLargeElemenents(partitionThis, cutIndex, pivot); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">There is no <kbd class="calibre11">Comparator</kbd> for <kbd class="calibre11">Integer</kbd> type in the JDK, but it is easy to define one as a lambda function. Now we can write the <kbd class="calibre11">partition</kbd> method, as follows:</p>
<pre class="calibre20">
public int partition(SortableCollection&lt;E&gt; sortable, int start, int end, E pivot){ <br class="title-page-name"/>    int small = start; <br class="title-page-name"/>    int large = end; <br class="title-page-name"/>    while( large &gt; small ){ <br class="title-page-name"/>        while( comparator.compare(sortable.get(small), pivot) &lt; 0 &amp;&amp; small &lt; large ){ <br class="title-page-name"/>            small ++; <br class="title-page-name"/>        } <br class="title-page-name"/>        while( comparator.compare(sortable.get(large), pivot) &gt;= 0 &amp;&amp; small &lt; large ){ <br class="title-page-name"/>            large--; <br class="title-page-name"/>        } <br class="title-page-name"/>        if( small &lt; large ){ <br class="title-page-name"/>            swapper.swap(small, large); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>    return large; <br class="title-page-name"/>}
</pre>
<div class="packtfigure"><img class="image-border26" src="../images/00038.jpeg"/></div>
<p class="calibre2">If we run the test, it runs fine. However, if we run the test with coverage, then the IDE tells us that the coverage is only 92%. The test covered only 13 of the 14 lines of the <kbd class="calibre11">partition</kbd> method.</p>
<p class="calibre2">There is a red rectangle on the gutter at line <strong class="calibre1">28</strong>. This is because the test array is already partitioned. There is no need to swap any element in it when the pivot value is <kbd class="calibre11">6</kbd>. It means that our test is good, but not good enough. What if there is an error on that line?</p>
<p class="calibre2">To amend this problem, we will extend the test, changing the test array from <kbd class="calibre11">{ 0, 7, 6 }</kbd> to <kbd class="calibre11">{ 0, 7, 6, 2}</kbd>. Run the test and it fails. Why? After some debugging, we will realize that we invoke the method <kbd class="calibre11">partition</kbd> with the fixed parameter <kbd class="calibre11">2</kbd> as the last index of the array. But, we made the array longer. Why did we write a constant there in the first place? It is a bad practice. Let's replace it with <kbd class="calibre11">partitionThis.length-1</kbd>. Now, it says that <kbd class="calibre11">cutIndex</kbd> is <kbd class="calibre11">2</kbd>, but we expected <kbd class="calibre11">1</kbd>. We forgot to adjust the assertion to the new array. Let's fix it. Now it works.</p>
<p class="calibre2">The last thing is to rethink the assertions. The less code the better. The assertion methods are quite general, and we will use it for one single test array. The assertion methods are so complex that they deserve their own test. But, we do not write code to test. Instead of that, we can simply delete the methods and have the final version of the test.</p>
<pre class="calibre20">
@Test <br class="title-page-name"/>public void partitionsIntArray() { <br class="title-page-name"/>    Integer[] partitionThis = new Integer[]{0, 7, 6, 2}; <br class="title-page-name"/>    Swapper swapper = new ArraySwapper&lt;&gt;(partitionThis); <br class="title-page-name"/>    Partitioner&lt;Integer&gt; partitioner = <br class="title-page-name"/>            new Partitioner&lt;&gt;((a, b) -&gt; a &lt; b ? -1 : a &gt; b ? +1 : 0, swapper); <br class="title-page-name"/>    final Integer pivot = 6; <br class="title-page-name"/>    final int cutIndex = partitioner.partition(new ArrayWrapper&lt;&gt;(partitionThis), 0, partitionThis.length-1, pivot); <br class="title-page-name"/>    Assert.assertEquals(2, cutIndex); <br class="title-page-name"/>    final Integer[] expected = new Integer[]{0, 2, 6, 7}; <br class="title-page-name"/>    Assert.assertArrayEquals(expected,partitionThis); <br class="title-page-name"/>}
</pre>
<p class="calibre2">And then again, is this a black-box test? What if the partitioning returns <kbd class="calibre11">{2, 1, 7, 6}</kbd>? It fits the definition. We can create more complex tests to cover such cases. But a more complex test may also have a bug in the test itself. As a different approach, we can create tests that may be simpler but rely on the internal structure of the implementation. These are not black-box tests and thus not ideal unit tests. I will go for the second one, but I will not argue if someone chooses the other.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Recursive sorting</h1>
            

            <article>
                
<p class="calibre2">We will implement the quick sort with an extra class that is in the <kbd class="calibre11">qsort</kbd> package along with the partitioning class, which is as follows:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.qsort; <br class="title-page-name"/><br class="title-page-name"/>// imports deleted from the print <br class="title-page-name"/><br class="title-page-name"/>public class Qsort&lt;E&gt;  { <br class="title-page-name"/>// constructor injected final fields deleted from the print <br class="title-page-name"/>    public void qsort(SortableCollection&lt;E&gt; sortable, int start, int end) { <br class="title-page-name"/>        if (start &lt; end) { <br class="title-page-name"/>            final E pivot = sortable.get(start); <br class="title-page-name"/>            final Partitioner&lt;E&gt; partitioner = new Partitioner&lt;&gt;(comparator, swapper); <br class="title-page-name"/>            int cutIndex = partitioner.partition(sortable, start, end, pivot); <br class="title-page-name"/>            if (cutIndex == start) { <br class="title-page-name"/>                cutIndex++; <br class="title-page-name"/>            } <br class="title-page-name"/>            qsort(sortable, start, cutIndex - 1); <br class="title-page-name"/>            qsort(sortable, cutIndex, end); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The method gets <kbd class="calibre11">SortableCollection&lt;E&gt;</kbd> and two index parameters. It does not sort the whole collection; it sorts only the elements between the <kbd class="calibre11">start</kbd> and the <kbd class="calibre11">end</kbd> index.</p>
<div class="packttip">It is always important to be extremely precise with the indexing. Usually, there is no problem with the start index in Java, but a lot of bugs source from how the <kbd class="calibre22">end</kbd> index is interpreted.<br class="calibre23"/>
In this method, the value of <kbd class="calibre22">end</kbd> can mean that the index is already not part of the to-be-sorted interval. In that case, the <kbd class="calibre22">partition</kbd> method should be invoked with <kbd class="calibre22">end-1</kbd> and the first recursive call with <kbd class="calibre22">cutIndex</kbd> as last parameter. It is a matter of taste. The important thing is to be precise and define the interpretation of index parameters.</div>
<p class="calibre2">If there is only one element <kbd class="calibre11">(start == end)</kbd>, then there is nothing to be sorted and the method returns. This is the end criterion of the recursion. The method also assumes that the <kbd class="calibre11">end</kbd> index is never smaller than the <kbd class="calibre11">start</kbd> index. As this method is used only inside the library that we are developing at the moment, such an assumption is not too risky to make.</p>
<p class="calibre2">If there is something to be sorted, then the method takes the first element of the to-be-sorted interval and uses it as pivot and calls the <kbd class="calibre11">partition</kbd> method. When the partition is done, the method recursively calls itself for the two halves.</p>
<p class="calibre2">This algorithm is recursive. This means that the method calls itself. When a method call is executed, the processor allocates some memory in an area called <strong class="calibre1">stack</strong> and it stores the local variables there. This area that belongs to the method in the stack is called <strong class="calibre1">stack frame</strong>. When the method returns, this area is released and the stack is restored, simply moving the stack pointer where it was to the previous state. This way a method can continue its execution after calling another method; the local variables are there.</p>
<p class="calibre2">When a method calls itself, it is not different. The local variables are local to the actual call of the method. When the method calls itself, it allocates space for the local variables again on the stack. In other words, these are new <em class="calibre12">instances</em> of the local variables.</p>
<p class="calibre2">We will use recursive methods in Java, and in other programming languages, when the definition of the algorithm is recursive. It is extremely important to understand that when the processor code runs, it is not recursive any more. On that level, there are instructions, register stores, and memory loads and jumps. There is nothing like function or method and therefore, on that level, there is nothing like recursion.</p>
<div class="packtinfobox">If you get that, it is easy to understand that any recursion can be coded as a loop.</div>
<p class="calibre2">As a matter of fact, it is also true the other way around—every loop can be coded as recursion but that is not really interesting until you start functional programming.</p>
<p class="calibre2">The problem with the recursion in Java, and in many other programming languages, is that it may run out of stack space. In the case of quick sort, this is not the case. You can safely assume that the stack for method calling in Java is a few hundreds of levels. Quick sort needs a stack that is approximately <em class="calibre12">log<sub class="calibre30">2</sub>n</em> deep, where <em class="calibre12">n</em> is the number of elements to be sorted. In the case of one billion elements, this is 30 that should just fit.</p>
<div class="packttip">Why is the stack not moved or resized? That is because the code that runs out of the stack space is usually bad style. They can be expressed more readable in form of some loop. A more robust stack implementation would only lure the novice programmer to do some less readable recursive coding.</div>
<p class="calibre2">There is a special case of recursion named tail recursion. A tail recursive method calls itself as the last instruction of the method. When the recursive call returns the code, executing the method does nothing else but release the stack frame that was used for this method invocation. In other words, we will keep the stack frame during the recursive call just to throw it away afterwards. Why not throw it away before the call? In that case, the actual frame, which has the same size and call, will allocate because this is just the same method that is kept and the recursive call is transformed into a jump instruction. This is an optimization that Java does not do. Functional languages are doing it, but Java is not really a functional language and therefore tail-recursive functions should rather be avoided and transformed to a loop in the Java source level.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Non-recursive sorting</h1>
            

            <article>
                
<p class="calibre2">To demonstrate that even non-tail recursive methods can be expressed in a non-recursive way, here is the quick sort that way:</p>
<pre class="calibre20">
public class NonRecursiveQuickSort&lt;E&gt; { <br class="title-page-name"/>    // injected final fields and constructor deleted from print  <br class="title-page-name"/>    private static class Stack { <br class="title-page-name"/>        final int begin; <br class="title-page-name"/>        final int fin; <br class="title-page-name"/>        public Stack(int begin, int fin) { <br class="title-page-name"/>            this.begin = begin; <br class="title-page-name"/>            this.fin = fin; <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public void qsort(SortableCollection&lt;E&gt; sortable, int start, int end) { <br class="title-page-name"/>        final List&lt;Stack&gt; stack = new LinkedList&lt;&gt;(); <br class="title-page-name"/>        final Partitioner&lt;E&gt; partitioner = new Partitioner&lt;&gt;(comparator, swapper); <br class="title-page-name"/>        stack.add(new Stack(start, end)); <br class="title-page-name"/>        int i = 1; <br class="title-page-name"/>        while (!stack.isEmpty()) { <br class="title-page-name"/>            Stack iter = stack.remove(0); <br class="title-page-name"/>            if (iter.begin &lt; iter.fin) { <br class="title-page-name"/>                final E pivot = sortable.get(iter.begin); <br class="title-page-name"/>                int cutIndex = partitioner.partition(sortable, iter.begin, iter.fin, pivot); <br class="title-page-name"/>                if( cutIndex == iter.begin ){ <br class="title-page-name"/>                    cutIndex++; <br class="title-page-name"/>                } <br class="title-page-name"/>                stack.add(new Stack(iter.begin, cutIndex - 1)); <br class="title-page-name"/>                stack.add(new Stack(cutIndex, iter.fin)); <br class="title-page-name"/>            } <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This code implements a stack on the Java level. While it sees that there is still something scheduled to be sorted in <kbd class="calibre11">stack</kbd>, it fetched it from the stack and does the sort partitioning, and schedules the two parts for being sorted.</p>
<p class="calibre2">This code is more complex than the previous one and you have to understand the role of the <kbd class="calibre11">Stack</kbd> class and how it works. On the other hand, the program uses only one instance of the <kbd class="calibre11">Partitioner</kbd> class and it is also possible to use a thread pool to schedule the subsequent sorts instead of handling the tasks in a single process. This may speed up the sort when it is executed on a multi-CPU machine. However, this is a bit more complex task and this chapter contains a lot of new things without multitasking; therefore, we will look at multithread code in two chapters later only.</p>
<div class="packttip">In the very first version of the sort, I was coding it without the three lines that compare <kbd class="calibre22">cutIndex</kbd> against the interval start and increments it in the <kbd class="calibre22">if</kbd> branch. It is needed very much. But, the unit tests we created in this book do not discover the bug if we miss those lines. I recommend that you just delete those lines and try to write some unit tests that fail. Then try to understand what the special case is when those lines are vital and try to modify your unit test so that it is the simplest possible that still discovers that bug. (Finally, put the four lines back and see if the code works.)<br class="calibre23"/>
Additionally, find some architectural reason why not to put this modification into the method <kbd class="calibre22">partition</kbd>. That method could just return <kbd class="calibre22">large+1</kbd> in case <kbd class="calibre22">large == start</kbd>.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing the API class</h1>
            

            <article>
                
<p class="calibre2">Having done all this, the last thing we will need is to have <kbd class="calibre11">QuickSort</kbd> as a simple class (all the real work was already done in different classes).</p>
<pre class="calibre20">
public class QuickSort&lt;E&gt; implements Sort&lt;E&gt; { <br class="title-page-name"/>    public void sort(SortableCollection&lt;E&gt; sortable) { <br class="title-page-name"/>        int n = sortable.size(); <br class="title-page-name"/>        Qsort&lt;E&gt; qsort = new Qsort&lt;&gt;(comparator,swapper); <br class="title-page-name"/>        qsort.qsort(sortable, 0, n-1); <br class="title-page-name"/>    } <br class="title-page-name"/>// ... setter injectors were deleted from the print <br class="title-page-name"/>}
</pre>
<p class="calibre2">Do not forget that we also need a test! But, in this case, that is not much different than that of <kbd class="calibre11">BubbleSort</kbd>.</p>
<pre class="calibre20">
@Test <br class="title-page-name"/>public void canSortStrings() { <br class="title-page-name"/>    final String[] actualNames = new String[]{ <br class="title-page-name"/>            "Johnson", "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    }; <br class="title-page-name"/>    final String[] expected = new String[]{"Abraham", "Dagobert", "Johnson", "Wilkinson", "Wilson"}; <br class="title-page-name"/>    Sort&lt;String&gt; sort = new QuickSort&lt;&gt;(); <br class="title-page-name"/>    sort.setComparator(String::compareTo); <br class="title-page-name"/>    sort.setSwapper(new ArraySwapper&lt;String&gt;(actualNames)); <br class="title-page-name"/>    sort.sort(new ArrayWrapper&lt;&gt;(actualNames)); <br class="title-page-name"/>    Assert.assertArrayEquals(expected, actualNames); <br class="title-page-name"/>}
</pre>
<p class="calibre2">This time, we used <kbd class="calibre11">String</kbd> array instead of <kbd class="calibre11">ArrayList</kbd>. This makes this test simpler and, this time, we already have the support classes.</p>
<p class="calibre2">You may recognize that this is not a unit test. In the case of <kbd class="calibre11">BubbleSort</kbd>, the algorithm was implemented in a single class. Testing that single class is a unit test. In the case of <kbd class="calibre11">QuickSort</kbd>, we separated the functionality into separate classes, and even into separate packages. A real unit test of the <kbd class="calibre11">QuickSort</kbd> class will disclose the dependency of that class on other classes. When this test runs, it involves the execution of <kbd class="calibre11">Partitioner</kbd> and also <kbd class="calibre11">Qsort</kbd>; therefore, it is not really a unit test.</p>
<p class="calibre2">Should we bother about that? Not really. We want to create unit tests that involve a single unit to know where the problem is when a unit test fails. If there were only integration tests, a failing test case would not help a lot in pointing out where the problem is. All it says is that there is some problem in the classes that are involved in the test. In this case, there are only a limited number of classes (three) that are involved in this test and they are tied together. They are actually tied together and related to each other so closely that in the real production code, I would have implemented them in a single class. I separated them here to demonstrate how to test a single unit and also to demonstrate Java 9 module support that needs a bit more than a single class in a JAR file.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating modules</h1>
            

            <article>
                
<p class="calibre2">Module handling, also known as project <strong class="calibre1">Jigsaw,</strong> is a feature that was made available only in Java 9. It was a long planned feature that the developers were waiting for. First it was planned for Java 7, but it was so complex that it got postponed to Java 8 and then to Java 9. A year ago, it seemed that it would get postponed again, but finally, the project code got into the early releases and now nothing can stop from being part of the release.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Why modules are needed</h1>
            

            <article>
                
<p class="calibre2">We have already seen that there are four levels of access in Java. A method or field can be <kbd class="calibre11">private</kbd>, <kbd class="calibre11">protected</kbd>, <kbd class="calibre11">public</kbd>, or <kbd class="calibre11">default</kbd> (also known as package private) when no modifier is supplied. When you develop a complex library to be used in several projects, the library itself will contain many classes in many packages. There will certainly be classes and methods, fields in those that are used inside the library by other classes from different packages, but classes that are not to be used by the code outside the library. Making them anything less visible than <kbd class="calibre11">public</kbd> will render them unusable inside the library. Making them <kbd class="calibre11">public</kbd> will make them visible from outside.</p>
<p class="calibre2">In our code, the Maven module <kbd class="calibre11">quick</kbd> compiled to a JAR can only be used if the method sort can invoke <kbd class="calibre11">qsort</kbd>. But, we do not want <kbd class="calibre11">qsort</kbd> to be used directly from outside. In the next version, we may want to develop a version of the sort that uses <kbd class="calibre11">qsort</kbd> from the <kbd class="calibre11">NonRecursiveQuickSort</kbd> class and we do not want complaining customers whose code does not compile or work because of a minor library upgrade. We can document that the internal methods and classes are still public but not for use, but in vain. Developers using our library do not read documentation. This is also why we do not write excessive comments. Nobody will read it, not even the processor executing the code.</p>
<p class="calibre2">The most well-known and infamous example of this problem is the <kbd class="calibre11">sun.misc.Unsafe</kbd> class in the JDK. There is some really unsafe code in it, as the name implies. You can access memory out of heap, create objects without initialization, and so on. You should not. Why bother? You are a well-behaving developer and you just stick to the rules and you do not use that package. Whenever it changes in a new version of the JDK, your program is safe using only public and well-documented JDK API. Right?</p>
<p class="calibre2">Wrong! Without being aware of this, you may use some libraries that depend on other libraries that use the package. Mockito and Spring Framework are only two of the numerous in danger. In addition, Java 9 will definitely come with a new version of this package. However, it will also come with module handling. While Java 9 will provide some useful API for the libraries that were using the <kbd class="calibre11">Unsafe</kbd> package because there was no provided API for the functionality they needed, it will deliver modules not to recreate the same problem again.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">What is a Java module</h1>
            

            <article>
                
<p class="calibre2">A Java module is a collection of classes in a JAR or in a directory that also contain a special class named <kbd class="calibre11">module-info</kbd>. If there is this file in a JAR or directory then it is a module, otherwise it is just a collection of classes that are on the <kbd class="calibre11">classpath</kbd> (or not). Java 8, and the earlier versions, will just ignore that class as it is never used as code. This way, using older Java, causes no harm and backward compatibility is maintained.</p>
<p class="calibre2">The module information defines what the module exports and what it requires. It has a special format. For example, we can place <kbd class="calibre11">module-info.java</kbd> in our <kbd class="calibre11">SortInterface</kbd> Maven module.</p>
<pre class="calibre20">
module packt.java9.by.example.ch03{ <br class="title-page-name"/>        exports packt.java9.by.example.ch03; <br class="title-page-name"/>        }
</pre>
<p class="calibre2">This means that any class, which is <kbd class="calibre11">public</kbd> and inside the <kbd class="calibre11">packt.java9.by.example.ch03</kbd> package, can be used from outside. This package is exported from the module, but other classes from other packages are not visible from outside of the module even if they are <kbd class="calibre11">public</kbd>. The name of the module is same as the package, but this is mere convention in case there is only one package exported. The requirement is the same as in the case of packages: there should be a name that is not likely to collide with other module names. The reversed domain name is a good choice but it is not a must as you can see in this book. There is no top-level domain <kbd class="calibre11">packt</kbd>, yet.</p>
<p class="calibre2">We should also configure the parent POM to ensure that the compiler we use is Java 9,</p>
<pre class="calibre20">
&lt;build&gt; ... <br class="title-page-name"/>    &lt;plugins&gt; ... <br class="title-page-name"/>        &lt;plugin&gt; <br class="title-page-name"/>            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; <br class="title-page-name"/>            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; <br class="title-page-name"/>            &lt;version&gt;3.5.1&lt;/version&gt; <br class="title-page-name"/>            &lt;configuration&gt; <br class="title-page-name"/>                &lt;source&gt;1.9&lt;/source&gt; <br class="title-page-name"/>                &lt;target&gt;1.9&lt;/target&gt; <br class="title-page-name"/>            &lt;/configuration&gt; <br class="title-page-name"/>        &lt;/plugin&gt; <br class="title-page-name"/>...
</pre>
<p class="calibre2">Older versions would be confused with the <kbd class="calibre11">module-info.java</kbd> file. (By the way, even the early access version of Java 9 I use for this book sometimes gives a hard time.)</p>
<p class="calibre2">We also create a <kbd class="calibre11">module-info.java</kbd> file in the Maven module, <kbd class="calibre11">quick</kbd>, which is as follows:</p>
<pre class="calibre20">
module packt.java9.by.example.ch03.quick{ <br class="title-page-name"/>        exports packt.java9.by.example.ch03.quick; <br class="title-page-name"/>        requires packt.java9.by.example.ch03; <br class="title-page-name"/>        }
</pre>
<p class="calibre2">This module exports another package and requires the <kbd class="calibre11">packt.java9.by.example.ch03</kbd> module that we have just created. Now, we can compile the modules and the created JARs in the<kbd class="calibre11">./quick/target</kbd> and <kbd class="calibre11">./SortInterface/target</kbd> directories are now Java 9 modules.</p>
<div class="packtinfobox">As Maven does not fully support the modules yet, when I issue the <kbd class="calibre22">mvn install</kbd> command, I get the following error message:<br class="calibre23"/>
<kbd class="calibre22">[ERROR] .../genericsort/quick/src/main/java/module-info.java:[3,40] module not found: packt.java9.by.example.ch03</kbd><br class="calibre23"/>
Maven puts the compiled modules on <kbd class="calibre22">classpath</kbd>, but Java 9 seeks <kbd class="calibre22">modulepath</kbd> for modules. Maven does not handle <kbd class="calibre22">modulepath</kbd> yet. To hack <kbd class="calibre22">modulepath</kbd> to the compiler, we will have to add the following configuration lines to the parent POM to the <kbd class="calibre22">configuration</kbd> of the compiler plugin:<kbd class="calibre22">&lt;compilerArgs&gt;</kbd><br class="calibre23"/>
<kbd class="calibre22">&lt;arg&gt;-modulepath&lt;/arg&gt;</kbd><br class="calibre23"/>
<kbd class="calibre22">&lt;arg&gt;${project.parent.basedir}/SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar: ...&lt;/arg&gt;</kbd><br class="calibre23"/>
<kbd class="calibre22">&lt;/compilerArgs&gt;</kbd><br class="calibre23"/>
The actual file should list all the colon separated JAR files that Maven generates, and on which some of the modules depend. These are the <kbd class="calibre22">SortInterface</kbd>, <kbd class="calibre22">quick</kbd>, and <kbd class="calibre22">SortSupportClasses</kbd>.</div>
<p class="calibre2">To test the functionality of module support, we will create another Maven module called <kbd class="calibre11">Main</kbd>. It has only one class, called <kbd class="calibre11">Main</kbd>, with a <kbd class="calibre11">public static void main</kbd> method:</p>
<pre class="calibre20">
package packt.java9.by.example.ch03.main; <br class="title-page-name"/><br class="title-page-name"/>// ... imports deleted from the print <br class="title-page-name"/><br class="title-page-name"/>public class Main { <br class="title-page-name"/>    public static void main(String[] args) throws IOException { <br class="title-page-name"/>        String fileName = args[0]; <br class="title-page-name"/>        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileName)))); <br class="title-page-name"/>        List&lt;String&gt; lines = new LinkedList&lt;&gt;(); <br class="title-page-name"/>        String line; <br class="title-page-name"/>        while ((line = br.readLine()) != null) { <br class="title-page-name"/>            lines.add(line); <br class="title-page-name"/>        } <br class="title-page-name"/>        br.close(); <br class="title-page-name"/>        String[] lineArray = lines.toArray(new String[0]); <br class="title-page-name"/>        Sort&lt;String&gt; sort = new QuickSort&lt;&gt;(); <br class="title-page-name"/>        Qsort&lt;String&gt; qsort = new Qsort&lt;&gt;(String::compareTo,new ArraySwapper&lt;&gt;(lineArray)); <br class="title-page-name"/>        sort.setComparator(String::compareTo); <br class="title-page-name"/>        sort.setSwapper(new ArraySwapper&lt;&gt;(lineArray)); <br class="title-page-name"/>        sort.sort(new ArrayWrapper&lt;&gt;(lineArray)); <br class="title-page-name"/>        for (final String outLine : lineArray) { <br class="title-page-name"/>            System.out.println(outLine); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">It takes the first argument (without checking that there is one, which we should not use in a production code) and uses that as a file name. Then, it reads the lines of the file into a <kbd class="calibre11">String</kbd> array, sorts it, and prints it to the standard output.</p>
<p class="calibre2">As the module support only works for modules, this Maven module also has to be a Java module and have a <kbd class="calibre11">module-info.java</kbd> file.</p>
<pre class="calibre20">
module packt.java9.by.example.ch03.main{ <br class="title-page-name"/>        requires packt.java9.by.example.ch03.quick; <br class="title-page-name"/>        requires packt.java9.by.example.ch03; <br class="title-page-name"/>        requires packt.java9.by.example.ch03.support; <br class="title-page-name"/>        }
</pre>
<p class="calibre2">Additionally, we will have to create a <kbd class="calibre11">module-info.java</kbd> file for the support module; otherwise, we will not be able to use it from our module.</p>
<p class="calibre2">After compiling the modules using <kbd class="calibre11">mvn install</kbd>, we can run it to print out the parent POM.</p>
<pre class="calibre20">
    <strong class="calibre1">java -cp Main/target/Main-1.0.0-SNAPSHOT.jar:SortInterface/target/SortInterface-1.0.0-SNAPSHOT.jar:quick/target/quick-1.0.0-SNAPSHOT.jar:SortSupportClasses/target/SortSupportClasses-1.0.0-SNAPSHOT.jar packt.java9.by.example.ch03.main.Main pom.xml </strong>
</pre>
<div class="packtinfobox">Note that this is one line of command that print breaks into several lines.</div>
<p class="calibre2">Now, if we try to access <kbd class="calibre11">Qsort</kbd> directly inserting the following line <kbd class="calibre11">Qsort&lt;String&gt; qsort = new Qsort&lt;&gt;(String::compareTo,new ArraySwapper&lt;&gt;(lineArray));</kbd> into the <kbd class="calibre11">main</kbd> method, Maven will complain because the module system hides it from our <kbd class="calibre11">Main</kbd> class:</p>
<pre class="calibre20">
    <strong class="calibre1">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.5.1:compile (default-compile) on project Main: Compilation failure: Compilation failure:</strong><br class="title-page-name"/><strong class="calibre1">[ERROR] .../Main/src/main/java/packt/java9/by/example/ch03/main/Main.java:[4,41] package packt.java9.by.example.ch03.qsort does not exist</strong><br class="title-page-name"/><strong class="calibre1">[ERROR] .../Main/src/main/java/packt/java9/by/example/ch03/main/Main.java:[25,9] cannot find symbol</strong>
</pre>
<p class="calibre2">The module system also supports the <kbd class="calibre11">java.util.ServiceLoader</kbd> based class-loading mechanism, which we will not discuss in this book. This is an old technology that is rarely used in an enterprise environment when Spring, Guice, or some other dependency injection framework is used. If you see a <kbd class="calibre11">module-info.java</kbd> file that contains the <kbd class="calibre11">uses</kbd> and <kbd class="calibre11">provides</kbd> keywords, then first consult with the Java documentation about the <kbd class="calibre11">ServiceLoader</kbd> class at <a href="http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" class="calibre6">http://<span>docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html</span></a>, and then the Java 9 language documentation on module support (<a href="http://openjdk.java.net/projects/jigsaw/quick-start" class="calibre6"><span>http://openjdk.java.net/projects/jigsaw/quick-start</span></a>).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we developed a general sorting algorithm implementing quick sort. We modified our project to be a multi-module Maven project and also to use Java module definitions. We were using JUnit to develop unit tests, and we developed the code using TDD. We converted the code from old style Java to new using generics, and we used exception handling. These are the basic tools that are needed for the coming chapters, where we will develop a guessing game. First we will develop a simpler version and in the subsequent chapter we will develop a version that uses parallel computing, and multiple proccessors.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>