- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn how to secure our application in this chapter. This chapter will
    explain how to implement authentication in our frontend when we are using **JSON
    Web Token** (**JWT**) authentication in the backend. First, we will switch on
    security in our backend to enable JWT authentication. Then, we will create a component
    for the login functionality. Finally, we will modify our CRUD functionalities
    to send the token in the request’s authorization header to the backend, and implement
    the logout functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application that we created in *Chapter 5*, *Securing Your Backend*,
    is required ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05)),
    as is the React app that we used in *Chapter 14*, *Styling the Frontend with React
    MUI* ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub link for this chapter will also be useful: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: Securing the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 13*, we implemented CRUD functionalities in our frontend using
    an unsecured backend. Now, it is time to switch on security for our backend and
    go back to the version that we created in *Chapter 5*, *Securing Your Backend*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your backend project with the Eclipse IDE and open the `SecurityConfig.java`
    file in the editor view. We have commented the security out and allowed everyone
    access to all endpoints. Now, we can remove that line and also remove the comments
    from the original version. Now, the `filterChain()` method of your `SecurityConfig.java`
    file should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s test what happens when the backend is secured again. Run the backend by
    pressing the **Run** button in Eclipse, and check from the console view that the
    application started correctly. Run the frontend by typing the `npm run dev` command
    into your terminal, and the browser should be opened to the address `localhost:5173`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now see that the list page and the car list are loading. If you
    open the developer tools and the **Network** tab, you will notice that the response
    status is **401 Unauthorized**. This is actually what we want because we haven’t
    yet executed authentication in relation to our frontend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: 401 Unauthorized'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to work with the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 5*, *Securing Your Backend*, we created JWT authentication and
    allowed everyone access to the `/login` endpoint without authentication. Now,
    on the frontend login page, we have to send a `POST` request to the `/login` endpoint
    using user credentials to get a token. After that, the token will be included
    in all requests that we send to the backend, as demonstrated in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Secured application'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we will start to implement login functionality on our frontend.
    We will implement the login page where the user enters credentials, and then we
    will send a login request to get a token from the server. We will use the stored
    token in the requests that we send to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a login component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first create a login component that asks for credentials from the user
    to get a token from the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `Login.tsx` in the `components` folder. Now, the file
    structure of the frontend should be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file in the VS Code editor view and add the following base code to
    the `Login` component. We need `axios` to send `POST` requests to the `/login`
    endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need two states for the authentication: one for the credentials (username
    and password), and one boolean value to indicate the status of the authentication.
    We also create a type for the user state. The initial value of the authentication
    status state is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the user interface, we are going to use the **Material UI** (**MUI**) component
    library, as we did with the rest of the user interface. We need `TextField` components
    for the credentials, the `Button` component to call a login function, and the
    `Stack` component for layout. Add imports for the components to the `Login.tsx`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have already used all three of these component types in *Chapter 14*, *Styling
    the Frontend with MUI*, to style our UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the imported components to the `return` statement. We need two `TextField`
    components: one for the username and one for the password. One `Button` component
    is needed to call the login function that we are going to implement later in this
    section. We use the `Stack` component to align our `TextField` components to the
    center and to get spacing between them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the change handler function for the `TextField` components, in order
    to save typed values to the states. You have to use the spread syntax because
    it ensures that you retain all the other properties of the `user` object that
    are not modified in this update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As shown in *Chapter 5*, *Securing Your Backend*, the login is done by calling
    the `/login` endpoint using the `POST` method and sending the `user` object inside
    the body. If authentication succeeds, we get a token in a response `Authorization`
    header. We will then save the token to session storage and set the `isAuthenticated`
    state value to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Session storage** is similar to local storage, but it is cleared when a page
    session ends (when the page is closed). `localStorage` and `sessionStorage` are
    properties of the `Window` interface.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the `isAuthenticated` state value is changed, the user interface is re-rendered:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will implement some conditional rendering that renders the `Login` component
    if the `isAuthenticated` state is `false`, or the `Carlist` component if the `isAuthenticated`
    state is `true`. First, import the `Carlist` component into the `Login.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, implement the following changes to the `return` statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To show the login form, we have to render the `Login` component instead of
    the `Carlist` component in the `App.tsx` file. Import and render the `Login` component
    and remove the unused `Carlist` import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when your frontend and backend are running, your frontend should look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you log in using the *user*/*user* or *admin*/*admin* credentials that we
    have inserted into the database, you should see the car list page. If you open
    the developer tools’ **Application** tab, you can see that the token is now saved
    to session storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Session storage'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST API calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the end of the previous section, the car list is still loading and we can’t
    fetch cars. This is the correct behavior because we haven’t included the token
    in any requests yet. That is required for JWT authentication, which we will implement
    in the next phase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `carapi.ts` file in the VS Code editor view. To fetch the cars, we
    first have to read the token from session storage and then add the `Authorization`
    header with the token value to the `GET` request. You can see the source code
    for the `getCars` function here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you log in to your frontend, you should see the car list populated with cars
    from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the request content from the developer tools; you can see that it contains
    the `Authorization` header with the token value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Request headers ](img/B19818_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Request headers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the other CRUD functionalities in the same way so they work correctly.
    The source code for the `deleteCar` function appears as follows, after the modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The source code for the `addCar` and `editCar` functions appears as follows,
    after the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring duplicate code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, all the CRUD functionalities will work after you have logged in to the
    application. But, as you can see, we have quite a lot of duplicate code, such
    as the lines where we retrieve our token from session storage. We can do some
    refactoring to avoid repeating the same code and make our code easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a function that retrieves the token from session storage
    and creates a configuration object for Axios requests that contains headers with
    the token. Axios provides the `AxiosRequestConfig` interface, which can be used
    to configure requests we send using Axios. We also set the `content-type` header
    value to `application/json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can use the `getAxiosConfig()` function without retrieving a token
    in each function, by removing the configuration object and calling the `getAxiosConfig()`
    function instead, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Axios also provides **interceptors** that can be used to intercept and modify
    requests and responses before they are handled by `then` or `catch`. You can read
    more about interceptors in the Axios documentation: [https://axios-http.com/docs/interceptors](https://axios-http.com/docs/interceptors).'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an error message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this phase, we are going to implement an error message that is shown to
    a user if authentication fails. We will use the `Snackbar` MUI component to show
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following import to the `Login.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new state called `open` to control the visibility of the `Snackbar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Snackbar` component to the `return` statement, inside the stack just
    under the `Button` component. The `Snackbar` component is used to show toast messages.
    The component is shown if the `open` prop value is `true`. The `autoHideDuration`
    defines the number of milliseconds to wait before the `onClose` function is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `Snackbar` component if authentication fails by setting the `open`
    state value to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now try to log in with the wrong credentials, you will see the following
    message in the bottom-left corner of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: Login failed'
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this last section, we will implement the logout functionality in the `Login`
    component. The logout button is rendered on the car list page. The `Carlist` component
    is a child component of the `Login` component; therefore, we can pass the logout
    function to the car list using the props. Let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `handleLogout()` function for the `Login` component, which
    updates the `isAuthenticated` state to `false` and clears the token from session
    storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we pass the `handleLogout` function to the `Carlist` component using
    the props, as shown in the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to create a new type for the props that we receive in the `Carlist`
    component. The prop name is `logOut`, which is a function that takes no arguments,
    and we mark this prop as optional. Add the following type to the `Carlist` component
    and receive the `logOut` prop in the function arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can call the logout function and add the logout button. We use the
    Material UI `Stack` component to align the buttons so that the **NEW CAR** button
    is on the left and the **LOG OUT** button is on the right side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you log in to your frontend, you can see the **LOG OUT** button on
    the car list page, as shown in the following screenshot. When you click the button,
    the login page is rendered because the `isAuthenticated` state is set to `false`
    and the token is cleared from session storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Log out'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a more complicated frontend with multiple pages, it would be wise
    to render the logout button in the app bar so that it is shown on each page. Then,
    you can use a state management technique to share a state with the whole component
    tree in your app. One solution would be to use the **React Context API** that
    we introduced in *Chapter 8*, *Getting Started with React*. In this scenario,
    you could use context to share the `isAuthenticated` state in your application’s
    component tree.
  prefs: []
  type: TYPE_NORMAL
- en: As your application grows in complexity, managing state becomes crucial to ensuring
    that your components can access and update data efficiently. There are also other
    alternatives to the React Context API to manage states that you can study. The
    most common state management libraries are **React Redux** ([https://react-redux.js.org](https://react-redux.js.org))
    and MobX ([https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created test cases for the `CarList` component,
    and at that point the app was unsecured. At this stage, our `CarList` component
    test cases will fail, and you should refactor them. To create a React test that
    simulates a login process and then tests whether data is fetched from a backend
    REST API, you can also use libraries like `axios-mock-adapter` ([https://github.com/ctimmerm/axios-mock-adapter](https://github.com/ctimmerm/axios-mock-adapter)).
    Mocking Axios allows you to simulate the login process and data fetching without
    making actual network requests. We are not going into the details here, but we
    recommend you explore this further.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready with our car application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to implement a login and logout functionality
    for our frontend when we are using JWT authentication. Following successful authentication,
    we used session storage to save the token that we received from the backend. The
    token was then used in all requests that we sent to the backend; therefore, we
    had to modify our CRUD functionalities to work with authentication properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will deploy our backend and frontend and also
    demonstrate how to create Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should you create a login form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you log in to the backend using JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is session storage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you send a token to the backend in CRUD functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some other resources for learning about React and state management:'
  prefs: []
  type: TYPE_NORMAL
- en: '*State Management with React Query*, by Daniel Afonso ([https://www.packtpub.com/product/state-management-with-react-query/9781803231341](https://www.packtpub.com/product/state-management-with-react-query/9781803231341))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MobX Quick Start Guide*, by Pavan Podila and Michel Weststrate ([https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10796108009382640.png)'
  prefs: []
  type: TYPE_IMG
