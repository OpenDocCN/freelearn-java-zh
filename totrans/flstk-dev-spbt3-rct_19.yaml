- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Securing Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的应用程序
- en: We will learn how to secure our application in this chapter. This chapter will
    explain how to implement authentication in our frontend when we are using **JSON
    Web Token** (**JWT**) authentication in the backend. First, we will switch on
    security in our backend to enable JWT authentication. Then, we will create a component
    for the login functionality. Finally, we will modify our CRUD functionalities
    to send the token in the request’s authorization header to the backend, and implement
    the logout functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章学习如何确保我们的应用程序的安全性。本章将解释在我们后端使用**JSON Web Token**（JWT）认证时，如何在我们的前端实现认证。首先，我们将开启后端的安全性以启用JWT认证。然后，我们将创建一个用于登录功能的组件。最后，我们将修改我们的CRUD功能，以便在请求的授权头中发送令牌到后端，并实现注销功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Securing the backend
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护后端
- en: Securing the frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护前端
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot application that we created in *Chapter 5*, *Securing Your Backend*,
    is required ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05)),
    as is the React app that we used in *Chapter 14*, *Styling the Frontend with React
    MUI* ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*，“保护你的后端”中创建的Spring Boot应用程序是必需的（[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05)），以及我们在*第14章*，“使用React
    MUI美化前端”中使用的React应用程序（[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter14)）。
- en: 'The following GitHub link for this chapter will also be useful: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的以下GitHub链接也将很有用：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16)。
- en: Securing the backend
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护后端
- en: 'In *Chapter 13*, we implemented CRUD functionalities in our frontend using
    an unsecured backend. Now, it is time to switch on security for our backend and
    go back to the version that we created in *Chapter 5*, *Securing Your Backend*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第13章*中，我们使用未加密的后端在我们的前端实现了CRUD功能。现在，是时候为我们的后端开启安全性，回到我们在*第5章*，“保护你的后端”中创建的版本：
- en: 'Open your backend project with the Eclipse IDE and open the `SecurityConfig.java`
    file in the editor view. We have commented the security out and allowed everyone
    access to all endpoints. Now, we can remove that line and also remove the comments
    from the original version. Now, the `filterChain()` method of your `SecurityConfig.java`
    file should look like the following:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Eclipse IDE打开你的后端项目，并在编辑器视图中打开`SecurityConfig.java`文件。我们已取消注释安全设置并允许所有人访问所有端点。现在，我们可以删除那行，并也从原始版本中删除注释。现在，你的`SecurityConfig.java`文件的`filterChain()`方法应该看起来像以下这样：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s test what happens when the backend is secured again. Run the backend by
    pressing the **Run** button in Eclipse, and check from the console view that the
    application started correctly. Run the frontend by typing the `npm run dev` command
    into your terminal, and the browser should be opened to the address `localhost:5173`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试当后端再次被保护时会发生什么。通过在Eclipse中按**运行**按钮来运行后端，并从控制台视图检查应用程序是否正确启动。通过在终端中输入`npm
    run dev`命令来运行前端，浏览器应该会打开到地址`localhost:5173`。
- en: 'You should now see that the list page and the car list are loading. If you
    open the developer tools and the **Network** tab, you will notice that the response
    status is **401 Unauthorized**. This is actually what we want because we haven’t
    yet executed authentication in relation to our frontend:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该会看到列表页面和汽车列表正在加载。如果你打开开发者工具并切换到**网络**标签，你会注意到响应状态是**401未授权**。这实际上是我们想要的，因为我们还没有针对前端执行认证：
- en: '![](img/B19818_16_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_16_01.png)'
- en: 'Figure 16.1: 401 Unauthorized'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：401未授权
- en: Now, we are ready to work with the frontend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始处理前端工作了。
- en: Securing the frontend
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护前端
- en: 'In *Chapter 5*, *Securing Your Backend*, we created JWT authentication and
    allowed everyone access to the `/login` endpoint without authentication. Now,
    on the frontend login page, we have to send a `POST` request to the `/login` endpoint
    using user credentials to get a token. After that, the token will be included
    in all requests that we send to the backend, as demonstrated in the following
    figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*保护后端*中，我们创建了JWT认证，并允许所有人无需认证即可访问`/login`端点。现在，在前端登录页面上，我们必须使用用户凭证向`/login`端点发送`POST`请求以获取令牌。之后，该令牌将包含在我们发送到后端的全部请求中，如下图所示：
- en: '![](img/B19818_16_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_16_02.png)'
- en: 'Figure 16.2: Secured application'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：安全应用
- en: With this knowledge, we will start to implement login functionality on our frontend.
    We will implement the login page where the user enters credentials, and then we
    will send a login request to get a token from the server. We will use the stored
    token in the requests that we send to the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，我们将开始在前端实现登录功能。我们将实现用户输入凭证的登录页面，然后我们将发送登录请求以从服务器获取令牌。我们将使用存储的令牌来发送到服务器的请求。
- en: Creating a login component
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录组件
- en: 'Let’s first create a login component that asks for credentials from the user
    to get a token from the backend:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个登录组件，该组件会要求用户输入凭证以从后端获取令牌：
- en: 'Create a new file called `Login.tsx` in the `components` folder. Now, the file
    structure of the frontend should be the following:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中创建一个名为`Login.tsx`的新文件。现在，前端文件结构应该是以下这样：
- en: '![](img/B19818_16_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_16_03.png)'
- en: 'Figure 16.3: Project structure'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：项目结构
- en: 'Open the file in the VS Code editor view and add the following base code to
    the `Login` component. We need `axios` to send `POST` requests to the `/login`
    endpoint:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code编辑器视图中打开文件，并将以下基本代码添加到`Login`组件中。我们需要`axios`来向`/login`端点发送`POST`请求：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need two states for the authentication: one for the credentials (username
    and password), and one boolean value to indicate the status of the authentication.
    We also create a type for the user state. The initial value of the authentication
    status state is `false`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个状态来处理认证：一个用于凭证（用户名和密码），一个布尔值用于指示认证状态。我们还创建了一个用户状态类型。认证状态状态的初始值是`false`：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the user interface, we are going to use the **Material UI** (**MUI**) component
    library, as we did with the rest of the user interface. We need `TextField` components
    for the credentials, the `Button` component to call a login function, and the
    `Stack` component for layout. Add imports for the components to the `Login.tsx`
    file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户界面中，我们将使用**Material UI**（**MUI**）组件库，就像我们处理其他用户界面一样。我们需要`TextField`组件来输入凭证，`Button`组件来调用登录函数，以及`Stack`组件来进行布局。将组件导入添加到`Login.tsx`文件中：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have already used all three of these component types in *Chapter 14*, *Styling
    the Frontend with MUI*, to style our UI.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经在*第14章*，*使用MUI美化前端*中使用了这三种组件类型来美化我们的UI。
- en: 'Add the imported components to the `return` statement. We need two `TextField`
    components: one for the username and one for the password. One `Button` component
    is needed to call the login function that we are going to implement later in this
    section. We use the `Stack` component to align our `TextField` components to the
    center and to get spacing between them:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导入的组件添加到`return`语句中。我们需要两个`TextField`组件：一个用于用户名，一个用于密码。需要一个`Button`组件来调用我们将在本节后面实现的登录函数。我们使用`Stack`组件来使我们的`TextField`组件居中并对齐它们之间的间距：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the change handler function for the `TextField` components, in order
    to save typed values to the states. You have to use the spread syntax because
    it ensures that you retain all the other properties of the `user` object that
    are not modified in this update:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于`TextField`组件的更改处理函数，以便将输入的值保存到状态中。你必须使用扩展语法，因为它确保你保留了`user`对象中未修改的所有其他属性：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in *Chapter 5*, *Securing Your Backend*, the login is done by calling
    the `/login` endpoint using the `POST` method and sending the `user` object inside
    the body. If authentication succeeds, we get a token in a response `Authorization`
    header. We will then save the token to session storage and set the `isAuthenticated`
    state value to `true`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*第5章*，*保护后端*所示，登录是通过调用`/login`端点并使用`POST`方法在正文中发送`user`对象来完成的。如果身份验证成功，我们将在响应的`Authorization`头中获取令牌。然后我们将令牌保存到会话存储中，并将`isAuthenticated`状态值设置为`true`。
- en: '**Session storage** is similar to local storage, but it is cleared when a page
    session ends (when the page is closed). `localStorage` and `sessionStorage` are
    properties of the `Window` interface.'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**会话存储**与本地存储类似，但在页面会话结束时（当页面关闭时）会被清除。`localStorage`和`sessionStorage`是`Window`接口的属性。'
- en: 'When the `isAuthenticated` state value is changed, the user interface is re-rendered:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isAuthenticated`状态值改变时，用户界面会重新渲染：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will implement some conditional rendering that renders the `Login` component
    if the `isAuthenticated` state is `false`, or the `Carlist` component if the `isAuthenticated`
    state is `true`. First, import the `Carlist` component into the `Login.tsx` file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现一些条件渲染，如果`isAuthenticated`状态值为`false`，则渲染`Login`组件；如果`isAuthenticated`状态值为`true`，则渲染`Carlist`组件。首先，将`Carlist`组件导入到`Login.tsx`文件中：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, implement the following changes to the `return` statement:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，对`return`语句实现以下更改：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To show the login form, we have to render the `Login` component instead of
    the `Carlist` component in the `App.tsx` file. Import and render the `Login` component
    and remove the unused `Carlist` import:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示登录表单，我们必须在`App.tsx`文件中将`Login`组件而不是`Carlist`组件渲染出来。导入并渲染`Login`组件，并删除未使用的`Carlist`导入：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, when your frontend and backend are running, your frontend should look
    like the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你的前端和后端都在运行时，你的前端应该看起来像以下截图：
- en: '![](img/B19818_16_04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_16_04.png)'
- en: 'Figure 16.4: Login page'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：登录页面
- en: 'If you log in using the *user*/*user* or *admin*/*admin* credentials that we
    have inserted into the database, you should see the car list page. If you open
    the developer tools’ **Application** tab, you can see that the token is now saved
    to session storage:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用我们已插入数据库的`user`/*用户*或`admin`/*管理员*凭据登录，你应该看到汽车列表页面。如果你打开开发者工具的**应用程序**选项卡，你可以看到令牌现在已保存到会话存储中：
- en: '![](img/B19818_16_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_16_05.png)'
- en: 'Figure 16.5: Session storage'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：会话存储
- en: Implementing REST API calls
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现REST API调用
- en: 'At the end of the previous section, the car list is still loading and we can’t
    fetch cars. This is the correct behavior because we haven’t included the token
    in any requests yet. That is required for JWT authentication, which we will implement
    in the next phase:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节结束时，汽车列表仍在加载，我们无法获取汽车。这是正确的行为，因为我们还没有在任何请求中包含令牌。这是JWT身份验证所必需的，我们将在下一阶段实现：
- en: 'Open the `carapi.ts` file in the VS Code editor view. To fetch the cars, we
    first have to read the token from session storage and then add the `Authorization`
    header with the token value to the `GET` request. You can see the source code
    for the `getCars` function here:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code编辑器视图中打开`carapi.ts`文件。要获取汽车，我们首先必须从会话存储中读取令牌，然后将带有令牌值的`Authorization`头添加到`GET`请求中。你可以在这里看到`getCars`函数的源代码：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you log in to your frontend, you should see the car list populated with cars
    from the database.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你登录到你的前端，你应该看到数据库中的汽车已填充到汽车列表中。
- en: 'Check the request content from the developer tools; you can see that it contains
    the `Authorization` header with the token value:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查开发者工具中的请求内容；你可以看到它包含带有令牌值的`Authorization`头：
- en: '![Figure 14.6 – Request headers ](img/B19818_16_06.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 请求头](img/B19818_16_06.png)'
- en: 'Figure 16.6: Request headers'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：请求头
- en: 'Modify the other CRUD functionalities in the same way so they work correctly.
    The source code for the `deleteCar` function appears as follows, after the modifications:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式修改其他CRUD功能，以确保它们能正确工作。在修改后，`deleteCar`函数的源代码如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The source code for the `addCar` and `editCar` functions appears as follows,
    after the modifications:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后，`addCar`和`editCar`函数的源代码如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Refactoring duplicate code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构重复代码
- en: 'Now, all the CRUD functionalities will work after you have logged in to the
    application. But, as you can see, we have quite a lot of duplicate code, such
    as the lines where we retrieve our token from session storage. We can do some
    refactoring to avoid repeating the same code and make our code easier to maintain:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，登录到应用程序后，所有CRUD功能都将正常工作。但是，如你所见，我们有很多重复的代码，例如我们从会话存储中检索令牌的行。我们可以进行一些重构，以避免重复相同的代码并使我们的代码更容易维护：
- en: 'First, we will create a function that retrieves the token from session storage
    and creates a configuration object for Axios requests that contains headers with
    the token. Axios provides the `AxiosRequestConfig` interface, which can be used
    to configure requests we send using Axios. We also set the `content-type` header
    value to `application/json`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个函数，从会话存储中检索令牌并为Axios请求创建一个包含带有令牌的头的配置对象。Axios提供了`AxiosRequestConfig`接口，可用于配置我们使用Axios发送的请求。我们还设置了`content-type`头的值为`application/json`：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can use the `getAxiosConfig()` function without retrieving a token
    in each function, by removing the configuration object and calling the `getAxiosConfig()`
    function instead, as shown in the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过移除配置对象并调用`getAxiosConfig()`函数，而不在每个函数中检索令牌来使用`getAxiosConfig()`函数，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Axios also provides **interceptors** that can be used to intercept and modify
    requests and responses before they are handled by `then` or `catch`. You can read
    more about interceptors in the Axios documentation: [https://axios-http.com/docs/interceptors](https://axios-http.com/docs/interceptors).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Axios还提供了**拦截器**，可以在请求和响应被`then`或`catch`处理之前拦截和修改它们。你可以在Axios文档中了解更多关于拦截器的信息：[https://axios-http.com/docs/interceptors](https://axios-http.com/docs/interceptors)。
- en: Displaying an error message
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示错误消息
- en: 'In this phase, we are going to implement an error message that is shown to
    a user if authentication fails. We will use the `Snackbar` MUI component to show
    the message:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将实现一个错误消息，如果认证失败，将显示给用户。我们将使用`Snackbar` MUI组件来显示消息：
- en: 'Add the following import to the `Login.tsx` file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入添加到`Login.tsx`文件中：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a new state called `open` to control the visibility of the `Snackbar`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的状态`open`来控制`Snackbar`的可见性：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `Snackbar` component to the `return` statement, inside the stack just
    under the `Button` component. The `Snackbar` component is used to show toast messages.
    The component is shown if the `open` prop value is `true`. The `autoHideDuration`
    defines the number of milliseconds to wait before the `onClose` function is called:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Snackbar`组件添加到`return`语句中，位于`Button`组件下面的堆栈中。`Snackbar`组件用于显示吐司消息。如果`open`属性值为`true`，则显示该组件。`autoHideDuration`定义了在调用`onClose`函数之前等待的毫秒数：
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `Snackbar` component if authentication fails by setting the `open`
    state value to `true`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果认证失败，通过将`open`状态值设置为`true`来打开`Snackbar`组件：
- en: '[PRE18]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you now try to log in with the wrong credentials, you will see the following
    message in the bottom-left corner of the screen:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在尝试使用错误的凭据登录，你将在屏幕的左下角看到以下消息：
- en: '![](img/B19818_16_07.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_16_07.png)'
- en: 'Figure 16.7: Login failed'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：登录失败
- en: Logging out
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登出
- en: 'In this last section, we will implement the logout functionality in the `Login`
    component. The logout button is rendered on the car list page. The `Carlist` component
    is a child component of the `Login` component; therefore, we can pass the logout
    function to the car list using the props. Let’s do this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将在`Login`组件中实现登出功能。登出按钮渲染在车辆列表页面上。`Carlist`组件是`Login`组件的子组件；因此，我们可以通过属性将登出函数传递给车辆列表。让我们这样做：
- en: 'First, we create a `handleLogout()` function for the `Login` component, which
    updates the `isAuthenticated` state to `false` and clears the token from session
    storage:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为`Login`组件创建一个`handleLogout()`函数，该函数将`isAuthenticated`状态更新为`false`，并从会话存储中清除令牌：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we pass the `handleLogout` function to the `Carlist` component using
    the props, as shown in the highlighted code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用属性将`handleLogout`函数传递给`Carlist`组件，如高亮代码所示：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have to create a new type for the props that we receive in the `Carlist`
    component. The prop name is `logOut`, which is a function that takes no arguments,
    and we mark this prop as optional. Add the following type to the `Carlist` component
    and receive the `logOut` prop in the function arguments:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为在 `Carlist` 组件中接收的 props 创建一个新的类型。prop 名称是 `logOut`，它是一个不接受任何参数的函数，我们将此
    prop 标记为可选。将以下类型添加到 `Carlist` 组件中，并在函数参数中接收 `logOut` prop：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can call the logout function and add the logout button. We use the
    Material UI `Stack` component to align the buttons so that the **NEW CAR** button
    is on the left and the **LOG OUT** button is on the right side of the screen:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调用注销函数并添加注销按钮。我们使用 Material UI 的 `Stack` 组件来对齐按钮，使得 **NEW CAR** 按钮位于屏幕左侧，而
    **LOG OUT** 按钮位于右侧：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if you log in to your frontend, you can see the **LOG OUT** button on
    the car list page, as shown in the following screenshot. When you click the button,
    the login page is rendered because the `isAuthenticated` state is set to `false`
    and the token is cleared from session storage:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你登录到你的前端，你可以在汽车列表页面上看到 **LOG OUT** 按钮，如下面的截图所示。当你点击按钮时，会渲染登录页面，因为 `isAuthenticated`
    状态被设置为 `false`，并且令牌已从会话存储中清除：
- en: '![](img/B19818_16_08.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_16_08.png)'
- en: 'Figure 16.8: Log out'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8：注销
- en: If you have a more complicated frontend with multiple pages, it would be wise
    to render the logout button in the app bar so that it is shown on each page. Then,
    you can use a state management technique to share a state with the whole component
    tree in your app. One solution would be to use the **React Context API** that
    we introduced in *Chapter 8*, *Getting Started with React*. In this scenario,
    you could use context to share the `isAuthenticated` state in your application’s
    component tree.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个更复杂的具有多个页面的前端，明智的做法是在应用栏中渲染注销按钮，这样它就会显示在每个页面上。然后，你可以使用状态管理技术来与你的整个组件树共享状态。一个解决方案是使用我们在
    *第 8 章* 中介绍的 **React Context API**。在这种情况下，你可以使用上下文来在应用组件树中共享 `isAuthenticated`
    状态。
- en: As your application grows in complexity, managing state becomes crucial to ensuring
    that your components can access and update data efficiently. There are also other
    alternatives to the React Context API to manage states that you can study. The
    most common state management libraries are **React Redux** ([https://react-redux.js.org](https://react-redux.js.org))
    and MobX ([https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用复杂性增长，管理状态变得至关重要，以确保你的组件可以高效地访问和更新数据。还有其他替代 React Context API 的状态管理方法，你可以研究。最常见的状态管理库是
    **React Redux**（[https://react-redux.js.org](https://react-redux.js.org)）和 MobX（[https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx)）。
- en: In the previous chapter, we created test cases for the `CarList` component,
    and at that point the app was unsecured. At this stage, our `CarList` component
    test cases will fail, and you should refactor them. To create a React test that
    simulates a login process and then tests whether data is fetched from a backend
    REST API, you can also use libraries like `axios-mock-adapter` ([https://github.com/ctimmerm/axios-mock-adapter](https://github.com/ctimmerm/axios-mock-adapter)).
    Mocking Axios allows you to simulate the login process and data fetching without
    making actual network requests. We are not going into the details here, but we
    recommend you explore this further.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为 `CarList` 组件创建了测试用例，当时应用是不安全的。在这个阶段，我们的 `CarList` 组件测试用例将会失败，你应该对它们进行重构。为了创建一个模拟登录过程并测试是否从后端
    REST API 获取数据的 React 测试，你也可以使用像 `axios-mock-adapter` 这样的库（[https://github.com/ctimmerm/axios-mock-adapter](https://github.com/ctimmerm/axios-mock-adapter)）。Mocking
    Axios 允许你在不进行实际网络请求的情况下模拟登录过程和数据获取。我们这里不深入细节，但建议你进一步探索。
- en: Now, we are ready with our car application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的汽车应用已经准备好了。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement a login and logout functionality
    for our frontend when we are using JWT authentication. Following successful authentication,
    we used session storage to save the token that we received from the backend. The
    token was then used in all requests that we sent to the backend; therefore, we
    had to modify our CRUD functionalities to work with authentication properly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在使用 JWT 认证时为我们的前端实现登录和注销功能。在认证成功后，我们使用会话存储来保存从后端接收到的令牌。然后，我们在发送到后端的全部请求中使用该令牌；因此，我们必须修改我们的
    CRUD 功能以正确地与认证一起工作。
- en: In the next and final chapter, we will deploy our backend and frontend and also
    demonstrate how to create Docker containers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将部署我们的后端和前端，并演示如何创建 Docker 容器。
- en: Questions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How should you create a login form?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何创建一个登录表单？
- en: How should you log in to the backend using JWT?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何使用 JWT 登录后端？
- en: What is session storage?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话存储是什么？
- en: How should you send a token to the backend in CRUD functions?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CRUD 函数中，您应该如何向后端发送令牌？
- en: Further reading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some other resources for learning about React and state management:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他关于学习 React 和状态管理的资源：
- en: '*State Management with React Query*, by Daniel Afonso ([https://www.packtpub.com/product/state-management-with-react-query/9781803231341](https://www.packtpub.com/product/state-management-with-react-query/9781803231341))'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 React Query 进行状态管理》*，作者 Daniel Afonso ([https://www.packtpub.com/product/state-management-with-react-query/9781803231341](https://www.packtpub.com/product/state-management-with-react-query/9781803231341))'
- en: '*MobX Quick Start Guide*, by Pavan Podila and Michel Weststrate ([https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837))'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《MobX 快速入门指南》*，作者 Pavan Podila 和 Michel Weststrate ([https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837](https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837))'
- en: Learn more on Discord
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code10796108009382640.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code10796108009382640.png)'
