<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-142"><em class="italic"><a id="_idTextAnchor141"/>Chapter 6</em>: Data Structures, Generics, and Popular Utilities</h1>
			<p>This chapter presents the Java collections framework and its three main interfaces, <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>, including a discussion and demonstration of generics. The <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods are also discussed in the context of Java collections. Utility classes for managing arrays, objects, and time/date values have corresponding dedicated sections too. After studying this chapter, you will be able to use all the main data structures in your programs. </p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li><strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong> interfaces</li>
				<li><strong class="source-inline">Collections</strong> utilities</li>
				<li><strong class="source-inline">Arrays</strong> utilities</li>
				<li><strong class="source-inline">Object</strong> utilities</li>
				<li>The <strong class="source-inline">java.time</strong> package</li>
			</ul>
			<p>Let’s begin!</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java<strong class="bold"> Standard Edition</strong> (<strong class="bold">SE</strong>) version 17 or later</li>
				<li>An <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) or your preferred code editor </li>
			</ul>
			<p>Instructions on how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> of this book, <em class="italic">Getting Started with Java 17</em>. The files with code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository, in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch06_collections</strong> folder. </p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>List, Set, and Map interfaces</h1>
			<p>The <strong class="bold">Java collections framework</strong> consists<a id="_idIndexMarker720"/> of classes <a id="_idIndexMarker721"/>and<a id="_idIndexMarker722"/> interfaces that implement a <a id="_idIndexMarker723"/>collection data structure. Collections are similar to arrays in that they can hold references to objects and can be managed as a group. The difference is that arrays require their capacity to be defined before they can be used, while collections can increase and decrease their size automatically as needed. You just add or remove an object reference to a collection, and the collection changes its size accordingly. Another difference is that collections cannot have their elements be primitive types, such as <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, or <strong class="source-inline">double</strong>. If you need to store such type values, the elements must be of a corresponding wrapper type, such as <strong class="source-inline">Short</strong>, <strong class="source-inline">Integer</strong>, or <strong class="source-inline">Double</strong>.</p>
			<p>Java collections support various algorithms for storing and accessing elements of a collection: an ordered list, a unique set, a <a id="_idIndexMarker724"/>dictionary (called a <strong class="bold">map</strong> in<a id="_idIndexMarker725"/> Java), a <strong class="bold">stack</strong>, a <strong class="bold">queue</strong>, and some<a id="_idIndexMarker726"/> others. All classes and interfaces of the Java collections framework belong to the <strong class="source-inline">java.util</strong> package <a id="_idIndexMarker727"/>of the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>). The <strong class="source-inline">java.util</strong> package contains the following:</p>
			<ul>
				<li>Interfaces that extend the <strong class="source-inline">Collection</strong> interface: <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Queue</strong>, to name the most popular ones</li>
				<li>Classes that implement the previously listed interfaces: <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">HashSet</strong>, <strong class="source-inline">Stack</strong>, <strong class="source-inline">LinkedList</strong>, and some others</li>
				<li>The <strong class="source-inline">Map</strong> interface and its <strong class="source-inline">ConcurrentMap</strong> and <strong class="source-inline">SortedMap</strong> sub-interfaces, to name a couple</li>
				<li>Classes that implement <strong class="source-inline">Map</strong>-related interfaces: <strong class="source-inline">HashMap</strong>, <strong class="source-inline">HashTable</strong>, and <strong class="source-inline">TreeMap</strong>, to name the three most frequently used</li>
			</ul>
			<p>Reviewing all the classes and interfaces of the <strong class="source-inline">java.util</strong> package would require a dedicated book. So, in this section, we will just have a brief overview of the three main interfaces—<strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>—and one implementation class for each of them—<strong class="source-inline">ArrayList</strong>, <strong class="source-inline">HashSet</strong>, and <strong class="source-inline">HashMap</strong>. We start with methods that are shared by the <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> interfaces. The principal difference between <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> is that <strong class="source-inline">Set</strong> does not allow the duplication of elements. Another difference is that <strong class="source-inline">List</strong> preserves the order of elements and also allows them to be sorted.</p>
			<p>To identify an element inside a collection, the <strong class="source-inline">equals()</strong> method is used. To improve performance, classes that implement the <strong class="source-inline">Set</strong> interface often use the <strong class="source-inline">hashCode()</strong> method too. This facilitates rapid calculation of an integer (called a <strong class="bold">hash value</strong> or <strong class="bold">hash code</strong>) that is most of the time (but not always) unique to each element. Elements <a id="_idIndexMarker728"/>with the<a id="_idIndexMarker729"/> same hash value are placed in the same <em class="italic">bucket</em>. While establishing whether there is already a certain value in the set, it is enough to check the internal hash table and see whether such a value has already been used. If not, the new element is unique. If yes, then the new element can be compared (using the <strong class="source-inline">equals()</strong> method) with each of the elements with the same hash value. Such a procedure is faster than comparing a new element with each element of the set one by one. </p>
			<p>That is why we often see that the name of a class has a <strong class="source-inline">hash</strong> prefix, indicating that the class uses a hash value, so the element must implement the <strong class="source-inline">hashCode()</strong> method. While doing this, you must make sure that it is implemented<a id="_idIndexMarker730"/> so that every time the <strong class="source-inline">equals()</strong> method returns <strong class="source-inline">true</strong> for<a id="_idIndexMarker731"/> two <a id="_idIndexMarker732"/>objects, the hash values of these two objects returned by the <strong class="source-inline">hashCode()</strong> method are equal too. Otherwise, the just-described algorithm of using the hash value will not work.</p>
			<p>And finally, before talking about <strong class="source-inline">java.util</strong> interfaces, a few words about generics.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Generics</h2>
			<p>You can see <a id="_idIndexMarker733"/>these most often in declarations such as these:</p>
			<pre class="source-code">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</pre>
			<pre class="source-code">Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</pre>
			<p>In the preceding examples, <strong class="bold">generics</strong> are element nature declarations surrounded by angle brackets. As you can see, they are redundant, as they are repeated in the left- and right-hand sides of the assignment statement. That is why Java allows replacement of the generics on the right side with empty brackets (<strong class="source-inline">&lt;&gt;</strong>) called <a id="_idIndexMarker734"/>a <strong class="bold">diamond</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">List&lt;String&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</pre>
			<p>Generics inform the compiler about the expected type of collection elements. This way, the compiler can check whether an element a programmer tries to add to a declared collection is of a compatible type. Observe the following, for example:</p>
			<pre class="source-code">List&lt;String&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list.add("abc");</pre>
			<pre class="source-code">list.add(42);   //compilation error</pre>
			<p>This helps to avoid runtime errors. It also tips off the programmer (because an IDE compiles the code when a programmer writes it) about possible manipulations of collection elements.</p>
			<p>We will also see these other types of generics:</p>
			<ul>
				<li><strong class="source-inline">&lt;? extends T&gt;</strong> means <em class="italic">a type that is either</em> <strong class="source-inline">T</strong> <em class="italic">or a child of</em> <strong class="source-inline">T</strong>, where <strong class="source-inline">T</strong> is the type used as the generics of a collection.</li>
				<li><strong class="source-inline">&lt;? super T&gt;</strong> means <em class="italic">a type</em> <strong class="source-inline">T</strong> <em class="italic">or any of its base (parent) class</em>, where <strong class="source-inline">T</strong> is the type used as the generics of a collection.</li>
			</ul>
			<p>With that, let’s start with how an object of a class that implements the <strong class="source-inline">List</strong> or <strong class="source-inline">Set</strong> interface can be created—or, in other words, the <strong class="source-inline">List</strong> or <strong class="source-inline">Set</strong> type <a id="_idIndexMarker735"/>of variable can be initialized. To demonstrate the methods of these two interfaces, we will use two classes: <strong class="source-inline">ArrayList</strong> (implements <strong class="source-inline">List</strong>) and <strong class="source-inline">HashSet</strong> (implements <strong class="source-inline">Set</strong>).</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>How to initialize List and Set</h2>
			<p>Since<a id="_idIndexMarker736"/> Java 9, the <strong class="source-inline">List</strong> or <strong class="source-inline">Set</strong> interfaces<a id="_idIndexMarker737"/> have static <strong class="source-inline">of()</strong> factory methods that can be used to initialize a collection, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">of()</strong>: Returns an empty collection.</li>
				<li><strong class="source-inline">of(E... e)</strong>: Returns a collection with as many elements as are passed in during the call. They can be passed in a comma-separated list or as an array.</li>
			</ul>
			<p>Here are a few examples:</p>
			<pre class="source-code">//Collection&lt;String&gt; coll </pre>
			<pre class="source-code">//        = List.of("s1", null); //does not allow null</pre>
			<pre class="source-code">Collection&lt;String&gt; coll = List.of("s1", "s1", "s2");</pre>
			<pre class="source-code">//coll.add("s3");         //does not allow add element</pre>
			<pre class="source-code">//coll.remove("s1");   //does not allow remove element</pre>
			<pre class="source-code">//((List&lt;String&gt;) coll).set(1, "s3");    </pre>
			<pre class="source-code">                       //does not allow modify element</pre>
			<pre class="source-code">System.out.println(coll);       //prints: [s1, s1, s2]</pre>
			<pre class="source-code">//coll = Set.of("s3", "s3", "s4");     </pre>
			<pre class="source-code">                            //does not allow duplicate</pre>
			<pre class="source-code">//coll = Set.of("s2", "s3", null);     </pre>
			<pre class="source-code">                                 //does not allow null</pre>
			<pre class="source-code">coll = Set.of("s3", "s4");</pre>
			<pre class="source-code">System.out.println(coll);  </pre>
			<pre class="source-code">                        //prints: [s3, s4] or [s4, s3]</pre>
			<pre class="source-code">//coll.add("s5");         //does not allow add element</pre>
			<pre class="source-code">//coll.remove("s2");   //does not allow remove element</pre>
			<p>As you might expect, the factory method for <strong class="source-inline">Set</strong> does not allow duplicates, so we have commented the line out (otherwise, the preceding example would stop running at that line). What is less expected is that you cannot have a <strong class="source-inline">null</strong> element, and you cannot add/remove/modify elements of a collection after it was initialized using one of the <strong class="source-inline">of()</strong> methods. That’s why we have commented out some lines of the preceding example. If you need to add elements after a collection is initialized, you have to initialize it using a constructor or some other utilities that create a modifiable collection (we will see an example of <strong class="source-inline">Arrays.asList()</strong> shortly).</p>
			<p>The <strong class="source-inline">Collection</strong> interface provides two methods for adding elements to an object that implements <strong class="source-inline">Collection</strong> (the parent interface of <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong>) that look like this:</p>
			<ul>
				<li><strong class="source-inline">boolean add(E e)</strong>: This attempts to add the provided element <strong class="source-inline">e</strong> to the collection; it returns <strong class="source-inline">true</strong> in case of success, and <strong class="source-inline">false</strong> in case of not being able to accomplish it (for example, when such an element already exists in the <strong class="source-inline">Set</strong> interface).</li>
				<li><strong class="source-inline">boolean addAll(Collection&lt;? extends E&gt; c)</strong>: This attempts to add all of the elements in the provided collection to the collection; it returns <strong class="source-inline">true</strong> if at least one element was added, and <strong class="source-inline">false</strong> in case of not being able to add <a id="_idIndexMarker738"/>an <a id="_idIndexMarker739"/>element to the collection (for example, when all elements of the provided collection <strong class="source-inline">c</strong> already exist in the <strong class="source-inline">Set</strong> interface).</li>
			</ul>
			<p>Here’s an example of using the <strong class="source-inline">add()</strong> method:</p>
			<pre class="source-code">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">System.out.println(list1);     //prints: [s1, s1]</pre>
			<pre class="source-code">Set&lt;String&gt; set1 = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set1.add("s1");</pre>
			<pre class="source-code">set1.add("s1");</pre>
			<pre class="source-code">System.out.println(set1);      //prints: [s1]</pre>
			<p>And here is an example of using the <strong class="source-inline">addAll()</strong> method:</p>
			<pre class="source-code">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">System.out.println(list1);      //prints: [s1, s1]</pre>
			<pre class="source-code">List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list2.addAll(list1);</pre>
			<pre class="source-code">System.out.println(list2);      //prints: [s1, s1]</pre>
			<pre class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set.addAll(list1);</pre>
			<pre class="source-code">System.out.println(set);        //prints: [s1]</pre>
			<p>Here is<a id="_idIndexMarker740"/> an <a id="_idIndexMarker741"/>example of the <strong class="source-inline">add()</strong> and <strong class="source-inline">addAll()</strong> methods’ functionality:</p>
			<pre class="source-code">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">list1.add("s1");</pre>
			<pre class="source-code">System.out.println(list1);     //prints: [s1, s1]</pre>
			<pre class="source-code">List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">list2.addAll(list1);</pre>
			<pre class="source-code">System.out.println(list2);      //prints: [s1, s1]</pre>
			<pre class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set.addAll(list1);</pre>
			<pre class="source-code">System.out.println(set);        //prints: [s1]</pre>
			<pre class="source-code">Set&lt;String&gt; set1 = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set1.add("s1");</pre>
			<pre class="source-code">Set&lt;String&gt; set2 = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set2.add("s1");</pre>
			<pre class="source-code">set2.add("s2");</pre>
			<pre class="source-code">System.out.println(set1.addAll(set2)); //prints: true</pre>
			<pre class="source-code">System.out.println(set1);              //prints: [s1, s2]</pre>
			<p>Notice how, in<a id="_idIndexMarker742"/> the <a id="_idIndexMarker743"/>last example in the preceding code snippet, the <strong class="source-inline">set1.addAll(set2)</strong> method returns <strong class="source-inline">true</strong>, although not all elements were added. To see the case of the <strong class="source-inline">add()</strong> and <strong class="source-inline">addAll()</strong> methods returning <strong class="source-inline">false</strong>, look at the following example:</p>
			<pre class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">System.out.println(set.add("s1"));   //prints: true</pre>
			<pre class="source-code">System.out.println(set.add("s1"));   //prints: false</pre>
			<pre class="source-code">System.out.println(set);             //prints: [s1]</pre>
			<pre class="source-code">Set&lt;String&gt; set1 = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set1.add("s1");</pre>
			<pre class="source-code">set1.add("s2");</pre>
			<pre class="source-code">Set&lt;String&gt; set2 = new HashSet&lt;&gt;();</pre>
			<pre class="source-code">set2.add("s1");</pre>
			<pre class="source-code">set2.add("s2");</pre>
			<pre class="source-code">System.out.println(set1.addAll(set2)); //prints: false</pre>
			<pre class="source-code">System.out.println(set1);              //prints: [s1, s2]</pre>
			<p>The <strong class="source-inline">ArrayList</strong> and <strong class="source-inline">HashSet</strong> classes also have constructors that accept a collection, as illustrated in the following code snippet:</p>
			<pre class="source-code">Collection&lt;String&gt; list1 = List.of("s1", "s1", "s2");</pre>
			<pre class="source-code">System.out.println(list1);      //prints: [s1, s1, s2]</pre>
			<pre class="source-code">List&lt;String&gt; list2 = new ArrayList&lt;&gt;(list1);</pre>
			<pre class="source-code">System.out.println(list2);      //prints: [s1, s1, s2]</pre>
			<pre class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;(list1);</pre>
			<pre class="source-code">System.out.println(set);        //prints: [s1, s2]</pre>
			<pre class="source-code">List&lt;String&gt; list3 = new ArrayList&lt;&gt;(set);</pre>
			<pre class="source-code">System.out.println(list3);      //prints: [s1, s2]</pre>
			<p>Now, after <a id="_idIndexMarker744"/>we<a id="_idIndexMarker745"/> have learned how a collection can be initialized, we can turn to other methods in the <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> interfaces.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>java.lang.Iterable interface</h2>
			<p>The <strong class="source-inline">Collection</strong> interface<a id="_idIndexMarker746"/> extends the <strong class="source-inline">java.lang.Iterable</strong> interface, which means that classes that implement the <strong class="source-inline">Collection</strong> interface—directly or not—also implement the <strong class="source-inline">java.lang.Iterable</strong> interface. There are only three methods in the <strong class="source-inline">Iterable</strong> interface, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">Iterator&lt;T&gt; iterator()</strong>: This returns an object of a class that implements the <strong class="source-inline">java.util.Iterator</strong> interface; it allows the collection to be used in <strong class="source-inline">FOR</strong> statements, as in this example:<p class="source-code">Iterable&lt;String&gt; list = List.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(list);       //prints: [s1, s2, s3]</p><p class="source-code">for(String e: list){</p><p class="source-code">    System.out.print(e + " ");  //prints: s1 s2 s3</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">default void forEach (Consumer&lt;? super T&gt; function)</strong>: This applies the<a id="_idIndexMarker747"/> provided function of the <strong class="source-inline">Consumer</strong> type to each element of the collection until all elements have been processed or the function throws an exception. We will discuss what a function is in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>; for now, we will just provide an example here:<p class="source-code">Iterable&lt;String&gt; list = List.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(list);   //prints: [s1, s2, s3]</p><p class="source-code">list.forEach(e -&gt; System.out.print(e + " "));</p><p class="source-code">                            //prints: s1 s2 s3</p></li>
				<li><strong class="source-inline">default Spliterator&lt;T&gt; splititerator()</strong>: This returns an object of a class that implements the <strong class="source-inline">java.util.Spliterator</strong> interface; it is used primarily for implementing methods that allow parallel processing and is outside the scope of this book.</li>
			</ul>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Collection interface</h2>
			<p>As we have<a id="_idIndexMarker748"/> mentioned already, the <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> interfaces extend the <strong class="source-inline">Collection</strong> interface, which means that all methods of the <strong class="source-inline">Collection</strong> interface are inherited by <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong>. These methods are listed here:</p>
			<ul>
				<li><strong class="source-inline">boolean add(E e)</strong>: This attempts to add an element to the collection.</li>
				<li><strong class="source-inline">boolean addAll(Collection&lt;? extends E&gt; c)</strong>: This attempts to add all elements in the collection provided.</li>
				<li><strong class="source-inline">boolean equals(Object o)</strong>: This compares the collection with the <strong class="source-inline">o</strong> object provided. If the object provided is not a collection, this object returns <strong class="source-inline">false</strong>; otherwise, it compares the composition of the collection with the composition of the collection provided (as an <strong class="source-inline">o</strong> object). In the case of <strong class="source-inline">List</strong>, it also compares the order of elements. Let’s illustrate this with a few examples, as follows:<p class="source-code">Collection&lt;String&gt; list1 = List.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(list1);     //prints: [s1, s2, s3]</p><p class="source-code">Collection&lt;String&gt; list2 = List.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(list2);     //prints: [s1, s2, s3]</p><p class="source-code">System.out.println(list1.equals(list2));  </p><p class="source-code">                                      //prints: true</p><p class="source-code">Collection&lt;String&gt; list3 = List.of("s2", "s1", "s3");</p><p class="source-code">System.out.println(list3);     //prints: [s2, s1, s3]</p><p class="source-code">System.out.println(list1.equals(list3));  </p><p class="source-code">                                      //prints: false</p><p class="source-code">Collection&lt;String&gt; set1 = Set.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(set1);   </p><p class="source-code">            //prints: [s2, s3, s1] or different order</p><p class="source-code">Collection&lt;String&gt; set2 = Set.of("s2", "s1", "s3");</p><p class="source-code">System.out.println(set2);   </p><p class="source-code">            //prints: [s2, s1, s3] or different order</p><p class="source-code">System.out.println(set1.equals(set2));  </p><p class="source-code">                                       //prints: true</p><p class="source-code">Collection&lt;String&gt; set3 = Set.of("s4", "s1", "s3");</p><p class="source-code">System.out.println(set3);   </p><p class="source-code">            //prints: [s4, s1, s3] or different order</p><p class="source-code">System.out.println(set1.equals(set3));  </p><p class="source-code">                                      //prints: false</p></li>
				<li><strong class="source-inline">int hashCode()</strong>: This<a id="_idIndexMarker749"/> returns the hash value for the collection; it is used in the case where the collection is an element of a collection that requires the <strong class="source-inline">hashCode()</strong> method implementation.</li>
				<li><strong class="source-inline">boolean isEmpty()</strong>: This returns <strong class="source-inline">true</strong> if the collection does not have any elements.</li>
				<li><strong class="source-inline">int size()</strong>: This returns the count of elements of the collection; when the <strong class="source-inline">isEmpty()</strong> method returns <strong class="source-inline">true</strong>, this method returns <strong class="source-inline">0</strong>.</li>
				<li><strong class="source-inline">void clear()</strong>: This removes all elements from the collection; after this method is called, the <strong class="source-inline">isEmpty()</strong> method returns <strong class="source-inline">true</strong>, and the <strong class="source-inline">size()</strong> method returns <strong class="source-inline">0</strong>.</li>
				<li><strong class="source-inline">boolean contains(Object o)</strong>: This returns <strong class="source-inline">true</strong> if the collection contains the provided <strong class="source-inline">o</strong> object. For this method to work correctly, each element of the collection and the provided object must implement the <strong class="source-inline">equals()</strong> method, and, in the case of <strong class="source-inline">Set</strong>, the <strong class="source-inline">hashCode()</strong> method should be implemented.</li>
				<li><strong class="source-inline">boolean containsAll(Collection&lt;?&gt; c)</strong>: This returns <strong class="source-inline">true</strong> if the collection contains all elements in the collection provided. For this method to work correctly, each element of the collection and each element of the collection provided must implement the <strong class="source-inline">equals()</strong> method, and, in the case of <strong class="source-inline">Set</strong>, the <strong class="source-inline">hashCode()</strong> method should be implemented.</li>
				<li><strong class="source-inline">boolean remove(Object o)</strong>: This attempts to remove the specified element from this collection and returns <strong class="source-inline">true</strong> if it was present. For this method to work correctly, each element of the collection and the object provided must implement the <strong class="source-inline">equals()</strong> method, and, in the case of <strong class="source-inline">Set</strong>, the <strong class="source-inline">hashCode()</strong> method should be implemented.</li>
				<li><strong class="source-inline">boolean removeAll(Collection&lt;?&gt; c)</strong>: This attempts to remove from the collection all elements of the collection provided; similar to the <strong class="source-inline">addAll()</strong> method, this method returns <strong class="source-inline">true</strong> if at least one of the elements was removed; otherwise, it returns <strong class="source-inline">false</strong>. For this method to work correctly, each<a id="_idIndexMarker750"/> element of the collection and each element of the collection provided must implement the <strong class="source-inline">equals()</strong> method, and, in the case of <strong class="source-inline">Set</strong>, the <strong class="source-inline">hashCode()</strong> method should be implemented.</li>
				<li><strong class="source-inline">default boolean removeIf(Predicate&lt;? super E&gt; filter)</strong>: This attempts to remove from the collection all elements that satisfy the given predicate; it is a function we are going to describe in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>. It returns <strong class="source-inline">true</strong> if at least one element was removed.</li>
				<li><strong class="source-inline">boolean retainAll(Collection&lt;?&gt; c)</strong>: This attempts to retain in the collection just the elements contained in the collection provided. Similar to the <strong class="source-inline">addAll()</strong> method, this method returns <strong class="source-inline">true</strong> if at least one of the elements is retained; otherwise, it returns <strong class="source-inline">false</strong>. For this method to work correctly, each element of the collection and each element of the collection provided must implement the <strong class="source-inline">equals()</strong> method, and, in the case of <strong class="source-inline">Set</strong>, the <strong class="source-inline">hashCode()</strong> method should be implemented.</li>
				<li><strong class="source-inline">Object[] toArray()</strong>, <strong class="source-inline">T[] toArray(T[] a)</strong>: This converts the collection to an array.</li>
				<li><strong class="source-inline">default T[] toArray(IntFunction&lt;T[]&gt; generator)</strong>: This converts the collection to an array, using the function provided. We are going to explain functions in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>.</li>
				<li><strong class="source-inline">default Stream&lt;E&gt; stream()</strong>: This returns a <strong class="source-inline">Stream</strong> object (we talk about streams in <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>).</li>
				<li><strong class="source-inline">default Stream&lt;E&gt; parallelStream()</strong>: This returns a possibly parallel <strong class="source-inline">Stream</strong> object (we<a id="_idIndexMarker751"/> talk about streams in <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>).</li>
			</ul>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>List interface</h2>
			<p>The <strong class="source-inline">List</strong> interface has <a id="_idIndexMarker752"/>several other methods that do not belong to any of its parent interfaces, as outlined here:</p>
			<ul>
				<li>Static factory <strong class="source-inline">of()</strong> methods, described in the <em class="italic">How to initialize List and Set</em> subsection.</li>
				<li><strong class="source-inline">void add(int index, E element)</strong>: This inserts the element provided at the provided position in the list.</li>
				<li><strong class="source-inline">static List&lt;E&gt; copyOf(Collection&lt;E&gt; coll)</strong>: This returns an unmodifiable <strong class="source-inline">List</strong> interface containing the elements of the given <strong class="source-inline">Collection</strong> interface and preserves their order. The following code snippet demonstrates the functionality of this method:<p class="source-code">Collection&lt;String&gt; list = List.of("s1", "s2", "s3");</p><p class="source-code">System.out.println(list);    //prints: [s1, s2, s3]</p><p class="source-code">List&lt;String&gt; list1 = List.copyOf(list);</p><p class="source-code">//list1.add("s4");                //run-time error</p><p class="source-code">//list1.set(1, "s5");             //run-time error</p><p class="source-code">//list1.remove("s1");             //run-time error</p><p class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;();</p><p class="source-code">System.out.println(set.add("s1"));</p><p class="source-code">System.out.println(set);          //prints: [s1]</p><p class="source-code">Set&lt;String&gt; set1 = Set.copyOf(set);</p><p class="source-code">//set1.add("s2");                 //run-time error</p><p class="source-code">//set1.remove("s1");              //run-time error</p><p class="source-code">Set&lt;String&gt; set2 = Set.copyOf(list);</p><p class="source-code">System.out.println(set2);    //prints: [s1, s2, s3] </p></li>
				<li><strong class="source-inline">E get(int index)</strong>: This <a id="_idIndexMarker753"/>returns the element located at the position specified in the list.</li>
				<li><strong class="source-inline">List&lt;E&gt; subList(int fromIndex, int toIndex)</strong>: Extracts a sublist between <strong class="source-inline">fromIndex</strong> (inclusive) and <strong class="source-inline">toIndex</strong> (exclusive).</li>
				<li><strong class="source-inline">int indexOf(Object o)</strong>: This returns the first index (position) of a specified element in the list; the first element in the list has an index (position) of <strong class="source-inline">0</strong>.</li>
				<li><strong class="source-inline">int lastIndexOf(Object o)</strong>: This returns the last index (position) of a specified element in the list; the final element in the list has a <strong class="source-inline">list.size() - 1</strong> index position.</li>
				<li><strong class="source-inline">E remove(int index)</strong>: This removes the element located at a specified position in the list; it returns the element removed.</li>
				<li><strong class="source-inline">E set(int index, E element)</strong>: This replaces the element located at a position specified in the list; it returns the element replaced.</li>
				<li><strong class="source-inline">default void replaceAll(UnaryOperator&lt;E&gt; operator)</strong>: This transforms the list by applying the function provided to each element. The <strong class="source-inline">UnaryOperator</strong> function will be described in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>.</li>
				<li><strong class="source-inline">ListIterator&lt;E&gt; listIterator()</strong>: Returns a <strong class="source-inline">ListIterator</strong> object that allows the list to be traversed backward.</li>
				<li><strong class="source-inline">ListIterator&lt;E&gt; listIterator(int index)</strong>: Returns a <strong class="source-inline">ListIterator</strong> object that allows the sublist (starting from the provided position) to be <a id="_idIndexMarker754"/>traversed backward. Observe the following, for example:<p class="source-code">List&lt;String&gt; list = List.of("s1", "s2", "s3");</p><p class="source-code">ListIterator&lt;String&gt; li = list.listIterator();</p><p class="source-code">while(li.hasNext()){</p><p class="source-code">    System.out.print(li.next() + " ");     </p><p class="source-code">                              //prints: s1 s2 s3</p><p class="source-code">}</p><p class="source-code">while(li.hasPrevious()){</p><p class="source-code">    System.out.print(li.previous() + " ");  </p><p class="source-code">                               //prints: s3 s2 s1</p><p class="source-code">}</p><p class="source-code">ListIterator&lt;String&gt; li1 = list.listIterator(1);</p><p class="source-code">while(li1.hasNext()){</p><p class="source-code">    System.out.print(li1.next() + " ");       </p><p class="source-code">                                  //prints: s2 s3</p><p class="source-code">}</p><p class="source-code">ListIterator&lt;String&gt; li2 = list.listIterator(1);</p><p class="source-code">while(li2.hasPrevious()){</p><p class="source-code">    System.out.print(li2.previous() + " ");   </p><p class="source-code">                                      //prints: s1</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">default void sort(Comparator&lt;? super E&gt; c)</strong>: This sorts the list according to the order generated by the <strong class="source-inline">Comparator</strong> interface provided. Observe the<a id="_idIndexMarker755"/> following, for example:<p class="source-code">List&lt;String&gt; list = new ArrayList&lt;&gt;();</p><p class="source-code">list.add("S2");</p><p class="source-code">list.add("s3");</p><p class="source-code">list.add("s1");</p><p class="source-code">System.out.println(list);     //prints: [S2, s3, s1]</p><p class="source-code">list.sort(String.CASE_INSENSITIVE_ORDER);</p><p class="source-code">System.out.println(list);     //prints: [s1, S2, s3]</p><p class="source-code">//list.add(null);      //causes NullPointerException</p><p class="source-code">list.sort(Comparator.naturalOrder());</p><p class="source-code">System.out.println(list);     //prints: [S2, s1, s3]</p><p class="source-code">list.sort(Comparator.reverseOrder());</p><p class="source-code">System.out.println(list);     //prints: [s3, s1, S2]</p><p class="source-code">list.add(null);</p><p class="source-code">list.sort(Comparator.nullsFirst(Comparator</p><p class="source-code">                                   .naturalOrder()));</p><p class="source-code">System.out.println(list);  </p><p class="source-code">                        //prints: [null, S2, s1, s3]</p><p class="source-code">list.sort(Comparator.nullsLast(Comparator</p><p class="source-code">                                  .naturalOrder()));</p><p class="source-code">System.out.println(list);         </p><p class="source-code">                        //prints: [S2, s1, s3, null]</p><p class="source-code">Comparator&lt;String&gt; comparator = </p><p class="source-code">     (s1, s2) -&gt; s1 == null ? -1 : s1.compareTo(s2);</p><p class="source-code">list.sort(comparator);</p><p class="source-code">System.out.println(list);         </p><p class="source-code">                         //prints: [null, S2, s1, s3]</p><p class="source-code">Comparator&lt;String&gt; comparator = (s1, s2) -&gt; </p><p class="source-code"> s1 == null ? -1 : s1.compareTo(s2);</p><p class="source-code">list.sort(comparator);</p><p class="source-code">System.out.println(list);    </p><p class="source-code">                             //prints: [null, S2, s1, s3]</p></li>
			</ul>
			<p>There are <a id="_idIndexMarker756"/>principally two ways to sort a list, as follows:</p>
			<ul>
				<li>Using a <strong class="source-inline">Comparable</strong> interface <a id="_idIndexMarker757"/>implementation (called <strong class="bold">natural order</strong>)</li>
				<li>Using a <strong class="source-inline">Comparator</strong> interface implementation</li>
			</ul>
			<p>The <strong class="source-inline">Comparable</strong> interface only has a <strong class="source-inline">compareTo()</strong> method. In the preceding example, we have implemented the <strong class="source-inline">Comparator</strong> interface basing it on the <strong class="source-inline">Comparable</strong> interface implementation in the <strong class="source-inline">String</strong> class. As you can see, this implementation provided the same sort order as <strong class="source-inline">Comparator.nullsFirst(Comparator.naturalOrder())</strong>. This style of implementation is <a id="_idIndexMarker758"/>called <strong class="bold">functional programming</strong>, which we will discuss in more detail in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Set interface </h2>
			<p>The <strong class="source-inline">Set</strong> interface has the<a id="_idIndexMarker759"/> following methods that do not belong to any of its parent interfaces:</p>
			<ul>
				<li>Static <strong class="source-inline">of()</strong> factory methods, described in the <em class="italic">How to initialize List and Set</em> subsection.</li>
				<li>The <strong class="source-inline">static Set&lt;E&gt; copyOf(Collection&lt;E&gt; coll)</strong> method: This returns an unmodifiable <strong class="source-inline">Set</strong> interface containing elements of the given <strong class="source-inline">Collection</strong>; it works the same way as the <strong class="source-inline">static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;E&gt; coll)</strong> method described in the <em class="italic">List interface</em> section.</li>
			</ul>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Map interface</h2>
			<p>The <strong class="source-inline">Map</strong> interface has <a id="_idIndexMarker760"/>many methods similar to the <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> methods, as listed here:</p>
			<ul>
				<li><strong class="source-inline">int size()</strong></li>
				<li><strong class="source-inline">void clear()</strong></li>
				<li><strong class="source-inline">int hashCode()</strong></li>
				<li><strong class="source-inline">boolean isEmpty()</strong></li>
				<li><strong class="source-inline">boolean equals(Object o)</strong></li>
				<li><strong class="source-inline">default void forEach(BiConsumer&lt;K,V&gt; action)</strong></li>
				<li>Static factory methods: <strong class="source-inline">of()</strong>, <strong class="source-inline">of(K, V v)</strong>, <strong class="source-inline">of(K k1, V v1, K k2, V v2)</strong>, and many other methods besides</li>
			</ul>
			<p>The <strong class="source-inline">Map</strong> interface, however, does not extend <strong class="source-inline">Iterable</strong>, <strong class="source-inline">Collection</strong>, or any other interface, for that matter. It is designed to be able to store <strong class="bold">values</strong> by their <strong class="bold">keys</strong>. Each key is unique, while several equal values can be stored with different keys on the same map. The combination of key and value constitutes <strong class="source-inline">Entry</strong>, which is an internal interface of <strong class="source-inline">Map</strong>. Both <strong class="source-inline">value</strong> and <strong class="source-inline">key</strong> objects must implement the <strong class="source-inline">equals()</strong> method. A <strong class="source-inline">key</strong> object must also implement the <strong class="source-inline">hashCode()</strong> method. </p>
			<p>Many methods of the <strong class="source-inline">Map</strong> interface have exactly the same signature and functionality as in the <strong class="source-inline">List</strong> and <strong class="source-inline">Set</strong> interfaces, so we are not going to repeat them here. We will only walk through the <strong class="source-inline">Map</strong>-specific methods, as follows:</p>
			<ul>
				<li><strong class="source-inline">V get(Object key)</strong>: This retrieves the value according to the key provided; it returns <strong class="source-inline">null</strong> if there is no such key.</li>
				<li><strong class="source-inline">Set&lt;K&gt; keySet()</strong>: This retrieves all keys from the map.</li>
				<li><strong class="source-inline">Collection&lt;V&gt; values()</strong>: This retrieves all values from the map.</li>
				<li><strong class="source-inline">boolean containsKey(Object key)</strong>: This returns <strong class="source-inline">true</strong> if the key provided exists in the map.</li>
				<li><strong class="source-inline">boolean containsValue(Object value)</strong>: This returns <strong class="source-inline">true</strong> if the value provided<a id="_idIndexMarker761"/> exists in the map.</li>
				<li><strong class="source-inline">V put(K key, V value)</strong>: This adds the value and its key to the map; it returns the previous value stored with the same key.</li>
				<li><strong class="source-inline">void putAll(Map&lt;K,V&gt; m)</strong>: This copies from the map provided all the key-value pairs.</li>
				<li><strong class="source-inline">default V putIfAbsent(K key, V value)</strong>: This stores the value provided and maps to the key provided if such a key is not already used by the map. It returns the value mapped to the key provided—either an existing or a new one.</li>
				<li><strong class="source-inline">V remove(Object key)</strong>: This removes both the key and value from the map; it returns a value or <strong class="source-inline">null</strong> if there is no such key, or if the value is <strong class="source-inline">null</strong>.</li>
				<li><strong class="source-inline">default boolean remove(Object key, Object value)</strong>: This removes the key-value pair from the map if such a pair exists in the map.</li>
				<li><strong class="source-inline">default V replace(K key, V value)</strong>: This replaces the value if the key provided is currently mapped to the value provided. It returns the old value if it was replaced; otherwise, it returns <strong class="source-inline">null</strong>.</li>
				<li><strong class="source-inline">default boolean replace(K key, V oldValue, V newValue)</strong>: This replaces the <strong class="source-inline">oldValue</strong> value with the <strong class="source-inline">newValue</strong> value provided if the key provided is currently mapped to the <strong class="source-inline">oldValue</strong> value. It returns <strong class="source-inline">true</strong> if the <strong class="source-inline">oldValue</strong> value was replaced; otherwise, it returns <strong class="source-inline">false</strong>.</li>
				<li><strong class="source-inline">default void replaceAll(BiFunction&lt;K,V,V&gt; function)</strong>: This <a id="_idIndexMarker762"/>applies the function provided to each key-value pair in the map and replaces it with the result, or throws an exception if this is not possible.</li>
				<li><strong class="source-inline">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong>: This returns a set of all key-value pairs as objects of <strong class="source-inline">Map.Entry</strong>.</li>
				<li><strong class="source-inline">default V getOrDefault(Object key, V defaultValue)</strong>: This returns the value mapped to the key provided or the <strong class="source-inline">defaultValue</strong> value if the map does not have the key provided.</li>
				<li><strong class="source-inline">static Map.Entry&lt;K,V&gt; entry(K key, V value)</strong>: This returns an unmodifiable <strong class="source-inline">Map.Entry</strong> object with the <strong class="source-inline">key</strong> object and <strong class="source-inline">value</strong> object provided in it.</li>
				<li><strong class="source-inline">static Map&lt;K,V&gt; copy(Map&lt;K,V&gt; map):</strong> This converts the <strong class="source-inline">Map</strong> interface provided to an unmodifiable one.</li>
			</ul>
			<p>The following <strong class="source-inline">Map</strong> methods are much too complicated for the scope of this book, so we are just mentioning them for the sake of completeness. They allow multiple values to be combined or calculated and aggregated in a single existing value in the <strong class="source-inline">Map</strong> interface, or a new one to be created:</p>
			<ul>
				<li><strong class="source-inline">default V merge(K key, V value, BiFunction&lt;V,V,V&gt; remappingFunction)</strong>: If the provided key-value pair exists and the value is not <strong class="source-inline">null</strong>, the provided function is used to calculate a new value; it removes the key-value pair if the newly calculated value is <strong class="source-inline">null</strong>. If the key-value pair provided does not exist or the value is <strong class="source-inline">null</strong>, the non-<strong class="source-inline">null</strong> value provided replaces the current one. This method can be used for aggregating several values; for example, it can be used for concatenating the following string values: <strong class="source-inline">map.merge(key, value, String::concat)</strong>. We will explain what <strong class="source-inline">String::concat</strong> means in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming.</em></li>
				<li><strong class="source-inline">default V compute(K key, BiFunction&lt;K,V,V&gt; remappingFunction)</strong>: This computes a new value using the function provided.</li>
				<li><strong class="source-inline">default V computeIfAbsent(K key, Function&lt;K,V&gt; mappingFunction)</strong>: This computes a new value using the function provided only if the provided key is not already associated with a value, or the<a id="_idIndexMarker763"/> value is <strong class="source-inline">null</strong>.</li>
				<li><strong class="source-inline">default V computeIfPresent(K key, BiFunction&lt;K,V,V&gt; remappingFunction)</strong>: This computes a new value using the function provided only if the provided key is already associated with a value and the value is not <strong class="source-inline">null</strong>.</li>
			</ul>
			<p>This last group of <em class="italic">computing</em> and <em class="italic">merging</em> methods is rarely used. The most popular, by far, are the <strong class="source-inline">V put(K key, V value)</strong> and <strong class="source-inline">V get(Object key)</strong> methods, which allow the use of the main <strong class="source-inline">Map</strong> function of storing key-value pairs and retrieving the value using the key. The <strong class="source-inline">Set&lt;K&gt; keySet()</strong> method is often used for iterating over the map’s key-value pairs, although the <strong class="source-inline">entrySet()</strong> method seems a more natural way of doing that. Here is an example:</p>
			<pre class="source-code">Map&lt;Integer, String&gt; map = Map.of(1, "s1", 2, "s2", 3, "s3");</pre>
			<pre class="source-code">for(Integer key: map.keySet()){</pre>
			<pre class="source-code">    System.out.print(key + ", " + map.get(key) + ", ");  </pre>
			<pre class="source-code">                                 //prints: 3, s3, 2, s2, 1, s1,</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">for(Map.Entry e: map.entrySet()){</pre>
			<pre class="source-code">    System.out.print(e.getKey() + ", " + e.getValue() + ", "); </pre>
			<pre class="source-code">                                 //prints: 2, s2, 3, s3, 1, s1,</pre>
			<pre class="source-code">}</pre>
			<p>The first of the <strong class="source-inline">for</strong> loops in the preceding code example uses a more widespread way to access the key-pair values of a map by iterating over the keys. The second <strong class="source-inline">for</strong> loop iterates over the set of entries, which (in our opinion) is a more natural way to do it. Notice that the printed-out values are not in the same order we have put them in the map. That is because, since Java 9, unmodifiable collections (that is, what <strong class="source-inline">of()</strong> factory methods produce) have added randomization to the order of <strong class="source-inline">Set</strong> elements, which changes the order of elements between different code executions. Such a design was done to make <a id="_idIndexMarker764"/>sure a programmer does not rely on a certain order of <strong class="source-inline">Set</strong> elements, which is not guaranteed for a set. </p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>Unmodifiable collections</h2>
			<p>Please note that<a id="_idIndexMarker765"/> collections produced by <strong class="source-inline">of()</strong> factory methods used to be<a id="_idIndexMarker766"/> called <strong class="bold">immutable</strong> in Java 9, and <strong class="bold">unmodifiable</strong> since Java 10. That is because immutable implies that you cannot change anything in collections, while, in fact, collection elements can be changed if they are modifiable objects. For example, let’s build a collection of objects of the <strong class="source-inline">Person1</strong> class, as follows: </p>
			<pre class="source-code">class Person1 {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person1(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name == null ? "" : name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setName(String name){ this.name = name; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        return "Person{age=" + age +</pre>
			<pre class="source-code">                ", name=" + name + "}";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the following code snippet, for simplicity, we will create a list with one element only and will then try<a id="_idIndexMarker767"/> to modify the element:</p>
			<pre class="source-code">Person1 p1 = new Person1(45, "Bill");</pre>
			<pre class="source-code">List&lt;Person1&gt; list = List.of(p1);</pre>
			<pre class="source-code">//list.add(new Person1(22, "Bob"));</pre>
			<pre class="source-code">                         //UnsupportedOperationException</pre>
			<pre class="source-code">System.out.println(list);    </pre>
			<pre class="source-code">                    //prints: [Person{age=45, name=Bill}]</pre>
			<pre class="source-code">p1.setName("Kelly");       </pre>
			<pre class="source-code">System.out.println(list);    </pre>
			<pre class="source-code">                   //prints: [Person{age=45, name=Kelly}]</pre>
			<p>As you can see, although it is not possible to add an element to the list created by the <strong class="source-inline">of()</strong> factory<a id="_idIndexMarker768"/> method, its element can still be modified if a reference to the element exists outside the list.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Collections utilities</h1>
			<p>There are two<a id="_idIndexMarker769"/> classes with static methods handling collections that are very popular and helpful, as follows:</p>
			<ul>
				<li><strong class="source-inline">java.util.Collections</strong></li>
				<li><strong class="source-inline">org.apache.commons.collections4.CollectionUtils</strong></li>
			</ul>
			<p>The fact that the methods are static means they do not depend on the object state, so they are <a id="_idIndexMarker770"/>also<a id="_idIndexMarker771"/> called <strong class="bold">stateless methods</strong> or <strong class="bold">utility methods</strong>.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>java.util.Collections class</h2>
			<p>Many<a id="_idIndexMarker772"/> methods in the <strong class="source-inline">Collections</strong> class<a id="_idIndexMarker773"/> manage collections and analyze, sort, and compare them. There are more than 70 of them, so we won’t have a chance to talk about all of them. Instead, we are going to look at the ones most often used by mainstream application developers, as follows:</p>
			<ul>
				<li><strong class="source-inline">static copy(List&lt;T&gt; dest, List&lt;T&gt; src)</strong>: This copies elements of the <strong class="source-inline">src</strong> list to the <strong class="source-inline">dest</strong> list and preserves the order of elements and their position in the list. The <strong class="source-inline">dest</strong> list size has to be equal to, or bigger than, the <strong class="source-inline">src</strong> list size, otherwise a runtime exception is raised. Here is an example of this method’s usage:<p class="source-code">List&lt;String&gt; list1 = Arrays.asList("s1","s2");</p><p class="source-code">List&lt;String&gt; list2 = Arrays.asList("s3", "s4", "s5");</p><p class="source-code">Collections.copy(list2, list1);</p><p class="source-code">System.out.println(list2);    //prints: [s1, s2, s5]</p></li>
				<li><strong class="source-inline">static void sort(List&lt;T&gt; list)</strong>: This sorts the list in order according to the <strong class="source-inline">compareTo(T)</strong> method implemented by each element (called <strong class="bold">natural ordering</strong>). It only <a id="_idIndexMarker774"/>accepts lists with elements that implement the <strong class="source-inline">Comparable</strong> interface (which requires implementation of the <strong class="source-inline">compareTo(T)</strong> method). In the example that follows, we use <strong class="source-inline">List&lt;String&gt;</strong> because the <strong class="source-inline">String</strong> class implements <strong class="source-inline">Comparable</strong>:<p class="source-code">//List&lt;String&gt; list = </p><p class="source-code">         //List.of("a", "X", "10", "20", "1", "2");</p><p class="source-code">List&lt;String&gt; list = </p><p class="source-code">     Arrays.asList("a", "X", "10", "20", "1", "2");</p><p class="source-code">Collections.sort(list);</p><p class="source-code">System.out.println(list);      </p><p class="source-code">                     //prints: [1, 10, 2, 20, X, a]</p></li>
			</ul>
			<p>Note that we could not use the <strong class="source-inline">List.of()</strong> method to create a list because the list would be unmodifiable and its order could not be changed. Also, look at the resulting order: numbers come first, then capital letters, followed by lowercase letters. That is because the <strong class="source-inline">compareTo()</strong> method in the <strong class="source-inline">String</strong> class uses code points of the characters to <a id="_idIndexMarker775"/>establish the order. Here is the code<a id="_idIndexMarker776"/> that demonstrates this:</p>
			<p class="source-code">List&lt;String&gt; list = </p>
			<p class="source-code">           Arrays.asList("a", "X", "10", "20", "1", "2");</p>
			<p class="source-code">Collections.sort(list);</p>
			<p class="source-code">System.out.println(list);  //prints: [1, 10, 2, 20, X, a]</p>
			<p class="source-code">list.forEach(s -&gt; {</p>
			<p class="source-code">    for(int i = 0; i &lt; s.length(); i++){</p>
			<p class="source-code">       System.out.print(" " + </p>
			<p class="source-code">                            Character.codePointAt(s, i));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if(!s.equals("a")) {</p>
			<p class="source-code">       System.out.print(","); </p>
			<p class="source-code">                   //prints: 49, 49 48, 50, 50 48, 88, 97</p>
			<p class="source-code">    }</p>
			<p class="source-code">});</p>
			<p>As you can see, the order is defined by the value of the code points of the characters that compose the string.</p>
			<ul>
				<li><strong class="source-inline">static void sort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator)</strong>: This sorts the order of the list according to the <strong class="source-inline">Comparator</strong> object provided, irrespective of whether the list elements implement the <strong class="source-inline">Comparable</strong> interface or not. As an example, let’s sort a list that consists of objects in the <strong class="source-inline">Person</strong> class, as follows:<p class="source-code">class Person  {</p><p class="source-code">    private int age;</p><p class="source-code">    private String name;</p><p class="source-code">    public Person(int age, String name) {</p><p class="source-code">        this.age = age;</p><p class="source-code">        this.name = name == null ? "" : name;</p><p class="source-code">    }</p><p class="source-code">    public int getAge() { return this.age; }</p><p class="source-code">    public String getName() { return this.name; }</p><p class="source-code">    @Override</p><p class="source-code">    public String toString() {</p><p class="source-code">        return "Person{name=" + name + </p><p class="source-code">                       ", age=" + age + "}";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>And here is <a id="_idIndexMarker777"/>the <strong class="source-inline">Comparator</strong> class to sort the<a id="_idIndexMarker778"/> list of <strong class="source-inline">Person</strong> objects:<p class="source-code">class ComparePersons implements Comparator&lt;Person&gt; {</p><p class="source-code">    public int compare(Person p1, Person p2){</p><p class="source-code">        int result = p1.getName().compareTo(p2.getName());</p><p class="source-code">        if (result != 0) { return result; }</p><p class="source-code">        return p1.age - p2.getAge();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>Now, we can use the <strong class="source-inline">Person</strong> and <strong class="source-inline">ComparePersons</strong> classes, as follows:</p>
			<pre class="source-code">List&lt;Person&gt; persons = </pre>
			<pre class="source-code">      Arrays.asList(new Person(23, "Jack"),</pre>
			<pre class="source-code">                    new Person(30, "Bob"), </pre>
			<pre class="source-code">                    new Person(15, "Bob"));</pre>
			<pre class="source-code">Collections.sort(persons, new ComparePersons());</pre>
			<pre class="source-code">System.out.println(persons);    </pre>
			<pre class="source-code">                //prints: [Person{name=Bob, age=15}, </pre>
			<pre class="source-code">                //         Person{name=Bob, age=30}, </pre>
			<pre class="source-code">                //         Person{name=Jack, age=23}]</pre>
			<p>As we have mentioned already, there are many more utilities in the <strong class="source-inline">Collections</strong> class, so we recommend you look through the related documentation <a id="_idIndexMarker779"/>at least once and understand all its <a id="_idIndexMarker780"/>capabilities.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>CollectionUtils class</h2>
			<p>The <strong class="source-inline">org.apache.commons.collections4.CollectionUtils</strong> class in the <em class="italic">Apache Commons</em> project <a id="_idIndexMarker781"/>contains static stateless methods<a id="_idIndexMarker782"/> that complement the methods of the <strong class="source-inline">java.util.Collections</strong> class. They help to search, process, and compare Java collections.</p>
			<p>To use this class, you would need to add the following dependency to the Maven <strong class="source-inline">pom.xml</strong> configuration file:</p>
			<pre class="source-code"> &lt;dependency&gt;</pre>
			<pre class="source-code">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;4.4&lt;/version&gt;</pre>
			<pre class="source-code"> &lt;/dependency&gt;</pre>
			<p>There are many methods in this class, and more methods will probably be added over time. These utilities are created in addition to <strong class="source-inline">Collections</strong> methods, so they are more complex and nuanced and do not fit the scope of this book. To give you an idea of the methods available in the <strong class="source-inline">CollectionUtils</strong> class, here is a brief description of the methods, grouped according to their functionality:</p>
			<ul>
				<li>Methods that retrieve an element from a collection</li>
				<li>Methods that add an element or a group of elements to a collection</li>
				<li>Methods that merge <strong class="source-inline">Iterable</strong> elements into a collection</li>
				<li>Methods that remove or retain elements with or without criteria</li>
				<li>Methods that compare two collections</li>
				<li>Methods that transform a collection</li>
				<li>Methods that select from, and filter, a collection</li>
				<li>Methods that generate the union, intersection, or difference of two collections</li>
				<li>Methods that create an immutable empty collection</li>
				<li>Methods that check collection size and emptiness</li>
				<li>A method that reverses an array</li>
			</ul>
			<p>This last method <a id="_idIndexMarker783"/>should probably belong to the utility class<a id="_idIndexMarker784"/> that handles arrays, and that is what we are going to discuss now.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Arrays utilities</h1>
			<p>There are two <a id="_idIndexMarker785"/>classes with static methods handling collections that are very popular and helpful, as follows:</p>
			<ul>
				<li><strong class="source-inline">java.util.Arrays</strong></li>
				<li><strong class="source-inline">org.apache.commons.lang3.ArrayUtils</strong></li>
			</ul>
			<p>We will briefly review each of them.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>java.util.Arrays class</h2>
			<p>We<a id="_idIndexMarker786"/> have <a id="_idIndexMarker787"/>already used the <strong class="source-inline">java.util.Arrays</strong> class several times. It is the primary utility class for array management. This utility class used to be very popular because of the <strong class="source-inline">asList(T...a)</strong> method. It was the most compact way of creating and initializing a collection and is shown in the following snippet:</p>
			<pre class="source-code">List&lt;String&gt; list = Arrays.asList("s0", "s1");</pre>
			<pre class="source-code">Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList("s0", "s1");</pre>
			<p>It is still a popular way of creating a modifiable list—we used it, too. However, after a <strong class="source-inline">List.of()</strong> factory method was introduced, the <strong class="source-inline">Arrays</strong> class declined substantially.</p>
			<p>Nevertheless, if you need to manage arrays, then the <strong class="source-inline">Arrays</strong> class may be a big help. It contains more than 160 methods, and most of them are overloaded with different parameters and array types. If we group them by the method name, there will be 21 groups, and if we further group them by functionality, only the following 10 groups will cover all the <strong class="source-inline">Arrays</strong> class functionality:</p>
			<ul>
				<li><strong class="source-inline">asList()</strong>: This creates an <strong class="source-inline">ArrayList</strong> object based on the provided array or comma-separated list of parameters.</li>
				<li><strong class="source-inline">binarySearch()</strong>: This searches an array or only a specified part of it (according to the range of indices).</li>
				<li><strong class="source-inline">compare()</strong>, <strong class="source-inline">mismatch()</strong>, <strong class="source-inline">equals()</strong>, and <strong class="source-inline">deepEquals()</strong>: These compare two arrays or their elements (according to the range of indices).</li>
				<li><strong class="source-inline">copyOf()</strong> and <strong class="source-inline">copyOfRange()</strong>: This copies all arrays or only a specified (according to the range of indices) part of them.</li>
				<li><strong class="source-inline">hashcode()</strong> and <strong class="source-inline">deepHashCode()</strong>: This generates a hash code value based on the array provided.</li>
				<li><strong class="source-inline">toString()</strong> and <strong class="source-inline">deepToString()</strong>: This creates a <strong class="source-inline">String</strong> representation of an array.</li>
				<li><strong class="source-inline">fill()</strong>, <strong class="source-inline">setAll()</strong>, <strong class="source-inline">parallelPrefix()</strong>, and <strong class="source-inline">parallelSetAll()</strong>: This sets a value (fixed or generated by the function provided) for every element of an array or those specified according to a range of indices.</li>
				<li><strong class="source-inline">sort()</strong> and <strong class="source-inline">parallelSort()</strong>: This sorts elements of an array or only part of it (specified according to a range of indices).</li>
				<li><strong class="source-inline">splititerator()</strong>: This returns a <strong class="source-inline">Splititerator</strong> object for parallel processing of an array or part of it (specified according to a range of indices).</li>
				<li><strong class="source-inline">stream()</strong>: This generates a stream of array elements or some of them (specified according to a range of indices); see <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em><em class="italic">.</em></li>
			</ul>
			<p>All of these methods are helpful, but we would like to draw your attention to the <strong class="source-inline">equals(a1, a2)</strong> and <strong class="source-inline">deepEquals(a1, a2)</strong> methods. They are particularly helpful for array comparison because an <strong class="source-inline">array</strong> object cannot implement an <strong class="source-inline">equals()</strong> custom method and uses the implementation of the <strong class="source-inline">Object</strong> class instead (which compares only references). The <strong class="source-inline">equals(a1,</strong> <strong class="source-inline">a2)</strong> and <strong class="source-inline">deepEquals(a1, a2)</strong> methods allow a comparison of not just <strong class="source-inline">a1</strong> and <strong class="source-inline">a2</strong> references, but use the <strong class="source-inline">equals()</strong> method to compare elements as well. Here is <a id="_idIndexMarker788"/>a code <a id="_idIndexMarker789"/>example to demonstrate how these methods work:</p>
			<pre class="source-code">String[] arr1 = {"s1", "s2"};</pre>
			<pre class="source-code">String[] arr2 = {"s1", "s2"};</pre>
			<pre class="source-code">System.out.println(arr1.equals(arr2));   //prints: false</pre>
			<pre class="source-code">System.out.println(Arrays.equals(arr1, arr2));     </pre>
			<pre class="source-code">                                         //prints: true</pre>
			<pre class="source-code">System.out.println(Arrays.deepEquals(arr1, arr2));  </pre>
			<pre class="source-code">                                         //prints: true</pre>
			<pre class="source-code">String[][] arr3 = {{"s1", "s2"}};</pre>
			<pre class="source-code">String[][] arr4 = {{"s1", "s2"}};</pre>
			<pre class="source-code">System.out.println(arr3.equals(arr4));   //prints: false</pre>
			<pre class="source-code">System.out.println(Arrays.equals(arr3, arr4));     </pre>
			<pre class="source-code">                                         //prints: false</pre>
			<pre class="source-code">System.out.println(Arrays.deepEquals(arr3, arr4));</pre>
			<pre class="source-code">                                         //prints: true</pre>
			<p>As you can see, <strong class="source-inline">Arrays.deepEquals()</strong> returns <strong class="source-inline">true</strong> every time two equal arrays are compared when every element of one array equals the element of another array in the same <a id="_idIndexMarker790"/>position, while the <strong class="source-inline">Arrays.equals()</strong> method<a id="_idIndexMarker791"/> does the same, but for <strong class="bold">one-dimensional</strong> (<strong class="bold">1D</strong>) arrays <a id="_idIndexMarker792"/>only.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>ArrayUtils class</h2>
			<p>The <strong class="source-inline">org.apache.commons.lang3.ArrayUtils</strong> class complements the <strong class="source-inline">java.util.Arrays</strong> class <a id="_idIndexMarker793"/>by adding new methods to the array <a id="_idIndexMarker794"/>managing the toolkit and the ability to handle <strong class="source-inline">null</strong> in cases when, otherwise, <strong class="source-inline">NullPointerException</strong> could be thrown. To use this class, you would need to add the following dependency to the Maven <strong class="source-inline">pom.xml</strong> configuration file:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</pre>
			<pre class="source-code">   &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</pre>
			<pre class="source-code">   &lt;version&gt;3.12.0&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>The <strong class="source-inline">ArrayUtils</strong> class has around 300 overloaded methods that can be collected in the following 12 groups:</p>
			<ul>
				<li><strong class="source-inline">add()</strong>, <strong class="source-inline">addAll()</strong>, and <strong class="source-inline">insert()</strong>: These add elements to an array.</li>
				<li><strong class="source-inline">clone()</strong>: This clones an array, similar to the <strong class="source-inline">copyOf()</strong> method of the <strong class="source-inline">Arrays</strong> class and the <strong class="source-inline">arraycopy()</strong> method of <strong class="source-inline">java.lang.System.</strong></li>
				<li><strong class="source-inline">getLength()</strong>: This returns an array length or <strong class="source-inline">0</strong> when the array itself is <strong class="source-inline">null.</strong></li>
				<li><strong class="source-inline">hashCode()</strong>: This calculates the hash value of an array, including nested arrays.</li>
				<li><strong class="source-inline">contains()</strong>, <strong class="source-inline">indexOf()</strong>, and <strong class="source-inline">lastIndexOf()</strong>: These search an array.</li>
				<li><strong class="source-inline">isSorted()</strong>, <strong class="source-inline">isEmpty</strong>, and <strong class="source-inline">isNotEmpty()</strong>: These check an array and handle <strong class="source-inline">null.</strong></li>
				<li><strong class="source-inline">isSameLength()</strong> and <strong class="source-inline">isSameType()</strong>: These compare arrays.</li>
				<li><strong class="source-inline">nullToEmpty()</strong>: This converts a <strong class="source-inline">null</strong> array to an empty one.</li>
				<li><strong class="source-inline">remove()</strong>, <strong class="source-inline">removeAll()</strong>, <strong class="source-inline">removeElement()</strong>, <strong class="source-inline">removeElements()</strong>, and <strong class="source-inline">removeAllOccurances()</strong>: These remove certain or all elements.</li>
				<li><strong class="source-inline">reverse()</strong>, <strong class="source-inline">shift()</strong>, <strong class="source-inline">shuffle()</strong>, and <strong class="source-inline">swap()</strong>: These change the order of array elements.</li>
				<li><strong class="source-inline">subarray()</strong>: This extracts part of an array according to a range of indices.</li>
				<li><strong class="source-inline">toMap()</strong>, <strong class="source-inline">toObject()</strong>, <strong class="source-inline">toPrimitive()</strong>, <strong class="source-inline">toString()</strong>, and <strong class="source-inline">toStringArray()</strong>: These <a id="_idIndexMarker795"/>convert <a id="_idIndexMarker796"/>an array to another type and handle <strong class="source-inline">null</strong> values.</li>
			</ul>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Objects utilities</h1>
			<p>The following <a id="_idIndexMarker797"/>two utilities are described in this section:</p>
			<ul>
				<li><strong class="source-inline">java.util.Objects</strong></li>
				<li><strong class="source-inline">org.apache.commons.lang3.ObjectUtils</strong></li>
			</ul>
			<p>They are especially useful during class creation, so we will concentrate largely on methods related to this task.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>java.util.Objects class</h2>
			<p>The <strong class="source-inline">Objects</strong> class has<a id="_idIndexMarker798"/> only 17 methods that are all <a id="_idIndexMarker799"/>static. Let’s look at some of them while applying them to the <strong class="source-inline">Person</strong> class. Let’s assume this class will be an element of a collection, which means it has to implement the <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods. The code is<a id="_idIndexMarker800"/> illustrated<a id="_idIndexMarker801"/> in the following snippet:</p>
			<pre class="source-code">class Person {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge(){ return this.age; }</pre>
			<pre class="source-code">    public String getName(){ return this.name; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public boolean equals(Object o) {</pre>
			<pre class="source-code">        if (this == o) return true;</pre>
			<pre class="source-code">        if (o == null) return false;</pre>
			<pre class="source-code">        if(!(o instanceof Person)) return false;</pre>
			<pre class="source-code">        Person = (Person)o;</pre>
			<pre class="source-code">        return age == person.getAge() &amp;&amp;</pre>
			<pre class="source-code">                Objects.equals(name, person.getName()); </pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public int hashCode(){</pre>
			<pre class="source-code">        return Objects.hash(age, name);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Notice that we do not check the <strong class="source-inline">name</strong> property for <strong class="source-inline">null</strong> because <strong class="source-inline">Object.equals()</strong> does not break when any of the parameters is <strong class="source-inline">null</strong>. It just does the job of comparing objects. If only one of them is <strong class="source-inline">null</strong>, it returns <strong class="source-inline">false</strong>. If both are <strong class="source-inline">null</strong>, it returns <strong class="source-inline">true</strong>.</p>
			<p>Using <strong class="source-inline">Object.equals()</strong> is a safe way to implement the <strong class="source-inline">equals()</strong> method; however, if you need to compare objects that may be arrays, it is better to use the <strong class="source-inline">Objects.deepEquals()</strong> method because it not only handles <strong class="source-inline">null</strong>, as the <strong class="source-inline">Object.equals()</strong> method does, but also compares values of all<a id="_idIndexMarker802"/> array elements, even if the array is <a id="_idIndexMarker803"/>multidimensional, as illustrated here:</p>
			<pre class="source-code">String[][] x1 = {{"a","b"},{"x","y"}};</pre>
			<pre class="source-code">String[][] x2 = {{"a","b"},{"x","y"}};</pre>
			<pre class="source-code">String[][] y =  {{"a","b"},{"y","y"}};</pre>
			<pre class="source-code">System.out.println(Objects.equals(x1, x2));</pre>
			<pre class="source-code">                                       //prints: false</pre>
			<pre class="source-code">System.out.println(Objects.equals(x1, y));  </pre>
			<pre class="source-code">                                       //prints: false</pre>
			<pre class="source-code">System.out.println(Objects.deepEquals(x1, x2));</pre>
			<pre class="source-code">                                       //prints: true</pre>
			<pre class="source-code">System.out.println(Objects.deepEquals(x1, y));</pre>
			<pre class="source-code">                                      //prints: false</pre>
			<p>The <strong class="source-inline">Objects.hash()</strong> method handles <strong class="source-inline">null</strong> values too. One important thing to remember is that the list of properties compared in the <strong class="source-inline">equals()</strong> method has to match the list of properties passed into <strong class="source-inline">Objects.hash()</strong> as parameters. Otherwise, two equal <strong class="source-inline">Person</strong> objects will have different hash values, which makes hash-based collections work incorrectly.</p>
			<p>Another thing worth noticing is that there is another hash-related <strong class="source-inline">Objects.hashCode()</strong> method that accepts only one parameter, but the value it generates is not equal to the value generated by <strong class="source-inline">Objects.hash()</strong> with only one parameter. Observe the following, for example:</p>
			<pre class="source-code">System.out.println(Objects.hash(42) ==</pre>
			<pre class="source-code">               Objects.hashCode(42));    //prints: false</pre>
			<pre class="source-code">System.out.println(Objects.hash("abc") ==</pre>
			<pre class="source-code">               Objects.hashCode("abc")); //prints: false</pre>
			<p>To avoid this caveat, always use <strong class="source-inline">Objects.hash()</strong>.</p>
			<p>Another potential source of confusion is demonstrated in the following code snippet:</p>
			<pre class="source-code">System.out.println(Objects.hash(null));      //prints: 0</pre>
			<pre class="source-code">System.out.println(Objects.hashCode(null));  //prints: 0</pre>
			<pre class="source-code">System.out.println(Objects.hash(0));         //prints: 31</pre>
			<pre class="source-code">System.out.println(Objects.hashCode(0));     //prints: 0</pre>
			<p>As you can see, the <strong class="source-inline">Objects.hashCode()</strong> method generates the same hash value for <strong class="source-inline">null</strong> and <strong class="source-inline">0</strong>, which<a id="_idIndexMarker804"/> can be problematic for some <a id="_idIndexMarker805"/>algorithms based on the hash value.</p>
			<p><strong class="source-inline">static &lt;T&gt; int compare (T a, T b, Comparator&lt;T&gt; c)</strong> is another popular method that returns <strong class="source-inline">0</strong> (if the arguments are equal); otherwise, it returns the result of <strong class="source-inline">c.compare(a, b)</strong>. It is very useful for implementing the <strong class="source-inline">Comparable</strong> interface (establishing a natural order for custom object sorting). Observe the following, for example:</p>
			<pre class="source-code">class Person implements Comparable&lt;Person&gt; {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge(){ return this.age; }</pre>
			<pre class="source-code">    public String getName(){ return this.name; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public int compareTo(Person p){</pre>
			<pre class="source-code">        int result = Objects.compare(name, p.getName(),</pre>
			<pre class="source-code">                                    Comparator.naturalOrder());</pre>
			<pre class="source-code">        if (result != 0) { </pre>
			<pre class="source-code">           return result;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return Objects.compare(age, p.getAge(),</pre>
			<pre class="source-code">                                    Comparator.naturalOrder());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This way, you <a id="_idIndexMarker806"/>can easily change the sorting algorithm by <a id="_idIndexMarker807"/>setting the <strong class="source-inline">Comparator.reverseOrder()</strong> value or by adding <strong class="source-inline">Comparator.nullFirst()</strong> or <strong class="source-inline">Comparator.nullLast()</strong>.</p>
			<p>Also, the <strong class="source-inline">Comparator</strong> implementation we used in the previous section can be made more flexible by using the <strong class="source-inline">Objects.compare()</strong> method, as follows:</p>
			<pre class="source-code">class ComparePersons implements Comparator&lt;Person&gt; {</pre>
			<pre class="source-code">    public int compare(Person p1, Person p2){</pre>
			<pre class="source-code">        int result = Objects.compare(p1.getName(),</pre>
			<pre class="source-code">           p2.getName(), Comparator.naturalOrder());</pre>
			<pre class="source-code">        if (result != 0) { </pre>
			<pre class="source-code">           return result;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return Objects.compare(p1.getAge(), p2.getAge(),</pre>
			<pre class="source-code">                              Comparator.naturalOrder());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Finally, the last two methods of the <strong class="source-inline">Objects</strong> class that we are going to discuss are methods that generate a string representation of an object. They come in handy when you need to call a <strong class="source-inline">toString()</strong> method on an object but are not sure whether the object reference is <strong class="source-inline">null</strong>. Observe the following, for example:</p>
			<pre class="source-code">List&lt;String&gt; list = Arrays.asList("s1", null);</pre>
			<pre class="source-code">for(String e: list){</pre>
			<pre class="source-code">    //String s = e.toString();  //NullPointerException</pre>
			<pre class="source-code">}</pre>
			<p>In the<a id="_idIndexMarker808"/> preceding <a id="_idIndexMarker809"/>example, we know the exact value of each element; however, imagine a scenario where the list is passed into the method as a parameter. Then, we are forced to write something like this:</p>
			<pre class="source-code">void someMethod(List&lt;String&gt; list){</pre>
			<pre class="source-code">    for(String e: list){</pre>
			<pre class="source-code">        String s = e == null ? "null" : e.toString();</pre>
			<pre class="source-code">    }</pre>
			<p>This doesn’t seem to be a big deal. But after writing such code a dozen times, a programmer naturally thinks about some kind of utility method that does all of that, and that is when the following two methods of the <strong class="source-inline">Objects</strong> class help:</p>
			<ul>
				<li><strong class="source-inline">static String toString(Object o)</strong>: This returns the result of calling <strong class="source-inline">toString()</strong> on the parameter when it is not <strong class="source-inline">null</strong> and returns <strong class="source-inline">null</strong> when the parameter value is <strong class="source-inline">null</strong>.</li>
				<li><strong class="source-inline">static String toString(Object o, String nullDefault)</strong>: This returns the result of calling <strong class="source-inline">toString()</strong> on the first parameter when it is not <strong class="source-inline">null</strong> and returns the second <strong class="source-inline">nullDefault</strong> parameter value when the first parameter value is <strong class="source-inline">null</strong>.</li>
			</ul>
			<p>The following code snippet demonstrates these two methods:</p>
			<pre class="source-code">List&lt;String&gt; list = Arrays.asList("s1", null);</pre>
			<pre class="source-code">for(String e: list){</pre>
			<pre class="source-code">    String s = Objects.toString(e);</pre>
			<pre class="source-code">    System.out.print(s + " ");          //prints: s1 null</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">for(String e: list){</pre>
			<pre class="source-code">    String s = Objects.toString(e, "element was null");</pre>
			<pre class="source-code">    System.out.print(s + " ");        </pre>
			<pre class="source-code">                                  //prints: s1 element was null</pre>
			<pre class="source-code">}</pre>
			<p>As of the time of <a id="_idIndexMarker810"/>writing, the <strong class="source-inline">Objects</strong> class has 17 methods. We recommend you become<a id="_idIndexMarker811"/> familiar with them so as to avoid writing your own utilities in the event that the same utility already exists. </p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>ObjectUtils class</h2>
			<p>The last <a id="_idIndexMarker812"/>statement<a id="_idIndexMarker813"/> of the previous section applies to the <strong class="source-inline">org.apache.commons.lang3.ObjectUtils</strong> class of the <strong class="source-inline">Apache Commons</strong> library that complements the methods of the <strong class="source-inline">java.util.Objects</strong> class described in the preceding section. The scope of this book and its allotted size does not allow for a detailed review of all the methods under the <strong class="source-inline">ObjectUtils</strong> class, so we will describe them briefly in groups according to their related functionality. To use this class, you would need to add the following dependency to the Maven <strong class="source-inline">pom.xml</strong> configuration file:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;3.12.0&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>All the<a id="_idIndexMarker814"/> methods<a id="_idIndexMarker815"/> of the <strong class="source-inline">ObjectUtils</strong> class can be organized into seven groups, as follows:</p>
			<ul>
				<li>Object cloning methods</li>
				<li>Methods that support a comparison of two objects</li>
				<li>The <strong class="source-inline">notEqual()</strong> method, which compares two objects for inequality, where either one or both objects may be <strong class="source-inline">null</strong></li>
				<li>Several <strong class="source-inline">identityToString()</strong> methods that generate a <strong class="source-inline">String</strong> representation of the provided object as if produced by <strong class="source-inline">toString()</strong>, which is a default method of the <strong class="source-inline">Object</strong> base class and, optionally, append it to another object</li>
				<li>The <strong class="source-inline">allNotNull()</strong> and <strong class="source-inline">anyNotNull()</strong> methods, which analyze an array of objects for <strong class="source-inline">null</strong></li>
				<li>The <strong class="source-inline">firstNonNull()</strong> and <strong class="source-inline">defaultIfNull()</strong> methods, which analyze an array of objects and return the first not-<strong class="source-inline">null</strong> object or default value</li>
				<li>The <strong class="source-inline">max()</strong>, <strong class="source-inline">min()</strong>, <strong class="source-inline">median()</strong>, and <strong class="source-inline">mode()</strong> methods, which analyze an array of <a id="_idIndexMarker816"/>objects and return the one that corresponds to <a id="_idIndexMarker817"/>the method name</li>
			</ul>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>The java.time package</h1>
			<p>There are many <a id="_idIndexMarker818"/>classes in the <strong class="source-inline">java.time</strong> package and its sub-packages. They were introduced as a replacement for other (older packages) that handled date and time. The new classes are thread-safe (hence, better suited for multithreaded processing), and what is also important is that they are more consistently designed and easier to understand. Also, the new implementation follows <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO</strong>) standards<a id="_idIndexMarker819"/> as regards date and time formats, but allows any other custom format to be used as well.</p>
			<p>We will describe the following five main classes and demonstrate how to use them:</p>
			<ul>
				<li><strong class="source-inline">java.time.LocalDate</strong></li>
				<li><strong class="source-inline">java.time.LocalTime</strong></li>
				<li><strong class="source-inline">java.time.LocalDateTime</strong></li>
				<li><strong class="source-inline">java.time.Period</strong></li>
				<li><strong class="source-inline">java.time.Duration</strong></li>
			</ul>
			<p>All these and other classes of the <strong class="source-inline">java.time</strong> package, as well as its sub-packages, are rich in various functionality that covers all practical cases. But we are not going to discuss all of them; we will just introduce the basics and the most popular use cases.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>LocalDate class</h2>
			<p>The <strong class="source-inline">LocalDate</strong> class<a id="_idIndexMarker820"/> does not carry time. It represents a <a id="_idIndexMarker821"/>date in <em class="italic">ISO 8601</em> format (<strong class="source-inline">yyyy-MM-dd</strong>) and is shown in the following code snippet:</p>
			<pre class="source-code">System.out.println(LocalDate.now()); </pre>
			<pre class="source-code">                    //prints: current date in format yyyy-MM-dd</pre>
			<p>That is the current date in this location at the time of writing. The value was picked up from the computer clock. Similarly, you can get the current date in any other time zone using that static <strong class="source-inline">now(ZoneId zone)</strong> method. A <strong class="source-inline">ZoneId</strong> object can be constructed using the static <strong class="source-inline">ZoneId.of(String zoneId)</strong> method, where <strong class="source-inline">String zoneId</strong> is any of the string values returned by the <strong class="source-inline">ZoneId.getAvailableZoneIds()</strong> method, as illustrated in the following code snippet:</p>
			<pre class="source-code">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</pre>
			<pre class="source-code">for(String zoneId: zoneIds){</pre>
			<pre class="source-code">    System.out.println(zoneId);</pre>
			<pre class="source-code">}</pre>
			<p>The preceding<a id="_idIndexMarker822"/> code<a id="_idIndexMarker823"/> prints almost 600 time zone <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>). Here are a few of them:</p>
			<pre class="source-code">Asia/Aden</pre>
			<pre class="source-code">Etc/GMT+9</pre>
			<pre class="source-code">Africa/Nairobi</pre>
			<pre class="source-code">America/Marigot</pre>
			<pre class="source-code">Pacific/Honolulu</pre>
			<pre class="source-code">Australia/Hobart</pre>
			<pre class="source-code">Europe/London</pre>
			<pre class="source-code">America/Indiana/Petersburg</pre>
			<pre class="source-code">Asia/Yerevan</pre>
			<pre class="source-code">Europe/Brussels</pre>
			<pre class="source-code">GMT</pre>
			<pre class="source-code">Chile/Continental</pre>
			<pre class="source-code">Pacific/Yap</pre>
			<pre class="source-code">CET</pre>
			<pre class="source-code">Etc/GMT-1</pre>
			<pre class="source-code">Canada/Yukon</pre>
			<pre class="source-code">Atlantic/St_Helena</pre>
			<pre class="source-code">Libya</pre>
			<pre class="source-code">US/Pacific-New</pre>
			<pre class="source-code">Cuba</pre>
			<pre class="source-code">Israel</pre>
			<pre class="source-code">GB-Eire</pre>
			<pre class="source-code">GB</pre>
			<pre class="source-code">Mexico/General</pre>
			<pre class="source-code">Universal</pre>
			<pre class="source-code">Zulu</pre>
			<pre class="source-code">Iran</pre>
			<pre class="source-code">Navajo</pre>
			<pre class="source-code">Egypt</pre>
			<pre class="source-code">Etc/UTC</pre>
			<pre class="source-code">SystemV/AST4ADT</pre>
			<pre class="source-code">Asia/Tokyo</pre>
			<p>Let’s try<a id="_idIndexMarker824"/> to <a id="_idIndexMarker825"/>use <strong class="source-inline">"Asia/Tokyo"</strong>, for example, as follows:</p>
			<pre class="source-code">ZoneId = ZoneId.of("Asia/Tokyo");</pre>
			<pre class="source-code">System.out.println(LocalDate.now(zoneId)); </pre>
			<pre class="source-code">           //prints: current date in Tokyo in format yyyy-MM-dd</pre>
			<p>A <strong class="source-inline">LocalDate</strong> object can represent any date in the past, or in the future too, using the following methods:</p>
			<ul>
				<li><strong class="source-inline">LocalDate parse(CharSequence text)</strong>: This constructs an object from a string in <em class="italic">ISO 8601</em> format (<strong class="source-inline">yyyy-MM-dd</strong>).</li>
				<li><strong class="source-inline">LocalDate parse(CharSequence text, DateTimeFormatter formatter)</strong>: This constructs an object from a string in a format specified by the <strong class="source-inline">DateTimeFormatter</strong> object that has a rich system of patterns and many predefined <a id="_idIndexMarker826"/>formats <a id="_idIndexMarker827"/>as well—here are a few of them:<ul><li><strong class="source-inline">BASIC_ISO_DATE</strong>—for example, <strong class="source-inline">20111203</strong></li><li><strong class="source-inline">ISO_LOCAL_DATE ISO</strong>—for example, <strong class="source-inline">2011-12-03</strong></li><li><strong class="source-inline">ISO_OFFSET_DATE</strong>—for example, <strong class="source-inline">2011-12-03+01:00</strong></li><li><strong class="source-inline">ISO_DATE</strong>—for example, <strong class="source-inline">2011-12-03+01:00; 2011-12-03</strong></li><li><strong class="source-inline">ISO_LOCAL_TIME</strong>—for example, <strong class="source-inline">10:15:30</strong></li><li><strong class="source-inline">ISO_OFFSET_TIME</strong>—for example, <strong class="source-inline">10:15:30+01:00</strong></li><li><strong class="source-inline">ISO_TIME</strong>—for example, <strong class="source-inline">10:15:30+01:00; 10:15:30</strong></li><li><strong class="source-inline">ISO_LOCAL_DATE_TIME</strong>—for example, <strong class="source-inline">2011-12-03T10:15:30</strong></li></ul></li>
				<li><strong class="source-inline">LocalDate of(int year, int month, int dayOfMonth)</strong>: This constructs an object from a year, month, and day.</li>
				<li><strong class="source-inline">LocalDate of(int year, Month, int dayOfMonth)</strong>: This constructs an object from a year, month (enum constant), and day.</li>
				<li><strong class="source-inline">LocalDate ofYearDay(int year, int dayOfYear)</strong>: This constructs an object from a year and day-of-year.</li>
			</ul>
			<p>The following code snippet demonstrates the methods listed in the preceding bullets:</p>
			<pre class="source-code">LocalDate lc1 = LocalDate.parse("2023-02-23");</pre>
			<pre class="source-code">System.out.println(lc1);           //prints: 2023-02-23</pre>
			<pre class="source-code">LocalDate lc2 = LocalDate.parse("20230223",</pre>
			<pre class="source-code">                     DateTimeFormatter.BASIC_ISO_DATE);</pre>
			<pre class="source-code">System.out.println(lc2);           //prints: 2023-02-23</pre>
			<pre class="source-code">DateTimeFormatter frm =</pre>
			<pre class="source-code">              DateTimeFormatter.ofPattern("dd/MM/yyyy");</pre>
			<pre class="source-code">LocalDate lc3 =  LocalDate.parse("23/02/2023", frm);</pre>
			<pre class="source-code">System.out.println(lc3);           //prints: 2023-02-23</pre>
			<pre class="source-code">LocalDate lc4 =  LocalDate.of(2023, 2, 23);</pre>
			<pre class="source-code">System.out.println(lc4);           //prints: 2023-02-23</pre>
			<pre class="source-code">LocalDate lc5 =  LocalDate.of(2023, Month.FEBRUARY, 23);</pre>
			<pre class="source-code">System.out.println(lc5);           //prints: 2023-02-23</pre>
			<pre class="source-code">LocalDate lc6 = LocalDate.ofYearDay(2023, 54);</pre>
			<pre class="source-code">System.out.println(lc6);           //prints: 2023-02-23</pre>
			<p>A <strong class="source-inline">LocalDate</strong> object <a id="_idIndexMarker828"/>can provide various values, as <a id="_idIndexMarker829"/>illustrated in the following code snippet:</p>
			<pre class="source-code">LocalDate lc = LocalDate.parse("2023-02-23");</pre>
			<pre class="source-code">System.out.println(lc);                  //prints: 2023-02-23</pre>
			<pre class="source-code">System.out.println(lc.getYear());        //prints: 2023</pre>
			<pre class="source-code">System.out.println(lc.getMonth());       //prints: FEBRUARY</pre>
			<pre class="source-code">System.out.println(lc.getMonthValue());  //prints: 2</pre>
			<pre class="source-code">System.out.println(lc.getDayOfMonth());  //prints: 23</pre>
			<pre class="source-code">System.out.println(lc.getDayOfWeek());   //prints: THURSDAY</pre>
			<pre class="source-code">System.out.println(lc.isLeapYear());     //prints: false</pre>
			<pre class="source-code">System.out.println(lc.lengthOfMonth());  //prints: 28</pre>
			<pre class="source-code">System.out.println(lc.lengthOfYear());   //prints: 365</pre>
			<p>A <strong class="source-inline">LocalDate</strong> object<a id="_idIndexMarker830"/> can <a id="_idIndexMarker831"/>be modified, like this:</p>
			<pre class="source-code">LocalDate lc = LocalDate.parse("2023-02-23");</pre>
			<pre class="source-code">System.out.println(lc.withYear(2024));     //prints: 2024-02-23</pre>
			<pre class="source-code">System.out.println(lc.withMonth(5));       //prints: 2023-05-23</pre>
			<pre class="source-code">System.out.println(lc.withDayOfMonth(5));  //prints: 2023-02-05</pre>
			<pre class="source-code">System.out.println(lc.withDayOfYear(53));  //prints: 2023-02-22</pre>
			<pre class="source-code">System.out.println(lc.plusDays(10));       //prints: 2023-03-05</pre>
			<pre class="source-code">System.out.println(lc.plusMonths(2));      //prints: 2023-04-23</pre>
			<pre class="source-code">System.out.println(lc.plusYears(2));       //prints: 2025-02-23</pre>
			<pre class="source-code">System.out.println(lc.minusDays(10));      //prints: 2023-02-13</pre>
			<pre class="source-code">System.out.println(lc.minusMonths(2));     //prints: 2022-12-23</pre>
			<pre class="source-code">System.out.println(lc.minusYears(2));      //prints: 2021-02-23</pre>
			<p>A <strong class="source-inline">LocalDate</strong> object can be compared, like this:</p>
			<pre class="source-code">LocalDate lc1 = LocalDate.parse("2023-02-23");</pre>
			<pre class="source-code">LocalDate lc2 = LocalDate.parse("2023-02-22");</pre>
			<pre class="source-code">System.out.println(lc1.isAfter(lc2));       //prints: true</pre>
			<pre class="source-code">System.out.println(lc1.isBefore(lc2));      //prints: false</pre>
			<p>There are<a id="_idIndexMarker832"/> many<a id="_idIndexMarker833"/> other helpful methods in the <strong class="source-inline">LocalDate</strong> class. If you have to work with dates, we recommend that you <a id="_idIndexMarker834"/>read the <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) of this class and other classes of the <strong class="source-inline">java.time</strong> package and its sub-packages.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>LocalTime class</h2>
			<p>The <strong class="source-inline">LocalTime</strong> class <a id="_idIndexMarker835"/>contains time without a date. It has similar<a id="_idIndexMarker836"/> methods to the methods of the <strong class="source-inline">LocalDate</strong> class. Here is how an object of the <strong class="source-inline">LocalTime</strong> class can be created:</p>
			<pre class="source-code">System.out.println(LocalTime.now()); //prints: 21:15:46.360904</pre>
			<pre class="source-code">ZoneId = ZoneId.of("Asia/Tokyo");</pre>
			<pre class="source-code">System.out.println(LocalTime.now(zoneId)); </pre>
			<pre class="source-code">                                     //prints: 12:15:46.364378</pre>
			<pre class="source-code">LocalTime lt1 =  LocalTime.parse("20:23:12");</pre>
			<pre class="source-code">System.out.println(lt1);                     //prints: 20:23:12</pre>
			<pre class="source-code">LocalTime lt2 = LocalTime.of(20, 23, 12);</pre>
			<pre class="source-code">System.out.println(lt2);                     //prints: 20:23:12</pre>
			<p>Each component of time value can be extracted from a <strong class="source-inline">LocalTime</strong> object, as follows:</p>
			<pre class="source-code">LocalTime lt2 =  LocalTime.of(20, 23, 12);</pre>
			<pre class="source-code">System.out.println(lt2);                     //prints: 20:23:12</pre>
			<pre class="source-code">System.out.println(lt2.getHour());           //prints: 20</pre>
			<pre class="source-code">System.out.println(lt2.getMinute());         //prints: 23</pre>
			<pre class="source-code">System.out.println(lt2.getSecond());         //prints: 12</pre>
			<pre class="source-code">System.out.println(lt2.getNano());           //prints: 0</pre>
			<p>An <a id="_idIndexMarker837"/>object<a id="_idIndexMarker838"/> of the <strong class="source-inline">LocalTime</strong> class can be modified, as follows:</p>
			<pre class="source-code">LocalTime lt2 = LocalTime.of(20, 23, 12);</pre>
			<pre class="source-code">System.out.println(lt2.withHour(3));      //prints: 03:23:12</pre>
			<pre class="source-code">System.out.println(lt2.withMinute(10));   //prints: 20:10:12</pre>
			<pre class="source-code">System.out.println(lt2.withSecond(15));   //prints: 20:23:15</pre>
			<pre class="source-code">System.out.println(lt2.withNano(300)); </pre>
			<pre class="source-code">                                   //prints: 20:23:12.000000300</pre>
			<pre class="source-code">System.out.println(lt2.plusHours(10));    //prints: 06:23:12</pre>
			<pre class="source-code">System.out.println(lt2.plusMinutes(2));   //prints: 20:25:12</pre>
			<pre class="source-code">System.out.println(lt2.plusSeconds(2));   //prints: 20:23:14</pre>
			<pre class="source-code">System.out.println(lt2.plusNanos(200));</pre>
			<pre class="source-code">                                   //prints: 20:23:12.000000200</pre>
			<pre class="source-code">System.out.println(lt2.minusHours(10));   //prints: 10:23:12</pre>
			<pre class="source-code">System.out.println(lt2.minusMinutes(2));  //prints: 20:21:12</pre>
			<pre class="source-code">System.out.println(lt2.minusSeconds(2));  //prints: 20:23:10</pre>
			<pre class="source-code">System.out.println(lt2.minusNanos(200));</pre>
			<pre class="source-code">                                   //prints: 20:23:11.999999800</pre>
			<p>And two objects of the <strong class="source-inline">LocalTime</strong> class can also be compared, as follows:</p>
			<pre class="source-code">LocalTime lt2 =  LocalTime.of(20, 23, 12);</pre>
			<pre class="source-code">LocalTime lt4 =  LocalTime.parse("20:25:12");</pre>
			<pre class="source-code">System.out.println(lt2.isAfter(lt4));       //prints: false</pre>
			<pre class="source-code">System.out.println(lt2.isBefore(lt4));      //prints: true</pre>
			<p>There are <a id="_idIndexMarker839"/>many other helpful methods in the <strong class="source-inline">LocalTime</strong> class. If you<a id="_idIndexMarker840"/> have to work with dates, we recommend that you read the API of this class and other classes of the <strong class="source-inline">java.time</strong> package and its sub-packages.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>LocalDateTime class</h2>
			<p>The <strong class="source-inline">LocalDateTime</strong> class<a id="_idIndexMarker841"/> contains <a id="_idIndexMarker842"/>both the date and time and has all the methods the <strong class="source-inline">LocalDate</strong> and <strong class="source-inline">LocalTime</strong> classes have, so we are not going to repeat them here. We will only show how an object of the <strong class="source-inline">LocalDateTime</strong> class can be created, as follows:</p>
			<pre class="source-code">System.out.println(LocalDateTime.now());       </pre>
			<pre class="source-code">                     //prints: 2019-03-04T21:59:00.142804</pre>
			<pre class="source-code">ZoneId = ZoneId.of("Asia/Tokyo");</pre>
			<pre class="source-code">System.out.println(LocalDateTime.now(zoneId)); </pre>
			<pre class="source-code">                    //prints: 2019-03-05T12:59:00.146038</pre>
			<pre class="source-code">LocalDateTime ldt1 = </pre>
			<pre class="source-code">           LocalDateTime.parse("2020-02-23T20:23:12");</pre>
			<pre class="source-code">System.out.println(ldt1);  //prints: 2020-02-23T20:23:12</pre>
			<pre class="source-code">DateTimeFormatter formatter =</pre>
			<pre class="source-code">     DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");</pre>
			<pre class="source-code">LocalDateTime ldt2 =</pre>
			<pre class="source-code">  LocalDateTime.parse("23/02/2020 20:23:12", formatter);</pre>
			<pre class="source-code">System.out.println(ldt2);  //prints: 2020-02-23T20:23:12</pre>
			<pre class="source-code">LocalDateTime ldt3 = </pre>
			<pre class="source-code">               LocalDateTime.of(2020, 2, 23, 20, 23, 12);</pre>
			<pre class="source-code">System.out.println(ldt3);  //prints: 2020-02-23T20:23:12</pre>
			<pre class="source-code">LocalDateTime ldt4 =</pre>
			<pre class="source-code">  LocalDateTime.of(2020, Month.FEBRUARY, 23, 20, 23, 12);</pre>
			<pre class="source-code">System.out.println(ldt4);  //prints: 2020-02-23T20:23:12</pre>
			<pre class="source-code">LocalDate ld = LocalDate.of(2020, 2, 23);</pre>
			<pre class="source-code">LocalTime lt = LocalTime.of(20, 23, 12);</pre>
			<pre class="source-code">LocalDateTime ldt5 = LocalDateTime.of(ld, lt);</pre>
			<pre class="source-code">System.out.println(ldt5); //prints: 2020-02-23T20:23:12</pre>
			<p>There are many other helpful methods in the <strong class="source-inline">LocalDateTime</strong> class. If you have to work with<a id="_idIndexMarker843"/> dates, we recommend that you read the API of this<a id="_idIndexMarker844"/> class and other classes of the <strong class="source-inline">java.time</strong> package and its sub-packages.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Period and Duration classes</h2>
			<p>The <strong class="source-inline">java.time.Period</strong> and <strong class="source-inline">java.time.Duration</strong> classes are designed to contain<a id="_idIndexMarker845"/> an amount <a id="_idIndexMarker846"/>of <a id="_idIndexMarker847"/>time, as<a id="_idIndexMarker848"/> outlined here:</p>
			<ul>
				<li>A <strong class="source-inline">Period</strong> object contains an amount of time in units of years, months, and days.</li>
				<li>A <strong class="source-inline">Duration</strong> object contains an amount of time in hours, minutes, seconds, and nanoseconds.</li>
			</ul>
			<p>The following code snippet demonstrates their creation and usage using the <strong class="source-inline">LocalDateTime</strong> class, but the same methods exist in the <strong class="source-inline">LocalDate</strong> (for <strong class="source-inline">Period</strong>) and <strong class="source-inline">LocalTime</strong> (for <strong class="source-inline">Duration</strong>) classes:</p>
			<pre class="source-code">LocalDateTime ldt1 = LocalDateTime.parse("2023-02-23T20:23:12");</pre>
			<pre class="source-code">LocalDateTime ldt2 = ldt1.plus(Period.ofYears(2));</pre>
			<pre class="source-code">System.out.println(ldt2);      //prints: 2025-02-23T20:23:12</pre>
			<p>The following methods work the same way as the methods of the <strong class="source-inline">LocalTime</strong> class:</p>
			<pre class="source-code">LocalDateTime ldt = LocalDateTime.parse("2023-02-23T20:23:12");</pre>
			<pre class="source-code">ldt.minus(Period.ofYears(2));</pre>
			<pre class="source-code">ldt.plus(Period.ofMonths(2));</pre>
			<pre class="source-code">ldt.minus(Period.ofMonths(2));</pre>
			<pre class="source-code">ldt.plus(Period.ofWeeks(2));</pre>
			<pre class="source-code">ldt.minus(Period.ofWeeks(2));</pre>
			<pre class="source-code">ldt.plus(Period.ofDays(2));</pre>
			<pre class="source-code">ldt.minus(Period.ofDays(2));</pre>
			<pre class="source-code">ldt.plus(Duration.ofHours(2));</pre>
			<pre class="source-code">ldt.minus(Duration.ofHours(2));</pre>
			<pre class="source-code">ldt.plus(Duration.ofMinutes(2));</pre>
			<pre class="source-code">ldt.minus(Duration.ofMinutes(2));</pre>
			<pre class="source-code">ldt.plus(Duration.ofMillis(2));</pre>
			<pre class="source-code">ldt.minus(Duration.ofMillis(2));</pre>
			<p>Some <a id="_idIndexMarker849"/>other <a id="_idIndexMarker850"/>methods<a id="_idIndexMarker851"/> of <a id="_idIndexMarker852"/>creating and using <strong class="source-inline">Period</strong> objects are demonstrated in the following code snippet:</p>
			<pre class="source-code">LocalDate ld1 =  LocalDate.parse("2023-02-23");</pre>
			<pre class="source-code">LocalDate ld2 =  LocalDate.parse("2023-03-25");</pre>
			<pre class="source-code">Period = Period.between(ld1, ld2);</pre>
			<pre class="source-code">System.out.println(period.getDays());       //prints: 2</pre>
			<pre class="source-code">System.out.println(period.getMonths());     //prints: 1</pre>
			<pre class="source-code">System.out.println(period.getYears());      //prints: 0</pre>
			<pre class="source-code">System.out.println(period.toTotalMonths()); //prints: 1</pre>
			<pre class="source-code">period = Period.between(ld2, ld1);</pre>
			<pre class="source-code">System.out.println(period.getDays());       //prints: -2</pre>
			<p><strong class="source-inline">Duration</strong> objects can be similarly created and used, as illustrated in the following code snippet:</p>
			<pre class="source-code">LocalTime lt1 =  LocalTime.parse("10:23:12");</pre>
			<pre class="source-code">LocalTime lt2 =  LocalTime.parse("20:23:14");</pre>
			<pre class="source-code">Duration = Duration.between(lt1, lt2);</pre>
			<pre class="source-code">System.out.println(duration.toDays());     //prints: 0</pre>
			<pre class="source-code">System.out.println(duration.toHours());    //prints: 10</pre>
			<pre class="source-code">System.out.println(duration.toMinutes());  //prints: 600</pre>
			<pre class="source-code">System.out.println(duration.toSeconds());  //prints: 36002</pre>
			<pre class="source-code">System.out.println(duration.getSeconds()); //prints: 36002</pre>
			<pre class="source-code">System.out.println(duration.toNanos());    </pre>
			<pre class="source-code">                                       //prints: 36002000000000</pre>
			<pre class="source-code">System.out.println(duration.getNano());    //prints: 0.</pre>
			<p>There<a id="_idIndexMarker853"/> are <a id="_idIndexMarker854"/>many<a id="_idIndexMarker855"/> other <a id="_idIndexMarker856"/>helpful methods in <strong class="source-inline">Period</strong> and <strong class="source-inline">Duration</strong> classes. If you have to work with dates, we recommend that you read the API of this class and other classes of the <strong class="source-inline">java.time</strong> package and its sub-packages.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Period of day</h2>
			<p>Java 16 includes a<a id="_idIndexMarker857"/> new time format that shows a period of <a id="_idIndexMarker858"/>the day as <strong class="source-inline">AM</strong>, <strong class="source-inline">in the morning</strong>, and similar. The following two methods demonstrate usage of the <strong class="source-inline">DateTimeFormatter.ofPattern()</strong> method with the <strong class="source-inline">LocalDateTime</strong> and <strong class="source-inline">LocalTime</strong> classes:</p>
			<pre class="source-code">void periodOfDayFromDateTime(String time, String pattern){</pre>
			<pre class="source-code">   LocalDateTime date = LocalDateTime.parse(time);</pre>
			<pre class="source-code">   DateTimeFormatter frm =</pre>
			<pre class="source-code">            DateTimeFormatter.ofPattern(pattern);</pre>
			<pre class="source-code">   System.out.print(date.format(frm));</pre>
			<pre class="source-code">} </pre>
			<pre class="source-code">void periodOfDayFromTime(String time, String pattern){</pre>
			<pre class="source-code">   LocalTime date = LocalTime.parse(time);</pre>
			<pre class="source-code">   DateTimeFormatter frm =</pre>
			<pre class="source-code">           DateTimeFormatter.ofPattern(pattern);</pre>
			<pre class="source-code">   System.out.print(date.format(frm));</pre>
			<pre class="source-code">}</pre>
			<p>The following<a id="_idIndexMarker859"/> code <a id="_idIndexMarker860"/>demonstrates the effect of <strong class="source-inline">"h a"</strong> and <strong class="source-inline">"h B"</strong> patterns:</p>
			<pre class="source-code">periodOfDayFromDateTime("2023-03-23T05:05:18.123456", </pre>
			<pre class="source-code">           "MM-dd-yyyy h a"); //prints: 03-23-2023 5 AM</pre>
			<pre class="source-code">periodOfDayFromDateTime("2023-03-23T05:05:18.123456", </pre>
			<pre class="source-code">       "MM-dd-yyyy h B"); //prints: 03-23-2023 5 at night</pre>
			<pre class="source-code">periodOfDayFromDateTime("2023-03-23T06:05:18.123456", </pre>
			<pre class="source-code">                  "h B");   //prints: 6 in the morning</pre>
			<pre class="source-code">periodOfDayFromTime("11:05:18.123456", "h B"); </pre>
			<pre class="source-code">                            //prints: 11 in the morning</pre>
			<pre class="source-code">periodOfDayFromTime("12:05:18.123456", "h B"); </pre>
			<pre class="source-code">                          //prints: 12 in the afternoon</pre>
			<pre class="source-code">periodOfDayFromTime("17:05:18.123456", "h B"); </pre>
			<pre class="source-code">                          //prints: 5 in the afternoon</pre>
			<pre class="source-code">periodOfDayFromTime("18:05:18.123456", "h B"); </pre>
			<pre class="source-code">                          //prints: 6 in the evening</pre>
			<pre class="source-code">periodOfDayFromTime("20:05:18.123456", "h B"); </pre>
			<pre class="source-code">                          //prints: 8 in the evening</pre>
			<pre class="source-code">periodOfDayFromTime("21:05:18.123456", "h B"); </pre>
			<pre class="source-code">                         //prints: 9 at night</pre>
			<p>You can<a id="_idIndexMarker861"/> use <strong class="source-inline">"h a"</strong> and <strong class="source-inline">"h B"</strong> patterns to make the time <a id="_idIndexMarker862"/>presentation more user-friendly. </p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/>Summary</h1>
			<p>This chapter introduced you to the Java collections framework and its three main interfaces: <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>. Each of the interfaces was discussed and its methods were demonstrated with one of the implementing classes. The generics were explained and demonstrated as well. The <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods have to be implemented in order for an object to be capable of being handled by Java collections correctly.</p>
			<p>The <strong class="source-inline">Collections</strong> and <strong class="source-inline">CollectionUtils</strong> utility classes have many useful methods for collection handling and were presented in examples, along with the <strong class="source-inline">Arrays</strong>, <strong class="source-inline">ArrayUtils</strong>, <strong class="source-inline">Objects</strong>, and <strong class="source-inline">ObjectUtils</strong> classes.</p>
			<p>The class methods of the <strong class="source-inline">java.time</strong> package allow time/date values to be managed and were demonstrated in specific practical code snippets.</p>
			<p>You can now use all the main data structures we talked about in this chapter in your programs.</p>
			<p>In the next chapter, we will overview JCL and some external libraries, including those that support testing. Specifically, we will explore the <strong class="source-inline">org.junit</strong>, <strong class="source-inline">org.mockito</strong>, <strong class="source-inline">org.apache.log4j</strong>, <strong class="source-inline">org.slf4j</strong>, and <strong class="source-inline">org.apache.commons</strong> packages and their sub-packages.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/>Quiz</h1>
			<ol>
				<li>What is the Java collections framework? Select all that apply:<ol><li>A collection of frameworks</li><li>Classes and interfaces of the <strong class="source-inline">java.util</strong> package</li><li><strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong> interfaces</li><li>Classes and interfaces that implement a collection data structure</li></ol></li>
				<li>What is meant by <em class="italic">generics</em> in a collection? Select all that apply:<ol><li>A collection structure definition</li><li>An element type declaration</li><li>A type generalization</li><li>A mechanism that provides compile-time safety</li></ol></li>
				<li>What are the limitations of the collection of <strong class="source-inline">of()</strong> factory methods? Select all that apply:<ol><li>They do not allow a <strong class="source-inline">null</strong> element.</li><li>They do not allow elements to be added to the initialized collection.</li><li>They do not allow modification of elements in relation to the initialized collection.</li></ol></li>
				<li>What does the implementation of the <strong class="source-inline">java.lang.Iterable</strong> interface allow? Select all that apply:<ol><li>It allows elements of the collection to be accessed one by one.</li><li>It allows the collection to be used in <strong class="source-inline">FOR</strong> statements.</li><li>It allows the collection to be used in <strong class="source-inline">WHILE</strong> statements.</li><li>It allows the collection to be used in <strong class="source-inline">DO...WHILE</strong> statements.</li></ol></li>
				<li>What does the implementation of the <strong class="source-inline">java.util.Collection</strong> interface allow? Select all that apply:<ol><li>Addition to the collection of elements from another collection</li><li>Removal from the collection of objects that are elements of another collection</li><li>Modification of just those elements of the collection that belong to another collection</li><li>Removal from the collection of objects that do not belong to another collection</li></ol></li>
				<li>Select all the correct statements pertaining to <strong class="source-inline">List</strong> interface methods:<ol><li><strong class="source-inline">z get(int index)</strong>: This returns the element at a specified position in the list.</li><li><strong class="source-inline">E remove(int index)</strong>: This removes the element at a specified position in the list; it returns the removed element.</li><li><strong class="source-inline">static List&lt;E&gt; copyOf(Collection&lt;E&gt; coll)</strong>: This returns an unmodifiable <strong class="source-inline">List</strong> interface containing elements of the given <strong class="source-inline">Collection</strong> interface and preserves their order.</li><li><strong class="source-inline">int indexOf(Object o)</strong>: This returns the position of a specified element in the list.</li></ol></li>
				<li>Select all the correct statements pertaining to <strong class="source-inline">Set</strong> interface methods:<ol><li><strong class="source-inline">E get(int index)</strong>: This returns the element at a specified position in the list.</li><li><strong class="source-inline">E remove(int index)</strong>: This removes the element at a specified position in the list; it returns the removed element.</li><li><strong class="source-inline">static Set&lt;E&gt; copyOf(Collection&lt;E&gt; coll)</strong>: This returns an unmodifiable <strong class="source-inline">Set</strong> interface containing elements of the given <strong class="source-inline">Collection</strong> interface.</li><li><strong class="source-inline">int indexOf(Object o)</strong>: This returns the position of a specified element in the list.</li></ol></li>
				<li>Select all the correct statements pertaining to <strong class="source-inline">Map</strong> interface methods:<ol><li><strong class="source-inline">int size()</strong>: This returns the count of key-value pairs stored in the map; when the <strong class="source-inline">isEmpty()</strong> method returns <strong class="source-inline">true</strong>, this method returns <strong class="source-inline">0</strong>.</li><li><strong class="source-inline">V remove(Object key)</strong>: This removes both the key and value from the map; returns <strong class="source-inline">value</strong> or <strong class="source-inline">null</strong> if there is no such key or the value is <strong class="source-inline">null</strong>.</li><li><strong class="source-inline">default boolean remove(Object key, Object value)</strong>: This removes the key-value pair if such a pair exists in the map; returns <strong class="source-inline">true</strong> if the value is removed.</li><li><strong class="source-inline">default boolean replace(K key, V oldValue, V newValue)</strong>: This replaces the <strong class="source-inline">oldValue</strong> value with the <strong class="source-inline">newValue</strong> value provided if the key provided is currently mapped to the <strong class="source-inline">oldValue</strong> value—it returns <strong class="source-inline">true</strong> if the <strong class="source-inline">oldValue</strong> value was replaced; otherwise, it returns <strong class="source-inline">false</strong>.</li></ol></li>
				<li>Select all correct statements pertaining to the <strong class="source-inline">static void sort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator)</strong> method of the <strong class="source-inline">Collections</strong> class:<ol><li>It sorts the list’s natural order if list elements implement the <strong class="source-inline">Comparable</strong> interface.</li><li>It sorts the list’s order according to the <strong class="source-inline">Comparator</strong> object provided.</li><li>It sorts the list’s order according to the <strong class="source-inline">Comparator</strong> object provided if list elements implement the <strong class="source-inline">Comparable</strong> interface.</li><li>It sorts the list’s order according to the provided <strong class="source-inline">Comparator</strong> object irrespective of whether the list elements implement the <strong class="source-inline">Comparable</strong> interface.</li></ol></li>
				<li>What is the outcome of executing the following code?<p class="source-code">List&lt;String&gt; list1 = Arrays.asList("s1","s2", "s3");</p><p class="source-code">List&lt;String&gt; list2 = Arrays.asList("s3", "s4");</p><p class="source-code">Collections.copy(list1, list2);</p><p class="source-code">System.out.println(list1);    </p><ol><li><strong class="source-inline">[s1, s2, s3, s4]</strong></li><li><strong class="source-inline">[s3, s4, s3]</strong></li><li><strong class="source-inline">[s1, s2, s3, s3, s4]</strong></li><li><strong class="source-inline">[s3, s4]</strong></li></ol></li>
				<li>What is the functionality of <strong class="source-inline">CollectionUtils</strong> class methods? Select all that apply:<ol><li>It matches the functionality of <strong class="source-inline">Collections</strong> class methods, but by handling <strong class="source-inline">null</strong></li><li>It complements the functionality of <strong class="source-inline">Collections</strong> class methods</li><li>It searches, processes, and compares Java collections in a way that <strong class="source-inline">Collections</strong> class methods do not do</li><li>It duplicates the functionality of <strong class="source-inline">Collections</strong> class methods</li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">Integer[][] ar1 = {{42}};</p><p class="source-code">Integer[][] ar2 = {{42}};</p><p class="source-code">System.out.print(Arrays.equals(ar1, ar2) + " "); </p><p class="source-code">System.out.println(Arrays.deepEquals(arr3, arr4)); </p><ol><li><strong class="source-inline">false true</strong></li><li><strong class="source-inline">false</strong></li><li><strong class="source-inline">true false</strong></li><li><strong class="source-inline">true</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">String[] arr1 = { "s1", "s2" };</p><p class="source-code">String[] arr2 = { null };</p><p class="source-code">String[] arr3 = null;</p><p class="source-code">System.out.print(ArrayUtils.getLength(arr1) + " "); </p><p class="source-code">System.out.print(ArrayUtils.getLength(arr2) + " "); </p><p class="source-code">System.out.print(ArrayUtils.getLength(arr3) + " "); </p><p class="source-code">System.out.print(ArrayUtils.isEmpty(arr2) + " "); </p><p class="source-code">System.out.print(ArrayUtils.isEmpty(arr3));</p><ol><li><strong class="source-inline">1 2 0 false true</strong></li><li><strong class="source-inline">2 1 1 false true</strong></li><li><strong class="source-inline">2 1 0 false true</strong></li><li><strong class="source-inline">2 1 0 true false</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code"> String str1 = "";</p><p class="source-code"> String str2 = null;</p><p class="source-code"> System.out.print((Objects.hash(str1) == </p><p class="source-code">                   Objects.hashCode(str2)) + " ");</p><p class="source-code"> System.out.print(Objects.hash(str1) + " ");</p><p class="source-code"> System.out.println(Objects.hashCode(str2) + " "); </p><ol><li><strong class="source-inline">true 0 0</strong></li><li><strong class="source-inline">Error</strong></li><li><strong class="source-inline">false -1 0</strong></li><li><strong class="source-inline">false 31 0</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">String[] arr = {"c", "x", "a"};</p><p class="source-code">System.out.print(ObjectUtils.min(arr) + " ");</p><p class="source-code">System.out.print(ObjectUtils.median(arr) + " ");</p><p class="source-code">System.out.println(ObjectUtils.max(arr));</p><ol><li><strong class="source-inline">c x a</strong></li><li><strong class="source-inline">a c x</strong></li><li><strong class="source-inline">x c a</strong></li><li><strong class="source-inline">a x c</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">LocalDate lc = LocalDate.parse("1900-02-23");</p><p class="source-code">System.out.println(lc.withYear(21)); </p><ol><li><strong class="source-inline">1921-02-23</strong></li><li><strong class="source-inline">21-02-23</strong></li><li><strong class="source-inline">0021-02-23</strong></li><li><strong class="source-inline">Error</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">LocalTime lt2 = LocalTime.of(20, 23, 12);</p><p class="source-code">System.out.println(lt2.withNano(300));      </p><ol><li><strong class="source-inline">20:23:12.000000300</strong></li><li><strong class="source-inline">20:23:12.300</strong></li><li><strong class="source-inline">20:23:12:300</strong></li><li><strong class="source-inline">Error</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">LocalDate ld = LocalDate.of(2020, 2, 23);</p><p class="source-code">LocalTime lt = LocalTime.of(20, 23, 12);</p><p class="source-code">LocalDateTime ldt = LocalDateTime.of(ld, lt);</p><p class="source-code">System.out.println(ldt);                </p><ol><li><strong class="source-inline">2020-02-23 20:23:12</strong></li><li><strong class="source-inline">2020-02-23T20:23:12</strong></li><li><strong class="source-inline">2020-02-23:20:23:12</strong></li><li><strong class="source-inline">Error</strong></li></ol></li>
				<li>What is the result of executing the following code?<p class="source-code">LocalDateTime ldt = </p><p class="source-code">              LocalDateTime.parse("2020-02-23T20:23:12");</p><p class="source-code">System.out.print(ldt.minus(Period.ofYears(2)) + " ");</p><p class="source-code">System.out.print(ldt.plus(Duration.ofMinutes(12)) + " ");</p><p class="source-code">System.out.println(ldt);</p><ol><li><strong class="source-inline">2020-02-23T20:23:12 2020-02-23T20:23:12</strong></li><li><strong class="source-inline">2020-02-23T20:23:12 2020-02-23T20:35:12</strong></li><li><strong class="source-inline">2018-02-23T20:23:12 2020-02-23T20:35:12 2020-02-23T20:23:12</strong></li><li><strong class="source-inline">2018-02-23T20:23:12 2020-02-23T20:35:12 2018-02-23T20:35:12</strong></li></ol></li>
			</ol>
		</div>
	</body></html>