- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Driving Design – TDD and SOLID
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动设计 – TDD和SOLID
- en: So far, we’ve created some basic unit tests that have driven out a simple design
    for a couple of classes. We’ve experienced how **test-driven development** (**TDD**)
    makes decision-making about design choices central. In order to build out to a
    larger application, we are going to need to be able to handle designs of greater
    complexity. To do this, we are going to apply some recommended approaches to assessing
    what makes one design preferable to another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一些基本的单元测试，这些测试驱动了几个类的简单设计。我们体验了**测试驱动开发**（**TDD**）如何使设计选择的决定变得核心。为了构建更大的应用程序，我们需要能够处理更复杂的设计。为此，我们将应用一些推荐的评估方法，以确定哪种设计比另一种设计更可取。
- en: The SOLID principles are five design guidelines that steer designs toward being
    more flexible and modular. The word *SOLID* is an acronym, where each letter represents
    one of five principles whose names begin with that letter. These principles existed
    long before they were known by this name. They have proven helpful in my experience,
    and it is worth understanding the benefits each one brings and how we can apply
    them to our code. To do this, we will use a running code example in this chapter.
    It is a simple program that draws shapes of various kinds using simple **American
    Standard Code for Information Interchange** (**ASCII**) art on a console.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是五个设计指南，它们引导设计变得更加灵活和模块化。单词*SOLID*是一个缩写词，其中每个字母代表一个以该字母开头的五个原则之一。这些原则在它们被这个名称所知之前就已经存在。在我的经验中，它们已被证明是有帮助的，了解每个原则带来的好处以及我们如何将它们应用到我们的代码中是值得的。为此，我们将在本章中使用一个运行代码示例。这是一个简单的程序，它使用简单的**美国信息交换标准代码**（**ASCII**）艺术在控制台上绘制各种形状。
- en: Before we start, let’s think about the best *order* to learn these five principles.
    The acronym *SOLID* is easy to say, but it isn’t the easiest way to learn the
    principles. Some principles build on others. Experience shows that some are used
    more than others, especially when doing TDD. For this reason, we’re going to review
    the principles in the order *SDLOI*. It doesn’t sound as good, as I’m sure you
    will agree, but it makes a better order of learning.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们考虑学习这五个原则的最佳**顺序**。缩写词*SOLID*容易说，但并不是学习原则的最简单方式。一些原则建立在其他原则之上。经验表明，有些原则比其他原则使用得更多，尤其是在进行TDD时。因此，我们将按照*SDLOI*的顺序回顾这些原则。当然，它听起来并不那么好，正如您所同意的，但它构成了更好的学习顺序。
- en: Originally, the SOLID principles were conceived as patterns that applied to
    classes in **object-oriented programming** (**OOP**), but they are more general-purpose
    than that. They equally apply to individual methods in a class as well as the
    class itself. They also apply to the design of microservice interconnections and
    function design in functional programming. We will be seeing examples applied
    at both the class level and the method level in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，SOLID原则被构想为适用于面向对象编程（**OOP**）中类的模式，但它们的用途更广泛。它们同样适用于类中的单个方法以及类本身。它们也适用于微服务互连的设计以及函数式编程中的函数设计。在本章中，我们将看到在类级别和方法级别应用示例。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Test guide–we drive the design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试指南–我们驱动设计
- en: '**Single Responsibility Principle** (**SRP**)–simple building blocks'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）–简单的构建块'
- en: '**Dependency Inversion Principle** (**DIP**)–hiding irrelevant details'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）–隐藏无关细节'
- en: '**Liskov Substitution Principle** (**LSP**)–swappable objects'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）–可替换的对象'
- en: '**Open-Closed Principle** (**OCP**)–extensible design'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放封闭原则**（**OCP**）–可扩展的设计'
- en: '**Interface Segregation Principle** (**ISP**)–effective interfaces'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）–有效的接口'
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07).
    A running example of code that draws shapes using all five SOLID principles is
    provided.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07)找到。提供了一个运行示例代码，该代码使用所有五个SOLID原则绘制形状。
- en: Test guide – we drive the design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试指南 – 我们驱动设计
- en: 'In [*Chapter 5*](B18384_05.xhtml#_idTextAnchor092), *Writing Our First Test*,
    we wrote our first test. To do that, we ran through a number of design decisions.
    Let’s review that initial test code and list all the design decisions we had to
    make, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18384_05.xhtml#_idTextAnchor092)，“编写我们的第一个测试”，我们编写了第一个测试。为了做到这一点，我们经历了一系列的设计决策。让我们回顾一下那个初始的测试代码，并列出我们不得不做出的所有设计决策，如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We decided on the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定以下事项：
- en: What to test
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试什么
- en: What to call the test
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何命名测试
- en: What to call the method under test
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何命名待测试的方法
- en: Which class to put that method on
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应将该方法放在哪个类上
- en: The signature of that method
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法的签名
- en: The constructor signature of the class
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的构造函数签名
- en: Which other objects should collaborate
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些其他对象应该协作
- en: The method signatures involved in that collaboration
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那次协作中涉及的方法签名
- en: What form the output of this method will take
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法输出的形式
- en: How to access that output and assert that it worked
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问该输出并断言其已成功
- en: These are all design decisions that our human minds must make. TDD leaves us
    very much hands-on when it comes to designing our code and deciding how it should
    be implemented. To be honest, I am happy about that. Designing is rewarding and
    TDD provides helpful scaffolding rather than a prescriptive approach. TDD acts
    as a guide to remind us to make these design decisions early. It also provides
    a way to document these decisions as test code. Nothing more, but equally, nothing
    less.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们人类大脑必须做出的设计决策。TDD在设计和决定代码实现方式时让我们非常亲自动手。说实话，我很高兴。设计是有回报的，TDD提供了有助的脚手架而不是规定性的方法。TDD充当指南，提醒我们尽早做出这些设计决策。它还提供了一种将这些决策作为测试代码进行记录的方法。不多也不少。
- en: It can be helpful to use techniques such as pair programming or mobbing (also
    known as ensemble programming) as we make these decisions—then, we add more experience
    and more ideas to our solution. Working alone, we simply have to take the best
    decisions we can, based on our own experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出这些决策时，使用诸如结对编程或团队编程（也称为集体编程）等技术可能会有所帮助——然后，我们将更多的经验和想法添加到我们的解决方案中。单独工作，我们只能根据自己的经验做出最好的决定。
- en: 'The critical point to get across here is that TDD does not and *cannot* make
    these decisions for us. We must make them. As such, it is useful to have some
    guidelines to steer us toward better designs. A set of five design principles
    known as the **SOLID principles** are helpful. SOLID is an acronym for the following
    five principles:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，TDD不会也不会为我们做出这些决策。我们必须自己做出。因此，有一些指导方针来引导我们做出更好的设计是有用的。一套被称为**SOLID原则**的五个设计原则是有帮助的。SOLID是以下五个原则的缩写：
- en: SRP
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRP
- en: OCP
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCP
- en: LSP
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSP
- en: ISP
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISP
- en: DIP
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIP
- en: In the following sections, we will learn what these principles are and how they
    help us write well-engineered code and tests. We will start with SRP, which is
    arguably the most foundational principle of any style of program design.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习这些原则是什么以及它们如何帮助我们编写良好设计的代码和测试。我们将从SRP开始，这是任何程序设计风格的基础性原则。
- en: SRP – simple building blocks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SRP – 简单的构建块
- en: 'In this section, we will examine the first principle, known as SRP. We will
    use a single code example throughout all sections. This will clarify how each
    principle is applied to an **object-oriented** (**OO**) design. We’re going to
    look at a classic example of OO design: drawing shapes. The following diagram
    is an overview of the design in **Unified Modeling Language** (**UML**), describing
    the code presented in the chapter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查第一个原则，即SRP。在整个章节中，我们将使用一个单一的代码示例。这将阐明每个原则是如何应用于**面向对象**（**OO**）设计的。我们将查看一个经典的OO设计示例：绘制形状。以下图是**统一建模语言**（**UML**）的设计概览，描述了章节中展示的代码：
- en: '![Figure 7.1 – UML diagram for shapes code](img/Figure_7.1_B18384.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 形状代码的UML图](img/Figure_7.1_B18384.jpg)'
- en: Figure 7.1 – UML diagram for shapes code
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 形状代码的UML图
- en: This diagram shows an overview of the Java code available in the GitHub folder
    for this chapter. We’ll be using specific parts of the code to illustrate how
    each of the SOLID principles has been used to create this design.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了GitHub文件夹中本章可用的Java代码概览。我们将使用代码的特定部分来展示每个SOLID原则是如何被用来创建这个设计的。
- en: UML diagrams
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: UML图
- en: UML was created in 1995 by Grady Booch, Ivar Jacobson, and James Rumbaugh. UML
    is a way of visualizing OO designs at a high level. The preceding diagram is a
    UML class diagram. UML offers many other kinds of useful diagrams. You can learn
    more at [https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558](https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: UML（统一建模语言）是由Grady Booch、Ivar Jacobson和James Rumbaugh在1995年创建的。UML是一种在高级别可视化面向对象设计的方法。前面的图是UML类图。UML还提供了许多其他有用的图表。您可以在[https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558](https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558)了解更多信息。
- en: SRP guides us to break code down into pieces that encapsulate a single aspect
    of our solution. Maybe that is a technical aspect in nature—such as reading a
    database table—or maybe it is a business rule. Either way, we split different
    aspects into different pieces of code. Each piece of code is responsible for a
    single detail, which is where the name *SRP* comes from. Another way of looking
    at this is that a piece of code should only ever have *one reason to change*.
    Let’s examine why this is an advantage in the following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SRP引导我们将代码分解成封装我们解决方案单一方面的片段。这可能是一种技术方面的本质——例如读取数据库表——或者可能是一种业务规则。无论如何，我们将不同的方面拆分到不同的代码片段中。每个代码片段只负责一个细节，这就是*SRP*这个名字的由来。另一种看待方式是，一个代码片段应该只有一个改变的理由。让我们在以下章节中探讨为什么这是一个优势。
- en: Too many responsibilities make code harder to work with
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过多的职责使代码更难处理
- en: A common programming mistake is to combine too many responsibilities into a
    single piece of code. If we have a class that can generate **Hypertext Markup
    Language** (**HTML**), execute a business rule, and fetch data from a database
    table, that class will have three reasons to change. Any time a change in one
    of these areas is necessary, we will risk making a code change that breaks the
    other two aspects. The technical term for this is that the code is **highly coupled.**
    This leads to changes in one area rippling out and affecting other areas.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的编程错误是将过多的职责组合到一个代码块中。如果我们有一个可以生成**超文本标记语言**（**HTML**）、执行业务规则和从数据库表中获取数据的类，那么这个类将有三个改变的理由。任何对这些区域之一的更改都需要时，我们都会冒着做出破坏其他两个方面的代码更改的风险。这个术语的技术名称是代码**高度耦合**。这导致一个区域的更改会波及到其他区域。
- en: 'We can visualize this as code block **A** in the following diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中将这一点可视化为代码块**A**：
- en: '![Figure 7.2 – Single component: multiple reasons to change](img/Figure_7.2_B18384.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 单个组件：多个改变的理由](img/Figure_7.2_B18384.jpg)'
- en: 'Figure 7.2 – Single component: multiple reasons to change'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 单个组件：多个改变的理由
- en: Block **A** deals with three things, so a change to any of them implies a change
    in **A**. To improve this, we apply SRP and separate out the code responsible
    for creating HTML, applying business rules, and accessing the database. Each of
    those three code blocks—**A**, **B**, and **C**—now only has one reason to change.
    Changing any single code block should not result in changes rippling out to the
    other blocks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 块**A**处理三件事，因此对其中任何一项的更改都意味着对**A**的更改。为了改进这一点，我们应用SRP（单一职责原则）并将负责创建HTML、应用业务规则和访问数据库的代码分离出来。这三个代码块——**A**、**B**和**C**——现在只有一个改变的理由。更改任何单个代码块都不应该导致对其他块的连锁反应。
- en: 'We can visualize this in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中可视化这一点：
- en: '![Figure 7.3 – Multiple components: one reason to change](img/Figure_7.3_B18384.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 多个组件：一个改变的理由](img/Figure_7.3_B18384.jpg)'
- en: 'Figure 7.3 – Multiple components: one reason to change'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 多个组件：一个改变的理由
- en: Each code block deals with one thing and has only one reason to change. We can
    see that SRP works to limit the scope of future code changes. It also makes it
    easier to find code in a large code base, as it is logically organized.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码块只处理一件事，并且只有一个改变的理由。我们可以看到SRP（单一职责原则）有助于限制未来代码更改的范围。它还使得在大型代码库中查找代码变得更加容易，因为它是逻辑上组织的。
- en: 'Applying SRP gives other benefits, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用SRP（单一职责原则）带来其他好处，如下所示：
- en: Ability to reuse code
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用能力
- en: Simplified future maintenance
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化未来的维护
- en: Ability to reuse code
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重用能力
- en: Reusing code has been a goal of software engineering for a long time. Creating
    software from scratch takes time, costs money, and prevents a software engineer
    from doing something else. It makes sense that if we create something that is
    generally useful, we use it again wherever possible. The barrier to this happens
    when we have created large, application-specific pieces of software. The fact
    that they are highly specialized means they can only be used in their original
    context.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的重用一直是软件工程的目标。从头开始创建软件需要时间，花费金钱，并阻止软件工程师做其他事情。如果我们创建了一些通用的东西，我们尽可能再次使用它是合理的。当我们创建了大型、特定应用的软件时，这种障碍就出现了。它们高度专业化的事实意味着它们只能在原始环境中使用。
- en: By creating smaller, more general-purpose software components, we will be able
    to use those again in different contexts. The smaller the scope of what the component
    aims to do, the more likely it is that we can reuse it without modification. If
    we have a small function or class that does one thing, it becomes easy to reuse
    that across our code base. It may even end up as part of a framework or library
    that we can reuse across multiple projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建更小、更通用的软件组件，我们将在不同的环境中再次使用它们。组件旨在完成的范围越小，我们越有可能在不修改的情况下重用它。如果我们有一个只做一件事的小函数或类，那么在代码库中重用它就变得容易了。它甚至可能成为框架或库的一部分，我们可以在多个项目中重用它。
- en: SRP does not guarantee that code will be reusable, but it does aim to reduce
    the scope of what any piece of code does. This way of thinking about code as a
    series of building blocks where each one does a small part of the overall task
    is more likely to result in reusable components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SRP并不能保证代码可重用，但它旨在减少任何代码片段的作用范围。将代码视为一系列构建块的方式，其中每个构建块都完成整体任务的一部分，更有可能产生可重用的组件。
- en: Simplified future maintenance
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的未来维护
- en: As we write code, we’re aware that we are not just writing to solve a problem
    now, but also writing code that might be revisited in the future. This might be
    done by other people in the team or maybe by ourselves. We want to make this future
    work as simple as possible. To achieve this, we need to keep our code well-engineered—making
    it safe and easy to work with later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们意识到我们不仅仅是在解决当前的问题，而是在编写可能在未来被重新访问的代码。这可能是团队中的其他人或我们自己。我们希望使未来的工作尽可能简单。为了实现这一点，我们需要保持代码的良好工程化——使其安全且易于以后使用。
- en: Duplicated code is a problem for maintenance—it complicates future code changes.
    If we copy and paste a section of code three times, let’s say, it seems quite
    obvious to us at the time what we are doing. We have one concept that needs to
    happen three times, so we paste it three times. But when it comes time to read
    the code again, that thought process has been lost. It just reads as three unrelated
    pieces of code. *We lose engineering information by copy and paste*. We will need
    to reverse-engineer that code to work out that there are three places where we
    need to change it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码是维护问题——它使未来的代码更改复杂化。如果我们复制粘贴一段代码三次，比如说，当时我们很清楚我们在做什么。我们有一个需要发生三次的概念，所以我们粘贴了三次。但当再次阅读代码时，那种思考过程已经丢失了。它只是看起来像三段不相关的代码。*我们通过复制粘贴丢失了工程信息*。我们需要逆向工程那段代码，以找出需要更改的三个地方。
- en: Counter-example – shapes code that violates SRP
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反例 – 违反SRP的形状代码
- en: 'To see the value of applying SRP, let’s consider a piece of code that doesn’t
    use it. The following code snippet has a list of shapes that all get drawn when
    we call the `draw()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到应用SRP的价值，让我们考虑一个没有使用它的代码片段。以下代码片段有一个形状列表，当调用 `draw()` 方法时，所有形状都会被绘制：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that this code has four responsibilities, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这段代码有四个职责，如下所示：
- en: Managing the list of shapes with the `add()` method
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `add()` 方法管理形状列表
- en: Drawing all the shapes in the list with the `draw()` method
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `draw()` 方法绘制列表中的所有形状
- en: Knowing every type of shape in the `switch` statement
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `switch` 语句中知道每种形状的类型
- en: Has implementation details for drawing each shape type in the `case` statements
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `case` 语句中有绘制每种形状类型的实现细节
- en: If we want to add a new type of shape—triangle, for example—then we’ll need
    to change this code. This will make it longer, as we need to add details about
    how to draw the shape inside a new `case` statement. This makes the code harder
    to read. The class will also have to have new tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加一种新的形状类型——例如三角形——那么我们需要更改此代码。这将使它变得更长，因为我们需要在新的`case`语句中添加有关如何绘制形状的详细信息。这使得代码更难阅读。该类还必须要有新的测试。
- en: Can we change this code to make adding a new type of shape easier? Certainly.
    Let’s apply SRP and refactor.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否改变此代码以使添加新类型的形状更容易？当然可以。让我们应用SRP并进行重构。
- en: Applying SRP to simplify future maintenance
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用SRP以简化未来的维护
- en: 'We will refactor this code to apply SRP, taking small steps. The first thing
    to do is to move that knowledge of how to draw each type of shape out of this
    class, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步重构此代码以应用SRP。首先要做的是将如何绘制每种形状的知识从该类中移出，如下所示：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code that used to be in the `case` statement blocks has been moved into
    the shape classes. Let’s look at the changes in the `Rectangle` class as one example—you
    can see what’s changed in the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在`case`语句块中的代码已被移动到形状类中。以下是一个例子，我们可以看到以下代码片段中的变化：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see how the `Rectangle` class now has the single responsibility of knowing
    how to draw a rectangle. It does nothing else. The one and only reason it will
    have to change is if we need to change how a rectangle is drawn. This is unlikely,
    meaning that we now have a *stable abstraction*. In other words, the `Rectangle`
    class is a building block we can rely on. It is unlikely to change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Rectangle`类现在只负责知道如何绘制矩形。它不做其他任何事情。它唯一需要改变的原因是如果我们需要改变矩形的绘制方式。这种情况不太可能发生，这意味着我们现在有一个*稳定的抽象*。换句话说，`Rectangle`类是我们可以依赖的构建块。它不太可能改变。
- en: If we examine our refactored `Shapes` class, we see that it too has improved.
    It has one responsibility less because we moved that out into the `TextBox` and
    `Rectangle` classes. It is simpler to read already, and simpler to test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查我们的重构`Shapes`类，我们会看到它也得到了改进。由于我们将它移动到了`TextBox`和`Rectangle`类中，它少了一个责任。它已经更容易阅读，也更容易测试。
- en: SRP
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SRP
- en: Do one thing and do it well. Have only one reason for a code block to change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 做一件事，做好这件事。代码块只有一个改变的理由。
- en: More improvements can be made. We see that the `Shapes` class retains its `switch`
    statement and that every `case` statement looks duplicated. They all do the same
    thing, which is to call a `draw()` method on a shape class. We can improve this
    by replacing the `switch` statement entirely—but that will have to wait until
    the next section, where we introduce the DIP.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行更多改进。我们注意到`Shapes`类保留了其`switch`语句，并且每个`case`语句看起来都是重复的。它们都做同样的事情，即在一个形状类上调用`draw()`方法。我们可以通过完全替换`switch`语句来改进这一点——但这将留待下一节介绍DIP时再进行。
- en: Before we do that, let’s think about how SRP applies to our test code itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，让我们考虑一下SRP如何应用于我们的测试代码本身。
- en: Organizing tests to have a single responsibility
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织测试以具有单一责任
- en: SRP also helps us to organize our *tests*. Each test should test only one thing.
    Perhaps this would be a single happy path or a single boundary condition. This
    makes it simpler to localize any faults. We find the test that failed, and because
    it concerns only a single aspect of our code, it is easy to find the code where
    the defect must be. The recommendation to only have a single assertion for each
    test flows naturally from this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: SRP还帮助我们组织我们的*测试*。每个测试应该只测试一件事情。这可能是一条单一的快乐路径或一个单一的边界条件。这使得定位任何故障变得简单。我们找到失败的测试，因为它只涉及我们代码的一个方面，所以很容易找到必须修复缺陷的代码。每个测试只有一个断言的建议自然地源于此。
- en: Separating tests with different configurations
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 分离具有不同配置的测试
- en: Sometimes, a group of objects can be arranged to collaborate in multiple different
    ways. The tests for this group are often better if we write a single test per
    configuration. We end up with multiple smaller tests that are easier to work with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一组对象可以以多种不同的方式协作。如果为该组编写每个配置的单个测试，则这些测试通常更好。我们最终得到多个更小的测试，更容易处理。
- en: This is an example of applying SRP to each configuration of that group of objects
    and capturing that by writing one test for each specific configuration.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对将SRP应用于那一组对象每个配置并通过为每个特定配置编写一个测试来捕获该配置的一个示例。
- en: We’ve seen how SRP helps us create simple building blocks for our code that
    are simpler to test and easier to work with. The next powerful SOLID principle
    to look at is DIP. This is a very powerful tool for managing complexity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到SRP如何帮助我们创建简单的代码构建块，这些构建块更容易测试和操作。接下来要查看的强大的SOLID原则是DIP。这是一个管理复杂性的非常强大的工具。
- en: DIP – hiding irrelevant details
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DIP – 隐藏无关细节
- en: In this section, we will learn how the DIP allows us to split code into separate
    components that can change independently of each other. We will then see how this
    naturally leads to the OCP part of SOLID.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习DIP如何使我们能够将代码分割成可以独立变化的单独组件。然后我们将看到这如何自然地引导到SOLID原则中的OCP部分。
- en: '`Shapes` class after applying SRP to it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用SRP后的`Shapes`类：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code does work well to maintain a list of `Shape` objects and draw them.
    The problem is that it knows too much about the types of shapes it is supposed
    to draw. The `draw()` method features a`Shape` to the system, then we have to
    modify this `switch` statement and the associated TDD test code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在维护`Shape`对象列表并绘制它们方面工作得很好。问题是它对它应该绘制的形状类型了解得太多。`draw()`方法向系统提供了一个`Shape`，然后我们必须修改这个`switch`语句以及相关的TDD测试代码。
- en: 'The technical term for one class knowing about another is that a `Shapes` class
    *depends on* the `TextBox` and `Rectangle` classes. We can represent that visually
    in the following UML class diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类知道另一个类的技术术语是，一个`Shapes`类*依赖于*`TextBox`和`Rectangle`类。我们可以在以下UML类图中直观地表示这一点：
- en: '![Figure 7.4 – Depending on the details](img/Figure_7.4_B18384.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 依赖于细节](img/Figure_7.4_B18384.jpg)'
- en: Figure 7.4 – Depending on the details
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 依赖于细节
- en: 'We can see that the `Shapes` class depends directly on the detail of the `Rectangle`
    and `TextBox` classes. This is shown by the direction of the arrows in the UML
    class diagram. Having these dependencies makes working with the `Shapes` class
    more difficult for the following reasons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Shapes`类直接依赖于`Rectangle`和`TextBox`类的细节。这可以通过UML类图中箭头的方向来体现。这些依赖关系使得使用`Shapes`类变得更加困难，以下是一些原因：
- en: We have to change the `Shapes` class to add a new kind of shape
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须修改`Shapes`类以添加一种新的形状
- en: Any changes in the concrete classes such as `Rectangle` will cause this code
    to change
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对具体类如`Rectangle`的更改都将导致这段代码发生变化
- en: The `Shapes` class will get longer and less easy to read
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shapes`类将会变得更长，也更难以阅读'
- en: We will end up with more test cases
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终会有更多的测试用例
- en: Each test case will be coupled to concrete classes such as `Rectangle`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试用例都将与具体类如`Rectangle`耦合
- en: This is a very procedural approach to creating a class that deals with multiple
    kinds of shapes. It violates SRP by doing too much and knowing too much detail
    about each kind of shape object. The `Shapes` class depends on the details of
    concrete classes such as `Rectangle` and `TextBox`, which directly causes the
    aforementioned problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常过程化的创建处理多种形状的类的办法。它违反了SRP原则，因为它做了太多的事情，并且对每种形状对象了解得过于详细。`Shapes`类依赖于具体类如`Rectangle`和`TextBox`的细节，这直接导致了上述问题。
- en: Thankfully, there is a better way. We can use the power of an interface to improve
    this, by making it so that the `Shapes` class does *not* depend on those details.
    This is called DI. Let’s see what that looks like next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更好的方法。我们可以利用接口的力量来改进它，使得`Shapes`类不依赖于这些细节。这被称为DI。让我们看看它是什么样子。
- en: Applying DI to the shapes code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将DI应用于形状代码
- en: 'We can improve the shapes code by applying the `draw()` method to our `Shape`
    interface, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`draw()`方法应用于我们的`Shape`接口来改进形状代码，如下所示：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This interface is our abstraction of the single responsibility that each shape
    has. Each shape must know how to draw itself when we call the `draw()` method.
    The next step is to make our concrete shape classes implement this interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口是我们对每个形状所具有的单个责任的抽象。每个形状必须知道当调用`draw()`方法时如何绘制自己。下一步是让我们的具体形状类实现这个接口。
- en: 'Let’s take the `Rectangle` class as an example. You can see this here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以`Rectangle`类为例。你可以在这里看到它：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve now introduced the OO concept of polymorphism into our shape classes.
    This breaks the dependency that the `Shapes` class has on knowing about the `Rectangle`
    and `TextBox` classes. All that the `Shapes` class now depends on is the `Shape`
    interface. It no longer needs to know the type of each shape.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将面向对象的多态概念引入了我们的形状类。这打破了`Shapes`类对`Rectangle`和`TextBox`类的依赖。`Shapes`类现在只依赖于`Shape`接口。它不再需要知道每种形状的类型。
- en: 'We can refactor the `Shapes` class to look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Shapes`类重构如下：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This refactoring has completely removed the `switch` statement and the `getType()`
    method, making the code much simpler to understand and test. If we add a new kind
    of shape, the `Shapes` class *no longer needs to change*. We have broken that
    dependency on knowing the details of shape classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次重构完全移除了`switch`语句和`getType()`方法，使代码更容易理解和测试。如果我们添加一种新的形状，`Shapes`类*就不再需要更改*。我们已经打破了知道形状类细节的依赖。
- en: 'One minor refactor moves the `Graphics` parameter we pass into the `draw()`
    method into a field, initialized in the constructor, as illustrated in the following
    code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码片段，我们可以看到一次小的重构将传递给`draw()`方法的`Graphics`参数移动到一个字段中，该字段在构造函数中初始化：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is DIP at work. We’ve created an abstraction in the `Shape` interface.
    The `Shapes` class is a consumer of this abstraction. The classes implementing
    that interface are providers. Both sets of classes depend only on the abstraction;
    they do not depend on details inside each other. There are no references to the
    `Rectangle` class in the `Shapes` class, and there are no references to the `Shapes`
    inside the `Rectangle` class. We can see this inversion of dependencies visualized
    in the following UML class diagram—see how the direction of the dependency arrows
    has changed compared to *Figure 7**.4*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是DIP在起作用。我们在`Shape`接口中创建了一个抽象。`Shapes`类是这个抽象的消费者。实现该接口的类是提供者。这两组类只依赖于抽象；它们不依赖于彼此内部的细节。在`Shapes`类中没有对`Rectangle`类的引用，在`Rectangle`类中也没有对`Shapes`的引用。我们可以在以下UML类图中看到这种依赖关系的逆转——与*图7.4*相比，看看依赖箭头的方向是如何改变的：
- en: '![Figure 7.5 – Inverting dependencies](img/Figure_7.5_B18384.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 逆转依赖关系](img/Figure_7.5_B18384.jpg)'
- en: Figure 7.5 – Inverting dependencies
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 逆转依赖关系
- en: In this version of the UML diagram, the arrows describing the dependencies between
    classes point the opposite way. *The dependencies have been inverted*—hence, the
    name of this principle. Our `Shapes` class now depends on our abstraction, the
    `Shape` interface. So do all the `Rectangle` class and `TextBox` class concrete
    implementations. We have inverted the dependency graph and turned the arrows upside
    down. DI fully decouples classes from each other and, as such, is very powerful.
    We will see how this leads to a key technique for TDD testing when we look at
    [*Chapter 8*](B18384_08.xhtml#_idTextAnchor149), *Test Doubles – Stubs* *and Mocks*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个UML图的版本中，描述类之间依赖关系的箭头指向相反的方向。*依赖关系已经被逆转*——因此，这个原则的名称。现在我们的`Shapes`类依赖于我们的抽象，即`Shape`接口。同样，所有`Rectangle`类和`TextBox`类的具体实现也是如此。我们已经逆转了依赖图，并将箭头颠倒过来。DI完全解耦了类，因此非常强大。当我们查看[*第8章*](B18384_08.xhtml#_idTextAnchor149)，*测试替身
    – 模拟和存根*时，我们将看到这如何导致TDD测试的关键技术。
- en: DIP
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: DIP
- en: Make code depend on abstractions and not on details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码依赖于抽象而不是细节。
- en: 'We’ve seen how DIP is a major tool we can use to simplify our code. It allows
    us to write code that deals with an interface, and then use that code with any
    concrete class that implements that interface. This begs a question: can we write
    a class that implements an interface but will not work correctly? That’s the subject
    of our next section.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到DIP是如何成为一个我们可以用来简化代码的主要工具。它允许我们编写处理接口的代码，然后使用这些代码与实现该接口的任何具体类。这引发了一个问题：我们能否编写一个实现接口但不会正确工作的类？这就是我们下一节的主题。
- en: LSP – swappable objects
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LSP – 可交换的对象
- en: '*Turing Award* winner Barbara Liskov is the creator of a rule concerning inheritance
    that is now commonly known as LSP. It was brought about by a question in OOP:
    if we can extend a class and use it in place of the class we extended, how can
    we be sure the new class will not break things?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图灵奖*获得者芭芭拉·利斯科夫是关于继承的规则的创造者，现在这个规则通常被称为LSP。它是由面向对象中的一个问题引起的：如果我们可以扩展一个类并在其扩展的地方使用它，我们如何确保新的类不会破坏事物？'
- en: We’ve seen in the previous section on DIP how we can use any class that implements
    an interface in place of the interface itself. We also saw how those classes can
    provide any implementation they like for that method. The interface itself provides
    no guarantees at all about what might lurk inside that implementation code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于DIP（依赖倒置原则）的讨论中，我们看到了如何使用实现接口的任何类来代替接口本身。我们还看到了这些类可以为该方法提供任何喜欢的实现。接口本身对实现代码内部可能存在的内容没有任何保证。
- en: 'There is, of course, a bad side to this—which LSP aims to avoid. Let’s explain
    this by looking at a counter-example in code. Suppose we made a new class that
    implemented `interface Shape`, such as this one (Warning: Do *NOT* run the code
    that follows in the `MaliciousShape` class!):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也存在一个不好的方面——这是LSP试图避免的。让我们通过查看代码中的反例来解释这一点。假设我们创建了一个新的类，它实现了`interface Shape`，如下所示（警告：不要在`MaliciousShape`类中运行以下代码！）：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice anything a little odd about that new class? It contains a Unix command
    to remove all our files! This is not what we are expecting when we call the `draw()`
    method on a shape object. Due to permissions failures, it might not be able to
    delete anything, but it’s an example of what can go wrong.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到那个新类有什么奇怪的地方吗？它包含一个Unix命令来删除所有我们的文件！当我们对一个形状对象调用`draw()`方法时，这并不是我们所期望的。由于权限失败，它可能无法删除任何东西，但这是一个可能出错的反例。
- en: An interface in Java can only protect the *syntax* of method calls we expect.
    It cannot enforce any *semantics*. The problem with the preceding `MaliciousShape`
    class is that it does not respect the intent behind the interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的接口只能保护我们期望的方法调用的*语法*。它不能强制执行任何*语义*。前面`MaliciousShape`类的问题在于它没有尊重接口背后的意图。
- en: LSP guides us to avoid this error. In other words, LSP states that any class
    that implements an interface or extends another class must handle all the input
    combinations that the original class/interface could. It must provide the expected
    outputs, it must not ignore valid inputs, and it must not produce completely unexpected
    and undesired behavior. Classes written like this are safe to use through a reference
    to their interface. The problem with our `MaliciousShape` class is that it was
    not compatible with LSP—it added some extra totally unexpected and unwanted behavior.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: LSP指导我们避免这种错误。换句话说，LSP指出，任何实现接口或扩展另一个类的类必须处理原始类/接口可能的所有输入组合。它必须提供预期的输出，它必须不忽略有效的输入，并且它必须不产生完全意外和不期望的行为。这样的类可以通过它们的接口引用安全使用。我们`MaliciousShape`类的问题在于它与LSP不兼容——它添加了一些完全意外和不期望的行为。
- en: LSP formal definition
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: LSP正式定义
- en: 'American computer scientist Barbara Liskov came up with a formal definition:
    If *p(x)* is a property provable about objects *x* of type *T*, then *p(y)* should
    be true for objects *y* of type *S* where *S* is a subtype of *T*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 美国计算机科学家芭芭拉·利斯科夫提出了一个正式的定义：如果*p(x)*是关于类型*T*的对象*x*的可证明属性，那么*p(y)*对于类型*S*的对象*y*也应该为真，其中*S*是*T*的子类型。
- en: Reviewing LSP usage in the shapes code
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查形状代码中的LSP使用情况
- en: 'The classes that implement `Shape` all conform to LSP. This is clear in the
    `TextBox` class, as we can see here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Shape`的所有类都符合LSP。这在`TextBox`类中很明显，如下所示：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code clearly can handle drawing any valid text provided to its
    constructor. It also provides no surprises. It draws the text, using primitives
    from the `Graphics` class, and does nothing else.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显然可以处理提供给其构造函数的任何有效文本。它也没有带来任何惊喜。它使用`Graphics`类的基本功能绘制文本，而不会做其他任何事情。
- en: 'Other examples of LSP compliance can be seen in the following classes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: LSP（里氏替换原则）的合规性示例可以在以下类中看到：
- en: '`Rectangle`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle`'
- en: '`Triangle`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Triangle`'
- en: LSP
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: LSP
- en: A code block can be safely swapped for another if it can handle the full range
    of inputs and provide (at least) all expected outputs, with no undesired side
    effects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个代码块可以安全地替换为另一个代码块，它可以处理完整的输入范围并提供（至少）所有预期的输出，而没有不期望的副作用。
- en: There are some surprising violations of LSP. Perhaps the classic one for the
    shapes code example is about adding a `Square` class. In mathematics, a square
    is a kind of rectangle, with the extra constraint that its height and width are
    equal. In Java code, should we make the `Square` class extend the `Rectangle`
    class? How about the `Rectangle` class extending `Square`?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些令人惊讶的LSP违反情况。也许对于形状代码示例的经典违反之一是关于添加`Square`类。在数学中，正方形是一种矩形，它有一个额外的约束，即其高度和宽度相等。在Java代码中，我们应该让`Square`类扩展`Rectangle`类吗？或者让`Rectangle`类扩展`Square`？
- en: Let’s apply LSP to decide. We will imagine some code that expects a `Rectangle`
    class so that it can change its height, but not its width. If we passed a `Square`
    class to that code, would it work properly? The answer is no. You would then have
    a square with unequal width and height. This *fails* LSP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用LSP来决定。我们将想象一些期望`Rectangle`类以便可以更改其高度但不能更改其宽度的代码。如果我们向该代码传递一个`Square`类，它是否会正常工作？答案是不会。那么你将得到一个宽度和高度不等的长方形。这*违反*了LSP。
- en: The point of LSP is about making classes properly conform to interfaces. In
    the next section, we’ll look at OCP, which is closely related to DI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: LSP的要点是使类正确地符合接口。在下一节中，我们将探讨与DI密切相关OCP。
- en: OCP – extensible design
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OCP – 可扩展的设计
- en: In this section, we’ll see how OCP helps us write code that we can add new features
    to, without changing the code itself. This does sound like an impossibility at
    first, but it flows naturally from DIP combined with LSP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到OCP如何帮助我们编写可以添加新功能而无需更改代码本身的代码。这听起来可能首先是不可能的，但它自然地从DIP与LSP的结合中产生。
- en: OCP results in code that is open to extension but closed to modification. We
    saw this idea at work when we looked at DIP. Let’s review the code refactoring
    we did in the light of OCP.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OCP导致代码对扩展开放但对修改封闭。当我们查看DIP时，我们看到了这个想法是如何工作的。让我们根据OCP回顾我们进行的代码重构。
- en: 'Let’s start with the original code for the `Shapes` class, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Shapes`类的原始代码开始，如下所示：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding a new type of shape requires modification of the code inside the `draw()`
    method. We will be adding a new `case` statement in to support our new shape.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的形状类型需要在`draw()`方法内部修改代码。我们将添加一个新的`case`语句来支持我们的新形状。
- en: 'Modifying existing code has several disadvantages, as set out here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有代码有几个缺点，如下所述：
- en: We invalidate prior testing. This is now different code than we had tested.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使之前的测试无效。现在的代码与之前测试的代码不同。
- en: We might introduce an error that breaks some of the existing support for shapes.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能引入一个错误，破坏了形状的一些现有支持。
- en: The code will become longer and more difficult to read.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将变得更长，更难以阅读。
- en: We might have several developers add shapes at the same time and get a merge
    conflict when we combine their work.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能有几个开发者同时添加形状，并在合并他们的工作时遇到合并冲突。
- en: 'By applying DIP and refactoring the code, we ended up with this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用DIP和重构代码，我们最终得到了如下代码：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now see that adding a new type of shape *does not need modification to
    this code*. This is an example of OCP at work. The `Shapes` class is *open* to
    having new kinds of shapes defined, but it is *closed* against the need for modification
    when that new shape is added. This also means that any tests relating to the `Shapes`
    class will remain unchanged, as there is no difference in behavior for this class.
    That is a powerful advantage.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，添加新的形状类型*不需要修改此代码*。这是一个OCP在起作用的例子。`Shapes`类对新形状的定义是*开放*的，但当添加新形状时，它是*封闭*对修改的需求。这也意味着与`Shapes`类相关的任何测试都将保持不变，因为没有这个类的行为差异。这是一个强大的优势。
- en: OCP relies on DI to work. It is more or less a restatement of a consequence
    of applying DIP. It also provides us with a technique to support *swappable behavior*.
    We can use DIP and OCP to create plugin systems.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: OCP依赖于DI来工作。这基本上是对应用DIP的一个后果的重申。它还为我们提供了一种支持*可替换行为*的技术。我们可以使用DIP和OCP来创建插件系统。
- en: Adding a new type of shape
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的形状类型
- en: 'To see how this works in practice, let’s create a new type of shape, the `RightArrow`
    class, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这在实践中是如何工作的，让我们创建一个新的形状类型，即`RightArrow`类，如下所示：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `RightArrow` class implements the `Shape` interface and defines a `draw()`
    method. To demonstrate that nothing in the `Shapes` class needs to change in order
    to use this, let’s review some code that uses both the `Shapes` and our new class,
    `RightArrow`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`RightArrow`类实现了`Shape`接口并定义了一个`draw()`方法。为了证明在使用此方法时`Shapes`类中没有任何东西需要改变，让我们回顾一些同时使用`Shapes`和我们的新类`RightArrow`的代码，如下所示：'
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We see that the `Shapes` class is being used in a completely normal way, without
    change. In fact, the only change needed to use our new `RightArrow` class is to
    create an object instance and pass it to the `add()` method of shapes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Shapes`类被以完全正常的方式使用，没有任何改变。实际上，要使用我们新的`RightArrow`类，唯一需要改变的是创建一个对象实例并将其传递给`Shapes`类的`add()`方法。
- en: OCP
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: OCP
- en: Make code open for new behaviors, but closed for modifications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码对新行为开放，但对修改封闭。
- en: 'The power of OCP should now be clear. We can extend the capabilities of our
    code and keep changes limited. We greatly reduce the risk of breaking code that
    is already working, as we no longer need to change that code. OCP is a great way
    to manage complexity. In the next section, we’ll look at the remaining SOLID principle:
    ISP.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: OCP的力量现在应该很清楚了。我们可以扩展我们代码的功能，同时保持更改有限。我们大大降低了破坏现有工作代码的风险，因为我们不再需要更改该代码。OCP是管理复杂性的好方法。在下一节中，我们将探讨剩下的SOLID原则：ISP。
- en: ISP – effective interfaces
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISP – 有效的接口
- en: In this section, we will look at a principle that helps us write effective interfaces.
    It is known as ISP.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个帮助我们编写有效接口的原则。它被称为ISP。
- en: ISP advises us to keep our interfaces small and dedicated to achieving a single
    responsibility. By small interfaces, we mean having as few methods as possible
    on any single interface. These methods should all relate to some common theme.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ISP建议我们保持我们的接口小而专注于实现单一责任。通过小接口，我们指的是在任何单个接口上尽可能少的方法。这些方法都应该与某个共同的主题相关。
- en: We can see that this principle is really just SRP in another form. We are saying
    that an effective interface should describe a single responsibility. It should
    cover one abstraction, not several. The methods on the interface should strongly
    relate to each other and also to that single abstraction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看出，这个原则实际上只是SRP的另一种形式。我们说的是，一个有效的接口应该描述一个单一的责任。它应该覆盖一个抽象，而不是几个。接口上的方法应该紧密相关，并且也与那个单一抽象相关。
- en: If we need more abstractions, then we use more interfaces. We keep each abstraction
    in its own separate interface, which is where the term *interface segregation*
    comes from —we keep different abstractions apart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更多的抽象，那么我们就使用更多的接口。我们将每个抽象保持在其自己的单独接口中，这就是术语*接口分离*的来源——我们将不同的抽象分开。
- en: The related **code smell** to this is a large interface that covers several
    different topics in one. We could imagine an interface having hundreds of methods
    in little groups—some relating to file management, some about editing documents,
    and some about printing documents. Such interfaces quickly become difficult to
    work with. ISP suggests that we improve this by splitting the interface into several
    smaller ones. This split would preserve the groups of methods—so, you might see
    interfaces for file management, editing, and printing, with relevant methods under
    each. We have made our code simpler to understand by splitting apart these separate
    abstractions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的**代码异味**是一个覆盖一个主题的多个不同主题的大接口。我们可以想象一个接口有数百个方法分成小群组——一些与文件管理相关，一些关于编辑文档，还有一些关于打印文档。这样的接口很快就会变得难以操作。ISP建议我们通过将接口拆分为几个更小的接口来改进这一点。这种拆分将保留方法组——因此，你可能会看到文件管理、编辑和打印的接口，每个接口下都有相关的方法。通过将这些单独的抽象分开，我们已经使代码更容易理解。
- en: Reviewing ISP usage in the shapes code
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在shapes代码中回顾ISP的使用
- en: 'The most noticeable use of ISP is in the `Shape` interface, as illustrated
    here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ISP最明显的用途是在`Shape`接口中，如下所示：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This interface clearly has a single focus. It is an interface with a very narrow
    focus, so much so that only one method needs to be specified: `draw()`. There
    is no confusion arising from other mixed-in concepts here and no unnecessary methods.
    That single method is both necessary and sufficient. The other major example is
    in the `Graphics` interface, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口显然有一个单一的关注点。它是一个具有非常狭窄关注点的接口，以至于只需要指定一个方法：`draw()`。这里没有因其他混合概念而产生的混淆，也没有不必要的其他方法。这个单一的方法既是必要的也是充分的。另一个主要示例是在`Graphics`接口中，如下所示：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Graphics` interface contains only methods related to drawing graphics primitives
    on screen. It has two methods—`drawText` to display a text string, and `drawHorizontalLine`
    to draw a line in a horizontal direction. As these methods are strongly related—known
    technically as exhibiting **high cohesion**—and few in number, ISP is satisfied.
    This is an effective abstraction over the graphics drawing subsystem, tailored
    to our purposes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphics`接口只包含与在屏幕上绘制图形原语相关的方法。它有两个方法——`drawText`用于显示文本字符串，以及`drawHorizontalLine`用于绘制水平方向的线条。由于这些方法紧密相关——技术上称为具有**高内聚性**——并且数量很少，ISP得到了满足。这是针对我们目的的图形绘制子系统的有效抽象。'
- en: 'For completeness, we can implement this interface in a number of ways. The
    example in GitHub uses a simple text console implementation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们可以以多种方式实现这个接口。GitHub中的示例使用了一个简单的文本控制台实现：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That implementation is also LSP-compliant—it can be used wherever the `Graphics`
    interface is expected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: ISP
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Keep interfaces small and strongly related to a single idea.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now covered all five of the SOLID principles and shown how they have been
    applied to the shapes code. They have guided the design toward compact code, having
    a well-engineered structure to assist future maintainers. We know how to incorporate
    these principles into our own code to gain similar benefits.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at simple explanations of how the SOLID principles
    help us design both our production code and our tests. We’ve worked through an
    example design that uses all five SOLID principles. In future work, we can apply
    SRP to help us understand our design and limit the rework involved in future changes.
    We can apply DIP to split up our code into independent small pieces, leaving each
    piece to hide some of the details of our overall program, creating a divide-and-conquer
    effect. Using LSP, we can create objects that can be safely and easily swapped.
    OCP helps us design software that is simple to add functionality to. ISP will
    keep our interfaces small and easy to understand.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter puts these principles to use to solve a problem in testing—how
    do we test the collaborations between our objects?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do the SOLID principles only apply to OO code?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Although originally applied to an OO context, they have uses in both functional
    programming and microservice design. SRP is almost universally useful—sticking
    to one main focus is helpful for anything, even paragraphs of documentation. SRP
    thinking also helps us write a pure function that does only one thing and a test
    that does only one thing. DIP and OCP are easily done in functional contexts by
    passing in the dependency as a pure function, as we do with Java lambdas. SOLID
    as a whole gives a set of goals for managing coupling and cohesion among any kind
    of software components.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to use SOLID principles with TDD?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. TDD works by defining the outcomes and public interface of a software component.
    How we implement that component is irrelevant to a TDD test, but using principles
    such as SRP and DIP makes it much easier to write tests against that code by giving
    us the test access points we need.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Are SOLID principles the only ones we should use?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. We should use every technique at our disposal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles make a great starting point in shaping your code and we
    should take advantage of them, but there are many other valid techniques to design
    software. The whole catalog of design patterns, the excellent system of **General
    Responsibility Assignment Software Patterns** (**GRASP**) by Craig Larman, the
    idea of information hiding by David L. Parnas, and the ideas of coupling and cohesion
    all apply. We should use any and every technique we know—or can learn about—to
    serve our goal of making software that is easy to read and safe to change.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: If we do not use the SOLID principles, can we still do TDD?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不使用 SOLID 原则，我们还能做 TDD 吗？
- en: Yes—very much so. TDD concerns itself with testing the behavior of code, not
    the details of how it is implemented. SOLID principles simply help us create OO
    designs that are robust and simpler to test.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——非常相关。TDD 关注的是测试代码的行为，而不是它如何实现的细节。SOLID 原则仅仅帮助我们创建出健壮且易于测试的面向对象设计。
- en: How does SRP relate to ISP?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SRP 如何与 ISP 相关？
- en: ISP guides us to prefer many shorter interfaces over one large interface. Each
    of the shorter interfaces should relate to one single aspect of what a class should
    provide. This is usually some kind of role, or perhaps a subsystem. ISP can be
    thought of as making sure our interfaces each apply the SRP and do only one thing—well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ISP 指导我们更倾向于使用多个较短的接口而不是一个大的接口。每个较短的接口应该与类应该提供的一个单一方面相关。这通常是一种角色，或者可能是一个子系统。ISP
    可以被看作是确保我们的每个接口都应用了 SRP 并且只做一件事——做好。
- en: How does OCP relate to DIP and LSP?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OCP 如何与 DIP 和 LSP 相关？
- en: OCP guides us to create software components that can have new capabilities added
    without changing the component itself. This is done by using a plugin design.
    The component will allow separate classes to be plugged in providing the new capabilities.
    The way to do this is to create an abstraction of what a plugin should do in an
    interface—DIP. Then, create concrete plugin implementations of this conforming
    to LSP. After that, we can inject these new plugins into our component. OCP relies
    on DIP and LSP to work.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: OCP 指导我们创建可以添加新功能而不改变组件本身的软件组件。这是通过使用插件设计来实现的。该组件将允许插入不同的类以提供新功能。这样做的方法是在接口中创建一个插件应该做什么的抽象——DIP。然后，创建符合
    LSP 的具体插件实现。之后，我们可以将这些新插件注入到我们的组件中。OCP 依赖于 DIP 和 LSP 来工作。
