<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Building an Accounting Application Using Reactive Programming</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will develop a sample program that does the inventory management part of the company we created the order handling code for. Do not expect a fully developed, ready-to-use, professional application, and also, do not expect that we will get into the details of accounting and bookkeeping. That is not our aim. We will focus more on the programming technique that is of our interest—reactive programming. Sorry pals, I know that bookkeeping and accounting is fun, but this is not that book.</p>
<p class="calibre2">Reactive programming is an old (well, what is old in computer science?) approach that has come recently to Java. Java 9 is the first release that supports some of the aspects of reactive programming in the standard JDK. In one sentence, reactive programming is about focusing more on how the data flows and less on how the implementation handles the data flow. As you may recall, this is also a step towards describing <em class="calibre12">what we want to do</em> from the description of <em class="calibre12">how to do it</em>.</p>
<p class="calibre2">After going through this chapter, you will understand what reactive programming is and what tools there are in Java that you can utilize. You will also understand what reactive programming is good for and when and how you can utilize this principle in the future, as there will be more and more frameworks supporting reactive programming in Java. In this chapter, you will learn the following topics:</p>
<ul class="calibre14">
<li class="calibre15">Reactive programming in general</li>
<li class="calibre15">Reactive streams in Java</li>
<li class="calibre15">How to implement our sample code in a reactive way</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive... what?</h1>
            

            <article>
                
<p class="calibre2">There are reactive programming, reactive systems, and reactive streams. These are three different things related to each other. It is not without reason that all the three are called <em class="calibre12">reactive</em>.</p>
<p class="calibre2"><strong class="calibre1">Reactive programming</strong> is a programming paradigm similar to object-oriented programming and functional programming. A <strong class="calibre1">reactive system</strong> is a system design that sets certain aims and technological constraints on how a certain type of information systems should be designed to be reactive. There are a lot of resemblances to reactive programming principles in this. A <strong class="calibre1">reactive stream</strong> is a set of interface definitions that helps to achieve similar coding advantage to reactive systems and which can be used to create reactive systems. Reactive stream interfaces are a part of JDK 9, but are available not only in Java, but also in other languages.</p>
<p class="calibre2">We will look at these in separate sections, at the end of which, you will presumably have a better understanding of why each of them is called reactive.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive programming in a nutshell</h1>
            

            <article>
                
<p class="calibre2">Reactive programming is a paradigm that focuses more on where the data flows during computation than on how to compute the result. If the problem is best described as several computations that depend on the output of each other but several may be executed independent of the other, reactive programming may come into the picture. As a simple example, we can have the following computation that calculates the value of <kbd class="calibre11">h</kbd> from some given <kbd class="calibre11">b</kbd>, <kbd class="calibre11">c</kbd>, <kbd class="calibre11">e</kbd>, and <kbd class="calibre11">f</kbd> values, using <kbd class="calibre11">f1</kbd>, <kbd class="calibre11">f2</kbd>, <kbd class="calibre11">f3</kbd>, <kbd class="calibre11">f4</kbd>, and <kbd class="calibre11">f5</kbd> as simple computational steps:</p>
<pre class="calibre20">
a = f1(b,c) <br class="title-page-name"/>d = f2(e,f) <br class="title-page-name"/>k = f3(e,c) <br class="title-page-name"/>g = f4(b,f,k) <br class="title-page-name"/>h = f5(d,a,g)
</pre>
<p class="calibre2">If we write these in Java in the conventional way, the methods <kbd class="calibre11">f1</kbd> to <kbd class="calibre11">f5</kbd> will be invoked one after the other. If we have multiple processors and are able to parallelize the execution, we may perform some of the methods in parallel. This, of course, assumes that these methods are purely computational methods and do not change the state of the environment, and, in this way, can be executed independent of each other. For example, <kbd class="calibre11">f1</kbd>, <kbd class="calibre11">f2</kbd>, and <kbd class="calibre11">f3</kbd> can be executed independent of each other. The execution of the function <kbd class="calibre11">f4</kbd> depends on the output of <kbd class="calibre11">f3,</kbd> and the execution of <kbd class="calibre11">f5</kbd> depends on the output of <kbd class="calibre11">f1</kbd>, <kbd class="calibre11">f2</kbd>, and <kbd class="calibre11">f4</kbd>.</p>
<p class="calibre2">If we have two processors, we can execute <kbd class="calibre11">f1</kbd> and <kbd class="calibre11">f2</kbd> together, followed by the execution of <kbd class="calibre11">f3</kbd>, then <kbd class="calibre11">f4</kbd>, and finally, <kbd class="calibre11">f5</kbd>. These are four steps. If we look at the preceding calculation not as commands but rather as expressions and how the calculations depend on each other, then we do not dictate the actual execution order and the environment may decide to calculate <kbd class="calibre11">f1</kbd> and <kbd class="calibre11">f3</kbd> together, then <kbd class="calibre11">f2</kbd> and <kbd class="calibre11">f4</kbd>, and finally <kbd class="calibre11">f5</kbd>, saving one step. This way, we can concentrate on the data flow and let the reactive environment act upon it without putting extra constraints.</p>
<div class="packtfigure"><img class="image-border43" src="../images/00060.gif"/></div>
<p class="calibre2">This is a very simple approach of reactive programming. The description of the calculation in the form of expressions gives the data flow, but in the explanation, we still assumed that the calculation is executed synchronously. If the calculations are executed on different processors that are on different machines connected to a network, then the calculation may not and does not need to be synchronous. Reactive programs can be asynchronously executed if the environment is asynchronous. It may happen that the different calculations, <kbd class="calibre11">f1</kbd> to <kbd class="calibre11">f4</kbd>, are implemented and deployed on different machines. In such a case, the values calculated are sent from one to the other over the network and the nodes execute the calculation every time there is a change in the inputs. This is very similar to good old analog computers that were created using simple building blocks and the calculations were done using analogue signals.</p>
<p class="calibre2">The program was implemented as an electronic circuit, and when the input voltage or current (usually voltage) changed in the inputs, the analog circuits followed it in light's speed, and the result appeared in the output. In such a case, the signal propagation was limited by the speed of light on the wires and analog circuitry speed in the wired modules, which was extremely fast and may beat digital computers.</p>
<p class="calibre2">When we talk about digital computers the propagation of the <em class="calibre12">signal</em> is digital, and this way, it needs to be sent from one calculation node to the other one, be it some <span>object</span> in JVM or some program on the network. A node has to execute its calculation if:</p>
<ul class="calibre14">
<li class="calibre15">Some of the values in the input have changed</li>
<li class="calibre15">The output of the calculation is needed</li>
</ul>
<p class="calibre2">If the input has not changed, then the result should eventually be the same as the last time; thus, the calculation does not need to be executed again—it would be a waste of resources. If the result of the calculation is not needed, then there is no need to perform the calculation even if the result would not be the same as the last one. No one cares.</p>
<p class="calibre2">To accommodate this, reactive environments implement two approaches to propagate the values. The nodes may pull the values from the output of other modules. This will ensure that no calculation that is not needed will be executed. The modules may push their output to the next module that depends on them. This approach will ensure that only changed values ignite calculation. Some of the environments may implement a hybrid solution.</p>
<p class="calibre2">When values change in the system, the change is propagated towards the other nodes that again propagate the changes to another node and so on. If we imagine the calculation dependencies as a directed graph, then the changes travel towards the transitive closure of the changed values along the nodes connected. The data may travel with all the values from one node output to the other node input or only the change may travel. The second approach is more complex because it needs the changed data and also meta information that describes what has changed. On the other hand, the gain may be significant when the output and input set of data is huge and only a small portion of it is changed. It may also be important to calculate and propagate only the actual delta of the change when there is a high probability that some of the nodes do not change the output for many of the different inputs. In such a case, the change propagation may stop at the node where there is no real change in spite of the changed input values. This can save up a lot of calculation in some of the networks.</p>
<p class="calibre2">In the configuration of the data propagation, the directed acyclic graph can be expressed in the code of the program, it can be configured or it can even be set up and changed during the execution of the code dynamically. When the program code contains the structure of the graph, the routes and the dependencies are fairly static. To change the data propagation, the code of the program has to be changed, recompiled, and deployed. In the case of multiple network node programs, this may even need multiple deployments that should be carefully furnished to avoid different incompatible versions running on different nodes. There should be similar considerations when the graph is described in some configuration. In such a case, the compilation of the program(s) may not be needed when only the wiring of the graph is changed, but the burden to have compatible configuration on different nodes in the case of a network execution is still there.</p>
<p class="calibre2">Letting the graph change dynamically also does not solve this problem. The setup and the structure are more flexible and, at the same time, more complex. The data propagated along the edges of the graph may contain not only computational data but also data that drives change in the graph. Many times, this leads to a very flexible model called higher-order reactive programming.</p>
<p class="calibre2">Reactive programming has a lot of benefits but, at the same time, may be very complex, sometimes too complex, for simple problems. It is to be considered when the problem to be solved can easily be described using data graph and simple data propagations. We can separate the description of the problem and the order of the execution of the different blocks. This is the same consideration that we discussed in the previous chapter. We describe more about the <em class="calibre12">what to do</em> part and less about the <em class="calibre12">how to do</em> part.</p>
<p class="calibre2">On the other hand, when the reactive system decides the order of execution, what is changed, and how that should be reflected on the output of other blocks, it should do so without knowing the core of the problem that it is solving. In some situations, coding the execution order manually based on the original problem could perform better.</p>
<div class="packtinfobox">This is similar to the memory management issue. In modern runtime environments, such as the JVM, Python runtime, Swift programming, or even Golang, there is some automated memory management. When programming in C, the programmer has full control over memory allocation and memory release. In the case of real-time applications, where the performance and response time is of the utmost importance, there is no way to let an automated garbage collector take time and delay the execution from time to time. In such a case, the C code can be optimized to allocate memory when needed; there is a resource for the allocation and release of memory when possible and there is time to manage memory. These programs are better performing than the ones created for the same purpose using a garbage collector. Still, we do not use C in most of the applications because we can afford the extra resource needed for automated memory collection. Even though it would be possible to write a faster code managing the memory manually, automated code is faster than what an average programmer would have created using C, and also, the frequency of programming errors is much lower.</div>
<p class="calibre2">Just as there are some issues that we have to pay attention to when using automated memory management, we have to pay attention to some issues in a reactive environment, which would not exist in the case of manual coding. Still, we use the reactive approach for its benefits.</p>
<p class="calibre2">The most important issue is to avoid loops in the dependency graph. Although it is absolutely perfect to write the definition of calculations, a reactive system would probably not be able to cope with these definitions. Some reactive systems may resolve in some simple-case cyclic redundancy, but that is some extra feature and we generally just have to avoid that. Consider the following computations:</p>
<pre class="calibre20">
a = b + 3 <br class="title-page-name"/>b = 4 / a
</pre>
<p class="calibre2">Here, <kbd class="calibre11">a</kbd> depends on <kbd class="calibre11">b</kbd>, so when <kbd class="calibre11">b</kbd> changes, <kbd class="calibre11">a</kbd> is calculated. However, <kbd class="calibre11">b</kbd> also depends on <kbd class="calibre11">a</kbd>, which is recalculated and, in this way, the system gets into an infinite loop. The preceding example seems to be simple, but that is the feature of a good example. Real-life problems are not simple, and in a distributed environment, it is extremely hard sometimes to find cyclic redundancy.</p>
<p class="calibre2">Another problem is called <strong class="calibre1">glitch</strong>. Consider the following definition:</p>
<pre class="calibre20">
a = b + 3 <br class="title-page-name"/>q = b + a
</pre>
<p class="calibre2">When the parameter <kbd class="calibre11">b</kbd> is changed, for example, from <kbd class="calibre11">3</kbd> to <kbd class="calibre11">6</kbd>, the value of <kbd class="calibre11">a</kbd> will change from <kbd class="calibre11">6</kbd> to <kbd class="calibre11">9</kbd>, and thus, <kbd class="calibre11">q</kbd> will change from <kbd class="calibre11">9</kbd> to <kbd class="calibre11">15</kbd>. This is very simple. However, the execution order based on the recognition of the changes may first alter the value of <kbd class="calibre11">q</kbd> from <kbd class="calibre11">9</kbd> to <kbd class="calibre11">12</kbd> before modifying it to <kbd class="calibre11">15</kbd> in a second step. This can happen if the calculating node responsible for the calculation of <kbd class="calibre11">q</kbd> recognizes the change in <kbd class="calibre11">b</kbd> before the value of <kbd class="calibre11">a</kbd> as a consequence of the change in the value of <kbd class="calibre11">b</kbd>. For a short period of time, the value of <kbd class="calibre11">q</kbd> will be <kbd class="calibre11">12</kbd>, which does not match the previous and also does not the changed state. This value is only a glitch in the system that happens after an input changes and also disappears without any further change in the input in the system.</p>
<div class="packtfigure"><img class="image-border44" src="../images/00061.gif"/></div>
<p class="calibre2">If you have ever learnt the design of logical circuits, then static hazards may ring a bell. They are exactly the same phenomenon.</p>
<p class="calibre2">Reactive <span>programming</span> also assumes that the calculations are stateless. The individual nodes that perform the calculation may have a state in practice and, many times, they do. It is not inherently evil to have a state in some calculation. However, debugging something that has a state is significantly more complex than debugging something that is stateless, functional.</p>
<p class="calibre2">It is also an important aid to the reactive environment, letting it perform different optimizations based on the fact that the calculations are functional. If the nodes have a state, then the calculations may not be rearranged freely because the outcome may depend on the actual evaluation order. These systems may not really be <em class="calibre12">reactive</em>, or, at least, it may be debated.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive systems</h1>
            

            <article>
                
<p class="calibre2">Reactive system is defined in the reactive manifesto at <a href="http://www.reactivemanifesto.org/" class="calibre6"><span>http://www.reactivemanifesto.org/</span></a>. The creators of the manifesto realized that with the change of technology, new system patterns will need to be developed in enterprise computing to leverage the new technology and yield better outcomes. The manifesto envisions systems that are:</p>
<ul class="calibre14">
<li class="calibre15">Responsive</li>
<li class="calibre15">Resilient</li>
<li class="calibre15">Elastic</li>
<li class="calibre15">Message-driven.</li>
</ul>
<p class="calibre2">The first three features are user values; the last one is more of a technological approach to get the values.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Responsive</h1>
            

            <article>
                
<p class="calibre2">A system is responsive if it gives results in a reliable manner. If you talk to me, I will answer your question or, at least, tell you that I do not know the answer or that I was not able to understand the question. Better if you get the answer, but if a system cannot give that to you it is still expected to give something back. If you have past experience with client operating systems from just ten years ago and some old computers, you can understand this. Getting a rotating hourglass is frustrating. You just do not know whether the system is working to get you the answer or is totally frozen.</p>
<p class="calibre2">A reactive system has to be responsive. The response should come in a timely manner. The actual timing depends on the actual system. It may be milliseconds, seconds, or even hours in case the system is running on a space ship travelling towards the other side of Jupiter. The important thing is that the system should guarantee some <em class="calibre12">soft</em> upper limit for the response time. This does not necessarily mean that the system should be a real-time solution, which is a much stricter requirement.</p>
<p class="calibre2">The advantage of responsiveness is not only that the user does not become nervous in front of the computer. After all, most of these services are used by other services that mainly communicate with each other. The real advantage is that error discovery is more reliable. If a reactive system element becomes non responsive, it is certainly an error condition, and something should be done about it, out of the scope of normal operations (replace a faulty communication card, restart a system, and so on). The sooner we can identify an error state, the cheaper it is to fix it. The more we can identify where the problem is, the less time and money we could spend localizing the error. Responsiveness is not about speed. It is about better operation, better quality.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Resilient</h1>
            

            <article>
                
<p class="calibre2">Resilient systems keep working even when there is some error. Well, not any error. That would be a miracle, or simply nonsense! An error generally is an error. If the Armageddon comes and it is the end of the world as we know it, even resilient systems will not be responsive. For smaller disruptions, however, there may be some cure to make the systems resilient.</p>
<p class="calibre2">There are techniques that may help if only a disk fails, there is a power outage, or there is a programming error. Systems may be replicated, so when one of the instances stops responding, some other instance may take up the task of the failing one and can go on working. Systems prone to errors may be isolated from each other in terms of space or time. When there is an earthquake or flood at one location, the other location may still go on working. If different components do not need to communicate in real time and messages are stored and forwarded in a reliable manner, then this is not a problem even if the two systems are never available at the same time. They can still cooperate taking up the messages, performing the task they are supposed to, and sending out the resulting message afterwards.</p>
<p class="calibre2">Errors in the system have to be addressed even if the system remains responsive. Errors do not affect the responsiveness of a resilient system, but the level of resilience decreases and should be restored.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Elastic</h1>
            

            <article>
                
<p class="calibre2">Elasticity means that the system is adapting to the load. We can have a huge system, with lots of processors capable of serving the largest anticipated demand. That is not elasticity. Since the demand is not constant and, most of the time, is smaller than the maximum, the resources of such a system are idle. This causes waste of time, CPU cycle, energy, and, thus, ecological footprint.</p>
<div class="packtfigure"><img class="image-border45" src="../images/00062.gif"/></div>
<p class="calibre2">Having systems run on the cloud can avoid such losses. The cloud is nothing but many computers that somebody operates for multiple applications, for multiple corporations even, and each rents only the CPU cycles that it really needs and only when it needs. Other times, when the load is smaller the CPU and the electric power can be used by someone else. Since different applications and different corporations have different peak times, the loss of resources is less with this model. There are many issues that have to be solved, such as data isolation and protection of information from eavesdropping, but these are mainly solved. Secret service corporations will not rent resources from a cloud service to run their computations (perhaps, they'd do for some other purpose) and some other paranoid companies may also refrain from doing that, but most of the companies will do. It is more effective and is thus cheaper even after considering all the side effects one can consider.</p>
<p class="calibre2">Elasticity means that the allocated resources follow, or rather anticipate the coming needs. When the system anticipates higher capacity needs, it allocates more resources and at off-peak time, it releases the resources so that other cloud customers can use it.</p>
<p class="calibre2">Elasticity also assumes that the system is scalable. The two things, elasticity and scalability, are closely related but are not the same. Scalability means that the application can accommodate higher load, allocating more resources. Scalability does not care whether this allocation is static buying and powering of huge computer boxes in a computing center dedicated to the application or dynamic allocation of resources from the cloud on demand. Scalability simply means that if the demand doubles, then the resources can also be multiplied to meet the demand. If the multiplication factor in the resources needed is the same or is not more than the factor in demand, then the application is scalable. If we need more resources to meet the demand, or if we cannot meet the demand even if the demand increases only moderately, then the application is not scalable. Elastic applications are always scalable; otherwise, they cannot be elastic.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Message-driven</h1>
            

            <article>
                
<p class="calibre2">Reactive systems are message-driven; not because we need message-driven systems but much rather because message-driven systems are those that can deliver responsiveness, resilience, and elasticity at the same time.</p>
<p class="calibre2">Message-driven architecture means that the information travels between the components disconnected. One component sends a message and then <em class="calibre12">forgets</em> it. It does not wait for the other component to act upon the message. When the message is sent, all the tasks on behalf of the sending component are performed and all the resources needed to handle the tasks are released, resulting in the message being released and ready to be used for the next task.</p>
<p class="calibre2">Message-driven does not necessarily mean networking. Messages can travel between objects, threads, and processes inside the same machine. On the other hand, if the interfaces to the messaging architecture are well-designed, then the components do not need to be modified if the infrastructure changes and the messages that were previously passing between threads will now have to travel through the ocean in IP packets.</p>
<p class="calibre2">Sending messages makes it possible to isolate the sender and the receiver in space and time, just as we described, as a means for elasticity. The receiver may pick up the message some time after it arrived, when it has the resources to do so. Responsiveness, though, requires that this time is not in the unreachable distant future but in some limited distance. If the message cannot be processed successfully, another message may signal the error. An error message is not the result we expect, but it is still some response and the system remains responsive with all the benefits it means.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Back-pressure</h1>
            

            <article>
                
<p class="calibre2">Message handling, with the appropriate messaging interfaces and implementation, supports back-pressure. Back-pressure is a means to lessen the burden on a component when it cannot or can barely handle more messages. Messages may be queuing for processing, but no real-life queue has unlimited capacity and reactive systems should not lose a message uncontrolled. Back-pressure signals the load of the component to the message producers, asking them to lessen the production. It is like a water pipe. If you start closing the outlet of the pipe, the pressure starts to increase in the pipe backward, the water source forcing it to deliver less and less water.</p>
<p class="calibre2">Back-pressure is an effective way of handling load because it moves load handling to the component that can really do it. In old-fashioned queuing systems, there is a queue that stores the items till the component receiving them can consume them, doing its job. A queue design can be good if there is a well-defined limit for the size of the load and for the maximum size of the queue. If ever the queue is full, the items cannot be delivered and the system stalls.</p>
<p class="calibre2">Applying back-pressure is a bit different. A queue may still be used in front of the components for performance optimization and to ensure responsiveness. The producer of the item can still put the produced item in the queue and return to attending to its own duties and does not need to wait till the consumer can attend to the item. This is decoupling, as we mentioned earlier. Seeing that the queue is full or almost full can also act as a very simple back-pressure. It is not true if someone says that queues are totally missing this feature. At times, it may simply be totally sufficient just to look at the capacity of a queue, and also the items in it, to see if there is some need to lessen the load on the receiver the queue belongs to. But the producer does this, not the receiver, and that is an essential problem.</p>
<p class="calibre2">The producer sees that the receiver is not keeping pace with the supply but the producer does not have any information about the cause, and not knowing the cause cannot predict the future behavior. Having a back-pressure information channel from the receiver to the producer makes the story more fine grained.</p>
<div class="packtinfobox">The producer may see that there are, say, 10 slots in the queue and it thinks that there is no problem; the producer decides to deliver eight more items in the next 150ms. One item usually takes 10ms to process, give or take; thus the items are expected to be processed in less than 100ms, which is just better than the required 200ms maximum. The producer only knows that an item <em class="calibre27">usually</em> takes 10ms to process.<br class="calibre23"/>
The receiver, on the other hand, sees that the last item it got into the queue requires so much processing that, by itself, it will require 200ms. To signal this, it can tell the producer over the back-pressure not to deliver new items till further notice. The receiver knows that the items would have fit in the queue fine but would not be processed in a timely manner. Using this information, the producer will issue some commands to the cloud control to allocate another processing and sends the next eight items to the new receiver, letting the old one do its cumbersome job it has to with that far above than average item.</div>
<p class="calibre2">Back-pressure lets you aid the data load control, with information created by the receivers that have the most information about processing the items.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive streams</h1>
            

            <article>
                
<p class="calibre2">Reactive streams started as an initiative to provide a standard of handling data streams in an asynchronous mode by regulating the push of the data using back-pressure. The original site of the project is <a href="http://www.reactive-streams.org/" class="calibre6"><span>http://www.reactive-streams.org/</span></a>.</p>
<p class="calibre2">Reactive streams are now implemented in JDK 9 in the <kbd class="calibre11">java.util.concurrent</kbd> package.</p>
<p class="calibre2">The aim of the definition of reactive streams is to define the interface that can handle the propagation of the generated data in a totally asynchronous way without the need on the receiving side to buffer the unlimited created data. When data is created in a stream and is made available to be worked on the worker that gets the data, has to be fast enough to handle all the data that is generated. The capacity should be high enough to handle the highest production. Some intermediate buffers may handle peaks, but if there is no control that stops or delays production when the consumer is at the top of its capacity, the system will fail. Reactive system interfaces are designed to provide a way to support back-pressure. Back-pressure is a process to signal the producer of the data to slow down or even to stop the production to the level that fits the consumer. Every call the interfaces define is asynchronous so that the performance of one part is not affected by the delays in the execution of other parts.</p>
<p class="calibre2">The initiative did not aim to define the way in which data is transferred between production and consumption. It focuses on the interfaces to give a clear structure for the programs and also to give an API that will work with all the implementations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Reactive programming in Java</h1>
            

            <article>
                
<p class="calibre2">Java is not a reactive language. This does not mean that we cannot create reactive programs in Java. There are libraries that support different reactive programming approaches. It is to mention the Akka framework and the ReactiveX that also exist for other languages as well. With Java 9, the JDK starts to support reactive programming, providing a few classes and interfaces for the purpose. We will focus on these features.</p>
<p class="calibre2">The JDK contains the <kbd class="calibre11">java.util.concurrent.Flow</kbd> class, which contains related interfaces and some static methods to support flow controlled programs. The model that this class supports is based on <kbd class="calibre11">Publisher</kbd>, <kbd class="calibre11">Subscriber</kbd>, and <kbd class="calibre11">Subscription</kbd>.</p>
<p class="calibre2">As a very simple explanation, a <kbd class="calibre11">Publisher</kbd> accepts a subscription from a <kbd class="calibre11">Subscriber</kbd>. A <kbd class="calibre11">Subscriber</kbd> gets the data it subscribed to when the data is available. The interfaces focus on the very core of the data flow control of the communication and are a bit abstract. No surprise, they are interfaces. However, it may not be simple to understand their working at first.</p>
<p class="calibre2">The <kbd class="calibre11">Publisher</kbd> interface defines the <kbd class="calibre11">subscribe</kbd> method. This is the only method this interface defines and that is because this is the only thing that a <em class="calibre12">real</em> publisher can be asked. You can subscribe to the publications. The argument of the method is a <kbd class="calibre11">Subscriber</kbd> that subscribes to the publications:</p>
<pre class="calibre20">
void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)
</pre>
<p class="calibre2">There is a readily available <kbd class="calibre11">Publisher</kbd> class in the JDK that we will look at later. When the <kbd class="calibre11">subscribe</kbd> method of the <kbd class="calibre11">Publisher</kbd> is called, it has to decide if the subscriber can get the subscription or not. Usually, the subscription is accepted but the implementation has the freedom to refuse a subscription attempt. <kbd class="calibre11">Publisher</kbd> may refuse a subscription if, for example, the subscription for the actual subscriber was already performed and the <kbd class="calibre11">Publisher</kbd> implementation does not allow multiple subscriptions from the same subscriber.</p>
<p class="calibre2">The implementation of the method is required to call the <kbd class="calibre11">onError</kbd> method of <kbd class="calibre11">subscriber</kbd>, with <kbd class="calibre11">Throwable</kbd> as the argument. In the case of multiple subscriptions, <kbd class="calibre11">IllegalStateException</kbd> seems to be suitable, as the JDK documentation defines at the moment.</p>
<p class="calibre2">If the subscription is successful, <kbd class="calibre11">Publisher</kbd> is expected to call the <kbd class="calibre11">onSubscribe</kbd> method of <kbd class="calibre11">subscriber</kbd>. The argument to this method is a <kbd class="calibre11">Subscription</kbd> object (an instance of a class that implements the interface <kbd class="calibre11">Subscription</kbd>). This way, the <kbd class="calibre11">Publisher</kbd> notifies the <kbd class="calibre11">Subscriber</kbd> that the subscription request was accepted, and also passes an object to manage the subscription.</p>
<p class="calibre2">Managing the subscription as an abstraction could be imagined as a complex task, but in the case of reactive streams, it is very simple. All the subscriber can and should do is to set the number of items it can receive at the moment, and the subscription can be cancelled.</p>
<div class="packttip">Why should the <kbd class="calibre22">Publisher</kbd> call back the <kbd class="calibre22">onSubscribe</kbd> method of <kbd class="calibre22">Subscriber</kbd>? Why doesn't it simply return the subscription or throw some error? The reason for this complex behavior is that it may not be the <kbd class="calibre22">Subscriber</kbd> that invokes the <kbd class="calibre22">subscribe</kbd> method. Just as in real life, I can subscribe and pay for a year of a magazine subscription as a Christmas gift. (This is the season when I am writing this part of the book.) In our code, some wiring component responsible for who is notified about a certain data change calls <kbd class="calibre22">subscribe</kbd> and not necessarily the subscriber. The <kbd class="calibre22">Subscriber</kbd> is only responsible for the minimal things that a subscriber should be responsible for.<br class="calibre23"/>
The other reason is that the whole approach is asynchronous. When we subscribe to something, the subscription may not be available and ready immediately. There could be some long-running processes that need to finish till the subscription will be available and the caller that is calling <kbd class="calibre22">subscribe</kbd> does not need to wait for the completion of the process. When the subscription is ready it is passed to the subscriber, to the very entity that really needs it.</div>
<p class="calibre2">The <kbd class="calibre11">Subscriber</kbd> interface defines the <kbd class="calibre11">onSubscribe</kbd>, <kbd class="calibre11">onError</kbd> (we have already talked about these), <kbd class="calibre11">onComplete</kbd> and <kbd class="calibre11">onNext</kbd> methods.</p>
<p class="calibre2">It is important in the definition of these interfaces that the subscriber gets the items from <kbd class="calibre11">Publisher</kbd> or from some other object to which the <kbd class="calibre11">Publisher</kbd> delegates this task via some push. The subscriber does not need to go to the <em class="calibre12">newsstand</em> to get the next issue; someone calling the <kbd class="calibre11">onNext</kbd> method delivers the issue to it directly.</p>
<p class="calibre2">This also bears the consequence that unless there are some controls in the hands of the <kbd class="calibre11">Subscriber</kbd>, it could happen that the <kbd class="calibre11">Publisher</kbd> floods the <kbd class="calibre11">Subscriber</kbd> with items. Not every <kbd class="calibre11">Subscriber</kbd> is capable of handling unlimited items. The <kbd class="calibre11">Subscriber</kbd> gets a <kbd class="calibre11">Subscription</kbd> object upon performing the subscription and this object can be used to control the flow of the item objects.</p>
<p class="calibre2">The <kbd class="calibre11">Publisher</kbd> creates the <kbd class="calibre11">Subscription</kbd> object and the interface defines two methods: <kbd class="calibre11">cancel</kbd> and <kbd class="calibre11">request</kbd>. The <kbd class="calibre11">cancel</kbd> method should be called by the <kbd class="calibre11">Subscriber</kbd> to notify the <kbd class="calibre11">Publisher</kbd> that it should not deliver more items. The subscription is cancelled. The <kbd class="calibre11">request(long n)</kbd> method specifies that the subscriber is prepared to get at most <kbd class="calibre11">n</kbd> items via subsequent calls to the <kbd class="calibre11">onNext</kbd> method:</p>
<div class="packtfigure"><img class="image-border46" src="../images/00063.gif"/></div>
<p class="calibre2">If the subscriber has already invoked the <kbd class="calibre11">request</kbd> method, the specified number is added to the subscription counter. In other words, the specified <kbd class="calibre11">long</kbd> value does not reflect the actual state of the subscriber. It is a delta, increasing some counters maintained by the <kbd class="calibre11">Publisher</kbd> that counts the number of items that can be delivered adding the value of the <kbd class="calibre11">long</kbd> argument and decrementing by one on each item delivered to the <kbd class="calibre11">Subscriber</kbd>. The most usual approach is to call <kbd class="calibre11">request(1)</kbd> each time the <kbd class="calibre11">Subscriber</kbd> has finished processing a request.</p>
<p class="calibre2">If the <kbd class="calibre11">request</kbd> method is invoked with the <kbd class="calibre11">Long.MAX_VALUE</kbd> argument, the <kbd class="calibre11">Publisher</kbd> may just send any item that it can without counting and without limit. This is essentially switching off the back-pressure mechanism.</p>
<p class="calibre2">The specification also mentions that the call to <kbd class="calibre11">cancel</kbd> does not necessarily mean that there will be no more issues delivered at all. Cancellation is done on best effort. Just as in real life, when you send your mail to the daily paper with your intent to cancel the subscription, the publisher will not send an agent to stop the postman before he drops the issue to your mailbox. If something was already on its way when the cancellation arrived to the publisher it goes its way. If the <kbd class="calibre11">Publisher</kbd> has already started some asynchronous process that cannot reasonably be stopped, then the method <kbd class="calibre11">onNext</kbd> method will be invoked with some of the elements.</p>
<p class="calibre2">The <kbd class="calibre11">Publisher</kbd> and <kbd class="calibre11">Subscriber</kbd> interfaces have a generic parameter, <kbd class="calibre11">T</kbd>. This is the type of items that the <kbd class="calibre11">Publisher</kbd> interface publishes and the <kbd class="calibre11">Subscriber</kbd> interface gets in the <kbd class="calibre11">onNext</kbd> method. To be a bit more precise, the <kbd class="calibre11">Subscriber</kbd> interface can have an <kbd class="calibre11">R</kbd> type, which is a superclass of <kbd class="calibre11">T</kbd>; thus, it is compatible with the <kbd class="calibre11">Publisher</kbd> interface. For example, if <kbd class="calibre11">Publisher</kbd> publishes <kbd class="calibre11">Long</kbd> values, then the <kbd class="calibre11">Subscriber</kbd> interface can accept <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Number</kbd>, or <kbd class="calibre11">Object</kbd> in the argument of the <kbd class="calibre11">onNext</kbd> method, depending on the declaration of the class that implements <kbd class="calibre11">Subscriber</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">Flow</kbd> class also contains a <kbd class="calibre11">Processor</kbd> interface that extends both <kbd class="calibre11">Publisher</kbd> and <kbd class="calibre11">Subscriber</kbd>. This interface is there to be implemented by classes that also accept data and send data to other components in the reactive flow. Such elements are very common in reactive stream programs because many elements that perform some tasks get the items to work on from other reactive stream elements; thus, they are <kbd class="calibre11">Subscriber</kbd>s and, at the same time, they send it after they have finished their tasks; thus, they are <kbd class="calibre11">Publisher</kbd>s.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing inventory</h1>
            

            <article>
                
<p class="calibre2">Now that we have discussed a lot of technologies and programming approach, it is very much the time to implement some sample code. We will implement inventory keeping in our application using reactive streams. For the example, the inventory will be very simple. It is a <kbd class="calibre11">Map&lt;Product,InventoryItem&gt;</kbd> that holds the number of items for each product. The actual map is <kbd class="calibre11">ConcurrentHashMap</kbd> and the <kbd class="calibre11">InventoryItem</kbd> class is a bit more complex than a <kbd class="calibre11">Long</kbd> number to properly handle concurrency issues. When we design a program that is built on responsive streams, we do not need to deal with much concurrency locking, but we still should be aware that the code runs in a multithread environment and may exhibit strange behavior if we do not follow some rules.</p>
<p class="calibre2">The code for the <kbd class="calibre11">Inventory</kbd> class is fairly simple since it handles only a map:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.inventory; <br class="title-page-name"/><br class="title-page-name"/>import ...; <br class="title-page-name"/><br class="title-page-name"/>@Component <br class="title-page-name"/>public class Inventory { <br class="title-page-name"/>    private final Map&lt;Product, InventoryItem&gt; inventory = <br class="title-page-name"/>            new ConcurrentHashMap&lt;&gt;(); <br class="title-page-name"/><br class="title-page-name"/>    private InventoryItem getItem(Product product) { <br class="title-page-name"/>        inventory.putIfAbsent(product, new InventoryItem()); <br class="title-page-name"/>        return inventory.get(product); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public void store(Product product, long amount) { <br class="title-page-name"/>        getItem(product).store(amount); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    public void remove(Product product, long amount) <br class="title-page-name"/>            throws ProductIsOutOfStock { <br class="title-page-name"/>        if (getItem(product).remove(amount) != amount) <br class="title-page-name"/>            throw new ProductIsOutOfStock(product); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The inventory item maintaining the class is a bit more complex since this is the level where we handle a bit of concurrency or, at least, this is the class where we have to pay some attention:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.inventory; <br class="title-page-name"/><br class="title-page-name"/>import java.util.concurrent.atomic.AtomicLong; <br class="title-page-name"/><br class="title-page-name"/>public class InventoryItem { <br class="title-page-name"/>    private final AtomicLong amountOnStock = <br class="title-page-name"/>            new AtomicLong(0); <br class="title-page-name"/>    void store(long n) { <br class="title-page-name"/>        amountOnStock.accumulateAndGet(n, <br class="title-page-name"/>                (stock, delta) -&gt; stock + delta); <br class="title-page-name"/>    } <br class="title-page-name"/>    long remove(long delta) { <br class="title-page-name"/>        class ClosureData { <br class="title-page-name"/>            long actNr; <br class="title-page-name"/>        } <br class="title-page-name"/>        ClosureData d = new ClosureData(); <br class="title-page-name"/>        amountOnStock.accumulateAndGet(delta, <br class="title-page-name"/>                (stock, n) -&gt; <br class="title-page-name"/>                        stock &gt;= n ? <br class="title-page-name"/>                                stock - (d.actNr = n) <br class="title-page-name"/>                                : <br class="title-page-name"/>                                stock - (d.actNr = 0) <br class="title-page-name"/>        ); <br class="title-page-name"/>        return d.actNr; <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">When we add products to the inventory, we have no limit. The storage shelves are extremely huge and we do not model that they once may get full and the inventory may not be able to accommodate more items. When we want to remove items from the repository, however, we have to deal with the fact that there may not be enough items from the product. In such a case, we do not remove any items from the repository. We serve the customer to full satisfaction or we do not serve at all.</p>
<p class="calibre2">To maintain the number of the items in the inventory, we use <kbd class="calibre11">AtomicLong</kbd>. This class has the <kbd class="calibre11">accumulateAndGet</kbd> method. This method gets a <kbd class="calibre11">Long</kbd> parameter and a <kbd class="calibre11">LongBinaryOperator</kbd> that we provide in our code as a lambda. This code is invoked by the <kbd class="calibre11">accumulateAndGet</kbd> method to calculate the new value of the stock. If there are enough items, then we remove the requested number of items. If there are not enough items on stock, then we remove zero. The method returns the number of items that we actually return. Since that number is calculated inside the lambda, it has to escape from there. To do so, we use <kbd class="calibre11">ClosureData</kbd> defined inside the method.</p>
<div class="packttip">Note that, for example, in Groovy we could simply use a <kbd class="calibre22">Long d</kbd> variable and alter the variable inside the closure. Groovy calls lambda to closures, so to say. In Java we cannot do so because the variables that we can access from inside the method should be effectively final. However, this is nothing more than a bit more explicit notation that belongs to the closure environment. The <kbd class="calibre22">ClosureData d</kbd> object is final as opposed to the field the class has, which can be modified inside the lambda.</div>
<p class="calibre2">The most interesting class that we are really interested in this chapter is <kbd class="calibre11">InventoryKeeper</kbd>. This class implements the <kbd class="calibre11">Subscriber</kbd> interface and is capable of consuming orders to maintain the inventory:</p>
<pre class="calibre20">
package packt.java9.by.example.mybusiness.inventory; <br class="title-page-name"/><br class="title-page-name"/>import ... <br class="title-page-name"/><br class="title-page-name"/>public class InventoryKeeper implements Flow.Subscriber&lt;Order&gt; { <br class="title-page-name"/>    private static final Logger log = <br class="title-page-name"/>            LoggerFactory.getLogger(InventoryKeeper.class); <br class="title-page-name"/>    private final Inventory inventory; <br class="title-page-name"/><br class="title-page-name"/>    public <a class="calibre26">InventoryKeeper</a>(@Autowired Inventory inventory) { <br class="title-page-name"/>        this.inventory = inventory; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    private Flow.Subscription subscription = null; <br class="title-page-name"/>    private static final long WORKERS = 3; <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void onSubscribe(Flow.Subscription subscription) { <br class="title-page-name"/>        log.info("onSubscribe was called"); <br class="title-page-name"/>        subscription.request(WORKERS); <br class="title-page-name"/>        this.subscription = subscription; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">The <kbd class="calibre11">onSubscribe</kbd> method is invoked after the object is subscribed. The subscription is passed to the object and is also stored in a field. Since the subscriber needs this subscription in subsequent calls, when an item passed in <kbd class="calibre11">onNext</kbd> is processed and a new item is acceptable, a field is a good place to store this object in. In this method, we also set the initial request to three items. The actual value is simply demonstrative. Enterprise environments should be able to configure such parameters:</p>
<pre class="calibre20">
    private ExecutorService service =  <br class="title-page-name"/>                   Executors.newFixedThreadPool((int) WORKERS);
</pre>
<p class="calibre2">The most important part of the code is the <kbd class="calibre11">onNext</kbd> method. What it does is actually goes through all the items of the order and removes the number of items from the inventory. If some of the items are out of stock, then it logs an error. This is the boring part. The interesting part is that it does this through an executor service. This is because the call to <kbd class="calibre11">onNext</kbd> should be asynchronous. The publisher calls <kbd class="calibre11">onNext</kbd> to deliver the item, but we should not make it wait for the actual processing. When the postman brings your favorite magazine, you don't start reading it immediately and make the postman wait for your signature approving acceptance. All you have to do in <kbd class="calibre11">onNext</kbd> is fetch the next order and make sure that this will be processed in due time:</p>
<pre class="calibre20">
    @Override <br class="title-page-name"/>    public void onNext(Order order) { <br class="title-page-name"/>        service.submit(() -&gt; { <br class="title-page-name"/>                    int c = counter.incrementAndGet(); <br class="title-page-name"/>                    for (OrderItem item : order.getItems()) { <br class="title-page-name"/>                        try { <br class="title-page-name"/>                            inventory.remove(item.getProduct(), <br class="title-page-name"/>                                               item.getAmount()); <br class="title-page-name"/>                        } catch (ProductIsOutOfStock exception) { <br class="title-page-name"/>                            log.error("Product out of stock"); <br class="title-page-name"/>                        } <br class="title-page-name"/>                    } <br class="title-page-name"/>                    subscription.request(1); <br class="title-page-name"/>                    counter.decrementAndGet(); <br class="title-page-name"/>                } <br class="title-page-name"/>        ); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void onError(Throwable throwable) { <br class="title-page-name"/>        log.info("onError was called for {}", throwable); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    @Override <br class="title-page-name"/>    public void onComplete() { <br class="title-page-name"/>        log.info("onComplete was called"); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The actual implementation in this code uses <kbd class="calibre11">ThreadPool</kbd> with three threads in it. Also, the number of required items is three. This is a logical coincidence: each thread works on a single item. It does not need to be like that, even if in most cases it is. Nothing can stop us from making more threads working on the same item if that makes sense. The opposite is also true. One single thread may be created to work on multiple items. These codes will probably be more complex and the whole idea of these complex execution models is to make the coding and the logic simpler, move the multithreading, coding, and implementation issues into the framework, and focus on the business logic in the application code. But I cannot tell that there may not be an example for a subscriber working multiple threads on multiple items, intermingled.</p>
<p class="calibre2">The last code we have to look at in this chapter is the unit test that drives the code with some examples:</p>
<pre class="calibre20">
    public void testInventoryRemoval() { <br class="title-page-name"/>        Inventory inventory = new Inventory(); <br class="title-page-name"/>        SubmissionPublisher&lt;Order&gt; p = <br class="title-page-name"/>                         new SubmissionPublisher&lt;&gt;();
</pre>
<p class="calibre2">We create <kbd class="calibre11">Publisher</kbd> using the JDK class, <kbd class="calibre11">SubmissionPublisher</kbd>, which neatly implements this interface delivering multithread functionality for us without much hassle:</p>
<pre class="calibre20">
        p.subscribe(new InventoryKeeper(inventory));
</pre>
<p class="calibre2">We create an inventory keeper and we subscribe to the publisher. This does not start delivering anything because there are no publications yet, but it creates a bond between the subscriber and the publisher telling, them that whenever there is a product submitted, the subscriber wants it.</p>
<p class="calibre2">After that, we create the products and store them in the inventory, 20 pieces altogether, and we also create an order that wants 10 products to be delivered. We will execute this order many times. This is a bit of simplification, but for the test, there is no reason to create separate order objects that have the same products and the same amounts in the list of items:</p>
<pre class="calibre20">
        Product product = new Product(); <br class="title-page-name"/>        inventory.store(product, 20); <br class="title-page-name"/>        OrderItem item = new OrderItem(); <br class="title-page-name"/>        item.setProduct(product); <br class="title-page-name"/>        item.setAmount(10); <br class="title-page-name"/>        Order order = new Order(); <br class="title-page-name"/>        List&lt;OrderItem&gt; items = new LinkedList&lt;&gt;(); <br class="title-page-name"/>        items.add(item); <br class="title-page-name"/>        order.setItems(items);
</pre>
<p class="calibre2">After all this has been done, we submit the order to the <kbd class="calibre11">Publisher</kbd> 10 times. It means that there are 10 orders for the same product, each asking for 10 pieces, that is, 100 pieces together. Those are 100 pieces against the warehouse where we have only 20 of it. What we should expect is that only the first two orders will be fulfilled and the rest will be rejected and that is what will actually happen when we execute this code:</p>
<pre class="calibre20">
        for (int i = 0; i &lt; 10; i++) <br class="title-page-name"/>            p.submit(order); <br class="title-page-name"/>        log.info("All orders were submitted");
</pre>
<p class="calibre2">After all the orders are published, we wait for half a second so that the other threads have time to execute and then we finish:</p>
<pre class="calibre20">
        for (int j = 0; j &lt; 10; j++) { <br class="title-page-name"/>            log.info("Sleeping a bit..."); <br class="title-page-name"/>            Thread.sleep(50); <br class="title-page-name"/>        } <br class="title-page-name"/>        p.close(); <br class="title-page-name"/>        log.info("Publisher was closed"); <br class="title-page-name"/>    }
</pre>
<p class="calibre2">Note that this is not a regular unit test file. It is some test code to play around, which I also recommend for you to execute, debug, and look at the different log outputs.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this short chapter, we had a look at reactive programming, reactive systems, and reactive streams. We discussed the similarities and the differences between these that may lead to confusions. We paid special attention to Java 9 reactive streams that have practically nothing to do with <kbd class="calibre11">Stream</kbd> classes and methods.</p>
<p class="calibre2">In the second half of the chapter, we discussed a very simple example that uses reactive streams.</p>
<p class="calibre2">After reading this chapter, you have learned a lot about the Java language and programming. We did not detail all the small bits of Java, but that is not possible in a book. I dare say that there is no man (or woman for that matter) on the Earth or around it on an orbital route, wherever humans are, who knows everything about Java. We, however, know enough by now to start coding in an enterprise environment and to learn more and more on the go till we retire, or even after that. What is still left is a little bit of programming. In the previous sentence I said coding to make some distinction. Coding is not the same as programming. Coding is a technique used in the profession of programming. During the next, and last, chapter we will see the aspects of programming and how it can, and should, be done in professional manner. This is rarely a part of an introductory book, but I am happy that we could agree on this topic with the publisher. This way, you can finish the book not only with the knowledge that you learn from this book, but also with a vision, looking ahead on the road you will walk up the hillside to the top. You will know the topics, areas, and subjects that you can go on learning.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>