<html><head></head><body>
  <div id="_idContainer118" class="Basic-Text-Frame">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-138" class="chapterTitle">Working with Date and Time</h1>
    <p class="normal">This chapter includes 20 problems covering different date-time topics. These problems are mainly focused on the <code class="inlineCode">Calendar</code> API and on the JDK Date/Time API. About the latter, we will cover some less popular APIs such as <code class="inlineCode">ChronoUnit</code>, <code class="inlineCode">ChronoField</code>, <code class="inlineCode">IsoFields</code>, <code class="inlineCode">TemporalAdjusters</code>, and so on.</p>
    <p class="normal">At the end of this chapter, you’ll have a ton of tips and tricks in your tool belt that will be very useful for solving a wide range of real-world date-time problems.</p>
    <h1 id="_idParaDest-139" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess on date and time. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="68"><strong class="keyWord">Defining a day period</strong>: Write an application that goes beyond AM/PM flags and split the day into four periods: <em class="italic">night</em>, <em class="italic">morning</em>, <em class="italic">afternoon</em>, and <em class="italic">evening</em>. Depending on the given date-time and time zone generate one of these periods.</li>
      <li class="numberedList"><strong class="keyWord">Converting between Date and YearMonth</strong>: Write an application that converts between <code class="inlineCode">java.util.Date</code> and <code class="inlineCode">java.time.YearMonth</code> and vice versa.</li>
      <li class="numberedList"><strong class="keyWord">Converting between int and YearMonth</strong>: Let’s consider that a <code class="inlineCode">YearMonth</code> is given (for instance, 2023-02). Convert it to an integer representation (for instance, 24277) that can be converted back to <code class="inlineCode">YearMonth</code>.</li>
      <li class="numberedList"><strong class="keyWord">Converting week/year to Date</strong>: Let’s consider that two integers are given representing a week and a year (for instance, week 10, year 2023). Write a program that converts 10-2023 to a <code class="inlineCode">java.util.Date</code> via <code class="inlineCode">Calendar</code> and to a <code class="inlineCode">LocalDate</code> via the <code class="inlineCode">WeekFields</code> API. Also, do vice versa: from a given <code class="inlineCode">Date</code>/<code class="inlineCode">LocalDate</code> extract the year and the week as integers.</li>
      <li class="numberedList"><strong class="keyWord">Checking for a leap year</strong>: Let’s consider that an integer is given representing a year. Write an application that checks if this year is a leap year. Provide at least three solutions.</li>
      <li class="numberedList"><strong class="keyWord">Calculating the quarter of a given date</strong>: Let’s consider that a <code class="inlineCode">java.util.Date</code> is given. Write a program that returns the quarter containing this date as an integer (1, 2,3, or 4) and as a string (Q1, Q2, Q3, or Q4).</li>
      <li class="numberedList"><strong class="keyWord">Getting the first and last day of a quarter</strong>: Let’s consider that a <code class="inlineCode">java.util.Date</code> is given. Write a program that returns the first and last day of the quarter containing this date. Represent the returned days as <code class="inlineCode">Date</code> (implementation based on <code class="inlineCode">Calendar</code>) and <code class="inlineCode">LocalDate</code> (implementation based on the JDK 8 Date/Time API).</li>
      <li class="numberedList"><strong class="keyWord">Extracting the months from a given quarter</strong>: Let’s consider that a quarter is given (as an integer, a string (Q1, Q2, Q3, or Q4), or a <code class="inlineCode">LocalDate</code>). Write a program that extracts the names of the months of this quarter. </li>
      <li class="numberedList"><strong class="keyWord">Computing pregnancy due date</strong>: Write a pregnancy due date calculator.</li>
      <li class="numberedList"><strong class="keyWord">Implementing a stopwatch</strong>: Write a program that implements a stopwatch via <code class="inlineCode">System.nanoTime()</code> and via <code class="inlineCode">Instant.now()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Extracting the count of milliseconds since midnight</strong>: Let’s consider that a <code class="inlineCode">LocalDateTime</code> is given. Write an application that counts the milliseconds passed from midnight to this <code class="inlineCode">LocalDateTime</code>.</li>
      <li class="numberedList"><strong class="keyWord">Splitting a date-time range into equal intervals</strong>: Let’s assume that we have a date-time range given via two <code class="inlineCode">LocalDateTime</code> instances, and an integer, <code class="inlineCode">n</code>. Write an application that splits the given range into <code class="inlineCode">n</code> equal intervals (<code class="inlineCode">n</code> equal <code class="inlineCode">LocalDateTime</code> instances).</li>
      <li class="numberedList"><strong class="keyWord">Explaining the difference between Clock.systemUTC() and Clock.systemDefaultZone()</strong>:<strong class="keyWord"> </strong>Explain via meaningful examples what is the difference between <code class="inlineCode">systemUTC()</code> and <code class="inlineCode">systemDefaultZone()</code>.</li>
      <li class="numberedList"><strong class="keyWord">Displaying the names of the days of the week</strong>: Display the names of the days of the week via the <code class="inlineCode">java.text.DateFormatSymbols</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Getting the first and last day of the year</strong>: Let’s consider that an integer representing a year is given. Write a program that returns the first and last day of this year. Provide a solution based on the <code class="inlineCode">Calendar</code> API and one based on the JDK 8 Date/Time API. </li>
      <li class="numberedList"><strong class="keyWord">Getting the first and last day of the week</strong>: Let’s assume that we have an integer representing a number of weeks (for instance, 3 represents three consecutive weeks starting from the current date). Write a program that returns the first and last day of each week. Provide a solution based on the <code class="inlineCode">Calendar</code> API and one based on the JDK 8 Date/Time API.</li>
      <li class="numberedList"><strong class="keyWord">Calculating the middle of the month</strong>: Provide an application containing a snippet based on the <code class="inlineCode">Calendar</code> API, and one based on the JDK 8 Date/Time API for calculating the middle of the given month as a <code class="inlineCode">Date</code>, respectively as a <code class="inlineCode">LocalDate</code>.</li>
      <li class="numberedList"><strong class="keyWord">Getting the number of quarters between two dates</strong>: Let’s consider that a date-time range is given via two <code class="inlineCode">LocalDate</code> instances. Write a program that counts the number of quarters contained in this range.</li>
      <li class="numberedList"><strong class="keyWord">Converting Calendar to </strong><strong class="keyWord">LocalDateTime</strong>: Write a program that converts the given <code class="inlineCode">Calendar</code> into a <code class="inlineCode">LocalDateTime</code> (default time zone), respectively into a <code class="inlineCode">ZonedDateTime</code> (for the Asia/Calcutta time zone).</li>
      <li class="numberedList"><strong class="keyWord">Getting the number of weeks between two dates</strong>: Let’s assume that we have a date-time range given as two <code class="inlineCode">Date</code> instances or as two <code class="inlineCode">LocalDateTime</code> instances. Write an application that returns the number of weeks contained in this range. For the <code class="inlineCode">Date</code> range, write a solution based on the <code class="inlineCode">Calendar</code> API, while for the <code class="inlineCode">LocalDateTime</code> range, write a solution based on the JDK 8 Date/Time API.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03</span></a>.</p>
    <h1 id="_idParaDest-140" class="heading-1">68. Defining a day period</h1>
    <p class="normal">Let’s imagine that we want to say hello to a friend from another country (in a different time zone) via a message such as <em class="italic">Good morning</em>, <em class="italic">Good afternoon</em>, and so on based on their local time. So, having access <a id="_idIndexMarker368"/>to AM/PM flags is not enough, because we consider that a day (24 hours) can be represented by the following periods:</p>
    <ul>
      <li class="bulletList">9:00 PM (or 21:00) – 5:59 AM = night</li>
      <li class="bulletList">6:00 AM – 11:59 AM = morning </li>
      <li class="bulletList">12:00 PM – 5:59 PM (or 17:59) = afternoon</li>
      <li class="bulletList">6:00 PM (or 18:00) – 8:59 PM (or 20:59) = evening</li>
    </ul>
    <h2 id="_idParaDest-141" class="heading-2">Before JDK 16</h2>
    <p class="normal">First, we have to obtain the time <a id="_idIndexMarker369"/>corresponding to our friend’s time zone. For this, we can start from our local time given as a <code class="inlineCode">java.util.Date</code>, <code class="inlineCode">java.time.LocalTime</code>, and so on. If we start from a <code class="inlineCode">java.util.Date</code>, then we can obtain the time in our friend’s time zone as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> date.toInstant().atZone(zoneId).toLocalTime();
</code></pre>
    <p class="normal">Here, <code class="inlineCode">date</code> is a <code class="inlineCode">new Date()</code> and <code class="inlineCode">zoneId</code> is <code class="inlineCode">java.time.ZoneId</code>. Of course, we can pass the zone ID as a <code class="inlineCode">String</code> and use the <code class="inlineCode">ZoneId.of(String zoneId)</code> method to get the <code class="inlineCode">ZoneId</code> instance.</p>
    <p class="normal">If we prefer to start from <code class="inlineCode">LocalTime.now()</code>, then we can obtain the time in our friend’s time zone as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> LocalTime.now(zoneId);
</code></pre>
    <p class="normal">Next, we can define the day periods as a bunch of <code class="inlineCode">LocalTime</code> instances and add some conditions to determine the<a id="_idIndexMarker370"/> current period. The following code exemplifies this statement:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toDayPeriod</span><span class="hljs-params">(Date date, ZoneId zoneId)</span> {
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> date.toInstant().atZone(zoneId).toLocalTime();
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">night</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">morning</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">afternoon</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">evening</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">almostMidnight</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>);
<span class="hljs-type"> LocalTime</span> <span class="hljs-variable">midnight</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
 <span class="hljs-keyword">if</span>((lt.isAfter(night) &amp;&amp; lt.isBefore(almostMidnight)) 
  || lt.isAfter(midnight) &amp;&amp; (lt.isBefore(morning))) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">"night"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lt.isAfter(morning) &amp;&amp; lt.isBefore(afternoon)) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">"morning"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lt.isAfter(afternoon) &amp;&amp; lt.isBefore(evening)) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">"afternoon"</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lt.isAfter(evening) &amp;&amp; lt.isBefore(night)) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">"evening"</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"day"</span>;
}
</code></pre>
    <p class="normal">Now, let’s see how we can do this in JDK 16+.</p>
    <h2 id="_idParaDest-142" class="heading-2">JDK 16+</h2>
    <p class="normal">Starting with JDK 16+, we can go <a id="_idIndexMarker371"/>beyond AM/PM flags via the following strings: <em class="italic">in the morning</em>, <em class="italic">in the afternoon</em>, <em class="italic">in the evening</em>, and <em class="italic">at night</em>.</p>
    <p class="normal">These friendly outputs are available via the new pattern, <code class="inlineCode">B</code>. This pattern is available starting with JDK 16+ via <code class="inlineCode">DateTimeFormatter</code> and <code class="inlineCode">DateTimeFormatterBuilder</code> (you should be familiar with these APIs from <em class="italic">Chapter 1</em>, <em class="italic">Problem 18</em>, shown in <em class="italic">Figure 1.18</em>).</p>
    <p class="normal">So, the following code uses the <code class="inlineCode">DateTimeFormatter</code> to exemplify the usage of pattern <code class="inlineCode">B</code>, representing a period of the day:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toDayPeriod</span><span class="hljs-params">(Date date, ZoneId zoneId)</span> {
 <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">zdt</span> <span class="hljs-operator">=</span> date.toInstant().atZone(zoneId);
 <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> 
    <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MMM-dd [B]"</span>);
 <span class="hljs-keyword">return</span> zdt.withZoneSameInstant(zoneId).format(formatter);
}
</code></pre>
    <p class="normal">Here is an output for <a id="_idIndexMarker372"/>Australia/Melbourne:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-Feb-04 at night
</code></pre>
    <p class="normal">You can see more examples in the bundled code. Feel free to challenge yourself to adjust this code to reproduce the result from the first example.</p>
    <h1 id="_idParaDest-143" class="heading-1">69. Converting between Date and YearMonth</h1>
    <p class="normal">Converting a <code class="inlineCode">java.util.Date</code> to JDK 8 <code class="inlineCode">java.time.YearMonth</code> can be done based on <code class="inlineCode">YearMonth.from(TemporalAccessor temporal)</code>. A <code class="inlineCode">TemporalAccessor</code> is an interface (more precisely, a framework-level interface) that <a id="_idIndexMarker373"/>exposes read-only access to any temporal object including date, time, and offset (a combination of these is also allowed). So, if we convert the given <code class="inlineCode">java.util.Date</code> to <code class="inlineCode">java.time.LocalDate</code>, then the result of the conversion can be passed to <code class="inlineCode">YearMonth.from()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> YearMonth <span class="hljs-title">toYearMonth</span><span class="hljs-params">(Date date)</span> {
  <span class="hljs-keyword">return</span> YearMonth.from(date.toInstant()
                  .atZone(ZoneId.systemDefault())
                  .toLocalDate());
}
</code></pre>
    <p class="normal">Vice versa can be obtained via <code class="inlineCode">Date.from(Instant instant)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">toDate</span><span class="hljs-params">(YearMonth ym)</span> {
  <span class="hljs-keyword">return</span> Date.from(ym.atDay(<span class="hljs-number">1</span>).atStartOfDay(
          ZoneId.systemDefault()).toInstant());
}
</code></pre>
    <p class="normal">Well, that was easy, wasn’t it?</p>
    <h1 id="_idParaDest-144" class="heading-1">70. Converting between int and YearMonth</h1>
    <p class="normal">Consider that we have <code class="inlineCode">YearMonth.now()</code> and we want to convert it to an integer (for example, this can be useful for storing a year/month date<a id="_idIndexMarker374"/> in a database using a numeric field). Check out the solution:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">to</span><span class="hljs-params">(YearMonth u)</span> {
  <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) u.getLong(ChronoField.PROLEPTIC_MONTH);
}
</code></pre>
    <p class="normal">The <em class="italic">proleptic-month </em>is a <code class="inlineCode">java.time.temporal.TemporalField</code>, which basically represents a date-time field such as <em class="italic">month-of-year</em> (our case) or <em class="italic">minute-of-hour</em>. The proleptic-month starts from 0 and counts the months sequentially from year 0. So, <code class="inlineCode">getLong()</code> returns the value of the specified field (here, the proleptic-month) from this year-month as a <code class="inlineCode">long</code>. We can cast this <code class="inlineCode">long</code> to <code class="inlineCode">int</code> since the proleptic-month shouldn’t go beyond the <code class="inlineCode">int</code> domain (for instance, for 2023/2 the returned <code class="inlineCode">int</code> is 24277).</p>
    <p class="normal">Vice versa can be accomplished as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> YearMonth <span class="hljs-title">from</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> t)</span> {
  <span class="hljs-keyword">return</span> YearMonth.of(<span class="hljs-number">1970</span>, <span class="hljs-number">1</span>)
    .with(ChronoField.PROLEPTIC_MONTH, t);
}
</code></pre>
    <p class="normal">You can start from any year/month. The 1970/1 (known as the <em class="italic">epoch</em> and the starting point for <code class="inlineCode">java.time.Instant</code>) choice was just <a id="_idIndexMarker375"/>an arbitrary choice.</p>
    <h1 id="_idParaDest-145" class="heading-1">71. Converting week/year to Date</h1>
    <p class="normal">Let’s consider the year 2023, week 10. The corresponding date is Sun Mar 05 15:15:08 EET 2023 (of course, the time<a id="_idIndexMarker376"/> component is relative). Converting the year/week to <code class="inlineCode">java.util.Date</code> can be done via the <code class="inlineCode">Calendar</code> API as in the following self-explanatory snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Date <span class="hljs-title">from</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year, </span><span class="hljs-type">int</span><span class="hljs-params"> week)</span> {
  <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
  calendar.set(Calendar.YEAR, year);
  calendar.set(Calendar.WEEK_OF_YEAR, week);
  calendar.set(Calendar.DAY_OF_WEEK, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> calendar.getTime();
}
</code></pre>
    <p class="normal">If you prefer to obtain a <code class="inlineCode">LocalDate</code> instead of a <code class="inlineCode">Date</code> then you can easily perform the corresponding conversion or you can rely on <code class="inlineCode">java.time.temporal.WeekFields</code>. This API exposes several fields for working with <em class="italic">week-of-year</em>, <em class="italic">week-of-month</em>, and <em class="italic">day-of-week</em>. This being said, here is the previous solution written via <code class="inlineCode">WeekFields</code> to return a <code class="inlineCode">LocalDate</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDate <span class="hljs-title">from</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year, </span><span class="hljs-type">int</span><span class="hljs-params"> week)</span> {
  <span class="hljs-type">WeekFields</span> <span class="hljs-variable">weekFields</span> <span class="hljs-operator">=</span> WeekFields.of(Locale.getDefault());
  <span class="hljs-keyword">return</span> LocalDate.now()
                  .withYear(year)
                  .with(weekFields.weekOfYear(), week)
                  .with(weekFields.dayOfWeek(), <span class="hljs-number">1</span>);
}
</code></pre>
    <p class="normal">On the other hand, if we have a <code class="inlineCode">java.util.Date</code> and we want to extract the year and the week from it, then we can <a id="_idIndexMarker377"/>use the <code class="inlineCode">Calendar</code> API. Here, we extract the year:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getYear</span><span class="hljs-params">(Date date)</span> {
  <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
  calendar.setTime(date);
  <span class="hljs-keyword">return</span> calendar.get(Calendar.YEAR);
}
</code></pre>
    <p class="normal">And here, we extract the week:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getWeek</span><span class="hljs-params">(Date date)</span> { 
  <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
  calendar.setTime(date);
  <span class="hljs-keyword">return</span> calendar.get(Calendar.WEEK_OF_YEAR);
}
</code></pre>
    <p class="normal">Getting the year and the week from a <code class="inlineCode">LocalDate</code> is easy thanks to <code class="inlineCode">ChronoField.YEAR</code> and <code class="inlineCode">ChronoField.ALIGNED_WEEK_OF_YEAR</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getYear</span><span class="hljs-params">(LocalDate date)</span> {
  <span class="hljs-keyword">return</span> date.get(ChronoField.YEAR);
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getWeek</span><span class="hljs-params">(LocalDate date)</span> {
  <span class="hljs-keyword">return</span> date.get(ChronoField.ALIGNED_WEEK_OF_YEAR);
}
</code></pre>
    <p class="normal">Of course, getting the week can be accomplished via <code class="inlineCode">WeekFields</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> date.get(WeekFields.of(
  Locale.getDefault()).weekOfYear());
</code></pre>
    <p class="normal">Challenge yourself to <a id="_idIndexMarker378"/>obtain week/month and day/week from a <code class="inlineCode">Date</code>/<code class="inlineCode">LocalDate</code>.</p>
    <h1 id="_idParaDest-146" class="heading-1">72. Checking for a leap year</h1>
    <p class="normal">This problem becomes easy as long as we know what a leap year is. In a nutshell, a leap year is any year divisible by 4 (so, <code class="inlineCode">year % 4 == 0</code>) that it is not a century (for instance, 100, 200, …, n00). However, if the year represents <a id="_idIndexMarker379"/>a century that is divisible by 400 (so, <code class="inlineCode">year % 400 == 0</code>), then it is a leap year. In this context, our code is just a simple chain of <code class="inlineCode">if</code> statements as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> boolean <span class="hljs-title">isLeapYear</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year)</span> {
  <span class="hljs-keyword">if</span> (year % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (year % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
    <p class="normal">But, this code can be condensed using the <code class="inlineCode">GregorianCalendar</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">GregorianCalendar</span>(year, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).isLeapYear(year);
}
</code></pre>
    <p class="normal">Or, starting with JDK 8, we can rely on the <code class="inlineCode">java.time.Year</code> API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year)</span> {
  <span class="hljs-keyword">return</span> Year.of(year).isLeap(); 
}
</code></pre>
    <p class="normal">In the bundled code, you can see more approaches.</p>
    <h1 id="_idParaDest-147" class="heading-1">73. Calculating the quarter of a given date</h1>
    <p class="normal">A year has 4 quarters (commonly <a id="_idIndexMarker380"/>denoted as Q1, Q2, Q3, and Q4) and each quarter has 3 months. If we consider that January is 0, February is 1, …, and December is 11, then we can observe that January/3 = 0, February/3 =0, March/3 = 0, and 0 can represent Q1. Next, 3/3 = 1, 4/3 = 1, 5/3 = 1, so 1 can represent Q2. Based on the same logic, 6/3 = 2, 7/3 = 2, 8/3 = 2, so 2 can represent Q3. Finally, 9/3 = 3, 10/3 = 3, 11/3 = 3, so 3 represents Q4.</p>
    <p class="normal">Based on this statement and the <code class="inlineCode">Calendar</code> API, we can obtain the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">quarter</span><span class="hljs-params">(Date date)</span> {
  String[] quarters = {<span class="hljs-string">"Q1"</span>, <span class="hljs-string">"Q2"</span>, <span class="hljs-string">"Q3"</span>, <span class="hljs-string">"Q4"</span>};
  <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
  calendar.setTime(date);
  <span class="hljs-type">int</span> <span class="hljs-variable">quarter</span> <span class="hljs-operator">=</span> calendar.get(Calendar.MONTH) / <span class="hljs-number">3</span>;
  <span class="hljs-keyword">return</span> quarters[quarter];
}
</code></pre>
    <p class="normal">But, starting with JDK 8, we can rely on <code class="inlineCode">java.time.temporal.IsoFields</code>. This class contains fields (and units) that follow the calendar system based on the ISO-8601 standard. Among these artifacts, we have the <em class="italic">week-based-year</em> and the one that we are interested in, <em class="italic">quarter-of-year</em>. This time, let’s return the quarter as an integer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">quarter</span><span class="hljs-params">(Date date)</span> {
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> date.toInstant()
    .atZone(ZoneId.systemDefault()).toLocalDate();
  <span class="hljs-keyword">return</span> localDate.get(IsoFields.QUARTER_OF_YEAR);
}
</code></pre>
    <p class="normal">In the bundled code, you can see more examples including one that uses <code class="inlineCode">DateTimeFormatter.ofPattern("QQQ")</code>.</p>
    <h1 id="_idParaDest-148" class="heading-1">74. Getting the first and last day of a quarter</h1>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker381"/> represent the first and last day of a quarter via this simple class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Quarter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Date firstDay;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Date lastDay;
  ...
}
</code></pre>
    <p class="normal">Next, we have a <code class="inlineCode">java.util.Date</code> and we want the first and the last day of the quarter containing this date. For this, we can use JDK 8’s <code class="inlineCode">IsoFields.DAY_OF_QUARTER</code> (we introduced <code class="inlineCode">IsoFields</code> in the previous problem). But, before we can use <code class="inlineCode">IsoFields</code>, we have to convert the given <code class="inlineCode">java.util.Date</code> to a <code class="inlineCode">LocalDate</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> date.toInstant()
  .atZone(ZoneId.systemDefault()).toLocalDate();
</code></pre>
    <p class="normal">Once we have the given <code class="inlineCode">Date</code> as a <code class="inlineCode">LocalDate</code>, we can easily extract the first day of the quarter via <code class="inlineCode">IsoFields.DAY_OF_QUARTER</code>. Next, we add 2 months to this day to move into the last month of the quarter (a quarter has 3 months, so a year has 4 quarters) and we rely on <code class="inlineCode">java.time.temporal.TemporalAdjusters</code>, more<a id="_idIndexMarker382"/> precisely on <code class="inlineCode">lastDayOfMonth()</code> to obtain the last day of the quarter. Finally, we convert the two obtained <code class="inlineCode">LocalDate</code> instances to <code class="inlineCode">Date</code> instances. Here is the complete code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Quarter <span class="hljs-title">quarterDays</span><span class="hljs-params">(Date date)</span> {
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> date.toInstant()
    .atZone(ZoneId.systemDefault()).toLocalDate();
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">firstDay</span>
    <span class="hljs-operator">=</span> localDate.with(IsoFields.DAY_OF_QUARTER, <span class="hljs-number">1L</span>);
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastDay</span> <span class="hljs-operator">=</span> firstDay.plusMonths(<span class="hljs-number">2</span>)
    .with(TemporalAdjusters.lastDayOfMonth());
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Quarter</span>(
    Date.from(firstDay.atStartOfDay(
      ZoneId.systemDefault()).toInstant()),
    Date.from(lastDay.atStartOfDay(
      ZoneId.systemDefault()).toInstant())
  );
}
</code></pre>
    <p class="normal">Of course, these conversions are not needed if you work directly with <code class="inlineCode">LocalDate</code>. But, this way, you have a chance to learn more.</p>
    <p class="normal">In the bundled code, you can find more examples, including one that relies entirely on the <code class="inlineCode">Calendar</code> API.</p>
    <h1 id="_idParaDest-149" class="heading-1">75. Extracting the months from a given quarter</h1>
    <p class="normal">This problem becomes quite easy to solve if we are familiar with JDK 8’s <code class="inlineCode">java.time.Month</code>. Via this API, we can find the<a id="_idIndexMarker383"/> first month (0 for January, 1 for February, …) of a quarter containing the given <code class="inlineCode">LocalDate</code> as <code class="inlineCode">Month.from(LocalDate).firstMonthOfQuarter().getValue()</code>.</p>
    <p class="normal">Once we have the first month, it is easy to obtain the other two as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; quarterMonths(LocalDate ld) {
  List&lt;String&gt; qmonths = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-type">int</span> <span class="hljs-variable">qmonth</span> <span class="hljs-operator">=</span> Month.from(ld)
    .firstMonthOfQuarter().getValue();
  qmonths.add(Month.of(qmonth).name());
  qmonths.add(Month.of(++qmonth).name());
  qmonths.add(Month.of(++qmonth).name());
  <span class="hljs-keyword">return</span> qmonths;
}
</code></pre>
    <p class="normal">How about passing the quarter itself as an argument? This can be done as a number (1, 2, 3, or 4) or as a string (Q1, Q2, Q3, or Q4). If the given <code class="inlineCode">quarter</code> is a number, then the first month of the quarter can be obtained as <code class="inlineCode">quarter</code> * 3 – 2, where the <code class="inlineCode">quarter</code> is 1, 2, 3, or 4. This time, let’s express the code in a functional style:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">qmonth</span> <span class="hljs-operator">=</span> quarter * <span class="hljs-number">3</span> - <span class="hljs-number">2</span>;
List&lt;String&gt; qmonths = IntStream.of(
        qmonth, ++qmonth, ++qmonth)
  .mapToObj(Month::of)
  .map(Month::name)
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">Of course, if you find it more concise, then you can use <code class="inlineCode">IntStream.range(qmonth, qmonth+2)</code> instead of <code class="inlineCode">IntStream.of()</code>. In the bundled, code you can find more examples.</p>
    <h1 id="_idParaDest-150" class="heading-1">76. Computing pregnancy due date</h1>
    <p class="normal">Let’s start with these two <a id="_idIndexMarker384"/>constants:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PREGNANCY_WEEKS</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PREGNANCY_DAYS</span> <span class="hljs-operator">=</span> PREGNANCY_WEEKS * <span class="hljs-number">7</span>;
</code></pre>
    <p class="normal">Let’s consider the first day as a <code class="inlineCode">LocalDate</code> and we want to write a calculator that prints the pregnancy due date, the number <a id="_idIndexMarker385"/>of remaining days, the number of passed days, and the current week.</p>
    <p class="normal">Basically, the pregnancy due date is obtained by adding the <code class="inlineCode">PREGNANCY_DAYS</code> to the given first day. Further, the number of remaining days is the difference between today and the given first day, while the number of passed days is <code class="inlineCode">PREGNANCY_DAYS</code> minus the number of remaining days. Finally, the current week is obtained as the number of passed days divided by 7 (since a week has 7 days). Based on<a id="_idIndexMarker386"/> these statements, the code speaks for itself:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pregnancyCalculator</span><span class="hljs-params">(LocalDate firstDay)</span> {
  firstDay = firstDay.plusDays(PREGNANCY_DAYS);
  System.out.println(<span class="hljs-string">"Due date: "</span> + firstDay);
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();
  <span class="hljs-type">long</span> <span class="hljs-variable">betweenDays</span> <span class="hljs-operator">=</span>    
    Math.abs(ChronoUnit.DAYS.between(firstDay, today));
  <span class="hljs-type">long</span> <span class="hljs-variable">diffDays</span> <span class="hljs-operator">=</span> PREGNANCY_DAYS - betweenDays;
  <span class="hljs-type">long</span> <span class="hljs-variable">weekNr</span> <span class="hljs-operator">=</span> diffDays / <span class="hljs-number">7</span>;
  <span class="hljs-type">long</span> <span class="hljs-variable">weekPart</span> <span class="hljs-operator">=</span> diffDays % <span class="hljs-number">7</span>;
  <span class="hljs-type">String</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> weekNr + <span class="hljs-string">" | "</span> + weekPart;
  System.out.println(<span class="hljs-string">"Days remaining: "</span> + betweenDays);
  System.out.println(<span class="hljs-string">"Days in: "</span> + diffDays);
  System.out.println(<span class="hljs-string">"Week: "</span> + week);
} 
</code></pre>
    <p class="normal">See if you can think of a way to use this to calculate another important date.</p>
    <h1 id="_idParaDest-151" class="heading-1">77. Implementing a stopwatch</h1>
    <p class="normal">A classical implementation for a stopwatch relies on <code class="inlineCode">System.nanoTime()</code>, <code class="inlineCode">System.currentTimeMillis()</code>, or on <code class="inlineCode">Instant.now()</code>. In all cases, we have to provide support for starting and stopping the <a id="_idIndexMarker387"/>stopwatch, and some helpers to obtain the measured time in different time units.</p>
    <p class="normal">While the solutions based on <code class="inlineCode">Instant.now()</code> and <code class="inlineCode">currentTimeMillis()</code> are available in the bundled code, here we’ll show the one based on <code class="inlineCode">System.nanoTime()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NanoStopwatch</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> startTime;
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> stopTime;
  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> running;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>.startTime = System.nanoTime();
    <span class="hljs-built_in">this</span>.running = <span class="hljs-literal">true</span>;
   }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>.stopTime = System.nanoTime();
    <span class="hljs-built_in">this</span>.running = <span class="hljs-literal">false</span>;
   }
  <span class="hljs-comment">//elaspsed time in nanoseconds</span>
   <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">getElapsedTime</span><span class="hljs-params">()</span> {
     <span class="hljs-keyword">if</span> (running) {
       <span class="hljs-keyword">return</span> System.nanoTime() - startTime;
     } <span class="hljs-keyword">else</span> {
       <span class="hljs-keyword">return</span> stopTime - startTime;
     } 
  }
}
</code></pre>
    <p class="normal">If you need to return the measured<a id="_idIndexMarker388"/> time in milliseconds or seconds as well, then simply add the following two helpers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//elaspsed time in millisecods</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">elapsedTimeToMillis</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> nanotime)</span> {
  <span class="hljs-keyword">return</span> TimeUnit.MILLISECONDS.convert(
    nanotime, TimeUnit.NANOSECONDS);
}
<span class="hljs-comment">//elaspsed time in seconds</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">elapsedTimeToSeconds</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> nanotime)</span> {
  <span class="hljs-keyword">return</span> TimeUnit.SECONDS.convert(
    nanotime, TimeUnit.NANOSECONDS);
}
</code></pre>
    <p class="normal">This approach is based on <code class="inlineCode">System.nanoTime()</code> for measuring the elapsed time with high accuracy. This approach returns a high-resolution time in nanoseconds that doesn’t rely on a system clock or any other wall clock (as <code class="inlineCode">Instant.now()</code> or <code class="inlineCode">System.currentTimeMillis()</code> does), so it is not exposed to common issues of wall clocks such as leap second, time uniformity, synchronicity issues, and so on.</p>
    <p class="normal">Whenever you need a professional tool for measuring elapsed time, rely on Micrometer (<a href="https://micrometer.io/"><span class="url">https://micrometer.io/</span></a>), JMH (<a href="https://openjdk.org/projects/code-tools/jmh/"><span class="url">https://openjdk.org/projects/code-tools/jmh/</span></a>), Gatling (<a href="https://gatling.io/open-source/"><span class="url">https://gatling.io/open-source/</span></a>), and so on.</p>
    <h1 id="_idParaDest-152" class="heading-1">78. Extracting the count of milliseconds since midnight</h1>
    <p class="normal">So, we have a date-time (let’s say a <code class="inlineCode">LocalDateTime</code> or <code class="inlineCode">LocalTime</code>) and we want to know how many milliseconds have passed<a id="_idIndexMarker389"/> from midnight to this date-time. Let’s consider that the given date-time is right now:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();
</code></pre>
    <p class="normal">Midnight is relative to <code class="inlineCode">now</code>, so we can find the difference as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">midnight</span> <span class="hljs-operator">=</span> LocalDateTime.of(now.getYear(),
  now.getMonth(), now.getDayOfMonth(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">Finally, compute the difference in milliseconds between midnight and now. This can be accomplished in several ways, but probably the most concise solution relies on <code class="inlineCode">java.time.temporal.ChronoUnit</code>. This API exposes a set of units useful to manipulate a date, time, or date-time including milliseconds:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Millis: "</span> 
  + ChronoUnit.MILLIS.between(midnight, now));
</code></pre>
    <p class="normal">In the bundled code, you can see more examples of <code class="inlineCode">ChronoUnit</code>.</p>
    <h1 id="_idParaDest-153" class="heading-1">79. Splitting a date-time range into equal intervals</h1>
    <p class="normal">Let’s consider a date-time range (bounded by a start date and an end date represented by two <code class="inlineCode">LocalDateTime</code> instances) and<a id="_idIndexMarker390"/> an integer <code class="inlineCode">n</code>. In order to split the given range into <code class="inlineCode">n</code> equal intervals, we start by defining a <code class="inlineCode">java.time.Duration</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Duration</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> Duration.between(start, end);
</code></pre>
    <p class="normal">Having this date-time range, we can rely on <code class="inlineCode">dividedBy()</code> to obtain a copy of it divided by the specified <code class="inlineCode">n</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Duration</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> range.dividedBy(n - <span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">Finally, we can begin from the start date (the left head of the range) and repeatedly increment it with the <code class="inlineCode">interval</code> value until we reach the end date (the right head of the range). After each step, we store the new date in a list that will be returned at the end. Here is the complete code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;LocalDateTime&gt; <span class="hljs-title">splitInEqualIntervals</span><span class="hljs-params">(</span>
<span class="hljs-params">       LocalDateTime start, LocalDateTime end, </span><span class="hljs-type">int</span><span class="hljs-params"> n)</span> {
  <span class="hljs-type">Duration</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> Duration.between(start, end);
  <span class="hljs-type">Duration</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> range.dividedBy(n - <span class="hljs-number">1</span>);
  List&lt;LocalDateTime&gt; listOfDates = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(); 
  <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">timeline</span> <span class="hljs-operator">=</span> start;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
    listOfDates.add(timeline);
    timeline = timeline.plus(interval);
  }
  listOfDates.add(end);
  <span class="hljs-keyword">return</span> listOfDates;
}
</code></pre>
    <p class="normal">The resulting <code class="inlineCode">listOfDates</code> will<a id="_idIndexMarker391"/> contain <code class="inlineCode">n</code> dates at equal intervals.</p>
    <h1 id="_idParaDest-154" class="heading-1">80. Explaining the difference between Clock.systemUTC() and Clock.systemDefaultZone()</h1>
    <p class="normal">Let’s start with the following three lines <a id="_idIndexMarker392"/>of code:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(Clock.systemDefaultZone());
System.out.println(system(ZoneId.systemDefault()));
System.out.println(Clock.systemUTC());
</code></pre>
    <p class="normal">The output reveals that the first two<a id="_idIndexMarker393"/> lines are similar. Both of them display the default time zone (in my case, Europe/Bucharest):</p>
    <pre class="programlisting code"><code class="hljs-code">SystemClock[Europe/Bucharest]
SystemClock[Europe/Bucharest]
</code></pre>
    <p class="normal">The third line is different. Here, we see <code class="inlineCode">Z</code> time zone, which is specific to the UTC time zone and indicates the presence of a zone offset:</p>
    <pre class="programlisting code"><code class="hljs-code">SystemClock[Z]
</code></pre>
    <p class="normal">On the other hand, creating an <code class="inlineCode">Instant</code> reveals that <code class="inlineCode">Clock.systemUTC()</code> and <code class="inlineCode">Clock.systemDefaultZone()</code> produce the same result:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(Clock.systemDefaultZone().instant());
System.out.println(system(ZoneId.systemDefault()).instant());
System.out.println(Clock.systemUTC().instant());
</code></pre>
    <p class="normal">The instant time is the same in all three cases:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-02-07T05:26:17.374159500Z
2023-02-07T05:26:17.384811300Z
2023-02-07T05:26:17.384811300Z
</code></pre>
    <p class="normal">But, the difference occurs <a id="_idIndexMarker394"/>when we try to create a date, time, or<a id="_idIndexMarker395"/> date-time from these two clocks. For instance, let’s create a <code class="inlineCode">LocalDateTime</code> from <code class="inlineCode">Clock.systemUTC()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 2023-02-07T05:26:17.384811300</span>
System.out.println(LocalDateTime.now(Clock.systemUTC()));
</code></pre>
    <p class="normal">And, a <code class="inlineCode">LocalDateTime</code> from <code class="inlineCode">Clock.systemDefaultZone()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 2023-02-07T07:26:17.384811300</span>
System.out.println(LocalDateTime.now(
  Clock.systemDefaultZone()));
</code></pre>
    <p class="normal">My time (default time zone, Europe/Bucharest) is 07:26:17. But, the time via <code class="inlineCode">Clock.systemUTC()</code> is 05:26:17. This is because Europe/Bucharest is at an offset of UTC-2, so <code class="inlineCode">systemUTC()</code> produces the date-time in the UTC time zone, while <code class="inlineCode">systemDefaultZone()</code> produces the date-time in the current default time zone. However, both of them produce the same <code class="inlineCode">Instant</code>.</p>
    <h1 id="_idParaDest-155" class="heading-1">81. Displaying the names of the days of the week</h1>
    <p class="normal">One of the hidden gems in Java is <code class="inlineCode">java.text.DateFormatSymbols</code>. This class is a wrapper for date-time formatting data such as the<a id="_idIndexMarker396"/> names of the days of the week, and the names of the months. All these names are localizable.</p>
    <p class="normal">Typically, you will use <code class="inlineCode">DateFormatSymbols</code> via a <code class="inlineCode">DateFormat</code> such as <code class="inlineCode">SimpleDateFormat</code>, but in order to solve this problem, we can use it directly as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">String[] weekdays = <span class="hljs-keyword">new</span> <span class="hljs-title">DateFormatSymbols</span>().getWeekdays();
IntStream.range(<span class="hljs-number">1</span>, weekdays.length)
    .mapToObj(t -&gt; String.format(<span class="hljs-string">"</span><span class="hljs-string">Day: %d -&gt; %s"</span>,
       t, weekdays[t]))
    .forEach(System.out::println);
</code></pre>
    <p class="normal">This code will output the weekdays’ names as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Day: 1 -&gt; Sunday
...
Day: 7 -&gt; Saturday
</code></pre>
    <p class="normal">Challenge yourself to come up with another solution.</p>
    <h1 id="_idParaDest-156" class="heading-1">82. Getting the first and last day of the year</h1>
    <p class="normal">Getting the first and last day of the<a id="_idIndexMarker397"/> given year (as a numeric value) can be done via <code class="inlineCode">LocalDate</code> and the handy <code class="inlineCode">TemporalAdjusters</code>, <code class="inlineCode">firstDayOfYear()</code>, and <code class="inlineCode">lastDayOfYear()</code>. First, we create a <code class="inlineCode">LocalDate</code> from the given year. Next, we use this <code class="inlineCode">LocalDate</code> with <code class="inlineCode">firstDayOfYear()</code>/<code class="inlineCode">lastDayOfYear()</code> as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">fetchFirstDayOfYear</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year, </span><span class="hljs-type">boolean</span><span class="hljs-params"> name)</span> {
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.ofYearDay(year, <span class="hljs-number">1</span>);
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">firstDay</span> <span class="hljs-operator">=</span> ld.with(firstDayOfYear());
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">return</span> firstDay.toString();
  }
  <span class="hljs-keyword">return</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"EEEE"</span>).format(firstDay);
}
</code></pre>
    <p class="normal">And, for the last day, the code is almost similar:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">fetchLastDayOfYear</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> year, </span><span class="hljs-type">boolean</span><span class="hljs-params"> name)</span> {
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> LocalDate.ofYearDay(year, <span class="hljs-number">31</span>);
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastDay</span> <span class="hljs-operator">=</span> ld.with(lastDayOfYear());
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">return</span> lastDay.toString();
  }
  <span class="hljs-keyword">return</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"EEEE"</span>).format(lastDay);
}
</code></pre>
    <p class="normal">If the flag argument (<code class="inlineCode">name</code>) is <code class="inlineCode">false</code>, then we return the first/last day via <code class="inlineCode">LocalDate.toString()</code>, so we will get something like 2020-01-01 (the first day of 2020) and 2020-12-31 (the last day of 2020). If this flag argument is <code class="inlineCode">true</code>, then we rely on the <code class="inlineCode">EEEE</code> pattern to return only the name<a id="_idIndexMarker398"/> of the first/last day of the year as Wednesday (the first day of 2020) and Thursday (the last day of 2020).</p>
    <p class="normal">In the bundle code, you can also find a solution to this problem via the <code class="inlineCode">Calendar</code> API.</p>
    <h1 id="_idParaDest-157" class="heading-1">83. Getting the first and last day of the week</h1>
    <p class="normal">Let’s assume given an integer (<code class="inlineCode">nrOfWeeks</code>) representing<a id="_idIndexMarker399"/> the number of weeks that we want to extract the first and last day of each week starting from now. For instance, for the given <code class="inlineCode">nrOfWeeks</code> = 3 and a local date such as 06/02/2023, we want this:</p>
    <pre class="programlisting con"><code class="hljs-con">[
Mon 06/02/2023,
Sun 12/02/2023,
Mon 13/02/2023,
Sun 19/02/2023,
Mon 20/02/2023,
Sun 26/02/2023
]
</code></pre>
    <p class="normal">This is much easier than it might seem. We just need a loop from 0 to <code class="inlineCode">nrOfWeeks</code> and two <code class="inlineCode">TemporalAdjusters</code> to fit the first/last day of each week. More precisely, we need the <code class="inlineCode">nextOrSame(DayOfWeek dayOfWeek)</code> and <code class="inlineCode">previousOrSame(DayOfWeek dayOfWeek)</code> adjusters. </p>
    <p class="normal">The <code class="inlineCode">nextOrSame()</code> adjuster’s role is to adjust the current date to the first occurrence of the given <em class="italic">day of week</em> after the date being adjusted (this can be <em class="italic">next or same</em>). On the other hand, the <code class="inlineCode">previousOrSame()</code> adjuster’s role is to adjust the current date to the first occurrence of the given <em class="italic">day of week</em> before the date being adjusted (this can be <em class="italic">previous or same</em>). For instance, if today is [Tuesday 07/02/2023], then <code class="inlineCode">previousOrSame(DayOfWeek.MONDAY)</code> will return [Monday 06/02/2023], and <code class="inlineCode">nextOrSame(DayOfWeek.SUNDAY)</code> will return [Sunday 12/02/2023].</p>
    <p class="normal">Based on these statements, we can solve our problem via the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">weekBoundaries</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> nrOfWeeks)</span> {
  List&lt;String&gt; boundaries = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-type">LocalDate</span> <span class="hljs-variable">timeline</span> <span class="hljs-operator">=</span> LocalDate.now();
  <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter
    .ofPattern(<span class="hljs-string">"</span><span class="hljs-string">EEE dd/MM/yyyy"</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nrOfWeeks; i++) {
    boundaries.add(dtf.format(timeline.with(
      previousOrSame(DayOfWeek.MONDAY))));
    boundaries.add(dtf.format(timeline.with(
      nextOrSame(DayOfWeek.SUNDAY))));
    timeline = timeline.plusDays(<span class="hljs-number">7</span>);
  }
  <span class="hljs-keyword">return</span> boundaries;
}
</code></pre>
    <p class="normal">In the bundled code, you can also<a id="_idIndexMarker400"/> see a solution based on the <code class="inlineCode">Calendar</code> API.</p>
    <h1 id="_idParaDest-158" class="heading-1">84. Calculating the middle of the month</h1>
    <p class="normal">Let’s imagine that we have a <code class="inlineCode">LocalDate</code> and we want to calculate from it another <code class="inlineCode">LocalDate</code> representing the middle of the month. This can be achieved in seconds if we know that the <code class="inlineCode">LocalDate</code> API has a method<a id="_idIndexMarker401"/> named <code class="inlineCode">lengthOfMonth()</code>, which returns an integer representing the length of the month in days. So, all we have to do is calculate <code class="inlineCode">lengthOfMonth()</code>/2 as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDate <span class="hljs-title">middleOfTheMonth</span><span class="hljs-params">(LocalDate date)</span> {
  <span class="hljs-keyword">return</span> LocalDate.of(date.getYear(), date.getMonth(), 
    date.lengthOfMonth() / <span class="hljs-number">2</span>); 
}
</code></pre>
    <p class="normal">In the bundled code, you can see a solution based on the <code class="inlineCode">Calendar</code> API.</p>
    <h1 id="_idParaDest-159" class="heading-1">85. Getting the number of quarters between two dates</h1>
    <p class="normal">This is just another problem that requires<a id="_idIndexMarker402"/> us to have a deep grasp of the Java Date/Time API. This time, we talk about <code class="inlineCode">java.time.temporal.IsoFields</code>, which was introduced in <em class="italic">Problem 73</em>. One of the ISO fields is <code class="inlineCode">QUARTER_YEARS</code>, which is a temporal unit representing the concept of a <em class="italic">quarter-year</em>. So, having two <code class="inlineCode">LocalDate</code> instances, we can write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title">nrOfQuarters</span><span class="hljs-params">(</span>
<span class="hljs-params">    LocalDate startDate, LocalDate endDate)</span> {
  <span class="hljs-keyword">return</span> IsoFields.QUARTER_YEARS.between(startDate, endDate);
}
</code></pre>
    <p class="normal">Feel free to challenge yourself to provide a solution for <code class="inlineCode">java.util.Date</code>/<code class="inlineCode">Calendar</code>.</p>
    <h1 id="_idParaDest-160" class="heading-1">86. Converting Calendar to LocalDateTime</h1>
    <p class="normal">In <em class="italic">Problem 68</em>, you saw that <a id="_idIndexMarker403"/>converting a <code class="inlineCode">java.util.Date</code> (date) to a <code class="inlineCode">LocalTime</code> can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">lt</span> <span class="hljs-operator">=</span> date.toInstant().atZone(zoneId).toLocalTime();
</code></pre>
    <p class="normal">In the same manner, we can convert a <code class="inlineCode">java.util.Date</code> to a <code class="inlineCode">LocalDateTime</code> (here, <code class="inlineCode">zoneId</code> was replaced with <code class="inlineCode">ZoneId.systemDefault()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">ldt</span> <span class="hljs-operator">=</span> date.toInstant().atZone(
  ZoneId.systemDefault()).toLocalDateTime();
</code></pre>
    <p class="normal">We also know that we can obtain a <code class="inlineCode">java.util.Date</code> from a <code class="inlineCode">Calendar</code> via the <code class="inlineCode">getTime()</code> method. So, by gluing the pieces of the puzzle together, we obtain the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalDateTime
       <span class="hljs-title">toLocalDateTime</span><span class="hljs-params">(Calendar calendar)</span> {
  <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> calendar.getTime();
  <span class="hljs-keyword">return</span> date.toInstant().atZone(
    ZoneId.systemDefault()).toLocalDateTime();
}
</code></pre>
    <p class="normal">The same result but following a shorter path can be obtained like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(
  calendar.getTimeInMillis()), ZoneId.systemDefault());
</code></pre>
    <p class="normal">Or, even shorter, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> LocalDateTime.ofInstant(
  calendar.toInstant(), ZoneId.systemDefault());
</code></pre>
    <p class="normal">But, this code assumes that the time zone of the given <code class="inlineCode">Calendar</code> is the default time zone. If the calendar has a different time zone (for instance, Asia/Calcutta), then we might expect back a <code class="inlineCode">ZonedDateTime</code> instead of a <code class="inlineCode">LocalDateTime</code>. This means that we should adjust the previous code accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZonedDateTime
       <span class="hljs-title">toZonedDateTime</span><span class="hljs-params">(Calendar calendar)</span> {
  <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> calendar.getTime();
  <span class="hljs-keyword">return</span> date.toInstant().atZone(
    calendar.getTimeZone().toZoneId());
}
</code></pre>
    <p class="normal">Again, some shorter <a id="_idIndexMarker404"/>versions are available, but we’ve not shown these as they are less expressive:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> ZonedDateTime.ofInstant(
  Instant.ofEpochMilli(calendar.getTimeInMillis()),
    calendar.getTimeZone().toZoneId());
<span class="hljs-keyword">return</span> ZonedDateTime.ofInstant(calendar.toInstant(),
    calendar.getTimeZone().toZoneId());
</code></pre>
    <p class="normal">Done!</p>
    <h1 id="_idParaDest-161" class="heading-1">87. Getting the number of weeks between two dates</h1>
    <p class="normal">If the given two dates are instances of <code class="inlineCode">LocalDate</code>(<code class="inlineCode">Time</code>), then we can rely on <code class="inlineCode">java.time.temporal.ChronoUnit</code>. This API exposes a set of units useful to manipulate a date, time, or date-time and we<a id="_idIndexMarker405"/> have used it before in <em class="italic">Problem 78</em>. This time, let’s use it again to compute the number of weeks between two dates:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title">nrOfWeeks</span><span class="hljs-params">(</span>
<span class="hljs-params">    LocalDateTime startLdt, LocalDateTime endLdt)</span> {
  <span class="hljs-keyword">return</span> Math.abs(ChronoUnit.WEEKS.between(
    startLdt, endLdt));
}
</code></pre>
    <p class="normal">On the other hand, if the given dates are <code class="inlineCode">java.util.Date</code>, then you can choose to convert them to <code class="inlineCode">LocalDateTime</code> and use the previous code or to rely on the <code class="inlineCode">Calendar</code> API. Using the <code class="inlineCode">Calendar</code> API is about looping from the start date to the end date while incrementing the calendar date week by week:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title">nrOfWeeks</span><span class="hljs-params">(Date startDate, Date endDate)</span> {
  <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();
  calendar.setTime(startDate);
  <span class="hljs-type">int</span> <span class="hljs-variable">weeks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (calendar.getTime().before(endDate)) {
    calendar.add(Calendar.WEEK_OF_YEAR, <span class="hljs-number">1</span>);
    weeks++;
  }
  <span class="hljs-keyword">return</span> weeks;
}
</code></pre>
    <p class="normal">When the calendar date is after <a id="_idIndexMarker406"/>the end date, we have the number of weeks.</p>
    <h1 id="_idParaDest-162" class="heading-1">Summary</h1>
    <p class="normal">Mission accomplished! I hope you enjoyed this short chapter filled to the brim with tips and tricks about manipulating date-time in real-world applications. I strongly encourage you to also read the homologous chapter from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, which contains another 20 problems covering other date-time topics.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>