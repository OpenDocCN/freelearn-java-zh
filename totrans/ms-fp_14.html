<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Scala</h1>
                </header>
            
            <article>
                
<p>This book uses Scala extensively as its primary example language. In this chapter, we will briefly overview the language basics. First, we will start from the motivation for using it as an example language.</p>
<p>Following are the topics covered in this chapter:</p>
<ul>
<li>Motivation for using Scala</li>
<li>Variables and functions</li>
<li>Control structures</li>
<li>Inheritance model</li>
</ul>
<p><span>This chapter is supposed to be a quick introduction for the rest of the book, and should not be regarded as a full-size tutorial on Scala.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motivation for using Scala</h1>
                </header>
            
            <article>
                
<p>The primary motivation for using Scala for examples in this book is as follows. First of all, Scala is a functional language. This means that it has support for almost all of the functional programming styles that have been developed so far. Another reason for choosing Scala is that it is designed explicitly with object-oriented programmers in mind. Scala positions itself as a mix between object-oriented and functional languages. This means that new programmers that come from the object-oriented world can use Scala as an object-oriented language. This facilitates the transition from the object-oriented style. In fact, Scala is often used as Java without semicolons, meaning that you can program your Scala programs similarly to how you used to program your Java programs. The preceding reasons facilitate transition for new programmers greatly. Also, Scala features a very powerful mechanics for functional programming. So, you can write functional programs just the way you would do in Haskell.</p>
<p class="mce-root"/>
<p>We can even say that Scala is more potent than Haskell because, in some circumstances, the object-oriented approach is absolutely necessary. You can access the entire JVM infrastructure, meaning that you can use any Java library from Scala easily. The infrastructure is very mature and industry-oriented. Unfortunately, you cannot say the same thing about Haskell, which is less production-ready than JVM languages. Purely functional languages such as Haskell are used in production. However, they do not possess as mature infrastructure, say, for dependency management or compile tools as does Scala. Even though you can use all of the object-oriented libraries from Java in Scala, there is an entire host of native libraries for Scala, which are also production-ready and can facilitate a purely functional programming style.</p>
<p>A final thing about Scala worth mentioning is that it is an experimental language. This means it is often used as a playground to test new features and research in computer science. This means that leading-edge research is available to you as a Scala programmer. Combine that with accessibility to JVM, and you get an ideal tool to advance your knowledge in computer science while developing real-world software.</p>
<p>In short, all of this means that while using Scala, you can use a wide spectrum of styles, from a conventional object-oriented approach all the way to leading edge functional programming research. This makes it a great language for examples in this books.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scala infrastructure</h1>
                </header>
            
            <article>
                
<p>First, let's have a look at the infrastructure developed for Scala. Let's have a look at the Scala interpreter first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scala interpreter</h1>
                </header>
            
            <article>
                
<p>Although Scala is a compiled language, it has its own interpreter. It comes as part of the standard language distribution, and if you install Scala, you will have access to it. Please consult <a href="https://www.scala-lang.org/">https://www.scala-lang.org/</a> on the instructions to install Scala.</p>
<p>You can access the interpreter from the command line by simply typing <kbd>scala</kbd>.</p>
<p class="mce-root"/>
<p>In this interpreter, you can run Scala expressions and get evaluations of them in real time. Besides ordinary expressions, you can run interpreter-specific expressions to tune it up. This kind of expression usually starts with a colon followed by a keyword. To access the list of all the relevant Scala interpreter expressions, type the following command:</p>
<pre><strong>:help<br/></strong></pre>
<p>The output of the preceding command looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/58c25f72-880b-48f2-b4ce-54637cb2e50e.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SBT build tool</h1>
                </header>
            
            <article>
                
<p>SBT is a build tool for Scala. It is a dedicated build tool developed specifically for Scala. It is possible to integrate Scala with Gradle or Maven, and in fact, this is an option that many teams prefer to do. SBT is supposed to be simple, but in fact, it is the precise opposite of simple. If you decide to use SBT as your Scala build tool, be advised that it possesses a complex infrastructure and is not well documented.</p>
<p class="mce-root"/>
<p>However, it is rather powerful. It allows you to write build descriptions in a subset of the Scala language. This means that your build scripts are Scala programs in themselves. This is not something you get with build tools, such as Gradle or Maven.</p>
<p>For this book, we do not need to be familiar with SBT. The GitHub repository with the examples for this books uses SBT, so you will need some basic familiarity with this software to run the examples. However, in this book, we do not feature SBT in parts that are crucial to functional programming. If you want to become more familiar with this tool, please see the official documentation of SBT.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables and functions</h1>
                </header>
            
            <article>
                
<p>The backbone of the Scala language is variables and functions.</p>
<p>The variables are defined as follows:</p>
<pre class="mce-root">scala&gt; var foo = 3<br/>foo: Int = 3</pre>
<p>Variables are defined using the <kbd>var</kbd> keyword followed by the name of the variable, followed by the value you would like to assign to the variable.</p>
<p>Variables defined in the preceding manner are mutable. This means that once they are assigned, you can modify them:</p>
<pre>scala&gt; var foo = 3<br/>foo: Int = 3<br/><br/>scala&gt; foo = 20<br/>foo: Int = 20</pre>
<p>However, purely functional programming advocates against this style. Since Scala positions itself as a mixture of purely functional and object-oriented styles, it offers a way to define an immutable variable:</p>
<pre>scala&gt; val bar = 3<br/>bar: Int = 3</pre>
<p>Now, if <span><span>you </span></span>try to modify is this variable, you will get a compile-time error:</p>
<pre>scala&gt; val bar = 3<br/>bar: Int = 3<br/><br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>scala&gt; bar = 20<br/>&lt;console&gt;:12: error: reassignment to val<br/>       bar = 20</pre>
<p>Besides all of these, Scala has a similar syntax for functions:</p>
<pre>scala&gt; def square(x: Int) = x * x<br/>square: (x: Int)Int<br/><br/>scala&gt; square(10)<br/>res0: Int = 100<br/><br/>scala&gt; square(2)<br/>res1: Int = 4</pre>
<p>So, a function is just like a value. However, it can be parameterized by arguments, and it will evaluate every time you call it. A normal value is evaluated only once.</p>
<p>Value can be modified with a <kbd>lazy</kbd> attribute to make it lazily evaluated:</p>
<pre>scala&gt; val x = { println("x value is evaluated now"); 10 }<br/>x value is evaluated now<br/>x: Int = 10<br/><br/>scala&gt; lazy val x = { println("x value is evaluated now"); 10 }<br/>x: Int = &lt;lazy&gt;<br/><br/>scala&gt; x<br/>x value is evaluated now<br/>res2: Int = 10</pre>
<p>When you do find this way, it is not evaluated right away but at the time when it is called for the first time. In a sense, it is similar to a function in this manner, because it is not evaluated right away. However, a function is evaluated every time we call it, and this can be not said of a value.</p>
<p>In the preceding code, all of their definitions are specified without the types they return. However, Scala is a strongly typed language. The compiler knows the types of all its variables. The compiler of Scala is powerful, and it can infer the types of its values and variables in a wide range of circumstances so that you do not need to provide them explicitly. So, in the preceding code, the compiler infers the types of the values, variables, and functions.</p>
<p>You can explicitly specify the type you would like a variable to have as follows:</p>
<pre>scala&gt; var x: Int = 5<br/>x: Int = 5<br/><br/>scala&gt; var x: String = 4<br/>&lt;console&gt;:11: error: type mismatch;<br/> found : Int(4)<br/> required: String<br/>       var x: String = 4<br/>                       ^<br/><br/>scala&gt; val x: Int = 5<br/>x: Int = 5<br/><br/>scala&gt; def square(x: Int): Int = x * x<br/>square: (x: Int)Int</pre>
<p>Also, notice that when you run the code without an explicit type specification through a Scala interpreter, the result will be aware of the type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Control structures</h1>
                </header>
            
            <article>
                
<p>Similarly to the majority of modern programming languages, the Scala language has a bunch of control structures; for example, for branching and looping. The control structures in question are <kbd>if</kbd>, <kbd>while</kbd>, <kbd>for</kbd>, and pattern matching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">If and While</h1>
                </header>
            
            <article>
                
<p><kbd>if</kbd> and <kbd>while</kbd> are implemented the same way as they are in any other programming language:</p>
<pre>scala&gt; val flag = true<br/>flag: Boolean = true<br/><br/>scala&gt; if (flag) {<br/>     | println("Flag is true")<br/>     | }<br/>Flag is true<br/><br/>scala&gt; if (!flag) {<br/>     | println("Flag is false")<br/>     | } else {<br/>     | println("Flag is true")<br/>     | }<br/>Flag is true<br/><br/>scala&gt; var x: Int = 0<br/>x: Int = 0<br/><br/>scala&gt; while (x &lt; 5) {<br/>     | x += 1<br/>     | println(s"x = $x")<br/>     | }<br/>x = 1<br/>x = 2<br/>x = 3<br/>x = 4<br/>x = 5</pre>
<p>Notice that in such constructs, you can optionally omit the curly braces if the body of the construct is a single expression:</p>
<pre>scala&gt; if (flag) println("Flag is true")<br/>Flag is true</pre>
<p>This is something you can do in many places in Scala. Wherever you have a body that consists of a single expression, you can omit the curly braces around this expression. There are certain exceptions to this rule, however.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">For</h1>
                </header>
            
            <article>
                
<p>The <kbd>for</kbd> statement is a little bit more unconventional. In fact, the <kbd>for</kbd> statement is syntactic sugar for an application of the <kbd>foreach</kbd>, <kbd>map</kbd>, and <kbd>flatMap</kbd> methods. For example, take a look at the following expression:</p>
<pre>scala&gt; val list = 0 to 3<br/>list: scala.collection.immutable.Range.Inclusive = Range 0 to 3<br/><br/>scala&gt; val result =<br/>     | for {<br/>     |   e &lt;- list<br/>     |   list2 = 0 to e<br/>     |   e2 &lt;- list2<br/>     | } yield (e, e2)<br/>result: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((0,0), (1,0), (1,1), (2,0), (2,1), (2,2), (3,0), (3,1), (3,2), (3,3))<br/><br/>scala&gt; println(result.mkString("\n"))<br/>(0,0)<br/>(1,0)<br/>(1,1)<br/>(2,0)<br/>(2,1)<br/>(2,2)<br/>(3,0)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre>(3,1)<br/>(3,2)<br/>(3,3)</pre>
<p>The preceding <kbd>for</kbd> expression expands to the following method applications:</p>
<pre>scala&gt; val result = list.flatMap { e =&gt;<br/>     | val list2 = 0 to e<br/>     | list2.map { e2 =&gt; (e, e2) }<br/>     | }<br/>result: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((0,0), (1,0), (1,1), (2,0), (2,1), (2,2), (3,0), (3,1), (3,2), (3,3))</pre>
<p>So, basically, if a type defines the methods specified in the preceding code, you can write the application in terms of the <kbd>for</kbd> construct. For example, if you take an <kbd>Option</kbd> type that defines <kbd>map</kbd>, <kbd>flatMap</kbd>, and <kbd>foreach</kbd>, you can write a program as follows:</p>
<pre>scala&gt; val opt1 = Some(3)<br/>opt1: Some[Int] = Some(3)<br/><br/>scala&gt; val opt2 = Some(2)<br/>opt2: Some[Int] = Some(2)<br/><br/>scala&gt; val opt3: Option[Int] = None<br/>opt3: Option[Int] = None<br/><br/>scala&gt; val res1 =<br/>     | for {<br/>     |   e1 &lt;- opt1<br/>     |   e2 &lt;- opt2<br/>     | } yield e1 * e2<br/>res1: Option[Int] = Some(6)<br/><br/>scala&gt; val res2 =<br/>     | for {<br/>     |   e1 &lt;- opt1<br/>     |   e3 &lt;- opt3<br/>     | } yield e1 * e3<br/>res2: Option[Int] = None</pre>
<p>The <kbd>for</kbd> construct is not called a loop in Scala, but a Monadic flow. This is due to the special meaning of the <kbd>map</kbd> and <kbd>flatMap</kbd> functions in functional programming.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>Special constructs in Scala are partial functions and pattern matching. For example, you can write expressions as follows:</p>
<pre>scala&gt; val str = "Foo"<br/>str: String = Foo<br/><br/>scala&gt; str match {<br/>     | case "Bar" =&gt; println("It is a bar")<br/>     | case "Foo" =&gt; println("It is a foo")<br/>     | }<br/>It is a foo</pre>
<p>More complex pattern matching is also possible. For example, given a list, we can match on its head and tail, or its head and its second argument and its tail:</p>
<pre>scala&gt; val list = List(1, 2, 3, 4, 5)<br/>list: List[Int] = List(1, 2, 3, 4, 5)<br/><br/>scala&gt; list match {<br/>     | case e1 :: e2 :: rest =&gt; e1 + e2<br/>     | }<br/>&lt;console&gt;:13: warning: match may not be exhaustive.<br/>It would fail on the following inputs: List(_), Nil<br/>       list match {<br/>       ^<br/>res10: Int = 3</pre>
<p>In fact, we can perform pattern matching on virtually anything with the help of so-called extractors. For example, it is possible to match on a custom data type as follows:</p>
<pre>scala&gt; class Dummy(x: Int) { val xSquared = x * x }<br/>defined class Dummy<br/><br/>scala&gt; object square {<br/>     | def unapply(d: Dummy): Option[Int] = Some(d.xSquared)<br/>     | }<br/>defined object square<br/><br/>scala&gt; new Dummy(3) match {<br/>     | case square(s) =&gt; println(s"Square is $s")<br/>     | }<br/>Square is 9</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The semantics of pattern matching is that on runtime, the environment will call the <kbd>unapply</kbd> function on the data type in question, and see whether this function returns some result or whether it is a <kbd>None</kbd>. If some result is returned in an option, the result is used to populate the variables in the pattern matching clause. Otherwise, the pattern is considered not matched.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Partial functions</h1>
                </header>
            
            <article>
                
<p>The preceding pattern matching statements are very close to the notion of partial functions in Scala. The same way pattern matching statements have a certain domain of cases that they can handle and throw an exception in all other cases, partial functions are defined on a part of their input domain. For example, the preceding <kbd>match</kbd> statement can be converted into a partial function, as follows:</p>
<pre>scala&gt; val findSquare: PartialFunction[Any, Int] = {<br/>     | case x: Int =&gt; x * x<br/>     | case square(s) =&gt; s<br/>     | }<br/>findSquare: PartialFunction[Any,Int] = &lt;function1&gt;<br/><br/>scala&gt; findSquare(2)<br/>res12: Int = 4<br/><br/>scala&gt; findSquare(new Dummy(3))<br/>res13: Int = 9<br/><br/>scala&gt; findSquare("Stuff")<br/>scala.MatchError: Stuff (of class java.lang.String)<br/>  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:255)<br/>  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)<br/>  at $anonfun$1.applyOrElse(&lt;console&gt;:13)<br/>  at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:34)<br/>  ... 28 elided</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance model</h1>
                </header>
            
            <article>
                
<p>Scala features a lot of object-oriented functionality. This means it supports inheritance concepts that are core to the object-oriented programming. Moreover, since Scala compiles to the Java Virtual Machine, it is essential that it supports the same model as Java for Java interoperability reasons.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p>Classes in Scala have similar semantics to their Java counterparts. They are defined as follows:</p>
<pre>scala&gt; :paste<br/>// Entering paste mode (ctrl-D to finish)<br/><br/>class Dummy(constructorArgument: String) {<br/>  var variable: Int = 0<br/>  val value: String = constructorArgument * 2<br/>  def method(x: Int): String = s"You gave me $x"<br/>}<br/><br/>// Exiting paste mode, now interpreting.<br/><br/>defined class Dummy<br/><br/>scala&gt; new Dummy("Foo")<br/>res15: Dummy = Dummy@1a2f7e20<br/><br/>scala&gt; res15.variable<br/>res16: Int = 0<br/><br/>scala&gt; res15.value<br/>res17: String = FooFoo<br/><br/>scala&gt; res15.method(2)<br/>res18: String = You gave me 2</pre>
<p>Also, it is possible to define so-called case classes in Scala. These classes are used to represent product types, that is, several types bound together in one datatype. For example, you can define a case class for the <kbd>User</kbd> domain object as follows:</p>
<pre>scala&gt; case class User(id: Int, name: String, passwordHash: String)<br/>defined class User</pre>
<p>As follows from their name, case classes are primarily used for pattern matching. When you are defining a case class, the compiler automatically generates extractors for this class, so that it can be used in pattern matching, as follows:</p>
<pre>scala&gt; val user = User(1, "dummyuser123", "d8578edf8458ce06fbc5bb76a58c5ca4")<br/>user: User = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)<br/><br/>scala&gt; user match {<br/>     | case User(id, name, hash) =&gt; println(s"The user $name has id $id and password hash $hash")<br/>     | }<br/>The user dummyuser123 has id 1 and password hash d8578edf8458ce06fbc5bb76a58c5ca4</pre>
<p>Also, the compiler generates convenient <kbd>toString</kbd>, <kbd>equals</kbd>, and <kbd>hashCode</kbd> methods for case classes:</p>
<pre>scala&gt; user.toString<br/>res20: String = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)<br/><br/>scala&gt; val user2 = User(user.id, user.name, user.passwordHash)<br/>user2: User = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)<br/><br/>scala&gt; user.equals(user2)<br/>res21: Boolean = true<br/><br/>scala&gt; user.hashCode<br/>res22: Int = -363163489<br/><br/>scala&gt; user2.hashCode<br/>res23: Int = -363163489</pre>
<p>Case classes are especially useful when modeling your domain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Traits</h1>
                </header>
            
            <article>
                
<p>The concept of an object-oriented interface is encapsulated in a trait in Scala. Similarly to an interface, a trait can have abstract members. <span>However, unlike Java interfaces, traits may also have concrete members. These are injected into the implementing classes:</span></p>
<pre>scala&gt; :paste<br/>// Entering paste mode (ctrl-D to finish)<br/><br/>trait Foo {<br/>  def saySomething = println("I am inherited from Foo")<br/>}<br/><br/>// Exiting paste mode, now interpreting.<br/><br/>defined trait Foo</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Just like in Java, Scala classes can implement more than one trait. However, since traits in Scala can have concrete members, a new inheritance model that allows for that is required.</p>
<p>In Scala, a so-called linearization model is implemented. This means that whenever a class is inherited from multiple traits, they are organized into a clear sequence, which determines the priority of inheritance. For example, consider the following inheritance case:</p>
<pre>scala&gt; :paste<br/>// Entering paste mode (ctrl-D to finish)<br/><br/>trait Foo {<br/>  def saySomething = println("I am inherited from Foo")<br/>}<br/><br/>trait Bar {<br/>  def saySomething = println("I am inherited from Bar")<br/>}<br/><br/>class Dummy extends Foo with Bar {<br/>  override def saySomething = super.saySomething<br/>}<br/><br/>// Exiting paste mode, now interpreting.<br/><br/>defined trait Foo<br/>defined trait Bar<br/>defined class Dummy<br/><br/>scala&gt; new Dummy().saySomething<br/>I am inherited from Bar</pre>
<p>In this case, the <kbd>Bar</kbd> <span>trait </span>will get a priority over the <kbd>Foo</kbd> <span>trait. </span>This allows you to inherit from multiple traits and be aware of the precise sequence in which they will be applied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Singleton objects</h1>
                </header>
            
            <article>
                
<p>In Scala, it is impossible to make a class have static members. However, the concept of a static member is present in Java. Since Scala compiles to JVM, it needs a way to model this concept from Java. In Scala, a concept of a singleton object is used to model static members:</p>
<pre>scala&gt; :paste<br/>// Entering paste mode (ctrl-D to finish)<br/><br/>object Foo {<br/>  def say = println("I am Foo")<br/>}<br/><br/>// Exiting paste mode, now interpreting.<br/><br/>defined object Foo<br/><br/>scala&gt; Foo.say<br/>I am Foo</pre>
<p>In the preceding code, we can call the members of the singleton object without instantiating it or doing anything else with it, directly by its name. This is because it is a standalone fully fledged object that is constructed by our <kbd>object</kbd> statement. It exists in a single instance for the entire JVM.</p>
<p>The concept of a singleton object can be leveraged to model static members from Java. In Scala, there is a concept of a so-called companion object of a trait or a class. For any trait or class, if you define an object with the same name as the entity in question, it is considered a companion object to it. All of the static members of this class are defined as members of this singleton object. This allows you a clear separation between object and types. No longer can you call a member of a class without instantiating it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we had a brief overview of the Scala programming language, in which the examples in this book are implemented. First of all, we have motivated the usage of Scala as an example language by the fact that it supports a wide range of programming styles.</p>
<p>Next, we had a look at what makes Scala different from other languages. Please keep in mind that this section is meant as a brief overview of the language, and you should use more comprehensive tutorials if you are interested in finding out more about Scala.</p>


            </article>

            
        </section>
    </body></html>