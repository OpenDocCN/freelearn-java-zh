- en: 16\. Predicates and Other Functional Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores all the valid use cases of functional interfaces. It will
    first define what these interfaces are (beginning with the predicate interface),
    as well as how best to employ them in your code. You will then learn how to build
    and apply predicates, studying their composition and how to use this to model
    complex behavior. You will practice creating consumer interfaces to change the
    state of your program, and, eventually, use functions to extract useful constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alongside the many other improvements in Java 8 (such as the streaming API,
    method references, optionals, and collectors) there are interface improvements
    that allow default and static methods known as functional interfaces. These are
    interfaces with one single abstract method, which enables their transformation
    into lambdas. You can read more about this in *Chapter 13*, *Functional Programming
    with Lambda Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a total of 43 unique functional interfaces in the `java.util.function`
    package; most of them are variants of the same kind of interface, albeit with
    different data types. In this chapter, we'll introduce you to the **predicate
    functional interface**, along with a few other selected interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you'll find that many of the functional interfaces operate in very similar
    ways, often just replacing the type of data that the interface can operate on.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The predicate interface is a quite simple, yet surprisingly elegant and complex,
    functional interface that allows you, as a programmer, to define functions that
    describe the state of your program in the shape of Booleans. In Java, speech predicates
    are one-argument functions that return a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The predicate API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the predicate API also utilizes the new interface features of Java
    8\. Its sports default and static functions to enrich the API, allowing more complex
    descriptions of your program''s state. Here, three functions are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With these three functions, you can chain predicates to describe more complex
    queries on your program's state. The `and` function will combine two or more predicates,
    ensuring that every predicate supplied returns true.
  prefs: []
  type: TYPE_NORMAL
- en: The `or` function is equivalent to a logical OR, letting you short-circuit the
    predicate chain when required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `not` function returns the negated version of the predicate supplied,
    and it has the exact same effect as calling `negate()` on the supplied predicate.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `helper` function to build a predicate that checks whether two
    objects are identical according to the `equals` method on said objects. We can
    use the static `isEqual(Object target)` method to build that predicate for two
    objects The following exercise will serve as an example of defining a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Defining a predicate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining a predicate is quite simple. Consider building the backend server
    of a home alarm system. This system needs to easily understand the state of numerous
    different sensors at the same time—instances such as: Is the door open or closed?
    Is the battery healthy or not? Are the sensors connected?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building such a system is a complex task. We''ll try simplifying the process
    in this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started, but no project is open, select `Create New Project`.
    If IntelliJ already has a project open, select `File` -> `New` -> `Project` from
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `New Project` dialog, select a Java project. Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`.
    Click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Chapter16`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location. If you wish to select one,
    you may enter it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter16`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your project will be created with the standard folder structure, and with an
    entry point class for your program. It will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename this file to `Exercise1.java`, making sure to use the `Refactor` | `Rename`
    menu. When you''re done, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The alarm system will have three different kinds of sensors – a `Gateway sensor`,
    a `Movement sensor`, and a `Fire sensor`. They will all have the same basic qualities
    but may differ in certain aspects. Create the `Base` sensor interface and let
    it have two getter/setter pairs. The first pair should be called `batteryHealth`
    and will return an integer between 0 and 100, and the second pair will be a Boolean
    value called `triggered`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Gateway Sensor` class, and allow it to implement the `Sensor` interface
    and return instance variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same thing for the `Movement` and `Fire` sensor classes, except the
    `Fire` sensor will also have the current `temperature`, and the `movement sensor`
    will return the strength of the ambient light in the room:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code for `Movement` class is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add constructors to all three sensor classes, utilizing IntelliJ helpers to
    this end. Open the `Fire` class, use the `Code` | `Generate` menu, and select
    `Constructor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all three variables and click `OK`. Your `Fire` class should now look
    something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generate constructors for the `Gateway` and `Movement` sensors as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have three functioning classes representing sensor states in
    your program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s now time to describe your first predicate class, the predicate that describes
    whether a sensor has a triggered alarm. Create a new class, and call it `HasAlarm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Predicate` interface, using `Sensor` as the type definition.
    In the `test` function, return the trigger status of the sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in your program''s entry point, the `main` method, create a list of sensors
    and add a few `Gateway` sensors to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `for` loop in the main method to iterate through the list. In the `for`
    loop, add an `if` statement that uses the predicate to check whether an alarm
    was triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may very well ask yourself what the point of this is. This is no different
    from using the sensor's `public triggered()` function. This is also an uncommon
    way of applying predicates, but it illustrates how predicates work. A much more
    common approach involves using streams and lambdas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create another predicate and call it `HasWarning`. In this class, we''ll
    simply check whether the battery status is below a threshold of `10`, which will
    symbolize 10% in our example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `HasAlarm` and `HasWarning` predicates to generate a newly composed
    predicate. Instantiate the `HasAlarm` predicate and apply the default `or()` function
    to chain the `HasWarning` predicate as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new `if` statement in the `for` loop using the newly composed predicate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, applying predicates—or any other functional interface,
    for that matter—directly on objects in loops like this is uncommon. Instead you
    will primarily use the Java streams API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Toggling the Sensor States'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rewrite the program once more, adding a scanner to your program to toggle sensor
    states from the command line. Each sensor should be capable of at least toggling
    the battery health and triggered status. When a sensor has updated, you should
    check the system for changes and generate a proper response on the command line
    if a warning or alarm has been triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this Activity can be found on page 565.
  prefs: []
  type: TYPE_NORMAL
- en: Consumer Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In functional programming, we''re often told to avoid side effects in our code.
    The consumer functional interface, however, is an exception to this rule. Its
    only purpose is to produce a side effect based on the state of the argument. The
    consumer has quite a simple API, the core function of which is called `accept()`
    and doesn''t return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be used for chaining multiple consumers by using the `andThen()`
    function, which returns the newly chained consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2: Producing Side Effects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing the previous exercise, consider the following example wherein we
    will add functionality for reacting to warnings and alarms in the system. You
    can use consumers to produce side effects and to store the current state of the
    system in variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `Exercise1.java` class, and call it `Exercise2`. Remove the whole `for`
    loop, but leave the instantiated predicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new static Boolean variable in `Exercise2`, and call it `alarmServiceNotified`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is, of course, not the manner in which you'd commonly apply static variables
    (if you ever really should use static variables). However, in this example, it
    makes it a lot easier to illustrate side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new class, call it `SendAlarm`, and allow it to implement the consumer
    interface. It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `accept(Sensor sensor)` function, check whether the sensor has been
    triggered. If it has been triggered, set the static variable to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the `main` method, instantiate a new `SendAlarm` consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using streams, first, filter the list of sensors based on the previously defined
    composed predicate. Then, use `forEach` to apply the `SendAlarm` consumer to each
    of the sensors that have an alarm or warning triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add an `if` statement, checking whether the alarm service was notified,
    and print a message if it was:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build one more consumer, and this time call it `ResetAlarm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add logic to the `ResetAlarm` `accept()` function to set `batteryHealth` to
    `50` and `Triggered` to `false`. Also, set the static notification variable to
    `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the new `ResetAlarm` consumer, and then apply it after the `SendAlarm`
    consumer using the `andThen()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, a bonus. At the very end of *Exercise 2*, *Producing Side Effects*
    ''s `main` method, apply the negated version of the `hasAlarmOrWarning` predicate,
    and print out an `Everything okay` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function, functional interface (yes, it's called a function) was introduced
    mainly to translate one value into another. It is often used in mapping scenarios.
    It also contains default methods to combine multiple functions into one, and chain
    functions after one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main function in the interface is called `apply`, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It defines a return value, `R`, and an input to the function. The idea is that
    the return value and input don't have to be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition is handled by the `compose` function, which also returns an
    instance of the interface, which means that you can chain compositions. The order
    is right to left; in other words, the argument function is applied before the
    calling function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `andThen` function allows you to chain functions after one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the following exercise, you will practice using these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Extracting Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extract all of the alarm system data as integers—battery percentages, temperatures,
    triggered status, and others, depending on how far you''ve taken your alarm system.
    Start by extracting the battery health data:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `Exercise2` class and call it `Exercise3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove everything except the list of sensors. Your class should look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new class, call it `ExtractBatteryHealth`, and let it implement the
    `Function<T, R>` functional interface. Override the `apply` function. Your class
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `apply` function, make it return the battery health, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate your new `ExtractBatteryHealth` function and add a few more sensors
    to the list if you haven''t already done so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, use the java streams `map` operation and apply your new instance of
    `ExtractBatteryHealth`. Terminate the stream with a `toArray` operation. You should
    now have an array of all your battery health:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print your battery health to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 2: Using a Recursive Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculate the average battery health in your alarm system—either through a loop,
    a stream, or a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 566.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Using a Lambda Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of instantiating the `ExtractBatteryHealth` functional interface, use
    a lambda and store a reference to that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 567.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've explored how to use the functional interfaces provided
    by Java 8\. You've used them both in loops, on single instances, and in streams—all
    of which are valid use cases for functional interfaces. However, you'll quickly
    find that these instances of functional interfaces (lamdas, for short) are more
    commonly used together with streams.
  prefs: []
  type: TYPE_NORMAL
- en: There are many pre-defined functional interfaces in Java, but only a few of
    them are unique in the way they work. Most are just primitive versions of the
    different functions, such as `IntPredicate`, `LongPredicate`, `DoublePredicate`,
    and `Predicate`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn more about the Reactive Streams initiative,
    the Flow API, and what Java does to build good foundational interfaces for reactive
    programming.
  prefs: []
  type: TYPE_NORMAL
