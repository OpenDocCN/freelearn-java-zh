<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Integrating with Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>One of the new features introduced as a part of Spring Framework 5 is the introduction of a new reactive web application framework, Spring WebFlux. WebFlux lives alongside the well-established web application framework Spring MVC. The book aims to introduce reactive parts of Spring Security in which Spring WebFlux is one of the core components.</p>
<p>Making your application reactive brings in an asynchronous nature to your application. Traditional Java applications used threads to achieve parallel and asynchronous nature to the application, however, usage of threads for a web application is not scalable and efficient in any manner.</p>
<p>This chapter starts by introducing you to the core differences between Spring MVC and Spring WebFlux. It then delves into the Spring Security module and how reactive aspects have been brought into it.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Spring MVC versus WebFlux</li>
<li>Reactive support in Spring 5</li>
<li>Spring WebFlux</li>
<li>Spring WebFlux authentication architecture</li>
<li>Spring WebFlux authorization</li>
<li>Sample project</li>
<li>Customization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC versus WebFlux</h1>
                </header>
            
            <article>
                
<p>Spring WebFlux was brought in as part of Spring 5 to bring in a new alternative to existing Spring MVC. Spring WebFlux brings in non-blocking event loop style programming to provide asynchronicity.</p>
<p class="mce-root"/>
<p>Event loop was brought in and made famous by Node.js. Node.js was able to perform non-blocking operations using single-threaded JavaScript by offloading operations to the system kernel whenever possible. The kernel, being multithreaded, is able to do these offloaded operations and after successful execution notifies Node.js through callbacks. There is a constantly running process that checks the call stack (where operations are stacked which need to be executed) and keeps executing processes in <strong><span>First In, First Out</span></strong> (<strong><span>FIFO</span></strong>) manner. If the call stack is empty, it looks into the <em>Event Queue</em> for operations. It picks them up and then moves them to the call stack to be further picked for execution.</p>
<p>The following diagram shows what is in both web application frameworks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png" style="width:45.67em;height:30.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1: Spring MVC and Spring WebFlux</div>
<p>As shown in the preceding figure, Spring MVC is based on the Servlet API (works on thread pools) and Spring WebFlux is based on reactive streams (it works on an event loop mechanism). Both the frameworks, however, supports commonly used annotations such as <kbd>@Controller</kbd> and also support some well-known servers.</p>
<p class="mce-root"/>
<p>Let's see the workings of Spring MVC and Spring WebFlux side-by-side in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bf631caa-8c2b-4e35-ab85-e1374c4005be.png" style="width:31.83em;height:13.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2: Working of Spring MVC and Spring WebFlux</div>
<p>As you can see, the fundamental difference between the working of the two frameworks is that Spring MVC is blocking and Spring WebFlux is non-blocking.</p>
<p>In Spring WebFlux, Servlet APIs behave as an adapter layer, enabling it to support both servlet containers such as <strong>Tomcat</strong> and <strong>Jetty</strong> and non-servlet runtimes such as <strong>Undertow</strong> and <strong>Netty</strong>.</p>
<p>Spring MVC comprises synchronous APIs (Filter, Servlet, and so on) and blocking I/O (<kbd>InputStream</kbd>, <kbd>OutputStream</kbd>, and so on) as against Spring WebFlux's asynchronous APIs (<kbd>WebFilter</kbd>, <kbd>WebHandler</kbd>, and so on) and non-blocking I/O (Reactor Mono for <em>0..1</em> elements and Rector Flux for <em>0..N</em> elements).</p>
<p>Spring WebFlux supports various asynchronous and Reactive APIs, namely Java 9 Flow API, RxJava, Reactor, and Akka Streams. By default, it uses Spring's very own reactive framework, Reactor, and it does do its job quite well:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f8ce06eb-8094-44e7-b218-18d92d1711fa.png" style="width:25.83em;height:7.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3: Spring WebFlux reactive API support</div>
<p>As mentioned earlier, Spring WebFlux was brought in as an alternative to Spring MVC. It doesn't mean in any way that Spring MVC is deprecated. Applications written in Spring MVC can continue running on the same stack without any migration to Spring WebFlux. If needs be, we can bring in reactive coding practices to an existing Spring MVC application by running a reactive client to make calls to remote services.</p>
<p>Now that we have seen the features of the two web application frameworks in Spring, the next section will give an idea as to when to choose what framework while building your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to choose what?</h1>
                </header>
            
            <article>
                
<p>Reactive programming is quite good but that doesn't mean that we have to go reactive for every application. Along the same lines, not all the applications are a good fit for Spring WebFlux. Choose the framework by looking at the requirements and how these frameworks can solve them. If an application is working fine with Spring MVC as a framework, there is no need to port that to Spring WebFlux. In fact, as mentioned earlier, good parts of reactive can be brought into Spring MVC if needs be without much trouble.</p>
<p>Also, if the application already has blocking dependencies (JDBC, LDAP, and so on), then it's better to stick with Spring MVC as there would be complications bringing in reactive concepts. Even if we bring in reactive concepts, many parts of the application are in blocking mode, which will prevent taking full advantage of such a programming paradigm.</p>
<p>Adopt Spring WebFlux if your application deals with streams of data (input and output). Also, consider this as the web application choice if scalability and performance is of utmost importance. By their sheer nature, asynchronous and non-blocking, these applications would be performant compared to synchronous and blocking. Being asynchronous, they can deal with latencies and are more scalable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive support in Spring 5</h1>
                </header>
            
            <article>
                
<p>Spring Framework 5 has extensive support for a reactive programming paradigm. Many of the modules have embraced this concept with both hands and are making it a first-class citizen. The following diagram summarizes the Spring 5 support of reactive:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cc2a49cf-86fc-4206-978d-46f156a7d0ca.png" style="width:40.83em;height:23.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 4: Spring 5 and reactive support</div>
<p>Spring WebFlux module is a full-fledged web application framework built on top of a reactive programming paradigm (it uses Reactor and RxJava). Some of the early adopters of reactive programming in the Spring/Java ecosystem were <strong>Spring Data</strong>, <strong>Spring Security</strong>, and <strong>Thymeleaf</strong>. Spring Security has a number of features that supports reactive programming.</p>
<p>Spring Data has reactive support for Redis, MongoDB, Couchbase, and Cassandra. It also supports infinite streams (records emitted one by one in the form of a stream) from the database with <kbd>@Tailable</kbd>. JDBC inherently is blocking in nature, because of which, Spring Data JPA is blocking and cannot be made reactive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive in Spring MVC</h1>
                </header>
            
            <article>
                
<p>Even though Spring MVC is <span>inherently </span><span>blocking, some aspects can be made reactive by using reactive programming capabilities available as part of Spring 5.</span></p>
<p>In a Spring MVC controller, you can employ reactive types, <kbd>Flux</kbd> and <kbd>Mono</kbd>, as shown in the following diagram. The only rule is that you can use these reactive types only as the controller's return values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a1f41618-09a4-408c-b922-567bdd742bd5.png" style="width:46.42em;height:12.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5: Spring MVC becoming non-blocking with usage of reactive types</div>
<p>Spring MVC annotations such as <kbd>@Controller</kbd>, <kbd>@RequestMapping</kbd>, and so on are also supported in Spring WebFlux. So converting a Spring MVC web application to Spring WebFlux can be done over a period of time in a slow-paced manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux</h1>
                </header>
            
            <article>
                
<p>In this section, we will go into a bit more detail on Spring WebFlux. There are two (programming model) ways by which Spring WebFlux can be used. They are as follows:</p>
<ul>
<li style="font-weight: 400"><strong>Using annotations</strong>: By using annotations such as <kbd>@Controller</kbd> similar to how it is been done in Spring MVC</li>
<li style="font-weight: 400"><strong>Using functional style</strong>: By using routing and handling with Java Lambdas</li>
</ul>
<p>The following code shows the annotation-based style of using Spring WebFlux. We will be going through the entire code sample in subsequent sections in this chapter. This section, however, is aimed at giving an introduction before we delve deeper:</p>
<pre>@RestController<br/>@RequestMapping(value=”/api/movie”)<br/>public class MovieAPI {<br/>    @GetMapping(“/”)<br/>    public Flux(Movie) getMovies() {<br/>        //Logic of getting all movies<br/>    }<br/>    @GetMapping(“/{id}”)<br/>    public Mono&lt;Movie&gt; getMovie(@PathVariable Long id) {<br/>        //Logic for getting a specific movie<br/>    }<br/>    @PostMapping(“/post”)<br/>    public Mono&lt;ResponseEntity&lt;String&gt;&gt; createMovie(@RequestBody Movie movie) {<br/>        // Logic for creating movie<br/>    }<br/>}</pre>
<p>The functional-style programming model of Spring WebFlux uses two fundamental components:</p>
<ul>
<li style="font-weight: 400"><kbd>HandlerFunction</kbd>: Entrusted to handle an HTTP request. Equivalent to <kbd>@Controller</kbd> handler methods we have seen in our previous code snippet.</li>
<li style="font-weight: 400"><kbd>RouterFunction</kbd>: Entrusted to route an HTTP request. Equivalent to <kbd>@RequestMapping</kbd> in annotation-based.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HandlerFunction</h1>
                </header>
            
            <article>
                
<p><span><kbd>HandlerFunction</kbd> accepts a <kbd>ServerRequest</kbd> object and returns <kbd>Mono&lt;ServerResponse&gt;</kbd>. Both <kbd>ServerRequest</kbd> and <kbd>ServerResponse</kbd> objects are immutable and fully reactive, built on top of Reactor.</span></p>
<p><kbd>ServerRequest</kbd> exposes the body as <kbd>Mono</kbd> or <kbd>Flux</kbd>. Traditionally, <kbd>BodyExtractor</kbd> is used to achieve this. However, it also has utility methods which exposes these objects as shown in the following code. <kbd>ServerRequest</kbd> also gives access to all HTTP request elements, such as method, URI, and query string parameters:</p>
<pre>Mono&lt;String&gt; helloWorld = request.body(BodyExtractors.toMono(String.class);<br/>Mono&lt;String&gt; helloWorldUtil = request.bodyToMono(String.class);<br/><br/>Flux&lt;Person&gt; movie = request.body(BodyExtractors.toFlux(Movie.class);<br/>Flux&lt;Person&gt; movieUtil = request.bodyToFlux(Movie.class);</pre>
<p>The <kbd>ServerResponse</kbd> object gives you access to various HTTP responses. The <kbd>ServerResponse</kbd> object can be created by using a builder, which allows setting response status and response headers. It also allows you to set the response body:</p>
<pre>Mono&lt;Movie&gt; movie = ...<br/>ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(movie);</pre>
<p><kbd>HandlerFunction</kbd> can be created using a Lambda function as in the following code and return <kbd>ServerResponse</kbd> with status 200 OK and with a body based on a <kbd>String</kbd>:</p>
<pre>HandlerFunction&lt;ServerResponse&gt; handlerFunction =<br/>  request -&gt; ServerResponse.ok().body(fromObject("Sample HandlerFunction"));</pre>
<p>It is recommended to group all <kbd>HandlerFunction</kbd> objects into a single class having multiple methods, each handling a specific function, as shown in the following code snippet:</p>
<pre>public class MovieHandler {<br/>    public Mono&lt;ServerResponse&gt; listMovies(ServerRequest request) {<br/>        // Logic that returns all Movies objects<br/>    }<br/>    public Mono&lt;ServerResponse&gt; createMovie(ServerRequest request) {<br/>        // Logic that returns creates Movie object in the request object<br/>    }<br/>    public Mono&lt;ServerResponse&gt; getMovie(ServerRequest request) {<br/>        // Logic that returns one Movie object<br/>    }<br/>    //.. More methods as needed<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RouterFunction</h1>
                </header>
            
            <article>
                
<p>Incoming requests are intercepted by <kbd>RouterFunction</kbd>, and, according to the configured route, it is navigated to the right <kbd>HandlerFunction</kbd>. If the route is matched; <kbd>RouterFunction</kbd> takes in <kbd>ServerRequest</kbd> and returns back <kbd>Mono&lt;HandlerFunction&gt;</kbd>. If not, empty <kbd>Mono</kbd> is returned.</p>
<p><kbd>RouterFunction</kbd> is created as shown in the following code snippet:</p>
<pre>RouterFunctions.route(RequestPredicate, HandlerFunction)</pre>
<p><kbd>RequestPredicate</kbd> is a utility class that has predefined matching patterns for most of the common use cases, such as matching based on path, content type, HTTP method, and so on. An example code snippet for <kbd>RouterFunction</kbd> is as follows:</p>
<pre>RouterFunction&lt;ServerResponse&gt; routeFunctionSample =<br/>    RouterFunctions.route(RequestPredicates.path("/sample-route"),<br/>    request -&gt; Response.ok().body(fromObject("Sample Route")));</pre>
<p>Multiple <kbd>RouterFunction</kbd> objects can be composed by invoking the following method:</p>
<pre>RouterFunction.and(RouterFunction)</pre>
<p>There is also a convenient method, as follows, which is a combination of the <kbd>RouterFunction.and()</kbd> and <kbd>RouterFunctions.route()</kbd> methods:</p>
<pre>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</pre>
<p>The <kbd>RouterFunction</kbd> for the previous <kbd>HandlerFunction</kbd> is as follows:</p>
<pre>RouterFunction&lt;ServerResponse&gt; movieRoutes =<br/>    route(GET("/movie/{id}").and(accept(APPLICATION_JSON)), handler::getMovie)<br/>    .andRoute(GET("/movie").and(accept(APPLICATION_JSON)), handler::listMovies)<br/>    .andRoute(POST("/movie").and(contentType(APPLICATION_JSON)), handler::createMovie);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux server support</h1>
                </header>
            
            <article>
                
<p>Spring Webflux supports a number of servers, as follows:</p>
<ul>
<li style="font-weight: 400">Netty</li>
<li style="font-weight: 400">Jetty</li>
<li style="font-weight: 400">Tomcat</li>
<li style="font-weight: 400">Undertow</li>
<li style="font-weight: 400">Servlet 3.1+ containers</li>
</ul>
<p>Spring Boot 2+ uses Netty by default, when the web application framework selected is Spring WebFlux.</p>
<p>The <kbd>RouterFunction</kbd> created can be run on any of the servers listed previously. To do that, <kbd>RouterFunction</kbd> needs to be converted to <kbd>HttpHandler</kbd>, using the following method:</p>
<pre>RouterFunctions.toHttpHandler(RouterFunction)</pre>
<p>If you want to run the previously created <kbd>RouterFunction</kbd> in Netty, the following code snippet can be used:</p>
<pre>HttpHandler httpHandler = RouterFunctions.toHttpHandler(movieRoutes);<br/>ReactorHttpHandlerAdapter reactorAdapter = new ReactorHttpHandlerAdapter(httpHandler);<br/>HttpServer server = HttpServer.create(HOST, PORT);<br/>server.newHandler(reactorAdapter).block();</pre>
<p>When we look at our sample application in subsequent sections of this chapter, we will look at code for other Spring WebFlux supported servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive WebClient</h1>
                </header>
            
            <article>
                
<p>Spring WebFlux includes a reactive client named <kbd>WebClient</kbd>, enabling us to perform HTTP requests in a non-blocking manner and to use reactive streams. <kbd>WebClient</kbd> can be used as an alternative to <kbd>RestTemplate</kbd>, which is used more traditionally. <kbd>WebClient</kbd> exposes reactive <kbd>ClientHttpRequest</kbd> and <kbd>ClientHttpResponse</kbd> objects. The bodies of these objects consist of reactive <kbd>Flux&lt;DataBuffer&gt;</kbd>, as opposed to traditional blocking stream implementation (<kbd>InputStream</kbd> and <kbd>OutputStream</kbd>).</p>
<p>Create an instance of <kbd>WebClient</kbd>, perform a request, and then handle the response. The following is a code snippet showing the <kbd>WebClient</kbd> usage:</p>
<pre>WebClient client = WebClient.create("http://any-domain.com");<br/>Mono&lt;Movie&gt; movie = client.get()<br/>        .url("/movie/{id}", 1L)<br/>        .accept(APPLICATION_JSON)<br/>        .exchange(request)<br/>        .then(response -&gt; response.bodyToMono(Movie.class));</pre>
<p><kbd>WebClient</kbd> can be used from within both Spring MVC and Spring WebFlux web applications. <kbd>RestTemplate</kbd> usage can quite easily be swapped with <kbd>WebClient</kbd>, making use of the reactive advantages it provides.</p>
<p class="mce-root">In our sample project, we will cover the concepts and functionality of <kbd>WebClient</kbd>, using an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive WebTestClient</h1>
                </header>
            
            <article>
                
<p>Similar to <kbd>WebClient</kbd>, Spring WebFlux provides you with a non-blocking, reactive client named <kbd>WebTestClient</kbd>, to test your reactive APIs on your server. It has utilities that make testing these APIs easily in a test environment setup. <kbd>WebTestClient</kbd> can connect to any of the servers, as detailed earlier over an HTTP connection and execute necessary tests. However, the client has the capability of running the tests with and without a running server.</p>
<p><kbd>WebTestClient</kbd> also has a number of utilities to verify the response produced by executing these server side APIs. It can quite easily bind itself to the WebFlux web application and mock necessary request and response objects to ascertain the API's functional aspects. <kbd>WebTestClient</kbd> can mutate the headers as needed, to simulate the desired test environment. You can get an instance of <kbd>WebTestClient</kbd> for your entire application (by using the <kbd>WebTestClient.bindToApplicationContext</kbd> method), or you can restrict it to specific controller (using the <kbd>WebTextClient.bindToController</kbd> method), <kbd>RouterFunction</kbd> (using the <kbd>WebTestClient.bindToRouterFunction</kbd> method), and so on.</p>
<p>We will see a detailed example of how <kbd>WebTestClient</kbd> works in a subsequent hands-on section (The <em>Sample project</em> section, under the <em>Testing (WebTestClient)</em> sub-section).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive WebSocket</h1>
                </header>
            
            <article>
                
<p>Spring WebFlux includes a reactive <kbd>WebSocket</kbd> client and server support based on the Java WebSocket API.</p>
<p>On the server, create <kbd>WebSocketHandlerAdapter</kbd>, and then map each of those handlers to the URL. Since we don't cover <kbd>WebSocket</kbd> in our sample application, let's go into a bit more detail:</p>
<pre>public class MovieWebSocketHandler implements WebSocketHandler {<br/>    @Override<br/>    public Mono&lt;Void&gt; handle(WebSocketSession session) {<br/>        // ...<br/>    }<br/>}</pre>
<p>The <kbd>handle()</kbd> method takes in the <kbd>WebSocketSession</kbd> object and returns <kbd>Mono&lt;Void&gt;</kbd> when the handling of session is complete. <kbd>WebSocketSession</kbd> handles inbound and outbound messages using the <kbd>Flux&lt;WebSocketMessage&gt; receive()</kbd> and <kbd>Mono&lt;Void&gt; send(Publisher&lt;WebSocketMessage&gt;)</kbd> methods, respectively.</p>
<p>In the web application Java configuration, declare a bean for <kbd>WebSocketHandlerAdpater</kbd> and create another bean to map the URL to the appropriate <kbd>WebSocketHandler</kbd>, as shown in the following code snippet:</p>
<pre>@Configuration<br/>static class WebApplicationConfig {<br/>    @Bean<br/>    public HandlerMapping webSockerHandlerMapping() {<br/>        Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;();<br/>        map.put("/movie", new MovieWebSocketHandler());<br/><br/>        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();<br/>        mapping.setUrlMap(map);<br/>        return mapping;<br/>    }<br/>    @Bean<br/>    public WebSocketHandlerAdapter handlerAdapter() {<br/>        return new WebSocketHandlerAdapter();<br/>    }<br/>}</pre>
<p>Spring WebFlux also provides <kbd>WebSocketClient</kbd> and has abstractions for all of the web servers discussed earlier, such as Netty, Jetty, and so on. Use appropriate server abstractions and create the client, as shown in the following code snippet:</p>
<pre>WebSocketClient client = new ReactorNettyWebSocketClient();<br/>URI url = new URI("ws://localhost:8080/movie");<br/>client.execute(url, session -&gt;<br/>        session.receive()<br/>            .doOnNext(System.out::println)<br/>            .then());</pre>
<p>In the client code, we can now subscribe to the <kbd>WebSocket</kbd>, endpoint and listen to messages and do the needful (basic <kbd>WebSocket</kbd> implementation). The code snippet for such a client on the frontend is as follows:</p>
<pre>&lt;script&gt;<br/>   var clientWebSocket = new WebSocket("ws://localhost:8080/movie");<br/>   clientWebSocket.onopen = function() {<br/>       // Logic as needed<br/>   }<br/>   clientWebSocket.onclose = function(error) {<br/>       // Logic as needed<br/>   }<br/>   clientWebSocket.onerror = function(error) {<br/>       // Logic as needed<br/>   }<br/>   clientWebSocket.onmessage = function(error) {<br/>       // Logic as needed<br/>   }<br/>&lt;/script&gt;</pre>
<p class="mce-root">To keep the chapter focused and concise, we will not go over <kbd>WebSocket</kbd> security provided by Spring Security. In the last chapter of this book, we will quickly cover the <kbd>WebSocket</kbd> security, using an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux authentication architecture</h1>
                </header>
            
            <article>
                
<p>With the core Spring WebFlux concepts covered, we will now get into the crux of this chapter; introducing you to Spring Security for Spring WebFlux based reactive web applications.</p>
<p>As seen earlier, Spring Security in Spring MVC web applications is based on ServletFilter, and for Spring WebFlux, it is based on WebFilter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png" style="width:43.25em;height:37.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6: Spring MVC and Spring WebFlux authentication approach</div>
<p>We saw Spring Security in detail in Spring MVC web applications in previous chapters. We will now look at the inner details of Spring Security authentication for a Spring WebFlux based web application. The following diagram shows the interaction of various classes when an authentication process kicks in for a WebFlux application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png" style="width:49.92em;height:27.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7: Spring WebFlux authentication architecture</div>
<p>The preceding diagram is quite self-explanatory, and is very similar to what you saw earlier for Spring MVC. The core difference is that <kbd>ServletFilter</kbd> is now replaced with <kbd>WebFilter</kbd>, and we have reactive-based classes for other blocking classes in Spring MVC. However, the core concepts of Spring Security remain intact with <kbd>WebFilter</kbd> dealing with many aspects in the initial authentication process; the core authentication is handled by <kbd>ReactiveAuthenticationManager</kbd> and related classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring WebFlux authorization</h1>
                </header>
            
            <article>
                
<p>Similar to authentication, the core concepts, in regard to authorization remains similar to what we have seen earlier in Spring MVC. However, the classes performing the operation have changed, and are, reactive and non-blocking. The following diagram shows the authorization-related main classes and their interactions in a Spring WebFlux application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png" style="width:45.00em;height:25.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 8: Authorization-related classes in a Spring WebFlux application</div>
<p>As we all know by now, Spring WebFlux security works on <kbd>WebFilter</kbd>, and <kbd>AuthorizationWebFilter</kbd> intercepts the request and uses <kbd>ReactiveAuthorizationManager</kbd> to check whether the <kbd>Authentication</kbd> object has access to a protected resource. <kbd>ReactiveAuthorizationManager</kbd> has two methods, namely, <kbd>check</kbd> (checks whether access is granted to an <kbd>Authentication</kbd> object) and <kbd>verify</kbd><em> </em>(checks whether access has to be granted for an <kbd>Authentication</kbd> object). In the event of any exception, <kbd>ExceptionTranslationWebFilter</kbd> takes care of handling this by following the appropriate paths.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample project</h1>
                </header>
            
            <article>
                
<p>Enough explanation; it's time to get our hands dirty with actual code. In this section, we will create a movie catalog site with integrated Spring Security. We will be using reactive concepts throughout and will use form-based login. We will start with hardcoded users and then see how we can look at a persistent user store to authenticate the users against. We will then into testing in more detail and finally look at some customizations that we can bring to Spring Security pages. Finally, we will touch base on authorization aspects and close the sample application.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebFlux project setup</h1>
                </header>
            
            <article>
                
<p>We will create a basic WebFlux-based web application first, and will slowly add other features, including security, in it. The whole code is available in our book's GitHub page, under the chapter's folder, namely <kbd>spring-boot-webflux</kbd>.</p>
<p>I am using IntelliJ as my IDE, and since we are using <em>Lombok library</em> (annotation <kbd>preprocessor</kbd>), make sure to enable the Lombok plugin, so as to generate appropriate boilerplate code for your model. Our project is kept quite simple, and does the function of movie management (the movie CRUD operation).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven setup</h1>
                </header>
            
            <article>
                
<p>Using Spring Initializr for generating a Spring WebFlux project is really easy. But for us to get a handle on the various aspects of a WebFlux application, we will build aspect by ourselves. However, we will be using Spring Boot to run our application.</p>
<p>We will create a maven project, and will then add the following main dependencies (to make the code shorter, only important dependencies are shown in the following code) to our <kbd>pom.xml</kbd>:</p>
<pre>&lt;!--Spring Framework and Spring Boot--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;!--JSON--&gt;<br/>&lt;dependency&gt;<br/>…<br/>&lt;/dependency&gt;<br/>&lt;!--Logging--&gt;<br/>&lt;dependency&gt;<br/>…<br/>&lt;/dependency&gt;<br/>&lt;!--Testing--&gt;<br/>&lt;dependency&gt;<br/>…<br/>&lt;/dependency&gt;</pre>
<p>We will include snapshot repositories for both the library and plugin dependencies. Finally, we will add the all-important maven plugin for our Spring Boot, as follows:</p>
<pre>&lt;build&gt;<br/>  &lt;plugins&gt;<br/>      &lt;plugin&gt;<br/>          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>          &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>      &lt;/plugin&gt;<br/>  &lt;/plugins&gt;<br/>&lt;/build&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration class</h1>
                </header>
            
            <article>
                
<p>Even though we are going to use default configurations as much as possible, we will still have separate configuration classes for various components. In our project, we are building a basic WebFlux application, thus we have only one configuration class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The SpringWebFluxConfig class</h1>
                </header>
            
            <article>
                
<p>The main configuration class for a Spring WebFlux web application is achieved by this class:</p>
<pre>@Configuration<br/>@EnableWebFlux<br/>@ComponentScan<br/>public class SpringWebFluxConfig {<br/>  // ...<br/>}</pre>
<p>We have an empty class with just some very important annotations as shown in the preceding code. <kbd>@EnableWebFlux</kbd> makes the application reactive and makes it WebFlux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Repository</h1>
                </header>
            
            <article>
                
<p>We will be using hardcoded movies as our data structure for this sample and will write methods in a reactive way, to expose methods in our repository class. These methods can be used to manipulate the data structure of the movies. Our repository class is a conventional one, but the right data structures, in the form of <kbd>Mono</kbd> and <kbd>Flux</kbd>, aid in bringing a reactive nature to the application:</p>
<pre>@Repository<br/>public class MovieRepositoryImpl implements MovieRepository {<br/>    private Map&lt;Long, Movie&gt; movies = new HashMap&lt;Long, Movie&gt;();<br/><br/>    @PostConstruct<br/>    public void initIt() throws Exception {<br/>      movies.put(Long.valueOf(1), new Movie(Long.valueOf(1), "Moonlight",     <br/>        "Drama"));<br/>      movies.put(Long.valueOf(2), new Movie(Long.valueOf(2), "Dunkirk", <br/>        "Drama/Thriller"));<br/>      movies.put(Long.valueOf(3), new Movie(Long.valueOf(3), "Get Out", <br/>        "Mystery/Thriller"));<br/>      movies.put(Long.valueOf(4), new Movie(Long.valueOf(4), "The Shape of <br/>        Water", "Drama/Thriller"));<br/>    }<br/>    @Override<br/>    public Mono&lt;Movie&gt; getMovieById(Long id) {<br/>        return Mono.just(movies.get(id));<br/>    }<br/>    //...Other methods<br/>}</pre>
<p>The class is just a snippet extracted from the class, and shows only one method (<kbd>getMovieById</kbd>). As always, our class implements an interface (<kbd>MovieRepository</kbd>), and this reference will be used in other parts of the application (using Spring's Dependency Injection capability).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handler and router</h1>
                </header>
            
            <article>
                
<p>As detailed previously, we have two approaches, namely <strong>functional-based</strong> and <strong>annotation-based</strong>, for implementing a WebFlux application. Annotation-based is similar to Spring MVC, and because of this, we will be using functional-based approach in our sample application:</p>
<pre>@Component<br/>public class MovieHandler {<br/>    private final MovieRepository movieRepository;<br/><br/>    public MovieHandler(MovieRepository movieRepository) {<br/>        this.movieRepository = movieRepository;<br/>    }<br/>    public Mono&lt;ServerResponse&gt; listMovies(ServerRequest request) {<br/>        // fetch all Movies from repository<br/>        Flux&lt;Movie&gt; movies = movieRepository.listMovies();<br/>        // build response<br/>        return <br/>            ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)<br/>            .body(movies, Movie.class);<br/>    }<br/>    //...Other methods<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The class is quite straightforward and uses a repository class for data structure query and manipulation. Each method accomplishes the functionality, and finally returns <kbd>Mono&lt;ServerResponse&gt;</kbd>. Another important aspect of WebFlux in functional-based programming is the routing configuration class, as follows:</p>
<pre>@Configuration<br/>public class RouterConfig {<br/><br/>    @Bean<br/>    public RouterFunction&lt;ServerResponse&gt; routerFunction1(MovieHandler <br/>        movieHandler) {<br/>      return <br/>        route(GET("/").and(accept(MediaType.APPLICATION_JSON)), <br/>            movieHandler::listMovies)<br/>        .andRoute(GET("/api/movie").and(accept(MediaType.APPLICATION_JSON)), <br/>            movieHandler::listMovies)<br/>        .andRoute(GET("/api/movie/{id}").and(accept(MediaType.APPLICATION_JSON)), <br/>            movieHandler::getMovieById)<br/>        .andRoute(POST("/api/movie").and(accept(MediaType.APPLICATION_JSON)), <br/>            movieHandler::saveMovie)<br/>        .andRoute(PUT("/api/movie/{id}").and(accept(MediaType.APPLICATION_JSON)), <br/>            movieHandler::putMovie)<br/>        .andRoute(DELETE("/api/movie/{id}")<br/>            .and(accept(MediaType.APPLICATION_JSON)), movieHandler::deleteMovie);<br/>    }<br/>}</pre>
<p>This is the class that looks at the request and routes it to the appropriate handler method. In your application, you can have any number of router configuration files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrap application</h1>
                </header>
            
            <article>
                
<p>Our sample application uses Spring Boot. Spring WebFlux runs on a Reactor Netty server within Spring Boot by default. Our Spring Boot class is very basic and is as follows:</p>
<pre>@SpringBootApplication<br/>public class Run {<br/>  public static void main(String[] args) {<br/>      SpringApplication.run(Run.class, args);<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>You can run the application on any other server, apart from Spring Boot, and it is quite easy to achieve. We have a separate project named <kbd>spring-boot-tomcat-webflux</kbd> that runs on Spring Boot, but rather than running on Reactor Netty, it runs on a Tomcat server.</p>
<p>No change is required in any part of the code, apart from <kbd>pom.xml</kbd>:</p>
<pre>&lt;!--Spring Framework and Spring Boot--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>  &lt;exclusions&gt;<br/>      &lt;exclusion&gt;<br/>          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>          &lt;artifactId&gt;spring-boot-starter-reactor-netty&lt;/artifactId&gt;<br/>      &lt;/exclusion&gt;<br/>  &lt;/exclusions&gt;<br/>&lt;/dependency&gt;<br/>&lt;!--Explicit Tomcat dependency--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>From the <kbd>spring-boot-starter-webflux</kbd> artifact, exclude Reactor Netty. Thereafter, explicitly add the Tomcat dependency, <kbd>spring-boot-starter-tomcat</kbd>. The rest of the <kbd>pom.xml</kbd> is kept intact. For other server runtimes, such as Undertow, Jetty, and so on, the approach is similar to the one detailed here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Now, for the most important part: running the application that we built. As it is a Spring Boot application, execute the default command as follows:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>Once the server has started (default Rector Netty or Tomcat), open a browser and navigate to <kbd>localhost:8080/movies</kbd>. We have created default routing to point to "list all movies" endpoint and if all went well, you should see the JSON which shows all the hardcoded movies in our repository class.</p>
<p>In this section, we have created a sample Spring WebFlux movie application. We will add the all important security to this application in the next section.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding security</h1>
                </header>
            
            <article>
                
<p>To separate from what we have achieved up until now, we will have a separate project, <kbd>spring-boot-security-webflux</kbd> (the same as <kbd>spring-boot-webflux</kbd>). In it we will build all the security aspects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration classes</h1>
                </header>
            
            <article>
                
<p>We will be creating a new configuration class for Spring Security: <kbd>SpringSecurityWebFluxConfig</kbd>. Firstly, we will annotate the class with the most important annatation: <kbd>@EnableWebFluxSecurity</kbd>. This instructs it to enable Spring Security for WebFlux web applications. In the configuration class, we will look at two important beans, as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UserDetailsService bean</h1>
                </header>
            
            <article>
                
<p>We will use hardcoded user details, against which we will authenticate. This is not how it has to be done for a production-ready application, but for simplicity and to explain the concepts, let's take this shortcut:</p>
<pre>@Bean<br/>public MapReactiveUserDetailsService userDetailsRepository() {<br/>    UserDetails user = User.withUsername("user")<br/>        .password("{noop}password").roles("USER").build();<br/>    UserDetails admin = User.withUsername("admin")<br/>        .password("{noop}password").roles("USER","ADMIN").build();<br/>    return new MapReactiveUserDetailsService(user, admin);<br/>}</pre>
<p>The bean returns the reactive user details service, containing hardcoded credentials for two users; one a normal user and the other an admin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The SpringSecurityFilterChain bean</h1>
                </header>
            
            <article>
                
<p>This is the bean where we actually specify the Spring Security configuration:</p>
<pre>@Bean<br/>SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) <br/>    throws Exception {<br/>    return http<br/>      .authorizeExchange()<br/>      .pathMatchers(HttpMethod.GET, "/api/movie/**").hasRole("USER")<br/>      .pathMatchers(HttpMethod.POST, "/api/movie/**").hasRole("ADMIN")<br/>      .anyExchange().authenticated()<br/>      .and().formLogin()<br/>      .and().build();<br/>}</pre>
<p>Similar to what we saw earlier, in the Spring MVC application earlier, we match URL patterns and specify the role that is needed to access it. We are configuring the login method as a form in which the user will be shown the default login form by Spring Security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Execute the following command:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>When the server starts up, you have two ways in which you can test the application, as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CURL</h1>
                </header>
            
            <article>
                
<p>Open your favorite Command Prompt and execute the following command:</p>
<pre><strong>curl http://localhost:8080/ -v</strong></pre>
<p>You will be redirected to the <kbd>http://localhost:8080/login</kbd> page. Your entire application is secured and without logging in, you will not be able to access any content. With form login as the method, you won't be able to test it using <kbd>curl</kbd>. Let's change the login method from form (<kbd>formLogin</kbd>) to basic (<kbd>httpBasic</kbd>) in the Spring Security configuration (the <kbd>springWebFilterChain</kbd> bean). Now, execute the following command:</p>
<pre><strong>curl http://localhost:8080/api/movie -v -u admin:password</strong></pre>
<p>You should now see the raw JSON displaying all of the hardcoded movies. Use other common CURL commands, as follows, to test other endpoints:</p>
<pre><strong>curl http://localhost:8080/api/movie/1 -v -u admin:password</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Browser</h1>
                </header>
            
            <article>
                
<p>Let's put the login method <span>back</span><span> </span><span>to form, and then open a browser and navigate to</span> <kbd>http://localhost:8080</kbd><span>. You will be navigated to the default Spring Security login page. Enter the username as <kbd>admin</kbd> and the password as <kbd>password</kbd>, and click on <span class="packt_screen">Sign in</span>:</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fe1f91c0-67a5-4870-8c70-74d01fe378db.png" style="width:25.42em;height:21.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9: Default Spring Security login form</div>
<p>After successfully logging in, you will be navigated to the list all movies endpoint, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png" style="width:24.67em;height:24.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10: List all movies default home page after login</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebClient</h1>
                </header>
            
            <article>
                
<p>On the book's GitHub page, we have a separate project (<kbd>spring-boot-security-webclient-webflux</kbd>), in which you can see the entire code that will be detailed in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven setup</h1>
                </header>
            
            <article>
                
<p>Create a base maven project and add the following main dependency to your <kbd>pom.xml</kbd> file:</p>
<pre>&lt;!--Spring Framework and Spring Boot--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Now, add other dependencies, as well as the default Spring Boot build section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a WebClient instance</h1>
                </header>
            
            <article>
                
<p>A <kbd>WebClient</kbd> instance can be created by using the <kbd>create()</kbd> method, or by using the <kbd>builder()</kbd> method. In our sample, we have used the <kbd>builder()</kbd> method, as follows:</p>
<pre>@Service<br/>public class WebClientTestImpl implements WebClientTestInterface {<br/>    private final WebClient webClient;<br/>    public WebClientTestImpl(WebClient.Builder webClientBuilder) {<br/>        this.webClient = webClientBuilder.defaultHeader(HttpHeaders.ACCEPT,     <br/>        MediaType.APPLICATION_JSON_VALUE)<br/>              .baseUrl("http://localhost:8080/api/movie").build();<br/>    }<br/>    //...Other methods<br/>}</pre>
<p>We will be using all of the endpoints that we have created earlier in our base Spring WebFlux project, and will be accessing them using the <kbd>WebClient</kbd>.</p>
<p>Use the <kbd>create()</kbd> method to create an instance of <kbd>WebClient</kbd>, as follows:</p>
<pre>WebClient webClient = WebClient.create();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If you have a base URL, <kbd>WebClient</kbd> can be created as follows:</p>
<pre>WebClient webClient = WebClient.create("http://localhost:8080/api/movie");</pre>
<p>The <kbd>builder()</kbd> method provides bunch of utility methods, such as filters, setting headers, setting cookies, and so on. In our example, we have set some default headers and have also set the base URL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors</h1>
                </header>
            
            <article>
                
<p>A <kbd>WebClient</kbd> instance allows you to handle errors (the <kbd>WebClientTestImpl</kbd> class) in the <kbd>listMovies()</kbd> method, as follows:</p>
<pre>@Override<br/>public Flux&lt;Movie&gt; listMovies() {<br/>    return webClient.get().uri("/")<br/>        .retrieve()<br/>        .onStatus(HttpStatus::is4xxClientError, clientResponse -&gt;<br/>            Mono.error(new SampleException())<br/>        )<br/>        .onStatus(HttpStatus::is5xxServerError, clientResponse -&gt;<br/>            Mono.error(new SampleException())<br/>        )<br/>        .bodyToFlux(Movie.class);<br/>}</pre>
<p><kbd>SampleException</kbd> is a custom exception class that we created by extending the <kbd>Exception</kbd> class. We are handling 4xx and 5xx errors, and, when encountered, it sends the custom exception as response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending requests and retrieving responses</h1>
                </header>
            
            <article>
                
<p>The <kbd>retrieve()</kbd> method is a simple method, using which the response body can be retrieved. If you want to have more control over returned responses, the <kbd>exchange()</kbd> method can be used to retrieve the response. We have used both of the methods in our sample application; the code snippets for the two methods in the <kbd>WebClientTestImpl</kbd> class are as follows:</p>
<pre>@Override<br/>public Mono&lt;Movie&gt; getMovieById(Long id) <br/>  return this.webClient.get().uri("/{id}", id)<br/>          .retrieve().bodyToMono(Movie.class);<br/>}<br/>@Override<br/>public Mono&lt;Movie&gt; saveMovie(Movie movie) {<br/>  return webClient.post().uri("/")<br/>          .body(BodyInserters.fromObject(movie))<br/>          .exchange().flatMap( clientResponse -&gt;     <br/>            clientResponse.bodyToMono(Movie.class) );<br/>}</pre>
<p>In the first method, we execute a GET method on the URI <kbd>http://localhost:8080/api/movie/{id}</kbd>, use the <kbd>retrieve()</kbd> method, and then convert into <kbd>Mono</kbd>.</p>
<p>In the second method, we execute a POST method on the URL <kbd>http://localhost:8080/api/movie</kbd>, use the <kbd>exchange()</kbd> method, and use the <kbd>flatMap()</kbd> method to create the response.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running and testing the application</h1>
                </header>
            
            <article>
                
<p>We will be using the same movie model in this sample project. Since this is the only class that we need from our previous sample application, we will copy the class here. In an ideal scenario, we would have a JAR file containing all common classes, and it can be included in our <kbd>pom.xml</kbd> file.</p>
<p>Create the <kbd>Run</kbd> class (as seen earlier) and call the <kbd>WebClient</kbd> methods. The code snippet for one of the methods is as follows:</p>
<pre>@SpringBootApplication<br/>public class Run implements CommandLineRunner {<br/>  @Autowired<br/>  WebClientTestInterface webClient;<br/>  public static void main(String[] args) {<br/>      SpringApplication.run(Run.class, args);<br/>  }<br/>  @Override<br/>  public void run(String... args) throws Exception {<br/>      // get all movies<br/>      System.out.println("Get All Movies");<br/>      webClient.listMovies().subscribe(System.out::println);<br/>      Thread.sleep(3000);<br/>      … Other methods<br/>  }<br/>  //… Other WebClient methods getting called<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>After executing each <kbd>WebClient</kbd> call, we will sleep for three seconds. Since <kbd>WebClient</kbd> methods emit reactive types (<kbd>Mono</kbd> or <kbd>Flux</kbd>), you have to subscribe, as shown in the preceding code.</p>
<p>Start the <kbd>spring-boot-webflux</kbd> project, exposing the endpoints, which we will test by using <kbd>WebClient</kbd> in this project.</p>
<p>Make sure that your application's default port is changed in your <kbd>application.properties</kbd> file by including the following entry:</p>
<pre><strong>server.port=8081</strong></pre>
<p>Start the application by executing the Spring Boot command, as follows:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>If all goes well, you should see the output in the server console, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/22f55554-5b13-4aa5-aeeb-10c9acc37545.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 11: WebClient test execution</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing (WebTestClient)</h1>
                </header>
            
            <article>
                
<p>In our base <kbd>spring-boot-webflux</kbd> project, we have written test cases using <kbd>WebTestClient</kbd>. We have two test cases: one to get all movies, and other to save movie.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependency</h1>
                </header>
            
            <article>
                
<p>Make sure that you have the following dependencies in your <kbd>pom.xml</kbd> file:</p>
<pre>&lt;!--Testing--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;junit&lt;/groupId&gt;<br/>  &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.skyscreamer&lt;/groupId&gt;<br/>  &lt;artifactId&gt;jsonassert&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;<br/>  &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>As you can see, in the preceding code, all of the dependencies can be scoped for testing purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Test class</h1>
                </header>
            
            <article>
                
<p>Create a normal test class, as follows. Use the <kbd>@Autowired</kbd> annotation to inject the <kbd>WebTestClient</kbd> instance in your test class:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>@FixMethodOrder(MethodSorters.NAME_ASCENDING)<br/>public class WebclientDemoApplicationTests {<br/>  @Autowired<br/>  private WebTestClient webTestClient;<br/>  @Test<br/>  public void getAllMovies() {<br/>      System.out.println("Test 1 executing getAllMovies");<br/>      webTestClient.get().uri("/api/movie")<br/>              .accept(MediaType.APPLICATION_JSON)<br/>              .exchange()<br/>              .expectStatus().isOk()<br/>              .expectHeader().contentType(MediaType.APPLICATION_JSON)<br/>              .expectBodyList(Movie.class);<br/>  }<br/>  @Test<br/>  public void saveMovie() {<br/>      System.out.println("Test 2 executing saveMovie");<br/>      Movie movie = new Movie(Long.valueOf(10), "Test Title", "Test Genre");<br/>      webTestClient.post().uri("/api/movie")<br/>              .body(Mono.just(movie), Movie.class)<br/>              .exchange()<br/>              .expectStatus().isOk()<br/>              .expectBody();<br/>  }<br/>}</pre>
<p>The <kbd>WebTestClient</kbd> object's functionality is similar to <kbd>WebClient</kbd>, as seen earlier. We can check for various properties in the response to ascertain what we want to test. In the preceding example, for the first test, we are firing a GET request and checking for OK status, an application/JSON content type header, and, finally, a body having a list of <kbd>Movie</kbd> objects. In the second test, we are firing a POST request with a <kbd>Movie</kbd> object as the body, and, expecting an OK status and an empty body.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data</h1>
                </header>
            
            <article>
                
<p>Even though this book is focused on Spring Security on reactive concepts, I really want you to have some idea of reactive concepts in other areas as well. So, there is a separate project, <kbd>spring-boot-security-mongo-webflux</kbd>, which looks at implementing reactive concepts by integrating the earlier project with reactive MongoDB, using Spring Data. Covering every aspect in regard to this is not something that we will do. However, with the earlier project as a base, we will cover some of the important aspects in this section.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven dependency</h1>
                </header>
            
            <article>
                
<p>In your application <kbd>pom.xml</kbd>, add the following dependencies, both dealing with MongoDB inclusion into the project:</p>
<pre>&lt;!--Mongo--&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;<br/>  &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>I have installed MongoDB on my machine. I have started the database locally on the default port (<kbd>27017</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongoDB configuration</h1>
                </header>
            
            <article>
                
<p>Add the following to your application.properties file:</p>
<pre><strong>spring.data.mongodb.uri=mongodb://localhost:27017/movie</strong></pre>
<p>We will be pointing our DB to a locally running DB on the default port utilizing the movie database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a model</h1>
                </header>
            
            <article>
                
<p>In our already existing <kbd>Movie</kbd> model, we just added one more annotation: <kbd>@Document(collection = "movies")</kbd>. This annotation will inform MongoDB as to the name of the collection in the DB where this model will be stored.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a repository</h1>
                </header>
            
            <article>
                
<p>We will create a new repository, <kbd>ReactiveMovieRepository</kbd>, with our two curated methods and all of the default methods provided by our extended class:</p>
<pre>@Repository<br/>public interface ReactiveMovieRepository extends <br/>    ReactiveMongoRepository&lt;Movie, Long&gt; {<br/>      @Query("{ 'title': ?0, 'genre': ?1}")<br/>      Flux&lt;Movie&gt; findByTitleAndGenre(String title, String genre);<br/>      @Query("{ 'genre': ?0}")<br/>      Flux&lt;Movie&gt; findByGenre(String genre);<br/>}</pre>
<p>We will extend our repository from <kbd>ReactiveMongoRepository</kbd>. <kbd>ReactiveMongoRepository</kbd> has loads of common methods that can be used right away, without any trouble. The methods that we have implemented use plain queries against the MongoDB and return the list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a controller</h1>
                </header>
            
            <article>
                
<p>To make it separate from our existing functional-based programming, we have created a new controller that will expose some of the methods in a RESTful way, using the newly created <kbd>ReactiveMovieRepository</kbd>:</p>
<pre>@RestController<br/>public class MovieController {<br/>  @Autowired<br/>  private ReactiveMovieRepository reactiveMovieRepository;<br/>  @GetMapping("/movies")<br/>  public Flux&lt;Movie&gt; getAllMovies() {<br/>      return reactiveMovieRepository.findAll();<br/>  }<br/>  @GetMapping("/movies/{genre}")<br/>  public Flux&lt;Movie&gt; getAllMoviesByGenre(@PathVariable String genre) {<br/>      return reactiveMovieRepository.findByGenre(genre);<br/>  }<br/>  @GetMapping("/movies/{title}/{genre}")<br/>  public Flux&lt;Movie&gt; getAllMoviesByTitleAndGenre<br/>    (@PathVariable String title, @PathVariable String genre) {<br/>      return reactiveMovieRepository.findByTitleAndGenre(title, genre);<br/>  }<br/>  @PostMapping("/movies")<br/>  public Mono&lt;Movie&gt; createMovies(@Valid @RequestBody Movie movie) {<br/>      return reactiveMovieRepository.save(movie);<br/>  }<br/>}</pre>
<p>The class is quite straightforward; each method has appropriate mapping and uses corresponding repository classes to actually do the job.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Using the <kbd>mongod</kbd> command, we will start the locally installed MongoDB and then using the following command, we will start the project we just created:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>Head over to postman and call the URL <kbd>http://localhost:8080/movies</kbd> (GET). You will see an array with zero elements in it. Now, call the URL <kbd>http://localhost:8080/movies</kbd> (POST), with the following JSON in the body:</p>
<pre>{<br/>   "id": 1,<br/>   "title": "testtitle",<br/>   "genre": "thriller"<br/>}</pre>
<p>You will get a 200 OK status, and should see the newly created JSON as a response. Now, if you run the GET request on movies endpoint, you should see the newly created <kbd>Movie</kbd> as a response.</p>
<p>Here, we implemented CRUD in our <kbd>Movie</kbd> model by using MongoDB as a persistence store in a reactive programming paradigm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>In the past, we already saw that using the <kbd>@EnableWebFluxSecurity</kbd> annotation, we can get URL security. Spring Security also allows you to secure method execution in a reactive way, by using another annotation, <kbd>@EnableReactiveMethodSecurity</kbd>. The concept is the same what we saw in earlier examples based on Spring MVC. We will just cover method security in this section; the rest of the aspects are exactly the same and we will avoid replication here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method security</h1>
                </header>
            
            <article>
                
<p>To enable method security, first, annotate the Spring Security configurations class with <kbd>@EnableReactiveMethodSecurity</kbd>:</p>
<pre>@EnableReactiveMethodSecurity<br/>public class SpringSecurityWebFluxConfig {<br/>    …<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>After that, for any method that you would like to have some security features for, use all of the various security-related annotations discussed in previous chapters:</p>
<pre>@GetMapping("/movies")<br/>@PreAuthorize("hasRole('ADMIN')")<br/>public Flux&lt;Movie&gt; getAllMovies() {<br/>  return reactiveMovieRepository.findAll();<br/>}</pre>
<p>In the preceding method, we are directing Spring Security that the method execution for <kbd>getAllMovies()</kbd> should be allowed if the user is authenticated and has the <kbd>ADMIN</kbd> role granted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customization</h1>
                </header>
            
            <article>
                
<p>Spring Security allows for a number of customizations. The default pages produced by Spring Security, such as login form, logout form, and so on, can be fully customized in all aspects suiting your application's brand. If you would like to tweak Spring Security's default execution, implementing your own filter is appropriate. Since Spring Security depends heavily on filters to achieve its functionality, let's look at the customization opportunity in this.</p>
<p>In addition, almost all parts of Spring Security can be customized by using your own classes, and then plugged into the Spring Security default flow to manage your own customizations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing custom filters</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, in a WebFlux web application, Spring Security works based on <kbd>WebFilter</kbd> (similar to Servlet Filter in Spring MVC). If you would like to customize certain aspects in Spring Security, especially in request and response manipulation, implementing a custom <kbd>WebFilter</kbd> is one of the approaches that can be looked at.</p>
<p>Spring WebFlux offers two approaches to implement filters:</p>
<ul>
<li style="font-weight: 400"><strong>Using</strong> <kbd>WebFilter</kbd>: Works for both annotation-based and functional-based (<kbd>routerhandler</kbd>)</li>
<li style="font-weight: 400"><strong>Using</strong> <kbd>HandlerFilterFunction</kbd>: Works only with functional-based</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using WebFilter</h1>
                </header>
            
            <article>
                
<p>We will be building on top of our project, <kbd>spring-boot-webflux</kbd>. To make it isolated from other projects, we will create a new project, <kbd>spring-boot-webflux-custom</kbd>. As indicated previously, using <kbd>WebFilter</kbd> applies to both annotation-based and functional-based WebFlux approaches. In our example, we'll have two paths: <kbd>filtertest1</kbd> and <kbd>filtertest2</kbd>. We will write test cases using <kbd>WebFluxTestClient</kbd>, and will assert certain conditions. Being separate from the rest, we will create a new routing config, a handler, and an entirely new REST controller. We will not go into detail on some of the aspects already covered. In this section, we will just go through the <kbd>WebFilter</kbd> code, and also some important aspects of the test cases:</p>
<pre>@Component<br/>public class SampleWebFilter implements WebFilter {<br/>    @Override<br/>    public Mono&lt;Void&gt; filter(ServerWebExchange serverWebExchange, <br/>            WebFilterChain webFilterChain) {<br/>        serverWebExchange.getResponse().getHeaders().add("filter-added-header", <br/>            "filter-added-header-value");<br/>        return webFilterChain.filter(serverWebExchange);<br/>    }<br/>}</pre>
<p>The <kbd>SampleWebFilter</kbd> class implements <kbd>WebFilter</kbd>, and also implements the <kbd>filter</kbd> method. In this class, we will add a new response header, <kbd>filter-added-header</kbd>:</p>
<pre>@Test<br/>public void filtertest1_with_pathVariable_equalTo_value1_apply_WebFilter() {<br/>    EntityExchangeResult&lt;String&gt; result = <br/>        webTestClient.get().uri("/filtertest1/value1")<br/>        .exchange()<br/>        .expectStatus().isOk()<br/>        .expectBody(String.class)<br/>        .returnResult();<br/>    Assert.assertEquals(result.getResponseBody(), "value1");<br/>    Assert.assertEquals(result.getResponseHeaders()<br/>        .getFirst("filter-added-header"), "filter-added-header-value");<br/>}<br/>@Test<br/>public void filtertest2_with_pathVariable_equalTo_value1_apply_WebFilter() {<br/>    EntityExchangeResult&lt;String&gt; result = <br/>        webTestClient.get().uri("/filtertest2/value1")<br/>        .exchange()<br/>        .expectStatus().isOk()<br/>        .expectBody(String.class)<br/>        .returnResult();<br/>    Assert.assertEquals(result.getResponseBody(), "value1");<br/>    Assert.assertEquals(result.getResponseHeaders()<br/>        .getFirst("filter-added-header"), "filter-added-header-value");<br/>}</pre>
<p>In both test cases, for both paths, we will check for newly added headers. When you run the test cases (using <kbd>mvn test</kbd>), it will confirm this finding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using HandlerFilterFunction</h1>
                </header>
            
            <article>
                
<p>We will implement a new <kbd>HandlerFilterFunction</kbd>, <kbd>SampleHandlerFilterFunction</kbd>, in which we will look at a path variable (<kbd>pathVariable</kbd>) and check for its value. If the value is equal to <kbd>value2</kbd>, we will mark the status as <kbd>BAD_REQUEST</kbd>. It's important to note that since <kbd>HandlerFilterFunction</kbd> applies only to functional-based, even though the path variable value is equal to <kbd>value2</kbd>, the status is not stamped as <kbd>BAD_REQUEST</kbd>, and the response received is OK:</p>
<pre>public class SampleHandlerFilterFunction implements <br/>        HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {<br/>    @Override<br/>    public Mono&lt;ServerResponse&gt; filter(ServerRequest serverRequest, <br/>        HandlerFunction&lt;ServerResponse&gt; handlerFunction) {<br/>        if (serverRequest.pathVariable("pathVariable")<br/>                .equalsIgnoreCase("value2")) {<br/>            return ServerResponse.status(BAD_REQUEST).build();<br/>        }<br/>        return handlerFunction.handle(serverRequest);<br/>    }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"/>
<p><kbd>SampleHandlerFilterFunction</kbd> implements the <kbd>HandlerFilterFunction</kbd> class, and also implements the <kbd>filter</kbd> method. In this class, we will explicitly set the response status as a bad request, if a condition is met:</p>
<pre>@Test<br/>public void filtertest1_with_pathVariable_equalTo_value2_apply_HandlerFilterFunction() {<br/>    webTestClient.get().uri("/filtertest1/value2")<br/>        .exchange()<br/>        .expectStatus().isOk();<br/>}<br/>@Test<br/>public void filtertest2_with_pathVariable_equalTo_value2_apply_HandlerFilterFunction() {<br/>    webTestClient.get().uri("/filtertest2/value2")<br/>        .exchange()<br/>        .expectStatus().isBadRequest();<br/>}</pre>
<p>In the preceding test cases, the path tested is different, and since <kbd>HandlerFilterFunction</kbd> applies only to functional-based, the response is OK when the path is <kbd>filtertest1</kbd>, and it's <kbd>BAD_REQUEST</kbd> when the path is <kbd>filtertest2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, for the first time in this book, we went over the details of reactive programming, using the Spring WebFlux framework. We started off by giving adequate details on the framework itself at a high level. We went over a very basic example, and then, introduced you to Spring Security and its functionality with Spring WebFlux.</p>
<p>Finally, we went through a hands-on coding session, with a sample application. In this example, we covered other reactive aspects, such as Spring Data Mongo, so as to give you more insight into the reactive world.</p>
<p>We ended the chapter with some of the customization possible in Spring WebFlux with Spring Security.</p>
<p>Having read this chapter, you should have a clear idea of the differences between the Spring MVC and Spring WebFlux frameworks. You should also have a good understanding of the workings of Spring WebFlux security using the Spring Security module. The examples are meant to be simple in nature and as we are undressing Spring Security in this book, those aspects are given more value in the explanations.</p>


            </article>

            
        </section>
    </body></html>