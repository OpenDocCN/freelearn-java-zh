<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Creating REST Services with the Play 2 Framework"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Creating REST Services with the Play 2 Framework</h1></div></div></div><p class="calibre7">For the last REST framework in this book, we will look at Play 2. Play 2 is a modern web framework that can be used to create complete applications. Part of the tools this framework provides allows you to quickly and easily create REST services. In this chapter, we'll focus on that part.</p><p class="calibre7">In this chapter, we'll discuss the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Route matching with the route file</li><li class="listitem">Working with the incoming HTTP request and customizing the response</li><li class="listitem">Adding JSON support, custom validations, and error handling</li></ul></div><p class="calibre7">First, let's get a bit more information about what the Play 2 framework is, and where you can find additional information about it.</p></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Creating REST Services with the Play 2 Framework">
<div class="book" title="An introduction to the Play 2 framework"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec41" class="calibre1"/>An introduction to the Play 2 framework</h1></div></div></div><p class="calibre7">The Play 2 framework<a id="id273" class="calibre1"/> is one of the best-known and most used web frameworks in the Scala ecosystem. It provides a very developer-friendly way of creating web applications and REST services. Some of the most interesting features of Play 2 are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Automatically reload changes</strong></span>: When creating Play 2 applications, you don't have to restart the application after a change in the code. Just resend a request, and Play 2 will automatically reload the changes.</li><li class="listitem"><span class="strong"><strong class="calibre8">Scalable</strong></span>: Play 2 is based on Akka. Through the Akka framework, it provides an easy way to scale up and scale out.</li><li class="listitem"><span class="strong"><strong class="calibre8">Great tool support</strong></span>: Play 2 is based on SBT, the standard build tool for Scala. Through an SBT plugin, you can easily start, reload, and distribute your Play 2 applications.</li></ul></div><p class="calibre7">Even though Play 2 isn't specifically build as a REST framework, we can use parts of it to easily create REST applications, and still take advantage of the features of Play 2.</p></div></div>
<div class="book" title="Hello World with Play 2"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Hello World with Play 2</h1></div></div></div><p class="calibre7">To create a <a id="id274" class="calibre1"/>simple Hello World REST service in Play 2, we first need to set up the SBT project correctly. Play 2 uses an SBT plugin to run an HTTP server that you can use to access your REST service. The first thing we need to do is add this plugin to the <code class="email">plugins.sbt</code> file (which you can find in the <code class="email">project</code> directory):</p><div class="informalexample"><pre class="programlisting">addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.4.0")</pre></div><p class="calibre7">Next, we define the dependencies so that we can create a Play 2-based REST service. For Play 2, we use the following dependencies:</p><div class="informalexample"><pre class="programlisting">lazy val playVersion = "2.4.0"

val backendDeps = Seq (
  "com.typesafe.play" %% "play" % playVersion,
  "com.typesafe.play" %% "play-docs" % playVersion
)</pre></div><p class="calibre7">There is one more step we need to add to the SBT configuration (<code class="email">build.sbt</code>) to be able to run the samples in this chapter:</p><div class="informalexample"><pre class="programlisting">addCommandAlias("runCH06-HelloPlay", "; chapter06/run -Dhttp.port=8080  -Dplay.http.router=hello.Routes")

addCommandAlias("runCH06-runCH06Step1", "; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step01.Routes")

addCommandAlias("runCH06-runCH06Step2", "; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step02.Routes")

addCommandAlias("runCH06-runCH06Step3", "; chapter06/run -Dhttp.port=8080  -Dplay.http.router=step03.Routes")

import PlayKeys._
lazy val chapter06 = (project in file ("chapter-06"))
  .enablePlugins(PlayScala)
  .dependsOn(common)
  .settings(commonSettings: _*)
  .settings(
    name := "chapter-06",
    libraryDependencies := DependenciesChapter6.backendDeps
  )</pre></div><p class="calibre7">The important parts here are the <code class="email">addCommandAlias</code> and <code class="email">enablePlugins</code> functions. With the <code class="email">addCommandAlias</code> function, we define on which port Play 2 should listen and which route configuration <a id="id275" class="calibre1"/>it should use (more on that in the <span class="strong"><em class="calibre9">Working with the routes files</em></span> section). The first <code class="email">addCommandAlias</code> function defines that we'll use the <code class="email">hello.Routes</code> file and listen on port <code class="email">8080</code>. To be able to run Play 2 during development, we also need to add the plugin we defined earlier to this project. We do this through the <code class="email">enablePlugins(PlayScala)</code> call.</p><p class="calibre7">Now let's look a bit closer at the <code class="email">hello.routes</code> file that we use to define the routes for this Hello World example. You can find this file in the <code class="email">routes</code> directory. The content of the <code class="email">hello.routes</code> file looks similar to this:</p><div class="informalexample"><pre class="programlisting">GET     /hello                       controllers.Hello.helloWorld</pre></div><p class="calibre7">This means that a <code class="email">GET</code> request that matches the <code class="email">/hello</code> path will invoke the action defined by <code class="email">controllers.Hello.helloWorld</code>. This action is defined in the <code class="email">Hello.scala</code> file, which Play 2, by default, stores in the <code class="email">app</code> directory:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._

object Hello extends Controller {

  def helloWorld = Action {

    Ok("Hello Play")
  }

}</pre></div><p class="calibre7">Now start the project by calling <code class="email">sbt runCH06-HelloPlay</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$ sbt runCH06-HelloPlay</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>

<span class="strong"><strong class="calibre8">--- (Running the application, auto-reloading is enabled) ---</strong></span>

<span class="strong"><strong class="calibre8">[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application</strong></span>
<span class="strong"><strong class="calibre8">[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080</strong></span>

<span class="strong"><strong class="calibre8">(Server started, use Ctrl+D to stop and go back to the console...)</strong></span>
</pre></div><p class="calibre7">At this point, Play 2 starts and we can access our REST service on port <code class="email">8080</code>. Note that this time, we did not <a id="id276" class="calibre1"/>create our own custom launcher, but used the one provided by Play 2. To stop this server, you can hit <span class="strong"><em class="calibre9">Ctrl </em></span>+ <span class="strong"><em class="calibre9">D</em></span>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre7">When you start Play 2 the way we do in this chapter, we start Play 2 in development mode. In development mode, Play 2 will automatically reload server changes and provide detailed error messages when problems occur. However, you shouldn't run a production Play 2 application in development mode. The performance in development mode is worse than production mode, and through the detailed error messages, much of the internal state is exposed to the clients, which isn't something you want to do in production.</p><p class="calibre7">Therefore, when you are done with development, and start performance testing or deploying your application to production, you should start Play 2 in production mode. An explanation on how to do this can be found on the Play 2 website at <a class="calibre1" href="https://www.playframework.com/documentation/2.4.x/Production">https://www.playframework.com/documentation/2.4.x/Production</a>.</p></div><p class="calibre7">To test whether everything works correctly, open Postman and execute the <span class="strong"><strong class="calibre8">Hello Play</strong></span> request from the request in the <code class="email">Chapter 6</code> folder:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Hello World with Play 2" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The response is as you probably expect. A <code class="email">GET</code> request made to <code class="email">/hello</code> just returns the <code class="email">Hello Play</code> value. One of the great things about Play 2 is that you can change your code, without having to restart the server. As an example, change the response message in the <code class="email">Hello</code> controller to the following:</p><div class="informalexample"><pre class="programlisting">def helloWorld = Action {

  Ok("Hello Play, now with reload!")
}</pre></div><p class="calibre7">Save the file, don't stop <a id="id277" class="calibre1"/>or restart the Play 2 server; instead open up Postman and execute the same request again:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Hello World with Play 2" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, the server now returns the updated string value, without requiring you to restart the server.</p><p class="calibre7">In the following section, we will explore the routes file a bit more.</p></div>
<div class="book" title="Working with the routes file"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Working with the routes file</h1></div></div></div><p class="calibre7">In the <a id="id278" class="calibre1"/>previous section, we saw a very small routes file; it only contained a single line which handled a <code class="email">GET</code> request to the <code class="email">/hello</code> path. For this example, we'll use the following routes file (<code class="email">step01.routes</code> in the <code class="email">routes</code> folder):</p><div class="informalexample"><pre class="programlisting">POST     /tasks       controllers.Step1.createTask
GET      /tasks       controllers.Step1.getTasks
GET      /tasks/:id   controllers.Step1.getTask(id: Long)
DELETE   /tasks/:id   controllers.Step1.deleteTask(id: Long)
PUT      /tasks/:id   controllers.Step1.updateTask(id: Long)

GET         /*path    controllers.Step1.notImplemented(path: String)
POST        /*path    controllers.Step1.notImplemented(path: String)
PUT         /*path    controllers.Step1.notImplemented(path: String)
DELETE      /*path    controllers.Step1.notImplemented(path: String)</pre></div><p class="calibre7">In this<a id="id279" class="calibre1"/> route file, we define a number of different HTTP verbs, paths, and actions to execute. If we look at each line, we first see the HTTP verb, which we want to match. You can use this set of HTTP verbs with Play 2: <code class="email">GET</code>, <code class="email">POST</code>, <code class="email">PUT</code>, <code class="email">PATCH</code>, <code class="email">DELETE</code>, <code class="email">HEAD</code>, and <code class="email">OPTIONS</code>. Next, we see the path that we want to match. Play 2 provides a number of different constructs you can use in that position:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Path constructs</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">/tasks</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches the path, but doesn't extract any information.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">/tasks/:id</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This matches the path and extracts a segment, which is passed into the action with the provided name (<code class="literal">id</code> in this case).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">/*path</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Play 2 also supports wildcards. With <code class="literal">*</code>, you can match a path, which is extracted, assigned to the provided name (<code class="literal">path</code> in this case), and passed into the action.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">/$id&lt;[0-9]+&gt;</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If you start a path with <code class="literal">$</code>, Play 2 interprets this as a regular expression. The match is extracted, assigned to the name (<code class="literal">id</code>), and passed into the action.</p>
</td></tr></tbody></table></div><p class="calibre7">The last part of each line in the routes file is the name of the action to invoke (see the next code fragment). When we extract a value, we can also specify the type we expect (we will see more on this in the next section), for instance, <code class="email">controllers.Step1.getTask(id: Long)</code> converts the extracted <code class="email">id</code> to a <code class="email">Long</code>, and if we don't specify anything, it is passed into the action as a <code class="email">String</code>.</p><p class="calibre7">In the following code fragment, we show the controller that provides the actions referring from the routes file:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._

object Step1 extends Controller {

  def createTask = Action { request =&gt;
    val body: Option[String] = request.body.asText
    Ok(s"Create a task with body: 
         ${body.getOrElse("No body provided")}")
  }

  def getTasks = Action {
    Ok("Getting all tasks")
  }

  def getTask(id: Long) = Action {
    Ok(s"Getting task with id: $id")
  }

  def deleteTask(id: Long) = Action {
    Ok(s"Delete task with id: $id")
  }

  def updateTask(id: Long) = Action { request =&gt;
    val body: Option[String] = request.body.asText
    Ok(s"Update a task with body: 
         ${body.getOrElse("No body provided")}")
  }

  def notImplemented(path: String) = Action {
    NotFound(s"Specified route not found: $path")
  }
}</pre></div><p class="calibre7">In the actions<a id="id280" class="calibre1"/> we defined in this <code class="email">Controller</code>, we don't do anything special. We just specify the HTTP status, which is in the form of <code class="email">Ok</code>, <code class="email">NotFound</code>, or <code class="email">BadRequest</code>, and set the body to send back to the client. Play 2 provides standard results for all the defined HTTP codes. Look in the <code class="email">play.api.mvc.Results</code> object for all the possibilities.</p><p class="calibre7">Now open up Postman, and we'll test some of the routes we just implemented. Start up the Play 2 service with the <code class="email">sbt runCH06-runCH06Step1</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH06-runCH06Step1</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>

<span class="strong"><strong class="calibre8">--- (Running the application, auto-reloading is enabled) ---</strong></span>

<span class="strong"><strong class="calibre8">[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application</strong></span>
<span class="strong"><strong class="calibre8">[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080</strong></span>

<span class="strong"><strong class="calibre8">(Server started, use Ctrl+D to stop and go back to the console...)</strong></span>
</pre></div><p class="calibre7">In Postman, from <a id="id281" class="calibre1"/>the <code class="email">Chapter 06</code> folder, execute the <span class="strong"><strong class="calibre8">Step 01 – Get Task with Id</strong></span> request:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Working with the routes file" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the response you can see that the ID is extracted from the URL path. If you specify a value that can't be converted to a long, the route won't match, and the action won't be executed. In the response code of this request, you can see <span class="strong"><strong class="calibre8">200 OK</strong></span>, which reflects the <code class="email">Ok("…")</code> function we used in the controller. Next, let's execute a request which is matched by one of the wildcard matchers, that is, <span class="strong"><strong class="calibre8">Step 01 - Invalid</strong></span> request:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Working with the routes file" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This time, you <a id="id282" class="calibre1"/>can see that the response code is <span class="strong"><strong class="calibre8">404 Not Found</strong></span>, which is a result of the <code class="email">NotFound("…")</code> function in our controller.</p><p class="calibre7">In the next section, we'll expand on this example and add support for <code class="email">Future</code>. We will also look at more details of the incoming request and the ways you can customize the response.</p></div>
<div class="book" title="Adding the Future support and output writers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Adding the Future support and output writers</h1></div></div></div><p class="calibre7">In this <a id="id283" class="calibre1"/>section, we add more functionality to the very simple service we created in the previous section. We're going to add the functionality to create tasks using<a id="id284" class="calibre1"/> request parameters and also connect our generic <code class="email">TaskService</code>. First, we look at the route file (<code class="email">step02.routes</code>):</p><div class="informalexample"><pre class="programlisting">POST   /tasks            controllers.Step2.createTask(
                              title: String, person: Option[String],
                              status: String ?="New")
GET    /tasks            controllers.Step2.getTasks
GET    /tasks/:id        controllers.Step2.getTask(id: Long)
DELETE /tasks/:id        controllers.Step2.deleteTask(id: Long)
PUT    /tasks/:id        controllers.Step2.updateTask(
                              id: Long, title: String, 
                              person: Option[String],
                              status: String ?="New")</pre></div><p class="calibre7">Not that much has changed here, except that we now pass in more arguments to the actions defined in the <code class="email">Controller</code> class. If you look a bit closer at the first line, you can see that we pass in a number of parameters. So far, we've only seen parameters that were extracted from the URL path. If Play 2 encounters a parameter in the signature of the <code class="email">Action</code> method that it doesn't know, it assumes it is passed in as a request parameter. So in the case of the first route, we expect a <code class="email">title</code>, an optional <code class="email">person</code>, and a <code class="email">status</code> parameter. The <code class="email">title</code> parameter is required, the <code class="email">person</code> parameter is optional, and for the <code class="email">status</code> parameter, we <a id="id285" class="calibre1"/>set a default value using the <code class="email">?=</code> syntax. In the following <a id="id286" class="calibre1"/>paragraphs, we'll look at how these routes map to the actions defined in the <code class="email">Step2</code> controller.</p><p class="calibre7">Before we look at the actions, we'll have a quick look at a couple of <code class="email">Writeable</code> implicit values:</p><div class="informalexample"><pre class="programlisting">object Step2 extends Controller {

  // simple implicit to convert our tasks to a simple string for now
  implicit def wTask: Writeable[Task] = 
       Writeable(_.toString.getBytes, Some("application/text"))
  implicit def wListTask: Writeable[List[Task]] =
       Writeable(_.mkString("\n").getBytes, Some("application/text"))</pre></div><p class="calibre7">Play 2 uses a <code class="email">Writeable</code> object to determine how to convert some types to an HTTP response. In the previous sample, we just converted each task to a string and returned that. We needed to do this in each of the actions. By defining a <code class="email">Writeable[Task]</code> object (and a <code class="email">Writeable[List[Task]]</code> for a list of <code class="email">Tasks</code>), we can just return an <code class="email">Ok(task)</code> , and Play 2 will check whether an implicit <code class="email">Writeable</code> of that type is available in scope, and use that to convert the <code class="email">Task</code> to an output (an <code class="email">Array[Byte]</code> instance) it understands. In the following code fragment, we see that we just return a <code class="email">Task</code>, instead of converting it in the <code class="email">Action</code> block:</p><div class="informalexample"><pre class="programlisting">  def createTask(title: String, person: Option[String], 
                 status: String) = Action.async { request =&gt;

    val body: Option[String] = request.body.asText

    val createdTask = TaskService.insert(Task(
      -1,
      title,
      body.getOrElse("No body provided"),
      person.map(Person(_)),
      List[Note](),
      MStatus(status)))

    createdTask.map(Ok(_))
  }</pre></div><p class="calibre7">The <code class="email">createTask</code> action is called when we make a <code class="email">POST</code> with the required parameters. In this function, we just use the provided information and the request's body to create and store a new <code class="email">Task</code> instance. If <a id="id287" class="calibre1"/>you look at the signature of the <code class="email">TaskService.insert</code>, you can see that this function returns a <code class="email">Future[Task]</code> instance. If you use the <code class="email">Action {...}</code> function, you'll get a compile message since we want to return a <code class="email">Result[Future[Task]]</code> instance, which Play 2 doesn't understand. This is very easy to fix. All we need to do is use <code class="email">Action.async {…}</code> instead of <code class="email">Action {…}</code>. Now we can just return a <code class="email">Future[T]</code>, and Play 2 will know what to do (as long as there is an implicit <code class="email">Writeable[T]</code> in scope).</p><p class="calibre7">Before we move <a id="id288" class="calibre1"/>on to the next action, we'll look a bit closer at the request object used in this example. If you add <code class="email">request =&gt;</code> to your action block, you can access the incoming request. In this action, we use it to access the body, but this object allows access to more request information. The most important ones are listed here:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Property</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">id</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the ID of the request. This starts at 1 for the first request when the application is started and increments with each request. The type of this object is a long.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">tags</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This property contains information about the route and returns a <code class="literal">Map[String, String]</code>. This information looks similar to this:</p>
<div class="informalexample1"><pre class="programlisting1">Map(ROUTE_COMMENTS -&gt; this is a comment,
    ROUTE_PATTERN -&gt; /tasks,
    ROUTE_CONTROLLER -&gt; controllers.Step2,
    ROUTE_ACTION_METHOD -&gt; createTask,
    ROUTE_VERB -&gt; POST)</pre></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">uri</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This contains the full URI of the request. This is the path and query string together. This is of type, string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">path</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the path part of the URI. This returns a string</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">method</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the method part (the verb) used to make the request. This is a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">version</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the HTTP versions of this request. This is also returned as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">queryString</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the parsed query string in the form of a <code class="literal">Map[String, Seq[String]]</code> object, which contains the query parameters. If you want to access the raw query string, you can use the <code class="literal">rawQueryString</code> property.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">headers</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This accesses all the provided headers from the request. This object is of type, <code class="literal">Headers</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">remoteAddress</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the clients address as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">secure</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This property is true if the client used HTTPS; it is false otherwise.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">host</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the host part of the URI as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">domain</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The domain part of the URI as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">cookies</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The cookies send along the request. This object is of type, <code class="literal">Cookies</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">Besides these, the <code class="email">request</code> object also provides some additional properties to access specific headers: <code class="email">acceptLanguages</code>, <code class="email">acceptedTypes</code>, <code class="email">mediaType</code>, <code class="email">contentType</code>, and <code class="email">charSet</code>.</p><p class="calibre7">Now that we've <a id="id289" class="calibre1"/>seen what we can do with the incoming request, in the <a id="id290" class="calibre1"/>following code fragment, we'll look at how we can customize the response that gets sent back to the client:</p><div class="informalexample"><pre class="programlisting">  def getTasks = Action.async {
    TaskService.all.map(
      Ok(_)
        .as("application/text")
        .withCookies(new Cookie("play","cookie"))
        .withHeaders(("header1" -&gt; "header1value")))
  }</pre></div><p class="calibre7">In this fragment, we make a call to the <code class="email">TaskService.all</code> function, which returns a <code class="email">Future[List[Task]]</code> object. Since we've defined a <code class="email">Writeable</code> for <code class="email">List[Task]</code>, all we need to do is transform the <code class="email">Future[List[Task]]</code> to a <code class="email">Future[Result]</code>, which we do by calling map and returning <code class="email">Ok(_)</code>. When we return the result, we use a couple of additional functions to customize the result. We use as to set the content-type of the result, and with <code class="email">withCookies</code> and <code class="email">withHeaders</code>, we add a custom cookie and header. Play 2 provides the following functions for this:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Function</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withHeaders</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This adds the provided <code class="literal">(String, String)</code> tuples as a header to the response.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">withCookies</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This adds the provided <code class="literal">Cookies</code> instance to the response.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">discardingCookies</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">It is also possible to remove specific cookies from the response with this function. All the cookies, which match the provided <code class="literal">DiscardingCookies</code>, will be removed.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">as</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This sets the resulting content-type to the provided string value.</p>
</td></tr></tbody></table></div><p class="calibre7">The following code fragment shows the last couple of actions we implemented for this step:</p><div class="informalexample"><pre class="programlisting">  def getTask(id: Long) = Action.async {
    val task = TaskService.select(id);
    task.map({
      case Some(task) =&gt; Ok(task)
      case None =&gt; NotFound("")
    })
  }


  def updateTask(id: Long, title: String, 
                 person: Option[String], 
                 status: String) = Action.async { request =&gt;
    val body: Option[String] = request.body.asText

    val updatedTask = TaskService.update(id, Task(
      id,
      title,
      body.getOrElse("No body provided"),
      person.map(Person(_)),
      List[Note](),
      MStatus(status)))

    updatedTask.map({
      case Some(task) =&gt; Ok(task)
      case None =&gt; NotFound("")
    })
  }</pre></div><p class="calibre7">As you can see, these <a id="id291" class="calibre1"/>last two actions are much the same as we've already<a id="id292" class="calibre1"/> seen. We just map over the <code class="email">Future</code> and use pattern matching on the containing option to return either <code class="email">Ok</code> (200) or <code class="email">NotFound</code> (404).</p><p class="calibre7">Now that we've explored the complete example, we'll check how it looks in Postman. First start up the example for this step by running <code class="email">sbt runCH06-runCH06Step2</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH06-runCH06Step2</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>

<span class="strong"><strong class="calibre8">--- (Running the application, auto-reloading is enabled) ---</strong></span>

<span class="strong"><strong class="calibre8">[info] p.a.l.c.ActorSystemProvider - Starting application default Akka system: application</strong></span>
<span class="strong"><strong class="calibre8">[info] p.c.s.NettyServer$ - Listening for HTTP on /0:0:0:0:0:0:0:0:8080</strong></span>

<span class="strong"><strong class="calibre8">(Server started, use Ctrl+D to stop and go back to the console...)</strong></span>
</pre></div><p class="calibre7">Once started, first <a id="id293" class="calibre1"/>execute the <span class="strong"><strong class="calibre8">Step 02 - Create Task</strong></span> request a couple of times:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Adding the Future support and output writers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, the<a id="id294" class="calibre1"/> <code class="email">Task</code> is created asynchronously and the created <code class="email">Task</code> is returned. Now when we run the <span class="strong"><strong class="calibre8">Step 02 – Get all tasks</strong></span> request, you should see a list of all the requests, separated by line breaks:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="Adding the Future support and output writers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In the next section, we'll show you how you can add JSON marshalling and error handling.</p></div>
<div class="book" title="Adding JSON marshalling, validations, and error handling"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Adding JSON marshalling, validations, and error handling</h1></div></div></div><p class="calibre7">As we've seen <a id="id295" class="calibre1"/>with the other frameworks, an important <a id="id296" class="calibre1"/>feature of a REST framework is the support for JSON. With Play 2, adding JSON is very easy. All it takes is defining the following implicits:</p><div class="informalexample"><pre class="programlisting">implicit val fmtNote = Json.format[Note]
implicit val fmtPerson = Json.format[Person]
implicit val fmtMStatus = Json.format[MStatus]
implicit val fmtTask = Json.format[Task]</pre></div><p class="calibre7">With these implicits in <a id="id297" class="calibre1"/>scope, we can convert the relevant case classes to and from JSON by using the following two functions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Json.toJson(obj)</code>: This<a id="id298" class="calibre1"/> converts the provided <code class="email">obj</code> instance to JSON. This works if we've defined a <code class="email">Format</code> object for that case class as we've done earlier.</li><li class="listitem"><code class="email">request.body.asJson.map(_.as[Task])</code>: Converting from JSON to a case class is <a id="id299" class="calibre1"/>just as easy. Use <code class="email">asJson</code> to convert the incoming body to a <code class="email">JsValue</code> and then use as to convert it to a supported case class.</li></ul></div><p class="calibre7">While this approach works great for simple scenarios, it doesn't allow you to validate the input values before you create your case objects. If you want to add validations when parsing the incoming JSON, you have to explicitly write out how a specific JSON field is mapped to a property of the case class.</p><p class="calibre7">To convert from and to JSON, we need to define a <code class="email">Reads[T]</code> and a <code class="email">Writes[T]</code> object for each class. A <code class="email">Reads</code> object defines how we convert from the incoming JSON to a case class, and a <code class="email">Writes</code> defines the other way around. If the <code class="email">to</code> and <code class="email">from</code> are symmetrical, you can also use a single <code class="email">Format</code> implicit instead of defining the <code class="email">Reads</code> and <code class="email">Writes</code> separately (note that this doesn't work with case classes with only one parameter). If we look at the mapping of the <code class="email">Note</code> case class, we can use a <code class="email">Format</code> approach:</p><div class="informalexample"><pre class="programlisting">implicit def notesFormat: Format[Note] = (
   (JsPath \ "id").format[Long] and
   (JsPath \ "content").format[String])
     (Note.apply, unlift(Note.unapply))</pre></div><p class="calibre7">In this code fragment, we map the first parameter of the case class to the <code class="email">id</code> JSON field as a long and the second parameter to a string with name content. For the <code class="email">Status</code> case class, we define a separate <code class="email">Writes</code> and <code class="email">Reads</code> and add validation:</p><div class="informalexample"><pre class="programlisting">implicit def statusReads: Reads[MStatus] =
   ((JsPath \ "status").read(
     minLength[String](3) andKeep
       filter(ValidationError("Status must be either New,
                               In Progress or Closed"))
         ((b: String) =&gt; List("New", "In Progress",
                              "Closed").contains(b))
   ))
   .map(MStatus(_))

 implicit def statusWrites: Writes[MStatus] = ((JsPath \ 
           "status").write[String])
           .contramap((_.status))</pre></div><p class="calibre7">Note that <a id="id300" class="calibre1"/>in the<a id="id301" class="calibre1"/> import, we've aliased our <code class="email">Status</code> case class to <code class="email">MStatus</code> to avoid naming conflicts with the <code class="email">Status</code> provided <a id="id302" class="calibre1"/>by Play 2. In the <code class="email">statusReads</code> definition, you can see that we map the incoming status JSON field to our case class. We've also added two validation checks to this property. It needs to have a minimum length of <code class="email">3</code> (<code class="email">minLength</code>), and we check with a custom filter whether the value of <code class="email">status</code> is one of <code class="email">New</code>, <code class="email">In</code> <code class="email">Progress</code>, or <code class="email">Closed</code>. For writing out JSON, we create a simple <code class="email">Writes[MStatus]</code> instance.</p><p class="calibre7">In the <code class="email">Reads</code> of <code class="email">Task</code>, we also add some simple validations:</p><div class="informalexample"><pre class="programlisting">implicit def taskReads: Reads[Task] = (
     (JsPath \ "id").read[Long] and
       (JsPath \ "title").read(minLength[String](3)
                          andKeep maxLength[String](10)) and
       (JsPath \ "content").read[String] and(JsPath \ "assignedTo").readNullable[Person] and
       (JsPath \ "notes").read[List[Note]] and
       (JsPath \ "status").read[MStatus])(Task.apply _)</pre></div><p class="calibre7">We want the title to be at least three characters and have a max of 10. Note that we've used <code class="email">readNullable</code> in this <code class="email">Reads</code> definition. With <code class="email">readNullable</code>, we get an <code class="email">Option[T]</code> object, which implies that the JSON field is also optional. The following table shows the different validation checks you can make:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Validation</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">max</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id303" class="indexterm"/> checks for the maximum value of a numeric JSON property.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">min</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id304" class="indexterm"/>checks for the minimum value of a numeric JSON property.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">filterNot</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id305" class="indexterm"/>checks against a custom predicate. If the predicate returns true, a validation error will be created.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">filter</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id306" class="indexterm"/> checks against a custom predicate. If the predicate returns false, a validation error will be created.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">maxLength</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id307" class="indexterm"/>checks for the maximum length of a string JSON property.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">minLength</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id308" class="indexterm"/>checks for the minimum length of a string JSON property.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">pattern</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id309" class="indexterm"/> checks whether the JSON property matches the provided regular expression.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">email</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id310" class="indexterm"/>checks whether the JSON property is an e-mail address.</p>
</td></tr></tbody></table></div><p class="calibre7">You can also <a id="id311" class="calibre1"/>add multiple checks to a single JSON property. With <code class="email">andKeep</code> and <code class="email">keepAnd</code> (there is a small difference in semantics of these two functions, but <a id="id312" class="calibre1"/>when used with validations, they <a id="id313" class="calibre1"/>work in exactly the same manner), both checks need to succeed, and with <code class="email">or</code>, at least one of the checks must succeed.</p><p class="calibre7">Now that we've defined how to convert to and from JSON, let's look at how to use this in our actions:</p><div class="informalexample"><pre class="programlisting">  def createTask = Action.async { request =&gt;

    val body: Option[JsResult[Task]] = 
             request.body.asJson.map(_.validate[Task])

    // option defines whether we have a Json body or not.
    body match {
      case Some(task) =&gt;
        // jsResult defines whether we have failures.
        task match {
          case JsSuccess(task, _) =&gt; TaskService.insert(task).
                          map(b =&gt; Ok(Json.toJson(b)))
          case JsError(errors) =&gt;
                         Future{BadRequest(errors.mkString("\n"))}
        }
      case None =&gt; Future{BadRequest("Body can't be parsed to JSON")}
    }
  }</pre></div><p class="calibre7">In this code fragment, we first convert the body of the incoming request to JSON with the <code class="email">asJson</code> function. This returns an <code class="email">Option[JsValue]</code> object, which we map to an <code class="email">Option[JsResult[Task]]]</code> instance using the <code class="email">validate</code> function. If our option is <code class="email">None</code>, it means we couldn't parse the incoming JSON, and we'll return a <code class="email">BadRequest</code> result. If we've got validation errors we get a <code class="email">JsError</code> and respond with a <code class="email">BadRequest</code> showing the errors; if the validation went well, we get a <code class="email">JsSuccess</code> and add the <code class="email">Task</code> to the <code class="email">TaskService</code>, which responds with <code class="email">Ok</code>.</p><p class="calibre7">Now open Postman and check what the resulting JSON looks like. First add a couple of <code class="email">Tasks</code> with the <span class="strong"><strong class="calibre8">Step 03 – Create Task</strong></span> request:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Adding JSON marshalling, validations, and error handling" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The JSON used <a id="id314" class="calibre1"/>in this request complies with the validations we added, so the <a id="id315" class="calibre1"/>request is <a id="id316" class="calibre1"/>processed without errors. If you execute the <span class="strong"><strong class="calibre8">Step 03 – Create Task Invalid</strong></span> request, you'll see that the validations are triggered and a bad request is returned:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Adding JSON marshalling, validations, and error handling" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">So far in this <a id="id317" class="calibre1"/>chapter, we've only handled functional errors. Incorrect data resulted in a <code class="email">BadRequest</code> and a <code class="email">Task</code> which couldn't be found returned a <code class="email">Not Found</code> response. Play 2 also provides a generic way of handling unexpected errors. In the next section, we'll show you how you can add a custom error handler to your Play 2 service to process unhandled exceptions.</p><p class="calibre7">First, let's see what the <a id="id318" class="calibre1"/>default behavior of Play 2 is when an exception occurs. For <a id="id319" class="calibre1"/>this, we've changed the <code class="email">Delete</code> action to the following:</p><div class="informalexample"><pre class="programlisting">  def deleteTask(id: Long) = Action.async {
    val task = TaskService.delete(id);

    // assume this task does something unexpected and throws 
    // an exception.
    throw new IllegalArgumentException("Unexpected argument");
    
    task.map({
      case Some(task) =&gt; Ok(task)
      case None =&gt; NotFound("")
    })
  }</pre></div><p class="calibre7">The result, when we call this action, is the following:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Adding JSON marshalling, validations, and error handling" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Play 2 responds with a <code class="email">500 Internal Server</code> error and a lot of HTML explaining the error (note that when you run in production mode, you see a slightly different error, but still in HTML form). While <a id="id320" class="calibre1"/>this is great when developing web applications, it isn't that useful when creating a REST service. To customize the error handling, we <a id="id321" class="calibre1"/>have to provide Play 2 with an implementation of <code class="email">HttpErrorHandler</code>. We could implement this interface from scratch, but an easier approach is <a id="id322" class="calibre1"/>to extend the default error handler (<code class="email">DefaultErrorHandler</code>) provided by Play 2. The handler we'll use is shown here:</p><div class="informalexample"><pre class="programlisting">class ErrorHandler @Inject() (env: Environment,
                              config: Configuration,
                              sourceMapper: OptionalSourceMapper,
                              router: Provider[Router]
                              ) extends DefaultHttpErrorHandler(env, config, sourceMapper, router) {

  override def onDevServerError(request: RequestHeader, 
                             exception: UsefulException) = {
    Future.successful(
      InternalServerError("A server error occurred: " + 
                           exception.getMessage)
    )
  }

  override def onProdServerError(request: RequestHeader, 
                               exception: UsefulException) = {
    Future.successful(
      InternalServerError("A server error occurred: " + 
                           exception.getMessage)
    )
  }
}</pre></div><p class="calibre7">The following functions<a id="id323" class="calibre1"/> can be overridden to define custom error handling:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Function</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onClientError</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id324" class="indexterm"/> is called when an error occurs in the 4xx range. Depending on the error, the default handler delegates to any of the following three functions.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onBadRequest</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is<a id="id325" class="indexterm"/> called when a bad request (400) is made.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onForbidden</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id326" class="indexterm"/>is called when a request is made to a forbidden resource (403).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onNotFound</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This <a id="id327" class="indexterm"/>is called when a resource isn't found (404).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onServerError</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This<a id="id328" class="indexterm"/> is called when a server error occurs. This function delegates to one of the following two functions.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onDevServerError</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">When in<a id="id329" class="indexterm"/> development mode, this function is called when a server error occurs.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">onProdServerError</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">When in<a id="id330" class="indexterm"/> production mode, this function is called when a server error occurs.</p>
</td></tr></tbody></table></div><p class="calibre7">Now we'll get a <a id="id331" class="calibre1"/>much <a id="id332" class="calibre1"/>simpler error message when we make a request that causes an internal server error:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Adding JSON marshalling, validations, and error handling" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">At this point, we've discussed the most important features of the Play 2 framework.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we walked you through the main features of Play 2 (at least those relating to the REST part). We started with a simple service where we introduced the route file, the controller and the actions. After that, we looked at how to retrieve information from the request, parse path segments, and access query parameters. Play 2 also makes it simple to customize the response to an action. It provides standard case classes for all possible HTTP response code, and provides additional functionality to add headers and cookies to the response. Working with futures is supported by Play 2 through the <code class="email">async</code> function. This way we can work with futures, just like we do with normal objects. Finally, we looked at JSON support and validations. Play 2 has standard functionality to convert incoming JSON to case classes and convert case classes back to JSON. When converting JSON to a case class, you can also add validations that check whether the supplied values are valid, before the case class is created.</p><p class="calibre7">With this chapter on Play 2, we finished the discussion of the different REST frameworks featured in this book. In the last chapter of this book, we'll look at some advanced REST framework features, such as HATEOAS, authentication, and client support.</p></div></body></html>