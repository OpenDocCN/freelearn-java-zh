["```java\n\"PlayerService\" should { \n    \"return a Player object.\" in {//some code} \n    \"return an empty collection if there's no data.\" in {//some code} \n    \"return a Nothing on call to getPlayer method with right player string.\" in {//some code} \n    \"return a Some Player instance on call to getPlayer method with right player string.\" in {//some code} \n    \"print a Player's information on console.\" in {//some code} \n} \n```", "```java\nimport Dependencies._ \n\nlazy val root = (project in file(\".\")). \n  settings( \n    inThisBuild(List( \n      organization := \"com.example\", \n      scalaVersion := \"2.12.4\", \n      version      := \"0.1.0-SNAPSHOT\" \n    )), \n    name := \"Hello\", \n    libraryDependencies += scalaTest % Test \n  ) \n```", "```java\n        sbt testOnly example.HelloSpec\n```", "```java\npackage example \n\nimport org.scalatest._ \n\nclass HelloSpec extends FlatSpec with Matchers { \n  \"The Hello object\" should \"say hello\" in { \n    Hello.greeting shouldEqual \"hello\" \n  } \n} \n```", "```java\npackage example \n\nobject Hello extends Greeting with App { \n  println(greeting) \n} \n\ntrait Greeting { \n  lazy val greeting: String = \"hello\" \n} \n```", "```java\npackage example \n\nimport org.scalatest._ \n\nabstract class SomeSpec(toBeTested: String) extends FlatSpec with Matchers \n```", "```java\npackage example \n\nclass PlayerSpec extends SomeSpec(\"PlayerService\") { \n\n  it should \"compile\" in { \n  \"\"\"PlayerService.Player(\"Cristiano Ronaldo\", \"Portuguese\", 32, \"Real Madrid\")\"\"\" should compile \n  } \n\n} \nPlayer instances*.* When we try to run the test case, it's going to fail as expected, because we have not written the  Player class till now:\n```", "```java\n> testOnly example.PlayerSpec \n[info] PlayerSpec: \n[info] - should compile *** FAILED *** \n[info] Expected no compiler error, but got the following type error: \"not found: value Player\", for code: Player(\"Cristiano Ronaldo\", \"Portuguese\", 32, \"Real Madrid\") (PlayerSpec.scala:6) \n[info] Run completed in 281 milliseconds. \n[info] Total number of tests run: 1 \n[info] Suites: completed 1, aborted 0 \n[info] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0 \n[info] *** 1 TEST FAILED *** \n[error] Failed tests: \n[error]  example.PlayerSpec \n[error] (test:testOnly) sbt.TestsFailedException: Tests unsuccessful \n```", "```java\n// src/main/scala/example/PlayerService.scala\n\nobject PlayerService extends App { \n\n  case class Player(name: String, nationality: String, age: Int, league: String) \n\n} \n```", "```java\n[info] PlayerSpec: \n[info] - should compile \n[info] Run completed in 199 milliseconds. \n[info] Total number of tests run: 1 \n[info] Suites: completed 1, aborted 0 \n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0 \n[info] All tests passed. \n[success] Total time: 1 s, completed \n```", "```java\npackage example \n\nclass PlayerSpec extends SomeSpec(\"PlayerService\") { \n\n  it should \"compile\" in { \n    \"\"\"PlayerService.Player(\"Cristiano Ronaldo\", \"Portuguese\", 32, \"Real Madrid\")\"\"\" should compile \n    } \n\n  it should \"throw an exception when source is wrong\" in { \n    val src = \"some source\" \n    assertThrows[java.io.FileNotFoundException](PlayerService.readPlayerDataFromSource(src)) \n  } \n\n  it should \"return collection of String when data is read from correct source\" in { \n    val src = \"/Users/vika/Documents/LSProg/LSPWorkspace/First_Proj_Testing/src/main/scala/example/football_stats.csv\" \n    PlayerService.readPlayerDataFromSource(src) should not be empty \n  } \n\n  it should \"return None while parsing wrong player string data into player instance\" in { \n    val data = \"some wrong player string\" \n    PlayerService.parseToPlayer(data) shouldBe None \n  } \n\n  it should \"return Some Player while parsing player string data into player instance\" in { \n    val data = \"\"\"1,1,2,1,2,Cristiano Ronaldo,Portugal,Real Madrid,Spain,32,4829,40,4789,124,63\"\"\" \n    val player = PlayerService.Player(\"Cristiano Ronaldo\", \"Portugal\", 32, \"Real Madrid\") \n\n    PlayerService.parseToPlayer(data) shouldBe Some(player) \n  } \n\n} \n```", "```java\npackage example \n\nimport scala.util.Try \nimport scala.util.{Failure, Success} \n\nobject PlayerService extends App { \n\n  def readPlayerDataFromSource(src: String): List[String] = { \n    val source = io.Source.fromFile(src) \n\n    val list: List[String] = source.getLines().toList \n\n    source.close() \n    list \n  } \n\n  def parseToPlayer(string: String): Option[Player] = { \n    Try { \n      val columns = string.split((\",\")).map(_.trim) \n      Player(columns(5), columns(6), columns(9).toInt, columns(7)) \n    } match { \n      case Success(value) => Some(value) \n      case Failure(excep) => None \n    } \n  } \n\n  case class Player(name: String, nationality: String, age: Int, league: String) \n\n} \n```", "```java\n[info] PlayerSpec: \n[info] - should compile \n[info] - should throw an exception when source is wrong \n[info] - should return collection of String when data is read from correct source \n[info] - should return None while parsing wrong player string data into player instance \n[info] - should return Some Player while parsing player string data into player instance \n[info] Run completed in 324 milliseconds. \n[info] Total number of tests run: 5 \n[info] Suites: completed 1, aborted 0 \n[info] Tests: succeeded 5, failed 0, canceled 0, ignored 0, pending 0 \n[info] All tests passed. \n```", "```java\n    describe(\"In PlayerService object\"){\n        it(\"should compile\") {\n            assertCompiles(\"\"\"PlayerService.Player (\n                                  \"Cristiano Ronaldo\", \n                                  \"Portuguese\", 32, \n                                  \"Real Madrid\")\"\"\")\n        }\n    }\n```", "```java\n    \"PlayerService.Player.parseToPlayer\" when {\n        \"wrong parsing data passed\" should {\n            \"return None\" in {\n                PlayerService.parseToPlayer(\"some wrog data\") shouldBe None\n            }\n        }\n    }\n```", "```java\n    \"PlayerService.Player.parseToPlayer\" - {\n        \"wrong parsing data passed\" - {\n            \"return None\" in {\n                PlayerService.parseToPlayer(\"some wrog data\") shouldBe None\n            }\n        }\n    }\n```", "```java\nsomeCollection should have length 7 \nsomeString should include (\"world\") \ntwenty should be > 10 \nnumber shouldBe odd \nsequence should contain (\"thisvalue\")  \n```", "```java\nlibraryDependencies += \"org.scalamock\" %% \"scalamock\" % \"4.0.0\" % Test \n```", "```java\nimport org.scalamock.scalatest.MockFactory \n\nclass PlayerAppSpec extends SomeSpec(\"PlayerAppSpec\") with MockFactory { \n\n  it should \"give us a collection of 2 players\" in { \n\n    val mockPlayer = mock[PlayerService.Player] \n\n    val list = List(mockPlayer, mockPlayer) \n    list should have length 2 \n  } \n\n} \nscalamock dependency, the MockFactory trait in the scope, all by importing the dependencies and calling the mock method, specifying which type of object to create as a mock. It's as simple as that. We can also mock functions and set some expectations to that mocked function. Let's see the following example:\n```", "```java\nval someStringToIntFunc  = mockFunction[String, Int] \nsomeStringToIntFunc expects (\"Some Number\") returning 1 \n```"]