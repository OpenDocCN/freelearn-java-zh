- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Implementing Kubernetes Features to Simplify the System Landscape
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Kubernetes功能以简化系统景观
- en: The current microservice landscape contains several supporting services that
    implement important design patterns required in a large-scale microservice landscape,
    for example, an edge server, config server, authorization server, and a service
    for distributed tracing. For a recap, refer to *Chapter 1*, *Introduction to Microservices*.
    In the previous chapter, we replaced the implementation of the design pattern
    for service discovery, based on Netflix Eureka, with the built-in discovery service
    in Kubernetes. In this chapter, we will further simplify the microservice landscape
    by reducing the number of supporting services required to be deployed. Instead,
    the corresponding design patterns will be handled by built-in capabilities in
    Kubernetes. The Spring Cloud Config Server will be replaced with Kubernetes ConfigMaps
    and Secrets. The Spring Cloud Gateway will be replaced by a Kubernetes Ingress
    object, which can act as an edge server in the same way as the Spring Cloud Gateway.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的微服务景观包含几个支持服务，这些服务实现了在大规模微服务景观中所需的重要设计模式，例如，边缘服务器、配置服务器、授权服务器以及分布式跟踪服务。为了回顾，请参阅
    *第1章*，*微服务简介*。在前一章中，我们将基于Netflix Eureka的服务发现模式实现替换为Kubernetes内置的发现服务。在本章中，我们将通过减少需要部署的支持服务数量来进一步简化微服务景观。相反，相应的设计模式将由Kubernetes的内置功能处理。Spring
    Cloud Config Server将被Kubernetes ConfigMaps和Secrets替换。Spring Cloud Gateway将被Kubernetes
    Ingress对象替换，它可以像Spring Cloud Gateway一样充当边缘服务器。
- en: In *Chapter 11*, *Securing Access to APIs*, we introduced the use of certificates
    to protect the external API. The certificates were provisioned manually, which
    is both time-consuming and error-prone, specifically when it comes to remembering
    to rotate the certificates before they expire. In this chapter, we will learn
    about **cert-manager** and how it can be used to automate the process of creating,
    provisioning, and rotating certificates.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第11章*，*API访问安全* 中，我们介绍了使用证书来保护外部API。证书是手动配置的，这既耗时又容易出错，尤其是在记得在证书过期前旋转证书时。在本章中，我们将了解
    **cert-manager** 以及如何使用它来自动化创建、配置和旋转证书的过程。
- en: When more and more features in a platform such as Kubernetes are being used,
    it is important to ensure that the source code for the microservices doesn’t become
    dependent on the platform. To ensure that we can still use the microservices without
    deploying them to Kubernetes, we will conclude the chapter by deploying the microservice
    landscape using Docker Compose and executing the `test-em-all.bash` test script
    to verify that the microservices still work from a functional perspective without
    using Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个平台如Kubernetes上的功能越来越多时，确保微服务的源代码不依赖于该平台是很重要的。为了确保我们可以在不部署到Kubernetes的情况下仍然使用微服务，我们将通过使用Docker
    Compose部署微服务景观，并执行 `test-em-all.bash` 测试脚本以验证微服务在功能层面上仍然可以正常工作，而不使用Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Replacing the Spring Cloud Config Server with Kubernetes ConfigMaps and Secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes ConfigMaps和Secrets替换Spring Cloud Config Server
- en: Replacing the Spring Cloud Gateway with a Kubernetes Ingress object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes Ingress对象替换Spring Cloud Gateway
- en: Using `cert-manager` to automatically provision certificates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cert-manager` 自动配置证书
- en: Deploying and testing the microservice landscape on Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署和测试微服务景观
- en: Deploying and testing the microservice landscape using Docker Compose to ensure
    that the source code in the microservices isn’t locked into Kubernetes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose部署和测试微服务景观，以确保微服务的源代码不会被锁定在Kubernetes中
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书的源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS的安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter17`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自 `$BOOK_HOME/Chapter17` 的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to replace the Spring Cloud Config Server and Spring
    Cloud Gateway with corresponding features in Kubernetes, and use cert-manager
    to provision certificates, you can compare it with the source code for *Chapter
    16*, *Deploying Our Microservices to Kubernetes*. You can use your favorite `diff`
    tool and compare the two folders, `$BOOK_HOME/Chapter16` and `$BOOK_HOME/Chapter17`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，即查看用 Kubernetes 中相应的功能替换 Spring Cloud Config Server 和 Spring
    Cloud Gateway 以及使用 cert-manager 部署证书的过程，你可以将其与 *第 16 章*，*将我们的微服务部署到 Kubernetes*
    中的源代码进行比较。你可以使用你喜欢的 `diff` 工具并比较两个文件夹，`$BOOK_HOME/Chapter16` 和 `$BOOK_HOME/Chapter17`。
- en: Replacing the Spring Cloud Config Server
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换 Spring Cloud Config Server
- en: As we have seen in the previous chapter, ConfigMaps and Secrets can be used
    to hold configuration information for our microservices. The Spring Cloud Config
    Server adds features such as keeping all configurations in one place, optional
    version control using Git, and the ability to encrypt sensitive information on
    the disk. But it also consumes a non-negligible amount of memory (as with any
    Java and Spring-based application) and adds significant overhead during startup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，ConfigMaps 和 Secrets 可以用来保存我们微服务的配置信息。Spring Cloud Config Server
    添加了诸如将所有配置保存在一个地方、可选的 Git 版本控制以及能够在磁盘上加密敏感信息等功能。但它也消耗了相当数量的内存（就像任何基于 Java 和 Spring
    的应用程序一样）并在启动时增加了显著的开销。
- en: For example, when running automated integration tests such as the test script
    we are using in this book, `test-em-all.bash`, all microservices are started up
    at the same time, including the configuration server. Since the other microservices
    must get their configuration from the configuration server, they all have to wait
    for the configuration server to be up and running before they can start up themselves.
    This leads to a significant delay when running integration tests. If we use Kubernetes
    ConfigMaps and Secrets instead, this delay is eliminated, making automated integration
    tests run faster. Therefore, it makes sense to use the Spring Cloud Config Server
    when the underlying platform doesn’t provide a similar capability, but when deploying
    to Kubernetes, it is better to use ConfigMaps and Secrets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当运行自动化集成测试，例如本书中使用的测试脚本 `test-em-all.bash` 时，所有微服务都会同时启动，包括配置服务器。由于其他微服务必须从配置服务器获取配置，因此它们都必须等待配置服务器启动并运行后才能启动自己。这导致在运行集成测试时出现显著延迟。如果我们使用
    Kubernetes ConfigMaps 和 Secrets 代替，这种延迟就会消除，使自动化集成测试运行得更快。因此，当底层平台不提供类似功能时，使用
    Spring Cloud Config Server 是有意义的，但在部署到 Kubernetes 时，最好使用 ConfigMaps 和 Secrets。
- en: Using Kubernetes ConfigMaps and Secrets instead of the Spring Cloud Config Server
    will make the microservice landscape start up faster, which means it will require
    less memory. It will also simplify the microservice landscape by eliminating one
    supporting service, the configuration server. When we perform the replacement,
    it is important to do it in such a way that the source code in the microservices
    isn’t affected, thereby avoiding unnecessary lock-in to Kubernetes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes ConfigMaps 和 Secrets 而不是 Spring Cloud Config Server 将使微服务景观启动更快，这意味着它将需要更少的内存。它还将通过消除一个支持服务，即配置服务器，来简化微服务景观。当我们进行替换时，重要的是要以这种方式进行，即不影响微服务中的源代码，从而避免不必要的
    Kubernetes 锁定。
- en: 'This change is illustrated in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这一更改在下图中得到了说明：
- en: '![Diagram  Description automatically generated](img/B19825_17_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_17_01.png)'
- en: 'Figure 17.1: Replacing the Spring Cloud Config Server with Kubernetes built-in
    ConfigMaps and Secrets'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1：用 Kubernetes 内置的 ConfigMaps 和 Secrets 替换 Spring Cloud Config Server
- en: Let’s see what is required to replace the Spring Cloud Config Server with Kubernetes
    ConfigMaps and Secrets!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用 Kubernetes ConfigMaps 和 Secrets 替换 Spring Cloud Config Server 需要什么！
- en: Note especially that we only change the configuration; no changes are required
    in the Java source code!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只更改配置；Java 源代码中不需要任何更改！
- en: Changes required to replace the Spring Cloud Config Server
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换 Spring Cloud Config Server 所需的更改
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Config Server with Kubernetes ConfigMaps and
    Secrets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的配置中已应用以下更改以替换 Spring Cloud Config Server 为 Kubernetes ConfigMaps 和 Secrets：
- en: We have removed the `spring-cloud/config-server` project and also removed the
    project in the `settings.gradle` build file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经移除了 `spring-cloud/config-server` 项目，并也从 `settings.gradle` 构建文件中移除了项目。
- en: We have removed the Helm chart for the configuration server.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经移除了配置服务器的 Helm 图表。
- en: We have removed config server-specific tests from the `test-em-all.bash` test
    script.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经从 `test-em-all.bash` 测试脚本中移除了特定于配置服务器的测试。
- en: 'We have removed the following configuration from all microservices:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经从所有微服务中移除了以下配置：
- en: The `spring-cloud-starter-config` dependency in the `build.gradle` build files
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.gradle` 构建文件中的 `spring-cloud-starter-config` 依赖项'
- en: The `application.yml` files in the `src/main/resource` folders in each project,
    which were used to connect to the config server
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目 `src/main/resource` 文件夹中的 `application.yml` 文件，用于连接到配置服务器
- en: The `spring.cloud.config.enabled=false` property setting in integration tests,
    since it is no longer required
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于不再需要，集成测试中的 `spring.cloud.config.enabled=false` 属性设置
- en: 'Changes to the configuration files in the `config-repo` folder:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config-repo` 文件夹中的配置文件更改：'
- en: We have removed properties with sensitive information, for example, credentials
    for MongoDB, MySQL, RabbitMQ, and the password for the TLS certificate used by
    the edge server. Kubernetes Secrets will be used to handle sensitive information.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经移除了包含敏感信息的属性，例如 MongoDB、MySQL、RabbitMQ 的凭证以及边缘服务器使用的 TLS 证书的密码。将使用 Kubernetes
    Secrets 来处理敏感信息。
- en: The route to the configuration server API has been removed in the configuration
    of the edge server.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边缘服务器的配置中已移除配置服务器 API 的路由。
- en: 'Changes to the microservices’ Helm charts in `kubernetes/helm/components`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubernetes/helm/components` 中微服务 Helm 图表的更改：'
- en: A `config-repo` folder has been added to each chart. Soft links have been created
    in Helm chart’s `config-repo` folder for the required configuration files from
    the common `config-repo` folder. For each microservice, a soft link has been created
    to the common configuration file, `application.yaml`, and to the microservice-specific
    configuration file.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个图表中已添加 `config-repo` 文件夹。在 Helm 图表的 `config-repo` 文件夹中创建了从公共 `config-repo`
    文件夹所需的配置文件的软链接。对于每个微服务，已创建一个指向公共配置文件 `application.yaml` 和特定于微服务的配置文件软链接。
- en: For a recap on how soft links are created, refer to the *The components charts*
    section in *Chapter 16*, *Deploying Our Microservices to Kubernetes*.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于如何创建软链接的回顾，请参阅第 16 章 *将我们的微服务部署到 Kubernetes* 中的 *组件图表* 部分。
- en: 'The `values.yaml` file has been updated with the following:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml` 文件已更新如下：'
- en: 'An environment variable for a Spring property that is used for pointing out
    what configuration files to use. For example, the property looks like the following
    for the `product` microservice:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指出要使用哪些配置文件的 Spring 属性的环境变量。例如，对于 `product` 微服务，该属性看起来如下：
- en: '[PRE0]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A ConfigMap that the microservices will use to find their configuration files.
    The ConfigMap will be made available inside the container on the /config-repo
    path. The declaration looks like this:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将使用它来查找配置文件的 ConfigMap。ConfigMap 将在容器的 /config-repo 路径内提供。声明如下：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create the ConfigMap, a template has been added that is based on the named
    template, `common.configmap_from_file`, from the `common` chart.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了创建 ConfigMap，已添加一个基于 `common` 图表中的命名模板 `common.configmap_from_file` 的模板。
- en: 'Changes to the environments’ Helm charts in `kubernetes/helm/environments`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubernetes/helm/environments` 中环境 Helm 图表的更改：'
- en: We have removed the dependency on the config server’s chart.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经移除了对配置服务器图表的依赖。
- en: The `values.yaml` file has been updated.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml` 文件已更新。'
- en: 'The Secrets for the config server and its clients have been replaced with Secrets
    for the resource managers, MongoDB, MySQL, and RabbitMQ, and their clients. For
    example:'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器及其客户端的 Secrets 已替换为资源管理器、MongoDB、MySQL 和 RabbitMQ 及其客户端的 Secrets。例如：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Recap from the previous chapter: Note that this `values.yaml` file contains
    sensitive information, like the passwords from the example above. This file must
    therefore be stored securely. An alternative, if it is inappropriate to store
    this file securely, is to remove the sensitive information from this file and
    supply the sensitive information when the `helm install` command is executed.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一章的回顾：请注意，此 `values.yaml` 文件包含敏感信息，如上述示例中的密码。因此，必须安全地存储此文件。如果不适于安全存储此文件，则另一种选择是在执行
    `helm install` 命令时提供敏感信息，并从该文件中移除敏感信息。
- en: Each component is assigned the Secrets it requires.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件都被分配了它所需的Secrets。
- en: 'Recap from the previous chapter: the Secrets will be mapped into each Pod as
    environment variables.'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回顾上一章：Secrets将被映射到每个Pod作为环境变量。
- en: 'For example, the product service needs access to both MongoDB and RabbitMQ
    and is therefore assigned the following two Secrets:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，产品服务需要访问MongoDB和RabbitMQ，因此分配了以下两个Secrets：
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Most of the changes in the Helm charts’ `values.yaml` files end up in Kubernetes
    manifests for `Deployment` objects. For example, the `product` microservice’s
    `Deployment` object will look like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表的`values.yaml`文件中的大多数更改最终都会出现在Kubernetes的`Deployment`对象清单中。例如，`product`微服务的`Deployment`对象将如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that parts of the manifest that have not been affected by the changes above
    have been omitted for improved readability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述更改未影响的部分已被省略以提高可读性。
- en: 'If you want to render a component’s Kubernetes manifest yourself, you can do
    that by applying Helm’s `template` command on the chart of interest. You must
    also add values from the environment’s `values.yaml` file that are applicable
    for the component of the `template` command. Take the `product` service as an
    example. The `dev-env` chart’s `values.yaml` file contains the following settings
    that apply to the `product` service:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己渲染组件的Kubernetes清单，可以通过在感兴趣的图表上应用Helm的`template`命令来实现。你还必须添加适用于`template`命令组件的环境`values.yaml`文件中的值。以`product`服务为例。`dev-env`图表的`values.yaml`文件包含以下适用于`product`服务的设置：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To add these settings to the `template` command, we can use the `--set` flag.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些设置添加到`template`命令中，我们可以使用`--set`标志。
- en: There is also a `--values` flag that can be used to add a `values.yaml` file
    when the command is executed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`--values`标志可以在执行命令时添加`values.yaml`文件。
- en: 'When adding values from an environment chart, we must remember that they are
    parent charts to the component charts. This means that the name of the component
    chart must be removed from the settings when applied directly to the component
    chart. In this case, it means that we should add the following values to the `template`
    command to render the `product` chart correctly:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当从环境图表添加值时，我们必须记住它们是组件图表的父图表。这意味着在直接应用于组件图表时，必须从设置中移除组件图表的名称。在这种情况下，这意味着我们应该将以下值添加到`template`命令中，以正确渲染`product`图表：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'YAML arrays like the one above can be defined using the `--set` flag by listing
    the elements within curly braces, for example, `"{a,b,c}"`. The `product` chart
    can be rendered using the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`--set`标志定义如上所示的YAML数组，通过在大括号内列出元素，例如，`"{a,b,c}"`。可以使用以下命令渲染`product`图表：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result will contain manifests for the `product` microservice, a ConfigMap,
    a Service, and finally, a `Deployment` object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将包含`product`微服务的清单、一个ConfigMap、一个Service以及最后的`Deployment`对象。
- en: This is what is required to replace the configuration server with Kubernetes
    ConfigMaps and Secrets. In the next section, we will learn about how we can replace
    the Spring Cloud Gateway with a Kubernetes Ingress object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是用Kubernetes ConfigMaps和Secrets替换配置服务器的需求。在下一节中，我们将了解如何用Kubernetes Ingress对象替换Spring
    Cloud Gateway。
- en: Replacing the Spring Cloud Gateway
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Gateway
- en: In this section, we will further simplify the microservice landscape by replacing
    the Spring Cloud Gateway using the built-in Ingress object in Kubernetes, reducing
    the number of supporting services required to be deployed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用Kubernetes内置的Ingress对象替换Spring Cloud Gateway来进一步简化微服务景观，减少需要部署的支持服务的数量。
- en: As introduced in *Chapter 15*, *Introduction to Kubernetes*, an Ingress object
    can be used in Kubernetes to act as an edge server in the same way as a Spring
    Cloud Gateway. The Spring Cloud Gateway comes with a richer routing functionality
    compared to an Ingress object. However, the Ingress is part of the Kubernetes
    platform, requiring no extra deployments, and can also be extended using cert-manager
    to automatically provision certificates, as we will see later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第15章*Kubernetes简介*中所述，Ingress对象可以在Kubernetes中用作边缘服务器，就像Spring Cloud Gateway一样。与Ingress对象相比，Spring
    Cloud Gateway提供了更丰富的路由功能。然而，Ingress是Kubernetes平台的一部分，无需额外部署，并且还可以使用cert-manager扩展来自动配置证书，正如我们将在本章后面看到的那样。
- en: We have also used the Spring Cloud Gateway to protect our microservices from
    unauthenticated requests, by requiring a valid OAuth 2.0/OIDC access token from
    a trusted OAuth authorization server or OIDC provider. See *Chapter 11*, *Securing
    Access to APIs*, if a recap is required. Generally, Kubernetes Ingress objects
    do not have support for this. Specific implementations of the Ingress controller
    might, however, support it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用Spring Cloud Gateway来保护我们的微服务免受未经身份验证的请求，通过要求从受信任的OAuth授权服务器或OIDC提供者获取有效的OAuth
    2.0/OIDC访问令牌。如果需要回顾，请参阅第11章“确保API访问安全”。通常，Kubernetes Ingress对象不支持此功能。然而，Ingress控制器的特定实现可能支持它。
- en: Finally, the composite health check we added to the gateway in *Chapter 10*,
    *Using Spring Cloud Gateway to Hide Microservices behind an Edge Server*, can
    be replaced by the Kubernetes liveness and readiness probes defined in each microservice’s
    deployment manifest.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第10章“使用Spring Cloud Gateway在边缘服务器后面隐藏微服务”中添加的复合健康检查可以被每个微服务部署清单中定义的Kubernetes存活和就绪探针所替代。
- en: Therefore, in the same way as for the Spring Cloud Config Server, it makes sense
    to use the Spring Cloud Gateway where the underlying platform doesn’t provide
    a similar capability. When deploying to Kubernetes, it is better to use Ingress
    objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与Spring Cloud Config Server一样，当底层平台不提供类似功能时，使用Spring Cloud Gateway是有意义的。当部署到Kubernetes时，最好使用Ingress对象。
- en: In this chapter, we will delegate the responsibility of validating that the
    request contains a valid access token to the `product-composite` microservice.
    This is done by the Ingress forwarding the HTTP header that contains the access
    token in the requests to the `product-composite` microservice, and it will perform
    its validation of the OAuth access tokens as in the previous chapters. The next
    chapter will introduce the concept of a service mesh, where we will see an alternative
    implementation of an Ingress that fully supports validating JWT-encoded OAuth
    access tokens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将验证请求是否包含有效访问令牌的责任委托给`product-composite`微服务。这是通过Ingress将包含访问令牌的HTTP头从请求转发到`product-composite`微服务来完成的，它将像前几章一样执行其OAuth访问令牌的验证。下一章将介绍服务网格的概念，我们将看到一种完全支持验证JWT编码OAuth访问令牌的Ingress的替代实现。
- en: In the *Verifying that the microservices work without Kubernetes* section, we
    will still use the Spring Cloud Gateway together with Docker Compose, so we will
    not remove the project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在“验证微服务在没有Kubernetes的情况下工作”部分，我们仍然会使用Spring Cloud Gateway与Docker Compose一起使用，因此我们不会删除项目。
- en: 'The following diagram shows that the Spring Cloud Gateway is removed from the
    microservice landscape when deploying to Kubernetes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示，当部署到Kubernetes时，Spring Cloud Gateway将从微服务景观中移除：
- en: '![Graphical user interface, diagram, text, application  Description automatically
    generated](img/B19825_17_02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，图表，文本，应用程序  描述自动生成](img/B19825_17_02.png)'
- en: 'Figure 17.2: Replacing the Spring Cloud Gateway with the Kubernetes built-in
    Ingress controller'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：用Kubernetes内置Ingress控制器替换Spring Cloud Gateway
- en: Let’s see what is required to replace the Spring Cloud Gateway with a Kubernetes
    Ingress object!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用Kubernetes Ingress对象替换Spring Cloud Gateway需要什么！
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只更改了配置；也就是说，Java源代码中不需要任何更改！
- en: Changes required to replace the Spring Cloud Gateway
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Gateway所需的变化
- en: 'The following changes have been applied to the configuration of the source
    code to replace the Spring Cloud Gateway with a Kubernetes Ingress object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更改已应用于源代码配置，以用Kubernetes Ingress对象替换Spring Cloud Gateway：
- en: We have removed the Helm chart for the Spring Cloud Gateway.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经删除了Spring Cloud Gateway的Helm图表。
- en: We have added a named template for Ingress manifests and some default values
    for the Ingress in the `common` chart.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`common`图表中为Ingress清单添加了一个命名模板和一些默认值。
- en: 'The named template, `kubernetes/helm/common/templates/_ingress.yaml`, begins
    with a declaration that we recognize from the previous chapter:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名模板`kubernetes/helm/common/templates/_ingress.yaml`以我们在前一章中熟悉的声明开始：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The name of the template is `common.ingress`, and the `apiVersion` and `kind`
    are set to `networking.k8s.io/v1` and `Ingress, respectively,` to identify it
    as an Ingress manifest. Most of the remainder of the template above looks the
    same as seen in other manifests where overriding parameters is required, such
    as the `Deployment` or `Service` template. The only new part is that the template
    allows the addition of annotations, if required, using the `ingress.annotations`
    field in the `values.yaml` file.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模板的名称是 `common.ingress`，并且 `apiVersion` 和 `kind` 分别设置为 `networking.k8s.io/v1`
    和 `Ingress`，以标识这是一个 Ingress 清单。模板上方的其余部分与在其他需要覆盖参数的清单中看到的类似，例如 `Deployment` 或
    `Service` 模板。唯一的新部分是模板允许通过 `values.yaml` 文件中的 `ingress.annotations` 字段添加注释（如果需要的话）。
- en: 'The rest of the Ingress template contains the main part of the manifest, the
    `spec` part. It looks like this:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ingress 模板的其余部分包含清单的主要部分，即 `spec` 部分。它看起来像这样：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First comes a `tls` section where the manifest declares that the Ingress only
    accepts HTTPS traffic and that the accepted `hostname` will be specified with
    the key `ingress.host` in the `values.yaml` files. The certificate used for serving
    HTTPS requests will be stored in a Secret named as specified in the `values.yaml`
    files using the `ingress.tls.secretName` key.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先是 `tls` 部分，其中清单声明 Ingress 只接受 HTTPS 流量，并且接受的 `hostname` 将使用 `values.yaml`
    文件中的 `ingress.host` 键指定。用于服务 HTTPS 请求的证书将存储在名为 `values.yaml` 文件中指定的 Secret 中，使用
    `ingress.tls.secretName` 键。
- en: Next are the routing rules declared in the `rules` section. First is the hostname
    used for routing. This will be the same hostname as in the `tls` section above.
    Next comes a list of routes. They will be filled in using the `ingress.paths`
    section in the `values.yaml` file. Each entry contains a `path` and the name of
    the `service` that requests to that path will be routed to. Each service is expected
    to have the name of its port set to `http`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来是 `rules` 部分中声明的路由规则。首先是用于路由的主机名。这将与上面 `tls` 部分中的相同主机名相同。接下来是一系列路由。它们将使用
    `values.yaml` 文件中的 `ingress.paths` 部分进行填充。每个条目包含一个 `path` 和请求该路径的 `service` 名称，该请求将被路由到该服务。每个服务都期望其端口的名称设置为
    `http`。
- en: 'The `common` chart’s `values.yaml` file provides the following default values
    for the Ingress manifest:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`common` 图表的 `values.yaml` 文件为 Ingress 清单提供了以下默认值：'
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First is an annotation, `cert-manager.io/issuer`, declared for the Ingress object,
    indicating that cert-manager should manage the required certificate for this Ingress
    object using an issuer named `selfsigned`. More about this is below, in the *Automating
    certificate provisioning* section. Next is the Secret that will hold the certificate,
    given the default name `tls-certificate`.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先是针对 Ingress 对象声明的注释，`cert-manager.io/issuer`，表示 cert-manager 应该使用名为 `selfsigned`
    的颁发者来管理此 Ingress 对象所需的证书。更多关于此内容将在下面的 *自动化证书配置* 部分中介绍。接下来是存储证书的 Secret，默认名称为 `tls-certificate`。
- en: 'We have added templates and additional settings to the environment charts,
    `dev-env` and `prod-env`, for Ingress manifests. The templates are named `ingress.yml`
    and are based on the named template from the `common` chart described above:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已向环境图表 `dev-env` 和 `prod-env` 添加了模板和额外的设置以用于 Ingress 清单。模板命名为 `ingress.yml`，基于上面描述的
    `common` 图表的命名模板：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The remaining values required to render an Ingress manifest, a `hostname` and
    the actual `paths` used for routing, are specified in each environment chart’s
    `values.yaml` files. The declaration looks like this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染 Ingress 清单所需的其余值，包括用于路由的实际 `hostname` 和路径，都在每个环境图表的 `values.yaml` 文件中指定。声明看起来像这样：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the configuration, we can see that we will use the hostname `minikube.me`
    and that three routes are defined for the `auth-server`, while the rest of the
    declared paths will be routed to the `product-composite` service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置中我们可以看到，我们将使用主机名 `minikube.me`，并且为 `auth-server` 定义了三个路由，而其余声明的路径将被路由到 `product-composite`
    服务。
- en: We will register the hostname `minikube.me` in the local `/etc/hosts` file later,
    in the *Testing with Kubernetes ConfigMaps, Secrets, Ingress, and cert-manager*
    section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *使用 Kubernetes ConfigMaps、Secrets、Ingress 和 cert-manager 进行测试* 部分中稍后注册主机名
    `minikube.me` 到本地的 `/etc/hosts` 文件中。
- en: The changes above will result in an Ingress manifest being rendered by Helm.
    Since the Ingress template is only used by the environments charts, we need to
    render one of the environment charts to see the Ingress manifest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述更改将导致 Helm 渲染 Ingress 清单。由于 Ingress 模板仅由环境图表使用，我们需要渲染一个环境图表来查看 Ingress 清单。
- en: 'Run the following command to render manifests using the `dev-env` chart:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以使用`dev-env`图表渲染清单：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Look for `kind: Ingress` in the output and you will find the Ingress manifest.
    It looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在输出中查找`kind: Ingress`，你将找到Ingress清单。它看起来像这样：'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that some of the routing rules have been removed for improved readability.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了提高可读性，一些路由规则已被删除。
- en: The final missing piece is how the Secret containing the certificate is created;
    let’s look into that next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是包含证书的Secret是如何创建的；让我们接下来看看这个问题。
- en: Automating certificate provisioning
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化证书配置
- en: The cert-manager tool ([https://cert-manager.io/docs/](https://cert-manager.io/docs/))
    is a certificate management controller for Kubernetes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: cert-manager工具([https://cert-manager.io/docs/](https://cert-manager.io/docs/))是Kubernetes的证书管理控制器。
- en: 'It can facilitate the automated creation, provisioning, and rotation of certificates.
    It supports several sources for the certificates; for example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以简化证书的自动化创建、配置和轮换。它支持多个证书来源；例如：
- en: An **RFC8555** ([https://tools.ietf.org/html/rfc8555](https://tools.ietf.org/html/rfc8555))-compliant
    **ACME server** such as **Let’s Encrypt** ([https://letsencrypt.org](https://letsencrypt.org))
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个符合**RFC8555** ([https://tools.ietf.org/html/rfc8555](https://tools.ietf.org/html/rfc8555))的**ACME服务器**，例如**Let’s
    Encrypt** ([https://letsencrypt.org](https://letsencrypt.org))。
- en: '**HashiCorp Vault PKI Secrets Engine** ([https://www.vaultproject.io/docs/secrets/pki](https://www.vaultproject.io/docs/secrets/pki))'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashiCorp Vault PKI Secrets Engine** ([https://www.vaultproject.io/docs/secrets/pki](https://www.vaultproject.io/docs/secrets/pki))'
- en: Self-signed certificates, issued by cert-manager itself
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自签名证书，由cert-manager本身颁发
- en: For a full list of available issuers, see [https://cert-manager.io/docs/configuration/](https://cert-manager.io/docs/configuration/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的发行者完整列表，请参阅[https://cert-manager.io/docs/configuration/](https://cert-manager.io/docs/configuration/)。
- en: Since self-signed certificates don’t require communication with any external
    resources, they are a good candidate for use during development. We will use them
    within the scope of this book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自签名证书不需要与任何外部资源进行通信，因此在开发期间使用它们是一个很好的选择。我们将在本书的范围内使用它们。
- en: Using cert-manager in production typically requires the use of an issuer, such
    as Let’s Encrypt, which can issue certificates for the external APIs that the
    API clients (for example, web browsers and external systems) will trust.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中使用cert-manager通常需要使用一个发行者，例如Let’s Encrypt，它可以颁发客户端（例如，网络浏览器和外部系统）将信任的外部API的证书。
- en: After installation of cert-manager in a Kubernetes cluster, at least one issuer
    must be registered. An issuer can either be local to a namespace or accessible
    cluster-wide. We will use a local issuer that is registered in the existing namespace,
    `hands-on`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中安装cert-manager之后，至少必须注册一个发行者。发行者可以是特定命名空间内的本地发行者，或者是在集群范围内可访问的。我们将使用在现有命名空间`hands-on`中注册的本地发行者。
- en: 'It will be the responsibility of the environment charts, `dev-env` and `prod-env`,
    to register a proper issuer. Both environments will use the self-signed issuer.
    A named template, `_issuer.yaml`, has been added to the `common` chart. It looks
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将由环境图表`dev-env`和`prod-env`负责注册适当的发行者。这两个环境都将使用自签名发行者。已添加一个名为`_issuer.yaml`的命名模板到`common`图表中。它看起来像这样：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `apiVersion` and `kind` fields specify that this is an issuer defined by
    cert-manager. Its name is set to `selfsigned`. In the *Changes required to replace
    the Spring Cloud Gateway* section above, we saw how this name was used to annotate
    the Ingress manifest:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion`和`kind`字段指定这是一个由cert-manager定义的发行者。其名称设置为`selfsigned`。在上面的*替换Spring
    Cloud Gateway所需更改*部分中，我们看到了如何使用此名称来注释Ingress清单：'
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is all that it takes to get cert-manager to kick in and provide a certificate
    for the Ingress object. The cert-manager listens for the registration of Ingress
    objects that are annotated with `cert-manager.io/issuer` and starts to issue certificates
    using the issuer referenced in the value of the annotation, in this case, `selfsigned`.
    The cert-manager tool will use the issuer to create a certificate and store it
    in a Secret named by the Ingress object. In our case, the name is set to `tls-certificate`.
    A `Certificate` object will also be created with the same name, containing administrative
    information like when it is time for cert-manager to renew the certificate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是让 cert-manager 启动并提供 Ingress 对象证书所需的所有内容。cert-manager 监听带有 `cert-manager.io/issuer`
    注解的 Ingress 对象的注册，并开始使用注解值中引用的发行者颁发证书，在本例中为 `selfsigned`。cert-manager 工具将使用发行者创建证书并将其存储在以
    Ingress 对象命名的 Secret 中。在我们的例子中，名称设置为 `tls-certificate`。还将创建一个具有相同名称的 `Certificate`
    对象，其中包含管理信息，例如 cert-manager 何时需要更新证书。
- en: 'Since the named template, `common.issuer`, does not accept any configuration,
    all that is required to apply it in the `dev-env` and `prod-env` charts is to
    add a template in each chart that uses the named template. The template is named
    `issuer.yaml` and looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名为 `common.issuer` 的模板不接受任何配置，要在 `dev-env` 和 `prod-env` 图表中应用它，只需在每个图表中添加一个使用该命名模板的模板。该模板命名为
    `issuer.yaml`，其外观如下：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this, we have everything that is required to replace the Spring Cloud Config
    Server and Gateway with native Kubernetes components and cert-manager. Let’s deploy
    and run some tests!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就拥有了替换 Spring Cloud Config Server 和 Gateway 为本地 Kubernetes 组件和 cert-manager
    所需的一切。让我们部署并运行一些测试！
- en: Testing with Kubernetes ConfigMaps, Secrets, Ingress, and cert-manager
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes ConfigMaps、Secrets、Ingress 和 cert-manager 进行测试
- en: 'With the preceding changes described, we are ready to test the system landscape
    with the Spring Cloud Config Server and the Spring Cloud Gateway replaced by Kubernetes
    ConfigMaps, Secrets, an Ingress object, and cert-manager. As before, when we used
    the Spring Cloud Gateway as the edge server, the external API will be protected
    by HTTPS. With this deployment, it will be the Ingress controller that uses the
    certificate provisioned by cert-manager to protect the external API with HTTPS.
    This is illustrated in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了前面的更改之后，我们已准备好使用 Spring Cloud Config Server 和 Spring Cloud Gateway 被 Kubernetes
    ConfigMaps、Secrets、Ingress 对象和 cert-manager 替换的系统景观进行测试。和之前一样，当我们使用 Spring Cloud
    Gateway 作为边缘服务器时，外部 API 将由 HTTPS 保护。在这个部署中，将使用由 cert-manager 提供的证书来保护外部 API 的
    Ingress 控制器。这将在以下图中说明：
- en: '![Diagram  Description automatically generated](img/B19825_17_03.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 描述自动生成](img/B19825_17_03.png)'
- en: 'Figure 17.3: Protecting external access using HTTPS'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：使用 HTTPS 保护外部访问
- en: The Ingress controller is exposed on the default HTTPS port, `443`, on the Minikube
    instance. On the host, where we run the Minikube instance as a Docker container,
    we communicate with the Minikube instance via `localhost`. When the Minikube instance
    was created, port forwarding was configured from port `8443` on `localhost` to
    the `443` port in the Minikube instance. The Ingress controller was installed
    when we performed the `minikube addons enable ingress` command.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 控制器在 Minikube 实例的默认 HTTPS 端口 `443` 上公开。在主机上，我们作为 Docker 容器运行 Minikube
    实例时，我们通过 `localhost` 与 Minikube 实例通信。当创建 Minikube 实例时，已配置从 `localhost` 的 `8443`
    端口到 Minikube 实例的 `443` 端口的端口转发。我们在执行 `minikube addons enable ingress` 命令时安装了 Ingress
    控制器。
- en: For a recap on the setup of the Minikube instance, see the *Creating a Kubernetes
    cluster* section in *Chapter 15*, *Introduction to Kubernetes*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Minikube 实例设置的回顾，请参阅 *第 15 章*，*Kubernetes 简介* 中的 *创建 Kubernetes 集群* 部分。
- en: An interesting question here is, how can the Ingress controller use port `443`
    on the Minikube instance? We have seen the use of services of type `NodePort`
    that can allocate a port starting from `30000`, so how can the Ingress controller
    use the standard port for HTTPS, `443`?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题，Ingress 控制器是如何在 Minikube 实例上使用端口 `443` 的？我们看到了使用类型为 `NodePort` 的服务，它可以分配从
    `30000` 开始的端口，那么 Ingress 控制器是如何使用标准的 HTTPS 端口 `443` 的呢？
- en: 'The Ingress controller consists of a `Deployment` object, `ingress-nginx-controller`,
    in the `ingress-nginx` namespace. The answer to the question is that the `Deployment`
    object configures its Pod using a `hostPort` to map port `443` in the Kubernetes
    host, that is, the Minikube instance, to port `443` in the container that runs
    in the Pod. The central parts in the definition of the `Deployment` object look
    like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This setup works for a single-node Kubernetes cluster used for development and
    testing. In a multi-node Kubernetes cluster, external load balancers are used
    to expose an Ingress controller for high availability and scalability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The `Deployment` object uses the same type of commands as we used in *Chapter
    16*, *Deploying Our Microservices to Kubernetes*; refer to the *Deploying to Kubernetes
    for development and test* section. In this section, we will also install cert-manager
    and add an entry to the`/etc/hosts` file for the hostname `minikube.me`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to deploy the system landscape and verify that
    it works as expected:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Install cert-manager in the `cert-manager` namespace and wait for the deployment
    to complete. Before cert-manager can be installed, we need to add its Helm repository.
    Run the following commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The cert-manager tool also comes with a set of Kubernetes **Custom Resource
    Definitions** (**CRDs**), like the `Issuer` object that was introduced above.
    CRDs are used in Kubernetes to extend its API, that is, to add new objects to
    its API. The `--set installCRDs=true` flag in the command above ensures that these
    object definitions are installed when installing cert-manager.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that three Pods are ready in the `cert-manager` namespace with the following
    command:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Expect a response like this:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_04.png)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 17.4: Pods in the cert-manager namespace'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map `minikube.me` to the IP address we can use to reach the Minikube instance
    by adding a line to the `/etc/hosts` file. Run the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the `sudo` command will probably ask for your password.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify the result with the `cat /etc/hosts` command. Expect a line that contains
    `127.0.0.1 minikube.me`.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your `/etc/hosts` file contains multiple lines for `minikube.me` (for example,
    from earlier attempts), you need to remove the old ones manually.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can build Docker images from the source code as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `eval $(minikube docker-env -u)` command is used to ensure that the `./gradlew
    build` command uses the host’s Docker engine and not the Docker engine in the
    Minikube instance. The `build` command uses Docker to run test containers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the Helm chart dependencies:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we update the dependencies in the `components` folder:'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we update the dependencies in the `environments` folder:'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set the `hands-on` namespace as the default namespace for `kubectl`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In a separate terminal window, run the following command to monitor how certificate
    objects are created by cert-manager:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Deploy the system landscape using Helm and wait for all deployments to complete:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note how the certificate is created by cert-manager during the deployment.
    Expect the following output from the `kubectl get certificates` command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B19825_17_05.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Events from cert-manager provisioning a certificate'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Stop the `kubectl get certificates` command with *Ctrl*+ *C*.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test to verify that the system landscape works as expected:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Expect output from the tests similar to what we obtained in the previous chapter
    (in a condensed format):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_06.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Verifying the system landscape created by the dev-env Helm chart'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Before wrapping up the `dev-env`, let’s try out the certificate object that
    cert-manager created and see how it can be used to affect the retention time for
    the certificate.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Rotating certificates
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start getting acquainted with the certificate object by issuing the following
    command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the end of the output from the command, we will find the following information
    regarding the time that the certificate will be valid for:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_07.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Certificate validation period and renewal time'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the certificate is valid for 90 days (**Not After** – **Not
    Before**) and that cert-manager will try to renew it after 60 days (**Renewal
    Time** – **Not Before**). Since the self-signed issuer we are using doesn’t allow
    any configuration, these are the default values that cert-manager uses: 90 days,
    lifetime and a renewal process that is initiated after 2/3 of the lifetime.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: But we don’t want to wait 60 days before we can observe a renewal of the certificate.
    If we study the API specification for the certificate object at [https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.Certificate](https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.Certificate),
    we will find a field in the `spec` section that is of interest.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: It is named `renewBefore` and can be used to specify how early cert-manager
    should start the renewal process. If we want the certificate to be renewed once
    per minute, we can specify the `renewBefore` to be 90 days – 1 minute = 90*24
    hours – 1 minute = 2160 hours – 1 minute = 2159 hours and 59 minutes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `kubectl get events -w` command in a separate terminal window and
    run the following `patch` command to add the `renewBefore` field to the certificate:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Within 1 minute, the `get events` command should start to report on certificate
    renewals. For each renewal, the following should be printed by the `get events`
    command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_17_08.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.8: Events from cert-manager rotating a certificate'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait a couple of minutes to verify that the certificate is renewed once per
    minute. If you are curious about when the next renewal will happen, you can issue
    the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It should respond with a date like **2023-05-07T05:58:40Z**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If you no longer want to have a custom retention time, you can remove the `renewBefore`
    field with the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This concludes the tests we will do in the system landscape deployed using
    the `dev-env` chart. We can remove the system landscape with the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let us also recap how to deploy the system landscape using the `prod-env` chart!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes for staging and production
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deploying to a staging and production environment using the `prod-env` chart
    follows the same steps as we used in the *Deploying to Kubernetes for staging
    and production* section in *Chapter 16*, *Deploying Our Microservices to Kubernetes*.
    The steps are recapitulated here in a compact form:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Start MySQL, MongoDB, and RabbitMQ outside of Kubernetes:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Tag Docker images with `v1` versions:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Deploy the microservices using the `prod-env` Helm chart:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the test to verify that the system landscape works as expected:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you are done, clean up the resources created in both Kubernetes and Docker
    using the following commands:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Stop the `kubectl get cert -w` and `kubectl get events -w` commands if they
    still are running by using *Ctrl* + *C*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the namespace in Kubernetes with the following command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Stop MySQL, MongoDB, and RabbitMQ with the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With this, we are done with all tests running on Kubernetes. Let’s see how to
    verify that the microservices still work *without* Kubernetes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the microservices work without Kubernetes
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the previous one, we have seen how features in the Kubernetes
    platform, such as ConfigMaps, Secrets, Services, and Ingress objects, can simplify
    the effort of developing a landscape of cooperating microservices. But it is important
    to ensure that the source code of the microservices doesn’t become dependent on
    the platform from a functional perspective. Avoiding such a lock-in makes it possible
    to change to another platform in the future, if required, with minimal effort.
    Changing the platform should not require changes in the source code, but only
    in the configuration of the microservices.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Testing the microservices using Docker Compose and running the `test-em-all.bash`
    verification script will ensure that they work from a functional perspective without
    Kubernetes. When running microservices without Kubernetes, we will lack the non-functional
    features that Kubernetes provides us with, for example, monitoring, scaling, and
    restarting containers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Docker Compose, we will replace the following Kubernetes features:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Instead of ConfigMaps, we will use volumes that map the configuration files
    directly from the host filesystem
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using Secrets, we will keep sensitive information such as credentials
    in the Docker Compose `.env` file
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of an Ingress, we will use the Spring Cloud Gateway
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of Services, we will map hostnames used by the clients directly to the
    hostnames of the containers, meaning that we will not have any service discovery
    in place and will not be able to scale containers
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose this way will result in significant disadvantages from
    a non-functional perspective compared to using Kubernetes. But this is acceptable,
    given that Docker Compose will only be used to run functional tests.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the changes in the `docker-compose*.yml` files before we run
    the tests using Docker Compose.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Docker Compose files
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run microservices outside Kubernetes, using Docker Compose, the following
    changes have been applied to the `docker-compose*.yml` files:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the configuration server definition
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have removed the use of the following configuration server environment variables:
    `CONFIG_SERVER_USR` and `CONFIG_SERVER_PWD`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have mapped the `config-repo` folder as a volume in each container that needs
    to read configuration files from the configuration repository
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have defined the `SPRING_CONFIG_LOCATION` environment variable to point to
    the configuration files in the configuration repository
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have stored sensitive information such as credentials and passwords in TLS
    certificates in the Docker Compose `.env` file
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have defined environment variables with credentials for access to resource
    managers, using the variables defined in the `.env` file
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the configuration of the `product` microservice looks like the
    following in `docker-compose.yml`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is an explanation of the source code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The `config-repo` folder is mapped as a volume into the container at `/config-repo`
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml`
    files
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `.env` file
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The credentials referred to in the preceding source code are defined in the
    `.env` file as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Testing with Docker Compose
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test with Docker Compose, we will use Docker Desktop instead of Minikube.
    Perform the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To direct the Docker client to use Docker Desktop instead of Minikube, run
    the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To avoid port conflicts on port `8443`, you need to stop the Minikube instance:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Build the Docker images in Docker Desktop with the following command:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the tests using RabbitMQ (with one partition per topic):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The tests should begin by starting all the containers, running the tests, and
    finally, stopping all the containers. Expect output similar to what we have seen
    in the previous chapters (output reduced to improve readability):'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19825_17_09.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: Verifying the functionality of the system landscape without using
    Kubernetes'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, run the tests using RabbitMQ with multiple partitions per topic:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Expect output that’s similar to the preceding test.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, run the test using Kafka with multiple partitions per topic:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Expect output that’s similar to the preceding test.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since it can take a few seconds for the Kafka broker to decide which partition
    to assign to the instances in the consumer groups, the tests can fail since the
    rebalancing operation is still in progress when the tests are started. If the
    test fails, then rerun the command, but without the `start` flag:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Start the Minikube instance, and set the default namespace to `hands-on`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With the successful execution of these tests, we have verified that the microservices
    also work without Kubernetes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how capabilities in Kubernetes can be used to
    simplify a microservice landscape, meaning that we reduce the number of supporting
    services to be developed and deployed together with the microservices. We have
    seen how Kubernetes ConfigMaps and Secrets can be used to replace the Spring Cloud
    Config Server and how a Kubernetes Ingress object can replace the Spring Cloud
    Gateway.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Using cert-manager allowed us to automatically provision certificates for HTTPS
    endpoints exposed by the Ingress controller, eliminating the need for manual and
    cumbersome work.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the source code of the microservices can run on other platforms,
    that is, isn’t locked into Kubernetes, we deployed the microservices using Docker
    Compose and ran the `test-em-all.bash` test script.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be introduced to the concept of a service mesh
    and learn how a service mesh product, **Istio**, can be used to improve observability,
    security, resilience, and routing in a landscape of cooperating microservices
    that are deployed on Kubernetes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the next chapter!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How was the Spring Cloud Config Server replaced by Kubernetes resources?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How was the Spring Cloud Gateway replaced by Kubernetes resources?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to make cert-manager automatically provision certificates for
    an Ingress object?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the retention time of a certificate be checked and updated?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the actual certificate stored?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we run the tests using Docker Compose?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
