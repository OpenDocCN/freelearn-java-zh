- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Kubernetes Features to Simplify the System Landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current microservice landscape contains several supporting services that
    implement important design patterns required in a large-scale microservice landscape,
    for example, an edge server, config server, authorization server, and a service
    for distributed tracing. For a recap, refer to *Chapter 1*, *Introduction to Microservices*.
    In the previous chapter, we replaced the implementation of the design pattern
    for service discovery, based on Netflix Eureka, with the built-in discovery service
    in Kubernetes. In this chapter, we will further simplify the microservice landscape
    by reducing the number of supporting services required to be deployed. Instead,
    the corresponding design patterns will be handled by built-in capabilities in
    Kubernetes. The Spring Cloud Config Server will be replaced with Kubernetes ConfigMaps
    and Secrets. The Spring Cloud Gateway will be replaced by a Kubernetes Ingress
    object, which can act as an edge server in the same way as the Spring Cloud Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Securing Access to APIs*, we introduced the use of certificates
    to protect the external API. The certificates were provisioned manually, which
    is both time-consuming and error-prone, specifically when it comes to remembering
    to rotate the certificates before they expire. In this chapter, we will learn
    about **cert-manager** and how it can be used to automate the process of creating,
    provisioning, and rotating certificates.
  prefs: []
  type: TYPE_NORMAL
- en: When more and more features in a platform such as Kubernetes are being used,
    it is important to ensure that the source code for the microservices doesn’t become
    dependent on the platform. To ensure that we can still use the microservices without
    deploying them to Kubernetes, we will conclude the chapter by deploying the microservice
    landscape using Docker Compose and executing the `test-em-all.bash` test script
    to verify that the microservices still work from a functional perspective without
    using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Spring Cloud Config Server with Kubernetes ConfigMaps and Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the Spring Cloud Gateway with a Kubernetes Ingress object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `cert-manager` to automatically provision certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and testing the microservice landscape on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and testing the microservice landscape using Docker Compose to ensure
    that the source code in the microservices isn’t locked into Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter17`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to replace the Spring Cloud Config Server and Spring
    Cloud Gateway with corresponding features in Kubernetes, and use cert-manager
    to provision certificates, you can compare it with the source code for *Chapter
    16*, *Deploying Our Microservices to Kubernetes*. You can use your favorite `diff`
    tool and compare the two folders, `$BOOK_HOME/Chapter16` and `$BOOK_HOME/Chapter17`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Spring Cloud Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter, ConfigMaps and Secrets can be used
    to hold configuration information for our microservices. The Spring Cloud Config
    Server adds features such as keeping all configurations in one place, optional
    version control using Git, and the ability to encrypt sensitive information on
    the disk. But it also consumes a non-negligible amount of memory (as with any
    Java and Spring-based application) and adds significant overhead during startup.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when running automated integration tests such as the test script
    we are using in this book, `test-em-all.bash`, all microservices are started up
    at the same time, including the configuration server. Since the other microservices
    must get their configuration from the configuration server, they all have to wait
    for the configuration server to be up and running before they can start up themselves.
    This leads to a significant delay when running integration tests. If we use Kubernetes
    ConfigMaps and Secrets instead, this delay is eliminated, making automated integration
    tests run faster. Therefore, it makes sense to use the Spring Cloud Config Server
    when the underlying platform doesn’t provide a similar capability, but when deploying
    to Kubernetes, it is better to use ConfigMaps and Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes ConfigMaps and Secrets instead of the Spring Cloud Config Server
    will make the microservice landscape start up faster, which means it will require
    less memory. It will also simplify the microservice landscape by eliminating one
    supporting service, the configuration server. When we perform the replacement,
    it is important to do it in such a way that the source code in the microservices
    isn’t affected, thereby avoiding unnecessary lock-in to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Replacing the Spring Cloud Config Server with Kubernetes built-in
    ConfigMaps and Secrets'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what is required to replace the Spring Cloud Config Server with Kubernetes
    ConfigMaps and Secrets!
  prefs: []
  type: TYPE_NORMAL
- en: Note especially that we only change the configuration; no changes are required
    in the Java source code!
  prefs: []
  type: TYPE_NORMAL
- en: Changes required to replace the Spring Cloud Config Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Config Server with Kubernetes ConfigMaps and
    Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the `spring-cloud/config-server` project and also removed the
    project in the `settings.gradle` build file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have removed the Helm chart for the configuration server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have removed config server-specific tests from the `test-em-all.bash` test
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have removed the following configuration from all microservices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `spring-cloud-starter-config` dependency in the `build.gradle` build files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `application.yml` files in the `src/main/resource` folders in each project,
    which were used to connect to the config server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spring.cloud.config.enabled=false` property setting in integration tests,
    since it is no longer required
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes to the configuration files in the `config-repo` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have removed properties with sensitive information, for example, credentials
    for MongoDB, MySQL, RabbitMQ, and the password for the TLS certificate used by
    the edge server. Kubernetes Secrets will be used to handle sensitive information.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The route to the configuration server API has been removed in the configuration
    of the edge server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes to the microservices’ Helm charts in `kubernetes/helm/components`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `config-repo` folder has been added to each chart. Soft links have been created
    in Helm chart’s `config-repo` folder for the required configuration files from
    the common `config-repo` folder. For each microservice, a soft link has been created
    to the common configuration file, `application.yaml`, and to the microservice-specific
    configuration file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For a recap on how soft links are created, refer to the *The components charts*
    section in *Chapter 16*, *Deploying Our Microservices to Kubernetes*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `values.yaml` file has been updated with the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An environment variable for a Spring property that is used for pointing out
    what configuration files to use. For example, the property looks like the following
    for the `product` microservice:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'A ConfigMap that the microservices will use to find their configuration files.
    The ConfigMap will be made available inside the container on the /config-repo
    path. The declaration looks like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: To create the ConfigMap, a template has been added that is based on the named
    template, `common.configmap_from_file`, from the `common` chart.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changes to the environments’ Helm charts in `kubernetes/helm/environments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have removed the dependency on the config server’s chart.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `values.yaml` file has been updated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Secrets for the config server and its clients have been replaced with Secrets
    for the resource managers, MongoDB, MySQL, and RabbitMQ, and their clients. For
    example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Recap from the previous chapter: Note that this `values.yaml` file contains
    sensitive information, like the passwords from the example above. This file must
    therefore be stored securely. An alternative, if it is inappropriate to store
    this file securely, is to remove the sensitive information from this file and
    supply the sensitive information when the `helm install` command is executed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each component is assigned the Secrets it requires.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recap from the previous chapter: the Secrets will be mapped into each Pod as
    environment variables.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, the product service needs access to both MongoDB and RabbitMQ
    and is therefore assigned the following two Secrets:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most of the changes in the Helm charts’ `values.yaml` files end up in Kubernetes
    manifests for `Deployment` objects. For example, the `product` microservice’s
    `Deployment` object will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that parts of the manifest that have not been affected by the changes above
    have been omitted for improved readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to render a component’s Kubernetes manifest yourself, you can do
    that by applying Helm’s `template` command on the chart of interest. You must
    also add values from the environment’s `values.yaml` file that are applicable
    for the component of the `template` command. Take the `product` service as an
    example. The `dev-env` chart’s `values.yaml` file contains the following settings
    that apply to the `product` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To add these settings to the `template` command, we can use the `--set` flag.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `--values` flag that can be used to add a `values.yaml` file
    when the command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding values from an environment chart, we must remember that they are
    parent charts to the component charts. This means that the name of the component
    chart must be removed from the settings when applied directly to the component
    chart. In this case, it means that we should add the following values to the `template`
    command to render the `product` chart correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'YAML arrays like the one above can be defined using the `--set` flag by listing
    the elements within curly braces, for example, `"{a,b,c}"`. The `product` chart
    can be rendered using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result will contain manifests for the `product` microservice, a ConfigMap,
    a Service, and finally, a `Deployment` object.
  prefs: []
  type: TYPE_NORMAL
- en: This is what is required to replace the configuration server with Kubernetes
    ConfigMaps and Secrets. In the next section, we will learn about how we can replace
    the Spring Cloud Gateway with a Kubernetes Ingress object.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will further simplify the microservice landscape by replacing
    the Spring Cloud Gateway using the built-in Ingress object in Kubernetes, reducing
    the number of supporting services required to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in *Chapter 15*, *Introduction to Kubernetes*, an Ingress object
    can be used in Kubernetes to act as an edge server in the same way as a Spring
    Cloud Gateway. The Spring Cloud Gateway comes with a richer routing functionality
    compared to an Ingress object. However, the Ingress is part of the Kubernetes
    platform, requiring no extra deployments, and can also be extended using cert-manager
    to automatically provision certificates, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used the Spring Cloud Gateway to protect our microservices from
    unauthenticated requests, by requiring a valid OAuth 2.0/OIDC access token from
    a trusted OAuth authorization server or OIDC provider. See *Chapter 11*, *Securing
    Access to APIs*, if a recap is required. Generally, Kubernetes Ingress objects
    do not have support for this. Specific implementations of the Ingress controller
    might, however, support it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the composite health check we added to the gateway in *Chapter 10*,
    *Using Spring Cloud Gateway to Hide Microservices behind an Edge Server*, can
    be replaced by the Kubernetes liveness and readiness probes defined in each microservice’s
    deployment manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in the same way as for the Spring Cloud Config Server, it makes sense
    to use the Spring Cloud Gateway where the underlying platform doesn’t provide
    a similar capability. When deploying to Kubernetes, it is better to use Ingress
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delegate the responsibility of validating that the
    request contains a valid access token to the `product-composite` microservice.
    This is done by the Ingress forwarding the HTTP header that contains the access
    token in the requests to the `product-composite` microservice, and it will perform
    its validation of the OAuth access tokens as in the previous chapters. The next
    chapter will introduce the concept of a service mesh, where we will see an alternative
    implementation of an Ingress that fully supports validating JWT-encoded OAuth
    access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Verifying that the microservices work without Kubernetes* section, we
    will still use the Spring Cloud Gateway together with Docker Compose, so we will
    not remove the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows that the Spring Cloud Gateway is removed from the
    microservice landscape when deploying to Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, diagram, text, application  Description automatically
    generated](img/B19825_17_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Replacing the Spring Cloud Gateway with the Kubernetes built-in
    Ingress controller'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what is required to replace the Spring Cloud Gateway with a Kubernetes
    Ingress object!
  prefs: []
  type: TYPE_NORMAL
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  prefs: []
  type: TYPE_NORMAL
- en: Changes required to replace the Spring Cloud Gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following changes have been applied to the configuration of the source
    code to replace the Spring Cloud Gateway with a Kubernetes Ingress object:'
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the Helm chart for the Spring Cloud Gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have added a named template for Ingress manifests and some default values
    for the Ingress in the `common` chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The named template, `kubernetes/helm/common/templates/_ingress.yaml`, begins
    with a declaration that we recognize from the previous chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name of the template is `common.ingress`, and the `apiVersion` and `kind`
    are set to `networking.k8s.io/v1` and `Ingress, respectively,` to identify it
    as an Ingress manifest. Most of the remainder of the template above looks the
    same as seen in other manifests where overriding parameters is required, such
    as the `Deployment` or `Service` template. The only new part is that the template
    allows the addition of annotations, if required, using the `ingress.annotations`
    field in the `values.yaml` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the Ingress template contains the main part of the manifest, the
    `spec` part. It looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First comes a `tls` section where the manifest declares that the Ingress only
    accepts HTTPS traffic and that the accepted `hostname` will be specified with
    the key `ingress.host` in the `values.yaml` files. The certificate used for serving
    HTTPS requests will be stored in a Secret named as specified in the `values.yaml`
    files using the `ingress.tls.secretName` key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next are the routing rules declared in the `rules` section. First is the hostname
    used for routing. This will be the same hostname as in the `tls` section above.
    Next comes a list of routes. They will be filled in using the `ingress.paths`
    section in the `values.yaml` file. Each entry contains a `path` and the name of
    the `service` that requests to that path will be routed to. Each service is expected
    to have the name of its port set to `http`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `common` chart’s `values.yaml` file provides the following default values
    for the Ingress manifest:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First is an annotation, `cert-manager.io/issuer`, declared for the Ingress object,
    indicating that cert-manager should manage the required certificate for this Ingress
    object using an issuer named `selfsigned`. More about this is below, in the *Automating
    certificate provisioning* section. Next is the Secret that will hold the certificate,
    given the default name `tls-certificate`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have added templates and additional settings to the environment charts,
    `dev-env` and `prod-env`, for Ingress manifests. The templates are named `ingress.yml`
    and are based on the named template from the `common` chart described above:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The remaining values required to render an Ingress manifest, a `hostname` and
    the actual `paths` used for routing, are specified in each environment chart’s
    `values.yaml` files. The declaration looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the configuration, we can see that we will use the hostname `minikube.me`
    and that three routes are defined for the `auth-server`, while the rest of the
    declared paths will be routed to the `product-composite` service.
  prefs: []
  type: TYPE_NORMAL
- en: We will register the hostname `minikube.me` in the local `/etc/hosts` file later,
    in the *Testing with Kubernetes ConfigMaps, Secrets, Ingress, and cert-manager*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The changes above will result in an Ingress manifest being rendered by Helm.
    Since the Ingress template is only used by the environments charts, we need to
    render one of the environment charts to see the Ingress manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to render manifests using the `dev-env` chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Look for `kind: Ingress` in the output and you will find the Ingress manifest.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that some of the routing rules have been removed for improved readability.
  prefs: []
  type: TYPE_NORMAL
- en: The final missing piece is how the Secret containing the certificate is created;
    let’s look into that next.
  prefs: []
  type: TYPE_NORMAL
- en: Automating certificate provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cert-manager tool ([https://cert-manager.io/docs/](https://cert-manager.io/docs/))
    is a certificate management controller for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can facilitate the automated creation, provisioning, and rotation of certificates.
    It supports several sources for the certificates; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: An **RFC8555** ([https://tools.ietf.org/html/rfc8555](https://tools.ietf.org/html/rfc8555))-compliant
    **ACME server** such as **Let’s Encrypt** ([https://letsencrypt.org](https://letsencrypt.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HashiCorp Vault PKI Secrets Engine** ([https://www.vaultproject.io/docs/secrets/pki](https://www.vaultproject.io/docs/secrets/pki))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-signed certificates, issued by cert-manager itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of available issuers, see [https://cert-manager.io/docs/configuration/](https://cert-manager.io/docs/configuration/).
  prefs: []
  type: TYPE_NORMAL
- en: Since self-signed certificates don’t require communication with any external
    resources, they are a good candidate for use during development. We will use them
    within the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using cert-manager in production typically requires the use of an issuer, such
    as Let’s Encrypt, which can issue certificates for the external APIs that the
    API clients (for example, web browsers and external systems) will trust.
  prefs: []
  type: TYPE_NORMAL
- en: After installation of cert-manager in a Kubernetes cluster, at least one issuer
    must be registered. An issuer can either be local to a namespace or accessible
    cluster-wide. We will use a local issuer that is registered in the existing namespace,
    `hands-on`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be the responsibility of the environment charts, `dev-env` and `prod-env`,
    to register a proper issuer. Both environments will use the self-signed issuer.
    A named template, `_issuer.yaml`, has been added to the `common` chart. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apiVersion` and `kind` fields specify that this is an issuer defined by
    cert-manager. Its name is set to `selfsigned`. In the *Changes required to replace
    the Spring Cloud Gateway* section above, we saw how this name was used to annotate
    the Ingress manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is all that it takes to get cert-manager to kick in and provide a certificate
    for the Ingress object. The cert-manager listens for the registration of Ingress
    objects that are annotated with `cert-manager.io/issuer` and starts to issue certificates
    using the issuer referenced in the value of the annotation, in this case, `selfsigned`.
    The cert-manager tool will use the issuer to create a certificate and store it
    in a Secret named by the Ingress object. In our case, the name is set to `tls-certificate`.
    A `Certificate` object will also be created with the same name, containing administrative
    information like when it is time for cert-manager to renew the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the named template, `common.issuer`, does not accept any configuration,
    all that is required to apply it in the `dev-env` and `prod-env` charts is to
    add a template in each chart that uses the named template. The template is named
    `issuer.yaml` and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have everything that is required to replace the Spring Cloud Config
    Server and Gateway with native Kubernetes components and cert-manager. Let’s deploy
    and run some tests!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Kubernetes ConfigMaps, Secrets, Ingress, and cert-manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the preceding changes described, we are ready to test the system landscape
    with the Spring Cloud Config Server and the Spring Cloud Gateway replaced by Kubernetes
    ConfigMaps, Secrets, an Ingress object, and cert-manager. As before, when we used
    the Spring Cloud Gateway as the edge server, the external API will be protected
    by HTTPS. With this deployment, it will be the Ingress controller that uses the
    certificate provisioned by cert-manager to protect the external API with HTTPS.
    This is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Protecting external access using HTTPS'
  prefs: []
  type: TYPE_NORMAL
- en: The Ingress controller is exposed on the default HTTPS port, `443`, on the Minikube
    instance. On the host, where we run the Minikube instance as a Docker container,
    we communicate with the Minikube instance via `localhost`. When the Minikube instance
    was created, port forwarding was configured from port `8443` on `localhost` to
    the `443` port in the Minikube instance. The Ingress controller was installed
    when we performed the `minikube addons enable ingress` command.
  prefs: []
  type: TYPE_NORMAL
- en: For a recap on the setup of the Minikube instance, see the *Creating a Kubernetes
    cluster* section in *Chapter 15*, *Introduction to Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting question here is, how can the Ingress controller use port `443`
    on the Minikube instance? We have seen the use of services of type `NodePort`
    that can allocate a port starting from `30000`, so how can the Ingress controller
    use the standard port for HTTPS, `443`?
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ingress controller consists of a `Deployment` object, `ingress-nginx-controller`,
    in the `ingress-nginx` namespace. The answer to the question is that the `Deployment`
    object configures its Pod using a `hostPort` to map port `443` in the Kubernetes
    host, that is, the Minikube instance, to port `443` in the container that runs
    in the Pod. The central parts in the definition of the `Deployment` object look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This setup works for a single-node Kubernetes cluster used for development and
    testing. In a multi-node Kubernetes cluster, external load balancers are used
    to expose an Ingress controller for high availability and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The `Deployment` object uses the same type of commands as we used in *Chapter
    16*, *Deploying Our Microservices to Kubernetes*; refer to the *Deploying to Kubernetes
    for development and test* section. In this section, we will also install cert-manager
    and add an entry to the`/etc/hosts` file for the hostname `minikube.me`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to deploy the system landscape and verify that
    it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install cert-manager in the `cert-manager` namespace and wait for the deployment
    to complete. Before cert-manager can be installed, we need to add its Helm repository.
    Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The cert-manager tool also comes with a set of Kubernetes **Custom Resource
    Definitions** (**CRDs**), like the `Issuer` object that was introduced above.
    CRDs are used in Kubernetes to extend its API, that is, to add new objects to
    its API. The `--set installCRDs=true` flag in the command above ensures that these
    object definitions are installed when installing cert-manager.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that three Pods are ready in the `cert-manager` namespace with the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect a response like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 17.4: Pods in the cert-manager namespace'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map `minikube.me` to the IP address we can use to reach the Minikube instance
    by adding a line to the `/etc/hosts` file. Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `sudo` command will probably ask for your password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify the result with the `cat /etc/hosts` command. Expect a line that contains
    `127.0.0.1 minikube.me`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your `/etc/hosts` file contains multiple lines for `minikube.me` (for example,
    from earlier attempts), you need to remove the old ones manually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can build Docker images from the source code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `eval $(minikube docker-env -u)` command is used to ensure that the `./gradlew
    build` command uses the host’s Docker engine and not the Docker engine in the
    Minikube instance. The `build` command uses Docker to run test containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the Helm chart dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we update the dependencies in the `components` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we update the dependencies in the `environments` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `hands-on` namespace as the default namespace for `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a separate terminal window, run the following command to monitor how certificate
    objects are created by cert-manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the system landscape using Helm and wait for all deployments to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note how the certificate is created by cert-manager during the deployment.
    Expect the following output from the `kubectl get certificates` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B19825_17_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Events from cert-manager provisioning a certificate'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the `kubectl get certificates` command with *Ctrl*+ *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the test to verify that the system landscape works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect output from the tests similar to what we obtained in the previous chapter
    (in a condensed format):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Verifying the system landscape created by the dev-env Helm chart'
  prefs: []
  type: TYPE_NORMAL
- en: Before wrapping up the `dev-env`, let’s try out the certificate object that
    cert-manager created and see how it can be used to affect the retention time for
    the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start getting acquainted with the certificate object by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the output from the command, we will find the following information
    regarding the time that the certificate will be valid for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_17_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Certificate validation period and renewal time'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the certificate is valid for 90 days (**Not After** – **Not
    Before**) and that cert-manager will try to renew it after 60 days (**Renewal
    Time** – **Not Before**). Since the self-signed issuer we are using doesn’t allow
    any configuration, these are the default values that cert-manager uses: 90 days,
    lifetime and a renewal process that is initiated after 2/3 of the lifetime.'
  prefs: []
  type: TYPE_NORMAL
- en: But we don’t want to wait 60 days before we can observe a renewal of the certificate.
    If we study the API specification for the certificate object at [https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.Certificate](https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.Certificate),
    we will find a field in the `spec` section that is of interest.
  prefs: []
  type: TYPE_NORMAL
- en: It is named `renewBefore` and can be used to specify how early cert-manager
    should start the renewal process. If we want the certificate to be renewed once
    per minute, we can specify the `renewBefore` to be 90 days – 1 minute = 90*24
    hours – 1 minute = 2160 hours – 1 minute = 2159 hours and 59 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the `kubectl get events -w` command in a separate terminal window and
    run the following `patch` command to add the `renewBefore` field to the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Within 1 minute, the `get events` command should start to report on certificate
    renewals. For each renewal, the following should be printed by the `get events`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_17_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.8: Events from cert-manager rotating a certificate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait a couple of minutes to verify that the certificate is renewed once per
    minute. If you are curious about when the next renewal will happen, you can issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It should respond with a date like **2023-05-07T05:58:40Z**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you no longer want to have a custom retention time, you can remove the `renewBefore`
    field with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes the tests we will do in the system landscape deployed using
    the `dev-env` chart. We can remove the system landscape with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let us also recap how to deploy the system landscape using the `prod-env` chart!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes for staging and production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deploying to a staging and production environment using the `prod-env` chart
    follows the same steps as we used in the *Deploying to Kubernetes for staging
    and production* section in *Chapter 16*, *Deploying Our Microservices to Kubernetes*.
    The steps are recapitulated here in a compact form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start MySQL, MongoDB, and RabbitMQ outside of Kubernetes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tag Docker images with `v1` versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the microservices using the `prod-env` Helm chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test to verify that the system landscape works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are done, clean up the resources created in both Kubernetes and Docker
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the `kubectl get cert -w` and `kubectl get events -w` commands if they
    still are running by using *Ctrl* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the namespace in Kubernetes with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop MySQL, MongoDB, and RabbitMQ with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we are done with all tests running on Kubernetes. Let’s see how to
    verify that the microservices still work *without* Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the microservices work without Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter and the previous one, we have seen how features in the Kubernetes
    platform, such as ConfigMaps, Secrets, Services, and Ingress objects, can simplify
    the effort of developing a landscape of cooperating microservices. But it is important
    to ensure that the source code of the microservices doesn’t become dependent on
    the platform from a functional perspective. Avoiding such a lock-in makes it possible
    to change to another platform in the future, if required, with minimal effort.
    Changing the platform should not require changes in the source code, but only
    in the configuration of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the microservices using Docker Compose and running the `test-em-all.bash`
    verification script will ensure that they work from a functional perspective without
    Kubernetes. When running microservices without Kubernetes, we will lack the non-functional
    features that Kubernetes provides us with, for example, monitoring, scaling, and
    restarting containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Docker Compose, we will replace the following Kubernetes features:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of ConfigMaps, we will use volumes that map the configuration files
    directly from the host filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using Secrets, we will keep sensitive information such as credentials
    in the Docker Compose `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of an Ingress, we will use the Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of Services, we will map hostnames used by the clients directly to the
    hostnames of the containers, meaning that we will not have any service discovery
    in place and will not be able to scale containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker Compose this way will result in significant disadvantages from
    a non-functional perspective compared to using Kubernetes. But this is acceptable,
    given that Docker Compose will only be used to run functional tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the changes in the `docker-compose*.yml` files before we run
    the tests using Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Docker Compose files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run microservices outside Kubernetes, using Docker Compose, the following
    changes have been applied to the `docker-compose*.yml` files:'
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the configuration server definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have removed the use of the following configuration server environment variables:
    `CONFIG_SERVER_USR` and `CONFIG_SERVER_PWD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have mapped the `config-repo` folder as a volume in each container that needs
    to read configuration files from the configuration repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have defined the `SPRING_CONFIG_LOCATION` environment variable to point to
    the configuration files in the configuration repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have stored sensitive information such as credentials and passwords in TLS
    certificates in the Docker Compose `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have defined environment variables with credentials for access to resource
    managers, using the variables defined in the `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the configuration of the `product` microservice looks like the
    following in `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `config-repo` folder is mapped as a volume into the container at `/config-repo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml`
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `.env` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The credentials referred to in the preceding source code are defined in the
    `.env` file as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Testing with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test with Docker Compose, we will use Docker Desktop instead of Minikube.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To direct the Docker client to use Docker Desktop instead of Minikube, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid port conflicts on port `8443`, you need to stop the Minikube instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the Docker images in Docker Desktop with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests using RabbitMQ (with one partition per topic):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tests should begin by starting all the containers, running the tests, and
    finally, stopping all the containers. Expect output similar to what we have seen
    in the previous chapters (output reduced to improve readability):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19825_17_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: Verifying the functionality of the system landscape without using
    Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, run the tests using RabbitMQ with multiple partitions per topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect output that’s similar to the preceding test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, run the test using Kafka with multiple partitions per topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect output that’s similar to the preceding test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since it can take a few seconds for the Kafka broker to decide which partition
    to assign to the instances in the consumer groups, the tests can fail since the
    rebalancing operation is still in progress when the tests are started. If the
    test fails, then rerun the command, but without the `start` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Minikube instance, and set the default namespace to `hands-on`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the successful execution of these tests, we have verified that the microservices
    also work without Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how capabilities in Kubernetes can be used to
    simplify a microservice landscape, meaning that we reduce the number of supporting
    services to be developed and deployed together with the microservices. We have
    seen how Kubernetes ConfigMaps and Secrets can be used to replace the Spring Cloud
    Config Server and how a Kubernetes Ingress object can replace the Spring Cloud
    Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Using cert-manager allowed us to automatically provision certificates for HTTPS
    endpoints exposed by the Ingress controller, eliminating the need for manual and
    cumbersome work.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the source code of the microservices can run on other platforms,
    that is, isn’t locked into Kubernetes, we deployed the microservices using Docker
    Compose and ran the `test-em-all.bash` test script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be introduced to the concept of a service mesh
    and learn how a service mesh product, **Istio**, can be used to improve observability,
    security, resilience, and routing in a landscape of cooperating microservices
    that are deployed on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How was the Spring Cloud Config Server replaced by Kubernetes resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How was the Spring Cloud Gateway replaced by Kubernetes resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to make cert-manager automatically provision certificates for
    an Ingress object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the retention time of a certificate be checked and updated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the actual certificate stored?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we run the tests using Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
