- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Understanding Common Anti-Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见反模式
- en: Throughout the previous chapters, we have explored the *green working paths*
    of imaginary vehicle-related applications. In this chapter, the abstraction of
    the vehicle will remain a supporting element, because one may imagine a vehicle-inspired
    application more easily than other abstractions. A vehicle, along with all of
    its parts, is an idea that’s easy to grasp.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了想象中与车辆相关的应用的*绿色工作路径*。在本章中，车辆的抽象将保持为一个辅助元素，因为人们可能比其他抽象更容易想象出受车辆启发的应用。一辆车及其所有部件，是一个容易理解的概念。
- en: Let’s quickly recap the importance of design patterns and how they contribute
    to the success of an organization’s success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下设计模式的重要性以及它们如何有助于组织的成功。
- en: Melvin E. Conway said that the design and implementation of an application strongly
    reflect an organization’s internal communication. This statement is no less relevant
    today, especially now that many projects use agile approaches. Automated builds,
    continuous integration or testing, and subsequent automated deployment play a
    key role in delivering applications to production. Any overlooked or unexpected
    limitation can limit or damage an application’s main objective.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 梅尔文·E·康威说，应用程序的设计和实现强烈反映了组织的内部沟通。这个说法在今天仍然具有同等的相关性，尤其是在许多项目使用敏捷方法的情况下。自动构建、持续集成或测试以及随后的自动化部署在将应用程序交付到生产中起着关键作用。任何被忽视或意外的限制都可能限制或损害应用程序的主要目标。
- en: In this chapter, we will review some important areas for identifying signs of
    deviation from the main goal so that you can have functional, maintainable, and
    transparent applications. Not having those qualities can negatively affect application
    functionality on multiple levels. Runtime could be damaged, which might result
    in unpredictable costs. Faults could be hidden in application architecture, disallowing
    extendibility and maintainability. Such issues could also recur and require specialized
    attention in each case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些识别偏离主要目标迹象的重要领域，以便您能够拥有功能性强、可维护和透明的应用程序。缺乏这些品质可能会在多个层面上对应用程序的功能产生负面影响。运行时可能会受损，这可能导致不可预测的成本。错误可能隐藏在应用程序架构中，不允许扩展性和可维护性。这些问题也可能反复出现，并需要在每个案例中都需要专业的关注。
- en: 'We will concentrate on the following areas:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于以下领域：
- en: What anti-patterns are and how to identify them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是反模式以及如何识别它们
- en: Examining typical software anti-patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查典型的软件反模式
- en: Understanding software architecture anti-patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件架构反模式
- en: By the end of this chapter, you will be able to identify and understand some
    of the signs of anti-patterns that should be looked out for.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够识别和理解一些应该注意的反模式迹象。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07)。
- en: What anti-patterns are and how to identify them
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是反模式以及如何识别它们
- en: One might define an anti-pattern as the exact opposite of a good design pattern
    or good practice. Though that might seem like the bottom line, it ignores the
    context and sequence of actions that led to a software practice being called an
    anti-pattern. In other words, it does not explain why an anti-pattern is a collection
    of highly risky, ineffective, and counterproductive steps. It is important to
    understand these steps as they allow creating a repeatable process to obtain a
    similar result, just to verify the ambiguity. The bottom line is that these steps
    may limit the ability to productively address the issues. Let us dive a bit deeper
    into the theory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可能将反模式定义为优秀设计模式或良好实践的完全相反。尽管这可能看起来是底线，但它忽略了导致软件实践被称为反模式的具体背景和行动顺序。换句话说，它没有解释为什么反模式是一系列高度风险、无效和反生产性的步骤。理解这些步骤很重要，因为它们允许创建一个可重复的过程来获得类似的结果，只是为了验证其模糊性。底线是，这些步骤可能会限制有效地解决问题的能力。让我们更深入地探讨一下理论。
- en: Theoretical principles challenges
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论原则挑战
- en: Anti-patterns can naturally appear during software development due to multiple
    reasons. They may be due to a shift in business logic, technology migration, or
    missing information. The fact remains that anti-patterns do occur and, simply
    put, can be part of the development process due to team size, communication issues,
    and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多种原因，反模式可能会在软件开发过程中自然出现。它们可能是由于业务逻辑的变化、技术迁移或信息缺失。事实仍然是，反模式确实存在，简单来说，由于团队规模、沟通问题等，它们可能是开发过程的一部分。
- en: The key question is how to identify them. In [*Chapter 1*](B18884_01.xhtml#_idTextAnchor016),
    *Getting into Software Design Patterns*, we touched on the negative impact of
    violating the APIE and SOLID design principles; this can be a symptom that can
    be a signal to consider a source code refactoring response. Another phenomenon
    would be not respecting the **CAP** theorem (**Consistency**, **Availability**,
    and **Partition tolerance**). Development time may have been invested in trying
    to achieve all three properties at the same time, which is impossible. Such attempts
    could be seen as a strong signal to rethink the development strategies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是如何识别它们。在[*第一章*](B18884_01.xhtml#_idTextAnchor016)《进入软件设计模式》中，我们提到了违反APIE和SOLID设计原则的负面影响；这可能是考虑源代码重构响应的信号。另一种现象可能是不尊重**CAP定理**（**一致性**、**可用性**和**分区容错性**）。开发时间可能已经投入到试图同时实现这三个属性，这是不可能的。这样的尝试可能被视为重新思考开发策略的强烈信号。
- en: Although the principles of APIE and SOLID tend to be considered common knowledge,
    the truth is different, especially in the area of creating agile approaches and
    completing tasks. Development can tend to create continuous technical debt. The
    word *continuous* is quite important because the accumulation of such debt may
    lead to very unpleasant consequences.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然APIE和SOLID的原则通常被认为是常识，但事实并非如此，尤其是在创建敏捷方法和完成任务方面。开发可能会倾向于产生持续的技术债务。这个词“持续”非常重要，因为这种债务的积累可能会导致非常不愉快的后果。
- en: Collecting technical debt as a bottleneck
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将技术债务作为瓶颈收集
- en: Technical debt is an interesting concept because it requires the context of
    the software application and its goal in order to understand it. Technical debt
    contains some properties that may not be obvious at first glance, but may lead
    to a serious application bottleneck. Let’s imagine a vehicle production line as
    a collection of multiple processes running under various dynamics in parallel.
    The production line should deliver the expected result in the form of a vehicle.
    If there were an accumulation of bottlenecks, though, the result would not be
    achieved. This abstraction of a vehicle production line is quite simple, but putting
    it into the context of running software may be more difficult, as software relies
    on underlying technologies, platforms, and hardware.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是一个有趣的概念，因为它需要软件应用及其目标的上下文才能理解。技术债务包含一些可能一开始并不明显的属性，但可能导致严重的应用瓶颈。让我们想象一个汽车生产线，它是由多个在并行运行的各种动态下的过程组成的集合。生产线应以车辆的形式交付预期的结果。如果存在瓶颈的积累，那么结果将无法实现。这种汽车生产线的抽象相当简单，但将其应用于运行中的软件可能更困难，因为软件依赖于底层技术、平台和硬件。
- en: The Java platform comes with some caveats that must be accounted for. Basically,
    the rule is that the developer respects the platform and the platform does its
    best to serve a running software.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台有一些必须考虑的注意事项。基本上，规则是开发者尊重平台，平台尽力为运行中的软件提供服务。
- en: Inappropriately squeezing the capabilities of the Java platform
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不恰当地挤压Java平台的能力
- en: In [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for Design Patterns*, we touched on important topics such as types and memory
    models; not accounting for these may be considered an anti-pattern. As a reminder
    of the multi-threaded nature of the Java platform, we can mention the Java memory
    model, which guarantees the visibility of values to the application in a multi-threaded
    environment. Another thing that may turn into an anti-pattern is a garbage collection
    algorithm running in a separate thread alongside the main application execution
    thread. Because a Java application works with the final allocated memory space
    (the heap), the garbage collector tries to ensure that there is still an appropriate
    amount of heap memory available for use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18884_02.xhtml#_idTextAnchor037)，*《发现Java平台设计模式》*中，我们讨论了诸如类型和内存模型等重要主题；不考虑这些可能被视为反模式。作为Java平台多线程特性的提醒，我们可以提到Java内存模型，它保证在多线程环境中应用程序对值的可见性。另一个可能变成反模式的是在主应用程序执行线程旁边运行的垃圾回收算法。因为Java应用程序与最终分配的内存空间（堆）一起工作，垃圾收集器试图确保仍有足够数量的堆内存可供使用。
- en: 'The acquired knowledge helps us avoid one of the most common misconceptions
    relating to any anti-pattern: **unwanted autoboxing**, or the automatic conversion
    performed by the compiler between primitive types and the wrapper classes.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的知识帮助我们避免与任何反模式相关的最常见误解之一：**不想要的自动装箱**，即编译器在原始类型和包装类之间自动执行转换。
- en: 'The impact of autoboxing is not visible at first glance and may go unnoticed
    until your application faces a critical load. Let us look at aggregating sensor
    values, where each sensor value needs to be validated to identify an alarm. The
    alarm is caused, of course, by the occurrence of a critical value. The alarm system
    starts multiple threads in parallel to verify the delivered values (*Example 7.1*):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装箱的影响初看并不明显，可能直到你的应用程序面临关键负载时才会被发现。让我们看看聚合传感器值的情况，其中每个传感器值都需要经过验证以识别警报。警报当然是由关键值的出现引起的。警报系统并行启动多个线程以验证传递的值（*示例7.1*）：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 7.1 – The SensorAlarmWorker instance attempts to identify a warning
    signal by reading the Sensor instance value
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7.1 – SensorAlarmWorker实例尝试通过读取Sensor实例值来识别警告信号
- en: 'A vehicle sensor alarm system obviously has to analyze a huge amount of data
    delivered by its various sensors in order to identify a critical signal. An autoboxing
    issue tends to be very noticeable as it causes intensive and non-deterministic
    garbage collection (*Figure 7**.1*):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆传感器警报系统显然必须分析其各种传感器提供的海量数据，以识别关键信号。自动装箱问题往往非常明显，因为它会导致密集和非确定性的垃圾回收（*图7**.1*）：
- en: '![Figure 7.1 – The intensive garbage collection causes noticeable delays](img/B18884_07_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 繁重的垃圾回收导致明显的延迟](img/B18884_07_01.jpg)'
- en: Figure 7.1 – The intensive garbage collection causes noticeable delays
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 繁重的垃圾回收导致明显的延迟
- en: 'Although the root cause of the garbage collection seems to be resolved, it
    may appear unexpectedly. *Example 7.1* introduces the `Sensor` record class, holding
    an integer value as a primitive `int` type. The problem becomes apparent when
    the value of the primitive type is autoboxed while passing it to the `evaluateAlarm`
    method, which requires the use of the `Integer` wrapper class. Let us do a one-line
    correction to the `Sensor` value type (*Example 7.2*):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然垃圾回收的根本原因似乎已经解决，但它可能会意外出现。*示例7.1*介绍了`Sensor`记录类，它以原始`int`类型持有整数值。当原始类型的值在传递给需要使用`Integer`包装类的`evaluateAlarm`方法时自动装箱，问题就会显现出来。让我们对`Sensor`值类型进行一行修正（*示例7.2*）：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 7.2 – The Sensor field value is changed to the Integer type and corresponds
    with the method input type
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7.2 – 将Sensor字段值更改为Integer类型，并与方法输入类型相对应
- en: 'This change has quite a significant impact on the whole application, causing
    very limited occurrences of garbage collection. In other words, eliminating unwanted
    delays due to stop-the-world events, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*,*
    *Discovering the Java Platform for Design Patterns* (*Figure 7**.2*), speeds up
    the entire application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改对整个应用程序产生了相当显著的影响，导致垃圾回收的发生非常有限。换句话说，消除了由于停止世界事件（正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)*，*《发现Java平台设计模式》*中了解到）引起的不必要的延迟，从而加快了整个应用程序的运行速度：
- en: '![Figure 7.2 – Garbage collection pressure disappeared because the application
    didn’t create unnecessary short-living objects](img/B18884_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 由于应用程序没有创建不必要的短生命周期对象，垃圾收集压力消失了](img/B18884_07_02.jpg)'
- en: Figure 7.2 – Garbage collection pressure disappeared because the application
    didn’t create unnecessary short-living objects
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 由于应用程序没有创建不必要的短生命周期对象，垃圾收集压力消失了
- en: Autoboxing may sometimes be identified through code reviews, which play an essential
    role in removing the code smell anti-pattern.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可以通过代码审查识别出自动装箱，这在移除代码异味反模式中起着至关重要的作用。
- en: The Java platform contains many useful tools, and using them incorrectly can
    result in an unwanted state. Let’s look at some of these tools in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台包含许多有用的工具，如果使用不当，可能会导致不希望的状态。让我们在下一节中看看这些工具中的一些。
- en: Selecting the right tool
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的工具
- en: 'The next example may seem, at first glance, far from being a code smell. The
    Java platform contains very useful tools that can serve an application well if
    they are properly selected and used. A good example of the importance of careful
    selection is presented by the collection framework. [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*, reviewed different aspects
    of commonly used collection types. This led us to see how a wrong collection selection
    may result in a bottleneck due to the consumption of underlying resources. This
    kind of issue may not be obvious with a small data amount but emerges under bigger
    loads and hits very specific parts of an application. This phenomenon can be called
    the **busy method**, or **hot method** (*Figure 7**.3*):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子乍一看可能似乎与代码异味相去甚远。Java平台包含非常有用的工具，如果它们被正确选择和使用，可以为应用程序提供良好的服务。集合框架提供了一个很好的例子，说明了谨慎选择的重要性。[第2章](B18884_02.xhtml#_idTextAnchor037)，“发现Java平台的设计模式”，回顾了常用集合类型的各个方面。这使我们看到，错误的集合选择可能会导致由于底层资源的消耗而形成瓶颈。这种问题在小数据量下可能不明显，但在更大的负载下出现，并击中应用程序的非常特定的部分。这种现象可以称为**繁忙方法**或**热点方法**（图7.3）。
- en: '![Figure 7.3 – The computation time is limited by busy method execution](img/B18884_07_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 计算时间受繁忙方法执行限制](img/B18884_07_03.jpg)'
- en: Figure 7.3 – The computation time is limited by busy method execution
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 计算时间受繁忙方法执行限制
- en: 'Here the computation work of the application is centralized with one extremely
    busy method execution. `O(n)` time complexity for `ArrayList` with the `O(1)`
    time complexity for `HashSet` instances (*Figure 7**.4*):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，应用程序的计算工作集中在一种极其繁忙的方法执行上。`ArrayList`的`O(n)`时间复杂度与`HashSet`实例的`O(1)`时间复杂度（图7.4）：
- en: '![Figure 7.4 – The collection exchange leads to the desired computation work
    distribution](img/B18884_07_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 收集交换导致所需的计算工作分布](img/B18884_07_04.jpg)'
- en: Figure 7.4 – The collection exchange leads to the desired computation work distribution
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 收集交换导致所需的计算工作分布
- en: The correction results in bigger application throughput, which would be desirable
    for a vehicle data analyzer that attempts to evaluate collected data on a journey.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 修正结果导致更大的应用程序吞吐量，这对于试图在旅途中评估收集数据的车辆数据分析器来说是非常理想的。
- en: Although the code smell was not obvious, it was found because we used the right
    tool. Let’s summarize what we can take from the previous sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码异味并不明显，但我们之所以发现它，是因为我们使用了正确的工具。让我们总结一下从前几节中我们可以学到的东西。
- en: Conclusion of the code smell anti-pattern
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码异味反模式的结论
- en: In this chapter, we discovered that any attempt to challenge theoretical principles
    leads to an anti-pattern known as a code smell.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现任何试图挑战理论原则的尝试都会导致一个被称为代码异味反模式。
- en: We reviewed a case where unknown code smells posed a threat to an application’s
    goals. We talked about how each bottleneck needs to be understood in its context
    before we try to solve it. Removing such bottlenecks without understanding the
    important details may result in another anti-pattern and a never-ending cycle
    of refactoring, as the presented examples showed (*Figure 7**.1* and *Figure 7**.3*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了一个案例，其中未知的代码异味对应用程序的目标构成了威胁。我们讨论了在尝试解决瓶颈之前，需要在其上下文中理解每个瓶颈。在不理解重要细节的情况下移除这种瓶颈可能会导致另一个反模式和重构的无限循环，正如所展示的示例（图7.1和图7.3）所示。
- en: Another counterproductive thing to do would be optimizing the code base without
    solving the underlying technical debt, which may result not only in questionable
    application throughput degradation but also unwanted behavior.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种无效的做法是在没有解决潜在的技术债务的情况下优化代码库，这可能会导致应用吞吐量下降的问题，也可能导致不希望的行为。
- en: Before moving on to some of the most well-known software anti-patterns, let’s
    make some final considerations. Any anti-pattern can be caused by a migration
    where technical debts have been created, including incorrect information. Their
    appearance may be a side effect of incorrectly selected platform tools or a lack
    of awareness of the theory behind the Java programming language. Since this topic
    can become controversial, I'll leave you to draw your own conclusions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续探讨一些最著名的软件反模式之前，让我们做一些最后的考虑。任何反模式都可能是由于迁移过程中产生了技术债务，包括错误的信息。它们的出现可能是由于选择了不正确的平台工具或对Java编程语言背后的理论缺乏认识。由于这个话题可能会引起争议，我将留给你们自己得出结论。
- en: Examining typical software anti-patterns
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查典型的软件反模式
- en: The literature on this topic is full of different kinds of anti-patterns, some
    of which have very funny names, even though their impact is anything but funny.
    Sometimes anti-patterns can be the result of a lack of discipline in providing
    tested, well-structured, and maintainable code to colleagues. An often-used term
    today in this field is **clean code**. The following sections will explore some
    common anti-patterns that can be found in code bases, more specifically in method
    implementations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的文献充满了各种各样的反模式，其中一些有着非常有趣的名字，尽管它们的影响远非有趣。有时，反模式可能是由于在向同事提供经过测试、结构良好和可维护的代码时缺乏纪律。今天在这个领域中经常使用的一个术语是**清洁代码**。以下几节将探讨一些在代码库中可以找到的常见反模式，特别是方法实现中的反模式。
- en: Spaghetti code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意面代码
- en: 'Multiple factors may contribute to an application code base appearing very
    unstructured: that’s the first sign of a code smell. In such cases, one of the
    most famous anti-patterns, **spaghetti code**, tends to appear. Spaghetti code
    may remain overlooked due to the fact that interfaces still remain coherent, but
    their implementation will contain long methods with interconnected dependencies
    (*Example 7.3*):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 多个因素可能导致应用程序代码库看起来非常无结构：这是代码恶臭的第一个迹象。在这种情况下，最著名的反模式之一，**意面代码**往往会出现。由于接口仍然保持一致，意面代码可能仍然被忽视，但它们的实现将包含长方法，具有相互关联的依赖关系（*示例7.3*）：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 7.3 – An unclear drive() method that contains logic for everything from
    engine control to brake checks
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7.3 – 一个不清晰的drive()方法，其中包含从引擎控制到刹车检查的所有逻辑
- en: In such a state, it is nearly impossible to extend the application or verify
    its functionality. Sometimes, such code may become legacy code, which people will
    then use as an excuse. Such excuses will not contribute to the application’s success;
    the solution lies in refactoring and cleaning up the code base.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 处于这种状态时，几乎不可能扩展应用程序或验证其功能。有时，这样的代码可能成为遗留代码，人们随后会以此为借口。这样的借口不会有助于应用程序的成功；解决方案在于重构和清理代码库。
- en: Cut and paste programming
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪贴板编程
- en: This anti-pattern is perhaps another of the most common ones, where previously
    developed code is used to address the next challenge. This may seem like a smart
    reuse of code, but it can very quickly turn into a maintenance nightmare because
    the initial implementation conditions are completely ignored. This is a problem
    especially when the initial code was already anti-pattern-prone and ignored the
    principles mentioned in the previous chapters. The reuse of already-generated
    code should be done wisely in order to provide good protection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式可能是最常见的之一，其中以前开发的代码被用来应对下一个挑战。这看起来像是一种聪明的代码重用，但它可能很快就会变成一个维护噩梦，因为初始的实现条件被完全忽视了。这是一个问题，尤其是当初始代码已经存在反模式倾向并且忽略了前几章中提到的原则时。为了提供良好的保护，应该明智地重用已经生成的代码。
- en: Blob
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: 'This pattern can be identified in many older monolithic systems and applications.
    Nowadays, developers will claim that the problem has been overcome. The truth
    is not so certain. Not even frameworks are resistant to this anti-pattern. An
    anti-pattern can also be presented by a package that contains the most essential
    collection of divine classes or just one, the God class. This anti-pattern can
    often reside in classes called controllers, which control the entire behavior
    of an application. Such controllers accumulate a large number of different methods
    with different functionalities, meaning that the separation of concerns can end
    up being forgotten (*Example 7.4*):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以在许多较老的单一系统中识别出来。如今，开发者会声称这个问题已经得到了解决。但事实并非如此确定。甚至框架也无法抵御这种反模式。一个包含最基本的神圣类集合或仅包含一个，即上帝类的包，也可能表现出这种反模式。这种反模式通常存在于被称为控制器的类中，它们控制着应用程序的整个行为。这样的控制器积累了大量具有不同功能的不同方法，意味着关注点的分离最终可能会被遗忘（*示例
    7.4*）：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 7.4 – The instance of VehicleBlob attempts to control each possible
    part
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7.4 – VehicleBlob 实例尝试控制每个可能的部分
- en: A counterargument regarding the hypothetical maintainability of the code base
    could be considered invalid because such code might be difficult to test, perhaps
    even impossible. A similar problem can occur when the singleton design pattern
    is improperly overused. Once the blob anti-pattern is identified, it’s a great
    time to start thinking about creating simple diagrams supported by refactoring
    the source code before it’s too late.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码库假设可维护性的反论可能被认为是无效的，因为这样的代码可能难以测试，甚至可能无法测试。当单例设计模式被过度使用时，也可能出现类似的问题。一旦识别出
    blob 反模式，就是开始思考在为时已晚之前通过重构源代码创建简单图表的大好时机。
- en: Lava flow
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 火山熔岩流
- en: Clean code is sometimes used as a deep term. Nowadays, it is becoming a common
    practice to push a proof-of-concept application directly into production without
    further thought. This anti-pattern arises when incompatibility or extensibility
    problems start to appear. The fact that the proof of concept verified a possible
    solution does not guarantee that it was prepared for production according to common
    development principles and techniques. This anti-pattern can be identified by
    the occurrences of long implementation classes whose purpose has been lost over
    time, but everyone is afraid to remove them because it might affect the system.
    This anti-pattern was named after lava, a hot liquid that flows down a volcano
    until it catches fire. In the era of microservices, distributed systems, and cloud
    solutions, an example of shared functionalities, such as libraries or solutions,
    can be considered. When such a pattern emerges in the development process, it
    may be a good time to re-evaluate the design of the code base, perhaps draw some
    diagrams, and apply conclusions to mitigate the possibility of a fire.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码有时被用作一个深层次的术语。如今，直接将概念验证应用程序投入生产而不做进一步思考已成为一种常见的做法。当出现不兼容或可扩展性问题，这种反模式就会出现。概念验证验证了一个可能的解决方案，但这并不保证它已经根据常见的开发原则和技术为生产做好了准备。这种反模式可以通过出现长期实现类来识别，随着时间的推移，其目的已经消失，但每个人都害怕删除它们，因为可能会影响系统。这种反模式是以火山熔岩命名的，火山熔岩是一种热液，它沿着火山流下直到着火。在微服务、分布式系统和云解决方案的时代，共享功能，如库或解决方案的例子，可以考虑。当这种模式在开发过程中出现时，可能就是重新评估代码库设计的大好时机，也许可以绘制一些图表，并应用结论来减轻火灾的可能性。
- en: Functional decomposition
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能分解
- en: The functional decomposition anti-pattern may seem outdated due to the use of
    modern frameworks and the fact that the anti-pattern is better known in the field
    of procedural languages. The reality may be slightly different, as many legacy
    systems were migrated without sufficient understanding of the code base and business
    logic. Identifying the anti-pattern is trivial, as it’s impossible not to notice
    a code base containing many classes with a single responsibility, a lack of abstraction,
    and big cohesion. The root cause of this anti-pattern may be a lack of understanding
    of the basic principles of object-oriented programming or a misunderstanding of
    the application’s goal. The solution is to refactor the code base according to
    the required abstraction level while keeping in mind programming principles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了现代框架以及反模式在过程语言领域的知名度更高，功能分解反模式可能看起来已经过时。但现实可能略有不同，因为许多遗留系统在没有充分理解代码库和业务逻辑的情况下进行了迁移。识别这种反模式是微不足道的，因为不可能不注意到包含许多具有单一职责、缺乏抽象和高度内聚的类的代码库。这种反模式的根本原因可能是对面向对象编程的基本原则理解不足或对应用程序目标的误解。解决方案是根据所需的抽象级别重构代码库，同时牢记编程原则。
- en: Boat anchor
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 船锚
- en: Sometimes an application or a newly developed piece of software may inherit
    an outdated abstraction that becomes unnecessary. This abstraction can turn into
    a bottleneck not only because it requires maintenance but also because it can
    easily be replicated widely across a code base. The worst case can be the large
    utilization of this abstraction inside shared libraries or application modules.
    The anti-pattern can accelerate the degradation of the application code base at
    various levels.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个应用程序或新开发的软件可能继承了一个过时的抽象，这变得不再必要。这种抽象可能成为瓶颈，不仅因为它需要维护，而且因为它可以很容易地在代码库中广泛复制。最坏的情况可能是这种抽象在共享库或应用程序模块中的大量使用。这种反模式可能会加速应用程序代码库在各个层面的退化。
- en: One easy way to mitigate this is to keep in mind the SOLID design and APIE principles
    to allow for continuous refactoring. This enables the utilization of previously
    learned design patterns.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一种减轻这种情况的简单方法是在心中牢记SOLID设计和APIE原则，以允许持续重构。这使可以利用之前学到的设计模式。
- en: Conclusion
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Being able to identify and describe some of the most common deviations from
    well-known principles and approaches brings value to any project. In this subsection,
    we have examined anti-patterns and proposed solutions to keep your code base maintainable
    and readable. The last point we want to make in this section is about the proper
    naming of methods, fields, and classes, which can significantly improve readability
    and maintainability and limit the misunderstanding of API use. Proper naming is
    also important as it allows a good understanding of UML diagrams. The next section
    takes us more into source code architecture.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 能够识别和描述一些常见的偏离已知原则和方法的偏差，为任何项目带来价值。在本小节中，我们研究了反模式并提出了保持代码库可维护和可读性的解决方案。本节最后一点是关于方法、字段和类的适当命名，这可以显著提高可读性和可维护性，并限制对API使用的误解。适当的命名也很重要，因为它允许对UML图有一个良好的理解。下一节将带我们更深入地了解源代码架构。
- en: Understanding software architecture anti-patterns
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件架构反模式
- en: A clear understanding of classes, packages, and module composition can be seen
    as essential not only to the application itself, but, as we learned in [*Chapter
    2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform for Design
    Patterns*, to the platform as well. Thanks to the dynamic translation of the bytecode
    that the JIT compiler processes, the Java platform collects essential information
    about its optimization. Poor code quality and software architecture can cause
    latency, improper memory usage, or crashes. Let’s understand the possible obstacles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对类、包和模块组成的清晰理解不仅对应用程序本身至关重要，正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)中学习的，“发现Java平台设计模式”，对平台也是如此。多亏了JIT编译器处理的字节码的动态翻译，Java平台收集了有关其优化的关键信息。糟糕的代码质量和软件架构可能导致延迟、不正确的内存使用或崩溃。让我们了解可能的障碍。
- en: Golden hammer
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金锤
- en: One proven approach applied over a period of time without exploration of alternatives
    can easily turn into legacy code. The fact that it is difficult to accept other
    proposals or migration may be due to a particular set of approaches, otherwise
    known as the golden hammer anti-pattern, where developers believe that there is
    no need to investigate whether changes to something would be beneficial when it
    has been working fine for several years. A great example would be a vendor-specific
    database or tool, and the problem arises when the application needs to migrate
    to microservices or a more distributed design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间内应用一种经过验证的方法，而不探索替代方案，很容易变成遗留代码。难以接受其他提议或迁移的事实可能是因为一组特定的方法，也称为“黄金锤”反模式，其中开发者认为，当某事物已经连续几年运行良好时，没有必要调查对其进行的更改是否会有益。
- en: Scalability is penalized not only by the CAP theorem, as mentioned earlier,
    but may also suffer due to almost impossible usage across designed modules or
    application parts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性不仅受到前面提到的 CAP 定理的惩罚，还可能因为几乎无法在设计模块或应用程序部分之间使用而受到影响。
- en: Using a particular vendor’s product in your application architecture is not
    necessarily an issue. The challenge is that the development of the application
    relies entirely on the capabilities and functions provided by the vendor without
    evaluating its own capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用架构中使用特定供应商的产品并不一定是问题。挑战在于，应用程序的开发完全依赖于供应商提供的功能和能力，而没有评估自身的功能。
- en: A possible solution could be to re-evaluate current development approaches and
    allow for improvement through effective research of solutions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是重新评估当前的开发方法，并通过有效研究解决方案来允许改进。
- en: Continuous obsolescence
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续过时
- en: Improvements are inevitable. Today, products can take advantage of automated
    deployment or continuous integration support with a variety of different test
    scenarios. The rate of improvement is increasing rapidly. A good example is the
    Java platform, which recently reduced its release cadence to 6 months. This fact
    can contribute to the emergence of an anti-pattern, since refactoring is required,
    but on the other hand, it has a great effect on removing previous shortcomings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 改进是不可避免的。今天，产品可以利用自动化部署或持续集成支持，以及各种不同的测试场景。改进的速度正在迅速增加。一个很好的例子是 Java 平台，它最近将其发布周期缩短到
    6 个月。这一事实可能导致反模式的出现，因为需要重构，但另一方面，它对消除以前的缺点有巨大的影响。
- en: 'The continuous obsolescence anti-pattern can be easily identified by an inability
    to move a project to the next phase using continuous integration and delivery
    (*Example 7.5*):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 持续过时反模式可以通过无法使用持续集成和交付将项目推进到下一阶段来轻松识别（*示例 7.5*）：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 7.5 – The VehicleCO abstraction contains outdated methods that still
    need to be tested
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7.5 – VehicleCO 抽象包含需要测试的过时方法
- en: Of course, the concepts of continuous delivery and integration do not give any
    guarantee of code base clarity as they need to be followed by development discipline.
    Continuous clean-code-focused reviews, object-oriented principles, and proper
    patterns can drastically reduce the incidence of continuous obsolescence and have
    a major impact on the entire application architecture.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，持续交付和集成的概念并不提供任何关于代码库清晰度的保证，因为它们需要遵循开发纪律。持续关注清洁代码的审查、面向对象原则和适当的模式可以大大减少持续过时的发生，并对整个应用程序架构产生重大影响。
- en: Input kludge
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入修补
- en: It may not necessarily be obvious at first glance, but the input kludge anti-pattern
    is quite common. A good example would be several connected services that were
    tested until one began to deviate from its functionality. A quick ad hoc solution
    has more side effects that are recognized with a long delay due to disabled tests.
    Various services already had more patches applied than others, so even more tests
    were disabled. The fact remains that those disabled tests were critical to maintaining
    application integrity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能并不明显，但输入修补反模式相当常见。一个很好的例子是几个相互连接的服务，直到其中一个开始偏离其功能才进行测试。一个快速的临时解决方案产生了更多副作用，由于禁用测试而导致的长期延迟才被认识到。各种服务已经应用了比其他服务更多的补丁，因此禁用了更多测试。事实仍然是，那些禁用的测试对于维护应用程序的完整性至关重要。
- en: The solution might be to maintain discipline in testing and ensure that test
    inputs and outputs are valid and updated, rather than turning off essential tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可能是保持测试纪律，确保测试输入和输出有效且更新，而不是关闭必要的测试。
- en: Working in a minefield
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在雷区工作
- en: 'Gone are the days of completely monolithic applications. The current distributed
    nature of applications creates an expectation for application testing to achieve
    continuous delivery and refactoring. Although an application might contain tests
    for known issues, full integrity cannot be ensured. What happens if some enhancements
    are made to an application but they aren''t tested? Even a very small contribution
    to the code base can turn into a nightmare – working with such code bases can
    feel like being in a minefield. The solution to the problem is quite obvious:
    refactoring is required. Isolate the affected part with simplified tests to gain
    stability, apply all the knowledge learned, and slowly continue expanding the
    test base.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完全的单一应用程序时代已经过去了。当前应用程序的分布式特性要求应用测试以实现持续交付和重构。尽管一个应用程序可能包含针对已知问题的测试，但无法保证完全的完整性。如果对应用程序进行了增强但未进行测试，会发生什么？即使是代码库中微小的贡献也可能变成一场噩梦——与这样的代码库合作就像在雷区中行走。解决问题的方案非常明显：需要进行重构。通过简化的测试将受影响的部分隔离以获得稳定性，应用所有学到的知识，并逐渐继续扩展测试库。
- en: Ambiguous viewpoint
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊的观点
- en: In the era of microservices and distributed system design approaches, this anti-pattern
    may significantly damage the final result. The continued presence of this anti-pattern
    can result in an onion architecture approach where the separation of concerns
    and other SOLID principles become theory rather than practice. One indicator of
    this anti-pattern would be the creation of unclear services followed by entities
    for passing redundant information between layers, making the general architecture
    unclear. It can be recognized in its early stages as the presented design models
    do not support any principles of SOLID application design due to incomplete information
    or unclear and overlapping perspectives in the model and potential software design.
    The solution may be effectively executed by the use of a modeling technique, such
    as UML, to ensure visual clarity and source code transparency.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务和分布式系统设计方法的时代，这种反模式可能会对最终结果造成重大损害。这种反模式的持续存在可能导致洋葱架构方法，其中关注点的分离和其他SOLID原则成为理论而不是实践。这种反模式的一个指标是创建不明确的服务，随后是实体，用于在层之间传递冗余信息，使总体架构不明确。在早期阶段，这种反模式可以通过所提供的设计模型不支持任何SOLID应用程序设计原则来识别，因为这些模型由于信息不完整或模型和潜在软件设计中的不明确和重叠视角而存在。解决方案可以通过使用建模技术，如UML，来确保视觉清晰性和源代码透明度来有效执行。
- en: Poltergeists
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鬼火
- en: This anti-pattern cannot be fully ignored. It can be recognized if you can spot
    features that are not expected but suddenly appear and disappear. This anti-pattern
    is the result of very complex abstractions and the implementation of unnecessary
    classes. There are a couple of frameworks on the Java platform that can provide
    useless functionality. We can consider AspectJ and AOP as good examples as their
    usage may be directly responsible for mysterious side effects. The solution is
    to revisit and understand the class hierarchy and life cycles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式不能完全忽视。如果你能发现一些预料之外突然出现又消失的特征，就可以识别出这种反模式。这种反模式是极其复杂的抽象和实现不必要的类所导致的结果。Java平台上有一些框架可以提供无用的功能。我们可以将AspectJ和AOP视为很好的例子，因为它们的使用可能直接导致了神秘的副作用。解决方案是重新审视和理解类层次结构以及生命周期。
- en: Dead end
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死胡同
- en: The growth of the IT industry seems to be unstoppable, as more and more approaches
    and procedures for technical improvements emerge. As such, dependencies on non-updated
    components that were previously built into a system’s architecture can be detrimental
    and may be more difficult to remove than you might expect. Take, for example,
    Java version migrations, where staying with the old version is penalized not only
    by losing support but also by increasing maintenance costs. Trying to scale an
    application can also result in many challenges to do with application testability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: IT行业的发展似乎势不可挡，随着越来越多的技术改进方法和程序的出现。因此，对系统架构中先前构建的非更新组件的依赖可能是有害的，并且可能比预期的更难移除。以Java版本迁移为例，继续使用旧版本不仅会失去支持，还会增加维护成本。尝试扩展应用程序也可能导致许多与应用程序可测试性相关的问题。
- en: Even though this dead-end anti-pattern can be turned into an accepted software
    design, it is recommended to consider alternatives, because doing so may come
    with significant costs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种死胡同反模式可以转变为可接受的软件设计，但建议考虑替代方案，因为这样做可能会带来重大成本。
- en: Conclusion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Not all of the anti-patterns listed are completely bad (see the golden hammer
    or dead end, for example), but generally, any anti-pattern should be re-evaluated
    before it is accepted and documented.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的并非所有反模式都是完全不好的（例如，参见黄金锤或死胡同），但通常，任何反模式在接受和记录之前都应该重新评估。
- en: Java is a very powerful language and platform, not only because it allows using
    instance mutation, but also because it enables entities to hold their state and
    remain immutable. Special attention should be paid to the state of the code base
    in the case of concurrent applications, because such applications must be transparent
    not only to software engineers but also to the Java platform, as we learned in
    [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for Design Patterns*. A concurrent environment brings many possibilities and performance
    improvements on the one hand, but on the other hand, it can cause the misuse of
    certain design patterns, such as the double-checked locking pattern, thanks to
    a poor understanding of the platform (rather than the framework that uses the
    platform).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种非常强大的语言和平台，不仅因为它允许使用实例突变，还因为它使实体能够保持其状态并保持不可变。在并发应用程序的情况下，应特别注意代码库的状态，因为这些应用程序不仅需要对软件工程师透明，还需要对Java平台透明，正如我们在[*第2章*](B18884_02.xhtml#_idTextAnchor037)，“发现Java平台的设计模式”中所学到的。并发环境一方面带来了许多可能性和性能改进，但另一方面，它可能导致对某些设计模式（如双重检查锁定模式）的误用，这归因于对平台（而不是使用该平台的框架）的误解。
- en: A lack of test coverage, code writing discipline, information, or capability
    can also contribute significantly to the occurrence of anti-patterns. From a code
    base architecture perspective, verifying a correctly implemented function can
    become an impossible task or cause additional complications for mocking or debugging.
    Generally speaking, a transparent code architecture is one of the keys to a successful
    application. Let’s recap everything we’ve learned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏测试覆盖率、编码纪律、信息或能力也可能显著导致反模式的出现。从代码库架构的角度来看，验证正确实现的函数可能变得不可能，或者对模拟或调试造成额外复杂性。一般来说，透明的代码架构是成功应用程序的关键之一。让我们回顾一下我们所学的所有内容。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Knowing about anti-patterns and their identification can have a big impact on
    the viability of an application, especially when it comes to distributed systems.
    This chapter has shown that not knowing the Java platform and its tools well enough
    can lead to unexpected results, such as intense pressure on garbage collection
    algorithms running on side threads and missing out on optimization opportunities.
    Realizing the multi-threaded nature of the Java platform can lead to proper code
    composition, but also to proper use of immutability to enable continuous application
    development, that is, refactoring.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 了解反模式和它们的识别方法可以对应用程序的可行性产生重大影响，尤其是在分布式系统方面。本章已表明，如果对Java平台及其工具了解不够充分，可能会导致意外结果，例如在副线程上运行的垃圾收集算法承受巨大压力，以及错失优化机会。认识到Java平台的并发特性可以导致适当的代码结构，但同时也需要正确使用不可变性以实现持续的应用程序开发，即重构。
- en: Since most anti-patterns have a lack of testing as one of their root causes,
    a test environment might be the best starting place to determine the occurrence
    of anti-patterns or the need for refactoring. Compiled test code does not reside
    in deployed code, which makes test code the best place to start for future exploration
    and understanding your application’s behavior.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数反模式的一个根本原因就是缺乏测试，因此测试环境可能是确定反模式发生或重构需求的最佳起点。编译后的测试代码不位于部署代码中，这使得测试代码成为未来探索和理解应用程序行为的最佳起点。
- en: The Java platform and other used libraries change rapidly, and one of the keys
    to maintaining an application code base is the correct use of the open-close principle.
    It enables continuous refactoring, which is essential for the evolution of a healthy
    code base.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台和其他使用的库变化迅速，维护应用程序代码库的关键之一是正确使用开闭原则。它使持续重构成为可能，这对于健康代码库的演变至关重要。
- en: Anti-patterns are part of the application life cycle. They are present and can
    remain present in various forms for the sake of progress. It may not be worth
    the effort to remove them entirely; perhaps a better approach would be to understand
    them and get the code base to the desired state with known limitations being addressed
    on an ongoing basis. Improvements will be made throughout the entire development
    cycle of the application, and writing code will become a pleasant experience with
    many challenges solved.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式是应用程序生命周期的一部分。它们存在，并且可以以各种形式存在，以促进进步。可能不值得完全移除它们；可能更好的方法是要理解它们，并使代码库达到期望的状态，同时持续解决已知的限制。在整个应用程序的开发周期中，将进行改进，编写代码将变成一个愉快的体验，许多挑战都将得到解决。
- en: While the Java platform still has challenges, it remains a beautiful piece of
    software that uses mathematics, statistics, and probability science all at once!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java平台仍面临挑战，但它仍然是一块美丽的软件，它同时使用了数学、统计学和概率科学！
- en: Congratulations on successfully reaching the end of this book. Because every
    ending brings a new beginning, I encourage you to stay inspired and hungry and
    to have a lot of fun with coding or designing software! Keep your mind open and
    make it a source of valuable information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您成功完成这本书。因为每个结束都带来一个新的开始，我鼓励您保持灵感和渴望，并在编码或设计软件中享受很多乐趣！保持您的思想开放，让它成为有价值信息的来源。
- en: Sincerely, Miro Wengner!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 诚挚地，米罗·温格纳（Miro Wengner）！
- en: Further reading
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式：可重用面向对象软件的元素*》由埃里希·伽玛（Erich Gamma）、理查德·赫尔姆（Richard Helm）、拉尔夫·约翰逊（Ralph
    Johnson）和约翰·弗利斯（John Vlissides）著，Addison-Wesley，1995
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计原则与设计模式*》由罗伯特·C·马丁（Robert C. Martin）著，Object Mentor，2000
- en: '*AntiPatterns: Refactoring Software, Architectures, and Project in Crisis*
    by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J.
    Mowbray, John Wiley & Sons, Inc, 1998'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*反模式：重构软件、架构和危机项目*》由威廉·J·布朗（William J. Brown）、拉斐尔·C·马尔维乌（Raphael C. Malveau）、海斯·W·麦科密克三世（Hays
    W. McCormick III）和托马斯·J·莫布里（Thomas J. Mowbray）著，约翰·威利与 Sons, Inc, 1998
- en: '*CAP Twelve Years Later: How the “Rules” Have Changed*, [https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed),
    2012'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*CAP十二年后：规则如何改变*》，[https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed)，2012
- en: '*Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win*
    by Gene Kim, Kevin Behr, and George Spafford, IT Revolution Press, 2016'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*凤凰项目：一部关于IT、DevOps和帮助您的业务获胜的小说*》由吉恩·金（Gene Kim）、凯文·贝赫（Kevin Behr）和乔治·斯帕福德（George
    Spafford）著，IT革命出版社，2016
- en: '*How do Committees Invent?* by Melvin Edward Conway, Datamation 14, site 5,
    pages 28-31, 1968'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*委员会如何发明？*》由梅尔文·爱德华·康威（Melvin Edward Conway）著，Datamation 14，第5页，第28-31页，1968
- en: '*Mission Control* *Project*, [https://github.com/openjdk/jmc](https://github.com/openjdk/jmc)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*任务控制* 项目》，[https://github.com/openjdk/jmc](https://github.com/openjdk/jmc)
- en: Assessments
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1 – Getting into Software Design Patterns
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 – 进入软件设计模式
- en: The compiler compiles Java code into bytecode, which is executed by the JVM
    and JRE, respectively (refer to *Figure 1**.3*).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器将Java代码编译成字节码，分别由JVM和JRE执行（参见图1.3）。
- en: It refers to abstraction, polymorphism, inheritance, and encapsulation.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它指的是抽象、多态、继承和封装。
- en: Method overriding and method overloading.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法重写和方法重载。
- en: 'SOLID principles: The single-responsibility principle, open-closed principle,
    Liskov substitution principle, interface segregation principle, and dependency
    inversion principle.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOLID原则：单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则。
- en: The program should be open for extension and closed for modification.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序应该对扩展开放，对修改封闭。
- en: Design patterns represent the collection of commonly used problems and solutions
    to produce maintainable software.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计模式代表了常用问题和解决方案的集合，以产生可维护的软件。
- en: Chapter 2 – Discovering the Java Platform for Design Patterns
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 – 发现Java平台的设计模式
- en: The **Java Virtual Machine** (**JVM**), **Java Runtime Environment** (**JRE**),
    and **Java Development** **Kit** (**JDK**).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java虚拟机**（**JVM**）、**Java运行时环境**（**JRE**）和**Java开发工具包**（**JDK**）。'
- en: Java is a statically typed language, which means any value needs to be declared
    before it can be assigned to the value.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java是一种静态类型语言，这意味着任何值在可以分配给值之前都需要声明。
- en: '3\. Primitive types: `boolean`, `byte`, `short`, `char`, `int`, `float`, `long`,
    and `double`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 原始类型：`boolean`、`byte`、`short`、`char`、`int`、`float`、`long`和`double`。
- en: Garbage collector.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集器。
- en: '`Queue`, `Set`, and `List`.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Queue`、`Set`和`List`。'
- en: Key-value pairs.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键值对。
- en: In O-notation O(1).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在O-notation O(1)。
- en: In O-notation O(n).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在O-notation O(n)。
- en: '`Predicate<T>`, the return type is a primitive type, `boolean`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Predicate<T>`的返回类型是原始类型，`boolean`。'
- en: Element streams in the Java Stream API are lazily evaluated.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java Stream API中的元素流是延迟评估的。
- en: Chapter 3 – Working with Creational Design Patterns
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 – 与创建型设计模式一起工作
- en: Creational design patterns help abstract the object instantiation process by
    delegating it to the responsible part of the application.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建型设计模式通过将其委托给应用程序的负责部分来帮助抽象对象实例化过程。
- en: 2\. To reduce new object creation costs, the dependency injection, lazy initiation,
    and object pool patterns may be taken into consideration.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 为了减少创建新对象的成本，可以考虑使用依赖注入、延迟初始化和对象池模式。
- en: Only one instance is required to be present in JVM.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM中只需要存在一个实例。
- en: The builder pattern helps create configurations of a similar object type while
    reducing the number of constructors.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式有助于创建类似对象类型的配置，同时减少构造函数的数量。
- en: The factory method or abstract factory patterns should be considered, as both
    can compose complex objects without exposing the logic to the clients.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该考虑工厂方法模式或抽象工厂模式，因为两者都可以在不向客户端暴露逻辑的情况下组合复杂对象。
- en: The object pool design pattern introduces a cache of already created and reusable
    objects instead of allocating and destroying new instances.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象池设计模式引入了一个已创建和可重用对象的缓存，而不是分配和销毁新实例。
- en: The most useful pattern for creating objects of a specific family is the factory
    method pattern.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建特定家族对象最有用的模式是工厂方法模式。
- en: Chapter 4 – Applying Structural Design Patterns
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 – 应用结构设计模式
- en: 1\. Structural design patterns define communication between objects. These patterns
    support implementation flexibility and transparency.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 结构设计模式定义了对象之间的通信。这些模式支持实现灵活性和透明性。
- en: The structural design patterns described by the GoF author group are the adapter,
    bridge, composite, proxy, flyweight, facade, and decorator patterns.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GoF作者组描述的结构设计模式包括适配器、桥接、组合、代理、享元、外观和装饰器模式。
- en: The composite structural design pattern, which also guarantees uniform object
    handling.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合结构设计模式，同时也保证了对象处理的统一性。
- en: The marker pattern, with full awareness of its drawbacks.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记模式，充分意识到其缺点。
- en: The proxy pattern needs to be taken into account because the adapter and facade
    patterns have slightly different purposes.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理模式需要考虑，因为适配器和外观模式有略微不同的目的。
- en: The bridge pattern.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桥接模式。
- en: Chapter 5 – Behavioral Design Patterns
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 – 行为设计模式
- en: The Liskov substitution principle explored in [*Chapter 1*](B18884_01.xhtml#_idTextAnchor016),
    *Getting into Software* *Design Patterns*.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18884_01.xhtml#_idTextAnchor016)中探讨的Liskov替换原则，*进入软件* *设计模式*。
- en: The iterator pattern.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器模式。
- en: Yes – the strategy pattern.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的 – 策略模式。
- en: It is the null object pattern, which provides the type of such a state and limits
    the causes of null pointer exceptions.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是空对象模式，它提供了此类状态的类型，并限制了空指针异常的原因。
- en: This can be the pipeline pattern, the strategy pattern for the `map()` and `filter()`
    methods, or the null object pattern.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以是管道模式，`map()`和`filter()`方法的策略模式，或者空对象模式。
- en: All clients can be alerted by employing the observer pattern, which also transparently
    controls conditions.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过使用观察者模式来通知所有客户端，该模式还透明地控制条件。
- en: The command pattern can be used. A command is represented by a unique object.
    An object allows a client to pass parameters and can easily call a callback function.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用命令模式。命令由一个唯一的对象表示。对象允许客户端传递参数，并且可以轻松调用回调函数。
- en: Chapter 6 – Concurrency Design Patterns
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 – 并发设计模式
- en: The challenge solved by the double-checked singleton pattern is ensuring that
    only one class instance is present in the running JVM to avoid possible leaks
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重检查单例模式解决的问题是在运行中的JVM中确保只有一个类实例存在，以避免可能的泄漏。
- en: The usage of the `Executors` utility that resides in the `java.base` module
    and `java.util.concurrent` package
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位于`java.base`模块和`java.util.concurrent`包中的`Executors`实用程序。
- en: The balking pattern depends on the instance stat
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞模式取决于实例状态
- en: The scheduler pattern
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度模式
- en: The producer-consumer pattern is one of the most common concurrent design patterns,
    with clearly separated and addressed logic
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产者-消费者模式是其中最常见的一种并发设计模式，其逻辑被明确分离和解决
