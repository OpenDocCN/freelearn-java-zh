- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Common Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, we have explored the *green working paths*
    of imaginary vehicle-related applications. In this chapter, the abstraction of
    the vehicle will remain a supporting element, because one may imagine a vehicle-inspired
    application more easily than other abstractions. A vehicle, along with all of
    its parts, is an idea that’s easy to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly recap the importance of design patterns and how they contribute
    to the success of an organization’s success.
  prefs: []
  type: TYPE_NORMAL
- en: Melvin E. Conway said that the design and implementation of an application strongly
    reflect an organization’s internal communication. This statement is no less relevant
    today, especially now that many projects use agile approaches. Automated builds,
    continuous integration or testing, and subsequent automated deployment play a
    key role in delivering applications to production. Any overlooked or unexpected
    limitation can limit or damage an application’s main objective.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will review some important areas for identifying signs of
    deviation from the main goal so that you can have functional, maintainable, and
    transparent applications. Not having those qualities can negatively affect application
    functionality on multiple levels. Runtime could be damaged, which might result
    in unpredictable costs. Faults could be hidden in application architecture, disallowing
    extendibility and maintainability. Such issues could also recur and require specialized
    attention in each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will concentrate on the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: What anti-patterns are and how to identify them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining typical software anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding software architecture anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify and understand some
    of the signs of anti-patterns that should be looked out for.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: What anti-patterns are and how to identify them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One might define an anti-pattern as the exact opposite of a good design pattern
    or good practice. Though that might seem like the bottom line, it ignores the
    context and sequence of actions that led to a software practice being called an
    anti-pattern. In other words, it does not explain why an anti-pattern is a collection
    of highly risky, ineffective, and counterproductive steps. It is important to
    understand these steps as they allow creating a repeatable process to obtain a
    similar result, just to verify the ambiguity. The bottom line is that these steps
    may limit the ability to productively address the issues. Let us dive a bit deeper
    into the theory.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretical principles challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anti-patterns can naturally appear during software development due to multiple
    reasons. They may be due to a shift in business logic, technology migration, or
    missing information. The fact remains that anti-patterns do occur and, simply
    put, can be part of the development process due to team size, communication issues,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The key question is how to identify them. In [*Chapter 1*](B18884_01.xhtml#_idTextAnchor016),
    *Getting into Software Design Patterns*, we touched on the negative impact of
    violating the APIE and SOLID design principles; this can be a symptom that can
    be a signal to consider a source code refactoring response. Another phenomenon
    would be not respecting the **CAP** theorem (**Consistency**, **Availability**,
    and **Partition tolerance**). Development time may have been invested in trying
    to achieve all three properties at the same time, which is impossible. Such attempts
    could be seen as a strong signal to rethink the development strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Although the principles of APIE and SOLID tend to be considered common knowledge,
    the truth is different, especially in the area of creating agile approaches and
    completing tasks. Development can tend to create continuous technical debt. The
    word *continuous* is quite important because the accumulation of such debt may
    lead to very unpleasant consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting technical debt as a bottleneck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technical debt is an interesting concept because it requires the context of
    the software application and its goal in order to understand it. Technical debt
    contains some properties that may not be obvious at first glance, but may lead
    to a serious application bottleneck. Let’s imagine a vehicle production line as
    a collection of multiple processes running under various dynamics in parallel.
    The production line should deliver the expected result in the form of a vehicle.
    If there were an accumulation of bottlenecks, though, the result would not be
    achieved. This abstraction of a vehicle production line is quite simple, but putting
    it into the context of running software may be more difficult, as software relies
    on underlying technologies, platforms, and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform comes with some caveats that must be accounted for. Basically,
    the rule is that the developer respects the platform and the platform does its
    best to serve a running software.
  prefs: []
  type: TYPE_NORMAL
- en: Inappropriately squeezing the capabilities of the Java platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for Design Patterns*, we touched on important topics such as types and memory
    models; not accounting for these may be considered an anti-pattern. As a reminder
    of the multi-threaded nature of the Java platform, we can mention the Java memory
    model, which guarantees the visibility of values to the application in a multi-threaded
    environment. Another thing that may turn into an anti-pattern is a garbage collection
    algorithm running in a separate thread alongside the main application execution
    thread. Because a Java application works with the final allocated memory space
    (the heap), the garbage collector tries to ensure that there is still an appropriate
    amount of heap memory available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The acquired knowledge helps us avoid one of the most common misconceptions
    relating to any anti-pattern: **unwanted autoboxing**, or the automatic conversion
    performed by the compiler between primitive types and the wrapper classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The impact of autoboxing is not visible at first glance and may go unnoticed
    until your application faces a critical load. Let us look at aggregating sensor
    values, where each sensor value needs to be validated to identify an alarm. The
    alarm is caused, of course, by the occurrence of a critical value. The alarm system
    starts multiple threads in parallel to verify the delivered values (*Example 7.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Example 7.1 – The SensorAlarmWorker instance attempts to identify a warning
    signal by reading the Sensor instance value
  prefs: []
  type: TYPE_NORMAL
- en: 'A vehicle sensor alarm system obviously has to analyze a huge amount of data
    delivered by its various sensors in order to identify a critical signal. An autoboxing
    issue tends to be very noticeable as it causes intensive and non-deterministic
    garbage collection (*Figure 7**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The intensive garbage collection causes noticeable delays](img/B18884_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The intensive garbage collection causes noticeable delays
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the root cause of the garbage collection seems to be resolved, it
    may appear unexpectedly. *Example 7.1* introduces the `Sensor` record class, holding
    an integer value as a primitive `int` type. The problem becomes apparent when
    the value of the primitive type is autoboxed while passing it to the `evaluateAlarm`
    method, which requires the use of the `Integer` wrapper class. Let us do a one-line
    correction to the `Sensor` value type (*Example 7.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 7.2 – The Sensor field value is changed to the Integer type and corresponds
    with the method input type
  prefs: []
  type: TYPE_NORMAL
- en: 'This change has quite a significant impact on the whole application, causing
    very limited occurrences of garbage collection. In other words, eliminating unwanted
    delays due to stop-the-world events, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*,*
    *Discovering the Java Platform for Design Patterns* (*Figure 7**.2*), speeds up
    the entire application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Garbage collection pressure disappeared because the application
    didn’t create unnecessary short-living objects](img/B18884_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Garbage collection pressure disappeared because the application
    didn’t create unnecessary short-living objects
  prefs: []
  type: TYPE_NORMAL
- en: Autoboxing may sometimes be identified through code reviews, which play an essential
    role in removing the code smell anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform contains many useful tools, and using them incorrectly can
    result in an unwanted state. Let’s look at some of these tools in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example may seem, at first glance, far from being a code smell. The
    Java platform contains very useful tools that can serve an application well if
    they are properly selected and used. A good example of the importance of careful
    selection is presented by the collection framework. [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*, reviewed different aspects
    of commonly used collection types. This led us to see how a wrong collection selection
    may result in a bottleneck due to the consumption of underlying resources. This
    kind of issue may not be obvious with a small data amount but emerges under bigger
    loads and hits very specific parts of an application. This phenomenon can be called
    the **busy method**, or **hot method** (*Figure 7**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The computation time is limited by busy method execution](img/B18884_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The computation time is limited by busy method execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the computation work of the application is centralized with one extremely
    busy method execution. `O(n)` time complexity for `ArrayList` with the `O(1)`
    time complexity for `HashSet` instances (*Figure 7**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The collection exchange leads to the desired computation work
    distribution](img/B18884_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The collection exchange leads to the desired computation work distribution
  prefs: []
  type: TYPE_NORMAL
- en: The correction results in bigger application throughput, which would be desirable
    for a vehicle data analyzer that attempts to evaluate collected data on a journey.
  prefs: []
  type: TYPE_NORMAL
- en: Although the code smell was not obvious, it was found because we used the right
    tool. Let’s summarize what we can take from the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion of the code smell anti-pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discovered that any attempt to challenge theoretical principles
    leads to an anti-pattern known as a code smell.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed a case where unknown code smells posed a threat to an application’s
    goals. We talked about how each bottleneck needs to be understood in its context
    before we try to solve it. Removing such bottlenecks without understanding the
    important details may result in another anti-pattern and a never-ending cycle
    of refactoring, as the presented examples showed (*Figure 7**.1* and *Figure 7**.3*).
  prefs: []
  type: TYPE_NORMAL
- en: Another counterproductive thing to do would be optimizing the code base without
    solving the underlying technical debt, which may result not only in questionable
    application throughput degradation but also unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to some of the most well-known software anti-patterns, let’s
    make some final considerations. Any anti-pattern can be caused by a migration
    where technical debts have been created, including incorrect information. Their
    appearance may be a side effect of incorrectly selected platform tools or a lack
    of awareness of the theory behind the Java programming language. Since this topic
    can become controversial, I'll leave you to draw your own conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: Examining typical software anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The literature on this topic is full of different kinds of anti-patterns, some
    of which have very funny names, even though their impact is anything but funny.
    Sometimes anti-patterns can be the result of a lack of discipline in providing
    tested, well-structured, and maintainable code to colleagues. An often-used term
    today in this field is **clean code**. The following sections will explore some
    common anti-patterns that can be found in code bases, more specifically in method
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Multiple factors may contribute to an application code base appearing very
    unstructured: that’s the first sign of a code smell. In such cases, one of the
    most famous anti-patterns, **spaghetti code**, tends to appear. Spaghetti code
    may remain overlooked due to the fact that interfaces still remain coherent, but
    their implementation will contain long methods with interconnected dependencies
    (*Example 7.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 7.3 – An unclear drive() method that contains logic for everything from
    engine control to brake checks
  prefs: []
  type: TYPE_NORMAL
- en: In such a state, it is nearly impossible to extend the application or verify
    its functionality. Sometimes, such code may become legacy code, which people will
    then use as an excuse. Such excuses will not contribute to the application’s success;
    the solution lies in refactoring and cleaning up the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Cut and paste programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This anti-pattern is perhaps another of the most common ones, where previously
    developed code is used to address the next challenge. This may seem like a smart
    reuse of code, but it can very quickly turn into a maintenance nightmare because
    the initial implementation conditions are completely ignored. This is a problem
    especially when the initial code was already anti-pattern-prone and ignored the
    principles mentioned in the previous chapters. The reuse of already-generated
    code should be done wisely in order to provide good protection.
  prefs: []
  type: TYPE_NORMAL
- en: Blob
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern can be identified in many older monolithic systems and applications.
    Nowadays, developers will claim that the problem has been overcome. The truth
    is not so certain. Not even frameworks are resistant to this anti-pattern. An
    anti-pattern can also be presented by a package that contains the most essential
    collection of divine classes or just one, the God class. This anti-pattern can
    often reside in classes called controllers, which control the entire behavior
    of an application. Such controllers accumulate a large number of different methods
    with different functionalities, meaning that the separation of concerns can end
    up being forgotten (*Example 7.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 7.4 – The instance of VehicleBlob attempts to control each possible
    part
  prefs: []
  type: TYPE_NORMAL
- en: A counterargument regarding the hypothetical maintainability of the code base
    could be considered invalid because such code might be difficult to test, perhaps
    even impossible. A similar problem can occur when the singleton design pattern
    is improperly overused. Once the blob anti-pattern is identified, it’s a great
    time to start thinking about creating simple diagrams supported by refactoring
    the source code before it’s too late.
  prefs: []
  type: TYPE_NORMAL
- en: Lava flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clean code is sometimes used as a deep term. Nowadays, it is becoming a common
    practice to push a proof-of-concept application directly into production without
    further thought. This anti-pattern arises when incompatibility or extensibility
    problems start to appear. The fact that the proof of concept verified a possible
    solution does not guarantee that it was prepared for production according to common
    development principles and techniques. This anti-pattern can be identified by
    the occurrences of long implementation classes whose purpose has been lost over
    time, but everyone is afraid to remove them because it might affect the system.
    This anti-pattern was named after lava, a hot liquid that flows down a volcano
    until it catches fire. In the era of microservices, distributed systems, and cloud
    solutions, an example of shared functionalities, such as libraries or solutions,
    can be considered. When such a pattern emerges in the development process, it
    may be a good time to re-evaluate the design of the code base, perhaps draw some
    diagrams, and apply conclusions to mitigate the possibility of a fire.
  prefs: []
  type: TYPE_NORMAL
- en: Functional decomposition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functional decomposition anti-pattern may seem outdated due to the use of
    modern frameworks and the fact that the anti-pattern is better known in the field
    of procedural languages. The reality may be slightly different, as many legacy
    systems were migrated without sufficient understanding of the code base and business
    logic. Identifying the anti-pattern is trivial, as it’s impossible not to notice
    a code base containing many classes with a single responsibility, a lack of abstraction,
    and big cohesion. The root cause of this anti-pattern may be a lack of understanding
    of the basic principles of object-oriented programming or a misunderstanding of
    the application’s goal. The solution is to refactor the code base according to
    the required abstraction level while keeping in mind programming principles.
  prefs: []
  type: TYPE_NORMAL
- en: Boat anchor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes an application or a newly developed piece of software may inherit
    an outdated abstraction that becomes unnecessary. This abstraction can turn into
    a bottleneck not only because it requires maintenance but also because it can
    easily be replicated widely across a code base. The worst case can be the large
    utilization of this abstraction inside shared libraries or application modules.
    The anti-pattern can accelerate the degradation of the application code base at
    various levels.
  prefs: []
  type: TYPE_NORMAL
- en: One easy way to mitigate this is to keep in mind the SOLID design and APIE principles
    to allow for continuous refactoring. This enables the utilization of previously
    learned design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to identify and describe some of the most common deviations from
    well-known principles and approaches brings value to any project. In this subsection,
    we have examined anti-patterns and proposed solutions to keep your code base maintainable
    and readable. The last point we want to make in this section is about the proper
    naming of methods, fields, and classes, which can significantly improve readability
    and maintainability and limit the misunderstanding of API use. Proper naming is
    also important as it allows a good understanding of UML diagrams. The next section
    takes us more into source code architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding software architecture anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A clear understanding of classes, packages, and module composition can be seen
    as essential not only to the application itself, but, as we learned in [*Chapter
    2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform for Design
    Patterns*, to the platform as well. Thanks to the dynamic translation of the bytecode
    that the JIT compiler processes, the Java platform collects essential information
    about its optimization. Poor code quality and software architecture can cause
    latency, improper memory usage, or crashes. Let’s understand the possible obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: Golden hammer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One proven approach applied over a period of time without exploration of alternatives
    can easily turn into legacy code. The fact that it is difficult to accept other
    proposals or migration may be due to a particular set of approaches, otherwise
    known as the golden hammer anti-pattern, where developers believe that there is
    no need to investigate whether changes to something would be beneficial when it
    has been working fine for several years. A great example would be a vendor-specific
    database or tool, and the problem arises when the application needs to migrate
    to microservices or a more distributed design.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability is penalized not only by the CAP theorem, as mentioned earlier,
    but may also suffer due to almost impossible usage across designed modules or
    application parts.
  prefs: []
  type: TYPE_NORMAL
- en: Using a particular vendor’s product in your application architecture is not
    necessarily an issue. The challenge is that the development of the application
    relies entirely on the capabilities and functions provided by the vendor without
    evaluating its own capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: A possible solution could be to re-evaluate current development approaches and
    allow for improvement through effective research of solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous obsolescence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improvements are inevitable. Today, products can take advantage of automated
    deployment or continuous integration support with a variety of different test
    scenarios. The rate of improvement is increasing rapidly. A good example is the
    Java platform, which recently reduced its release cadence to 6 months. This fact
    can contribute to the emergence of an anti-pattern, since refactoring is required,
    but on the other hand, it has a great effect on removing previous shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The continuous obsolescence anti-pattern can be easily identified by an inability
    to move a project to the next phase using continuous integration and delivery
    (*Example 7.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 7.5 – The VehicleCO abstraction contains outdated methods that still
    need to be tested
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the concepts of continuous delivery and integration do not give any
    guarantee of code base clarity as they need to be followed by development discipline.
    Continuous clean-code-focused reviews, object-oriented principles, and proper
    patterns can drastically reduce the incidence of continuous obsolescence and have
    a major impact on the entire application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Input kludge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not necessarily be obvious at first glance, but the input kludge anti-pattern
    is quite common. A good example would be several connected services that were
    tested until one began to deviate from its functionality. A quick ad hoc solution
    has more side effects that are recognized with a long delay due to disabled tests.
    Various services already had more patches applied than others, so even more tests
    were disabled. The fact remains that those disabled tests were critical to maintaining
    application integrity.
  prefs: []
  type: TYPE_NORMAL
- en: The solution might be to maintain discipline in testing and ensure that test
    inputs and outputs are valid and updated, rather than turning off essential tests.
  prefs: []
  type: TYPE_NORMAL
- en: Working in a minefield
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gone are the days of completely monolithic applications. The current distributed
    nature of applications creates an expectation for application testing to achieve
    continuous delivery and refactoring. Although an application might contain tests
    for known issues, full integrity cannot be ensured. What happens if some enhancements
    are made to an application but they aren''t tested? Even a very small contribution
    to the code base can turn into a nightmare – working with such code bases can
    feel like being in a minefield. The solution to the problem is quite obvious:
    refactoring is required. Isolate the affected part with simplified tests to gain
    stability, apply all the knowledge learned, and slowly continue expanding the
    test base.'
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguous viewpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the era of microservices and distributed system design approaches, this anti-pattern
    may significantly damage the final result. The continued presence of this anti-pattern
    can result in an onion architecture approach where the separation of concerns
    and other SOLID principles become theory rather than practice. One indicator of
    this anti-pattern would be the creation of unclear services followed by entities
    for passing redundant information between layers, making the general architecture
    unclear. It can be recognized in its early stages as the presented design models
    do not support any principles of SOLID application design due to incomplete information
    or unclear and overlapping perspectives in the model and potential software design.
    The solution may be effectively executed by the use of a modeling technique, such
    as UML, to ensure visual clarity and source code transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Poltergeists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This anti-pattern cannot be fully ignored. It can be recognized if you can spot
    features that are not expected but suddenly appear and disappear. This anti-pattern
    is the result of very complex abstractions and the implementation of unnecessary
    classes. There are a couple of frameworks on the Java platform that can provide
    useless functionality. We can consider AspectJ and AOP as good examples as their
    usage may be directly responsible for mysterious side effects. The solution is
    to revisit and understand the class hierarchy and life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Dead end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The growth of the IT industry seems to be unstoppable, as more and more approaches
    and procedures for technical improvements emerge. As such, dependencies on non-updated
    components that were previously built into a system’s architecture can be detrimental
    and may be more difficult to remove than you might expect. Take, for example,
    Java version migrations, where staying with the old version is penalized not only
    by losing support but also by increasing maintenance costs. Trying to scale an
    application can also result in many challenges to do with application testability.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this dead-end anti-pattern can be turned into an accepted software
    design, it is recommended to consider alternatives, because doing so may come
    with significant costs.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all of the anti-patterns listed are completely bad (see the golden hammer
    or dead end, for example), but generally, any anti-pattern should be re-evaluated
    before it is accepted and documented.
  prefs: []
  type: TYPE_NORMAL
- en: Java is a very powerful language and platform, not only because it allows using
    instance mutation, but also because it enables entities to hold their state and
    remain immutable. Special attention should be paid to the state of the code base
    in the case of concurrent applications, because such applications must be transparent
    not only to software engineers but also to the Java platform, as we learned in
    [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for Design Patterns*. A concurrent environment brings many possibilities and performance
    improvements on the one hand, but on the other hand, it can cause the misuse of
    certain design patterns, such as the double-checked locking pattern, thanks to
    a poor understanding of the platform (rather than the framework that uses the
    platform).
  prefs: []
  type: TYPE_NORMAL
- en: A lack of test coverage, code writing discipline, information, or capability
    can also contribute significantly to the occurrence of anti-patterns. From a code
    base architecture perspective, verifying a correctly implemented function can
    become an impossible task or cause additional complications for mocking or debugging.
    Generally speaking, a transparent code architecture is one of the keys to a successful
    application. Let’s recap everything we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing about anti-patterns and their identification can have a big impact on
    the viability of an application, especially when it comes to distributed systems.
    This chapter has shown that not knowing the Java platform and its tools well enough
    can lead to unexpected results, such as intense pressure on garbage collection
    algorithms running on side threads and missing out on optimization opportunities.
    Realizing the multi-threaded nature of the Java platform can lead to proper code
    composition, but also to proper use of immutability to enable continuous application
    development, that is, refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Since most anti-patterns have a lack of testing as one of their root causes,
    a test environment might be the best starting place to determine the occurrence
    of anti-patterns or the need for refactoring. Compiled test code does not reside
    in deployed code, which makes test code the best place to start for future exploration
    and understanding your application’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform and other used libraries change rapidly, and one of the keys
    to maintaining an application code base is the correct use of the open-close principle.
    It enables continuous refactoring, which is essential for the evolution of a healthy
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns are part of the application life cycle. They are present and can
    remain present in various forms for the sake of progress. It may not be worth
    the effort to remove them entirely; perhaps a better approach would be to understand
    them and get the code base to the desired state with known limitations being addressed
    on an ongoing basis. Improvements will be made throughout the entire development
    cycle of the application, and writing code will become a pleasant experience with
    many challenges solved.
  prefs: []
  type: TYPE_NORMAL
- en: While the Java platform still has challenges, it remains a beautiful piece of
    software that uses mathematics, statistics, and probability science all at once!
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on successfully reaching the end of this book. Because every
    ending brings a new beginning, I encourage you to stay inspired and hungry and
    to have a lot of fun with coding or designing software! Keep your mind open and
    make it a source of valuable information.
  prefs: []
  type: TYPE_NORMAL
- en: Sincerely, Miro Wengner!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AntiPatterns: Refactoring Software, Architectures, and Project in Crisis*
    by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J.
    Mowbray, John Wiley & Sons, Inc, 1998'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CAP Twelve Years Later: How the “Rules” Have Changed*, [https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed),
    2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win*
    by Gene Kim, Kevin Behr, and George Spafford, IT Revolution Press, 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How do Committees Invent?* by Melvin Edward Conway, Datamation 14, site 5,
    pages 28-31, 1968'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mission Control* *Project*, [https://github.com/openjdk/jmc](https://github.com/openjdk/jmc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1 – Getting into Software Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiler compiles Java code into bytecode, which is executed by the JVM
    and JRE, respectively (refer to *Figure 1**.3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It refers to abstraction, polymorphism, inheritance, and encapsulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method overriding and method overloading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SOLID principles: The single-responsibility principle, open-closed principle,
    Liskov substitution principle, interface segregation principle, and dependency
    inversion principle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program should be open for extension and closed for modification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design patterns represent the collection of commonly used problems and solutions
    to produce maintainable software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2 – Discovering the Java Platform for Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Virtual Machine** (**JVM**), **Java Runtime Environment** (**JRE**),
    and **Java Development** **Kit** (**JDK**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java is a statically typed language, which means any value needs to be declared
    before it can be assigned to the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. Primitive types: `boolean`, `byte`, `short`, `char`, `int`, `float`, `long`,
    and `double`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Queue`, `Set`, and `List`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Key-value pairs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In O-notation O(1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In O-notation O(n).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Predicate<T>`, the return type is a primitive type, `boolean`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element streams in the Java Stream API are lazily evaluated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3 – Working with Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns help abstract the object instantiation process by
    delegating it to the responsible part of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. To reduce new object creation costs, the dependency injection, lazy initiation,
    and object pool patterns may be taken into consideration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only one instance is required to be present in JVM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The builder pattern helps create configurations of a similar object type while
    reducing the number of constructors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The factory method or abstract factory patterns should be considered, as both
    can compose complex objects without exposing the logic to the clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object pool design pattern introduces a cache of already created and reusable
    objects instead of allocating and destroying new instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most useful pattern for creating objects of a specific family is the factory
    method pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4 – Applying Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Structural design patterns define communication between objects. These patterns
    support implementation flexibility and transparency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The structural design patterns described by the GoF author group are the adapter,
    bridge, composite, proxy, flyweight, facade, and decorator patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The composite structural design pattern, which also guarantees uniform object
    handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The marker pattern, with full awareness of its drawbacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The proxy pattern needs to be taken into account because the adapter and facade
    patterns have slightly different purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bridge pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5 – Behavioral Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Liskov substitution principle explored in [*Chapter 1*](B18884_01.xhtml#_idTextAnchor016),
    *Getting into Software* *Design Patterns*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The iterator pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes – the strategy pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the null object pattern, which provides the type of such a state and limits
    the causes of null pointer exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This can be the pipeline pattern, the strategy pattern for the `map()` and `filter()`
    methods, or the null object pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All clients can be alerted by employing the observer pattern, which also transparently
    controls conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command pattern can be used. A command is represented by a unique object.
    An object allows a client to pass parameters and can easily call a callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6 – Concurrency Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge solved by the double-checked singleton pattern is ensuring that
    only one class instance is present in the running JVM to avoid possible leaks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The usage of the `Executors` utility that resides in the `java.base` module
    and `java.util.concurrent` package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The balking pattern depends on the instance stat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scheduler pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The producer-consumer pattern is one of the most common concurrent design patterns,
    with clearly separated and addressed logic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
