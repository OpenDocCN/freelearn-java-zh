<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Leveraging the New Default G1 Garbage Collector</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we examined <strong class="calibre8">Java Shell</strong> (<strong class="calibre8">JShell</strong>), Java 9's new <strong class="calibre8">read-eval-print loop</strong> (<strong class="calibre8">REPL</strong>) command-line tool. We started with introductory information regarding the tool and looked closely at the read-eval-print loop concept. We spent considerable time reviewing JShell commands and command-line options. Our coverage included practical guides to feedback modes, asset listing, and editing in the shell. We also gained experience working with scripts.</p>
<p class="mce-root">In this chapter, we will take an in-depth look at <strong class="calibre8">garbage collection</strong> and how it is handled in Java 9. We will start with an overview of garbage collection, and then look at specifics in the pre-Java 9 realm. Armed with that foundational information, we will look at specific garbage collection changes in the Java 9 platform. Lastly, we will look at some garbage collection issues that persist, even after Java 9.</p>
<p class="mce-root">The following topics are covered in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">Overview of garbage collection</li>
<li class="calibre14">The pre-Java 9 garbage collection schema</li>
<li class="calibre14">Collecting garbage with the new Java platform</li>
<li class="calibre14">Persistent issues</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Overview of garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Garbage collection is the mechanism used in Java to deallocate unused memory. Essentially, when an object is created, memory space is allocated and dedicated to that object until it no longer has any references pointing to it. At that time, the system deallocates the memory. Java performs this garbage collection automatically for us, which can lead to a lack of attention to memory usage and poor programming practices in the area of memory management and system performance.</p>
<p class="mce-root">Java's garbage collection is considered an automatic memory management schema because programmers do not have to designate objects as ready to be deallocated. The garbage collection runs on a low-priority thread and, as you will read later in this chapter, has variable execution cycles.</p>
<p class="mce-root">In our overview of garbage collection, we will look at the following concepts:</p>
<ul class="calibre13">
<li class="calibre14">Object life cycle</li>
<li class="calibre14">Garbage collection algorithms</li>
<li class="calibre14">Garbage collection options</li>
<li class="calibre14">Java methods relevant to garbage collection</li>
</ul>
<p class="mce-root">We will look at each of these concepts in the sections that follow.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Object life cycle</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In order to fully understand Java's garbage collection, we need to look at the entire life cycle of an object. Because the core of garbage collection is automatic in Java, it is not uncommon to see the terms <em class="calibre20">garbage collection</em> and <em class="calibre20">memory management</em> as assumed components of the object life cycle.</p>
<p class="mce-root">We will start our review of the object life cycle with object creation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Object creation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Objects are declared and created. When we write an object declaration, or declare an object, we are declaring a name or identifier so that we can refer to an object. For example, the following line of code declares <kbd class="calibre16">myObjectName</kbd> as the name of an object of type <kbd class="calibre16">CapuchinMonkey</kbd>. At this point, no object was created and no memory allocated for it:</p>
<pre class="calibre21">    CapuchinMonkey myObjectName;</pre>
<p class="mce-root">We use the <kbd class="calibre16">new</kbd> keyword to create an object. The following example illustrates how to invoke the <kbd class="calibre16">new</kbd> operation to create an object. This operation results in:</p>
<pre class="calibre21">    myObjectName = new CapuchinMonkey();</pre>
<p class="mce-root">Of course, we can combine the declaration and creation statements together by using <kbd class="calibre16">CapuchinMonkey myObjectName = new CapuchinMonkey();</kbd> instead of <kbd class="calibre16">CapuchinMonkey myObjectName;</kbd> and <kbd class="calibre16">myObjectName = new CapuchinMonkey();</kbd>. They were separated in the preceding example for illustrative purposes.</p>
<p class="mce-root">When an object is created, a specific amount of memory is allocated for storing that object. The amount of memory allocated can differ based on architecture and JVM.</p>
<p class="mce-root">Next look at the mid-life of an object.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Object mid-life</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Objects are created and Java allocates system memory for storing that object. If the object is not used, the memory allocated to it is considered wasted. This is something we want to avoid. Even with small applications, this type of wasted memory can lead to poor performance and even out-of-memory issues.</p>
<p class="mce-root">Our goal is to deallocate or release the memory, any previously allocated memory that we no longer need. Fortunately, with Java, there is a mechanism for handling this issue. It is called garbage collection.</p>
<p class="mce-root">When an object, such as our <kbd class="calibre16">myObjectName</kbd> example, no longer has any references pointing to it, the system will reallocate the associated memory.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Object destruction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The idea of Java having a garbage collector running in the dark shadows of your code (usually a low-priority thread) and deallocating memory currently allocated to unreferenced objects, is appealing. So, how does this work? The garbage collection system monitors objects and, as feasible, counts the number of references to each object.</p>
<p class="mce-root">When there are no references to an object, there is no way to get to it with the currently running code, so it makes perfect sense to deallocate the associated memory.</p>
<div class="packt_infobox">The term <strong class="calibre3">memory leak</strong> refers to small memory chunks to be lost or improperly deallocated. These leaks are avoidable with Java's garbage collection.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Garbage collection algorithms</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are several garbage collection algorithms, or types, for use by the Java virtual machine. In this section, we will cover the following garbage collection algorithms:</p>
<ul class="calibre13">
<li class="calibre14">Mark and sweep</li>
<li class="calibre14">CMS garbage collection</li>
<li class="calibre14">Serial garbage collection</li>
<li class="calibre14">Parallel garbage collection</li>
<li class="calibre14">G1 garbage collection</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Mark and sweep</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java's initial garbage collection algorithm, <em class="calibre20">mark and sweep</em>, used a simple two-step process:</p>
<ol class="calibre18">
<li class="chapter">Java first step, mark, is to step through all objects that have accessible references, marking those objects as alive.</li>
<li class="chapter">The second step, sweep, involves scanning the sea for any object that is not marked.</li>
</ol>
<p class="mce-root">As you can readily determine, the mark and sweep algorithm seems effective, but probably not very efficient due to the two-step nature of this approach. This eventually lead to a Java garbage collection system with vastly improved efficiencies.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrent mark sweep (CMS) garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre8">concurrent mark sweep</strong> (<span class="calibre7"><strong class="calibre8">CMS</strong>)</span> algorithm for garbage collection scans heap memory using multiple threads. Similar to the mark and sweep method, it marks objects for removal and then makes a sweep to actually remove those objects. This method of garbage collection is essentially an upgraded mark and sweep method. It was modified to take advantage of faster systems and had performance enhancements.</p>
<p class="mce-root">To manually invoke the concurrent mark sweep garbage collection algorithm for your application, use the following command-line option:</p>
<pre class="calibre21"><strong class="calibre3">-XX:+UseConcMarkSweepGC </strong></pre>
<p class="mce-root">If you want to use the concurrent mark sweep garbage collection algorithm and dictate the number of threads to use, you can use the following command-line option. In the following example, we are telling the Java platform to use the concurrent mark sweep garbage collection algorithm with eight threads:</p>
<pre class="calibre21"><strong class="calibre3">-XX:ParallelCMSThreads=8</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Serial garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java's serial garbage collection works on a single thread. When executing, it freezes all other threads until garbage collection operations have concluded. Due to the thread-freezing nature of serial garbage collection, it is only feasible for very small programs.</p>
<p class="mce-root">To manually invoke the serial garbage collection algorithm for your application, use the following command-line option:</p>
<pre class="calibre21"><strong class="calibre3">-XX:+UseSerialGC</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Parallel garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, the parallel garbage collection algorithm was the default garbage collector. It uses multiple threads but freezes all non-garbage collection threads in the application until garbage collection functions have completed, just like the serial garbage collection algorithm.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">G1 garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The G1 garbage collection algorithm was created for use with large memory heaps. This approach involves segmenting the memory heap into regions. Garbage collection, using the G1 algorithm, takes place in parallel with each heap region.</p>
<p class="mce-root">Another part of the G1 algorithm is that when memory is deallocated, the heap space is compacted. Unfortunately, the compacting operation takes place using the <em class="calibre20">Stop the World</em> approach.</p>
<p class="mce-root">The G1 garbage collection algorithm also prioritizes the regions based on those that have the most garbage to be collected.</p>
<div class="packt_infobox">The G1 name refers to Garbage First.</div>
<p class="mce-root">To manually invoke the G1 garbage collection algorithm for your application, use the following command-line option:</p>
<pre class="calibre21"><strong class="calibre3">-XX:+UseG1GC</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Garbage collection options</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here is a list of JVM sizing options:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Sizing description</strong></td>
<td class="calibre33"><strong class="calibre3">JVM option flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the initial heap size (young space plus tenured space).</td>
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">-XX:InitialHeapSize=3g</kbd></p>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the maximum heap size (young space plus tenured space).</td>
<td class="calibre33"><kbd class="calibre16">-XX:MaxHeapSize=3g</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the initial and maximum heap size (young space plus tenured space).</td>
<td class="calibre33"><kbd class="calibre16">-Xms2048m -Xmx3g</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the initial size of young space.</td>
<td class="calibre33"><kbd class="calibre16">-XX:NewSize=128m</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the maximum size of young space.</td>
<td class="calibre33"><kbd class="calibre16">-XX:MaxNewSize=128m</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets young space size. Uses ration of young verses tenured space. In the sample flag to the right, <kbd class="calibre16">3</kbd> means that young space will be three times smaller than tenured space.</td>
<td class="calibre33"><kbd class="calibre16">-XX:NewRation=3</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the size of single survivor space as a portion of Eden space size.</td>
<td class="calibre33"><kbd class="calibre16">-XX:SurvivorRatio=15</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the initial size of the permanent space.</td>
<td class="calibre33"><kbd class="calibre16">-XX:PermSize=512m</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the maximum size of the permanent space.</td>
<td class="calibre33"><kbd class="calibre16">-XX:MaxPermSize=512m</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the size of the stack area dedicated to each thread in bytes.</td>
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">-Xss512k</kbd></p>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the size of the stack area dedicated to each thread in Kbytes.</td>
<td class="calibre33"><kbd class="calibre16">-XX:ThreadStackSize=512</kbd></td>
</tr>
<tr class="calibre41">
<td class="calibre33">Sets the maximum size of off-heap memory available to the JVM.</td>
<td class="calibre33"><kbd class="calibre16">-XX:MaxDirectMemorySize=3g</kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">Here is a list of young garbage collection options:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Young garbage collection tuning option</strong></td>
<td class="calibre33"><strong class="calibre3">Flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the initial value for the number of collections before an object will be promoted from young to tenured space. This is referred to as the <strong class="calibre3">tenuring threshold</strong>.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:InitialTenuringThreshold=16</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the maximum value for tenuring threshold.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:MaxTenuringThreshold=30</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the maximum object size allowed to be allocated in young space. If an object is larger than the maximum size it will be allocated to tenured space and bypass young space.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:PretenureSizeThreshold=3m</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">This can be used to promote all young objects surviving the young collection to tenured space.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+AlwaysTenure</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">With this tag, objects from young space never get promoted to tenured space as long as the survivor space has sufficient room for them.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+NeverTenure</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">We can indicate that we want to use thread local allocation blocks in the young space. This is enabled by default.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+UseTLAB</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Toggle this to allow the JVM to adaptively resize the <strong class="calibre3">TLAB</strong> (<strong class="calibre3">Thread Local Allocation Blocks</strong>) for threads.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+ResizeTLAB</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the initial size of TLAB for a thread.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:TLABSize=2m</span></kbd></td>
</tr>
<tr class="calibre35">
<td class="calibre33">Sets the minimum allowable size of TLAB.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:MinTLABSize=128k</span></kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root">Here is a list of <strong class="calibre8">concurrent mark sweep</strong> (<strong class="calibre8">CMS</strong>) tuning options:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">CMS tuning option</strong></td>
<td class="calibre33"><strong class="calibre3">Flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+UseCMSInitiatingOccupancyOnly</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the percentage CMS generation occupancy to start a CMS collection cycle. If you indicate a negative number, you are telling the JVM you want to use <kbd class="calibre16">CMSTriggerRatio</kbd>.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:CMSInitiatingOccupancyFraction=70</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the percentage CMS generation occupancy that you want to initiate a CMS collection for bootstrapping collection statistics.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:CMSBootstrapOccupancy=10</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is the percentage of <kbd class="calibre16">MinHeapFreeRatio</kbd> in CMS generation that is allocated prior to a CMS cycle starts.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:CMSTriggerRatio=70</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the percentage of <kbd class="calibre16">MinHeapFreeRatio</kbd> in the CMS permanent generation that is allocated before starting a CMS collection cycle.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:CMSTriggerPermRatio=90</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is the wait duration after a CMS collection is triggered. Use the parameter to specify how long the CMS is allowed to wait for young collection.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:CMSWaitDuration=2000</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Enables parallel remark.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSParallelRemarkEnabled</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Enables parallel remark of survivor space.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSParallelSurvivorRemarkEnabled</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can use this to force young collection before the remark phase.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+CMSScavengeBeforeRemark</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Use this to prevent scheduling remark if Eden used is below the threshold value.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSScheduleRemarkEdenSizeThreshold</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the Eden occupancy percentage that you want CMS to try and schedule a remark pause.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:CMSScheduleRemarkEdenPenetration=20</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is where you want to start sampling Eden top at least before young generation occupancy reaches <em class="calibre22">1/4</em><sup class="calibre105">th</sup> (in our sample to the right) of the size at which you want to schedule remark.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:CMSScheduleRemarkSamplingRatio=4</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can select <kbd class="calibre16">variant=1</kbd> or <kbd class="calibre16">variant=2</kbd> of verification following remark.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:CMSRemarkVerifyVariant=1</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Elects to use the parallel algorithm for young space collection.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+UseParNewGC</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Enables the use of multiple threads for concurrent phases.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+CMSConcurrentMTEnabled</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">Sets the number of parallel threads used for the concurrent phases.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:ConcGCThreads=2</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Sets the number of parallel threads you want used for <em class="calibre22">stop-the-world</em> phases.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:ParallelGCThreads=2</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">You can enable <strong class="calibre3">incremental CMS</strong> (<strong class="calibre3">iCMS</strong>) mode.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+CMSIncrementalMode</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">If this is not enabled, CMS will not clean permanent space.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+CMSClassUnloadingEnabled</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This allows <kbd class="calibre16">System.gc()</kbd> to trigger concurrent collection instead of a full garbage collection cycle.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+ExplicitGCInvokesConcurrent</kbd></div>
</td>
</tr>
<tr class="calibre35">
<td class="calibre33">This allows <kbd class="calibre16">System.gc()</kbd> to trigger concurrent collection of permanent space.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</kbd></div>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip"><strong class="calibre3">iCMS</strong> (<strong class="calibre3">incremental concurrent mark sweep</strong>) mode is intended for servers with a small number of CPUs. It should not be employed on modern hardware.</div>
<p class="mce-root">Here are some miscellaneous garbage collection options:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Miscellaneous garbage collection options</strong></td>
<td class="calibre33"><strong class="calibre3">Flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">This will cause the JVM to ignore any <kbd class="calibre16">System.gc()</kbd> method invocations by an application.</td>
<td class="calibre33"><kbd class="calibre16">-XX:+DisableExplicitGC</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is the (soft reference) time to live in milliseconds per MB of free space in the heap.</td>
<td class="calibre33"><kbd class="calibre16">-XX:SoftRefLRUPolicyMSPerMB=2000</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">This is the <strong class="calibre3">use policy</strong> used to limit the time spent in garbage collection before an <kbd class="calibre16">OutOfMemory</kbd> error is thrown.</td>
<td class="calibre33"><kbd class="calibre16">-XX:+UseGCOverheadLimit</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This limits the proportion of time spent in garbage collection before an <kbd class="calibre16">OutOfMemory</kbd> error is thrown. This is used with <kbd class="calibre16">GCHeapFreeLimit</kbd>.</td>
<td class="calibre33"><kbd class="calibre16">-XX:GCTimeLimit=95</kbd></td>
</tr>
<tr class="calibre35">
<td class="calibre33">This sets the minimum percentage of free space after a full garbage collection before an <kbd class="calibre16">OutOfMemory</kbd> error is thrown. This is used with <kbd class="calibre16">GCTimeLimit</kbd>.</td>
<td class="calibre33"><kbd class="calibre16">-XX:GCHeapFreeLimit=5</kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">Finally, here are some G1 specific options. Note that, these are all supported starting with JVM 6u26:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">G1 garbage collection options</strong></td>
<td class="calibre33"><strong class="calibre3">Flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Size of the heap region. The default is 2,048 and the acceptable range is 1 MiB to 32 MiB.</td>
<td class="calibre33"><kbd class="calibre16">-XX:G1HeapRegionSize=16m</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is the confidence coefficient pause prediction heuristics.</td>
<td class="calibre33"><kbd class="calibre16">-XX:G1ConfidencePercent=75</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">This determines the minimum reserve in the heap.</td>
<td class="calibre33"><kbd class="calibre16">-XX:G1ReservePercent=5</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This is the garbage collection time per MMU--time slice in milliseconds.</td>
<td class="calibre33"><kbd class="calibre16">-XX:MaxGCPauseMillis=100</kbd></td>
</tr>
<tr class="calibre35">
<td class="calibre33">This is the pause interval time slice per MMU in milliseconds.</td>
<td class="calibre33"><kbd class="calibre16">-XX:GCPauseIntervalMillis=200</kbd></td>
</tr>
</tbody>
</table>
<div class="packt_infobox"><strong class="calibre3">MiB</strong> stands for <strong class="calibre3">Mebibyte</strong> which is a multiple of bytes for digital information.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java methods relevant to garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's look at two specific methods associated with garbage collection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The System.gc() method</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Although garbage collection is automatic in Java, you can make explicit calls to the <kbd class="calibre16">java.lang.System.gc()</kbd> method to aid in the debugging process. This method does not take any parameters and does not return any value. It is an explicit call that runs Java's garbage collector. Here is a sample implementation:</p>
<pre class="calibre21">    System.gc();<br class="calibre2"/>    System.out.println("Garbage collected and unused <br class="calibre2"/>     memory has been deallocated.");</pre>
<p class="mce-root">Let's look at a more in-depth example. In the following code, we start by creating an instance of the <kbd class="calibre16">Runtime</kbd>, using <kbd class="calibre16">Runtime myRuntime = Runtime.getRuntime();</kbd> which returns a singleton. This gives us access to the JVM. After printing some header information and initial memory stats, we create an <kbd class="calibre16">ArrayList</kbd> with a size of <kbd class="calibre16">300000</kbd>. Then, we create a loop that generates <kbd class="calibre16">100000</kbd> array list objects. Lastly, we provide output in three passes, asking the JVM to invoke the garbage collector with <kbd class="calibre16">1</kbd> second pauses in between. Here is the source code:</p>
<pre class="calibre21"><span class="calibre5">    package</span> MyGarbageCollectionSuite;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">    import</span> java.util.ArrayList;<br class="calibre2"/><span class="calibre5">    import</span> java.util.concurrent.TimeUnit;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">    public</span> <span class="calibre5">class</span> GCVerificationTest <br class="calibre2"/>    {<br class="calibre2"/><span class="calibre5">      public</span> <span class="calibre5">static</span> <span class="calibre5">void</span> main(String[] <span class="calibre5">args</span>) <span class="calibre5">throws</span> <br class="calibre2"/>       InterruptedException <br class="calibre2"/>       {<br class="calibre2"/>         // Obtain a Runtime instance (to communicate<br class="calibre2"/>          with the JVM)<br class="calibre2"/>         Runtime <span class="calibre5">myRuntime</span> = Runtime.getRuntime();<br class="calibre2"/><br class="calibre2"/>         // Set header information and output initial <br class="calibre2"/>          memory <span class="calibre5">stats<br class="calibre2"/></span><span class="calibre5">         System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span>"Garbage Collection<br class="calibre2"/>          Verification Test"<span class="calibre5">);<br class="calibre2"/></span><span class="calibre5">         System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span>"-----------------------------<br class="calibre2"/>          -----------------------------"<span class="calibre5">);<br class="calibre2"/></span>         System.<span class="calibre5">out</span>.println(<span class="calibre5">"Initial JVM Memory: "</span> + <br class="calibre2"/><span class="calibre5">          myRuntime</span>.totalMemory() + <br class="calibre2"/><span class="calibre5">            "tFree Memory: "</span> + <span class="calibre5">myRuntime</span>.freeMemory());<br class="calibre2"/>    <br class="calibre2"/>         // Use a bunch of memory<br class="calibre2"/>         ArrayList&lt;Integer&gt; <span class="calibre5">AccountNumbers</span> = <span class="calibre5">new</span> <br class="calibre2"/>          ArrayList&lt;&gt;(300000);<br class="calibre2"/><span class="calibre5">         for</span> (<span class="calibre5">int</span> <span class="calibre5">i</span> = 0; <span class="calibre5">i</span> &lt; 100000; <span class="calibre5">i</span>++)<br class="calibre2"/>         {<br class="calibre2"/><span class="calibre5">           AccountNumbers</span> = <span class="calibre5">new</span> ArrayList&lt;&gt;(3000);<br class="calibre2"/>           AccountNumbers<span class="calibre5"> = </span><span class="calibre5">null</span><span class="calibre5">;<br class="calibre2"/></span>         }<br class="calibre2"/><br class="calibre2"/>         // Provide update with with three passes<br class="calibre2"/><span class="calibre5">         for</span> (<span class="calibre5">int</span> <span class="calibre5">i</span> = 0; <span class="calibre5">i</span> &lt; 3; <span class="calibre5">i</span>++)<br class="calibre2"/>         {<br class="calibre2"/><span class="calibre5">           System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span>"---------------------------<br class="calibre2"/>            -----------"<span class="calibre5">);<br class="calibre2"/></span>           System.<span class="calibre5">out</span>.println(<span class="calibre5">"Free Memory before<br class="calibre2"/>            collection number "</span> + <br class="calibre2"/>              (<span class="calibre5">i</span>+1) + <span class="calibre5">": "</span> + <span class="calibre5">myRuntime</span>.freeMemory());<br class="calibre2"/>           System.gc();<br class="calibre2"/>           System.<span class="calibre5">out</span>.println(<span class="calibre5">"Free Memory after<br class="calibre2"/>            collection number "</span> + <br class="calibre2"/>              (<span class="calibre5">i</span>+1) + <span class="calibre5">": "</span> + <span class="calibre5">myRuntime</span>.freeMemory());<br class="calibre2"/><span class="calibre5">           TimeUnit.</span><span class="calibre5">SECONDS</span><span class="calibre5">.sleep(1); </span>// delay thread <br class="calibre2"/>            1 second<br class="calibre2"/>         }<br class="calibre2"/><br class="calibre2"/>       }<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root">As you can see from the following output, the garbage collector did not reallocate all of the 'garbage' during the first or even the second pass:</p>
<div class="mce-root1"><img src="Images/5a3d2619-3fad-4bb4-8b81-37917e313c73.png" width="878" height="395" class="calibre106"/></div>
<p class="mce-root">There is an alternative to using the <kbd class="calibre16">System.gc()</kbd> method to invoke the garbage collector. In our example, we could have used <kbd class="calibre16">myRuntime.gc()</kbd>, our earlier singleton example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The finalize() method</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">You can think of Java's garbage collector as a death dealer. When it removes something from memory, it is gone. This so-called death dealer is not without compassion as it provides each method with their final last words. The objects give their <em class="calibre20">last words</em> through a <kbd class="calibre16">finalize()</kbd> method. If an object has a <kbd class="calibre16">finalize()</kbd> method, the garbage collector invokes it before the object is removed and the associated memory deallocated. The method takes no parameters and has a return type of <kbd class="calibre16">void</kbd>.</p>
<p class="mce-root">The <kbd class="calibre16">finalize()</kbd> method is only called once and there can be variability when it is run. Certainly, the method is invoked before it is removed, but when the garbage collector runs is dependent on the system. If, as an example, you have a relatively small app that is running a memory-rich system, the garbage collector might not run at all. So, why include a <kbd class="calibre16">finalize()</kbd> method at all? It is considered poor programming practice to override the <kbd class="calibre16">finalize()</kbd> method. That being said, you can use the method if needed. In fact, you can add code there to add a reference to your object to ensure it is not removed by the garbage collector. Again, this is not advisable.</p>
<p class="mce-root">Because all objects in Java, even the ones you create yourself are child classes of <kbd class="calibre16">java.lang.Object</kbd>, every object in Java has a <kbd class="calibre16">finalize()</kbd> method.</p>
<p class="mce-root">The garbage collector, as sophisticated as it is, might not close databases, files, or network connections the way you want it done. If your application requires specific considerations when its objects are collected, you can override the object's <kbd class="calibre16">finalize()</kbd> method.</p>
<p class="mce-root">Here is an example implementation that demonstrates a use case for when you might want to override an object's <kbd class="calibre16">finalize()</kbd> method:</p>
<pre class="calibre21">    public<span class="calibre5"> </span>class<span class="calibre5"> Animal <br class="calibre2"/>    {<br class="calibre2"/></span>      private<span class="calibre5"> </span>static<span class="calibre5"> String </span><span class="calibre5">animalName</span><span class="calibre5">;<br class="calibre2"/></span>      private<span class="calibre5"> </span>static<span class="calibre5"> String </span>animalBreed<span class="calibre5">;<br class="calibre2"/></span>      private<span class="calibre5"> </span>static<span class="calibre5"> </span>int<span class="calibre5"> </span><span class="calibre5">objectTally</span><span class="calibre5"> = 0;<br class="calibre2"/><br class="calibre2"/></span>      // constructor<br class="calibre2"/><span class="calibre5">      public</span> Animal(String <span class="calibre5">name</span>, String <span class="calibre5">type</span>) <br class="calibre2"/>      {<br class="calibre2"/>        animalName<span class="calibre5"> = </span><span class="calibre5">name</span><span class="calibre5">;<br class="calibre2"/></span>        animalBreed<span class="calibre5"> = </span><span class="calibre5">type</span><span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>       // increment count of object<br class="calibre2"/><span class="calibre5">        ++</span>objectTally<span class="calibre5">;<br class="calibre2"/></span>      }<br class="calibre2"/><br class="calibre2"/><span class="calibre5">      protected</span> <span class="calibre5">void</span> finalize()<br class="calibre2"/>      {<br class="calibre2"/>        // decrement object count each time this method<br class="calibre2"/>        // is called by the garbage collector<br class="calibre2"/><span class="calibre5">        --</span>objectTally<span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>        //Provide output to user<br class="calibre2"/><span class="calibre5">        System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span><span class="calibre5">animalName</span><span class="calibre5"> + </span>" has been <br class="calibre2"/>         removed from memory."<span class="calibre5">);<br class="calibre2"/><br class="calibre2"/></span><span class="calibre5">  <br class="calibre2"/>        // condition for 1 animal (use singular form)<br class="calibre2"/>        if</span><span class="calibre5"> (</span><span class="calibre5">objectTally</span><span class="calibre5"> == 1) </span><br class="calibre2"/>        {<br class="calibre2"/><span class="calibre5">          System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span>"You have "<span class="calibre5"> + </span><span class="calibre5">objectTally</span><span class="calibre5"> + </span>"<br class="calibre2"/>           animal remaining."<span class="calibre5">);<br class="calibre2"/></span>        }<br class="calibre2"/><br class="calibre2"/>        // condition for 0 or greater than 1 <br class="calibre2"/>         animals (use plural form)<br class="calibre2"/><span class="calibre5">        else</span><span class="calibre5"> </span><br class="calibre2"/>        {<br class="calibre2"/><span class="calibre5">          System.</span><span class="calibre5">out</span><span class="calibre5">.println(</span>"You have "<span class="calibre5"> + </span><span class="calibre5">objectTally</span><span class="calibre5"> + </span>"<br class="calibre2"/>           animals remaining."<span class="calibre5">);<br class="calibre2"/></span>        }<br class="calibre2"/><br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root">As you can see in the preceding code, the <kbd class="calibre16">objectTally</kbd> count is incremented each time an object of type <kbd class="calibre16">Animal</kbd> is created and decremented when one is removed by the garbage collector.</p>
<div class="packt_tip">Overriding an object's <kbd class="calibre39">finalize()</kbd> method is usually discouraged. The <kbd class="calibre39">finalize()</kbd> method should normally be declared as <kbd class="calibre39">protected</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Pre-Java 9 garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java's garbage collection is not new to Java 9, it has existed since the initial release of Java. Java has long had a sophisticated garbage collection system that is automatic and runs in the background. By running in the background, we are referring to garbage collection processes running during idle times.</p>
<div class="packt_infobox">Idle times refer to the time in between input/output such as between keyboard input, mouse clicks, and output generation.</div>
<p class="mce-root">This automatic garbage collection has been one of the key factors in developers selecting Java for their programming solutions. Other programming languages such as C# and Objective-C have implemented garbage collection following the success of the Java platform.</p>
<p class="mce-root">Let's next take a look at the following listed concepts before we look at the changes to garbage collection in the Java 9 platform:</p>
<ul class="calibre13">
<li class="calibre14">Visualizing garbage collection</li>
<li class="calibre14">Garbage collection upgrades in Java 8</li>
<li class="calibre14">Case study - Games written with Java</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Visualizing garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">It can be helpful to visualize how garbage collection works and, perhaps more importantly, the need for it. Consider the following code snippet that progressively creates the string <kbd class="calibre16">Garbage</kbd>:</p>
<pre class="calibre21">    001 String var = new String("G");<br class="calibre2"/>    002 var += "a";<br class="calibre2"/>    003 var += "r";<br class="calibre2"/>    004 var += "b";<br class="calibre2"/>    005 var += "a";<br class="calibre2"/>    006 var += "g";<br class="calibre2"/>    007 var += "e";<br class="calibre2"/>    008 System.out.println("Your completed String<br class="calibre2"/>     is: " + var + ".");</pre>
<p class="mce-root">Clearly, the preceding code generates the output provided as follows:</p>
<pre class="calibre21">    Your completed String is Garbage.</pre>
<p class="mce-root">What might not be clear is that the sample code results in five unreferenced string objects. This is due, in part, because strings are immutable. As you can see in the following illustration, with each successive line of code, the referenced object is updated and an additional object becomes unreferenced:</p>
<div class="mce-root1"><img src="Images/2ecc5e95-dc0b-4998-a8dd-37452ec0d9ef.png" width="1422" height="529" class="calibre107"/></div>
<p class="mce-root">The preceding unreferenced objects listed certainly will not break the memory bank, but it is indicative of how quickly a large number of unreferenced objects can accumulate.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Garbage collection upgrades in Java 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As of Java 8, the default garbage collection algorithm was the parallel garbage collector. Java 8 was released with some improvements to the G1 garbage collection system. One of these improvements was the ability to use the following command-line option to optimize the heap memory by removing duplicative string values:</p>
<pre class="calibre21"><strong class="calibre3">-XX:+UseStringDeduplication</strong></pre>
<p class="mce-root">The G1 garbage collector can view the character arrays when it sees a string. It then takes the value and stores it with a new, weak reference to the character array. If the G1 garbage collector finds a string with the same hash code, it will compare the two strings with a character-by-character review. If a match is found, both strings end up pointing to the same character array. Specifically, the first string will point to the character array of the second string.</p>
<p class="mce-root">This method can require substantial processing overhead and should only be used if deemed beneficial or absolutely necessary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Case study - Games written with Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Multiplayer games require extensive management techniques, both for server and client systems. The JVM runs the garbage collection thread in a low-priority thread and periodically runs. Server administrators previously used an incremental garbage collection schema using the now depreciated <kbd class="calibre16">-Xincgc</kbd> command-line option to avoid <strong class="calibre8">server stalls</strong> that occur when the server is overloaded. The goal is to have garbage collection run more frequently and with much shorter execution cycles each time.</p>
<div class="packt_tip">When considering memory usage and garbage collection, it is important to use as little memory on the target system as possible and to limit pauses for garbage collection to the extent feasible. These tips are especially important for games, simulations, and other applications that require real-time performance.</div>
<p class="mce-root">The JVM manages the heap where Java memory is stored. The JVM starts with a small heap by default and grows as additional objects are created. The heap has two partitions--young and tenured. When objects are initially created, they are created in the young partition. Persistent objects are moved to the tenure partition. The creation of objects is usually very quick with not much more than pointer incrementation. Processing in the young partition is much faster than that of the tenured partition. This is important because it applies to the overall app, or in our case, a game's efficiency.</p>
<p class="mce-root">It becomes important for us to monitor our game's memory usage and when garbage collection occurs. To monitor garbage collection, we can add the verbose flag (<kbd class="calibre16">-verbose:gc</kbd>) when we launch our game such as with the following example:</p>
<pre class="calibre21"><strong class="calibre3">java -verbose:gc MyJavaGameClass</strong></pre>
<p class="mce-root">The JVM will then provide a line of formatted output for each garbage collection. Here is the format of the verbose GC output:</p>
<pre class="calibre21">    [&lt;TYPE&gt; &lt;MEMORY USED BEFORE&gt; -&gt; MEMORY USED AFTER<br class="calibre2"/>     (TOTAL HEAP SIZE), &lt;TIME&gt;]</pre>
<p class="mce-root">Let's look at two examples. In this first example, we see <kbd class="calibre16">GC</kbd> for type which refers to the young partition we previously discussed:</p>
<pre class="calibre21">    [GC 31924K -&gt; 29732K(42234K), 0.0019319 secs]</pre>
<p class="mce-root">In this second example, <kbd class="calibre16">Full GC</kbd> indicates that the garbage collection action was taken on the tenured partition of the memory heap:</p>
<pre class="calibre21">    [Full GC 29732K -&gt; 10911K(42234K), 0.0319319 secs]</pre>
<p class="mce-root">You can obtain more detailed information from the garbage collector using the <kbd class="calibre16">-XX:+PrintGCDetails</kbd> option as shown here:</p>
<pre class="calibre21"><strong class="calibre3">java -verbose:gc -XX:+PrintGCDetails MyJavaGameClass</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Collecting garbage with the new Java platform</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java came out of the gate with automatic garbage collection, making it a development platform of choice for many programmers. It was commonplace to want to avoid manual memory management in other programming languages. We have looked in-depth at the garbage collection system to include the various approaches, or algorithms, used by the JVM. Java 9 includes some relevant changes to the garbage collection system and was the focus of three <strong class="calibre8">Java Enhancement Program</strong> (<strong class="calibre8">JEP</strong>) issues. Those issues are listed here:</p>
<ul class="calibre13">
<li class="calibre14">Default garbage collection (JEP 248)</li>
<li class="calibre14">Depreciated garbage collection combinations (JEP 214)</li>
<li class="calibre14">Unified garbage collection logging (JEP 271)</li>
</ul>
<p class="mce-root">We will review each one of these garbage collection concepts and their corresponding <strong class="calibre8">Java Enhancement Plan</strong> (<strong class="calibre8">JEP</strong>) issue in the following sections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Default garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We previously detailed the following garbage collection approaches used by the JVM prior to Java 9. These are still plausible garbage collection algorithms:</p>
<ul class="calibre13">
<li class="calibre14">CMS garbage collection</li>
<li class="calibre14">Serial garbage collection</li>
<li class="calibre14">Parallel garbage collection</li>
<li class="calibre14">G1 garbage collection</li>
</ul>
<p class="mce-root">Let's briefly recap each of these approaches:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">CMS garbage collection</strong>: The CMS garbage collection algorithm scans heap memory using multiple threads. Using this approach, the JVM marks objects for removal and then makes a sweep to actually remove them.</li>
<li class="calibre14"><strong class="calibre3">Serial garbage collection</strong>: This approach uses a thread-freezing schema on a single thread. When the garbage collection is in progress, it freezes all other threads until garbage collection operations have concluded. Due to the thread-freezing nature of serial garbage collection, it is only feasible for very small programs.</li>
<li class="calibre14"><strong class="calibre3">Parallel garbage collection</strong>: This approach uses multiple threads but freezes all non-garbage collection threads in the application until garbage collection functions have completed, just like the serial garbage collection algorithm.</li>
<li class="calibre14"><strong class="calibre3">G1 garbage collection</strong>: This is the garbage collection algorithm with the following characteristics:
<ul class="calibre13">
<li class="calibre14">Is used with large memory heaps</li>
<li class="calibre14">Involves segmenting the memory heap into regions</li>
<li class="calibre14">Takes place in parallel with each heap region</li>
<li class="calibre14">Compacts the heap space when memory is deallocated</li>
<li class="calibre14">Compacting operations take place using the <em class="calibre22">Stop the World</em> approach</li>
<li class="calibre14"><span class="calibre5">Prioritizes the regions based on those that have the most garbage to be collected</span></li>
</ul>
</li>
</ul>
<p class="mce-root">Prior to Java 9, the parallel garbage collection algorithm was the default garbage collector. In Java 9, the G1 garbage collector is the new default implementation of Java's memory management system. This is true for both 32 and 64-bit server configurations.</p>
<p class="mce-root">Oracle assessed that the G1 garbage collector, mostly due to its low-pause nature, was a better performing garbage collection method than the parallel approach. This change was predicated on the following concepts:</p>
<ul class="calibre13">
<li class="calibre14">It is important to limit latency</li>
<li class="calibre14">Maximizing throughput is less important than limiting latency</li>
<li class="calibre14">The G1 garbage collection algorithm is stable</li>
</ul>
<p class="mce-root">There are two assumptions involved with making the G1 garbage collection method the default method over the parallel approach:</p>
<ul class="calibre13">
<li class="calibre14">Making G1 the default garbage collection method will significantly increase its use. This increased usage might unveil performance or stability issues not realized before Java 9.</li>
<li class="calibre14">The G1 approach is more processor-intensive than the parallel approach. In some use cases, this could be somewhat problematic.</li>
</ul>
<p class="mce-root">On the surface this change might seem like a great step for Java 9 and that very well might be the case. Caution, however, should be used when blindly accepting this new default collection method. It is recommended that systems be tested if switching to G1 to ensure your applications do not suffer from performance degradation or have unexpected issues that are caused by the use of G1. As previously suggested, G1 has not benefited from the widespread testing that the parallel method has.</p>
<p class="mce-root">This last point about the lack of widespread testing is significant. Making G1 the default automatic memory management (garbage collection) system with Java 9 is tantamount to turning developers into unsuspecting testers. While no major problems are expected, knowing that there is potential for performance and stability issues when using G1 with Java 9 will place greater emphasis on testing your Java 9 applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Depreciated garbage collection combinations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Oracle has been great about depreciating features, APIs, and libraries before removing them from a new release to the Java platform. With this schema in place, language components that were depreciated in Java 8 are subject for removal in Java 9. There are a few garbage collection combinations that were deemed to be rarely used and depreciated in Java 8. Those combinations, listed here, have been removed in Java 9:</p>
<ul class="calibre13">
<li class="calibre14">DefNew + CMS</li>
<li class="calibre14">ParNew + SerialOld</li>
<li class="calibre14">Incremental CMS</li>
</ul>
<p class="mce-root">These combinations, in addition to having been rarely used, introduced an unneeded level of complexity to the garbage collection system. This resulted in an extra drain on system resources without providing a commensurate benefit to the user or developer.</p>
<p class="mce-root">The following listed garbage collection configurations were affected by the aforementioned depreciation in the Java 8 platform:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Garbage collection configuration</strong></td>
<td class="calibre33"><strong class="calibre3">Flag(s)</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">DefNew + CMS</td>
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">-XX:+UseParNewGC</kbd></p>
<p class="mce-root3"><kbd class="calibre16">-XX:UseConcMarkSweepGC</kbd></p>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">ParNew + SerialOld</td>
<td class="calibre33"><kbd class="calibre16">-XX:+UseParNewGC</kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">ParNew + iCMS</td>
<td class="calibre33"><kbd class="calibre16">-Xincgc</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">ParNew + iCMS</td>
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">-XX:+CMSIncrementalMode</kbd></p>
<p class="mce-root3"><kbd class="calibre16">-XX:+UseConcMarkSweepGC</kbd></p>
</td>
</tr>
<tr class="calibre35">
<td class="calibre33">Defnew + ICMS</td>
<td class="calibre33">
<p class="mce-root3"><kbd class="calibre16">-XX:+CMSIncrementalMode</kbd></p>
<p class="mce-root3"><kbd class="calibre16">-XX:+UseConcMarkSweepGC</kbd></p>
<p class="mce-root3"><kbd class="calibre16">-XX:-UseParNewGC</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">The <strong class="calibre8">Java Enhancement Program 214</strong> (<strong class="calibre8">JEP 214</strong>) removed garbage collection combinations depreciated in JDK 8. Those combinations are listed above along with the flags that control those combinations. In addition, the flags to enable CMS foreground collections were removed and are not present in JDK 9. Those flags are listed as follows:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Garbage collection combinations</strong></td>
<td class="calibre33"><strong class="calibre3">Flag</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">CMS foreground</td>
<td class="calibre33"><kbd class="calibre16">-XX:+UseCMSCompactAtFullCollection</kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">CMS foreground</td>
<td class="calibre33"><kbd class="calibre16">-XX+CMSFullGCsBeforeCompaction</kbd></td>
</tr>
<tr class="calibre35">
<td class="calibre33">CMS foreground</td>
<td class="calibre33"><kbd class="calibre16">-XX+UseCMSCollectionPassing</kbd></td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">The only assessed downside to the removal of the depreciated garbage collection combinations is that applications that use JVM start up files with any of the flags listed in this section, will need to have their JVM start up files modified to remove or replace the old flags.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Unified garbage collection logging</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <strong class="calibre8">Java Enhancement Program #271</strong> (<strong class="calibre8">JEP-271</strong>) titled, <em class="calibre20">Unified GC Logging</em>, is intended to re-implement garbage collection logging using the unified JVM logging framework that was previously introduced with JEP-158. So, let's first review the Unified JVM Logging (JEP-158).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Unified JVM logging (JEP-158)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Creating a unified logging schema for the JVM was the central goal of JEP-158. Here is a high-level list of the goals of the JEP:</p>
<ul class="calibre13">
<li class="calibre14">Create a JVM-wide set of command-line options for all logging operations</li>
<li class="calibre14">Use categorized tags for logging</li>
<li class="calibre14">Provide six levels of logging:
<ul class="calibre13">
<li class="calibre14">Error</li>
<li class="calibre14">Warning</li>
<li class="calibre14">Information</li>
<li class="calibre14">Debug</li>
<li class="calibre14">Trace</li>
<li class="calibre14">Develop</li>
</ul>
</li>
</ul>
<div class="packt_infobox">This is not an exhaustive list of goals. We will discuss JEP-158 in greater detail in <a href="" target="_blank" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 14</a>, <em class="calibre22">Command Line Flags</em>.</div>
<p class="mce-root">The changes to the JVM, in the context of logging, can be categorized into:</p>
<ul class="calibre13">
<li class="calibre14">Tags</li>
<li class="calibre14">Levels</li>
<li class="calibre14">Decorations</li>
<li class="calibre14">Output</li>
<li class="calibre14">Command-line options</li>
</ul>
<p class="mce-root">Let's briefly look at these categories.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Tags</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Logging tags are identified in the JVM and can be changed in source code if needed. The tags should be self-identifying, such as <kbd class="calibre16">gc</kbd> for garbage collection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Levels</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Each log message has an associated level. As previously listed, the levels are error, warning, information, debug, trace, and develop. The following chart shows how the levels have an increasing level of verbosity in respect to how much information is logged:</p>
<div class="mce-root1"><img src="Images/a924575f-0997-4289-a024-1747463ddca0.png" width="1002" height="669" class="calibre108"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decorations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the context of Java 9's logging framework, decorations is metadata about the log message. Here is the alphabetic list of decorations that are available:</p>
<ul class="calibre13">
<li class="calibre14">level</li>
<li class="calibre14">pid</li>
<li class="calibre14">tags</li>
<li class="calibre14">tid</li>
<li class="calibre14">time</li>
<li class="calibre14">timemillis</li>
<li class="calibre14">timenanos</li>
<li class="calibre14">uptime</li>
<li class="calibre14">uptimemillis</li>
<li class="calibre14">uptimenanos</li>
</ul>
<p class="mce-root">For an explanation of these decorations, please refer to <a href="" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 14</a>, <em class="calibre20">Command Line Flags</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Output</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java 9 logging framework supports three types of output:</p>
<ul class="calibre13">
<li class="calibre14">stderr: Provides output to stderr</li>
<li class="calibre14">stdout: Provides output to stdout</li>
<li class="calibre14">text file: Writes the output to text files</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Command-line options</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A new command-line option was added to the logging framework to provide overall control of the JVM's logging operations. The <kbd class="calibre16">-Xlog</kbd> command-line option has an extensive array of parameters and possibilities. Here is one example:</p>
<pre class="calibre21"><strong class="calibre3">-Xlog:gc+rt*=debug</strong></pre>
<p class="mce-root">In this example, we are telling the JVM to take the following actions:</p>
<ul class="calibre13">
<li class="calibre14">Log all messages tagged with, at a minimum, the <kbd class="calibre16">gc</kbd> and <kbd class="calibre16">rt</kbd> tags</li>
<li class="calibre14">Use the <kbd class="calibre16">debug</kbd> level</li>
<li class="calibre14">Provide output to <kbd class="calibre16">stdout</kbd></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Unified GC logging (JEP-271)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that we have a general understanding of the changes to Java 9's logging framework, let's look at what changes JEP-271 introduced. In this section we will look at the following areas:</p>
<ul class="calibre13">
<li class="calibre14">Garbage collection logging options</li>
<li class="calibre14">The <kbd class="calibre16">gc</kbd> tag</li>
<li class="calibre14">Macros</li>
<li class="calibre14">Additional considerations</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Garbage collection logging options</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here is a list of garbage collection logging options and flags we had available to us before the introduction of Java 9's logging framework:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Garbage collection logging option</strong></td>
<td class="calibre33"><strong class="calibre3">JVM option flag(s)</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">This prints the basic garbage collection information.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-verbose:gc</span></kbd> <span class="calibre5">or</span> <kbd class="calibre16"><span class="calibre5">-XX:+PrintGC</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This will print more detailed garbage collection information.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintGCDetails</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can print timestamps for each garbage collection event. The seconds are sequential and begin from the JVM start time.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintGCTimeStamps</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">
<p class="mce-root3">You can print date stamps for each garbage collection event. Sample format:</p>
<p class="mce-root3"><kbd class="calibre16">2017-07-26T03:19:00.319+400:[GC . . . ]</kbd></p>
</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintGCDateStamps</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can use this flag to print timestamps for individual garbage collection work thread tasks.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintGCTaskTimeStamps</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Using this you can redirect garbage collection output to a file instead of the console.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-Xloggc:</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can print detailed information regarding young space following each collection cycle.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintTenuringDistribution</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">You can use this flag to print TLAB allocation statistics.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintTLAB</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Using this flag, you can print the times for reference processing (that is, weak, soft, and so on) during <em class="calibre22">stop-the-world</em> pauses.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintReferenceGC</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This reports if the garbage collection is waiting for native code to unpin objects in memory.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintJNIGCStalls</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">This will print a pause summary after each <em class="calibre22">stop-the-world</em> pause.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintGCApplicationStoppedTime</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">This flag will print time for each concurrent phase of garbage collection.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintGCApplicationConcurrentTime</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Using this flag will print a class histogram after a full garbage collection.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintClassHistogramAfterFullGC</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Using this flag will print a class histogram before a full garbage collection.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintClassHistogramBeforeFullGC</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">This creates a heap dump file after full garbage collection.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+HeapDumpAfterFullGC</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">This creates a heap dump file before full garbage collection.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+HeapDumpBeforeFullGC</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">This creates a heap dump file in an out-of-memory condition.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+HeapDumpOnOutOfMemoryError</kbd></div>
</td>
</tr>
<tr class="calibre32">
<td class="calibre33">You use this flag to specify the path where you want your heap dumps saved on your system.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:HeapDumpPath=&lt;path&gt;</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can use this to print CMS statistics, <kbd class="calibre16">if n &gt;= 1</kbd>. Applies specifically to CMS only.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:PrintCMSStatistics=2</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This will print CMS initialization details. Applies specifically to CMS only.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+PrintCMSInitiationStatistics</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can use this flag to print additional information concerning free lists. Applies specifically to CMS only.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:PrintFLSStatistics=2</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">You can use this flag to print additional information concerning free lists. Applies specifically to CMS only.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:PrintFLSCensus=2</span></kbd></td>
</tr>
<tr class="calibre34">
<td class="calibre33">You can use this flag to print detailed diagnostic information following a promotion (young to tenure) failure. Applies specifically to CMS only.</td>
<td class="calibre33"><kbd class="calibre16"><span class="calibre5">-XX:+PrintPromotionFailure</span></kbd></td>
</tr>
<tr class="calibre32">
<td class="calibre33">This flag allows you to dump useful information regarding the state of the CMS old generation when a promotion (young to tenure) failure occurs. Applies specifically to CMS only.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSDumpAtPromotionFailure</kbd></div>
</td>
</tr>
<tr class="calibre34">
<td class="calibre33">When the <kbd class="calibre16">-XX:+CMSDumpAtPromotionFailure</kbd> flag is used, you can use <kbd class="calibre16">-XX:+CMSPrintChunksInDump</kbd> to include additional details regarding free chunks. Applies specifically to CMS only.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSPrintChunksInDump</kbd></div>
</td>
</tr>
<tr class="calibre41">
<td class="calibre33">When using the <kbd class="calibre16">-XX:+CMSPrintChunksInDump</kbd> flag, you can include additional information about the allocated objects using the <kbd class="calibre16">-XX:+CMSPrintObjectsInDump</kbd> flag. Applies specifically to CMS only.</td>
<td class="calibre33">
<div class="calibre40"><kbd class="calibre16">-XX:+CMSPrintObjectsInDump</kbd></div>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The gc tag</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can use the <kbd class="calibre16">gc</kbd> tag with the <kbd class="calibre16">-Xlog</kbd> option to inform the JVM to only log <kbd class="calibre16">gc</kbd> tagged items at the info level. As you will recall, this is similar to using <kbd class="calibre16">-XX:+PrintGC</kbd>. With both options, the JVM will log one line for each garbage collection operation.</p>
<p class="mce-root">It is important to note that the <kbd class="calibre16">gc</kbd> tag was not intended to be used on its own; rather, it is recommended that it be used in conjunction with other tags.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Macros</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can create macros to add logic to our garbage collection logging. Here is the general syntax for the log macro:</p>
<pre class="calibre21">    log_&lt;level&gt;(Tag1[,...])(fmtstr, ...)</pre>
<p class="mce-root">Here is an example of a log macro:</p>
<pre class="calibre21">    log_debug(gc, classloading)("Number of objects<br class="calibre2"/>     loaded: %d.", object_count)</pre>
<p class="mce-root">The following example skeleton log macro shows how you can use the new Java 9 logging framework to create scripts for greater fidelity in logging:</p>
<pre class="calibre21">    LogHandle(gc, rt, classunloading) log;<br class="calibre2"/>    if (log.is_error())<br class="calibre2"/>    {<br class="calibre2"/>      // do something specific regarding the 'error' level<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    if (log.is_warning())<br class="calibre2"/>    {<br class="calibre2"/>      // do something specific regarding the 'warning'<br class="calibre2"/>      level<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    if (log.is_info())<br class="calibre2"/>    {<br class="calibre2"/>      // do something specific regarding the 'info' level<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    if (log.is_debug())<br class="calibre2"/>    {<br class="calibre2"/>      // do something specific regarding the 'debug' level<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    if (log.is_trace())<br class="calibre2"/>    {<br class="calibre2"/>      // do something specific regarding the 'trace' level<br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Additional considerations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here are some additional items to be considered in regards to garbage collection logging:</p>
<ul class="calibre13">
<li class="calibre14">Using the new <kbd class="calibre16">-Xlog:gc</kbd> should produce similar results to the <kbd class="calibre16">-XX:+PrintGCDetails</kbd> command-line option and flag pairing</li>
<li class="calibre14">The new <kbd class="calibre16">trace</kbd> level provides the level of detail previously provided with the <kbd class="calibre16">verbose</kbd> flag</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Persistent issues</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Even with the advent of Java 9, there were downsides to Java's garbage collection system. Because it is an automatic process, we do not have complete control of when the collector runs. We, as developers, are not in control of garbage collection, the JVM is. The JVM makes the decision when to run garbage collection. As you have seen earlier in this chapter, we can ask the JVM to run garbage collection using the <kbd class="calibre16">System.gc()</kbd> method. Despite our use of this method, we are guaranteed that our request will be honored or that it will be complied with in a timely manner.</p>
<p class="mce-root">Earlier in this chapter, we reviewed several approaches and algorithms for garbage collection. We discussed how we, as developers, can take control of the process. That assumes that we have the ability to take control of garbage collection. Even when we specify a specific garbage collection technique, for example using <kbd class="calibre16">-XX:+UseConcMarkSweepGC</kbd> for CMS garbage collection, we are not guaranteed that the JVM will use that implementation. So, we can do our best to control how the garbage collector works, but should remember that the JVM has the ultimate authority regarding how, when, and if garbage collection occurs.</p>
<p class="mce-root">Our lack of complete control over garbage collection underscores the importance of writing efficient code with memory management in mind. In the next sections, we will examine how to write code to explicitly make objects eligible for garbage collection by the JVM.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Making objects eligible for garbage collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An easy method for making objects available for garbage collection is to assign <kbd class="calibre16">null</kbd> to the reference variable that refers to the object. Let's review this example:</p>
<pre class="calibre21"><span class="calibre5">    package</span> MyGarbageCollectionSuite;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">    public</span> <span class="calibre5">class</span> GarbageCollectionExperimentOne <br class="calibre2"/>    {<br class="calibre2"/><span class="calibre5">      public</span> <span class="calibre5">static</span> <span class="calibre5">void</span> main(String[] <span class="calibre5">args</span>) <br class="calibre2"/>      {<br class="calibre2"/><br class="calibre2"/>        // Declare and create new object.<br class="calibre2"/>        String <span class="calibre5">junk</span> = <span class="calibre5">new</span> String(<span class="calibre5">"Pile of Junk"</span>);<br class="calibre2"/><br class="calibre2"/>        // Output to demonstrate that the object<br class="calibre2"/>        has an active reference<br class="calibre2"/>        // and is not eligible for garbage collection.<br class="calibre2"/>        System.<span class="calibre5">out</span>.println(<span class="calibre5">junk</span>);<br class="calibre2"/><br class="calibre2"/>        // Set the reference variable to null.<br class="calibre2"/><span class="calibre5">        junk</span> = <span class="calibre5">null</span>;<br class="calibre2"/><br class="calibre2"/>        // The String object junk is now eligible<br class="calibre2"/>        for garbage collection.<br class="calibre2"/><br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root">As indicated in the in-code comments, once the string object reference variable is set to null, in this case using the <kbd class="calibre16">junk = null;</kbd> statement, the object becomes available for garbage collection.</p>
<p class="mce-root">In our next example, we will abandon an object by setting its reference variable to point to a different object. As you can see in the following code, that results in the first object being available for garbage collection:</p>
<pre class="calibre21"><span class="calibre5">    package</span> MyGarbageCollectionSuite;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">    public</span> <span class="calibre5">class</span> GarbageCollectionExperimentTwo<br class="calibre2"/>    {<br class="calibre2"/><span class="calibre5">      public</span> <span class="calibre5">static</span> <span class="calibre5">void</span> main(String[] <span class="calibre5">args</span>)<br class="calibre2"/>      {<br class="calibre2"/>        // Declare and create the first object.<br class="calibre2"/><span class="calibre5">        String </span><span class="calibre5">junk1</span><span class="calibre5"> = </span><span class="calibre5">new</span><span class="calibre5"> String(</span>"The first pile of<br class="calibre2"/>         Junk"<span class="calibre5">);<br class="calibre2"/><br class="calibre2"/></span>        // Declare and create the second object.<br class="calibre2"/><span class="calibre5">        String </span><span class="calibre5">junk2</span><span class="calibre5"> = </span><span class="calibre5">new</span><span class="calibre5"> String(</span>"The second pile of <br class="calibre2"/>         Junk"<span class="calibre5">);<br class="calibre2"/><br class="calibre2"/></span>        // Output to demonstrate that both objects have<br class="calibre2"/>        active references<br class="calibre2"/>        // and are not eligible for garbage collection.<br class="calibre2"/>        System.<span class="calibre5">out</span>.println(<span class="calibre5">junk1</span>);<br class="calibre2"/>        System.<span class="calibre5">out</span>.println(<span class="calibre5">junk2</span>);<br class="calibre2"/><br class="calibre2"/>        // Set the first object's reference to the<br class="calibre2"/>         second object.<br class="calibre2"/>        junk1<span class="calibre5"> = </span>junk2;<br class="calibre2"/><br class="calibre2"/>        // The String "The first pile of Junk" is now<br class="calibre2"/>         eligible for garbage collection.<br class="calibre2"/><br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root">Let's review one final method of making objects available for garbage collection. In this example, we have a single instance variable (<kbd class="calibre16">objectNbr</kbd>) that is a reference variable to an instance of the <kbd class="calibre16">GarbageCollectionExperimentThree</kbd> class. The class does not do anything interesting other than create additional reference variables to instances of the <kbd class="calibre16">GarbageCollectionExperimentThree</kbd> class. In our example, we set the <kbd class="calibre16">objectNbr2</kbd>, <kbd class="calibre16">objectNbr3</kbd>, <kbd class="calibre16">objectNbr4</kbd>, and <kbd class="calibre16">objectNbr5</kbd> references to <kbd class="calibre16">null</kbd>. Although these objects have instance variables and can refer to each other, their accessibility outside of the class has been terminated by setting their references to <kbd class="calibre16">null</kbd>. This makes them ( <kbd class="calibre16">objectNbr2</kbd>, <kbd class="calibre16">objectNbr3</kbd>, <kbd class="calibre16">objectNbr4</kbd>, and <kbd class="calibre16">objectNbr5</kbd> ) eligible for garbage collection:</p>
<pre class="calibre21"><span class="calibre5">    package</span> MyGarbageCollectionSuite;<br class="calibre2"/>    {<br class="calibre2"/><br class="calibre2"/>      // instance variable<br class="calibre2"/>      GarbageCollectionExperimentThree <span class="calibre5">objectNbr</span>;<br class="calibre2"/><br class="calibre2"/><span class="calibre5">      public</span> <span class="calibre5">static</span> <span class="calibre5">void</span> main(String[] <span class="calibre5">args</span>) <br class="calibre2"/>      {<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr2</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr3</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr4</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr5</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr6</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/>        GarbageCollectionExperimentThree <span class="calibre5">objectNbr7</span> = <span class="calibre5">new<br class="calibre2"/></span>         GarbageCollectionExperimentThree();<br class="calibre2"/><br class="calibre2"/>        // set objectNbr2 to refer to objectNbr3<br class="calibre2"/>        objectNbr2<span class="calibre5">.</span><span class="calibre5">objectNbr</span><span class="calibre5"> = </span>objectNbr3<span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>        // set objectNbr3 to refer to objectNbr4<br class="calibre2"/>        objectNbr3<span class="calibre5">.</span><span class="calibre5">objectNbr</span><span class="calibre5"> = </span>objectNbr4<span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>        // set objectNbr4 to refer to objectNbr5<br class="calibre2"/>        objectNbr4<span class="calibre5">.</span><span class="calibre5">objectNbr</span><span class="calibre5"> = </span>objectNbr5<span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>        // set objectNbr5 to refer to objectNbr2<br class="calibre2"/>        objectNbr5<span class="calibre5">.</span><span class="calibre5">objectNbr</span><span class="calibre5"> = </span>objectNbr2<span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>        // set selected references to null<br class="calibre2"/>        objectNbr2<span class="calibre5"> = </span><span class="calibre5">null</span><span class="calibre5">;<br class="calibre2"/></span>        objectNbr3<span class="calibre5"> = </span><span class="calibre5">null</span><span class="calibre5">;<br class="calibre2"/></span>        objectNbr4<span class="calibre5"> = </span><span class="calibre5">null</span><span class="calibre5">;<br class="calibre2"/></span>        objectNbr5<span class="calibre5"> = </span><span class="calibre5">null</span><span class="calibre5">;<br class="calibre2"/><br class="calibre2"/></span>      }<br class="calibre2"/><br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter we took an in-depth review of garbage collection as a critical pre-Java 9 platform component. Our review included object life cycle, garbage collection algorithms, garbage collection options, and methods related to garbage collection. We looked at upgrades to garbage collection in Java 8 and looked at a case study to help our understanding of modern garbage collection. We then turned our focus to the changes to garbage collection with the new Java 9 platform. Our exploration of garbage collection in Java 9 included looks at default garbage collection, depreciated garbage collection combinations, and unified garbage collection logging. We concluded our exploration of garbage collection by looking at a few garbage collection issues that persist, even after Java 9.</p>
<p class="mce-root">In the next chapter we will look at how to write performance tests using the <strong class="calibre8">Java Microbenchmark Harness</strong> (<strong class="calibre8">JMH</strong>), a Java harness library for writing benchmarks for the JVM.</p>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </div>



  </body></html>