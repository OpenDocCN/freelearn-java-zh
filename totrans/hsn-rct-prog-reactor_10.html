<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing and Debugging</h1>
                </header>
            
            <article>
                
<p class="mce-root">Throughout this book, we have covered Reactor in great detail, working with its various operators and building examples using them. However, writing code is only half of the job. All production code must also be verified with adequate unit tests. These tests not only  validate our code, but they also enable us to make changes faster. If we refactor code, the tests ensure that our change has not broken any existing functionality. In this chapter, we will cover the testing support offered by Reactor. Testing business code will catch most of the issues, but the code will fail in production. In such scenarios, the code needs to be debugged in order to find the root cause of the failure. In this chapter, we will also cover some basic techniques to debug Reactor pipelines.</p>
<p>In this final chapter, we will learn how to:</p>
<ul>
<li>Test Reactor pipelines</li>
<li>Debug Reactor streams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE 2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing Reactor pipelines</h1>
                </header>
            
            <article>
                
<p>Unit testing Reactor pipelines is quite hard. This is because Reactor declares behaviors rather than states that can be validated. Fortunately, Reactor comes with utility classes that can assist in unit testing. The testing utilities are bundled in the <kbd>reactor-test</kbd> component. <kbd>reactor-test</kbd> provides us with the following three components:</p>
<ul>
<li><kbd>StepVerifier</kbd>: Allows us to validate a pipeline configuration and operators</li>
<li><kbd>TestPublisher</kbd>: Allows us to produce test data to enable testing operators</li>
<li><kbd>PublisherProbe</kbd>: Enables us to validate an existing publisher</li>
</ul>
<p>Before we proceed, let's first add <kbd>reactor-test</kbd> to our <kbd>build.gradle</kbd>. We do not need to specify the version of this as that is defined by the <kbd>org.springframework.boot</kbd> plugin:</p>
<pre>plugins {<br/>    id "io.spring.dependency-management" version "1.0.1.RELEASE"<br/>    id "org.springframework.boot" version "2.0.3.RELEASE"<br/>    id "java"<br/>}<br/><br/>// Removed for brevity<br/><br/>dependencies {<br/>        compile 'org.springframework.boot:spring-boot-starter-webflux'<br/>        compile 'org.springframework:spring-context-support'<br/>        compile group: 'org.freemarker', name: 'freemarker', version: '2.3.28'<br/>        testCompile group: 'junit', name: 'junit', version: '4.12'<br/>        testCompile 'io.projectreactor:reactor-test'<br/>}</pre>
<p>Now, let's run  <kbd>./gradlew clean deploy</kbd>. After doing this, we should find that we have a successful build.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StepVerifier</h1>
                </header>
            
            <article>
                
<p>Before now, we have tested final outcomes for each Reactive Stream as the complete pipeline was created in the test case. This approach is not a good unit test as it does not validate the components in isolation. In Reactor, pipelines are declared in code. These pipelines are then lazily instantiated and verified. Since a complete pipeline is instantiated, it is quite difficult to unit test components in isolation. For unit testing, we must have the ability to stub the components of a pipeline, leaving behind the component being tested. But in this case, how can we validate an existing pipeline for the sequence of operations? Reactor provides the <kbd>StepVerifier</kbd> component to validate the required operations in isolation. This API not only defines stubs, but also provides assertions to validate each step. In this section, we will work with various examples of validating different Reactor scenarios. Let's start with the simplest use case where, given a publisher, we may want to assert the <kbd>next</kbd> and <kbd>completion</kbd> events published by it:</p>
<pre>    @Test<br/>    public void testExpectation() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            System.out.println("generating next of " + state.getT1());<br/><br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        StepVerifier.create(fibonacciGenerator.take(10))<br/>                .expectNext(0L, 1L, 1L)<br/>                .expectNextCount(7)<br/>                .expectComplete()<br/>                .verify();<br/>    }</pre>
<p>In the preceding code, we are validating Fibonacci series operations as follows:</p>
<ul>
<li>We have configured the <kbd>take</kbd> operator to consume only 10 events.</li>
<li>Next, we used the <kbd>StepVerifier.Create</kbd> API to build an instance of a verfier.</li>
<li>The <kbd>expectNext</kbd> API is used to validate published values in the published order. This takes a single value or an array of values; we are validating the <kbd>0</kbd>, <kbd>1</kbd>, and <kbd>1</kbd> values.</li>
<li><kbd>expectNextCount</kbd> is used to validate the number of published values. Since we validate three values, we are left with seven more.</li>
<li>The <kbd>expectComplete</kbd> API is used to validate a completion event.</li>
<li>At the end, the <kbd>verify</kbd> API is used to validate the behavior.</li>
</ul>
<p>Now, let's run the test case. When doing this, we should see a green bar:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4974ddc7-cb65-41a3-8ecb-2c7105cedbaa.png" style=""/></div>
<p>If <kbd>expectNext</kbd> does not match the published values, the test fails with <kbd>java.lang.AssertionError</kbd> and detailed error text. If the published count differs, then it does not fail with <kbd>expectNextCount</kbd>, but <kbd>expectComplete</kbd>. In all assertion failures,  <kbd>StepVerifier</kbd> throws a <kbd>java.lang.AssertionError</kbd> with the following detailed message:</p>
<pre>java.lang.AssertionError: expectation "expectComplete" failed (expected: onComplete(); actual: onNext(34))<br/>     at reactor.test.DefaultStepVerifierBuilder.failPrefix(DefaultStepVerifierBuilder.java:2235)<br/>     at reactor.test.DefaultStepVerifierBuilder.fail(DefaultStepVerifierBuilder.java:2231)<br/>     at reactor.test.DefaultStepVerifierBuilder.lambda$expectComplete$4(DefaultStepVerifierBuilder.java:245)</pre>
<p>In the following sections, we will discuss the most commonly used methods available in <kbd>StepVerfier</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">expectError</h1>
                </header>
            
            <article>
                
<p>As discussed throughout this book, a Reactive Stream terminates with a completion or error event. Similarly to <kbd>expectComplete</kbd>, for a completion event, there is the <kbd>expectError</kbd> API to validate error events. The <kbd>expectError</kbd> API offers the following convenient methods to validate an error message or the exception class:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"><strong>Error name</strong></td>
<td style="height: 12.5166px;width: 65.1624%"><strong>Description</strong></td>
</tr>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"> <kbd>expectError()</kbd></td>
<td style="height: 12.5166px;width: 65.1624%">The API only validates the occurrence of an error event. It does not validate any details about the error.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>expectError(exceptionClass)</kbd></td>
<td style="height: 10px;width: 65.1624%">The API validates the underlying exception class wrapped in the error event.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>expectErrorMessage(errorMessage)</kbd></td>
<td style="height: 10px;width: 65.1624%">The API validates the underlying exception message wrapped in the error event.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>expectError(Predicate)</kbd></td>
<td style="height: 32px;width: 65.1624%">The API validates the underlying exception using the configured predicate.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In all preceding cases, <kbd>StepVerifier</kbd> asserts the exception wrapped in the error event. If the error does not match, an <kbd>assertionError</kbd> is thrown by <kbd>StepVerifier</kbd>. <kbd>StepVerifier</kbd> also provides an <kbd>expectErrorSatisfies</kbd> API, which can be used to configure customs assertions. This API takes a <kbd>Consumer</kbd> to assert an exception underlying the error event:</p>
<pre> @Test<br/>    public void testErrorExpectation() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &gt; 30)<br/>                sink.error(new IllegalStateException("Value out of bound"));<br/><br/>         // Removed for brevity<br/>        });<br/>        StepVerifier.create(fibonacciGenerator.take(10))<br/>                .expectNextCount(9)<br/>                .expectErroSatisfies(x -&gt; {<br/>                    assert(x instanceof IllegalStateException);<br/>                })<br/>                .verify();<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code, we are throwing an exception when the value goes above <kbd>30</kbd>. <kbd>expectErrorSatisfies</kbd> asserts that the exception thrown is an <kbd>IllegalStateException </kbd><span>type</span><span>. Let's execute the preceding test case to get a green bar for a successful test case. This is shown with the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65704bfa-2b8f-48f9-b5ee-0c563835ff9f.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">expectNext</h1>
                </header>
            
            <article>
                
<p>Reactor provides multiple methods to assert next values. In the preceding code, we matched values using the <kbd>expectNext()</kbd> overloaded operator. This operator is offered in the following variants:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"><strong>Operator</strong>
<table border="1" style="border-collapse: collapse;width: 100%"/>
</td>
<td style="height: 12.5166px;width: 65.1624%"><strong>Description</strong></td>
</tr>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"> <kbd>expectNext(value1,value2.. value6)</kbd></td>
<td style="height: 12.5166px;width: 65.1624%">This method verifies the published values <span><span>against </span></span>the supplied values. The values must be matched in the order specified.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>expectNext(value[])</kbd></td>
<td style="height: 10px;width: 65.1624%">This method verifies the published values against the supplied value array. All values must be matched in the order specified.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>expectNextSequence(Iterator)</kbd></td>
<td style="height: 10px;width: 65.1624%">This method verifies the published values against values from the configured iterator. All values must be matched in the order specified.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>expectNextCount(count)</kbd></td>
<td style="height: 32px;width: 65.1624%">This method matches the number of values published. </td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>expectNextMatches(predicate)</kbd></td>
<td style="height: 32px;width: 65.1624%">This method validates whether or not the next values satisfy the configured predicate.</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>All of the preceding methods validate the next published value against a matching expectation. This is good for small datasets, but when we are publishing large ranges such as the Fibonacci series, we cannot match all values. Sometimes, we are just interested in consuming all (or some) next values. This can be accomplished by using the <kbd>thenConsumeWhile</kbd> API. The methods take a predicate and then consume all sequenced values matching the predicate. Once the first value mismatches, the test case tries to validate the following configured expectation:</p>
<pre>    @Test<br/>    public void testConsumeWith() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            System.out.println("generating next of " + state.getT2());<br/><br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/><br/>        StepVerifier.create(fibonacciGenerator)<br/>                .thenConsumeWhile(x -&gt; x &gt;= 0)<br/>                .expectComplete()<br/>               .verify();<br/>    }</pre>
<p>In the preceding test case, the following has occurred:</p>
<ul>
<li><kbd>thenConsumeWhile</kbd> has been configured with the <kbd>x &gt;= 0 </kbd>predicate. This should match all values except the first negative value.</li>
<li>Next, we expect a complete event and then verify it using the <kbd>verify</kbd> API. This is shown in the following screenshot:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/28fb0557-cd81-4d16-912e-cda50dafe8e7.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We have looked at the <kbd>expect</kbd> methods to validate events generated in a Reactive Stream. If the expectation does not match, <kbd>StepVerifier</kbd> builds a generic message to indicate the failure. <kbd>StepVerifier</kbd> also provides support to build failure-specific and descriptive  messages. <kbd>StepVerifier</kbd> provides the <kbd>as</kbd> method, which can be invoked after the <kbd>expect</kbd> method. The <kbd>as</kbd> method takes a string, which is displayed when the exception does not match:</p>
<pre>   @Test<br/>    public void testExpectationWithDescp() throws Exception {<br/>        // removed for brevity<br/>        StepVerifier.create(fibonacciGenerator.take(9))<br/>                .expectNext(0L, 1L, 1L).as("Received 0,1,1 numbers")<br/>                .expectNextCount(7).as("Received 9 numbers")<br/>                .expectComplete()<br/>                .verify();<br/>    }</pre>
<p>In this code, we have provided descriptive messages for each expectation.  If the expectation does not match, the test fails with a specific error message, as shown in the following trace. This helps in debugging test failures:</p>
<pre>java.lang.AssertionError: expectation "Received 9 numbers" failed (expected: count = 7; actual: counted = 6; signal: onComplete())<br/><br/>    at reactor.test.DefaultStepVerifierBuilder.failPrefix(DefaultStepVerifierBuilder.java:2235)<br/>    at reactor.test.DefaultStepVerifierBuilder.fail(DefaultStepVerifierBuilder.java:2231)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Capture values</h1>
                </header>
            
            <article>
                
<p>There are times when we are unable to assert values directly. In such test scenarios, we usually capture the invoked values and then assert them separately. Reactor provides a <kbd>recordWith</kbd> API to capture values generated by the publisher under test. This method takes a <kbd>Supplier</kbd> function, which is invoked in order to instantiate a Collection for storing values. The recorder collection can then be asserted using the <kbd>expectRecordedMatches</kbd> method:</p>
<pre>@Test<br/>    public void testRecordWith() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>          //   Removed for Brevity<br/>     });<br/>        StepVerifier.create(fibonacciGenerator, Long.MAX_VALUE)<br/>                .recordWith(() -&gt; new ArrayList&lt;&gt;())<br/>                .thenConsumeWhile(x -&gt; x &gt;= 0)<br/>                .expectRecordedMatches(x -&gt; x.size() &gt; 0)<br/>                .expectComplete()<br/>                .verify();<br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>Configured <kbd>recordWith</kbd> to use an <kbd>ArrayList</kbd> for recording all values.</li>
<li>Configured <kbd>thenConsumeWhile</kbd> with the predicate <kbd>x &gt;= 0</kbd>. This should match all values except the first negative value. All matching values are added to the record collection.</li>
<li>Next, we configured <kbd>expectRecordedMatches</kbd> to assert the record collection to have values.</li>
<li>Finally, we expect a completion event and then verify it using the <kbd>verify</kbd> API as follows:</li>
</ol>
<p>When running the preceding test case, we should get a green bar for passing tests. This is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c428c11-7f97-46c9-b734-c8e7ac7d3328.png" style=""/></div>
<p>As well as the <kbd>expectRecordWith</kbd> method, Reactor also provides a <kbd>consumeRecordWith</kbd> API, which can be invoked for custom assertions. The  <kbd>consumeRecordWith</kbd> method takes a Consumer function for the recorded collection. It is important to note that a recorded session can only be matched with the next <kbd>consumeRecordWith</kbd> or <kbd>expectRecordWith</kbd> invocation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Verify</h1>
                </header>
            
            <article>
                
<p>As discussed previously, the <kbd>verify</kbd> operator is used to assert the configured behavior. The termination event for a publisher must be validated before the <kbd>verify</kbd> call. Alternatively, Reactor provides convenient verify methods to validate the termination event and assert the complete configured chain. Similar to <kbd>expectError</kbd>, the API is offered in the following methods:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"><strong>Method name</strong></td>
<td style="height: 12.5166px;width: 65.1624%"><strong>Description</strong></td>
</tr>
<tr style="height: 12.5166px">
<td style="height: 12.5166px;width: 32.8376%"> <kbd>verifyComplete()</kbd></td>
<td style="height: 12.5166px;width: 65.1624%">This method only validates the occurrence of a completion event.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>verifyError()</kbd></td>
<td style="height: 10px;width: 65.1624%">This method only validates the occurrence of an error event.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 32.8376%"><kbd>verifyError(exceptionClass)</kbd></td>
<td style="height: 10px;width: 65.1624%">This method  validates an error event and matches an underlying exception class wrapped in the error event.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>verifyError(exceptionMsg)</kbd></td>
<td style="height: 32px;width: 65.1624%">This method validates an error event and matches an underlying exception message wrapped in the error event.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>verifyError(predicate)</kbd></td>
<td style="height: 32px;width: 65.1624%">This method validates an error event and matches it against the supplied predicate.</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 32.8376%"><kbd>verfiyErrorSatisfies(assertConsumer)</kbd></td>
<td style="height: 32px;width: 65.1624%">This method validates an error event and matches the underlying exception for supplied custom assertions.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">In the preceding test, we can replace <kbd>expectComplete</kbd> and verify invocations with the following snippet:</p>
<pre>StepVerifier.create(fibonacciGenerator.take(10))<br/>        .expectNext(0L, 1L, 1L)<br/>        .expectNextCount(7)<br/>        .verifyComplete();</pre>
<p>We will leave the test execution to the reader. Again, a passed test should show a green bar. It is important to note that <kbd>verify</kbd> (and related methods) return <kbd>Duration</kbd>. The duration specifies the actual time the test took to execute. This also brings us to discussing the blocking behavior of verify methods. By default, the invocation of verify methods is synchronous and blocking. It can make the test wait infinitely. The behavior can be changed by specifying a <kbd>Duration</kbd> in the <kbd>verify</kbd> method call. Alternatively, we can set a default timeout by using the <kbd>StepVerifier.setDefaultTimeout</kbd> method:</p>
<pre>@Test<br/>    public void testWithTimeout() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>            // removed for brevity<br/>        });<br/>        StepVerifier.create(fibonacciGenerator.take(9).delaySequence(Duration.ofSeconds(1)))<br/>                .expectNext(0L, 1L, 1L)<br/>                .expectNextCount(7)<br/>                .expectComplete()<br/>                .verify(Duration.ofMillis(100));<br/>    }</pre>
<p>In this code, we have made the following changes:</p>
<ul>
<li>Delayed event generation for 1 second by using the <kbd>delaySequence</kbd> operator.</li>
<li>Removed the <kbd>verifyComplete</kbd> call, as we cannot specify a duration. Instead, we added the <kbd>expectComplete</kbd> method call.</li>
<li>Lastly, we used the verify call with a timeout duration. The timeout is set to 100 milliseconds.</li>
</ul>
<p>This test case  times out and fails with the following exception:</p>
<pre>java.lang.AssertionError: VerifySubscriber timed out on reactor.core.publisher.SerializedSubscriber@1a57272<br/><br/>    at reactor.test.DefaultStepVerifierBuilder$DefaultVerifySubscriber.pollTaskEventOrComplete(DefaultStepVerifierBuilder.java:1522)<br/>    at reactor.test.DefaultStepVerifierBuilder$DefaultVerifySubscriber.verify(DefaultStepVerifierBuilder.java:1107)<br/>    at reactor.test.DefaultStepVerifierBuilder$DefaultStepVerifier.verify(DefaultStepVerifierBuilder.java:729)<br/>    at ReactorTest.testWithTimeout(ReactorTest.java:58)<br/>   </pre>
<p>In the previous sections, we looked at methods that enable us to validate most of the operators for a Reactive Stream. We will cover some specific Reactor scenarios <span>next</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating backpressure</h1>
                </header>
            
            <article>
                
<p>As discussed previously in <a href="a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml" target="_blank">Chapter 7</a>, <em>Flow Control and Backpressure</em>, backpressure allows a subscriber to control event flow. This mechanism is aimed at controlling a fast generating producer. There are different configurations for backpressure. These configurations have already been discussed in <a href="a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml" target="_blank">Chapter 7</a>, <em><span>Flow Control and Backpressure</span></em>, and we will not cover them here. Fundamentally, backpressure skips delivering values to the Subscriber. Consequently, validating it means that we must look for values that have not been delivered to the Subscriber. Reactor provides the <kbd>verifyThenAssertThat</kbd> API  for the same reason. This method exposes assertions that can validate the end state of a publisher. Let's now work with a test case:</p>
<pre>    @Test<br/>    public void testBackPressure() throws Exception {<br/>        Flux&lt;Integer&gt; numberGenerator = Flux.create(x -&gt; {<br/>            System.out.println("Requested Events :" + x.requestedFromDownstream());<br/>            int number = 1;<br/>            while (number &lt; 100) {<br/>                x.next(number);<br/>                number++;<br/>            }<br/>            x.complete();<br/>        }, FluxSink.OverflowStrategy.ERROR);<br/><br/>        StepVerifier.create(numberGenerator, 1L)<br/>                .thenConsumeWhile(x -&gt; x &gt;= 0)<br/>                .expectError()<br/>                .verifyThenAssertThat()<br/>                .hasDroppedElements();<br/>    }</pre>
<p>In the preceding code, the following occurred:</p>
<ol>
<li>We configured a Publisher with <kbd>OverflowStrategy.ERROR</kbd> using the <kbd>Flux.create</kbd> API. Our Publisher generates 100 events without looking for more requests from the Subscriber.</li>
<li>Next, our <kbd>StepVerifier</kbd> is configured for only one event, limiting the request rate from the Subscriber. This is achieved using the <kbd>StepVerifier.create</kbd> API.</li>
<li>Since the subscriber is asking for one event and the Publisher is raising 100 events, this should lead to a backpressure error. In the test case, we configured <kbd>expectError()</kbd> to validate the error raised.</li>
<li>Lastly, we configured <kbd>verfiyThenAssertThat()</kbd> to check for dropped elements.</li>
</ol>
<p>The preceding test case validates the complete scenario of backpressure, which is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cf16a934-7ab9-4ad2-85f1-af867e9cbb27.png" style=""/></div>
<p>In the preceding test case, we have validated whether or not elements have been dropped. Reactor also provides the following assertions to validate various other scenarios:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><strong>Method name</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 75.1305%"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><kbd>hasDroppedElements</kbd></td>
<td style="width: 75.1305%">This method verifies whether or not elements have been dropped by a Publisher due to overflow.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><kbd>hasNotDroppedElements</kbd></td>
<td style="width: 75.1305%">This method verifies whether or not any elements have been dropped by a Publisher due to overflow.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><kbd>hasDroppedExactly</kbd></td>
<td style="width: 75.1305%">This method validates the dropped values against the ones supplied in the method invocation.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><kbd>hasDroppedErrors</kbd></td>
<td style="width: 75.1305%">This method verifies whether or not errors have been dropped by a Publisher.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.9875%"><kbd>hasOperatorErrors</kbd></td>
<td style="width: 75.1305%">This method verifies whether or not operator errors have been raised by stream processing.</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating time operations</h1>
                </header>
            
            <article>
                
<p class="mce-root">Validating time-based operations is a complex task. Traditionally, we used <kbd>Thread.sleep</kbd>  or <kbd>wait-notify</kbd> blocks to simulate the delay in the test case. Reactor also provides rich support to validate such operations. This allows us to build a virtual clock by using the <kbd>Stepverifier.withVirtualTime</kbd> method for Reactive Streams. The virtual clock can then be manipulated using any of the following operations to simulate time drift for the required operation:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.5325%"><strong>Operations</strong></td>
<td style="width: 77.5855%"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.5325%"><kbd>thenAwait</kbd></td>
<td style="width: 77.5855%">This only pauses the execution for the configured time.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 21.5325%"><kbd>expectNoEvent</kbd></td>
<td style="width: 77.5855%">This pauses the execution and validates that no event has happened during the configured delay.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">It is important to note that operators must be invoked after injecting the virtual clock. Also, the <kbd>expectNoEvent</kbd> API  recognizes subscription as an event. If it is used as the first step after injecting the virtual clock, then it will fail due to the Subscription event.  Let's now work with the following test case:</p>
<pre>    @Test<br/>     public void testDelay() {<br/>         StepVerifier.withVirtualTime(() -&gt; Flux.just(1, 2, 3, 4, 5, 6, 7, 8, 9)<br/>                 .delaySequence(Duration.ofMillis(100)))<br/>                 .expectSubscription()<br/>                 .thenAwait(Duration.ofSeconds(100))<br/>                 .expectNextCount(9)<br/>                 .verifyComplete();<br/>     }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code, we achieved the following:</p>
<ol>
<li>Created a Flux with the virtual clock using <kbd>StepVerifier.withVirtualTime</kbd></li>
<li>Configured a <kbd>delaySequence</kbd> operation on the Reactive Stream</li>
<li>Invoked <kbd>thenAwait</kbd> to hold the virtual clock for the configured time</li>
<li>Expected nine values to be published, followed by a completion event</li>
</ol>
<p>Let's now run the test case and verify it as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/edb91374-ab59-405c-a7a4-e7ba4139100c.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher probe</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we used <kbd>StepVerifier</kbd> to assert the steps executed in a reactive chain. However, <span>these are </span><span>often</span><span> </span><span>simple chains that can be validated end-to-end in a single test case. There may be scenarios where we need to inject a Publisher into a service or a method and verify the published signals. In such cases, we can instrument an existing Publisher using the</span> <kbd>PublisherProbe</kbd> <span>utility. The probe keeps track of signals published by the Publisher. In the end, we can assert and verify the final state of the probe. The utility helps to unit test a service or  method executing some specific logic on a Reactive Publisher.</span></p>
<p>A <kbd>PublisherProbe</kbd> can be constructed using either of the following methods:</p>
<ul>
<li><kbd>PublisherProbe.Of(ExisitingPublisher)</kbd>: Instruments an existing Publisher and generates a probe from it. The probe sends out signals as generated by the original Publisher.</li>
<li><kbd>PublisherProbe.empty()</kbd>: Creates an empty sequence probe. This probe does not emit any signals.</li>
</ul>
<p>We can get back a Mono or Flux from the <kbd>PublisherProbe</kbd> by invoking respective methods. The Flux/Mono can then be passed to the method/service under test. After the invocation, the final state can be verified using the following assertions:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 25.8324%"><strong>Method name</strong></td>
<td style="width: 73.2856%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 25.8324%"><kbd>assertWasSubscribed</kbd></td>
<td style="width: 73.2856%">This method validates that the Publisher was subscribed to in the invocation.</td>
</tr>
<tr>
<td style="width: 25.8324%"><kbd>assertWasRequested</kbd></td>
<td style="width: 73.2856%">This method validates that the Publisher was requested in the invocation.</td>
</tr>
<tr>
<td style="width: 25.8324%"><kbd>assertWasCancelled</kbd></td>
<td style="width: 73.2856%">
<p class="mce-root">This method validates that the Publisher was cancelled in the invocation.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following code depicts this:</p>
<pre><br/>    @Test<br/>    public void testPublisherProbe() throws Exception {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>            if (state.getT1() &lt; 0)<br/>                sink.complete();<br/>            else<br/>                sink.next(state.getT1());<br/>            return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/><br/>        PublisherProbe&lt;Long&gt; publisherProbe = PublisherProbe.of(fibonacciGenerator);<br/>        publisherProbe.flux().subscribe();<br/><br/>        publisherProbe.assertWasSubscribed();<br/>        publisherProbe.assertWasRequested();<br/><br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>Created a <kbd>PublisherProbe</kbd> using <kbd>fibonacciGenerator</kbd></li>
<li>Next we subscribed to the Flux generated by the probe</li>
<li>In the end we validate that the Flux was subscribed, flowed by the request event</li>
</ol>
<p class="mce-root"/>
<p>Let's run the test case and verify it as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cfda1f2c-2f9e-48a1-9748-6e1ca8d58860.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publisher stubs</h1>
                </header>
            
            <article>
                
<p>So far, we have been creating a <kbd>Publisher</kbd> along with the operators. As a result, we could build  end-to-end validations. However, in most business services, a <kbd>Publisher</kbd> will be created in some part of the code and operations will be performed in another. In order to unit test the operation service code, we would need to generate a dummy <kbd>Publisher</kbd>. Reactor also provides <kbd>TestPublisher</kbd> for this purpose. We can create a <kbd>TestPublisher</kbd> using the <kbd>create factory</kbd> method. The generated <kbd>TestPublisher</kbd> can be converted into a Flux or a Mono. <kbd>TestPublisher</kbd> makes it possible to emit  events using any of the following methods:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.5667%"><strong>Method name</strong></td>
<td style="width: 75.5513%"><strong>Description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.5667%"><kbd> next(T) / next(T,T...)</kbd></td>
<td style="width: 75.5513%">Invokes Publisher <kbd>OnNext</kbd> with the supplied values.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.5667%"><kbd> complete()</kbd></td>
<td style="width: 75.5513%">Terminates the Publisher stream with the <kbd>OnComplete</kbd> event.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.5667%"><kbd>error()</kbd></td>
<td style="width: 75.5513%">Terminates the Publisher stream with the <kbd>OnError</kbd> event.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 23.5667%"><kbd>emit(T,T,T .....)</kbd></td>
<td style="width: 75.5513%">Invokes Publisher <kbd>OnNext</kbd> with the supplied values, followed by <kbd>OnComplete</kbd> termination.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Let's work with sample code. We have the following <kbd>PrintService</kbd>, which prints even numbers to the console as follows:</p>
<pre>class PrintService{<br/>    public void printEventNumbers(Flux&lt;Long&gt; source, PrintWriter writer) {<br/>        source<br/>                .filter(x -&gt; x % 2 == 0)<br/>                .subscribe(writer::println);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Now, let's build a simple test case. In the test case, we will inject a few values and a <kbd>StringWriter</kbd>. At the end, we will validate whether or not <kbd>StringWriter</kbd> contains all the required values, as follows:</p>
<pre> @Test<br/> public void testPublisherStub() throws Exception {<br/>   TestPublisher&lt;Long&gt; numberGenerator= TestPublisher.&lt;Long&gt;create();<br/>   StringWriter out = new StringWriter();<br/>   new PrintService().printEventNumbers(numberGenerator.flux(),<br/>    new PrintWriter(out));<br/>   numberGenerator.next(1L,2L,3L,4L);<br/>   numberGenerator.complete();<br/>   assertTrue(out.getBuffer().length() &gt;0);<br/> }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>Generated a <kbd>TestPublisher</kbd> using the <kbd>create</kbd> method</li>
<li>Instantiated a <kbd>StringWriter</kbd> to capture printed values</li>
<li>Next, we generated <kbd>onNext</kbd> using some values</li>
<li>Finally, we generated <kbd>onComplete</kbd> and validated the printed values</li>
</ol>
<p>Now, run the test case. This should show a green bar for a test that has passed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0244c6dc-0de7-4753-ba1b-41964609c36d.png" style=""/></div>
<p><kbd>TestPublisher</kbd> also keeps track of the final state of the <kbd>Publisher</kbd> stub. The final state can be verified using the following assertions:</p>
<table border="1" style="border-collapse: collapse">
<tbody>
<tr>
<td><kbd>assertSubscribers</kbd></td>
<td>This method validates that the Publisher was subscribed to by the number of subscribers supplied in the invocation.</td>
</tr>
<tr>
<td><kbd>assertCancelled</kbd></td>
<td>This method validates that the Publisher was canceled multiple times, as specified by the number supplied in the invocation.</td>
</tr>
<tr>
<td><kbd>assertRequestOverflow</kbd></td>
<td>This method validates that the Publisher raised Overflow conditions by generating more events than asked for by the subscriber.<br/>
<p class="mce-root"/>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">In the preceding test case, we built a well-behaved <kbd>Publisher</kbd> stub. This did not send null events or raise more events than requested. The <kbd>TestPublisher</kbd> utility also enables us to instantiate Publisher, which violates the preceding conditions. Such a Publisher can be used to validate service/operator behaviors. An inconsistent Publisher can be generated using the <kbd>createNonCompliant</kbd> method. This method uses a violation type and generates configured errors:</p>
<pre>    @Test<br/>    public void testNonComplientPublisherStub() throws Exception {<br/>        TestPublisher&lt;Long&gt; numberGenerator= TestPublisher.createNoncompliant(TestPublisher.Violation.REQUEST_OVERFLOW);<br/>        StepVerifier.create(numberGenerator, 1L)<br/>                .then(() -&gt; numberGenerator.emit(1L,2L,3L,4L))<br/>                .expectNext(1L)<br/>                .verifyError();<br/><br/>    }</pre>
<p>In the preceding code, we have done the following:</p>
<ol>
<li>Generated a <kbd>TestPublisher</kbd> using the <kbd>createNonCompliant</kbd> method. Publisher has been configured to produce more than the requested events.</li>
<li>Subscribed to the publisher with an initial demand of one element.</li>
<li>Validated the produced element followed by an error termination.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging Reactor streams</h1>
                </header>
            
            <article>
                
<p>Debugging Rector streams is not straightforward. This is due to the fact that all stream processing in Reactor is asynchronous and non-blocking. In a synchronous and blocking system, an error stacktrace points to the root cause of the issue. However, in an asynchronous reactor stream, the error is logged in the <kbd>Subscriber</kbd> but has been raised in an operator in stream processing. The error stacktrace does not mention the operator. Let's take a look at the following Reactor stacktrace:</p>
<pre>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IllegalStateException<br/><br/>Caused by: java.lang.IllegalStateException<br/>    at ReactorDebug.lambda$testPublisherStub$1(ReactorDebug.java:22)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:202)<br/>    at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.request(FluxFilterFuseable.java:170)<br/>    at reactor.core.publisher.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:89)<br/>    at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onSubscribe(FluxFilterFuseable.java:79)<br/>    at reactor.core.publisher.FluxGenerate.subscribe(FluxGenerate.java:83)<br/>    at reactor.core.publisher.FluxFilterFuseable.subscribe(FluxFilterFuseable.java:51)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6877)<br/>    at reactor.core.publisher.Flux.subscribeWith(Flux.java:7044)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6870)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6834)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6777)<br/>    at PrintService.printEventNumbers(ReactorProbe.java:57)<br/>    at ReactorDebug.testPublisherStub(ReactorDebug.java:28)<br/>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br/>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/>    at java.lang.reflect.Method.invoke(Method.java:498)<br/>    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)<br/>    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)<br/>    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding stacktrace, we can observe the following:</p>
<ul>
<li><kbd>IllegalStateException</kbd>  has reached our subscriber</li>
<li>Reactor also raises an <kbd>ErrorCallbackNotImpletemented</kbd>, since the Subscriber does not handle the error event</li>
<li>The error is captured while performing <kbd>PrintService.printEventNumbers</kbd></li>
<li>The preceding error is raised in our <kbd>ReactorDebug.testPublisherStub</kbd> test case</li>
</ul>
<p>This does not help much, but we can clean up the stack trace by first implementing an error handler. The simplest approach here is to use the <kbd>printstackTrace</kbd> method of throwable:</p>
<pre>class PrintService{<br/>    public void printEventNumbers(Flux&lt;Long&gt; source, PrintWriter writer) {<br/>        source<br/>                .filter(x -&gt; x % 2 == 0)<br/>                .subscribe(writer::println,Throwable::printStackTrace);<br/>    }<br/>}</pre>
<p>The preceding change to the <kbd>subscribe</kbd> method sanitizes the stacktrace of the error raised. However, the error operator is still not explained in the trace, as shown in the following code:</p>
<pre>java.lang.IllegalStateException<br/>    at ReactorDebug.lambda$testPublisherStub$1(ReactorDebug.java:22)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:202)<br/>    at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.request(FluxFilterFuseable.java:170)<br/>    at reactor.core.publisher.LambdaSubscriber.onSubscribe(LambdaSubscriber.java:89)<br/>    at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onSubscribe(FluxFilterFuseable.java:79)<br/>    at reactor.core.publisher.FluxGenerate.subscribe(FluxGenerate.java:83)<br/>    at reactor.core.publisher.FluxFilterFuseable.subscribe(FluxFilterFuseable.java:51)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6877)<br/>    at reactor.core.publisher.Flux.subscribeWith(Flux.java:7044)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6870)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6834)<br/>    at reactor.core.publisher.Flux.subscribe(Flux.java:6804)<br/>    at PrintService.printEventNumbers(ReactorProbe.java:57)<br/>    at ReactorDebug.testPublisherStub(ReactorDebug.java:28)<br/>   ........<br/>   ......<br/>    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)<br/>    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br/>    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debug hook</h1>
                </header>
            
            <article>
                
<p>Reactor provides assembly-time instrumentation capability to debug a stacktrace. This capability enables us to intercept all invocations of Flux/Mono operations. Each interception then keeps a record of the error thrown with the operation invoked. The resultant mapping is then appended to the stacktrace. This record can then be used to find the root cause of the issue. Since this is an additional interception, which keeps a record mapping, it should only be invoked to debug errors and must not be enabled in production systems.  Reactor provides a <kbd>Hooks.OnOperatorDebug</kbd> API, which must be invoked before instantiating the Flux/Mono. Let's invoke <kbd>Hooks.OnOperatorDebug</kbd> in our test case, as follows:</p>
<pre>      @Test<br/>    public void testPublisherStub() throws Exception {<br/>        Hooks.onOperatorDebug();<br/>        Flux&lt;Long&gt; fibonacciGenerator = getFibonacciGenerator();<br/>        StringWriter out = new StringWriter();<br/>        new PrintService().printEventNumbers(fibonacciGenerator,new PrintWriter(out));<br/>        assertTrue(out.getBuffer().length() &gt;0);<br/>    }<br/>class PrintService {<br/>    public void printEventNumbers(Flux&lt;Long&gt; source, PrintWriter writer) {<br/>        source<br/>                .filter(x -&gt; x % 2 == 0)<br/>                .subscribe(writer::println,Throwable::printStackTrace);<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Let's run our test case and look at the generated stacktrace, which is as follows:</p>
<pre>java.lang.IllegalStateException<br/>    at ReactorDebug.lambda$getFibonacciGenerator$1(ReactorDebug.java:30)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:202)<br/>  ...........<br/>    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br/>    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <br/>Assembly trace from producer [reactor.core.publisher.FluxGenerate] :<br/>    reactor.core.publisher.Flux.generate(Flux.java:947)<br/>    ReactorDebug.getFibonacciGenerator(ReactorDebug.java:27)<br/>    ReactorDebug.testPublisherStub(ReactorDebug.java:19)<br/>Error has been observed by the following operator(s):<br/>    |_  Flux.generate(ReactorDebug.java:27)<br/>    |_  Flux.filter(ReactorProbe.java:58)</pre>
<p>Now, if we look at the bottom of the trace, it clearly states that an error has been thrown in the <kbd>Flux.generate</kbd> invocation. To solve this, we can fix this bug and rerun our test case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checkpoint operator</h1>
                </header>
            
            <article>
                
<p>The Debug hook discussed in the previous section has a global impact, instrumenting all Flux/Mono instances. Consequently, the impact of the debug hook is application-wide. Alternatively, Reactor also provides a <kbd>checkpoint</kbd> operator, which can only <span>alter </span>a particular Flux stream. The <kbd>checkpoint</kbd> operator instruments a Reactor Streams after the operator invocation. We can alter our previous test case as follows:</p>
<pre>@Test<br/>public void testPublisherStub() throws Exception {<br/>  Flux&lt;Long&gt; fibonacciGenerator = <br/>    getFibonacciGenerator().checkpoint();<br/>    StringWriter out = new StringWriter();<br/>  new PrintService().printEventNumbers(fibonacciGenerator,<br/>   new PrintWriter(out));<br/>  assertTrue(out.getBuffer().length() &gt;0);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code, we have invoked the <kbd>checkpoint()</kbd> operator after creating the Flux. The modified test case generates the following stacktrace. Since the <kbd>checkpoint</kbd> operator is invoked after <kbd>Flux.generate</kbd>, the record mapping refers to <kbd>FluxGenerate</kbd> as the point of error. This is shown with the following code:</p>
<pre>java.lang.IllegalStateException<br/>    at ReactorDebug.lambda$getFibonacciGenerator$1(ReactorDebug.java:29)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:202)   <br/>...........<br/>    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br/>    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br/>    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <br/>Assembly trace from producer [reactor.core.publisher.FluxGenerate] :<br/>    reactor.core.publisher.Flux.checkpoint(Flux.java:2690)<br/>    reactor.core.publisher.Flux.checkpoint(Flux.java:2640)<br/>    ReactorDebug.testPublisherStub(ReactorDebug.java:18)<br/>Error has been observed by the following operator(s):<br/>    |_  Flux.checkpoint(ReactorDebug.java:18)</pre>
<p>The <kbd>checkpoint</kbd> and the <kbd>debug</kbd> operators discussed previously have an impact on the memory footprint of the application.  Both these operators try to save stacktraces, which leads to higher memory consumption. Due to this, these operators cannot be enabled in production applications without paying an additional cost. But the <kbd>checkpoint</kbd> operator also offers a trimmed down version, which does not save any stacktraces. The <kbd>checkpoint</kbd> operator, when configured with a description message, disables stacktrace accumulation. The following stacktrace is generated when using checkpoint with a description in our preceding code:</p>
<pre>java.lang.IllegalStateException<br/>    at ReactorDebug.lambda$getFibonacciGenerator$1(ReactorDebug.java:29)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>   .......<br/>    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)<br/>    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)<br/>    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)<br/>    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)<br/>    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <br/>Assembly site of producer [reactor.core.publisher.FluxGenerate] is identified by light checkpoint [generator check]."description" : "generator check"</pre>
<p>In the preceding stacktrace, Reactor used the description and  prefixed the <kbd>identified by light checkpoint</kbd>  message to it. It no longer tries to build a stacktrace of operator invocations. The <kbd>identified by light checkpoint</kbd> <span>message</span><span> </span><span>can be in searched  in application logs.</span> <span>But if the description message is not good enough, Reactor allows us to enable stacktrace capturing in order to build</span> informative<span> failure traces.  This can be accomplished by using the </span><kbd>checkpoint(description,enableStackTrace)</kbd> <span>operator.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stream logging</h1>
                </header>
            
            <article>
                
<p>Logging is one of the most common ways to know what is happening underneath method invocations. Reactor uses SLF4J for logging, but it does not log stream operations out-of-the-box. Instead, Reactor provides the <kbd>log</kbd> operator, which can be used to selectively enable logging for a particular stream. Let's modify our test case using the log operator as follows:</p>
<pre>@Test<br/>public void testPublisherStub() throws Exception {<br/>  Flux&lt;Long&gt; fibonacciGenerator = getFibonacciGenerator().log();<br/>  StringWriter out = new StringWriter();<br/>  new PrintService().printEventNumbers(fibonacciGenerator,<br/>   new PrintWriter(out));<br/>  assertTrue(out.getBuffer().length() &gt;0);<br/>}</pre>
<p>The <kbd>log()</kbd> operator is offered in many variants. By default, the operator logs at the <kbd>INFO</kbd> level. We can configure this to log at the <kbd>DEBUG</kbd> or other levels as well. Furthermore, we can also place a <kbd>logback.xml</kbd> file to format the logged message, as follows:</p>
<pre>&lt;configuration&gt;<br/>     &lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt;<br/>         &lt;encoder&gt;<br/>             &lt;pattern&gt;<br/>                 %d{HH:mm:ss.SSS} [%thread] [%-5level] %logger{36} - %msg%n<br/>             &lt;/pattern&gt;<br/>         &lt;/encoder&gt;<br/>     &lt;/appender&gt;<br/>    &lt;root level="DEBUG"&gt;<br/>         &lt;appender-ref ref="stdout"/&gt;<br/>     &lt;/root&gt;<br/> &lt;/configuration&gt;</pre>
<p>In the preceding <kbd>logback.xml</kbd> file, we have configured a <kbd>stdout</kbd> appender. The appender will be invoked in a synchronous and blocking manner. Reactor also provides a <kbd>reactor-logback</kbd> library, which can be used to log messages in an asynchronous manner. The preceding test case now generates the following log message:</p>
<pre>23:07:09.139 [main] [DEBUG] reactor.util.Loggers$LoggerFactory - Using Slf4j logging frameworkthe<br/>23:07:09.419 [main] [INFO ] reactor.Flux.Generate.1 - | onSubscribe([Fuseable] FluxGenerate.GenerateSubscription)<br/>23:07:09.450 [main] [INFO ] reactor.Flux.Generate.1 - | request(unbounded)<br/>23:07:09.462 [main] [INFO ] reactor.Flux.Generate.1 - | onNext(0)<br/>23:07:09.463 [main] [INFO ] reactor.Flux.Generate.1 - | onNext(1)<br/>23:07:09.471 [main] [INFO ] reactor.Flux.Generate.1 - | request(1)<br/>........<br/>23:07:09.958 [main] [INFO ] reactor.Flux.Generate.1 - | request(1)<br/>23:07:10.087 [main] [ERROR] reactor.Flux.Generate.1 - | onError(java.lang.IllegalStateException)<br/>23:07:10.126 [main] [ERROR] reactor.Flux.Generate.1 - <br/>java.lang.IllegalStateException: null<br/>    at ReactorDebug.lambda$getFibonacciGenerator$1(ReactorDebug.java:29)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.fastPath(FluxGenerate.java:223)<br/>    at reactor.core.publisher.FluxGenerate$GenerateSubscription.request(FluxGenerate.java:202)<br/>    at ...........</pre>
<p>The preceding logging output clearly shows what events are happening in stream processing. We can interpret the log and build the following analysis:</p>
<ol>
<li>Each log line outputs the operator invoked. Consequently, we can see that the first subscription was raised.</li>
<li>Next, there was an unbounded request, which started generating events.</li>
<li>After that, the Subscriber raised a request for one element.</li>
<li>Finally, there was an <kbd>ERROR</kbd> event invoked in the generate operator due to  <kbd>IllegalStateException</kbd>.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Consequently, we can see that logging is a powerful mechanism for debugging and learning more about application stream processing. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter focused on testing and debugging Reactor Streams. Testing Reactor Flux/Mono streams is complex, as each stream is evaluated lazily in an async manner. We also looked at <kbd>StepVerifier</kbd>, which can validate individual steps in isolation. Next, we looked at a virtual clock to validate time-sensitive operations, such as delays. We also looked at the <kbd>PublisherProbe</kbd> utility used to validate a Publisher's end state. Then, in order to unit test Reactive operators and stream business logic, we performed stubbing using <kbd>TestPublisher</kbd>. The next section was about debugging Reactor Streams to gain further knowledge about under-the-covers processing. Debugging Reactor streams is complex, since the operators are evaluated in an asynchronous manner. We looked at the Debug hook and checkpoint operator to generate an operator mapped error stacktrace. Finally, we looked at the log operator used to generate logs for stream processing.</p>
<p>We have also come to the end of our book. On this journey, we learned about Reactor, an implementation of the Reactive Streams specification. We worked with Flux and Mono Publishers. We built simple applications to find out more about the available operators. We came to the conclusion that Reactor is a library that can be used in any Java application. </p>
<p>On this journey, we also discussed SpringWebFlux, a complete web framework using Rector. We developed simple web services using it and explored the backpressure behavior offered by Reactor. We concluded the journey by looking at various advanced features of Reactor. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which test utility class is available in Reactor to validate the invoked operations on a  stream?</li>
<li>What is the difference between <kbd>PublisherProbe</kbd> and <kbd>TestPublisher</kbd>?</li>
<li>How should the virtual clock be configured to validate time-bound operations?</li>
<li>What is the difference between the <kbd>onOperatorDebug</kbd> hook and the checkpoint operator?</li>
<li>How can we turn on logging for stream processing?</li>
</ol>


            </article>

            
        </section>
    </body></html>