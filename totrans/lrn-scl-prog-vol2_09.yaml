- en: Advanced Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Like punning, programming is a play on words."'
  prefs: []
  type: TYPE_NORMAL
- en: – Alan Peris
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re a developer, right? Think of a scenario where you''re asked to write
    some software that has certain entities. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the `Animal` and `Food` entities. We''re working on an automated system
    that serves food to animals in a zoo. Suppose we''re going to write a function
    which lets two animals share their food. It expects two animal objects, food,
    and then does the job. The function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, everything's fine, right? Let's introduce two animals now. We have two
    animal subclasses named `Lion` and `Deer`. Our simple function takes two `animal`
    instances and shares the `meal` instance among them. Now, you might wonder what
    happens when we pass instances of `Lion` and `Deer`; what might be the consequences?
    Hence, we promote strictly typed programs, which can fail at compile time. This
    means we can write our programs in such a way that the Scala compiler won't allow
    us to write such programs. You're able to see how types can save lives. Great,
    so this is the agenda here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be talking about types and parameterizing our types. We introduced type
    parameterization in the previous chapter, so we''ll take our journey further and
    learn more about type parameterization, abstract types, and a lot more. Let''s
    take a look at what''s coming:'
  prefs: []
  type: TYPE_NORMAL
- en: Genericity/type parameterization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterized types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract versus parameterized types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me tell you, this chapter's going to be another interesting one. We'll be
    using constructs that we've already used to make our code more meaningful. But
    before we dive in to learn about parameterized types in detail, let's talk about
    why there's so much hype about types.
  prefs: []
  type: TYPE_NORMAL
- en: Why so serious about types?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen that knowing what we''re doing can save life. But joking aside,
    if we really think before writing our applications, it can really help. Our programs
    consist of two ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can perform operations on the data available. At the same time, not all operations
    can be performed on all sorts of data. That's what difference types make. You
    don't want to perform an addition operation between an Integer and a String literal.
    That's why the compiler does not allow us to do that. Even if it assumes you're
    trying to concatenate the string with the literal, it's not going to give you
    a result that's not meaningful. That's why defining types make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss a few terms that we just mentioned. It''s really good that Scala
    is a statically typed language because it provides us compile time type safety.
    The code that we write is less prone to runtime errors, because we were so smart
    and we wrote it that way (we''ll learn about this in this chapter). Our beloved
    Scala compiler performs a compile time type check on the program we wrote and
    throws an error at compile time if we try to be too smart. The following diagram
    may clear your doubts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You see? The preceding picture depicts that if your program is working, that''s
    not enough, eventually you may find some corner cases that will cause them to
    fail. So, we better choose a language that helps you cover that section more,
    so that your program lives in a happy world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is essential for us to understand why we're supporting a system where using
    *types* is encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'We began to understand the importance of types in programming, and as we approached
    writing optimized and well structured code, we found something called type genericity.
    We began to write types which can be specified later on. And this gave rise to
    the notion of type constructors. Now, we can write types that take parameters.
    For example, think of a type `constructorList[T]`*.* Here, our known `List[T]`
    expects you to provide a type. You can also think of it as a function on a type,
    you provide a parameter while constructing. In our example, if we choose to provide
    a string, our list will then be called a `List[String]`*,* that''s an applied
    version of `List[T]` with the `String` type. This concept is called **parametric
    polymorphism** where we say that our `List[T]` uses a type parameter `T` to abstract
    over the type of its elements. Let''s try out the stuff we talked about in Scala
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet also failed with an error because we knew that we should
    provide a type parameter but we supplied some element that itself isn''t a type.
    So what should we do now? Let''s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This time it worked for us: we provided a type `String` to our type constructor
    and it worked for us. So I believe we can differentiate between a type constructor
    and a type. Now that you''ve insights into why we''re doing this, let''s dive
    in and learn about parameterized types.'
  prefs: []
  type: TYPE_NORMAL
- en: Here comes type parameterization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of the same scenario. You were asked to write a program that contains
    some different entities, for example, humans and animals. Now, both require food
    to stay alive. Our colleagues are aware of this and have written code that takes
    care of the way food is served to humans as well as animals.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have written the code and provided it as a library (we can access those
    functions by importing the packages they wrote). Our colleagues were ahead of
    time and wrote a function that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We were told the function will work, we just have to provide who to serve the
    food to as the first parameter and an optional food item as a meal. The rest will
    be taken care of by the logic they''ve put. We tried a couple of ways and wrote
    a few applications of this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And somehow, it works as expected. But wait, this is really cool, we were exposed
    to only one function and everything seemed to work as expected. They didn't want
    us to specifically call `serveMealToHumans` or `serveNonVegMealToAnimals` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This really helped us write better code at our end. We were both intelligent
    teams and we separated our concerns. You know, their concern was to take care
    of the ways of serving food to all, our concern was to ensure each of our entities
    are getting food they''re supposed to get. The job''s done. Let''s talk about
    why we chose this example. To understand that, take a look at the function signature
    they wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the `def` keyword, then the name of the function, but after that they
    wrote letters `A` and `B`*,* what are these? To learn more, let''s go ahead and
    read out the whole signature. There''s a parameter that we were supposed to serve,
    the type was named *A,* and the food option was given a type named `B` *(*option
    `B`*).* Well, these are type parameters. The function itself is an example of
    *parametric polymorphism.* We know that it means *having multiple forms.* The
    same goes here. Our function can have multiple parameter types. To better understand,
    take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here in the function calls, we specified the types of our parameters. From the
    signature of our function it is clear that we can give whichever type we want
    and the `serveMeal` function takes care of the rest of the logic. So, the take
    away is that these `A` and `B` parameters are called type parameters. The whole
    concept can be termed type parameterization. We cannot just write generic methods,
    but also generic classes and traits*.* Let's check them out.
  prefs: []
  type: TYPE_NORMAL
- en: Another way around - generic classes and traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just saw the effect of *genericity* and it solved more than one problem,
    we wrote less code and achieved more. The `serveMeal` function was a generic one
    because it takes type parameters, in our case `A` and `B`*.* It performs the intended
    logic, great! Let''s talk about *parameterized types.* You know the type `List`*,*
    right? Let''s take a look at its declaration in the Scala standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Okay, the declaration seems far too complex, doesn't it? No, wait, we know what
    sealed means, we know why we used an abstract class, then the name `List`*,* and
    then a few more declarations for showing inheritance relationships. But there's
    this thing called `[+A]` in our declaration. Our job is to find out what this
    is and why we used it.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous few topics, we gained an idea of this notion of *type constructors.*
    So, let's call this `List[+A]` a type constructor. We know that if we provide
    it a concrete type, List will make a meaningful type. We've tried this before
    so we won't be creating another list of strings. We'll try to learn the significance
    of this + sign in the next few topics. It shows a *variance* relationship. Let's
    look at the previous declaration first.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameter names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, in the declaration of the `List[+T]` type constructor (we can use the
    names parameterized types or type constructors interchangeably), we used the parameter
    name, `T`, it''s a convention to use such names in generic programming. The names *`T`,*
    `A`*,* `B`*,* or `C` have nothing to do with the initializer type you''re going
    to provide when you initiate a list instance. For example, when you give a `String`
    typefor the previously mentioned type parameter when you instantiate `List[String]`,
    it really doesn''t matter if the declaration has `List[T]` or `List[A]`. What
    we mean is the following two declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Container types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen Scala''s class hierarchy, hence we are aware of many collection
    types such as `List`, `Set`, and `Map`. What''s different about these types along
    with types such as `Option` and `Either`*,* is that they all expect you to provide
    a type and then instantiate. We call `List` as a container type because it works
    that way. We use a list to contain elements of a certain data type. Similarly,
    we can think of an `Option` as a binary containerized type, as `Option` can be
    some value or `None`*.* The `Either` type goes the same way. In Scala, when we
    create such container types*,* we tend to use a type parameter to declare and
    provide a concrete type, such as `String`*,* `Int`*,* Boolean*,* and so on when
    we instantiate. Take a look how `Option` is declared in Scala (more on `Option`
    and `Either` types in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a type parameter `A`*.* It''s possible to provide more than one type
    parameter if your type expects more than one type to get instantiated. An example
    of such a type is `Either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown previously, our type `Either` takes two types, `A` and `B`*.* But
    when I tried the following snippet it didn''t work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You see? We created two lists, first of strings and the other list of numbers.
    Then, a function named `listOf` that's a generic function simply to take a list
    and tell the type of list it is. We performed a pattern match to check the type
    of list passed to the function and print it. But it didn't work out for us (and
    might not for anyone). Also, it threw a few warnings telling us there was unreachable
    code for the second case expression. Let's talk about why!
  prefs: []
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the Scala compiler compiles the previous code, it erases the parameterized
    type information from the previous code and so it doesn''t have the necessary
    knowledge at runtime; the list we passed does not take any further information
    about itself. In other words, all type information for generic types is discarded
    by the time the code compiled. This phenomenon is termed **type erasure***.* This
    is the reason our function `listOf` didn''t work as we expected or, let''s say,
    assumed. That''s the same reason you got a warning of unreachable code, because
    our statically typed language was able to know that the second case will never
    be executed, and the first case is a kind of catch all in this pattern match.
    Let''s explain this a bit better. Take a look at a few cases where type erasure
    will be applicable. Imagine you have a trait named `Tfoo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the process of compilation, the generic type gets converted to object
    and becomes like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Variance under inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the ways we can learn about a concept is to ask questions that lead
    you to the concept. So let''s ask a question ourselves. Given that a `Cat` class
    type extends the `Animal`class, is it okay to treat a list of *cats* as a list
    of *animals*? Programmatically, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s possible, the statement that `List[Cat]` is a subtype of `List[Animal]`
    makes sense. Also, the concept is called **covariance**. Hence, we say `List`
    is covariant in its type parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you take a look at the preceding image, the direction of the inheritance
    relationship between two concrete classes, namely `*Cat*` and `Animal`, and their
    parameterized versions, namely `List[Cat]` and `List[Animal]` types, are the same.
    But it's not the case every time. There might be cases where you have a container
    type for which the variance relationship works the opposite way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it this way: given two types `A` and `B`, where `A` is a super
    type of `B`, and some container type `Foo[T]`*,* so the relationship where `Foo[A]`
    is a subtype of `Foo[B]` is called contravariance in `T`, and represented by `Foo[-T]`*.* Here
    the `-` sign represents contravariance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re thinking this is too theoretical, some code examples may make the
    concept clearer. Let''s take a look at a scenario. Nowadays, enterprises like
    to provide all sorts of arrangements for their employees from food and insurance
    to their travel needs. It''s not a big deal if some corporation decides to work
    with an airline company to provide corporate bookings for their employees. Airline
    companies, in order to support such bookings, can support schemes where they book
    seats for corporate passengers, executive passengers, and regular passengers.
    So, imagine in our program that books seats in an aircraft, we represent each
    seat as an aircraft seat. Programmatically, we can represent it as a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a few passengers represented by the `Passenger` class. There are
    a few subtypes of Passenger such as `CorporatePassenger`, `ExecutivePassenger`*,*
    and `RegularPassenger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown, `CorporatePassengers` and `RegularPassengers` inherit from the `Passengers` class,
    so there''s an inheritance relationship between these types. This can be represented
    by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you have a function that reserves seats for the corporate employees,
    its signature may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function expects you to provide an `AircraftSeat[CorporatePassengers]`,
    and does its job. If we try writing the whole of this in a Scala application,
    it''ll look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take a moment, and go through the preceding code. We''ll talk about a
    few points and try to play with annotations and inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AircraftSeat[-T]` is a container type in our case that uses contravariance
    annotation, that is, a `-` sign for its type parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers])`
    function takes `AircraftSeat` of type `CorporatePassengers` or its super type
    such as `Passengers`, because of the contravariance relationship in its type parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function call to `reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers])`
    and `reserveSeatForCorporatePassengers(new AircraftSeat[Passengers])` works because
    of contravariance in the parameterized type, `AircraftSeat`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous code, try changing the type constructor `AircraftSeat[-T]` to
    `AircraftSeat[+T]`. You'll be greeted with a compilation error saying type mismatch
    because the parameterized type gets changed to covariant in `T`, and because of
    that the `Passengers` super type is no longer valid in place of `Aircraft[CorporatePassengers]`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, if we try to make a function call to the `reserveSeatForCorporatePassengers`
    function with `RegularPassengers`, it won''t work and will throw a compilation
    error about type mismatch. The reason is the same: our parameterized type being
    contravariant in `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The previous example and experiments clear up what covariance and contravariance
    are and what the differences are between them. See the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image explains the inheritance relation between the concrete types
    `Passengers`*,* `CorporatePassengers`, and parameterized types `AircraftSeat[Passengers]`,
    and `AircraftSeat[CorporatePassengers]`*.* You may have noticed that the inheritance
    direction for contravariance is in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've understood two types of variance relationship within the parameterized
    types. First is covariance and then contravariance. Now, there's another type
    of variance relation that's possible and that's called invariant relationship
    in `T`. We don't use any signs to show that invariance relationship. We simply
    use the container type along with a type parameter name as in `Foo[T]`, the type
    is invariant in `T`. Hence, if you want to consume an instance of type `Foo[T]`,
    you must provide an instance of `Foo[T]`, any super type or sub type of T will
    not work for that.
  prefs: []
  type: TYPE_NORMAL
- en: Variance is quite an important concept in functional programming. Hence, you
    may find many examples of it in Scala. We've already seen examples, such as `List[+T]`
    and `option[+T]`*,* which are covariant in T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular example for such variance relationships is the `Function` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, Scala converts it into an instance of these `Function` traits and this
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, this trait as shown in the signature consumes the type `T` and produces
    `R`. We've put variance annotations in front of `T` and `R`, where `Function1`
    is contravariant in `[-T]`, the consumable type and covariant in `[+R]` the producible
    type. I hope this clears up the variance relationship. Let's look at when to use
    covariance and contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: When to use what type of variance relation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's clear that variance is useful for telling the compiler when it's okay to
    bind an instance of one parameterized type to a reference of the same parameterized
    type with a different type parameter. The way we did for `List[Animal]` and `List[Cat]`*.*
    But the question arises, whether to use covariance or use contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we saw the `Function1` trait from Scala's standard library.
    The input/consumable type was contravariant and the output/producible type was
    covariant. It gives us a sense that when we are about to consume some type, it's
    okay to use contravariance. (Why? We'll get to that shortly.)  When we are about
    to produce some results we should go for covariance. The idea here is that as
    a `consumer` you can consume a variety of types or, in other words, you're allowed
    to consume more general (contravariant) stuff, and at the same time as a `producer`,
    you are allowed to produce more specific (covariant) stuff. You get the point,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: So you remember, we talked about our programs made of two entities: *data* and
    *operations.* We also said not all operations can be performed on all data. Hence,
    we had the concept of types. Now, our lives are much more exciting because of
    type parameterization, but we should take care when we declare our parameterized
    types because there may be some operations that are not defined for all types
    under T in Foo[T]. For this, we have a thing called *Type Bounds.* Using type
    bounds we can specify for which types we want to perform the operations. Well,
    we'll talk about *bounds* too, but before that I want to talk about another way
    of achieving abstraction in our programs and that's through *abstract types.*
    Let's go through and try to understand a concept people find difficult when they
    start using Scala (you won't, we'll make it clear!).
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, first things first. We tried to achieve *abstraction *when we introduced
    *type parameterizing.* We will do the same thing using *abstract type members.*
    But what''s an *abstract type member*? How do we write them, how can we use them,
    and why do we even need them when we already have *parameterized types?* These
    are a few questions. We''ll try answering them. So let''s start with the first
    question. How do we write an abstract type. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we just wrote a trait named `ThinkingInTermsOfT` and it has an abstract
    type member. So, to declare an abstract type member we use the keyword `type`
    along with the parameter name that in our case is `T`. From our elementary Scala
    introduction or, let''s say, from previous chapters, we know how we can instantiate
    a trait*.* So when we instantiate our trait, we''ll give a type to our abstract
    member. That''s going to be a concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we instantiated the trait with a `new` keyword and then, while defining
    the trait implementation, we gave the `Int` type to our abstract type member `T`.
    This allows us to use `T` type at the declaration side trait without caring about
    what the type''s going to be. And when we instantiate, we assign a concrete type,
    just like we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You now have some idea of how to perform these kinds of operations and why
    we used this *type T* declaration: so that we can write our behavior methods such
    as `doX` and return `T`, or `doY(t: T)` using type `T` and return something. Abstract
    members give us the flexibility to write code without worrying about the type
    at the time of writing. Our functions/methods are fine to work with whatever type
    we define when we instantiate the trait/class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example to compare how and what we achieved using type members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example is easy to understand. We have both our parameterized version and
    the current one, a trait with an abstract type. So take a look at the parameterized
    version. We have specified that our `traitColumnParameterized[T]` is a parameterized
    type with parameter `T`. We're comfortable with this kind of syntax, right? We've
    just gone through it, it's simple and easy to understand. Now, the latter declaration,
    trait `ColumnAbstract` has a type member, we declared it using the `type`keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Now take a look at the implementation. For parameterized types we knew what
    we had to do and we instantiated the trait (you know what's happening with these
    curly braces at the time of instantiation, right?). Similarly, we instantiated
    the trait with the abstract member and overrode the definition with a `val`*,*
    that's possible, you know that already.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s why we were able to call both of these and get the values out of
    them. Now, if you try to assign the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we get an error, an error saying incompatible types. We know the reason:
    because an integer cannot satisfy the signature, the signature expects the type
    to be `T`, and `T` is `String`*.* So, you''re trying to do the wrong thing; the
    compiler won''t let you pass through. I would suggest you try out these two concepts
    of parameterized types and abstract types. The more you use them and write them,
    the more comfortable you will get. Remember, these abstract members expect you
    to provide types and in Scala, a function is also a type. So, you can go deeper
    by thinking in terms of generating functions dynamically using a trait.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a moment and think. Suppose you want to form a mechanism for performing
    an action/operation. The code for such an action generator may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this looks cool: we''ve used a parameterized type and also an abstract
    type member. Also, our type `Out` member can be a function type. Think of it as
    a rule or pattern. It can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To get more insight, let's think of a scenario where you want to provide a mechanism
    to generate a rating between 1 to 5 from a list of comments you received on your
    blog post. Now, different people have different ways of appreciating (or not appreciating)
    so some people were good enough to give you a rating of 4 or 5\. Some people,
    out of the blue, wrote, `Awesome`, `Nice`, or `Worst ever`. You have to generate
    a rating for your blog from all these comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the scenario, it might seem cool to write a rule, which, based on
    the comments, can generate the rating. Look closely: *generate the rating* is
    an action/operation. We''ll abstract this and we''ll write the generate the rating
    generator, we mean `ActionGenerator`. It could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `simpleRatingGenerator` is the `ActionGenerator`*.* A few takeaway points
    from the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax, like `type Rating = Int`, is just to make code more readable. It enables
    the reader to think of `Rating` as a type that internally accepts *integers.*
    This is merely type declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `simpleRatingGenerator` specifies from its definition that it can accept
    a `NumericString` and give a function that is of type `NumericString => Rating`*.*
    We can view it as if `simpleRatingGenerator` is an `ActionGenerator` that provides
    a mechanism to generate a rating from `NumericString`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the way we can use such an action generator is to get the mechanism and
    pass a numeric string value to it to get the rating. That''s how we do it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create another rating generator that takes comments such as `Awesome`*,*
    `Good`*,* `Nice`*, *and so on*.* Here is an example of how to create an `AlphanumericRatingGenerator`
    that can provide a mechanism to generate rating from `AlphanumericString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The way we can use this is the same way we used `simpleRatingGenerator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So these ways can come in handy when we try to provide a simple interface to
    a consumer of our functionality. For example, if a person wants to see the rating
    based on the comments, he may not be interested in the complexity and only like
    to call a particular function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why you would want to try out stuff with these concepts such as type parameters
    and abstract types now makes more sense: to create abstractions such as `ActionGenerator`*.*
    Life''s easier when you have a set of rules already defined and you only have
    to code them. So with this, let''s go ahead and try to make rules that are more
    precise. In other words, let''s take a look at how we can define limits for using
    our parameterized type.'
  prefs: []
  type: TYPE_NORMAL
- en: Type bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen an example where we were allowed to create `AircraftSeat` for passengers.
    The example looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From what we know so far, `Aircraft` is contravariant in its type parameter
    `T`. But the thing is, when it comes to creating instances of `AircraftSeat`*,*
    it can be created for any type of `T`. What's expected is that this type parameter
    can only be of the `Passengers` type or it's subtype. So to achieve that we can
    introduce a type bound, in our case we'll use an upper-type bound. The reason
    for this is because we want to specify the type that's on the top of the inheritance
    hierarchy, in our case it's `Passengers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''ll look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the notation `*<:*` specifies its *upper bound.* What does this do? Let''s
    check out an example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the same example we used earlier; the only thing different is
    that now we can only create `AircraftSeat` for the `Passengers` type. The code
    will work fine. But we would like to see the behavior for when we try to create
    an `AircraftSeat` instance with a type that''s not a subtype of `Passengers`*.*
    For that, let''s create another class and try to create an `AircraftSeat` instance
    out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to compile code with this instance, the Scala compiler will throw
    an error at compile time. It says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: From the error shown previously, it's clear that the compiler was able to understand
    what we specified and is not ready to take anything else other than `Passengers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, it''s possible to specify a lower bound for our type parameters.
    We can use the sign `>:` to specify lower bounds. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specified a `ListLikeStructure` for any reference types. It''s special
    in the sense that it only takes `Any`, `AnyRef`*,* or equivalent types in hierarchy*.*
    So let''s try creating an instance of the same for `Any` and `AnyRef`. The Scala
    compiler will not complain about the code and will work fine for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to create the same instance with a different type to `Any` or `AnyRef`, the
    Scala compiler will give an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: From this error, it's clear that the signature with a lower bound specified
    will not let you provide a type that comes lower in the type hierarchy. That's
    why we got an error for the `String` type. These are the ways we can provide lower
    and upper bounds in Scala. There's another way we can use both the bounds together
    to specify a specific range of types in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a class inheritance hierarchy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For such a structure, a `ListLikeStructure` can be declared in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It specifies you can only provide a type between `Two` and `Four`, so it''s
    possible to create structures with the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But once you try passing a type that''s not in the bounds, the Scala compiler
    greets you with a compile time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As the error indicates, this instantiation does not satisfy the bounds. So
    now you are aware of the bounds for type parameters. In the same way, we can put
    bounds to abstract types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, as shown in the previous declaration, our type `T` can be instantiated
    with only types for which `Two` is the upper bound.
  prefs: []
  type: TYPE_NORMAL
- en: With the discussion of bounds and variance, the difference and the use cases
    of both are clear. It's good to point out again, that variance is merely the rules
    for inheritance relationships between parameterized/container types. Bounds only
    write a rule that states a certain range of types can be used to instantiate a
    type that is parameterized or contains an abstract member.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea about parameterized types, abstract types, and ways
    to define them, we should also try and find out why we choose abstract types rather
    than parameterized types or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract versus parameterized types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both are forms of providing polymorphic abstractions in Scala. Mostly, it''s
    a design choice whether you prefer one over the other. Talking about design choices,
    let''s have a closer look. For that we''ll take an example where we have two class
    hierarchies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'From the knowledge about abstract types and upper bounds we can say `Animal`
    is an abstract class, which has an abstract type member named `SuitableFood`,
    which expects only the `Food` type. If we declare two subtypes of `Animal` class
    namely `Cow` and `Lion` it could look like a cow can eat `Grass` as well as `Meat`
    because both are subclasses of `Food`. But this isn''t the desired behavior. To
    resolve the issue, we can declare `Cow` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have put a bound on the abstract type member `SuitableFood`*.* Now, for
    any cow (instance), the type that we provide has to be of type `Grass` *(*and
    yes, we were allowed to put *Grass* only because it''s a subtype of `Food`*).*
    We can do the same for the `Lion` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try using these classes, we''ll have to provide the intended concrete
    types. Let''s take a look at the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: So, as shown, we can create a cow instance by providing a type that satisfies
    the bounds specified. These kinds of requirements are best written using abstract
    types. When you need to provide a type with a parameter, just for instantiation,
    examples are `List[String]` or similar types. When using the same type to evolve
    as you write/define members of your class/trait, it's better to consider abstract
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed *abstract versus parameterized types*, let's talk about
    one more concept that you will encounter often when working with Scala. We'll
    talk a bit about type-classes.
  prefs: []
  type: TYPE_NORMAL
- en: Type-classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why would someone need a concept such as a type-class? To answer this, we'll
    first have to understand what a type-class exactly is. As they say, "*Type-classes
    allow us to generalize over a set of types in order to define and execute a standard
    set of features for those types."* Let's try to understand this.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe you''re aware of the notion of encoding and decoding. Let''s think
    of encoding as applying a certain rule to convert A into a specific pattern. Now,
    after you encode something, it''s in that specific pattern. Decoding is the exact
    opposite of what we just did: it''s changing your type A from the pattern we just
    created to its original shape. For example, **comma-separated values** (**CSV**)
    can be considered an encoded pattern. Hence, there''s a scheme that converts words
    from a source to CSV format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We've written a *trait* named `CSVEncoder[T]`. It's time to rephrase what we
    said for type-classes. `CSVEncoder` allows us to generalize over type `T` in order
    to provide an encoding mechanism for the same type. This means that we can use
    `CSVEncoder` for all the types we want and use them whenever there's a need. This
    is the implementation of a type-class. We'll go through the overall type-class
    implementation in the next chapter after the discussion of implicits. For now,
    it's good to know what a concept such as type-class does.
  prefs: []
  type: TYPE_NORMAL
- en: With the conception of type-classes, it's time to summarize what we have learned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From understanding the basic need of types to understanding what a type-class
    is, we've gone through it all. Along the way, we discussed parametric polymorphism
    using parametric types and abstract types. With the concept of variance, as well
    as bounds, we've gone through it all and now it's a bit clearer. For more insights,
    practice is a must. We can think of scenarios to learn about the concepts. We
    tried to go through the concepts as they were and look at a few examples, but
    it'll definitely be fun if you try out some of these on your own. This chapter
    was the formation or the basis of real Scala programming. Concepts such as type-classes
    come in very handy when writing effective programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go through concepts such as *implicits* and the ways
    we can do exception handling in Scala. And of course, we'll play with type-classes.
  prefs: []
  type: TYPE_NORMAL
