<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Lambda Leftovers</h1>
                </header>
            
            <article>
                
<p>Imagine the convenience of marking unused parameters in a method or lambda expression and not passing any arbitrary values to conform to the syntax. Also, when working with lambdas, imagine the ability to declare a lambda parameter name, without caring whether the same variable name has been used in the enclosing scope or not. This is what <strong>lambda leftovers</strong> (JEP 302) provide in order to enhance lambdas and method references. Apart from these enhancements, it will also offer better disambiguation of functional expressions in methods (this is marked as optional in the <strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>), as of right now).</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Using underscores for unused method parameters</li>
<li>Shadowing lambda parameters</li>
<li>Disambiguation of functional expressions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The code in this chapter will use the features defined in lambda leftovers (JEP 302), which has yet to be targeted for a JDK release version. To experiment with the code, you can clone the relevant repository.</p>
<p>All of the code in this chapter can be accessed at <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a><span class="MsoHyperlink">.</span></p>
<p>Let's get started by understanding why would you need to mark unused lambda parameters.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Marking unused parameters with underscores</h1>
                </header>
            
            <article>
                
<p>Suppose that you are served four food items at a restaurant, but you don't eat three of them. If the restaurant has a protocol for customers to mark <strong>ort</strong> (which literally means <em>used</em>) and non-ort food items, the food from the table can be used in a certain manner. For example, the restaurant can mark the non-ort items as <em>good to eat</em>, and can consider sharing them with the needy.</p>
<p>Similarly, when calling a method or a lambda expression, you might not need all of the method parameters. In that case, communicating your intent to the compiler (that certain parameters aren't used) is a good idea. This has two benefits—it saves the compiler from type-checking the values that are not required, and it saves you from passing any arbitrary values to match the code definition and code-calling syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An example of lambda parameters</h1>
                </header>
            
            <article>
                
<p>The following is an example to demonstrate how you can use an <kbd>_</kbd> (underscore) to mark unused lambda parameters. The following code uses the <kbd>BiFunction&lt;T, U, R&gt;</kbd> functional interface which can accept two arguments (<kbd>T</kbd> and <kbd>U</kbd>), and returns a value of the type <kbd>R</kbd>:</p>
<pre>BiFunction&lt;Integer, String, Boolean&gt; calc = (age, _) -&gt; age &gt; 10;</pre>
<p>In the preceding example, since the lambda expression assigned to the <kbd>BiFunction</kbd><span> functional interface </span>uses just one of the method parameters (that is, <kbd>age</kbd>), JEP 302 proposes using the underscore to mark the unused parameter.</p>
<p>The following code highlights a few use cases to illustrate how you would use the same code without the convenience of marking unused lambda parameters (the comments state the value that the code is passing to the unused parameter):</p>
<pre><strong>// Approach 1</strong><br/>// Pass null to the unused parameter<br/>BiFunction&lt;Boolean, Integer, String&gt; calc = (age, <strong>null</strong>) -&gt; age &gt; 10;<br/><br/><strong>// Approach 2</strong><br/>// Pass empty string to the unused parameter<br/>BiFunction&lt;Boolean, Integer, String&gt; calc = (age, <strong>""</strong>) -&gt; age &gt; 10;<br/><br/><strong>// Approach 3</strong><br/>// Pass ANY String value to the unused parameter -<br/>// - doesn't matter, since it is not used<br/>BiFunction&lt;Boolean, Integer, String&gt; calc = <br/>                       (age, <strong>"Ban plastic straws"</strong>) -&gt; age &gt; 10;<br/>                               <br/><br/><strong>// Approach 4</strong><br/>// Pass any variable (of the same type) to the unused parameter -<br/>// - doesn't matter, since it is not used<br/>BiFunction&lt;Boolean, Integer, String&gt; calc = (age, <strong>name</strong>) -&gt; age &gt; 10;</pre>
<div class="packt_infobox">A lot of other functional programming languages use a similar notation to mark unused parameters.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The journey of getting there</h1>
                </header>
            
            <article>
                
<p>Using an underscore to mark unused parameters required changes in the Java language.</p>
<p>Until Java 8, the underscore was used as a valid identifier. The first step was to deny permission to use an underscore as a regular identifier. So, Java 8 issued a compiler warning for the usage of <kbd>_</kbd> as the name of formal parameters in lambdas. This was simple, and had no backward-compatibility issues since lambdas were introduced in Java 8. Moving forward, Java 9 replaced the compiler warning message with compilation errors for using underscores as parameter names.</p>
<p>With JEP 302, developers can use <kbd>_</kbd> to mark an unused method parameter for the following:</p>
<ul>
<li>Lambdas</li>
<li>Methods</li>
<li>Catch handlers</li>
</ul>
<p>In the next section, you'll see how (in the future) your lambda parameters will be able to shadow the variables with the same name in their enclosing scopes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shadowing of lambda parameters</h1>
                </header>
            
            <article>
                
<p>Java doesn't allow the declaration of variables with the same names in multiple scenarios. For instance, you can't define instance and static variables in a class with the same name. Similarly, you can't define method parameters and local variables with the same names in a method.</p>
<p class="mce-root"/>
<p>However, you can define local variables with the same names as an instance or <kbd>static</kbd> variables in a class. This doesn't mean that you can't access them later. To access an instance variable from a method, you can prefix the variable name with the <kbd>this</kbd> <span>keyword.</span></p>
<p>These restrictions allow you to access all of the variables within a scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The existing case of lambda parameters</h1>
                </header>
            
            <article>
                
<p>When you write a lambda expression, you can define multiple parameters. The following are some examples of lambdas that define single or multiple parameters:</p>
<pre>key -&gt; key.uppercase();           // single lambda parameter<br/>                                                  <br/>(int x, int y) -&gt; x &gt; y? x : y;   // two lambda parameters<br/>                                             <br/>(a, b, c, d) -&gt; a + b + c + d;    // four lambda parameters<br/>                                              </pre>
<p>Let's use one of the lambdas from the preceding code in stream processing. The following example will provide the string values from <kbd>List</kbd> as output, in uppercase:</p>
<pre><span>List&lt;String&gt; talks = List.of("Kubernetes", "Docker", "Java 11");</span><br/><span>talks.stream()</span><br/><span>        .map(</span><strong>key -&gt; key.toUpperCase()</strong><span>)</span><br/><span>        .forEach(System.out::prinltn);</span></pre>
<p>So far, so good. But what happens if the preceding code is defined in a method (say, <kbd>process()</kbd>) with a local variable (say, <kbd>key</kbd> (code on line number <kbd>3</kbd>)) that overlaps with the name of the <kbd>key</kbd>  lambda parameter (defined and used on the line number <kbd>5</kbd>)? See the following code:</p>
<pre>1. void process() {<br/>2.     List&lt;String&gt; talks = List.of("Kubernetes", "Docker", "Java 11");<br/>3.     String <strong>key</strong> = "Docker"; // local variable key<br/>4.     talks.stream()<br/>5.         .map(<strong>key</strong> -&gt; <strong>key</strong>.toUpperCase())       // WON'T compile: 'key' <br/>            redefined<br/>6.         .forEach(System.out::prinltn);<br/>7. }</pre>
<p>At present, the preceding code won't compile, because the <kbd>key</kbd> variable used in the lambda expression for the <kbd>map()</kbd> method can't overshadow the local <kbd>key</kbd> variable, defined in the <kbd>process()</kbd> <span>method. </span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why should lambda parameters overshadow enclosing variables?</h1>
                </header>
            
            <article>
                
<p>When you write a lambda expression, you (usually) define the parameter names as indicators of how the values assigned to them should be processed. They aren't meant to reuse the existing values, referred to by variables, in an enclosing block.</p>
<p>Let's revisit the preceding code:</p>
<pre>1. String key = "Docker"; // local variable key<br/>2. talks.stream()<br/>3.     .map(<strong>key -&gt; key.toUpperCase()</strong>)         // WON'T compile : 'key' <br/>                                              // redefined<br/>4.     .forEach(System.out::println);</pre>
<p>In the preceding code, the lambda expression on line <kbd>3</kbd> (in bold) defines one lambda parameter, <kbd>key</kbd>, specifying that when a value is passed to it, Java should call the <kbd>toUpperCase()</kbd> method on it and return the resulting value.</p>
<p>As is evident from this example, the <kbd>key</kbd> lambda parameter appears to be unrelated to the local <kbd>key</kbd> variable, defined in the enclosing block. So, the lambda parameters should be allowed to overshadow the variables with the same names in the enclosing block.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A few of the known issues</h1>
                </header>
            
            <article>
                
<p>As of now, it isn't clear whether a lambda expression will be able to access the value of the enclosing variable, which is overshadowed by the lambda parameter; and if it can, how?</p>
<p>For example, let's modify the preceding code by replacing the call to the <kbd>toUppercase()</kbd> method with a call to the <kbd>concat()</kbd> method as follows (changes are in bold):</p>
<pre>1. String key = "Docker"; // local variable key<br/>2. talks.stream()<br/>3.     .map(key -&gt; key.<strong>concat(key)</strong>)            <br/>4.     .forEach(System.out::prinltn);</pre>
<p>In the preceding code, imagine that the lambda expression on line <kbd>3</kbd> needs to access the value of the <kbd>key</kbd> variable defined on line <kbd>1</kbd>, since it wants to pass it to the <kbd>concat()</kbd> method. As of right now, it hasn't been finalized whether this will be allowed.</p>
<p class="mce-root"/>
<p>If it is allowed, Java will need to devise a way to mark and clearly differentiate a lambda parameter from another variable with the same name, in the enclosing block. This will be required for code readability—which, as you know, is important.</p>
<div class="packt_infobox">The accessibility of the overshadowed enclosing variable is the main problem associated with shadowing of lambda parameters.</div>
<p>In the next section, we'll look at how Java is trying to resolve overloaded method calls, which define functional interfaces as parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Disambiguation of functional expressions</h1>
                </header>
            
            <article>
                
<p>If you think Java started its journey through type inference with the <kbd>var</kbd> keyword (Java 10), think again. Type inference was introduced with Java 5 and has been increasing in coverage ever since.</p>
<p>With Java 8, the resolution of overloaded methods was restructured to allow for working with type inference. Before the introduction of lambdas and method references, a call to a method was resolved by checking the types of the arguments that were passed to it (the return type wasn't considered).</p>
<p>With Java 8, implicit lambdas and implicit method references couldn't be checked for the types of values that they accepted, leading to restricted compiler capabilities, to rule out ambiguous calls to overloaded methods. However, explicit lambdas and method references could still be checked by their arguments by the compiler. For your information, the lambdas that explicitly specify the types of their parameters are termed <strong>explicit lambdas</strong>.</p>
<p>Limiting the compiler's ability and relaxing the rules in this way was purposeful. It lowered the cost of type-checking for lambdas and avoided brittleness.</p>
<div class="packt_infobox">Although it is an interesting feature, the disambiguation of functional expressions is slated as an optional feature in JEP 302, because Oracle needs to assess its impact on the compiler implementation.</div>
<p>Before diving into the proposed solution, let's look at the existing issues, using code examples.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issues with resolving overloaded methods – passing lambdas </h1>
                </header>
            
            <article>
                
<p>Let's cover the existing issues with resolving overloaded methods when lambdas are passed as method parameters. Let's define two interfaces, <kbd>Swimmer</kbd> and <kbd>Diver</kbd>, as follows:</p>
<pre>interface Swimmer {<br/>    boolean test(String lap);<br/>}<br/>interface Diver {<br/>    String dive(int height);<br/>}</pre>
<p>In the following code, the overloaded <kbd>evaluate</kbd> method accepts the interfaces <kbd>Swimmer</kbd> and <kbd>Diver</kbd> as method parameters:</p>
<pre>class SwimmingMeet {<br/>    static void evaluate(Swimmer swimmer) {   // code compiles<br/>                                                     <br/>        System.out.println("evaluate swimmer");<br/>    }<br/>    static void evaluate(Diver diver) {      // code compiles<br/>                                                         <br/>        System.out.println("evaluate diver");<br/>    }<br/>}</pre>
<p>Let's call the overloaded <kbd>evaluate()</kbd> <span>method </span>in the following code:</p>
<pre>class FunctionalDisambiguation {<br/>    public static void main(String args[]) {<br/>        SwimmingMeet.evaluate(<strong>a -&gt; false</strong>); // This code WON'T compile<br/>    }<br/>}</pre>
<p>Revisit the lambda from the preceding code:</p>
<pre>a -&gt; false                               // this is an implicit lambda</pre>
<p>Since the preceding lambda expression doesn't specify the type of its input parameter, it could be either <kbd>String</kbd> (the <kbd>test()</kbd> method and the <kbd>Swimmer</kbd> interface) or <kbd>int</kbd> (the <kbd>dive()</kbd> method and the <kbd>Diver</kbd> interface). Since the call to the <kbd>evaluate()</kbd> method is ambiguous, it doesn't compile.</p>
<p class="mce-root"/>
<p>Let's add the type of the method parameter to the preceding code, making it an explicit lambda:</p>
<pre>SwimmingMeet.evaluate((String <strong>a) -&gt; false</strong>);         // This compiles!!</pre>
<p>The preceding call is not ambiguous now; the lambda expression accepts an input parameter of the <kbd>String</kbd> type and returns a <kbd>boolean</kbd> value, which maps to the <kbd>evaluate()</kbd> method which accepts <kbd>Swimmer</kbd> as a parameter (the functional <kbd>test()</kbd> method in the <kbd>Swimmer</kbd> interface accepts a parameter of the <kbd>String</kbd> type).</p>
<p>Let's see what happens if the <kbd>Swimmer</kbd> interface is modified, changing the data type of the <kbd>lap</kbd> parameter from <kbd>String</kbd> to <kbd>int</kbd>. To avoid confusion, all of the code will be repeated, with the modifications in bold:</p>
<pre>interface Swimmer {                            // test METHOD IS <br/>                                               // MODIFIED<br/>    boolean test(<strong>int</strong> lap);      // String lap changed to int lap<br/>                                               <br/>}<br/>interface Diver {<br/>    String dive(int height);<br/>}<br/>class SwimmingMeet {<br/>    static void evaluate(Swimmer swimmer) {          // code compiles<br/>                                                     <br/>        System.out.println("evaluate swimmer");<br/>    }<br/>    static void evaluate(Diver diver) {               // code compiles<br/>        System.out.println("evaluate diver");<br/>    }<br/>}</pre>
<p>Consider the following code, thinking about which of the lines of code will compile:</p>
<pre>1. SwimmingMeet.evaluate(<strong>a -&gt; false</strong>);<br/>2. SwimmingMeet.evaluate(<strong>(int a) -&gt; false</strong>);</pre>
<p>In the preceding example, the code on both of the line numbers won't compile for the same reason—the compiler is unable to determine the call to the overloaded <kbd>evaluate()</kbd> method. Since both of the functional methods (that is, <kbd>test()</kbd> in the <kbd>Swimmer</kbd> interface and <kbd>dive()</kbd> in the <kbd>Diver</kbd> interface) accept one method parameter of the <kbd>int</kbd> type, it isn't feasible for the compiler to determine the method call.</p>
<p>As a developer, you might argue that since the return types of <kbd>test()</kbd> and <kbd>dive()</kbd> are different, the compiler should be able to infer the correct calls. Just to reiterate, the return types of a method don't participate in method overloading. Overloaded methods must return in the count or type of their parameters.</p>
<p class="mce-root"/>
<div class="packt_infobox">The return type of methods doesn't participate in method overloading. Overloaded methods must return in the count or type of their parameters.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issues with resolving overloaded methods – passing method references</h1>
                </header>
            
            <article>
                
<p>You can define overloaded methods with different parameter types, as follows:</p>
<pre>class Championship {<br/>    static boolean reward(Integer lapTime) {<br/>        return(lapTime &lt; 60);<br/>    }<br/>    static boolean reward(String lap) {<br/>        return(lap.equalsIgnoreCase("final ");<br/>    }<br/>}</pre>
<p>However, the following code doesn't compile:</p>
<pre>someMethod(Chamionship::reward);                     // ambiguous call</pre>
<p>In the preceding line of code, since the compiler is not allowed to examine the method reference, the code fails to compile. This is unfortunate since the method parameters to the overloaded methods are <kbd>Integer</kbd> and <kbd>String</kbd>—no value can be compatible with both.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The proposed solution</h1>
                </header>
            
            <article>
                
<p>The accidental compiler issues involved with overloaded methods that use either lambda expressions or method references can be resolved by allowing the compiler to consider their return type as <kbd>also</kbd>. The compiler would then be able to choose the right overloaded method and eliminate the unmatched option.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>For Java developers working with lambdas and method references, this chapter demonstrates what Java has in the pipeline to help ease problems.</p>
<p>Lambda Leftovers (JEP 302) proposes using an underscore for unused parameters in lambdas, methods, and catch handlers. It plans to allow developers to define lambda parameters that can overshadow variables with the same name in their enclosing block. The disambiguation of functional expressions is an important and powerful feature. It will allow compilers to consider the return types of lambdas in order to determine the right overloaded methods. Since it can affect how the compilers work, this feature is marked as optional in this JEP.</p>
<p>In the next chapter, which is on pattern matching and switch expressions, you'll get to know the exciting capabilities that are being added to the Java language.</p>
<div class="packt_infobox">This chapter didn't include any coding exercises for the reader. The return type of methods doesn't participate in method overloading. Overloaded methods must return in the count or type of their parameters.</div>


            </article>

            
        </section>
    </body></html>