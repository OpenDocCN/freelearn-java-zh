<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deep Diving into Spring Security</h1>
                </header>
            
            <article>
                
<p>This is a hands-on <span>book,</span><span> but</span><span> our first chapter was theoretical (as it should be) because it was an introductory chapter.</span></p>
<p>In this chapter, we will dive deeply into the technical capabilities of Spring Security, specifically authentication and authorization, using code. However, before we get into the coding, we will give a brief explanation of the theory. We are doing this because it is important to understand the concepts before diving into coding.</p>
<p>The two most important aspects of security are as follows<span>:</span></p>
<ul>
<li><span>Find the identity of the user</span></li>
<li><span>Find what resources this user has access to</span></li>
</ul>
<p>authentication is the mechanism by which you find out who a user is, and authorization is the mechanism that allows an application to find out what the user can do with the application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ac322b64-46ba-4e10-8764-c3449f298df3.png" style="width:15.92em;height:10.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 01: Fundamental aspects of security—Authentication and Authorization</div>
<p>In this chapter we will cover the following:</p>
<ul>
<li>Authentication</li>
<li>Authentication mechanisms</li>
<li>Authorization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>One of the fundamental ways to secure a resource is to make sure that the caller is who they claim to be. This process of checking credentials and making sure that they are genuine is called <strong>authentication</strong>.</p>
<p>The following diagram shows the fundamental process Spring Security uses to address this core security requirement. The figure is generic and can be used to explain all the various authentication methods that the framework supports:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/35829f9b-bc45-453d-b3c9-8d3f78cf8f3c.png" style="width:44.33em;height:29.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 02: Authentication architecture</div>
<p>As detailed in <a href="bb1f1c6e-a9a4-4a14-aff4-3510fbfa7d14.xhtml"/><a href="bb1f1c6e-a9a4-4a14-aff4-3510fbfa7d14.xhtml"/><a href="bb1f1c6e-a9a4-4a14-aff4-3510fbfa7d14.xhtml">Chapter 1</a>, <em><span>Overview of Spring 5 and Spring Security 5</span></em> (in the <em>Working of Spring Security</em> section), Spring Security has a series of servlet filters (a filter chain). When a request reaches the server, it is intercepted by this series of filters (<em>Step 1</em> in the preceding diagram).</p>
<p>In the reactive world (with the new Spring WebFlux web application framework), filters are <span>written</span><span> </span><span>quite differently than traditional filters (such as those used in the Spring MVC web application framework). Having said that, the fundamental mechanism remains the same for both. We have a dedicated chapter explaining how to convert a Spring Security application to Spring MVC and Spring WebFlux where we will cover these aspects in a bit more detail.</span></p>
<p>The Servlet filter code execution in the filter chain keeps skipping until the right filter is reached. Once it reaches the right authentication filter based on the authentication mechanism used, it extracts the supplied credentials (most commonly a username and password) from the caller. Using the supplied values (here, we have a username and password), the filter (<kbd>UsernamePasswordAuthenticationFilter</kbd>) creates an <kbd>Authentication</kbd> object (in the preceding diagram, <kbd>UsernamePasswordAuthenticationToken</kbd> is created using the username and password supplied in <em>Step 2</em>). The <kbd>Authentication</kbd> object created in <em>Step 2</em> is then used to call the <kbd>authenticate</kbd> method in the<kbd>AuthenticationManager</kbd> interface:</p>
<pre>public interface AuthenticationManager {<br/>    Authentication authenticate(Authentication authentication) <br/>        throws AuthenticationException;<br/>}</pre>
<p>The actual implementation is provided by <em>ProviderManager</em>, which has a list of configured <kbd>AuthenticationProvider</kbd>.</p>
<pre>public interface AuthenticationProvider {<br/>    Authentication authenticate(Authentication authentication)<br/>        throws AuthenticationException;<br/>    boolean supports(Class&lt;?&gt; authentication);<br/>}</pre>
<p>The request passes through various providers and, in due course, tries to authenticate the request. There are a number of <kbd>AuthenticationProvider</kbd> as part of Spring Security.</p>
<p>In the diagram at the start of the chapter, <kbd>AuthenticationProvider</kbd> requires user details (some providers require this, but some don't), which are provided in <kbd>UserDetailsService</kbd>:</p>
<pre>public interface UserDetailsService {<br/>    UserDetails loadUserByUsername(String username) throws           <br/>        UsernameNotFoundException;<br/>}</pre>
<p><kbd>UserDetailsService</kbd> retrieves <kbd>UserDetails</kbd> (and implements the <kbd>User</kbd> interface) using the supplied username.</p>
<p>If all goes well, Spring Security creates a fully populated <kbd>Authentication</kbd> object (authenticate: true, granted authority list and username), which will contain various necessary details. The <kbd>Authentication</kbd> object is stored in the <kbd>SecurityContext</kbd> object by the filter for future use.</p>
<p>The <kbd>authenticate</kbd> method in <kbd>AuthenticationManager</kbd> can return the following:</p>
<ul>
<li>An <kbd>Authentication</kbd> object with <kbd>authenticated=true</kbd>, if Spring Security can validate the supplied user credentials</li>
<li>An <kbd>AuthenticationException</kbd>, if Spring Security finds that the supplied user credentials are invalid</li>
<li><kbd>null</kbd>, if Spring Security cannot decide whether it is true or false (confused state)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up AuthenticationManager</h1>
                </header>
            
            <article>
                
<p>There are number of built-in <kbd>AuthenticationManager</kbd> in Spring Security that can be easily used in your application. Spring Security also has a number of helper classes, using which you can set up <kbd>AuthenticationManager</kbd>. One helper class is <kbd>AuthenticationManagerBuilder</kbd>. Using this class, its quite easy to set up <kbd>UserDetailsService</kbd> against a database, in memory, in LDAP, and so on. If the need arises, you could also have your own custom <kbd>UserDetailsService</kbd> (maybe a custom single sign-on solution is already there in your organization).</p>
<p>You can make an <kbd>AuthenticationManager</kbd> global, so it will be accessible by your entire application. It will be available for method security and other <kbd>WebSecurityConfigurerAdapter</kbd> instances. <kbd>WebSecurityConfigurerAdapter</kbd> is a class that is extended by your Spring configuration file, making it quite easy to bring Spring Security into your Spring application. This is how you set up a global <kbd>AuthenticationManager</kbd> using the <kbd>@Autowired</kbd> annotation:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {<br/>     <br/>    @Autowired<br/>    public void confGlobalAuthManager(AuthenticationManagerBuilder auth) throws <br/>            Exception {<br/>        auth<br/>            .inMemoryAuthentication()<br/>                .withUser("admin").password("admin@password").roles("ROLE_ADMIN");<br/>    }<br/>}</pre>
<p>You can also create local <kbd>AuthenticationManager</kbd>, which is only available for this particular <kbd>WebSecurityConfigurerAdapter</kbd>, <span>by overriding the <kbd>configure</kbd> method, </span><span>as shown in the following code:</span></p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {<br/>     <br/>    @Override<br/>    protected void configure(AuthenticationManagerBuilder auth) throws Exception {<br/>        auth<br/>            .inMemoryAuthentication()<br/>                .withUser("admin").password("admin@password").roles("ROLE_ADMIN");<br/>    }<br/>}</pre>
<p>Another option is to expose the <kbd>AuthenticationManager</kbd> bean by overriding <kbd>authenticationManagerBean</kbd> method, as shown here:</p>
<pre>@Override<br/>    public AuthenticationManager authenticationManagerBean() throws Exception {<br/>        return super.authenticationManagerBean();<br/>}</pre>
<p>You can also expose various <kbd>AuthenticationManager</kbd>, <kbd>AuthenticationProvider</kbd>, or <kbd>UserDetailsService</kbd> as beans which will override the default ones.</p>
<p>In the preceding code examples we have used <kbd>AuthenticationManagerBuilder</kbd> to configure in-memory authentication. More mechanisms of the <kbd>AuthenticationManagerBuilder</kbd> class will be used in the subsequent examples in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AuthenticationProvider</h1>
                </header>
            
            <article>
                
<p><kbd>AuthenticationProvider</kbd> provides a mechanism for getting user details, with which authentication can be performed. Spring Security provides a number of <kbd>AuthenticationProvider</kbd> implementations, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c68b876c-9e2c-4329-b76d-63ebe1a3b376.png" style="width:30.92em;height:15.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 03: Spring Security built-in AuthenticationProvider</div>
<p>In subsequent chapters, we will go through each of these in detail with more code samples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom AuthenticationProvider</h1>
                </header>
            
            <article>
                
<p>If needs be, we can write a custom <kbd>AuthenticationProvider</kbd> by implementing the <kbd>AuthenticationProvider</kbd> interface. We will have to implement two methods, namely authenticate (<kbd>Authentication</kbd>) and <kbd>supports(Class&lt;?&gt; aClass)</kbd>:</p>
<pre style="padding-left: 30px">@Component<br/>public class CustomAuthenticationProvider implements AuthenticationProvider {<br/>    @Override<br/>    public Authentication authenticate(Authentication authentication) throws     <br/>            AuthenticationException {<br/>      String username = authentication.getName();<br/>      String password = authentication.getCredentials().toString();<br/>      if ("user".equals(username) &amp;&amp; "password".equals(password)) {<br/>        return new UsernamePasswordAuthenticationToken<br/>          (username, password, Collections.emptyList());<br/>      } else {<br/>        throw new BadCredentialsException("Authentication failed");<br/>      }<br/>    }<br/>    @Override<br/>    public boolean supports(Class&lt;?&gt; aClass) {<br/>      return aClass.equals(UsernamePasswordAuthenticationToken.class);<br/>    }<br/>}</pre>
<p>Our <kbd>authenticate</kbd> method is quite simple. We just compare the username and password with a static value. We can write any logic here and authenticate the user. If there is an error, it throws an exception, <kbd>AuthenticationException</kbd>.</p>
<p>On the book's GitHub page, navigate to the <kbd>jetty-in-memory-basic-custom-authentication</kbd> project to see the full source code of this class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple AuthenticationProvider</h1>
                </header>
            
            <article>
                
<p>Spring Security allows you to declare multiple <kbd>AuthenticationProvider</kbd> in your application. They are executed according to the order in which they are declared in the configuration.</p>
<p>The <kbd>jetty-in-memory-basic-custom-authentication</kbd> <span>project </span>is modified further, and we have used the newly created <kbd>CustomAuthenticationProvider</kbd> as an <kbd>AuthenticationProvider</kbd> (<kbd>Order 1</kbd>) and the existing <kbd>inMemoryAuthentication</kbd> as our second <kbd>AuthenticationProvider</kbd> (<kbd>Order 2</kbd>):</p>
<pre><span>@EnableWebSecurity<br/></span><span>@ComponentScan</span>(basePackageClasses = CustomAuthenticationProvider.<span>class</span>)<br/><span>public class </span>SpringSecurityConfig <span>extends </span>WebSecurityConfigurerAdapter {<br/><br/>    <span>@Autowired<br/></span><span>    </span>CustomAuthenticationProvider <span>customAuthenticationProvider</span>;<br/><br/>    <span>@Override<br/></span><span>    </span><span>protected void </span>configure(HttpSecurity http) <span>throws </span>Exception {<br/>        http.httpBasic()<br/>                .and()<br/>                .authorizeRequests()<br/>                .antMatchers(<span>"/**"</span>)<br/>                .authenticated(); <span>// Use Basic authentication<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>protected void </span>configure(AuthenticationManagerBuilder auth) <span>throws </span>Exception {<br/>        <span>// Custom authentication provider - Order 1<br/></span><span>        </span>auth.authenticationProvider(<span>customAuthenticationProvider</span>);<br/>        <span>// Built-in authentication provider - Order 2<br/></span><span>        </span>auth.inMemoryAuthentication()<br/>                .withUser(<span>"admin"</span>)<br/>                .password(<span>"{noop}admin@password"</span>)<br/>                <span>//{noop} makes sure that the password encoder doesn't do anything<br/></span><span>                </span>.roles(<span>"ADMIN"</span>) <span>// Role of the user<br/></span><span>                </span>.and()<br/>                .withUser(<span>"user"</span>)<br/>                .password(<span>"{noop}user@password"</span>)<br/>                .credentialsExpired(<span>true</span>)<br/>                .accountExpired(<span>true</span>)<br/>                .accountLocked(<span>true</span>)<br/>                .roles(<span>"USER"</span>);<br/>    }<br/>}</pre>
<p>Whenever the <kbd>authenticate</kbd> method executes without error, the controls return and thereafter configured <kbd>AuthenticationProvider</kbd>'s doesn't get executed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample application</h1>
                </header>
            
            <article>
                
<p>Let's gets our hands dirty by doing some coding. We will start off with the most common authentication mechanisms and then get into other authentication mechanisms that can be used with Spring Security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Base project setup</h1>
                </header>
            
            <article>
                
<p>Apart from the actual authentication mechanism, many aspects of the application are quite similar. In this section, we will set up the example and then cover the specific authentication mechanism in detail.</p>
<p class="mce-root"/>
<p>We will be using the default Spring Security DB schema against which we will authenticate the user. We will create a fully fledged Spring MVC web application, with each component being created from scratch. Creating a sample Spring Security application using Spring MVC with the help of Spring Boot is very easy. The application will function through many things that are hidden away from developers. But in this case, we will be creating this application component by component so that you can see the actual code with which a web application that is built on Spring MVC can be secured.</p>
<p>The default DB schema used by Spring Security is shown in the following diagram. However, you can customize it the way you think it is suitable for your application. We will be using the <strong>Users</strong> and <strong>Authorities</strong> tables for our setup here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/16b57543-4f52-4af7-96a2-95087c1b51c6.png" style="width:31.83em;height:26.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 04: Spring Security default database schema</div>
<p>Let's now start developing our sample application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1—Create a Maven project in IntelliJ IDEA</h1>
                </header>
            
            <article>
                
<p>In IntelliJ, select <span class="packt_screen">File | New | Project</span>. This will open up the <span class="packt_screen">New Projec</span><span class="packt_screen">t</span> wizard, as shown in the following screenshot. Now select <span class="packt_screen">Maven</span> and click the <span class="packt_screen">Next</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/32266a6a-98b5-4f72-a76d-702c307cbdd1.png" style="width:46.67em;height:34.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 05: New Maven project in IntelliJ</div>
<p>On the next screen in the <span class="packt_screen">New Project</span> wizard (<em>Step 2</em>), enter the <span class="packt_screen">GroupId</span>, <span class="packt_screen">ArtifactId</span>, and <span class="packt_screen">Version</span>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b886993-a053-4200-8076-bb7cf3e78c26.png" style="width:51.92em;height:38.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 06: Maven project setup in IntelliJ—Input GroupId, ArtifactId and Version</div>
<p><span>On the next screen in the <span class="packt_screen">New Project</span> wizard (<em>Step 3</em>), enter the <span class="packt_screen">Project name</span> and <span class="packt_screen">Project location</span>, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9eb9f732-38b0-4d9d-8be6-be901b714012.png" style="width:48.08em;height:35.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 07: Maven project setup—Setting Project name and Project location</div>
<p>IntelliJ will prompt you with instructions, as shown in the following screenshot. To automatically import projects whenever you make any changes in <kbd>pom.xml</kbd>, click on the <span class="packt_screen">Enable Auto-Import</span> link:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0ea8decb-8174-4daa-88b2-1dcd853587df.png" style="width:19.17em;height:3.58em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 08: Enabling Auto-Import in IntelliJ</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2—pom.xml changes</h1>
                </header>
            
            <article>
                
<p>Open the <kbd>pom.xml</kbd> file and add the following code within the project tag (<kbd>&lt;project&gt;&lt;/project&gt;</kbd>):</p>
<pre>&lt;!-- Spring dependencies --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;<br/>   &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;<br/>   &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;<br/>   &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br/>   &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br/>   &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;!-- Servlet and JSP related dependencies --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br/>   &lt;version&gt;3.1.0&lt;/version&gt;<br/>   &lt;scope&gt;provided&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;<br/>   &lt;version&gt;2.3.1&lt;/version&gt;<br/>   &lt;scope&gt;provided&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;<br/>   &lt;artifactId&gt;javax.servlet.jsp.jstl-api&lt;/artifactId&gt;<br/>   &lt;version&gt;1.2.1&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;taglibs&lt;/groupId&gt;<br/>   &lt;artifactId&gt;standard&lt;/artifactId&gt;<br/>   &lt;version&gt;1.1.2&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;!-- For datasource configuration --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br/>   &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;<br/>   &lt;version&gt;2.1.1&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;!-- We will be using MySQL as our database server --&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;mysql&lt;/groupId&gt;<br/>   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br/>   &lt;version&gt;6.0.6&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p class="mce-root">Build a setup on <kbd>pom.xml</kbd> in which we will be using jetty to run the application created.</p>
<pre>&lt;build&gt;<br/>   &lt;plugins&gt;<br/>       &lt;!-- We will be using jetty plugin to test the war file --&gt;<br/>       &lt;plugin&gt;<br/>           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br/>           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;<br/>           &lt;version&gt;9.4.8.v20171121&lt;/version&gt;<br/>       &lt;/plugin&gt;<br/>   &lt;/plugins&gt;<br/>&lt;/build&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 3—MySQL database schema setup</h1>
                </header>
            
            <article>
                
<p>Create a default database schema using the following scripts, and insert some users:</p>
<pre>create table users(<br/>    username varchar(75) not null primary key,<br/>    password varchar(150) not null,<br/>    enabled boolean not null<br/>);<br/>create table authorities (<br/>    username varchar(75) not null,<br/>    authority varchar(50) not null,<br/>    constraint fk_authorities_users foreign key(username) references users(username)<br/>);</pre>
<p class="mce-root"/>
<p>Insert data into the preceding tables using the following scripts:</p>
<pre>insert into users(username, password, enabled)<br/>    values('admin', '$2a$04$lcVPCpEk5DOCCAxOMleFcOJvIiYURH01P9rx1Y/pl.wJpkNTfWO6u', true);<br/>insert into authorities(username, authority) <br/>    values('admin','ROLE_ADMIN');<br/>insert into users(username, password, enabled)<br/>    values('user', '$2a$04$nbz5hF5uzq3qsjzY8ZLpnueDAvwj4x0U9SVtLPDROk4vpmuHdvG3a', true);<br/>insert into authorities(username,authority) <br/>    values('user','ROLE_USER');</pre>
<p>The <kbd>password</kbd> is one-way hashed using online tool <a href="http://www.devglan.com/online-tools/bcrypt-hash-generator">http://www.devglan.com/online-tools/bcrypt-hash-generator</a>. To compare the <kbd>password</kbd> we will use <kbd>PasswordEncoder</kbd> (<kbd>Bcrypt</kbd>).</p>
<p>Credentials are as follows:</p>
<ul>
<li>User = <kbd>admin</kbd> and password = <kbd>admin@password</kbd></li>
<li>User = <kbd>user</kbd> and password = <kbd>user@password</kbd></li>
</ul>
<div class="mce-root packt_infobox">It's important to note that, even though the role is named <kbd>ROLE_ADMIN</kbd>, the actual name is <kbd>ADMIN</kbd>, and this is what our code will be using while passing.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 4—Setting up MySQL database properties in your project</h1>
                </header>
            
            <article>
                
<p>Create a file named <kbd>mysqldb.properties</kbd> in the <kbd>src/main/resources</kbd> folder with the following content:</p>
<pre>mysql.driver=com.mysql.cj.jdbc.Driver<br/>mysql.jdbcUrl=jdbc:mysql://localhost:3306/spring_security_schema?useSSL=false<br/>mysql.username=root<br/>mysql.password=&lt;your-db-password&gt;</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 5—Spring application configuration</h1>
                </header>
            
            <article>
                
<p>Create a Java class named <kbd>ApplicationConfig</kbd> with the following code in the <kbd>com.packtpub.book.ch02.springsecurity.config</kbd> package:</p>
<pre>@Configuration<br/>@PropertySource("classpath:mysqldb.properties")<br/>public class ApplicationConfig {<br/><br/>   @Autowired<br/>   private Environment env;<br/><br/>   @Bean<br/>   public DataSource getDataSource() {<br/>       BasicDataSource dataSource = new BasicDataSource();<br/>       dataSource.setDriverClassName(env.getProperty("mysql.driver"));<br/>       dataSource.setUrl(env.getProperty("mysql.jdbcUrl"));<br/>       dataSource.setUsername(env.getProperty("mysql.username"));<br/>       dataSource.setPassword(env.getProperty("mysql.password"));<br/>       return dataSource;<br/>   }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 6—Web application configuration</h1>
                </header>
            
            <article>
                
<p>In this example, we are going to use Spring MVC as our web application framework. Let's create the web application configuration file:</p>
<pre>@Configuration<br/>@EnableWebMvc<br/>@ComponentScan(basePackages= {"com.packtpub.book.ch02.springsecurity.controller"})<br/>public class WebApplicationConfig implements WebMvcConfigurer {<br/>   @Override<br/>   public void configureViewResolvers(ViewResolverRegistry registry) {<br/>       registry.jsp().prefix("/WEB-INF/views/").suffix(".jsp");<br/>   }<br/>}</pre>
<p>The <kbd>@EnableWebMvc</kbd> annotation makes sure that your application is based on Spring MVC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 7—Spring MVC setup</h1>
                </header>
            
            <article>
                
<p>In Spring MVC, the request lands on <kbd>DispatcherServlet</kbd>. <kbd>DispatcherServlet</kbd> can be declared in <kbd>web.xml</kbd> or as a Java configuration if your servlet container is 3.0+. Please create a dummy <kbd>SpringSecurityConfig.java</kbd> file. We will be constructing this class when we explain the first authentication mechanism, namely, basic authentication:</p>
<pre>public class SpringMvcWebApplicationInitializer<br/>       extends AbstractAnnotationConfigDispatcherServletInitializer {<br/><br/>   @Override<br/>   protected Class&lt;?&gt;[] getRootConfigClasses() {<br/>       return new Class[] { ApplicationConfig.class, SpringSecurityConfig.class };<br/>   }<br/><br/>   @Override<br/>   protected Class&lt;?&gt;[] getServletConfigClasses() {<br/>       return new Class[] { WebApplicationConfig.class };<br/>   }<br/><br/>   @Override<br/>   protected String[] getServletMappings() {<br/>       return new String[] { "/" };<br/>   }<br/><br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 8—Controller setup</h1>
                </header>
            
            <article>
                
<p>Let's create a base controller (<kbd>HomeController</kbd>) for the secured JSP page (<kbd>home.jsp</kbd>). Please note that the return of the mapping method should be a string, and it should map to the actual name of the JSP file. In our case, it is <kbd>home.jsp</kbd>, a secured resource that the caller navigates when they log in:</p>
<pre>@Controller<br/>public class HomeController {<br/><br/>   @GetMapping("/")<br/>   public String home(Model model, Principal principal) {<br/>       if(principal != null)<br/>           model.addAttribute("msg", "Welcome " + principal.getName());<br/>       return "home";<br/>   }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 9—JSP creation</h1>
                </header>
            
            <article>
                
<p>Our home page is a very simple JSP file, as shown in the following code snippet. This JSP just displays a message that we have constructed in our <kbd>HomeController</kbd> class:</p>
<pre>&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1"<br/>        pageEncoding="ISO-8859-1"%&gt;<br/>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>   &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;<br/>   &lt;title&gt;Spring Security&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Spring Security Sample&lt;/h1&gt;<br/>&lt;h2&gt;${msg}&lt;/h2&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>This is now the base Spring MVC application, and with this we will try to set up various authentication mechanisms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security setup</h1>
                </header>
            
            <article>
                
<p>To explain Spring Security, we will implement basic authentication on the Spring MVC project that we created earlier. In <a href="69913c59-1186-44b2-8707-dceca721e206.xhtml">Chapter 3</a>, <span><em>Authentication Using SAML, LDAP, and OAuth/OIDC</em>,</span> we will look at implementing other authentication mechanisms using Spring Security. To accomplish basic authentication in your application, let's perform the additional steps outlined in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1—Spring Security configuration setup</h1>
                </header>
            
            <article>
                
<p>We will now create the all-important Spring Security configuration class and make sure that the default filter chain for Spring Security is set up to secure all the resources:</p>
<pre>@EnableWebSecurity<br/>public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {<br/>   @Autowired<br/>   private DataSource dataSource;<br/>   @Override<br/>   protected void configure(AuthenticationManagerBuilder auth) throws Exception {<br/>       auth.jdbcAuthentication().dataSource(dataSource)<br/>               .usersByUsernameQuery("select username, password, enabled"<br/>                       + " from users where username = ?")<br/>               .authoritiesByUsernameQuery("select username, authority "<br/>                       + "from authorities where username = ?")<br/>               .passwordEncoder(new BCryptPasswordEncoder());<br/>   }<br/>   @Override<br/>   protected void configure(HttpSecurity http) throws Exception {<br/>       http.authorizeRequests().anyRequest().hasAnyRole("ADMIN", "USER")<br/>               .and()<br/>               .httpBasic(); // Use Basic authentication<br/>   }<br/>}</pre>
<p>In Spring Security configuration, the first thing that we do is tell Spring Security that you will have to authenticate the user against a database by using a defined user query and checking the user's authority using the defined authority query.</p>
<p>We then set up the authentication mechanism to retrieve the user's credentials. Here we are using basic authentication as the mechanism to capture user credentials. Please note that the role names being used to check doesn't have the prefix <kbd>ROLE_</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2—Spring Security setup for a web application</h1>
                </header>
            
            <article>
                
<p>We know that we have to instruct the application to start using Spring Security. One easy way is to declare the Spring Security filter in <kbd>web.xml</kbd>. If you want to avoid using XML and perform the actions using Java instead, then create a class that extends <kbd>AbstractSecurityWebApplicationInitializer</kbd>; this will do the trick of initializing the filter and setting Spring Security for your application:</p>
<pre>public class SecurityWebApplicationInitializer<br/>       extends AbstractSecurityWebApplicationInitializer {<br/><br/>}</pre>
<p>With this, we have completed all the setup required to see basic authentication in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Run the project by executing the <kbd>mvn jetty:run</kbd> <span>command</span>. Once you see the log shown in the following screenshot, open a browser and go to <kbd>http://localhost:8080</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a210e9d-0372-4afc-9680-cc9b8c35ba93.png" style="width:52.08em;height:14.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 09: Jetty Server running - console log</div>
<p>Once you access the URL, the browser prompts with a default basic authentication dialog, as shown in the following screenshot. <span>Enter the</span> <span class="packt_screen"><span>U</span>sername</span> and <span class="packt_screen">Password</span><span> as </span><kbd>admin</kbd>/<kbd>admin@password</kbd><span> and click on <span class="packt_screen">Log In</span>: </span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/855b76d0-f0f3-4dbe-967e-d928a2405f89.png" style="width:34.42em;height:21.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10: Basic authentication dialog in the browser</div>
<p>If your credentials are correct and if the user has either the <kbd>ADMIN</kbd> or <kbd>USER</kbd> role, you should see the home page as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9c599ce-0360-4309-a0a5-a535d7d27a09.png" style="width:38.42em;height:15.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11: The home page after successful login</div>
<div class="packt_infobox">The full project code is available on the book's GitHub page (<a href="https://github.com/PacktPublishing/Hands-On-Spring-Security-5-for-Reactive-Applications">https://github.com/PacktPublishing/Hands-On-Spring-Security-5-for-Reactive-Applications</a>) within the <kbd>jetty-db-basic-authentication</kbd><em> </em><span>project</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">In-memory user storage</h1>
                </header>
            
            <article>
                
<p class="mce-root">As mentioned earlier, for various testing purposes, it's better to store the user credentials and then authenticate in memory than to use a proper database, such as MySQL. For this, just change the Spring Security configuration file (<kbd>SpringSecurityConfig.java</kbd>) by adding the following method:</p>
<pre>@Override<br/>protected void configure(AuthenticationManagerBuilder auth) throws Exception {<br/>   auth<br/>.inMemoryAuthentication()<br/>           .withUser("admin")<br/>           .password("{noop}admin@password") <br/>//{noop} makes sure that the password encoder doesn't do anything<br/>           .roles("ADMIN") // Role of the user<br/>           .and()<br/>           .withUser("user")<br/>           .password("{noop}user@password")<br/>           .credentialsExpired(true)<br/>           .accountExpired(true)<br/>           .accountLocked(true)<br/>           .roles("USER");<br/>}</pre>
<p>It's important to note that the password has a prefix, <kbd>{noop}</kbd>, attached to it. This ensures that when the password is validated, no encoding is carried out. This is one way to avoid having password encoding errors when you run the project.</p>
<div class="packt_infobox">The full source code, as a fully fledged project, can be found on this book's GitHub page in the <kbd>jetty-in-memory-basic-authentication</kbd> project.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Run as Spring Boot</h1>
                </header>
            
            <article>
                
<p>The preceding example can be easily converted to a Spring Boot application by following the ensuing additional steps. This process won't cover many of the trivial steps that we have done previously. You need to have one more configuration file, <kbd>SpringSecurityConfig.java</kbd><em>,</em> the details of which are as follows.</p>
<p>You can create a new file, usually named <kbd>Run.java</kbd>, with the following code:</p>
<pre>@SpringBootApplication<br/>public class Run {<br/>   public static void main(String[] args) {<br/>       SpringApplication.run(Run.class, args);<br/>   }<br/>}</pre>
<p>It's a very simple file with an important annotation in it, <kbd>@SpringBootApplication</kbd>. We took away the Spring MVC configuration class and put the following properties in the <kbd>application.properties</kbd> file. This is just another way to avoid creating a new Spring MVC configuration file and instead use the properties file:</p>
<pre>spring.mvc.view.prefix: /WEB-INF/views/<br/>spring.mvc.view.suffix: .jsp</pre>
<p>As earlier, everything else is kept intact. For the full project, refer to the book's GitHub page in the <kbd>spring-boot-in-memory-basic-authentication</kbd> project.</p>
<p>Open a command prompt and enter the following command:</p>
<pre><strong>mvn spring-boot:run</strong></pre>
<p>Open the browser and navigate to <kbd>http://localhost:8080</kbd>, and you should be provided with a basic authentication dialog. After successful login, you should be taken to the user home page, as shown earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p class="mce-root">Once the user is validated in terms of who they claim to be, the next aspect, what the user has access to, needs to be ascertained. This process of making sure what the user is allowed to do within the application is called authorization.</p>
<p class="mce-root">In line with authentication architecture, as seen earlier, authorization also has a manager, <kbd>AccessDecisionManager</kbd>. Spring Security has three built-in implementations for this: <kbd>AffirmativeBased</kbd>, <kbd>ConsensusBased</kbd>, and <kbd>UnanimousBased</kbd>. <kbd>AccessDecisionManager</kbd> works by delegating to a chain of <kbd>AccessDecisionVoter</kbd>. Authorization-related Spring Security classes/interfaces are shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed1850b0-950f-4d1c-ae8f-7bb3d3143455.png" style="width:55.75em;height:20.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 12: Spring Security Authorization <span>classes/interfaces</span></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In Spring Security, authorization to a secured resource is granted by invoking voters and then tallying the votes received. The three built-in implementations tally the votes <span>received</span><span> </span><span>in different manners:</span></p>
<ul>
<li><strong>AffirmativeBased</strong>: If at least one voter votes, the user is given access to the secured resource</li>
<li><strong>ConsensusBased</strong>: If a clear consensus is reached between the voters and their votes, then <span>the user is given access to </span>the secured resource</li>
<li><strong>UnanimousBased</strong>: If all the voters vote, <span>then </span><span>the user is given access to </span><span>the secured resource</span></li>
</ul>
<p>Spring Security provides two authorization approaches:</p>
<ul>
<li><strong>Web URL</strong>: Incoming URL (specific URL or regular expression)-based authorization</li>
<li><strong>Method</strong>: Method signature based on which access is controlled</li>
</ul>
<p>If your serving layer exposes only RESTful endpoints and the data in your application is properly categorized as resources (complying with REST principles), using a Web URL approach can be considered. If your application just exposes endpoints (REST-based, I would call) not really complying with REST principles, you can consider using method-based authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web URL</h1>
                </header>
            
            <article>
                
<p>Spring Security can be used to set up URL-based authorization. HTTP Security configured can be used with Spring Security configuration to achieve the desired authorization. In many examples that we have gone through so far, we have seen pattern matching authorization. Here is one such example:</p>
<ul>
<li><kbd>AntPathRequestMatcher</kbd>: Uses an Ant-style pattern for URL matching:</li>
</ul>
<pre style="padding-left: 60px">http<br/>    .antMatcher("/rest/**")<br/>    .httpBasic()<br/>        .disable()<br/>    .authorizeRequests()<br/>        .antMatchers("/rest/movie/**", "/rest/ticket/**", "/index")<br/>            .hasRole("ROLE_USER");</pre>
<p class="mce-root"/>
<p>In the preceding code snippet, the <kbd>/rest</kbd> URL's basic authentication is disabled, and for other URLs (<kbd>/rest/movie</kbd>, <kbd>/rest/ticket</kbd> and <kbd>/index</kbd>), users with the <kbd>USER</kbd> role have access. The snippet also shows single match (using <kbd>antMatcher</kbd>) and multiple matches (using <kbd>antMatchers</kbd>).</p>
<ul>
<li><kbd>MvcRequestMatcher</kbd>: This uses Spring MVC to match the path and then extracts variables. The matching is relative to the servlet path.</li>
<li><kbd>RegexRequestMatcher</kbd>: This uses a regular expression to match the URL. It can also be used to match the HTTP method, if needed. The matching is case-sensitive and takes the form (<kbd>servletPath</kbd> + <kbd>pathInfo</kbd> + <kbd>queryString</kbd>):</li>
</ul>
<pre style="padding-left: 60px">http<br/>    .authorizeRequests()<br/>    .regexMatchers("^((?!(/rest|/advSearch)).)*$").hasRole("ADMIN")<br/>    .regexMatchers("^((?!(/rest|/basicSearch)).)*$").access("hasRole(USER)")<br/>        .anyRequest()<br/>    .authenticated()<br/>    .and()<br/>    .httpBasic();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method invocation</h1>
                </header>
            
            <article>
                
<p>Spring Security allows users to access-control method execution using <strong>aspect-oriented programming</strong> (<strong><span>AOP</span></strong>) in the background. This can be done using XML configuration or using Java configuration. Since we have been following Java configuration throughout this book, we will cover Java configuration and annotations here to explain method security. The best practice is to choose a particular method invocation authorization approach and stick to it for consistency across your application. Choose whichever approach is apt for your application, as there isn't anything particular documented on when to choose what.</p>
<p>If you would like to enable method security in your application, firstly annotate the class with <kbd>@EnableMethodSecurity</kbd>. There are three types of annotation with which you can annotate the methods and authorize them. The types are as follows:</p>
<ul>
<li class="mce-root"><strong>Voting-based</strong> <strong>ann</strong><strong>otations</strong>: the most commonly used annotations in Spring Security. Spring Security's <kbd>@Secured</kbd> annotation falls into this category. To use these annotations, they first have to be enabled, as shown in the following code snippet:</li>
</ul>
<pre style="padding-left: 60px">@Configuration<br/>@EnableGlobalMethodSecurity(securedEnabled = true)<br/>public class SecurityConfig extends WebSecurityConfigurerAdapter {<br/>    // ...<br/>}</pre>
<p style="padding-left: 60px">Once the usage of annotation is enabled, the <kbd>@Secured</kbd> annotation can be used, as shown in the following code snippet:</p>
<pre style="padding-left: 60px">@RestController<br/>@RequestMapping("/movie")<br/>public class MovieController {<br/><br/>    @GetMapping("public")<br/>    @Secured("ROLE_PUBLIC")<br/>    public String publiclyAvailable() {<br/>        return "Hello All!";<br/>    }<br/><br/>    @GetMapping("admin")<br/>    @Secured("ROLE_ADMIN")<br/>    public String adminAccessible() {<br/>        return "Hello Admin!";<br/>    }<br/>}</pre>
<ul>
<li><strong>JSR-250 security annotations</strong>: This is also called the <span><strong>Enterprise JavaBeans 3.0</strong> (</span><strong>EJB</strong> <strong>3</strong><span>)</span> security annotation. Again, before using these annotations, they have to be enabled using <kbd>@EnableGlobalMethodSecurity(jsr250Enabled = true)</kbd>. The following snippet shows the JSR-250 security annotation in action:</li>
</ul>
<pre style="padding-left: 60px">@RestController<br/>@RequestMapping("/movie")<br/>public class MovieController {<br/><br/>    @GetMapping("public")<br/>    @PermitAll<br/>    public String publiclyAvailable() {<br/>        return "Hello All!";<br/>    }<br/><br/>    @GetMapping("admin")<br/>    @RolesAllowed({"ROLE_ADMIN"})<br/>    public String adminAccessible() {<br/>        return "Hello Admin!";<br/>    }<br/>}</pre>
<p class="mce-root"/>
<ul>
<li><strong>Expression-based annotation</strong>: Annotations based on <kbd>@Pre</kbd> and <kbd>@Post</kbd> fall into this category. They are enabled using <kbd>@EnableGlobalMethodSecurity(prePostEnabled = true)</kbd>:</li>
</ul>
<pre style="padding-left: 60px">@RestController<br/>@RequestMapping("/movie")<br/>public class MovieController {<br/>    @GetMapping("public")<br/>    @PreAuthorize("permitAll()")<br/>    public String publiclyAvailable() {<br/>        return "Hello All!";<br/>    }<br/>    @GetMapping("admin")<br/>    @PreAuthorize("hasAnyAuthority('ROLE_ADMIN')")<br/>    public String adminAccessible() {<br/>        return "Hello Admin!";<br/>    }<br/>}</pre>
<p>In the preceding example, <kbd>hasAnyAuthority</kbd> is called <strong>Spring Expression Language</strong> (<strong>SpEL</strong>). Similar to the example shown, there are many such predefined expressions that can be used for security.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain instance</h1>
                </header>
            
            <article>
                
<p>Spring Security provides ways to access control various permissions attached to any object. Spring Security <span><strong>Access Control List</strong> </span>(<strong>ACL</strong>) stores a list of permissions associated with a domain object. It also grants these permissions to various entities that need to perform different operations on the domain object. For Spring Security to work, you need to set up four database tables, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2edbf2b-2268-4cf9-9414-d68a1a2d93df.png" style="width:35.75em;height:32.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 13: Spring Security ACL database schema</div>
<p>Here is a small explanation of the tables in the preceding diagram:</p>
<ul>
<li><kbd>ACL_CLASS</kbd> table: As the name suggests, it stores the domain object's class name.</li>
<li><kbd>ACL_SID</kbd> table: <strong>Security Identity</strong> (<strong>SID</strong>) stores either a username (<kbd>testuser</kbd>) or role name (<kbd>ROLE_ADMIN</kbd>). The <kbd>PRINCIPAL</kbd> column stores either 0 or 1, 0 if the SID is a username and 1 if it is a role name.</li>
<li><kbd>ACL_OBJECT_IDENTITY</kbd> table: It is entrusted to store object-related information and links other tables.</li>
<li><kbd>ACL_ENTRY</kbd> table: It stores permission granted to each SID for each <kbd>OBJECT_IDENTITY</kbd>.</li>
</ul>
<p>In order for Spring Security ACL to work, it also requires a cache. One of the easiest ones to integrate with Spring is EhCache.</p>
<p>Spring Security ACL supports the following permissions:</p>
<ul>
<li><kbd>READ</kbd></li>
<li><kbd>WRITE</kbd></li>
<li><kbd>CREATE</kbd></li>
<li><kbd>DELETE</kbd></li>
<li><kbd>ADMINISTRATION</kbd></li>
</ul>
<p>To make it work, we have to enable it using <kbd>@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)</kbd>. We are now ready to put annotations in place to start access controlling domain objects. A code snippet in which Spring ACL is used is as follows:</p>
<pre>@PostFilter("hasPermission(filterObject, 'READ')")<br/>List&lt;Record&gt; findRecords();</pre>
<p>After querying for records (post-filtering), the result (a list) is scrutinized, and filtering takes place to only return the object to which the user has <kbd>READ</kbd> permission. We can also use <kbd>@PostAuthorize</kbd> as follows:</p>
<pre>@PostAuthorize("hasPermission(returnObject, 'READ')")</pre>
<p>After execution of the method (<kbd>@Post</kbd>), if the user has <kbd>READ</kbd> access on the object, it is returned. Otherwise, it throws an <kbd>AccessDeniedException</kbd> <span>exception:</span></p>
<pre>@PreAuthorize("hasPermission(#movie, 'WRITE')")<br/>Movie save(@Param("movie")Movie movie);</pre>
<p>Before the method is fired (<kbd>@Pre</kbd>), it checks whether the user has the <kbd>WRITE</kbd> permission on the object. Here, we use the parameter being passed into the method to check for user permission. If the user has permission to <kbd>WRITE</kbd>, it executes the method. Otherwise, it throws an exception.</p>
<p>We can have a fully fledged example of this, but we are already stretched by the number of topics that this book can cover. So I will leave it just here, and I am sure you now have enough information to make a complete implementation.</p>
<p>Some of the common built-in Spring expressions regarding security are as follows:</p>
<div>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Expression</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasRole([role_name])</kbd></p>
</td>
<td>
<p>If the current user has <kbd>role_name</kbd>, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasAnyRole([role_name1, role_name2])</kbd></p>
</td>
<td>
<p>If <span>the </span>current user has any of the role names in the list, <span>it </span>returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasAuthority([authority])</kbd></p>
</td>
<td>
<p>If <span>the </span>current user has specified authority, <span>it </span>returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasAnyAuthority([authority1, authority2])</kbd></p>
</td>
<td>
<p>If <span>the </span>current user has any of the authorities in the specified list, <span>it </span>returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>permitAll</kbd></p>
</td>
<td>
<p>Always equates to <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>denyAll</kbd></p>
</td>
<td>
<p>Always equates to <kbd>false</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>isAnonymous()</kbd></p>
</td>
<td>
<p>If <span>the</span><span> </span>current user is anonymous, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>isRememberMe()</kbd></p>
</td>
<td>
<p>If <span>the</span><span> </span>current user has set remember-me, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>isAuthenticated()</kbd></p>
</td>
<td>
<p>If <span>the</span><span> </span>current user is not anonymous, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>isFullyAuthenticated()</kbd></p>
</td>
<td>
<p>If the current user is not anonymous or remember-me user, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasPermission(Object target, Object permission)</kbd></p>
</td>
<td>
<p>If the current user has permission to target object, it returns <kbd>true</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>hasPermission(Object targetId, Object targetType, Object permission)</kbd></p>
</td>
<td>
<p>If the current user has permission to target object, it returns <kbd>true</kbd></p>
</td>
</tr>
</tbody>
</table>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other Spring Security capabilities</h1>
                </header>
            
            <article>
                
<p><span>Spring Security has a number of capabilities apart from core security features, authentication and authorization. Some of the most important ones are listed here. In <a href="8fd292f5-44c6-4cfb-b9cb-9a1bdb677624.xhtml">Chapter 7</a>, <em>Spring Security Add-Ons</em>, we will go through each of these in more detail using hands-on coding. We will build on the example that we have created in this chapter and explain each of these very important Spring Security capabilities:</span></p>
<ul>
<li><strong>Remember-me authentication</strong>: This is also known as persistent-login, and it allows websites to remember a user's identity in between multiple sessions. Spring Security provides a couple of implementations (hashed-token-based and persistent-token-based) that make this easy.</li>
<li><strong>Cross Site Request Forgery</strong> (<strong>CSRF</strong>): This is a very common security exploit employed by hackers to do unethical operations, whereby unauthorized commands are sent on behalf of the user. Spring Security allows us to fix this exploit easily with configurations.</li>
<li><strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>): This is a mechanism by which a web application running on a particular domain can access resources exposed in another domain by adding additional HTTP headers. This is one of the security mechanisms employed to make sure that only legitimate code can have access to resources exposed by a domain.</li>
<li><strong>Session management</strong>: Proper user session management is key to any application's security. Here are some of the important session-related functions that Spring Security takes care of easily:
<ul>
<li><strong>Session timeout</strong>: This makes sure that user sessions time out at the configured value, and this cannot be hacked.</li>
<li><strong>Concurrent session</strong>: This prevents users from having multiple (configured value) sessions active within the server.</li>
<li><strong>Session fixation</strong>: This is a security attack that allows the attacker to hijack a valid user's session and then start using it for unethical operations.</li>
</ul>
</li>
</ul>
<p>These are some of the important features that Spring Security brings to the table. We will thoroughly explore them after covering additional topics that are relevant to Spring Security.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter aimed at introducing two important security concepts, namely authentication and authorization, and how they are supported by Spring Security.</p>
<p>We started by explaining these concepts in detail and then dived into them with the help of a sample application. We have used Spring MVC application as a base to help you understand Spring Security concepts. <a href="5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml"/><a href="5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml">Chapter 4</a>, <em><span>Authentication Using CAS and JAAS</span></em>, is aimed at explaining reactive web application framework, Spring WebFlux.</p>
<p>In the next chapter, we will go through other authentication mechanisms supported by Spring Security by extending the example that we have built in this chapter.</p>


            </article>

            
        </section>
    </body></html>