- en: 'Chapter 3: Common Architecture Design Techniques'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034),
    *Software Requirements – Collecting, Documenting, Managing*, we highlighted techniques
    to retrieve and analyze the features an application should have. This is done
    by interacting with the business and other stakeholders and describing what the
    desired behavior should be. We now have all the ingredients needed to start baking
    our application. The first—very important—step is to define the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is debated as to how much, in terms of resources, you should invest in this
    phase. Some experts argue that architecture design is the most important phase,
    while others claim that it's crucial to keep a flexible approach, being able to
    adapt the architecture while the solution is evolving according to new ideas coming
    in or shifting external conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For sure, both ideas are interesting and have some strong points. Whatever your
    point of view on that is, it is really useful to have a clear understanding of
    what the most common ways of documenting the architectures you will design are.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a topic we started to touch on in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*. But while in
    the first chapter the idea was to start sketching some ideas and brainstorm potential
    solutions, in this chapter, we will cover a detailed design. This means exploring
    different modeling techniques, walking through notation and diagram types, and
    creating artifacts that are shareable and clear to understand for other team members.
    In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing marchitectures—impactful and purely demonstrative schemas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarizing ourselves with **Unified Modeling Language** (**UML**) notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring **ArchiMate**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the **C4 model**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other modeling techniques – **Business Process Model and Notation** (**BPMN**),
    **Decision Model and Notation** (**DMN**), and **arc42**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But first of all, let''s start by having a look at a less structured but widely
    used architectural style, with a funny and a bit of an ugly name: **marchitectures**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing marchitectures – impactful and purely demonstrative schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With its name being a portmanteau of marketing and architecture, as you can
    imagine, **marchitectures** are a very common tool to pitch your solution and
    get sponsorship (and often the budget) for your project. You don't need to get
    into technical details, nor to cover every aspect of the solution; the idea here
    is to give an idea of what the finished product will look like.
  prefs: []
  type: TYPE_NORMAL
- en: From a content point of view, marchitectures are no more and no less than a
    polished version of the first whiteboard sketches of a software architecture.
    This includes the same vague meaning, incomplete vision, and mixed point of view
    that we discussed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*.
  prefs: []
  type: TYPE_NORMAL
- en: Marchitectures often complement mockups of the **User Interface** (**UI**),
    marketing research, and industry trends. You want to convince the stakeholders
    (budget owners, investors, and so on) that your idea is a good one and that the
    underlying architecture (and implementation) will be rock-solid, yet flexible
    enough to follow the evolutions that the business will drive.
  prefs: []
  type: TYPE_NORMAL
- en: It is definitely an ambitious goal and is sometimes—inevitably—not fully met.
    Indeed, the real architecture will often only partially look like what you defined
    in your marchitecture.
  prefs: []
  type: TYPE_NORMAL
- en: Marchitectures are often used by software vendors and for good reason. If you
    are pitching a product (or a framework, or a service), you don't want to be too
    specific on what the finished solution will look like. You just need to give a
    high-level idea of how your product works. Maybe authentication will be different,
    and maybe you will need to integrate third-party systems into the final picture,
    but the important thing is to have a shiny picture of how good your architecture
    (marchitecture) looks. There is time to get into the nitty-gritty details later.
    UML notation, which we will look at in the next section, is a very good way to
    document those details.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarizing ourselves with UML notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are things in this book that we need to treat with reverential respect;
    **UML** is one of them. This modeling language is simply a piece of IT history.
    You should take into account that UML is a very comprehensive and articulate standard,
    aimed at modeling and representing a wide number of concepts. For this reason,
    going through the whole specification is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: But by the end of this section, you will have a grasp of the UML philosophy,
    and we will have covered practical examples of the most widespread UML diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It's worthwhile deepening your knowledge of the UML language. To do this, you
    will find plenty of resources on the web. I would also suggest you have a look
    at the official UML website, and at *The Unified Modeling Language User Guide*
    by Booch, Rumbaugh, and Jacobson (more information is available in the *Further
    reading* section of this chapter), which is probably the most important UML book,
    written by the original authors of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the fascinating UML genesis in the next section, where
    we will see how UML started as a joint effort by different working groups that
    were all working to solve a common problem: defining a language to break the barrier
    between designing and implementing a software solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the background to UML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UML's history began in the 1990s and is strictly related to **object-oriented
    programming**.
  prefs: []
  type: TYPE_NORMAL
- en: UML was born from an effort to standardize object modeling and the conceptual
    representation of object-oriented software. A further objective was to create
    an object that is both human- and machine-readable, supporting the life cycle
    starting from analysis, and moving toward implementation and testing.
  prefs: []
  type: TYPE_NORMAL
- en: The history of the UML standard starts with a cross-company, meritocratic effort
    to find a solution to common problems. This looks a lot like the open source development
    model. Everybody is free to contribute and share ideas with the community, regardless
    of their role or the company they are working for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an overview of what's contained in the UML framework.
  prefs: []
  type: TYPE_NORMAL
- en: Walking through the UML basics, as we discussed, UML was created to model object-oriented
    systems, and in theory, diagrams created with UML can be automatically translated
    into source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of interesting principles in the UML language, making it
    just as useful and relevant today, more than 20 years after its inception, as
    when it was created. Let''s have a look at some of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: UML is independent of the development methodology, meaning that it can be used
    even in modern Agile and **DevOps** teams. Some of the diagrams introduced by
    UML are commonly used in those contexts too. The goal of the language is to visualize,
    specify, construct, and document OO systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML is usually associated with diagrams and graphical artifacts. While they
    are, indeed, a core concept of the language, UML also defines the related semantics.
    This means that the reasoning for everything is well defined and formalized so
    that both a trained person and a machine can understand what a UML diagram represents
    in all its details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML concepts are built upon three different kinds of building blocks—namely,
    **things**, **relationships**, and **diagrams**. These are further organized into
    subcategories. For each of those concepts, a graphical representation (symbol)
    is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These building blocks are covered in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Things** are core entities that have the goal of abstracting concepts represented
    by the system. Things are further grouped into other subtypes, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural things**: These are the most essential elements in object-oriented
    programming (such as classes and interfaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral things**: These represent interactions (such as messages and actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping things**: These are used to organize other things (packages are
    an example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Annotational things**: These support elements to document the models (such
    as notes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Relationships** model the links between things. These are further organized
    into four main categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BusinessLogic` component, providing validations, checks, and so on, and a
    `PaymentService` component, called from the `BusinessLogic` component in order
    to provide payment functionalities. A change in the methods of the `PaymentService`
    component will require a change in the BackendAPI that uses it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PaymentTransaction` component with a user. Each payment must reference at
    least one user of the platform (that is, the one making the payment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MobilePayment` interface is a specific type of `PaymentTransaction` component,
    inheriting from it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPaymentService` interface, and its practical implementation—such as `MobilePayment`—implementing
    one particular way of making a payment (and abstracting the caller from the implementation
    details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Diagrams** are schemas representing meaningful sets of things. They are technically
    graphs, which helps them to be easily read and written by machines. Diagrams can
    be classified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural**: Describing the static aspects of a system, such as the structure,
    grouping, and hierarchy of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: Describing the interactions between objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagrams are the most widely known concept of UML. It is very likely that you
    have already seen a class diagram or a sequence one. In my opinion, diagrams are
    one of the most useful UML concepts. For this reason, we will walk through the
    main types of diagrams in the following upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see a graphical representation of the UML
    things we''ve just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Graphical representation of some UML things'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Graphical representation of some UML things
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next diagram, we represent the graphical symbols of the UML relationships
    we''ve described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Graphical representation of some UML relationships'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Graphical representation of some UML relationships
  prefs: []
  type: TYPE_NORMAL
- en: With regard to UML diagrams, due to their relevance, we will walk through some
    of the most common ones in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the beginning of this section, we've made it clear that UML is all about
    **object-oriented** modeling, which is expected since **Java** (probably the most
    widespread object-oriented language) is one of the pillars of this book, and—of
    course—modeling classes are one of the most important aspects of object-oriented
    modeling. I'm pretty sure you've already seen (or used) class diagrams. They're
    a very common and natural way to represent classes and how they are made, and
    indeed are used in countless documentation on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: A class diagram is made up of a set of classes (including their fields and methods)
    and the relationships between them. Interfaces are represented where present,
    and so is inheritance between classes. As per the other diagrams, a class diagram
    is conceptually a graph, made up of arcs and vertices.
  prefs: []
  type: TYPE_NORMAL
- en: A class diagram is intended to highlight a specific subset of the whole architecture,
    so the class represented is part of a given use case or belongs to a specific
    subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noticing that the relationships will represent both the kind of
    cooperation/responsibility between the classes and the multiplicity of the relationship
    itself (for example, one-to-many, one-to-one, and similar cardinalities). This
    is what a basic class diagram looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Basic class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Basic class diagram
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a class diagram is a great way to model the structure of a logical
    subdomain of the application (objects and their links). In the next section, we
    will look at sequence diagrams, which are another very widespread representation,
    focusing more on the end-to-end interactions needed to implement the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **sequence diagram** is probably one of the most famous UML diagrams. This
    diagram is a particular instance of so-called interaction diagrams, which are
    a representation of a set of objects (such as software components and actors)
    and how they interact (for example, exchanging messages). In the case of sequence
    diagrams, the interaction is pictured in a linear way, representing interactions
    ordered by the temporal dimension.
  prefs: []
  type: TYPE_NORMAL
- en: From a graphical viewpoint, a sequence diagram pictures objects in a row, each
    one with a line going down vertically (also known as a **lifeline**). Crossing
    those lifelines, interactions are laid out as horizontal lines, intersecting the
    involved objects.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence diagram also offers a way to represent conditions and iterations.
    **Conditions**, **parallelization**, **loops**, and **optional** are represented
    by drawing a box around the interactions and tagging the box with the right keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Given the nice level of detail that can be expressed by the message flow (including
    the time ordering) and the expressiveness provided by the structured controls
    (conditions and such), sequence diagrams are a very nice way to analyze and document
    functionalities, by breaking them up into smaller operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a sequence diagram looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Sequence diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Sequence diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the first row of the diagram, we have in this case a user
    and two components, whereby the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: Each one of them has a lifeline, which is highlighted to represent activation
    when an interaction is made (for example, a method is called, or a message is
    sent).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A self-message is pictured as a curved line, representing the call of a method
    on the same component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loop is represented as a frame with a tag. In the tag, other than loops, `opt`
    (`par` (`alt` (`opt` identifies an optional interaction that will happen only
    if a specified condition is met (such as an `if` block), `par` represents a parallel
    interaction (such as two methods called in parallel in a multithread fashion),
    and `alt` matches alternative conditions, such as an `if`/`else` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same kind of notation (box with a tag) can be used to represent sub diagrams.
    In this case, the tag has a `ref` value, while the name of the diagram representing
    that part is reported in the box. This provides a simple way of breaking down
    big and complex sequence diagrams into smaller ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this look at sequence diagrams, we have completed our very brief overview
    of the most common UML ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up on UML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said at the very beginning of this section, UML is a big and complete
    framework that is too complex to summarize in just a few pages. However, the essential
    concepts we have seen so far (including class diagrams and sequence diagrams)
    are a good way to start getting used to this language and add some useful tools
    to your toolbox. Of course, my advice is to go deeper and get to know more diagrams
    and techniques from this awesome language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we are going to explore a technique that shares many similarities
    with UML: ArchiMate.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ArchiMate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ArchiMate** is an architectural modeling technique aimed at analyzing and
    documenting enterprise architectures. This means that, while still having roots
    in technology and software, it''s usually adopted in projects with a broader scope,
    such as documenting the whole enterprise technology landscape (also known as **enterprise
    architecture**) and modeling the business processes implemented by the underlying
    technology implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: ArchiMate's name is a merging of *architecture* and *animate*, implying that
    one goal of this framework is to display the enterprise architecture in an intuitive
    way. ArchiMate was created in the early 2000s in the Netherlands, the result of
    a concerted effort from players in the government, industry, and academic sectors.
    Soon after the first drafts of this standard, the governance was transferred to
    **The Open Group**, an industry consortium regulating many other IT standards,
    such as **The Open Group Architectural Framework** (**TOGAF**, which is an enterprise
    architecture standard) and the **Single Unix Specification** (**SUS**, which is
    a **Portable Operating System Interface** (**POSIX**)-standard superset). The
    Open Group is also behind other famous standards in the Java world, such as **Service
    Oriented Architecture** (**SOA**) and **eXtended Architecture** (**XA**).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the ArchiMate Core Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The ArchiMate Core and Full Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first concept to approach in ArchiMate is the **Core Framework**. The ArchiMate
    Core Framework is a 3x3 matrix, created by crossing three layers (**Business**,
    **Application**, and **Technology**) stacked with three aspects (represented vertically:
    **Passive Structure**, **Behavior**, and **Active Structure**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the Core Framework matrix looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – ArchiMate Core Framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – ArchiMate Core Framework
  prefs: []
  type: TYPE_NORMAL
- en: 'The layers are a way to look at the same concept (or closely related concepts)
    from three different perspectives. In a way, a concept in one layer makes use
    of or is linked to concepts in nearby layers. You can see the three layers as
    a specification from the more abstract (business) to the more concrete (technology),
    as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Business** layer revolves around business capabilities, usually offered
    to the external world (for example, final customers). This includes business processes,
    events, and functions related to high-level capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Application** layer includes the software components offering capabilities
    to the **Business** layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Technology** layer is the technical infrastructure supporting the software
    components, including hardware and communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aspects are a way to classify objects by their role in an activity, as
    outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active Structure** includes the elements starting an action (including actors,
    devices, and software components).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior** includes the action itself being made by something in the **Active
    Structure** aspect (such as an actor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passive Structure** includes the objects on which the activity is made (for
    instance, the recipient of the action itself, such as a data object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should take into account the fact that some objects can be part of more
    than one aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see, the Core Framework provides a simple way to place and categorize
    objects, and it enables multiple viewpoints. Also, take into account that ArchiMate
    diagrams do not necessarily follow this matrix layout: this is merely a conceptual
    way to demonstrate layers and aspects and how they are related.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ArchiMate standard also provides an extended version of the framework.
    In this framework, three more layers are added, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy**, on top of the **Business** layer, aims to link business functionalities
    and use cases to the pursuit of strategic objectives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physical**, technically a subset of the **Technology** layer, is used to
    represent materials, physical objects, facilities, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation and Migration** is used to model all the temporary components
    supporting transitory phases during implementation and migration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fourth aspect, called **Motivation**, is also included in the extended framework.
    The goal of this aspect is to map and represent the strategic reasons behind the
    other architectural choices. In particular, you will see components such as value,
    goal, and stakeholders used to model the reason behind specific domains or use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the Full Framework looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – ArchiMate Full Framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – ArchiMate Full Framework
  prefs: []
  type: TYPE_NORMAL
- en: As per the Core Framework, this is just a logical model aimed to highlight areas
    of overlap between the layers and aspects. ArchiMate-compliant schemas will not
    necessarily come in a matrix format.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see the components of ArchiMate, which are the
    objects categorized according to the matrices we've just seen.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the ArchiMate language tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ArchiMate language is conceptually structured as a tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The top concept is the **model**, defined as a collection of concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **concept** is a generic term that can be characterized as an element or a
    relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **element** is a generic item that maps to a definition of the layers—that
    is, **Behavior**, **Active Structure**, or **Passive Structure**. An element is
    also allowed as part of the **Motivation** aspect (as per the Full Framework).
    Composite elements are intended as aggregations of other concepts. **Active Structure**
    and **Behavior** elements can further be classified as **Internal** or **External**.
    An event is a further specialization of a **Behavior** element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **relationship** represents the connection between two or more concepts. Relationships
    are further classified as **Structural** (elements are statically associated to
    create another element), **Dependency** (elements may be affected by changes in
    other elements), **Dynamic** (elements have temporal dependencies to other elements),
    or **Other**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationship connectors** are logical junctions (**And**, **Or**), associating
    relationships of the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is what the tree will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – ArchiMate language tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – ArchiMate language tree
  prefs: []
  type: TYPE_NORMAL
- en: In this classification, elements are just defined in an abstract way, not dependent
    on layers. In ArchiMate modeling, concrete implementations of those elements are
    then instantiated and classified in the relevant layer. As an example, a service
    is a generic internal **Behavior** element. It will then be used in the form of
    a business service, application service, or technology service, depending on which
    layer we are modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Other elements only make sense in a specific layer. For example, a communication
    network is an element property of the **Technology** layer, classified as an **Active
    Structure** element that doesn't have a one-to-one correspondence to elements
    present in other layers.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of elements and relationships can then be organized into custom
    views, effectively building architectural diagrams, optimized by stakeholders
    and viewpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to compare ArchiMate with UML.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing ArchiMate to UML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have seen, the ArchiMate language shows some similarities to UML.
    That is not by accident: ArchiMate is indeed inspired by UML, and some concepts
    of the two frameworks are almost the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, other than specific differences (for instance, concepts present in
    one framework and not in the other), there are some high-level considerations
    to take into account when comparing those two frameworks, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: UML is strictly centered around object-oriented modeling, while ArchiMate is
    not linked to a specific paradigm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArchiMate explicitly defines the **Business** layer and other higher-level concepts
    (including **Motivation** and **Strategy**) that are usually not contemplated
    in UML diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UML provides a fixed set of diagrams, while ArchiMate is more of a palette of
    different components and aspects, aimed at building views and viewpoints, explicitly
    providing ways of customizing the architecture definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw when we covered the ArchiMate genesis at the beginning of this section,
    The Open Group is the organization behind many other standards, including TOGAF.
    Let's see what the relationship between ArchiMate and TOGAF is.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing ArchiMate to TOGAF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TOGAF** is a complete framework, aimed at providing a standardized way of
    defining, modeling, and implementing architecture projects (for example, classifying
    the enterprise architecture of an organization). TOGAF is, in a way, complementary
    to ArchiMate. While TOGAF does not provide a specific architectural notation (as
    ArchiMate does), ArchiMate does not prescribe a specific process for architecture
    definition (as TOGAF does).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core of TOGAF is the **Architecture Development Method** (**ADM**) process.
    The process is made up of eight steps (plus two special phases: the preliminary
    phase and requirements collection). A detailed explanation of each step is beyond
    the scope of this book, but the important takeaway is that each phase of the TOGAF
    ADM can be mapped as a layer into the ArchiMate framework (for instance, Phase
    B, which is about the definition of business architecture, of course maps to the
    **Business** layer, while Phase F, Migration Planning, can be mapped to the **Implementation
    and** **Migration** layer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the section dedicated to ArchiMate. In the next section, we
    will go through another very smart architectural modeling technique: the C4 model.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C4 model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **C4 model** is a lightweight methodology for modeling and representing
    software architecture. It was created in 2006 by Simon Brown, and the official
    website (under a **Creative Commons (CC) License**) was launched in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: The model is somewhat inspired by UML, but it takes an alternative, leaner approach
    and, for this reason, is very popular among Agile teams who are looking for a
    more dynamic and less prescriptive way of designing and documenting software architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the C4 model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The keyword for understanding the C4 model is *zoom*. This concept means exactly
    what it does for pictures: the core idea of the C4 model, indeed, is about navigating
    the architectural representation by widening or narrowing the point of view. The
    C4 model is built around four main levels, detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context** is a diagram giving the big picture of an application. It shows
    the whole system represented as a box and depicts interactions with users and
    other systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container** is the view obtained when zooming in one level down. It represents
    what''s inside the system box by modeling the subsystems comprising it. In terms
    of granularity, a container is something that can be deployed and executed—so,
    it can represent a backend application, a database, a filesystem, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component** is another zoom level, looking inside one container. In essence,
    a component is an abstraction grouping of a set of code instances (for example,
    a bunch of classes) that implement a functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code** is the maximum level of zoom in this hierarchy and can be omitted.
    It''s used to directly represent source code and configurations. The C4 model
    does not provide a specific suggestion on how to draw this kind of schema, which
    is usually represented using UML class diagrams. The reason why it''s considered
    optional is that it is not very easy to keep this view up to date with code changes.
    A suggestion here is to try to stick to the automatic generation of this diagram
    if possible (by using plugins for the integrated development environments or other
    automated procedures).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the C4 model, in essence, is made up of three different diagrams (plus
    an optional one). Each diagram is linked to the others by a different level of
    zoom, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – C4 zoom levels'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B16354_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – C4 zoom levels
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this technique is to focus on a different ecosystem based on
    the level of zoom. Moreover, different views can be aimed at different stakeholders.
    In the next section, we will see what's inside each level.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the different levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C4 model does not provide any particular notation or symbology. Unlike UML,
    the kind of shapes, color coding, and so on are not part of the standard. The
    model simply encourages you to have a consistent representation (for example,
    once you choose a shape to represent an element, keep that shape in all the diagrams),
    to add an explicit legend to each diagram, and to comment as much as possible,
    for better clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'C4 is made up of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software system**: The top-level element, the center of the *context* representation.
    This is basically the whole system that we are going to design and implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container**: As we mentioned when discussing the level with the same name,
    a container is roughly something that can be deployed and started/stopped individually.
    This includes applications, databases, and so on. It''s usually completed with
    a description of the technology and framework used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component**: As before, this is a concept already introduced when discussing
    levels. A component is an abstraction aggregated over a subdomain or functionality.
    It''s basically a grouping of code. It may or may not map one-to-one to a Java
    package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationship**: A line (or, more often, an arrow) representing a link between
    one of the aforementioned elements. It''s usually completed with a textual explanation
    of the kind/scope/goal of the relationship, and technical details where relevant
    (for instance, the protocol used).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Person**: A human interacting with the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you will see, there is no explicit advice for representing the code. It's
    a common practice to represent it with UML classes but, as we said before, this
    is something that is only done if strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, C4 also includes some additional diagrams, as
    outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System landscape**: A context diagram showing the whole enterprise, in order
    to represent the full *neighborhood* of our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: A diagram representing a use case by numbering the interactions
    between elements in order to show the temporal progression. It looks quite similar
    to the UML sequence diagram but is less prescriptive in terms of syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: This shows the mapping between containers and the underlying
    infrastructure, which may be a physical server, a virtual machine, a **Linux**
    container, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these diagrams, we have completed our excursus on the C4 model. As you
    will see, this model is simpler than UML and ArchiMate but still quite complete
    and expressive, meaning that you can model a lot of architecture types with it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore other modeling techniques that
    are less common and aimed at specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Other modeling techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three modeling systems we have seen so far—UML, ArchiMate, and C4—are complete
    systems with different approaches, aimed at analyzing and representing software
    architecture end to end.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to quickly touch on some other techniques that
    have a more vertical approach, meaning that they are less general-purpose and
    more detailed when it comes to targeting specific use cases. Those techniques
    are **Business Process Model and Notation** (**BPMN**), **Decision Model and Notation**
    (**DMN**), and **arc42**.
  prefs: []
  type: TYPE_NORMAL
- en: BPMN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BPMN** is a standard that was developed and is currently maintained by the
    **Object Management Group** (**OMG**), the same organization behind UML. BPMN
    is also a standard that has been recognized by the **International Organization
    for Standardization** (**ISO**).'
  prefs: []
  type: TYPE_NORMAL
- en: As may be obvious by its name, this language specializes in representing business
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: BPMN is usually associated with the activity diagram of UML, as both are flow
    chart-like diagrams (with a slightly different notation and symbology), aimed
    at describing a use case in terms of elementary steps and the connections between
    them (for instance, optional conditions), including a temporal dimension (from-to).
    But the similarities end there.
  prefs: []
  type: TYPE_NORMAL
- en: UML is wider and aimed at modeling a lot of other things, rather than being
    fundamentally an object-oriented framework. On the other hand, BPMN focuses just
    on the modeling of business processes, and its primary goal is to define common
    ground between technical and business stakeholders. Indeed, the idea behind BPMN
    is that a businessperson (or better, someone with no technical skills but a good
    knowledge of processes) can model a diagram that can then be directly imported
    and executed into a BPMN engine, with little-to-no help from technical staff.
    This is not something that happens in the real world, as often, BPMN design is
    still an abstraction, and a number of technical steps are still needed to configure,
    deploy, and execute a BPMN process.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's true that BPMN is usually at least understandable (if not definable
    from scratch) by non-technical stakeholders. This is good enough for supporting
    collaboration between teams and reducing friction when translating business processes
    into code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The building blocks of BPMN are categorized as four basic families: **flow
    objects**, **connecting objects**, **swimlanes**, and **artifacts**. For each
    of them, a graphical notation is formalized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly speaking, **flow objects** represent the steps in the diagram and are
    described in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: The most important one is probably the **task**, which is the abstraction of
    generic activity. This means both non-automatic activities (manually performed
    outside of the BPMN platform) and automatic activities (such as sending an email
    or triggering a web service call).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other basic flow objects are **start** and **end** events, delimiting the beginning
    and end of a workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateways** are another important kind of object, used to model things such
    as conditional execution or the parallelization of paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connecting objects** are used to link flow objects with one another. They
    can mimic different behaviors, such as sequences, messages, or associations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swimlanes** are a way to graphically group and organize a business process.
    With swimlanes, you partition the business process according to the actor (or
    group of actors) in charge of a specific set of steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **artifacts** are supporting concepts (for example, annotations), aimed
    at enriching the BPMN flow expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what all these objects look like graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Graphical representation of some BPMN entities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Graphical representation of some BPMN entities
  prefs: []
  type: TYPE_NORMAL
- en: We will talk again about BPMN in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: DMN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DMN** is a standard published and maintained by OMG, and it''s younger than
    BPMN. DMN is somewhat complementary to BPMN. Instead of being aimed at modeling
    business processes, the scope of DMN is to model business rules, which are commonly
    used as one of the tasks in BPMN processes, rather than standalone, outside of
    BPMN processes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is exactly the same as BPMN: defining a common language between business
    and IT personas, allowing for better collaboration.'
  prefs: []
  type: TYPE_NORMAL
- en: DMN encompasses elements such as decision tables (tables representing rule outcome
    based on the combination of a set of inputs) and **Friendly Enough Expression
    Language** (**FEEL**), an expression language used to formalize the logic behind
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about DMN again in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: arc42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**arc42** is not a modeling technique but, instead, a templating model that
    helps with identifying, in software architecture, what the important concepts
    to document are and how to document them, by providing a kind of *scaffold*.'
  prefs: []
  type: TYPE_NORMAL
- en: arc42 was originally created by Dr. Peter Hruschka and Dr. Gernot Starke and
    has a completely open source approach (including being free to use in commercial
    projects). It's an exceptional way to start documenting your system from scratch,
    from an architectural point of view. From a practical viewpoint, it provides a
    scaffold (including sections to be fulfilled) on what the documentation should
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a substitute for other modeling languages and does not mandate a specific
    working model or development techniques. Instead, it is expected that you will
    use concepts and diagrams from other techniques (such as UML or C4) to fill out
    the sections of arc42-compliant documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Sections include elements such as the introduction, runtime view, cross-cutting
    concepts, architectural decisions, and more. It is really just a suggestion on
    the structure of the documentation; it's up to you to choose how deep to dive
    into each section. If you want to give it a try, you can go to the official website
    (see the *Further reading* section), download a template, and start to fill out
    the sections. It really is that easy.
  prefs: []
  type: TYPE_NORMAL
- en: BPMN, DMN, and arc42 cover specific niches and target specific needs. For this
    reason, they can be a useful complement to the more generic and comprehensive
    frameworks that we have seen before. With this section, we've completed our overview
    of architectural modeling techniques. Let's now complete this chapter by looking
    at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, as in previous ones, we will continue our study of the mobile
    payments application. We will keep exploring this context to see some examples
    of the diagrams we have discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: UML class diagrams for mobile payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a first example, we will look at UML class modeling. This is a very common
    diagram in Java projects. It is debated whether it's useful to build and maintain
    documentation that is so close to code (see also the considerations we discussed
    in the section on C4), since it may be seen as not adding that much value and
    being hard to maintain. Moreover, in modern development models (such as cloud-native
    and microservices), you are supposed to communicate between parts of the application
    by using established interfaces (such as **REpresentational State Transfer** (**REST**)
    or **Google Remote Procedure Call** (**gRPC**) and avoid exposing the internal
    model of your applications for others to tap into.
  prefs: []
  type: TYPE_NORMAL
- en: My personal view is that the truth is in the middle. Unless you are developing
    something very peculiar (such as a framework, a library, or a plugin extension
    system), you may not need to document your entire code base as class diagrams.
    However, in order to analyze impacts and collaborate with other team members on
    the same code base, it may be worthwhile to at least sketch the critical aspects
    of your application (this being the core classes and interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: Another useful technique is to rely on the automatic generation of class diagrams.
    You may find plugins for most commonly used IDEs and also for Maven that can do
    that for you. Class diagrams can be particularly useful for giving an idea of
    what the model behind your code looks like (think about a new team member joining
    the project) and can ease things such as refactoring by giving an idea of what
    impact a change could have on related classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a class diagram for mobile payments will look like (picking just
    a handful of significant classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – UML class diagram for payment and user objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – UML class diagram for payment and user objects
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, we are representing the `Payment` and
    `User` classes (some methods and fields are omitted for the sake of space).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notations we used in this diagram are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MobilePayment` is a subclass of `Payment` (generalization).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Payment` implements the `Auditable` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment is associated with `User`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also see the multiplicity (each user can have **n** payments). As we
    discussed before, this kind of association is very similar to what you can find
    in an entity relationship diagram representing database tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will see some C4 diagrams for mobile payments.
  prefs: []
  type: TYPE_NORMAL
- en: C4 diagrams for mobile payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the section dedicated to C4 diagrams, we saw that the C4 technique involves
    diagramming the system according to four main levels of zoom. As discussed, the
    last level of zoom (code) is optional, and there are no strict guidelines given
    on how to represent it. It is common to use class diagrams, as we did in the previous
    section. Supposing we take that as one of the four representations for our use
    case, let''s see what the path is that takes us to that schematization. Let''s
    start with the context diagram of a module of the mobile payments solution, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – C4 context diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – C4 context diagram
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this is very high-level, aimed at showing the ecosystem of interactions
    around our system. The mobile payment application is just a big block, and in
    the diagram, we summarize the external system and the actors interacting with
    it. There is also a synthetic description of the interactions (including the format/protocol)
    and the type of each element (software system, person).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now zoom into the container view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – C4 component diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – C4 component diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see a closer representation of the technical pieces comprising
    our application. Our application is no longer just a box: we can see all the processes
    (things that can be deployed and started independently from one another) that
    comprise our system included in the dashed box. External context is still present
    (for example, the transactional backend). Every interaction has some explanation
    and protocol. Every container has a generic description of the kind of technology
    that is implementing it. If you think this diagram is pretty similar to what we
    saw in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013), *Designing
    Software Architectures in Java – Methods and Styles*, you are right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are still a bit far from the code/class diagram. The component diagram is
    the missing link. We can view this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – C4 container diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – C4 container diagram
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we zoomed in one level deeper, highlighting three components that
    comprise the business logic container (**Mobile Application Backend**, **Data
    Mapper**, and **Integration**).
  prefs: []
  type: TYPE_NORMAL
- en: With this container diagram, we are one step above the direct representation
    of the implementation code (code diagram).
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of space, we are not providing the full code diagram here. However,
    the classes modeled as UML in the section before can be seen as a partial code
    diagram of the **Data Mapper** component, somewhat closing the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Those were very basic examples to show some bits of the modeling techniques
    in practice. Of course, giving detailed examples on every methodology shown in
    this chapter would have taken a whole book (or more than one) on its own, but
    I hope to have given you some basics to start from and deep dive into, in case
    you need to start practicing one of these diagrams for your projects. Let's now
    recap the main points of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a wide range of techniques for modeling and representing
    the internal architecture of a software system. We started with UML, which is
    a consolidated standard that is very widespread and actively used, especially
    in some of its aspects, such as class diagrams and sequence diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to ArchiMate, which gives an enterprise architecture point
    of view on the subject and is commonly used in a context that follows the TOGAF
    approach. We then moved on to the C4 approach, which is a younger standard that
    is very lightweight and particularly suitable for projects adopting lean methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: We've also seen a handful of specialized languages (BPMN and DMN), which are
    perfect for modeling specific aspects of our application. Last but not least,
    we quickly touched on arc42, which is a wonderful template system to start your
    architecture documentation and ensure that nothing important is missing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss **Domain Driven Design** (**DDD**) and
    other techniques to flesh out your application, which you can use once you have
    defined the architecture for it.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UML official website: [http://uml.org/](http://uml.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Unified Modeling Language User Guide*, by Grady Booch, James Rumbaugh,
    and Ivar Jacobson, published by Addison-Wesley, 1999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Open Group, *ArchiMate® 3.1 Specification*: [https://pubs.opengroup.org/architecture/archimate3-doc/](https://pubs.opengroup.org/architecture/archimate3-doc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'InfoQ, *The C4 Model for Software Architecture*: [https://www.infoq.com/articles/C4-architecture-model/](https://www.infoq.com/articles/C4-architecture-model/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C4 official website: [https://c4model.com/](https://c4model.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The arc42 official website: [https://arc42.org/](https://arc42.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
