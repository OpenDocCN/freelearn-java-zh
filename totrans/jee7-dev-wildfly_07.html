<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Adding Web Services to Your Applications</h1></div></div></div><p class="calibre8">In the previous chapter, we discussed the Java Messaging Service API, which is commonly used to develop loosely coupled applications and a common integration pattern for Java-to-Java systems. In this chapter, you will learn about web services that are defined by W3C as software systems, and designed to support interoperable machine-to-machine interaction over a network.</p><p class="calibre8">What makes web services different from other forms of distributed computing is that information is exchanged using only simple and nonproprietary protocols. This means the services can communicate with each other regardless of location, platform, or programming language. Essentially, web services protocols provide a platform-independent <a id="id762" class="calibre1"/>way to perform <span class="strong"><strong class="calibre9">Remote Procedure Calls</strong></span> (<span class="strong"><strong class="calibre9">RPCs</strong></span>).</p><p class="calibre8">The <a id="id763" class="calibre1"/>focus of this chapter will be on the two chief web services standards, <span class="strong"><strong class="calibre9">JAX-WS</strong></span> (<span class="strong"><strong class="calibre9">JSR 224</strong></span>) and <span class="strong"><strong class="calibre9">JAX-RS</strong></span> (<span class="strong"><strong class="calibre9">JSR 339</strong></span>), and how they are implemented <a id="id764" class="calibre1"/>in WildFly. As you can imagine, there is a lot of ground to cover, so we will quickly get our hands dirty with the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A short introduction to SOAP-based web services</li><li class="listitem">Creating, deploying, and using the JBoss JAX-WS implementation (Apache CXF)</li><li class="listitem">A quick overview of REST web services</li><li class="listitem">How to create, deploy, and use services using the JBoss JAX-RS implementation (RESTEasy)</li><li class="listitem">Integrating JAR-RS with an external non-Java application</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications">
<div class="book" title="Developing SOAP-based web services"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec33" class="calibre1"/>Developing SOAP-based web services</h1></div></div></div><p class="calibre8">As<a id="id765" class="calibre1"/> stated, web services are based on the exchange of messages using nonproprietary protocol messages. The messages themselves are not sufficient to define the web service platform. We actually need a list of standard components, including the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A language used to define the interfaces provided by a web service in a manner that is not dependent on the platform on which it is running or the programming language used to implement it</li><li class="listitem">A common standard format to exchange messages between web service <span class="strong"><strong class="calibre9">providers</strong></span> and web service <span class="strong"><strong class="calibre9">consumers</strong></span></li><li class="listitem">A registry within which service definitions can be placed</li></ul></div><p class="calibre8">The <span class="strong"><strong class="calibre9">Web Service Description Language</strong></span>, also known as <span class="strong"><strong class="calibre9">WSDL</strong></span>, (<a class="calibre1" href="http://www.w3.org/TR/wsdl">http://www.w3.org/TR/wsdl</a>) is the de facto <a id="id766" class="calibre1"/>standard to provide a description of a web service contract exposed to clients. In particular, a WSDL document describes a web service in terms of the operations that it provides, and the data types that each operation requires as inputs and can return in the form of results.</p><p class="calibre8">Communication between the service provider and service consumer happens by means of XML messages that rely on the SOAP specification.</p><p class="calibre8">A basic SOAP message consists of an envelope that may contain any number of headers and a body. These parts are delimited by XML elements called <code class="email">envelope</code>, <code class="email">header</code>, and <code class="email">body</code>, which belong to a namespace defined by the SOAP specification. The following figure depicts the basic structure of a SOAP message:</p><div class="mediaobject"><img src="../images/00062.jpeg" alt="Developing SOAP-based web services" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications">
<div class="book" title="Developing SOAP-based web services">
<div class="book" title="Strategies to build SOAP-based web services"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec55" class="calibre1"/>Strategies to build SOAP-based web services</h2></div></div></div><p class="calibre8">As we <a id="id767" class="calibre1"/>have just discussed, the service description is provided by a commonly used document interface named WSDL that exposes the services as a collection of networks, endpoints, and ports, using the XML format.</p><p class="calibre8">You may logically be inclined to think that it is necessary to state the corresponding programming interfaces at the beginning of the contract of a service and then produce them.</p><p class="calibre8">Actually, you can follow two approaches to develop your SOAP web services:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Top-down</strong></span>: This development strategy involves creating a web service from a <a id="id768" class="calibre1"/>WSDL file. The<a id="id769" class="calibre1"/> top-down approach is likely to be used when creating web services from scratch. It is the preferred choice of pure web service engineers because it is business-driven, that is, the contract is defined by business people and so the software is designed to fit the web service contract.</li><li class="listitem"><span class="strong"><strong class="calibre9">Bottom-up</strong></span>: This <a id="id770" class="calibre1"/>approach <a id="id771" class="calibre1"/>requires the WSDL file to be generated by the programming interfaces. It is likely to be used when we have existing applications that we want to expose as web services. As this approach does not require a deep knowledge of the WSDL syntax, it is the easiest choice if you want to turn your Java classes or EJB into web services.</li></ul></div><p class="calibre8">As the audience of this book is composed mainly of Java developers with little or no knowledge of WSDL basics, we will focus primarily on the bottom-up approach.</p><p class="calibre8">Designing top-down web services, on the other hand, will require you to integrate the basic web services notions provided with this chapter with a comprehensive awareness of the WSDL standard.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications">
<div class="book" title="Developing SOAP-based web services">
<div class="book" title="JBoss SOAP-based web services stack"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec56" class="calibre1"/>JBoss SOAP-based web services stack</h2></div></div></div><p class="calibre8">All <a id="id772" class="calibre1"/>JAX-WS functionalities <a id="id773" class="calibre1"/>provided on top of WildFly are currently served through a proper integration of the JBoss web services stack with most of the <span class="strong"><strong class="calibre9">Apache CXF</strong></span> project.</p><p class="calibre8">Apache CXF is an open source web service framework that provides an easy-to-use, standard-based programming model to develop both SOAP and REST web services. The integration layer (JBossWS-CXF in short hereafter) allows us to perform the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use standard web services APIs (including JAX-WS) on a WildFly Application Server; this is performed internally by leveraging Apache CXF, without requiring the user to deal with it</li><li class="listitem">Leverage Apache CXF's advanced native features on top of a WildFly Application Server without the need for the user to deal with all the required integration steps to run the application in such a container</li></ul></div><p class="calibre8">Therefore, the focus of the next section will be on developing JAX-WS web services using<a id="id774" class="calibre1"/> the built-in Apache <a id="id775" class="calibre1"/>CXF configuration. If you want <a id="id776" class="calibre1"/>to further expand your knowledge about Apache CXF's native features, you can refer to the official documentation that is available at <a class="calibre1" href="http://cxf.apache.org/">http://cxf.apache.org/</a>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications">
<div class="book" title="Developing SOAP-based web services">
<div class="book" title="A brief look at the JAX WS architecture"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec57" class="calibre1"/>A brief look at the JAX WS architecture</h2></div></div></div><p class="calibre8">When <a id="id777" class="calibre1"/>a SOAP message sent by the client <a id="id778" class="calibre1"/>enters the web service runtime environment, it is captured by <a id="id779" class="calibre1"/>a component named <span class="strong"><strong class="calibre9">server endpoint listener</strong></span>, which, in<a id="id780" class="calibre1"/> turn, uses the <span class="strong"><strong class="calibre9">Dispatcher</strong></span> module to deliver the SOAP message to that service.</p><p class="calibre8">At this point, the HTTP request is converted internally into a SOAP message. The message content is extracted from the transport protocol and processed through the handler chain configured for the web service.</p><p class="calibre8">SOAP message handlers are used to intercept SOAP messages as they make their way from the client to the endpoint service and vice versa. These handlers intercept SOAP messages for both the request and response of the web service.</p><p class="calibre8">The next step is unmarshalling the SOAP message into Java objects. This process is governed by WSDL to Java Mapping and XML to Java Mapping. The former is performed by the JAX-WS engine, and it determines which endpoint to invoke from the SOAP message. The latter, performed by the JAXB libraries, deserializes the SOAP message so that it is ready to invoke the endpoint method.</p><p class="calibre8">Finally, the deserialized SOAP message reaches the actual web service implementation and the method is invoked.</p><p class="calibre8">Once the call is completed, the process is reversed. The return value from the web service method is marshalled into a SOAP response message using JAX-WS WSDL to Java mapping and JAXB 2.0 XML to Java mapping.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre8">The JAXB provides a fast and convenient way to bind XML schemas and Java representations, making it easy for Java developers to incorporate XML data and process functions in Java applications. As part of this process, JAXB provides methods to unmarshal XML instance documents into Java content trees, and then marshal Java content trees back into XML instance documents. JAXB also provides a way to generate XML schema from Java objects.</p></div><p class="calibre8">Next, the <a id="id781" class="calibre1"/>outbound message is processed by <a id="id782" class="calibre1"/>handlers before returning it to the dispatcher and endpoint listener that will transmit the message as an HTTP response.</p><p class="calibre8">The following diagram describes how data flows from a web service client to a web service endpoint and back:</p><div class="mediaobject"><img src="../images/00063.jpeg" alt="A brief look at the JAX WS architecture" class="calibre11"/></div><p class="calibre12"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Adding Web Services to Your Applications">
<div class="book" title="Developing SOAP-based web services">
<div class="book" title="Coding SOAP web services with WildFly"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec58" class="calibre1"/>Coding SOAP web services with WildFly</h2></div></div></div><p class="calibre8">In the<a id="id783" class="calibre1"/> first deliverable, we will show <a id="id784" class="calibre1"/>how easily you can turn a plain Java class into a web service. The newly created service will then be tested using a simple Eclipse-based testing GUI. The second part of this section will draw your attention to how EJBs can be exposed as web service endpoints by enhancing your ticket application with a web service.</p><div class="book" title="Developing a POJO web service"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec42" class="calibre1"/>Developing a POJO web service</h3></div></div></div><p class="calibre8">We <a id="id785" class="calibre1"/>will start developing<a id="id786" class="calibre1"/> web services, using our project from <a class="calibre1" title="Chapter 4. Learning Context and Dependency Injection" href="part0028_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre10">Learning Context and Dependency Injection</em></span> (<code class="email">ticket-agency-cdi</code>) as a base. We will omit the current JSF-based web layer for now. You can safely remove all of the JSF-related classes and configurations. If you encounter any problems, remember that you'll find a fully working project in the code examples, upon completion of this chapter.</p><p class="calibre8">Our first class will not be related to our ticket application, but it will just demonstrate how to create a web service from a <code class="email">POJO</code> class named <code class="email">CalculatePowerWebService</code>. This class has a method named <code class="email">calculatePower</code>, which returns the power of an argument, as shown in the following highlighted code:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.boundary;

public class CalculatePowerWebService {

    public double <span class="strong"><strong class="calibre9">calculatePower</strong></span>(double base, double exponent) {
        return Math.pow(base, exponent);
    }
}</pre></div><p class="calibre8">Now, we will turn this simple class into a web service by adding the mandatory <code class="email">@WebService</code> annotation:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.webservice;

import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;

<span class="strong"><strong class="calibre9">@WebService(targetNamespace = "http://www.packtpub.com/",</strong></span>
<span class="strong"><strong class="calibre9">        serviceName = "CalculatePowerService")</strong></span>
<span class="strong"><strong class="calibre9">@SOAPBinding(style = SOAPBinding.Style.RPC)</strong></span>
public class CalculatePowerWebService {

    @WebMethod
    @WebResult(name = "result")
    public double calculatePower(@WebParam(name = "base") double base,
                                 @WebParam(name = "exponent") double exponent) {
        return Math.pow(base, exponent);
    }
}</pre></div><p class="calibre8">Inside <a id="id787" class="calibre1"/>the <code class="email">@WebService</code> annotation, you can specify additional elements, such as the <code class="email">targetNamespace</code> element that declares the namespace used for the WSDL elements generated <a id="id788" class="calibre1"/>by the web service. If you don't specify this element, the web service container will use the Java package name to generate a default XML namespace.</p><p class="calibre8">You can also use the <code class="email">serviceName</code> element to specify the service name. The name specified using <code class="email">serviceName</code> is used to generate the name attribute in the service element in the WSDL interface. If you don't specify the <code class="email">serviceName</code> element, the server will generate it using the default value, which is the bean class name appended with the service.</p><p class="calibre8">In the next<a id="id789" class="calibre1"/> row, we state that the web service is of the type <span class="strong"><strong class="calibre9">Remote Procedure Call</strong></span> using the <code class="email">@javax.jws.SOAPBinding</code> annotation. The possible values are <code class="email">DOCUMENT</code> and <code class="email">RPC</code>, the first one being the default value.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note34" class="calibre1"/>Note</h3><p class="calibre8">The choice between the RPC and Document style boils down to the different ways we can construct services using these two styles. The body of an RPC-style SOAP message is constructed in a specific way, which is defined in the SOAP standard. This is built on the assumption that you want to call the web service just like you would call a normal function or method that is part of your application code.</p><p class="calibre8">Therefore, the RPC is more tightly coupled because if you make any changes in the message structure, you'll need to change all the clients and servers processing this kind of message.</p><p class="calibre8">A document-style web service, on the other hand, contains no restrictions for how the SOAP body must be constructed. It allows you to include whatever XML data you want and also a schema for this XML. Therefore, the document style is probably more flexible, but the effort to implement the web service and clients may be slightly more.</p><p class="calibre8">In the end, the likelihood of change is a factor that one has to consider when choosing whether to use RPC- or Document-style web services.</p></div><p class="calibre8">Attaching<a id="id790" class="calibre1"/> the <code class="email">@WebMethod</code> attribute to a public method indicates that you want the method exposed as part of the web service.</p><p class="calibre8">The <code class="email">@WebParam</code> annotation<a id="id791" class="calibre1"/> is used to specify the parameter's name that needs to be exhibited in the WSDL. You should always consider using a <code class="email">WebParam</code> annotation, especially when using multiple parameters, otherwise the WSDL will use the default argument parameter (in this case, <code class="email">arg0</code>), which is meaningless for web service consumers.</p><p class="calibre8">The <code class="email">@WebResult</code> annotation is quite similar to <code class="email">@WebParam</code> in the sense that it can be used <a id="id792" class="calibre1"/>to specify<a id="id793" class="calibre1"/> the name of the <a id="id794" class="calibre1"/>value returned by the WSDL.</p><p class="calibre8">Your web service is now complete. In order to deploy your web service, run the following Maven goal, which will package and deploy your web service to your running WildFly instance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn package wildfly:deploy </strong></span>
</pre></div><p class="calibre8">WildFly will provide a minimal output on the console; this will inform you that the web service project has been deployed and the WSDL file has been generated:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">14:25:37,195 INFO  [org.jboss.weld.deployer] (MSC service thread 1-11) JBAS016005: Starting Services for CDI deployment: ticket-agency-ws.war</strong></span>
<span class="strong"><strong class="calibre9">14:25:37,198 INFO  [org.jboss.ws.cxf.metadata] (MSC service thread 1-11) JBWS024061: Adding service endpoint metadata: id=com.packtpub.wflydevelopment.chapter7.boundary.CalculatePowerWebService</strong></span>
<span class="strong"><strong class="calibre9"> address=http://localhost:8080/ticket-agency-ws/CalculatePowerService</strong></span>
<span class="strong"><strong class="calibre9"> implementor=com.packtpub.wflydevelopment.chapter7.boundary.CalculatePowerWebService</strong></span>
<span class="strong"><strong class="calibre9"> serviceName={http://www.packtpub.com/}CalculatePowerService</strong></span>
<span class="strong"><strong class="calibre9"> portName={http://www.packtpub.com/}CalculatePowerWebServicePort</strong></span>
<span class="strong"><strong class="calibre9"> annotationWsdlLocation=null</strong></span>
<span class="strong"><strong class="calibre9"> wsdlLocationOverride=null</strong></span>
<span class="strong"><strong class="calibre9"> mtomEnabled=false</strong></span>
</pre></div><p class="calibre8">From the short log, you can pick up some useful information. For example, the first line states that the web service has been bound in the endpoint registry as <code class="email">{http://www.packtpub.com/}CalculatePowerService</code>. Next is the information about the web context path, which, by default, has the same name as your project, that is, <code class="email">ticket-agency-ws</code>. The last piece of information is about the web service address, which is <code class="email">http://localhost:8080/ticket-agency-ws/CalculatePowerService</code>. By appending the <code class="email">?wsdl</code> suffix to the end of the address, you can inspect the web service contract.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note35" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">data</code> directory contains a versioned list of all the generated WSDLs. So, you might find the entire history of your web services published by <code class="email">ticket-agency-ws</code> in <code class="email">JBOSS_HOME/standalone/data/wsdl/ticket-agency-ws.war</code>.</p></div></div><div class="book" title="Inspecting the web service from the console"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec43" class="calibre1"/>Inspecting the web service from the console</h3></div></div></div><p class="calibre8">You can<a id="id795" class="calibre1"/> inspect the web <a id="id796" class="calibre1"/>services subsystem by moving to the web admin console and navigating to <span class="strong"><strong class="calibre9">Runtime</strong></span> | <span class="strong"><strong class="calibre9">Status</strong></span> | <span class="strong"><strong class="calibre9">Subsystems</strong></span> | <span class="strong"><strong class="calibre9">Web Services</strong></span>.</p><p class="calibre8">Here, you can gather some useful information about the services deployed. In fact, the most useful option is the list of endpoint contracts available, which is needed when developing our clients. The following screenshot shows a view of the web service endpoints from the console:</p><div class="mediaobject"><img src="../images/00064.jpeg" alt="Inspecting the web service from the console" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Particularly, in the lower part of the screen, you can read the web service endpoint address that bears the web application context name and registered name for the web service. In <a id="id797" class="calibre1"/>our case, it <a id="id798" class="calibre1"/>is <code class="email">http://localhost:8080/ticket-agency-ws/CalculatePowerService?wsdl</code>.</p></div><div class="book" title="Testing our simple web service"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec44" class="calibre1"/>Testing our simple web service</h3></div></div></div><p class="calibre8">Since our<a id="id799" class="calibre1"/> first web service is not yet connected to our ticketing system, we will use an external client application to test our web service. One of the best tools to test web services is <span class="strong"><strong class="calibre9">SoapUI</strong></span>.</p><p class="calibre8">SoapUI is<a id="id800" class="calibre1"/> a free, open source, cross-platform functional testing solution with an easy-to-use graphical interface and enterprise-class features. This tool allows you to create and execute automated, functional, regression, compliance, and load tests easily and rapidly. SoapUI is also available as an Eclipse plugin.</p><p class="calibre8">Here, we will use the SoapUI standalone application. Run it and create a new SOAP project providing the URL to the service WSDL, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00065.jpeg" alt="Testing our simple web service" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">After this, you'll see a view containing a few windows. The most important ones show the request logs and the project view in the navigator window, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="Testing our simple web service" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you can <a id="id801" class="calibre1"/>see, your service operations have been automatically discovered. Double-click on the <span class="strong"><strong class="calibre9">Request 1</strong></span> tree element; the SoapUI request window will appear where you can enter the named parameters. Enter the two arguments for the web service, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="Testing our simple web service" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Click on the <span class="strong"><strong class="calibre9">Submit</strong></span> button on the toolbar and check the result in the SOAP response window:</p><div class="mediaobject"><img src="../images/00068.jpeg" alt="Testing our simple web service" class="calibre11"/></div><p class="calibre12"> </p></div><div class="book" title="EJB3 Stateless Session Bean (SLSB) web services"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec45" class="calibre1"/>EJB3 Stateless Session Bean (SLSB) web services</h3></div></div></div><p class="calibre8">The <a id="id802" class="calibre1"/>JAX-WS programming model supports the same set of annotations on EJB3 Stateless<a id="id803" class="calibre1"/> Session Bean as it does on POJO endpoints. Now that we already have some web service muscle, we will engineer one of the examples introduced in this book.</p><p class="calibre8">Our main web service class will be named <code class="email">DefaultTicketWebService</code> and will use some of the core classes that we described in <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, such as <code class="email">TheatreBox</code>, which will keep in memory the ticket bookings and the <code class="email">Seat</code> class as the <a id="id804" class="calibre1"/>model. The business methods of our web service will be described by a <span class="strong"><strong class="calibre9">Service Endpoint Interface</strong></span> (<span class="strong"><strong class="calibre9">SEI</strong></span>) named <code class="email">TicketWebService</code>:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.boundary;

import javax.jws.WebService;
import java.util.List;


@WebService
public interface TicketWebService {

    List&lt;SeatDto&gt; getSeats();

    void bookSeat(int seatId);
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note36" class="calibre1"/>Note</h3><p class="calibre8">Writing the service interface is always a good practice as it gives a proper client-side view of our Service methods. The implementation class can then implement the methods defined in the interface.</p></div><p class="calibre8">We will now implement the interface by providing the business logic to the interface methods in the <code class="email">DefaultTicketWebService</code> class:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.boundary;

import javax.inject.Inject;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import java.io.Serializable;
import java.util.List;
import java.util.stream.Collectors;

<span class="strong"><strong class="calibre9">@WebService(targetNamespace = "http://www.packtpub.com/", serviceName = "TicketWebService")</strong></span>
public class DefaultTicketWebService implements TicketWebService, Serializable {

    @Inject
    private TheatreBox theatreBox;

    @<span class="strong"><strong class="calibre9">WebMethod</strong></span>
<span class="strong"><strong class="calibre9">    @WebResult(name = "listSeats")</strong></span>
    public List&lt;SeatDto&gt; getSeats() {
        return theatreBox.getSeats()
                         .stream()
                         .map(SeatDto::fromSeat)
                         .collect(Collectors.toList());
    }

<span class="strong"><strong class="calibre9">    @WebMethod</strong></span>
    public void bookSeat(@WebParam(name = "seatId") int seatId) {
        theatreBox.buyTicket(seatId);
    }
}</pre></div><p class="calibre8">As you <a id="id805" class="calibre1"/>can <a id="id806" class="calibre1"/>see, the implementation class contains the <code class="email">getSeats</code> method, which returns the list of seats that are self-generated <a id="id807" class="calibre1"/>when the <code class="email">TheatreBox</code> object is initialized. The <code class="email">bookSeat</code> method will be able to book seats for your web service clients as well.</p><p class="calibre8">Now deploy your web service and verify on the console that it has been correctly registered:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">00:43:12,033 INFO  [org.jboss.ws.cxf.metadata] (MSC service thread 1-13) JBWS024061: Adding service endpoint metadata: id=com.packtpub.wflydevelopment.chapter7.boundary.DefaultTicketWebService</strong></span>
<span class="strong"><strong class="calibre9"> address=http://localhost:8080/ticket-agency-ws/TicketWebService</strong></span>
<span class="strong"><strong class="calibre9"> implementor=com.packtpub.wflydevelopment.chapter7.boundary.DefaultTicketWebService</strong></span>
<span class="strong"><strong class="calibre9"> serviceName={http://www.packtpub.com/}TicketWebService</strong></span>
<span class="strong"><strong class="calibre9"> portName={http://www.packtpub.com/}DefaultTicketWebServicePort</strong></span>
<span class="strong"><strong class="calibre9"> annotationWsdlLocation=null</strong></span>
<span class="strong"><strong class="calibre9"> wsdlLocationOverride=null</strong></span>
<span class="strong"><strong class="calibre9"> mtomEnabled=false</strong></span>
</pre></div></div><div class="book" title="Developing a web service consumer"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec46" class="calibre1"/>Developing a web service consumer</h3></div></div></div><p class="calibre8">The <a id="id808" class="calibre1"/>web service <a id="id809" class="calibre1"/>consumer of the <code class="email">TicketWebService</code> class will be coded using the standard Java SE classes. We want to show here how to use these standard APIs. For this reason, you can just add a class named <code class="email">TicketWebServiceTestApplication</code> to your current or a separate project in the package <code class="email">com.packtpub.wflydevelopment.chapter7.webservice</code>:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.webservice;

import com.packtpub.wflydevelopment.chapter7.boundary.SeatDto;
import com.packtpub.wflydevelopment.chapter7.boundary.TicketWebService;

import javax.xml.namespace.QName;
import javax.xml.ws.Service;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collection;
import java.util.List;
import java.util.logging.Logger;

public class TicketWebServiceTestApplication {

    private static final Logger logger = Logger.getLogger(TicketWebServiceTestApplication.class.getName());

    public static void main(String[] args) throws MalformedURLException {
        final int seatId = 1;
        logger.info("TEST SOAP WS Service");
        final URL wsdlURL = <span class="strong"><strong class="calibre9">new URL("http://localhost:8080/ticket-agency-ws/TicketWebService?wsdl");</strong></span>
        final QName SERVICE_NAME = <span class="strong"><strong class="calibre9">new QName("http://www.packtpub.com/", "TicketWebService");</strong></span>
        final Service service = Service.create(wsdlURL, SERVICE_NAME);
        final TicketWebService infoService = service.getPort(TicketWebService.class);

        logger.info("Got the Service: " + infoService);

        infoService.bookSeat(seatId);
        logger.info("Ticket Booked with JAX-WS Service");

        final List&lt;SeatDto&gt; list = infoService.getSeats();

        dumpSeatList(list);
    }

    private static void dumpSeatList(Collection&lt;SeatDto&gt; list) {
        logger.info("================= Available Ticket List ================");
        list.stream().forEach(seat -&gt; logger.info(seat.toString()));
    }
}</pre></div><p class="calibre8">The service WSDL <a id="id810" class="calibre1"/>URL<a id="id811" class="calibre1"/> and name are needed for retrieval of the <code class="email">Service</code> object. Finally, the<a id="id812" class="calibre1"/> <code class="email">getPort</code> method will return a proxy to your web service that can be used to test two basic operations: booking a seat and checking from the <code class="email">Seat</code> list if the seat has actually been reserved.</p><p class="calibre8">This small standalone class has shown how it is possible to use SOAP-based services from the client-side perspective.</p><p class="calibre8">The <a id="id813" class="calibre1"/>most interesting <a id="id814" class="calibre1"/>part, however, is at the bottom of the Maven output, where the <code class="email">Ticket</code> list is dumped after booking one seat, as depicted in the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication main</strong></span>
<span class="strong"><strong class="calibre9">INFO: TEST SOAP WS Service</strong></span>
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication main</strong></span>
<span class="strong"><strong class="calibre9">INFO: Got the Service: JAX-WS RI 2.2.9-b130926.1035 svn-revision#8c29a9a53251ff741fca1664a8221dc876b2eac8: Stub for http://localhost:8080/ticket-agency-ws/TicketWebService</strong></span>
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication main</strong></span>
<span class="strong"><strong class="calibre9">INFO: Ticket Booked with JAX-WS Service</strong></span>
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication dumpSeatList</strong></span>
<span class="strong"><strong class="calibre9">INFO: ================= Available Ticket List ================</strong></span>
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication lambda$dumpSeatList$0</strong></span>
<span class="strong"><strong class="calibre9">INFO: SeatDto [id=1, name=Stalls, price=40, booked=true]</strong></span>
<span class="strong"><strong class="calibre9">apr 01, 2014 1:08:44 AM com.packtpub.wflydevelopment.chapter7.webservice.TicketWebServiceTestApplication lambda$dumpSeatList$0</strong></span>
<span class="strong"><strong class="calibre9">INFO: SeatDto [id=2, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
</pre></div></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Developing REST-based web services"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec34" class="calibre1"/>Developing REST-based web services</h1></div></div></div><p class="calibre8"><span class="strong"><strong class="calibre9">JAX-RS 2.0</strong></span> (JSR-339<a id="id815" class="calibre1"/> can be found at <a class="calibre1" href="https://jcp.org/en/jsr/detail?id=339">https://jcp.org/en/jsr/detail?id=339</a>) is a JCP<a id="id816" class="calibre1"/> specification <a id="id817" class="calibre1"/>that provides a Java API for RESTful web services in the HTTP protocol. It is a major refresh from the old Version 1.1. Some of the new features are the client API, HATEOAS support, and asynchronous calls.</p><p class="calibre8">In their simplest form, RESTful web services are networked applications that manipulate the state of system resources. In this context, resource manipulation means resource creation, retrieval, updatation, and deletion (CRUD). However, RESTful web services are not <a id="id818" class="calibre1"/>limited to just these four basic data manipulation concepts. On the contrary, RESTful web services can execute logic at the server level but remember that every result must be a resource representation of the domain.</p><p class="calibre8">The main difference with SOAP web services is that REST asks developers to use HTTP methods explicitly and in a way that's consistent with the protocol definition. This basic REST design principle establishes a <span class="strong"><strong class="calibre9">one-to-one</strong></span> mapping between CRUD operations and HTTP methods.</p><p class="calibre8">Therefore, with the delineated roles for resources and representations, we can now map our CRUD actions to the HTTP methods <code class="email">POST</code>, <code class="email">GET</code>, <code class="email">PUT</code>, and <code class="email">DELETE</code> as follows:</p><div class="informalexample"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Action</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">HTTP protocol equivalent</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">RETRIEVE</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">GET</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">CREATE</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">POST</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">UPDATE</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">PUT</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23">DELETE</p>
</td><td valign="top" class="calibre25">
<p class="calibre23">DELETE</p>
</td></tr></tbody></table></div></div>

<div class="book" title="Developing REST-based web services">
<div class="book" title="Accessing REST resources"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec59" class="calibre1"/>Accessing REST resources</h2></div></div></div><p class="calibre8">As we<a id="id819" class="calibre1"/> said, REST resources<a id="id820" class="calibre1"/> can be accessed using actions that map an equivalent HTTP request. In order to simplify the development of REST applications, you can use simple annotations to map your actions; for example, in order to retrieve some data from your application, you can use something similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@Path("/users")</strong></span>
public class UserResource {

<span class="strong"><strong class="calibre9">    @GET</strong></span>
    public String handleGETRequest() { . . .}

<span class="strong"><strong class="calibre9">    @POST</strong></span>
    public String handlePOSTRequest(String payload) { . . . }
}</pre></div><p class="calibre8">The first annotation, <code class="email">@Path</code>, in our example is used to specify the URI that is assigned to this web service. Subsequent methods have their specific <code class="email">@Path</code> annotation so that you can<a id="id821" class="calibre1"/> provide a different response <a id="id822" class="calibre1"/>according to the URI requested.</p><p class="calibre8">Then, we <a id="id823" class="calibre1"/>have an <code class="email">@GET</code> annotation that maps an HTTP <code class="email">GET</code> request and an <code class="email">@POST</code> annotation that handles an HTTP <code class="email">POST</code> request. So, in this example, if we were to request for a web application bound to the <code class="email">example</code> web context, an HTTP <code class="email">GET</code> request to the URL <code class="email">http://host/example/users</code> would trigger the <code class="email">handleGETRequest</code> method; on the other hand, an HTTP <code class="email">POST</code> request to the same URL would conversely invoke the <code class="email">handlePOSTRequest</code> method.</p></div></div>

<div class="book" title="Developing REST-based web services">
<div class="book" title="JBoss REST web services"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec60" class="calibre1"/>JBoss REST web services</h2></div></div></div><p class="calibre8">Having<a id="id824" class="calibre1"/> understood the basics <a id="id825" class="calibre1"/>of REST services, let's see how we can develop a RESTful web service using WildFly. The application server includes an out-of-the-box RESTEasy library that is a portable implementation of the JSR-339 specification. RESTEasy can run in any servlet container; however, it is perfectly integrated with WildFly, thus making the user experience nicer in that environment.</p><p class="calibre8">Besides the server-side specification, in the past, RESTEasy has been innovative in bringing <a id="id826" class="calibre1"/>JAX-RS to the client through the RESTEasy <span class="strong"><strong class="calibre9">JAX-RS Client Framework</strong></span>. However, the latest version of the JAX-RS specification comes with a client API, which we can use in every JAX-RS implementation.</p><div class="book" title="Activating JAX-RS"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec47" class="calibre1"/>Activating JAX-RS</h3></div></div></div><p class="calibre8">RESTEasy <a id="id827" class="calibre1"/>is bundled with WildFly, so<a id="id828" class="calibre1"/> you need very little effort to get started. You have two choices. The first one is to use the <code class="email">@ApplicationPath</code> annotation in a class that extends <code class="email">javax.ws.rs.core.Application</code>:</p><div class="informalexample"><pre class="programlisting">@ApplicationPath("/rest")
public class JaxRsActivator extends Application {
 
}</pre></div><p class="calibre8">The second choice is less popular and used to configure the application using a <code class="email">web.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app  
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_3_0.xsd" version="3.0"&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p class="calibre8">This <a id="id829" class="calibre1"/>simply means that if we were to deploy<a id="id830" class="calibre1"/> our former example, the HTTP <code class="email">GET</code> method, <code class="email">http://host/example/rest/users</code> would trigger our <code class="email">getUser</code> business method, while the same URL will place a request through the <code class="email">handlePOSTRequest</code> method using a <code class="email">POST</code> request.</p></div><div class="book" title="Adding REST to our ticket example"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec48" class="calibre1"/>Adding REST to our ticket example</h3></div></div></div><p class="calibre8">With <a id="id831" class="calibre1"/>all the configurations <a id="id832" class="calibre1"/>in place, we can now add a simple <a id="id833" class="calibre1"/>REST web service to our <code class="email">Ticket Web Service</code> project, which will provide the same functionalities as our SOAP web service.</p><p class="calibre8">So add a new class to your project and name it <code class="email">SeatsResource</code>. The code for this is as follows:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.boundary;

@Path("/seat")
<span class="strong"><strong class="calibre9">@Produces(MediaType.APPLICATION_JSON)</strong></span>
@RequestScoped
public class SeatsResource {

    @Inject
    private TheatreBooker theatreBooker;

    @Inject
    private TheatreBox theatreBox;

<span class="strong"><strong class="calibre9">    @GET</strong></span>
    public Collection&lt;SeatDto&gt; getSeatList() {
        return theatreBox.getSeats()
                 .stream()
                 .map(SeatDto::fromSeat)
                 .collect(Collectors.toList());
    }

<span class="strong"><strong class="calibre9">    @POST</strong></span>
    @Path("/{id}")
    public Response bookPlace(@PathParam("id") int id) {
        try {
            theatreBooker.bookSeat(id);
            return Response.ok(SeatDto.fromSeat(theatreBox.getSeat(id)))
             .build();
        } catch (Exception e) {
            final Entity&lt;String&gt; errorMessage = Entity
                                         .json(e.getMessage());
            return Response.status(Response.Status.BAD_REQUEST)
                       .entity(errorMessage).build();
        }
    }
}</pre></div><p class="calibre8">If you<a id="id834" class="calibre1"/> have understood<a id="id835" class="calibre1"/> our earlier section well, this code will be<a id="id836" class="calibre1"/> almost intuitive to you. We have included two methods here, just like the SOAP alter ego; the former one is named <code class="email">getSeatList</code>, which is bound to an HTTP <code class="email">GET</code> request and produces the list of <code class="email">Seats</code>. The list is returned using a JSON representation that is pretty common when returning Java objects to the client.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note37" class="calibre1"/>Note</h3><p class="calibre8">The grammar for JSON objects is simple and requires the grouping of the data definition and data values; it is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Elements are enclosed within curly brackets (<code class="email">{</code> and <code class="email">}</code>)</li><li class="listitem">Values of elements come in pairs with the structure of <code class="email">name:value</code> and are comma separated</li><li class="listitem">Arrays are enclosed within square brackets (<code class="email">[</code> and <code class="email">]</code>)</li></ul></div><p class="calibre8">That's <a id="id837" class="calibre1"/>all there is to it (for the full JSON grammar description, visit <a class="calibre1" href="http://www.json.org/">http://www.json.org/</a>).</p></div><p class="calibre8">The second method included in this class is <code class="email">bookPlace</code>, which will be used to invoke the corresponding <code class="email">bookSeat</code> class of our EJB. This method, on the other hand, is bound to the following HTTP <code class="email">POST</code> method:</p><div class="informalexample"><pre class="programlisting">@POST
@Path("/{id}")
public Response bookPlace(@PathParam("id") int id)</pre></div><p class="calibre8">You might be thinking that this <code class="email">Path</code> expression seems a bit weird, but all it does is map a URI parameter (included in the <code class="email">Path</code> expression) to a method parameter. In short, the parameter that is included in the URL will be passed to the method in the <code class="email">ID</code> variable.</p><p class="calibre8">The previous method also returns a JSON-formatted string that is encoded and decoded using Jackson (by default, it is possible to create your own message body providers!), a library that transforms POJOs to JSON (and vice versa).</p><p class="calibre8">Before we proceed, we need to extend our sample with a new resource account, which will allow us to check the cash status and optionally reset it:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.boundary;

@Path("/account")
@Produces(MediaType.APPLICATION_JSON)
@RequestScoped
public class AccountResource {

    @Inject
    private TheatreBooker theatreBooker;

    @GET
    public AccountDto getAccount() {
        return AccountDto
                 .fromAccount(theatreBooker.getCurrentAccount());
    }

    @POST
    public Response renew() {
        theatreBooker.createCustomer();
        return Response
        .ok(AccountDto.fromAccount(theatreBooker.getCurrentAccount()))
        .build();
    }
}</pre></div><p class="calibre8">The <a id="id838" class="calibre1"/>account representation <a id="id839" class="calibre1"/>is available, as shown in the following <a id="id840" class="calibre1"/>code:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.entity;

public class Account {

    private final int balance;

    public Account(int initialBalance) {
        this.balance = initialBalance;
    }

    public Account charge(int amount) {
        final int newBalance = balance - amount;
        if (newBalance &lt; 0) {
            throw new IllegalArgumentException("Debit value on account!");
        }
        return new Account(newBalance);
    }

    public int getBalance() {
        return balance;
    }

    @Override
    public String toString() {
        return "Account [balance = " + balance + "]";
    }
}</pre></div><p class="calibre8">The last step is to update our <code class="email">TheatreBooker</code> class to use our new account representation:</p><div class="informalexample"><pre class="programlisting">    private Account currentAccount;

    @PostConstruct
    public void createCustomer() {
        currentAccount = new Account(100);
    }

    public void bookSeat(int seatId) {
        logger.info("Booking seat " + seatId);
        final int seatPrice = theatreBox.getSeatPrice(seatId);

        if (seatPrice &gt; currentAccount.getBalance()) {
            throw new IllegalArgumentException("Not enough money!");
        }

        theatreBox.buyTicket(seatId);
        currentAccount = currentAccount.charge(seatPrice);

        logger.info("Seat booked.");
    }

    public Account getCurrentAccount() {
        return currentAccount;
    }</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note39" class="calibre1"/>Note</h3><p class="calibre8">The newest version of JAX-RS also supports server-side asynchronous responses. Thanks to the <code class="email">@Suspended</code> annotation and the <code class="email">AsyncResponse</code> class, you can use a separate (possibly delayed) thread to handle a request call.</p></div></div><div class="book" title="Adding filters"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec49" class="calibre1"/>Adding filters</h3></div></div></div><p class="calibre8">JAX-RS <a id="id841" class="calibre1"/>allows us to define filters and interceptors <a id="id842" class="calibre1"/>for both the client and server. They allow the developer to address cross-cutting concerns, such as security, auditing, or compression. Basically, you can treat filters and interceptors as extension points.</p><p class="calibre8">Filters are used mainly on headers of requests and responses. For example, you can block a request based on its header fields or log only failed requests. On the contrary, interceptors deal with message bodies, for example, you can sign or compress the messages. Interceptors also come in two flavors: one for reading (they are executed when a message is translated into a POJO, for example JSON to <code class="email">SeatDto</code>) and one for writing (they are used for POJO to message translation).</p><p class="calibre8">We can add a simple server-side logging filter to our application by creating the following class:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter7.controller;

import java.io.IOException;
import java.util.logging.Logger;

import javax.inject.Inject;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.ext.Provider;

@Provider
public class LoggingRestFilter implements ContainerRequestFilter, ContainerResponseFilter {

    @Inject
    private Logger logger;

    @Override
    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
            throws IOException {
        logger.info(responseContext.getStatusInfo().toString());
    }

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        logger.info(requestContext.getMethod() + " on " + requestContext.getUriInfo().getPath());
    }
}</pre></div><p class="calibre8">As you <a id="id843" class="calibre1"/>can see, we implement two pretty<a id="id844" class="calibre1"/> straightforward interfaces: <code class="email">ContainerRequestFilter</code> and <code class="email">ContainerResponseFilter</code>. We simply log some information about the HTTP request and response. To activate the filter, we use the <code class="email">@Provider</code> annotation; without additional configuration, the filter will work for every REST resource in our application. Additionally, if we would like to reject a request in the filter, there is a <code class="email">requestContext.abortWith</code> method.</p><p class="calibre8">The client side has two corresponding interfaces: <code class="email">ClientRequestFilter</code> and <code class="email">ClientResponseFilter</code>. The implementations, however, must be registered manually.</p><p class="calibre8">Now the REST service is complete and we can start deploying it in the usual way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn package wildfly:deploy</strong></span>
</pre></div><p class="calibre8">If you followed all the steps so far, the <code class="email">http://localhost:8080/ticket-agency-ws/rest/seat GET</code> method issued by your browser should print out the list of available seats:</p><div class="informalexample"><pre class="programlisting">[{"id":0,"name":"Stalls","price":40,"booked":false},{"id":1,"name":"Stalls","price":40,"booked":false},{"id":2,"name":"Stalls","price":40,"booked":false},{"id":3,"name":"Stalls","price":40,"booked":false},{"id":4,"name":"Stalls","price":40,"booked":false},
. . . . . .</pre></div><p class="calibre8">Going to <code class="email">http://localhost:8080/ticket-agency-ws/rest/account</code> will result in:</p><div class="informalexample"><pre class="programlisting">{"balance":100}</pre></div><p class="calibre8">You should also see some log statements from our filter in the console, for instance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">19:52:45,906 INFO  [com.packtpub.wflydevelopment.chapter7.controller.LoggingRestFilter] (default task-10) GET on /seat</strong></span>
<span class="strong"><strong class="calibre9">19:52:45,909 INFO  [com.packtpub.wflydevelopment.chapter7.controller.LoggingRestFilter] (default task-10) OK</strong></span>
<span class="strong"><strong class="calibre9">20:29:04,275 INFO  [com.packtpub.wflydevelopment.chapter7.controller.LoggingRestFilter] (default task-14) GET on /account</strong></span>
<span class="strong"><strong class="calibre9">20:29:04,313 INFO  [com.packtpub.wflydevelopment.chapter7.controller.LoggingRestFilter] (default task-14) OK</strong></span>
</pre></div></div><div class="book" title="Consuming our REST service"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec50" class="calibre1"/>Consuming our REST service</h3></div></div></div><p class="calibre8">Connecting<a id="id845" class="calibre1"/> to a RESTful web<a id="id846" class="calibre1"/> service takes no more work than directly connecting to the service through an HTTP connection. For this reason, you can use plenty of APIs to access your REST services, such as the JDK <code class="email">URLConnection</code> class or Jakarta Commons HttpClient API, since we have a standardized client available in JAX-RS.</p><p class="calibre8">If you want to retrieve the list of <code class="email">Seats</code> from your REST service, your code should look like this:</p><div class="informalexample"><pre class="programlisting">Client restclient = ClientBuilder.newClient();
WebTarget seatResource = restclient.target(APPLICATION_URL + "seat");
Collection&lt;SeatDto&gt; seats = seatResource.request().get(new GenericType&lt;Collection&lt;SeatDto&gt;&gt;() {});</pre></div><p class="calibre8">The previous code will simply perform a <code class="email">GET</code> action to the REST service that is deployed as part of the <code class="email">ticket-agency-ws</code> web application. RESTEasy (using Jackson) will transform the JSON objects.</p><p class="calibre8">The following standalone sample will get the data from the account and seat resources and attempt to book all of the available seats:</p><div class="informalexample"><pre class="programlisting">public class RestServiceTestApplication {
    private static final String APPLICATION_URL = "http://localhost:8080/ticket-agency-ws/rest/";

    private WebTarget accountResource;
    private WebTarget seatResource;

    public static void main(String[] args) {
        new RestServiceTestApplication().runSample();
    }

    public RestServiceTestApplication() {
        Client restclient = ClientBuilder.newClient();

        accountResource = restclient.target(APPLICATION_URL + "account");
        seatResource = restclient.target(APPLICATION_URL + "seat");
    }

    public void runSample() {
        printAccountStatusFromServer();

        System.out.println("=== Current status: ");
        Collection&lt;SeatDto&gt; seats = getSeatsFromServer();
        printSeats(seats);

        System.out.println("=== Booking: ");
        bookSeats(seats);

        System.out.println("=== Status after booking: ");
        Collection&lt;SeatDto&gt; bookedSeats = getSeatsFromServer();
        printSeats(bookedSeats);

        printAccountStatusFromServer();
    }

    private void printAccountStatusFromServer() {
<span class="strong"><strong class="calibre9">        AccountDto account = accountResource.request().get(AccountDto.class);</strong></span>
        System.out.println(account);
    }

    private Collection&lt;SeatDto&gt; getSeatsFromServer() {
<span class="strong"><strong class="calibre9">        return seatResource.request().get(new GenericType&lt;Collection&lt;SeatDto&gt;&gt;() { });</strong></span>
    }

    private void printSeats(Collection&lt;SeatDto&gt; seats) {
        seats.forEach(System.out::println);
    }

    private void bookSeats(Collection&lt;SeatDto&gt; seats) {
        for (SeatDto seat : seats) {
            try {
                String idOfSeat = Integer.toString(seat.getId());
                <span class="strong"><strong class="calibre9">seatResource.path(idOfSeat).request().post(Entity.json(""), String.class);</strong></span>
                System.out.println(seat + " booked");
            } catch (WebApplicationException e) {
                Response response = e.getResponse();
                StatusType statusInfo = response.getStatusInfo();
                System.out.println(seat + " not booked (" + statusInfo.getReasonPhrase() + "):" response.readEntity(JsonObject.class). getString("entity"));
            }
        }
    }
}</pre></div><p class="calibre8">In the <a id="id847" class="calibre1"/>highlighted fragments, you <a id="id848" class="calibre1"/>can see the REST calls used to retrieve the data and booking seats. Our <code class="email">post</code> call requires an ID to be specified; we do that by using the <code class="email">path</code> method of the <code class="email">request</code> builder. It is also possible to make the call asynchronously, using the <code class="email">async</code> method and a <code class="email">Future</code> object:</p><div class="informalexample"><pre class="programlisting">Future&lt;Collection&lt;SeatDto&gt;&gt; future = seatResource.request()
        .async().get(new GenericType&lt;Collection&lt;SeatDto&gt;&gt;() {});</pre></div><p class="calibre8">We can use the new <code class="email">CompletableFuture</code> class from Java 8 to be notified about the completion of a request:</p><div class="informalexample"><pre class="programlisting">CompletableFuture.&lt;Collection&lt;SeatDto&gt;&gt; supplyAsync(() -&gt; {
    try {
        return future.get();
    } catch (Exception e) {
        e.printStackTrace();
        throw new IllegalArgumentException(e);
    }
}).thenAccept(seats -&gt; seats.forEach(System.out::println));</pre></div><p class="calibre8">After receiving the data, we simply print it out. Another option is to simply create an <code class="email">InvocationCallback</code> class and pass it as a second argument to the <code class="email">get</code> method.</p></div><div class="book" title="Compiling our ticket example"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec51" class="calibre1"/>Compiling our ticket example</h3></div></div></div><p class="calibre8">Our<a id="id849" class="calibre1"/> sample can reside in a separate<a id="id850" class="calibre1"/> Maven module or you can leave it with the server content (although it is not a good practice). In order to compile our client project with the REST web service, we need to import the JAX-RS API that is included in the application server libraries. We will need the following dependencies in our standalone application:</p><div class="informalexample"><pre class="programlisting">&lt;properties&gt;
   . . .
    &lt;version.resteasy-client&gt;3.0.6.Final&lt;/version.resteasy-client&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
        &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
        &lt;version&gt; ${version.resteasy-client}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
        &lt;artifactId&gt;resteasy-json-p-provider&lt;/artifactId&gt;
        &lt;version&gt; ${version.resteasy-client}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
        &lt;artifactId&gt;resteasy-jackson-provider&lt;/artifactId&gt;
        &lt;version&gt; ${version.resteasy-client}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.packtpub.wflydevelopment.chapter7&lt;/groupId&gt;
        &lt;artifactId&gt;ticket-agency-ws&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><p class="calibre8">If you have any problems with the creation of the POM file, you can look it up in the samples<a id="id851" class="calibre1"/> that are distributed with<a id="id852" class="calibre1"/> this book.</p><p class="calibre8">Now simply run your application, and you should see something similar to the following console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">AccountDto [balance=100]</strong></span>
<span class="strong"><strong class="calibre9">=== Current status: </strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=1, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=2, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=3, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=4, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=5, name=Stalls, price=40, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=6, name=Circle, price=20, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">SeatDto [id=7, name=Circle, price=20, booked=false]</strong></span>
<span class="strong"><strong class="calibre9">…</strong></span>
</pre></div></div><div class="book" title="Adding AngularJS"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec52" class="calibre1"/>Adding AngularJS</h3></div></div></div><p class="calibre8">Our <a id="id853" class="calibre1"/>samples for the REST integration<a id="id854" class="calibre1"/> are not very spectacular. However, because we expose the functionality of our application via a REST API, it is easy to create a non-Java GUI, which can be used to control the application.</p><p class="calibre8">To create a GUI that uses only the REST API to communicate with our Java backend, we will use a popular <a id="id855" class="calibre1"/>JavaScript framework: AngularJS (<a class="calibre1" href="http://angularjs.org/">http://angularjs.org/</a>). We won't get into too much detail of the JavaScript code. The most interesting part for us is the usage of our REST API, which we currently consume only in a Java application.</p><p class="calibre8">As seen in <a class="calibre1" title="Chapter 5. Combining Persistence with CDI" href="part0030_split_000.html#page">Chapter 5</a>, <span class="strong"><em class="calibre10">Combining Persistence with CDI</em></span>, we will use WebJars. This time, apart from<a id="id856" class="calibre1"/> Bootstrap, we need the AngularJS (preferably in Version 3.x) and Angular UI Bootstrap package (<a class="calibre1" href="http://angular-ui.github.io/bootstrap/">http://angular-ui.github.io/bootstrap/</a>):</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;angularjs&lt;/artifactId&gt;
    &lt;version&gt;1.3.0-rc.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;angular-ui-bootstrap&lt;/artifactId&gt;
    &lt;version&gt;0.11.0-2&lt;/version&gt;
&lt;/dependency&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note40" class="calibre1"/>Note</h3><p class="calibre8">Remember that all the files that are required to run this sample are available with the code attached to this book.</p></div><p class="calibre8">We will need an <code class="email">index.html</code> file to start our work and an empty <code class="email">scripts</code> directory to store our logic. Our directory structure should currently look like this:</p><div class="mediaobject"><img src="../images/00069.jpeg" alt="Adding AngularJS" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In<a id="id857" class="calibre1"/> the <code class="email">index.html</code> file, we need to add all <a id="id858" class="calibre1"/>the required libraries along with our well-known Bootstrap structure:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html lang="en" ng-app="ticketApp"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Ticket Service&lt;/title&gt;
    &lt;link rel="stylesheet" href=""webjars/bootstrap/3.2.0/css/bootstrap.css"&gt;
    &lt;link rel="stylesheet" href=""webjars/bootstrap/3.2.0/css/bootstrap-theme.css"&gt;
    &lt;style&gt;
        body {
            padding-top: 60px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt;
&lt;/div&gt;

&lt;div class="container" ng-controller="SeatCtrl"&gt;
    &lt;footer&gt;
        &lt;p class="text-muted"&gt;&amp;copy; Packt Publishing 2014&lt;/p&gt;
    &lt;/footer&gt;
&lt;/div&gt;

&lt;script src="webjars/angularjs/1.3.0-rc.1/angular.js"&gt;&lt;/script&gt;
&lt;script src="webjars/angularjs/1.3.0-rc.1/angular-resource.js"&gt;&lt;/script&gt;
&lt;script src="webjars/angularjs/1.3.0-rc.1/angular-route.js"&gt;&lt;/script&gt;
&lt;script src="webjars/angular-ui-bootstrap/0.11.0/ui-bootstrap-tpls.js"&gt;&lt;/script&gt;

<span class="strong"><strong class="calibre9">&lt;script src="scripts/app.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong class="calibre9">&lt;script src="scripts/controllers/seat.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong class="calibre9">&lt;script src="scripts/services/seatservice.js"&gt;&lt;/script&gt;</strong></span>
<span class="strong"><strong class="calibre9">&lt;script src="scripts/services/accountservice.js"&gt;&lt;/script&gt;</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">You <a id="id859" class="calibre1"/>may have also noticed two strange-looking<a id="id860" class="calibre1"/> attributes in the <code class="email">html</code> tags: <code class="email">ng-app</code> and <code class="email">ng-controller</code>. These are AngularJS directives that point to the web page being an AngularJS application, and that the container div will use a <code class="email">SeatCtrl</code> controller.</p><p class="calibre8">Now, we will need the following files placed in our <code class="email">scripts</code> directory. The first one is the initialization file <code class="email">app.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
angular.module('ticketApp', [ 'ngResource', 'ngRoute', 'ui.bootstrap' ])
    .config(function ($routeProvider) {
        $routeProvider.when('/', {
            controller: 'SeatCtrl'
        }).otherwise({
            redirectTo: '/'
        });
    });</pre></div><p class="calibre8">Next we will initialize the address of our seat resource in <code class="email">scripts/services/seatservice.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
angular.module('ticketApp').service('SeatService',
    function SeatService($resource) {
        return $resource('rest/seat/:seatId', {
            seatId: '@id'
        }, {
<span class="strong"><strong class="calibre9">            query: {</strong></span>
<span class="strong"><strong class="calibre9">                method: 'GET',</strong></span>
<span class="strong"><strong class="calibre9">                isArray: true</strong></span>
<span class="strong"><strong class="calibre9">            },</strong></span>
<span class="strong"><strong class="calibre9">            book: {</strong></span>
<span class="strong"><strong class="calibre9">                method: 'POST'</strong></span>
<span class="strong"><strong class="calibre9">            }</strong></span>
        });
    });</pre></div><p class="calibre8">As you<a id="id861" class="calibre1"/> can see, we mapped our REST URL<a id="id862" class="calibre1"/> to the JavaScript code along with two HTTP methods: <code class="email">GET</code> and <code class="email">POST</code>. They will be called by the controller to communicate with the server; the same goes for our account resource, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">'use strict';
angular.module('ticketApp').service('AccountService',
    function AccountService($resource) {
        return $resource(<span class="strong"><strong class="calibre9">'rest/account', {}, {</strong></span>
<span class="strong"><strong class="calibre9">            query: {</strong></span>
<span class="strong"><strong class="calibre9">                method: 'GET',</strong></span>
<span class="strong"><strong class="calibre9">                isArray: false</strong></span>
<span class="strong"><strong class="calibre9">            },</strong></span>
<span class="strong"><strong class="calibre9">            reset: {</strong></span>
<span class="strong"><strong class="calibre9">                method: 'POST'</strong></span>
<span class="strong"><strong class="calibre9">            }</strong></span>
        });
    });</pre></div><p class="calibre8">Finally, we create a simple controller to place our logic at <code class="email">scripts/controllers/seat.js</code>:</p><div class="informalexample"><pre class="programlisting">'use strict';
angular.module('ticketApp').controller(
    'SeatCtrl',
    function ($scope, SeatService, AccountService) {
<span class="strong"><strong class="calibre9">        $scope.seats = SeatService.query();</strong></span>
<span class="strong"><strong class="calibre9">        $scope.account = AccountService.query();</strong></span>

        $scope.alerts = [];

<span class="strong"><strong class="calibre9">        $scope.bookTicket</strong></span> = function (seat) {
<span class="strong"><strong class="calibre9">            seat.$book</strong></span>({}, function success() {
                $scope.account.$query();
            }, function err(httpResponse) {
                $scope.alerts.push({
                    type: 'danger',
                    msg: 'Error booking ticket for seat '
                        + httpResponse.config.data.id + ': '
                        + httpResponse.data.entity
                });
            });
        };
        $scope.closeAlert = function (index) {
            $scope.alerts.splice(index, 1);
        };
        $scope.clearWarnings = function () {
            $scope.alerts.length = 0;
        };
        $scope.resetAccount = function () {
<span class="strong"><strong class="calibre9">            $scope.account.$reset();</strong></span>
        };
    });</pre></div><p class="calibre8">The<a id="id863" class="calibre1"/> highlighted portions of code are calls<a id="id864" class="calibre1"/> to the services we defined previously. For instance, <code class="email">$scope.seats = SeatService.query()</code> will issue a <code class="email">GET</code> request to retrieve a list of seats in the JSON format. The case for <code class="email">seat.$book</code> is similar; it will issue a <code class="email">POST</code> request to book a specific seat.</p><p class="calibre8">Our whole JavaScript logic is now in place. One final move is to place some HTML code bound to it in our <code class="email">index.html</code> file. Insert the following code in the <code class="email">index.html</code> file, inside the <code class="email">content</code> div:</p><div class="informalexample"><pre class="programlisting">   &lt;alert ng-repeat="alert in alerts" type="alert.type"
           close="closeAlert($index)"&gt;{{alert.msg}}
    &lt;/alert&gt;

    &lt;div class="panel panel-default"&gt;
        &lt;div class="panel-heading"&gt;
            &lt;h3 class="panel-title"&gt;Ticket booking&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class="panel-body"&gt;
            &lt;p&gt;
<span class="strong"><strong class="calibre9">                Remaining money: &lt;span class="badge"&gt;{{account.balance}}&lt;/span&gt;</strong></span>
            &lt;/p&gt;
            &lt;br/&gt;

            &lt;button type="button" class="btn btn-primary btn-xs"
                    ng-click="clearWarnings()"&gt;Clear warnings
            &lt;/button&gt;

            &lt;button type="button" class="btn btn-warning btn-xs"
                    ng-click="resetAccount()"&gt;Reset account
            &lt;/button&gt;
        &lt;/div&gt;
        &lt;table class="table table-hover table-striped"&gt;
            &lt;thead&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Booked&lt;/th&gt;       &lt;th&gt;Book&lt;/th&gt;&lt;/thead&gt;
            &lt;tbody&gt;
            &lt;tr ng-repeat="seat in seats"&gt;
<span class="strong"><strong class="calibre9">                &lt;td&gt;{{seat.id}}&lt;/td&gt;</strong></span>
<span class="strong"><strong class="calibre9">                &lt;td&gt;{{seat.name}}&lt;/td&gt;</strong></span>
<span class="strong"><strong class="calibre9">                &lt;td&gt;${{seat.price}}&lt;/td&gt;</strong></span>
                &lt;td&gt;&lt;span
                        class="glyphicon glyphicon-{{seat.booked ? 'ok' :'remove'}}"&gt;&lt;/span&gt;&lt;/td&gt;
                &lt;td&gt;
                    &lt;button type="button"
                            class="btn btn-primary {{seat.booked? 'disabled' :''}} btn-xs" <span class="strong"><strong class="calibre9">ng-click="bookTicket(seat)"&gt;Book</strong></span>
                    &lt;/button&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;</pre></div><p class="calibre8">The<a id="id865" class="calibre1"/> code is similar to the JSF tables we <a id="id866" class="calibre1"/>created in the earlier chapters. What is important to us is that the <code class="email">{{ }}</code> symbols are used by AngularJS to bind the displayed data with a variable in a controller, which, in fact, is a representation of our REST endpoints.</p><p class="calibre8">Additionally, the <code class="email">ng-click</code> directives are bound to the appropriate methods in the controller. The<a id="id867" class="calibre1"/> <code class="email">bookTicket</code> method issues a <code class="email">seat.$book</code> call, which is propagated as a <code class="email">POST</code> request to our backend.</p><p class="calibre8">We can now deploy our application to the server. After going to <code class="email">http://localhost:8080/ticket-agency-ws/index.html</code> in your browser, you should see your application running, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00070.jpeg" alt="Adding AngularJS" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">You <a id="id868" class="calibre1"/>can use the developer's tools in <a id="id869" class="calibre1"/>Chrome (or FireBug in Mozilla Firefox) to inspect the <code class="email">rest</code> calls that are done against the server; simply press <span class="strong"><em class="calibre10">F12</em></span> and switch to the <span class="strong"><strong class="calibre9">Network</strong></span> tab:</p><div class="mediaobject"><img src="../images/00071.jpeg" alt="Adding AngularJS" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Congratulations! You have just created a modern Internet application and combined it with a REST <a id="id870" class="calibre1"/>API that was earlier used by a standalone <a id="id871" class="calibre1"/>console application!</p></div></div></div>
<div class="book" title="Choosing between SOAP and REST services"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec35" class="calibre1"/>Choosing between SOAP and REST services</h1></div></div></div><p class="calibre8">The <a id="id872" class="calibre1"/>choice of adopting SOAP rather<a id="id873" class="calibre1"/> than REST depends on your application's requirements. SOAP web services are exposed using their own well-defined protocol and focus on exposing pieces of application logic as services. So if your requirement is to consume business services that are exposed using a well-defined and negotiated contract (between the service consumer and service provider), SOAP web services are a perfect match.</p><p class="calibre8">On the other hand, if you need to access some server resources using stateless HTTP invocations and as little as possible of  the navigation bar of your browser, you should probably go with RESTful web services.</p><p class="calibre8">That being said, there may still be some scenarios that could fit both the options, and you are free to choose whichever web service suits your requirements the best. Recently, REST has gained popularity, thanks to its interoperability. We use only the HTTP protocol and JSON, which almost every language can handle. Therefore, a REST API developed using Java EE can be used by a wide variety of clients along with mobile devices. Often, this feature is a deal breaker when it comes to designing a system.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec36" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we introduced some of the basic web services concepts so that you could get acquainted with these technologies before using them to enhance your ticket application.</p><p class="calibre8">Then, we went through SOAP-based web services that are based on a contract between the service and client defined by the WSDL file. SOAP web services are an excellent option to integrate systems when you have well-defined, abstract operations exposed using standard XML files.</p><p class="calibre8">Then, we discussed REST services. The key to the REST methodology is to write web services using an interface that is already well known and widely used: the URI. The twist here is to identify the key system resources (this can be entities, collections, or anything else the designer thinks is worthy of having its own URI) and expose them using standard methods that are mapped to standard methods. In this case, the HTTP verbs are mapped to resource-specific semantics.</p><p class="calibre8">We created two applications that use our REST API: one console-based and one written purely in JavaScript using AngularJS. Both of these use the same REST endpoints and the second one knows only about JSON; it has no idea about the Java classes underneath (or even about Java).</p><p class="calibre8">We discussed application server resources a lot. In the next chapter, we will explore another approach for client-server communication: WebSockets.</p></div></body></html>