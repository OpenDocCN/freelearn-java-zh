- en: Chapter 6. The Real-world Project with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have discussed about building the Java project, web project, Gradle
    life cycle, and multi-module feature of Gradle. As we know, before Gradle, there
    were many other build tools in the market, out of which the most popular ones
    are Ant and Maven. Since many project build scripts were already written in these
    two build tools. In this chapter, we will discuss different migration strategies
    to migrate the projects existing build scripts from Ant, Maven, to Gradle. Along
    with this, we will also focus on integrating Gradle build script to Continuous
    Integration tools like Jenkins and generating Java docs for the code.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from an Ant-based project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ant is one of the initial and most popular build tools, which made build and
    deployment processes much simpler as compared to other native script-based build
    tools. Still, you can find many projects that use Ant build script to build the
    project. Ant was developed on the philosophy of imperative programming model,
    which tells the system what to do and also how to do it. Thus, you have the benefit
    of controlling each and every action or step of your build script. The following
    is the sample Ant build script to build any Java project. Here, we are considering
    only minimal required tasks to build a Java project, since our purpose is to discuss
    the strategies to migrate from Ant scripts to Gradle scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined three targets such as `clean`, `compile`, and `createJar`,
    which will delete the directories, create the directories, compile the Java file
    present in source directories, and finally create the `.jar` file, respectively.
    There are three different strategies that a developer can follow in order to migrate
    the build scripts from Ant to Gradle, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing an Ant file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AntBuilder API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting Ant tasks to Gradle tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of them with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Importing an Ant file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very first and simplest approach for migration is to directly import your
    Ant script file into a Gradle script. Consider the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the project name is `Chapter6`, the Java source directory is `src/main/java`,
    and the Ant build script file is `build.xml`. The source code of `build.xml` is
    mentioned above. Now, as a part of the migration, create the `build_import.gradle`
    file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all. Yes, we have successfully migrated the Ant build script to Gradle
    script. Now, try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After executing this, you can find the `build`/`classes` and `dist` directory
    in the project directory, and `dist` contains the `JavaProject.jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using AntBuilder API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach to migrate is using AntBuilder API. By default, Gradle provides
    an AntBuilder object `ant` to the user. The user can use this object directly
    in the Gradle script to call the Ant tasks. The following is the sample code of
    the `build_antbuilder.gradle` file using AntBuilder API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see we have used different Ant tasks such as `mkdir`, `javac`,
    `jar`, and so on, as a method of an `ant` object. Now, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here also, you will find the same output, that is, it will create the `build`/`classes`
    directory in which you can find class files and the `dist` directory in which
    you can find the `.jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting Ant tasks to Gradle tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the final approach. Using this approach rather than using an `ant` object,
    you actually rewrite the complete build logic or functionality using the actual
    Gradle tasks. One simple approach to follow this strategy is that the user first
    needs to logically understand the complete flow file written in Ant and then convert
    it into a Gradle script step by step. For all the targets defined in Ant, the
    user can create tasks in Gradle, and for all the tasks defined in Ant, the user
    can use Gradle features to replicate the same behavior. Gradle provides different
    standard plugins to support most of the steps of the build requirement. A plugin
    has its own life cycle, and with the help of plugins, the user can avoid rewriting
    lot of boiler-plate scripts for a common build functionality. One such plugin
    is the `java` plugin. We have already seen the `java` plugin details in [Chapter
    2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 2. Building
    Java Projects"), *Building Java Projects*. If we want to migrate this Ant script
    to Gradle script in order to build a Java project, the user can simply use a `Java`
    plugin and job is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `build.gradle` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a developer follows the default conventions of a `java` plugin, he only
    needs to write this one line to build a Java project, and on executing the `gradle
    build` command, all the required steps would be done such as compiling code, executing
    unit test cases, and preparing a `.jar` file. However, this is not the case always;
    many legacy projects do not follow the conventions and they might have their own
    conventions. The `gradle` plugin provides the flexibility to configure the plugin
    based on the project''s need. We will rewrite the Ant script into Gradle script
    in the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Migrating from a Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven, one of the another build tool, which got most popularity after Ant and
    it also came with dependency management solution to the problem that the users
    were facing in Ant. The first problem in Ant was imperative programing where user
    has to write lots of boiler plate code. Another problem was dependency management.
    Ant does not have any in-built dependency management solution (Ant later integrated
    with Ivy for dependency management). A user has to write each and every JAR file
    path in the build file that it needs to download, and in case of transitive dependencies,
    it is too complex for the user to identify each and every dependent JAR and mention
    the JAR name in the build file. Also, in case of version conflicts, it consumes
    lots of a developer's efforts. Maven came with the declarative programing model
    and in-built dependency management solution. Gradle is also built on the top of
    these principles; thus, migrating from Maven to Gradle seems very comfortable
    for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Ant migration, Gradle does not provide any import feature or in-built
    Maven object. A user needs to rewrite the Maven script to the Gradle script. The
    following are some of the concepts that will help you to smoothly migrate from
    Maven to Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: Plugin declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repositories configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s move towards the explanation of these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugin declaration**: The plugin is the key driver for both Maven and Gradle
    functionalities. Same as Maven plugins, Gradle also packages most of its functionalities
    into plugins. In Maven, a user includes the plugin in the following XML format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To include a plugin, the user only needs to write the `apply plugin` statement
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Common conventions**: In both Maven and Gradle, a plugin always comes with
    some common conventions for its functionalities. For example, if a user includes
    a `java` plugin, the common convention is that the source code location should
    be `src/main/java`, test code location should be `src/test/java`, and so on. If
    a user includes a plugin and follows the same convention, then he can avoid writing
    any boiler-plate code that could save both his time and effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: Both Maven and Gradle come with in-built dependency
    management features. A user does not need to bother about each and every individual
    JAR required for the project. He just needs to mention the first-level dependency
    in the project, the rest all is taken care by the build tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Maven, a user can mention the dependency in the following format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To define the dependency in Gradle, a user has to use the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What scope is to Maven, the dependency configuration is to Gradle. You might
    have observed the scope attribute in Maven and dependency configuration attributes
    in Gradle. In Maven, scope identifies at which phase of build dependency needs
    to be downloaded. In Gradle, dependency configurations fulfill the same need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Repositories configuration**: Whenever we talk about dependencies, the first
    thing that comes into mind is the repository. This is the location from where
    you download dependencies. The following is the code snippet that can help you
    mention the repository location in Maven:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Gradle, you can mention the repository using the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we have seen, both Maven and Gradle follow the same philosophy for building
    any project. The main difference is Maven uses XML that is good at structure,
    but can be a pain while configuring the build script, whereas Gradle uses Groovy
    script that is a DSL and offers great flexibility while managing and altering
    the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a software does not make much sense unless you publish your software
    to some common repositories so that, if needed, it can be reused by other software
    or projects. We have discussed the repositories while downloading the dependencies.
    The other aspect of repositories is uploading the build outcome (JAR, WAR, EAR,
    and so on) to some common location so that it could be downloaded by other developers.
    The different plugins in Gradle provide an automated way to publish the default
    artifacts of the plugin. For example, a `java` plugin provides a task to upload
    a JAR file, a `war` plugin provides a task to upload a WAR file, a `scala` plugin
    provides a task to upload a JAR file, and so on. A user just needs to configure
    the *upload repository* location. If a user does not want to upload the default
    build artifact or a user wants to upload some custom artifacts, he can easily
    customize Gradle tasks to upload the other artifacts and also as per his custom
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, a `java` plugin provides different configurations such as compile,
    testCompile, runtime, and so on, to download JAR for a specific scope. To upload
    artifacts, Gradle provides one additional configuration, **archives**. A user
    can configure the artifact in archives configuration, and using the `uploadArchive`
    task, he can upload the artifacts to a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample example of the build file (`build_uploadArtifact.gradle`)
    to upload a JAR file generated by a `java` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can execute the `gradle –b build_uploadArtifact.gradle uploadArchives` command
    to upload the artifacts. As a part of life cycle, it will build and upload the
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `uploadArchives` task uploads the artifact to
    a repository (mentioned in the URL). If it is a secured repository, you can provide
    a username and password, or else ignore it. You have noticed that we have not
    mentioned archives here, so what would get uploaded? As we have already discussed,
    a `java` plugin builds the JAR file, a `war` plugin builds the WAR file, and so
    on. Thus, the default artifact generated by a plugin would be uploaded by default
    as a part of the `uploadArchives` task. We will see another example as to how
    to upload your custom artifact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `build_uploadCustom.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the `gradle –b build_uploadCustom.gradle uploadArchives` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can find that a new directory `tempRepo` is created after executing
    the build script. This contains all the above artifacts (ZIP, JAR, and XML files)
    that are published by the Gradle script.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have covered the following two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a custom file (a XML and ZIP file along with the default artifact)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading to a local file system (not on a central repository)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you configure any other custom file (JAR, WAR, or any other file) to the
    archives, it will also get uploaded to the repository. Here, we have configured
    two additional files, one `.xml` file and one `.zip` file along with the default
    Java artifact. If you want to share your artifacts with your team mates and at
    the same time do not want to upload the artifact to the repository, unless it
    passes integration tests, Gradle gives you the flexibility to upload the file
    to a local file system using `flatDir`.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle recently introduced a `maven-publish` plugin to have more control over
    the publishing process. It gives you many additional flexibilities along with
    the default publish tasks. A user can modify the POM file, publish multiple modules,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more details at [https://docs.gradle.org/current/userguide/publishing_maven.html](https://docs.gradle.org/current/userguide/publishing_maven.html).
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is one of the most popular buzzwords you
    can read everywhere. As is apparent from its name, CI is the process of integrating
    the code base each time; whenever any one makes commits to the repository. It
    compiles the code, run the unit test cases and prepare the build. One of the benefits
    a user gets here is, if there are compile issues and integration issues, a user
    can figure out at early stages, rather than it being too late. The following is
    the generic workflow the CI tool follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Integration](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1
  prefs: []
  type: TYPE_NORMAL
- en: How does Gradle fit into this flow? To plan the build and deployment automation
    solution for any software, we need a different set of tools to work together to
    achieve the common goal. Jenkins is one of the integration tools that helps to
    integrate the complete workflow. It also works on the concept of plugins; you
    can add different plugins to Jenkins (for example, Gradle, Git, Svn, and so on)
    as per your need and configure them to plan the automation flow.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are assuming that you have installed Jenkins. You can install a **Gradle
    plugin** by navigating to **Manage Jenkins** | **Manage Plugins** | **Search for
    Gradle**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Integration](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a plugin is installed, you can configure jobs in Jenkins using the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Integration](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3
  prefs: []
  type: TYPE_NORMAL
- en: Under project configuration screen, you need to configure the repository path.
    By default, Jenkins provides CVS and SVN plugins. If you need any other repository
    (perforce or Git), you can add the respective plugins. After repository configuration,
    you need to configure the **Build Triggers**. It allows you to trigger build periodically
    or, if you want to build on every commit, you can choose **Poll SCM**. Now, it
    is time to configure your build script that will build your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the **Build** menu, you can choose **Invoke Gradle script**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Integration](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the default build file name `build.gradle`, there is no need
    to configure the build file. Under **Task**, you can mention the name of the task
    you want to execute. For example, if you want to build the project, you can mention
    `build` in the text box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the configuration is done, you can click on **Build Now** on the left
    menu to build the project. Once done, click on the respective build number and
    it will display **Console Output** on the main screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous Integration](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation is one of the important part of development life cycle, which
    does not get enough attention from developers. If code is not properly documented,
    it always increases the maintenance efforts and also it takes time for the new
    team member to understand the code, if the code lacks the documentation. When
    you apply **Java plugin** to your build file, Gradle provides you a `javadoc`
    task. By default, Gradle generates the initial documentation for your code, even
    if the user does not mention any **Javadoc** in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Java sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the basic Java docs at `<project> \build\docs\javadoc`.
  prefs: []
  type: TYPE_NORMAL
- en: As per requirements, you can add your own tags (`@description`, `@param`, and
    so on) and details to the above class and get the updated Java docs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different migration strategies from existing build
    tools to Gradle, which could be very handy for users who are planning to migrate
    their existing Ant and Maven scripts to Gradle. We also discussed how to publish
    artifacts to repositories, which is a key functionality of any build tool, which
    help the users to always fetch the latest artifacts from the repositories. We
    discussed CI framework with the help of Jenkins and how Gradle fits into this
    flow, while automating the build and deployment solution. Finally, we discussed
    how to generate documents for the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing how to integrate TestNG with Gradle,
    which would help the user to run test cases as a part of the Gradle build. We
    will also be discussing integration testing strategies and Gradle integration
    with code analysis and code coverage tools.
  prefs: []
  type: TYPE_NORMAL
