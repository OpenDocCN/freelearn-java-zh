- en: Behavioral Design Patterns – Part One
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为设计模式 – 第一部分
- en: 'Our journey through the Scala design patterns has arrived at the group of **behavioral
    design patterns**. There are more members in this group than the others we''ve
    already been through, so we will split it into two separate parts. In this chapter,
    we will focus on the following behavioral design patterns:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Scala设计模式的探索已经到达了**行为设计模式**这一组。这个组比我们之前经历的其他组成员更多，所以我们将将其分为两个独立的部分。在本章中，我们将重点关注以下行为设计模式：
- en: Value object
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象
- en: Null object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空对象
- en: Strategy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Chain of responsibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Interpreter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: This chapter and the next one will give some clarity about what behavioral design
    patterns are, where they are useful, and how to implement them in Scala. We will
    be following a path similar to the previous chapters where we presented the patterns,
    showed a class diagram and a code example, and finally, gave a few hints about
    what to watch out for and where certain patterns are preferred to be used. Hopefully,
    you will get a feel for them and be able to confidently identify situations where
    they are applicable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章将阐明行为设计模式是什么，它们在哪里有用，以及如何在Scala中实现它们。我们将遵循与之前章节类似的道路，其中我们展示了模式、类图和代码示例，并最终给出了一些需要注意的事项和某些模式更倾向于在哪里使用的一些提示。希望你能对它们有一个感觉，并能够自信地识别出它们适用的场景。
- en: Defining behavioral design patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义行为设计模式
- en: Behavioral design patterns, as the name suggests, are to do with behavior. Their
    purpose is to identify and implement common communication patterns between objects
    in an application. They define object interaction in such a way that the communication
    between objects is easy and coupling is still kept at a low level.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，行为设计模式与行为有关。它们的目的在于识别和实现应用程序中对象之间的常见通信模式。它们以定义对象交互的方式，使得对象之间的通信变得容易，并且耦合仍然保持在较低水平。
- en: Behavioral design patterns describe how objects and classes interact with each
    other using messages. Contrary to creational and structural design patterns, the
    behavioral design patterns describe a **flow** or a **process**. This means that
    a developer should be really familiar with the actual process they are trying
    to implement. As with every other type of design pattern, behavioral design patterns
    exist in order to increase the testability, maintainability, and flexibility of
    the produced code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式描述了对象和类如何通过消息相互交互。与创建型和结构型设计模式相反，行为设计模式描述了一个**流程**或**过程**。这意味着开发者应该非常熟悉他们试图实现的实际过程。与其他类型的设计模式一样，行为设计模式的存在是为了提高产生的代码的可测试性、可维护性和灵活性。
- en: The value object design pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象设计模式
- en: In programming, there are different ways of comparing data. We can compare object
    identities or their values. These are useful in different scenarios and here,
    we will see what value objects are and when they can be used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，比较数据的方式有很多种。我们可以比较对象的标识或它们的值。这些在不同的场景中很有用，在这里，我们将看到值对象是什么以及它们何时可以使用。
- en: Value objects are small and simple immutable objects. Their equality is based
    not on identity, but on value equality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是小而简单的不可变对象。它们的等价性不是基于身份，而是基于值等价性。
- en: Value objects are used to represent numbers, money, dates, and so on. They should
    be small and immutable; otherwise, changing values could cause bugs and unexpected
    behavior. They are quite useful in multithreaded applications due to their immutability.
    They are also commonly used as data transfer objects in enterprise applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象用于表示数字、货币、日期等。它们应该是小而不可变的；否则，改变值可能会引起错误和意外行为。由于它们的不可变性，它们在多线程应用程序中非常有用。它们也常在企业应用程序中用作数据传输对象。
- en: An example class diagram
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: In languages such as Java, there is no direct support for value objects. What
    developers end up doing is to declare the fields as final and implement the `hashCode`
    and `equals` methods.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如Java这样的语言中，没有直接对值对象的支持。开发者最终会做的是将字段声明为final并实现`hashCode`和`equals`方法。
- en: 'Immutability, however, is a concept that is pretty much enforced in Scala.
    We already saw the **algebraic data types** (**ADTs**) earlier—they also fall
    in the value object category. Case classes and tuples are also immutable and they
    are used to achieve the value object design pattern. The following class diagram
    shows an example of the value object design pattern in Scala:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不可变性是一个在Scala中几乎强制执行的概念。我们之前已经看到了**代数数据类型**（**ADTs**）——它们也属于值对象类别。案例类和元组也是不可变的，它们用于实现值对象设计模式。以下类图显示了Scala中值对象设计模式的一个示例：
- en: '![](img/7245b962-065f-48a4-a276-328f2d2ca489.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7245b962-065f-48a4-a276-328f2d2ca489.png)'
- en: This diagram really doesn't do anything special. It is a representation of a
    case class called **Date**. This is everything we need to do in order to achieve
    immutability and be able to implement the value object design pattern.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表实际上并没有做什么特别的事情。它是一个名为**Date**的案例类的表示。这就是我们为了实现不可变性和能够实现值对象设计模式所需要做的所有事情。
- en: A code example
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个代码示例
- en: 'In our code example, we will use our `Date` class. Dates are quite commonly
    used in software products. Of course, there are libraries that provide complete
    functionality around date manipulations, but this should be good enough for an
    example. First of all, here is the `Date` class representation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们将使用我们的`Date`类。日期在软件产品中相当常用。当然，有一些库提供了关于日期操作的完整功能，但这对于示例来说已经足够了。首先，这是`Date`类的表示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is everything we need in order to get a value object. Scala does everything
    for us in the background by creating default implementations for the `hashCode`,
    `equals`, and `toString` methods. Case classes give us extra power, but this is
    out of this section's scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的一切，以便获得值对象。Scala在后台为我们创建默认实现，用于`hashCode`、`equals`和`toString`方法。案例类给我们带来了额外的功能，但这超出了本节的范围。
- en: 'Now, let''s use our `Date` class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的`Date`类：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we used our object as values. We should note that here, we
    have absolutely no validation of the parameters; however, it is something easy
    to add, but not relevant for the current example. If we run our code now, we will
    see the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了我们的对象作为值。我们应该注意，在这里，我们对参数没有任何验证；然而，这很容易添加，但与当前示例无关。如果我们现在运行我们的代码，我们将看到以下输出：
- en: '![](img/94f19c8a-5bd4-443e-b3d3-d092f2bba683.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94f19c8a-5bd4-443e-b3d3-d092f2bba683.png)'
- en: 'Just to prove that case classes allow us to implement the value object design
    pattern easily and normal classes don''t, let''s try and change our `Date` class
    to a normal one and then use it in the same example. Our class will change to
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明案例类使我们能够轻松实现值对象设计模式，而普通类则不能，让我们尝试将我们的`Date`类改为普通类，然后在相同的示例中使用它。我们的类将变为以下内容：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we will take the same example; however this time, we will use the `BadDate`,
    and since it''s not a case class, we will create it with the `new` keyword:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用相同的示例；然而，这次我们将使用`BadDate`，由于它不是一个案例类，我们将使用`new`关键字创建它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of this example will be:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出将是：
- en: '![](img/71d761db-03fc-4bc4-b29b-534a6c6891d9.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71d761db-03fc-4bc4-b29b-534a6c6891d9.png)'
- en: As you can see from the preceding output, normal classes do not work in the
    same way as case classes and some extra work needs to be performed in order to
    implement the value object design pattern with them. The reason for the preceding
    result is that classes, by default, are compared with each other by their reference
    identities and not by the values they carry. In order to change this, `hashCode`
    and `equals` should be implemented. Scala also allows us to override the `==`
    operator for the class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的输出中看到的那样，普通类与案例类的工作方式不同，需要做一些额外的工作才能使用它们实现值对象设计模式。前面结果的原因是，类默认情况下是通过它们的引用标识来相互比较的，而不是通过它们携带的值。为了改变这一点，应该实现`hashCode`和`equals`。Scala还允许我们为类重写`==`运算符。
- en: Alternative implementation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的实现
- en: The value object design pattern can also be achieved with predefined tuple classes
    in Scala. In this case, we don't even need to create our class and we can write
    something like `(3, "March", 2016)`. This would automatically have the same characteristics
    as value objects. There are implementations of tuples of up to 22 elements, but
    using them in real applications is not recommended, as readability and quality
    can degrade dramatically. Moreover, two *n* element tuples can be considered equal,
    even if semantically they are different types of objects in our application. Last
    but not least, accessing elements using case classes is much easier and nicer
    to read than writing something like `tuple._3`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，也可以使用预定义的元组类来实现值对象设计模式。在这种情况下，我们甚至不需要创建我们的类，可以写一些像`(3, "March", 2016)`的东西。这将自动具有与值对象相同的特性。有最多22个元素的元组实现，但在实际应用中使用它们并不推荐，因为可读性和质量可能会大幅下降。此外，两个*n*个元素的元组可以被认为是相等的，即使从语义上讲，它们在我们应用中是不同类型的对象。最后但同样重要的是，使用案例类访问元素比编写像`tuple._3`这样的东西更容易、更易于阅读。
- en: What it is good for
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: As we already mentioned, the value object design pattern is good for multithreading
    and creating **data transfer objects** (**DTOs**). It is something extremely easy
    to achieve in Scala, and many people use it on a daily basis without even realizing
    that it actually is a design pattern. Value objects are another example of the
    fact that Scala is a really powerful language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，值对象设计模式适用于多线程和创建**数据传输对象**（**DTOs**）。在Scala中，这非常容易实现，许多人每天都在使用它，甚至没有意识到它实际上是一种设计模式。值对象是Scala真正强大语言的一个例子。
- en: What it is not so good for
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: Other than using tuples to represent value objects in Scala, there are no other
    major drawbacks to using this pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Scala中使用元组来表示值对象之外，使用这种模式没有其他主要缺点。
- en: The null object design pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象设计模式
- en: Most object-oriented languages have a way of specifying the nonexistence of
    some value. In Scala and Java, for example, this could be the `null` value that
    can be assigned to an object. Calling any method on an object that is `null` would
    result in a `NullPointerException`, hence developers should be careful and check
    whether there is such a possibility. These checks, however, could make the source
    code hard to follow and extend as developers should always be aware. This is where
    the null object design pattern is helpful.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的语言都有一种指定某些值不存在的方式。例如，在Scala和Java中，这可能是可以分配给对象的`null`值。对一个`null`对象调用任何方法都会导致`NullPointerException`，因此开发者应该小心并检查是否存在这种可能性。然而，这些检查可能会使源代码难以理解和扩展，因为开发者应该始终保持警觉。这就是空对象设计模式发挥作用的地方。
- en: The purpose of the null object design pattern is to define an actual object
    that represents the `null` value and has neutral behavior.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象设计模式的目的在于定义一个实际的对象，它代表`null`值并具有中性行为。
- en: Using null objects removes the need to check whether something is set to `null`
    or not. The code becomes much more readable and easy to understand and makes bug
    occurrence harder.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空对象可以消除检查某个值是否设置为`null`的需求。代码变得更加易于阅读和理解，并使得错误发生的可能性降低。
- en: An example class diagram
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'For the class diagram, let''s imagine that we have a system that has to poll
    a queue for messages. Of course, this queue might not always have anything to
    offer, so it would return nulls. Instead of checking for `null`, we could simply
    return special null objects that will have empty behavior. Let''s show these message
    classes in a diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，让我们想象我们有一个系统必须轮询队列以获取消息。当然，这个队列可能不会总是有东西提供，所以它会返回`null`。而不是检查`null`，我们可以简单地返回具有空行为的特殊空对象。让我们在图中展示这些消息类：
- en: '![](img/05ead116-8979-4772-b363-223aecce4e84.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05ead116-8979-4772-b363-223aecce4e84.png)'
- en: Using the classes from the preceding diagram, whenever there is no number to
    print, we will return a **NullMessage** object with empty behavior. In some cases,
    for optimization purposes, people could have the **NullMessage** as a singleton
    instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面图中的类，每当没有数字要打印时，我们将返回一个具有空行为的**NullMessage**对象。在某些情况下，为了优化目的，人们可能会将**NullMessage**作为一个单例实例。
- en: A code example
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Before we actually look at our code, we will note a few observations about the
    preceding diagram. It represents a classical case using the null object design
    pattern. However, nowadays, it is not really used this way in either Java or Scala.
    For example, Java now supports `Optional`, which is used instead (assuming people
    use new versions of the language). In Scala, things are similar—we can and do
    use `Option[Message]` instead of null objects. Additionally, we gain all the other
    nice features of `Option` such as the ability to use them in pattern matching.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正查看代码之前，我们将注意一些关于前面图表的观察。它代表了一个使用空对象设计模式的经典案例。然而，如今，在Java或Scala中实际上并没有这样使用。例如，Java现在支持`Optional`，这被用作替代（假设人们使用语言的新版本）。在Scala中，情况类似——我们可以使用`Option[Message]`而不是空对象。此外，我们还获得了`Option`的所有其他良好特性，例如在模式匹配中使用它们的能力。
- en: 'So, as mentioned previously, our code is not really going to use the hierarchy
    of the preceding class diagram. It just doesn''t need it and it will be much simpler.
    Instead, we will be using `Option[Message]`. First of all, let''s see the `Message`
    class definition:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如前所述，我们的代码实际上不会使用前面类图中的层次结构。它根本不需要它，并且将会更简单。相反，我们将使用`Option[Message]`。首先，让我们看看`Message`类的定义：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We mentioned that we will be polling a queue for messages and then displaying
    them. We have simulated a queue that is being randomly populated using a different
    thread in our application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到我们将轮询队列以获取消息，然后显示它们。我们在应用程序中使用不同的线程模拟了一个随机填充的队列：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code shows what will be run in a different thread. The queue will
    be populated with random values between 0 (inclusive) and 10 (exclusive) at random
    intervals. Then, `getMessage` can be called and whatever is in the queue can be
    read. Since it is possible for the queue to be empty, we return an `Option` of
    `Message` to the caller. It is probably worth mentioning that in Scala, `Option(null)`
    returns `None`. This is exactly what we took advantage of in the preceding code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了将在不同线程中运行的代码。队列将在随机间隔内填充0（包含）到10（不包含）之间的随机值。然后，可以调用`getMessage`，并读取队列中的任何内容。由于队列可能为空，我们向调用者返回一个`Message`的`Option`。可能值得提一下，在Scala中，`Option(null)`返回`None`。这正是我们在前面的代码中所利用的。
- en: 'Let''s see how everything comes together in our example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的示例中所有这些是如何结合在一起的：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding program creates a generator and makes it run on a different thread.
    Then, it randomly requests items from the generator and prints them if something
    is actually returned. Due to the use of random generators, the program will print
    different things every time. Here is an example run:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序创建了一个生成器，并在不同的线程上运行它。然后，它随机请求生成器中的项目，并在有返回值时打印它们。由于使用了随机生成器，程序每次打印的内容都不同。以下是一个示例运行：
- en: '![](img/c7704895-c3d7-4eaa-b5b8-1c68814f69b8.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7704895-c3d7-4eaa-b5b8-1c68814f69b8.png)'
- en: As you can see from our example and the preceding output, we never actually
    check for nulls and our code just doesn't do anything when the queue returns `null`.
    This works nicely in large projects and it makes the source code look really elegant
    and easy to understand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的示例和前面的输出中看到的，我们实际上从未检查过`null`，并且当队列返回`null`时，我们的代码根本不做任何事情。这在大型项目中工作得很好，并且使源代码看起来非常优雅且易于理解。
- en: In real-life applications, code as in the previous example might not be a good
    idea. First of all, instead of calling `sleep` on a thread, we can use timers.
    Secondly, if we want to create producer–consumer applications, we can use libraries
    such as **Akka** ([https://akka.io/](https://akka.io/)), which allow us to do
    reactive programming and have really optimal code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，像前面示例中的代码可能不是一个好主意。首先，我们可以在线程上使用定时器而不是调用`sleep`。其次，如果我们想创建生产者-消费者应用程序，我们可以使用如**Akka**（[https://akka.io/](https://akka.io/））之类的库，这些库允许我们进行响应式编程，并拥有非常优化的代码。
- en: What it is good for
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: As you already saw, the null object design pattern is already incorporated in
    Scala (and newer versions of Java) through the use of `Option` (`Optional` in
    Java). This makes it really easy to use and shows the power of the language once
    more. Using null objects makes our code look much more readable and removes the
    need to take extra care when a value is `null`. It also reduces the risk of bugs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，空对象设计模式已经通过使用`Option`（Java中的`Optional`）在Scala（以及Java的新版本）中实现。这使得它非常容易使用，并再次展示了语言的力量。使用空对象使我们的代码看起来更加易读，并消除了在值是`null`时需要额外小心的需求。它还降低了出错的风险。
- en: What it is not so good for
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: There are no drawbacks of this design pattern that we can think of. One thing
    probably worth mentioning is this—use it only when it is actually needed, not
    everywhere.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想不出这个设计模式有什么缺点。可能值得提一下的是——只有在真正需要的时候才使用它，而不是到处都使用。
- en: The strategy design pattern
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: It is quite a common thing in enterprise applications to have different implementations
    of specific algorithms and choosing one to use while the application is running.
    Some examples might include different sorting algorithms that would have a different
    performance for different sizes or types of data, different parsers for various
    possible representations of data, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，有不同算法的实现，并在应用程序运行时选择一个使用，这是相当常见的事情。一些例子可能包括对不同大小或类型数据的排序算法，对不同数据可能表示的解析器，等等。
- en: The strategy design pattern enables us to define a family of algorithms and
    select a specific one at runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式使我们能够在运行时定义一组算法并选择一个特定的算法。
- en: The strategy design pattern helps with encapsulation as each algorithm can be
    separately defined and then injected into the classes that use it. The different
    implementations are also interchangeable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式有助于封装，因为每个算法都可以单独定义，然后注入到使用它的类中。不同的实现也是可互换的。
- en: An example class diagram
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'For the class diagram, let''s imagine that we are writing an application that
    needs to load some data from a file and then use this data somehow. Of course,
    the data could be represented in different formats (CSV or JSON, in this case),
    and depending on the file type, we will be using a different parsing strategy.
    The class diagram that represents our parser is shown in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类图，让我们想象我们正在编写一个需要从文件加载数据并使用这些数据的程序。当然，数据可以以不同的格式表示（在这种情况下是 CSV 或 JSON），并且根据文件类型，我们将使用不同的解析策略。表示我们的解析器的类图如下所示：
- en: '![](img/95f2cea4-955a-49ff-bb2e-91625b566eea.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95f2cea4-955a-49ff-bb2e-91625b566eea.png)'
- en: We basically have an interface that the different classes implement, and then
    depending on which one is needed, **PersonApplication** gets injected with the
    right one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上有一个接口，不同的类实现它，然后根据需要，**PersonApplication** 被注入正确的实现。
- en: The preceding class diagram looks really similar to the one we saw earlier in
    the book for the bridge design pattern. Even though this is the case, both patterns
    have different purposes—the builder is concerned with structure, while here it's
    all about behavior. Also, the strategy design pattern looks somewhat more coupled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类图与我们在书中看到的桥接设计模式的类图非常相似。尽管如此，这两种模式有不同的目的——构建者关注结构，而这里完全是关于行为。此外，策略设计模式看起来耦合度更高。
- en: A code example
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个代码示例
- en: 'In the previous section, we showed the class diagram of the example we will
    show here. As you can see, we used a model class called `Person`. It is just a
    case class with the following definition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了这里将要展示的示例的类图。正如你所见，我们使用了一个名为 `Person` 的模型类。它只是一个具有以下定义的案例类：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since there will be different formats available in our application, we have
    defined a common interface that all parsers will implement:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序中可能会有不同的格式，我们定义了一个公共接口，所有解析器都将实现：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s have a look at the implementations. First is the `CSVParser`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实现。首先是 `CSVParser`：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It relies on a library called `scala-csv` (details in the `pom.xml/build.sbt`
    file), which reads each line as a list of strings. Then, they are mapped to the
    `Person` objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它依赖于一个名为 `scala-csv` 的库（详细信息见 `pom.xml/build.sbt` 文件），该库将每一行读取为字符串列表。然后，它们被映射到
    `Person` 对象。
- en: 'Next is the code for the `JsonParser` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `JsonParser` 类的代码：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It reads a JSON file and parses it using the `json4s` library. As you can see,
    even though both implementations do the same thing, they are quite different.
    We cannot apply the CSV one when we have a JSON file and vice versa. The files
    also look really different. Here is the CSV file we are using in our example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它读取一个 JSON 文件并使用 `json4s` 库进行解析。正如你所见，尽管两种实现做的是同一件事，但它们相当不同。当我们有一个 JSON 文件时，我们不能应用
    CSV 实现，反之亦然。文件看起来也非常不同。以下是我们在示例中使用的 CSV 文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the JSON file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 JSON 文件：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both the preceding datasets contain exactly the same data, but the formats make
    them look completely different and they require different approaches in parsing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据集包含完全相同的数据，但格式使它们看起来完全不同，并且需要不同的解析方法。
- en: 'There is one extra thing we''ve done in our example. We''ve used a factory
    design pattern in order to pick the right implementation at runtime, depending
    on the file type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们做了一件事。我们使用工厂设计模式来在运行时根据文件类型选择正确的实现：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding factory is just an example. It only checks the file extension
    and of course, could be made much more robust. Using this factory, we can pick
    the right implementation of the parser for the application class to use, whose
    code is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的工厂只是一个例子。它只检查文件扩展名，当然，可以做得更加健壮。使用这个工厂，我们可以为应用程序类选择正确的解析器实现，其代码如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The application class looks the same no matter what the implementation is. Different
    implementations could be plugged in, and as long as there are no errors, everything
    should run.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不论实现方式如何，应用程序类看起来都是一样的。不同的实现可以被插入，只要没有错误，一切都应该运行。
- en: 'Now, let''s see how we can use our strategy design pattern in our example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在示例中使用我们的策略设计模式：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, it''s pretty simple. The output of the preceding application
    is shown as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这相当简单。上一应用程序的输出如下所示：
- en: '![](img/73e1d7b4-dbec-40ec-8400-d8a67d54e516.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73e1d7b4-dbec-40ec-8400-d8a67d54e516.png)'
- en: In both cases, our application coped just fine with the different formats. Adding
    new implementations for new formats is also straightforward—just implement the
    `Parser` interface and make sure the factory knows about them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，我们的应用程序都能够很好地处理不同的格式。为新的格式添加新的实现也很简单——只需实现 `Parser` 接口并确保工厂知道它们。
- en: The strategy design pattern the Scala way
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 方式的策略设计模式
- en: In the preceding section, we showed the strategy design pattern using classes
    and traits. This is what it would look in a purely object-oriented language. However,
    Scala is also functional and provides more ways to achieve it by writing far less
    code. In this subsection, we will show the strategy design pattern by taking advantage
    of the fact that in Scala, functions are first-class objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了使用类和特性来设计策略模式。这就是在纯面向对象语言中的样子。然而，Scala 既是函数式语言，又提供了通过编写更少的代码来实现它的更多方法。在本小节中，我们将利用
    Scala 中函数是一等对象的事实来展示策略模式。
- en: 'The first thing that will change is that we will not need to have an interface
    and classes that implement it. Instead, our `Application` class will look like
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先会改变的是，我们不需要有一个接口及其实现它的类。相反，我们的 `Application` 类将如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The most important thing to note here is that the strategy parameter is a function
    instead of a normal object. This instantly allows us to pass any function we want
    there without the need to implement specific classes, as long as it satisfies
    these requirements—one `String` parameter and returns a `List[T]`. If we have
    multiple methods in our strategy, we can use a case class or a tuple to group
    them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的最重要的事情是，策略参数是一个函数而不是一个普通对象。这立即允许我们传递任何我们想要的函数，而无需实现特定的类，只要它满足这些要求——一个
    `String` 参数并返回一个 `List[T]`。如果我们策略中有多个方法，我们可以使用一个 case 类或元组来分组它们。
- en: 'For the current example, we''ve decided to have the function implementations
    somewhere so that they are grouped with the factory, which will choose which one
    to use:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前示例，我们决定将函数实现放在某个地方，以便它们与工厂一起分组，工厂将选择使用哪一个：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code has the same factory as before, but this time it returns
    methods, which can then be called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与之前的工厂相同，但这次它返回方法，然后可以调用这些方法。
- en: 'Finally, here is how to use the application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是如何使用应用程序的：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output of the preceding example will be absolutely the same as before.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上一例子的输出将绝对与之前相同。
- en: What it is good for
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么
- en: The strategy design pattern helps us when we want to be able to change implementations
    at runtime. Also, as we can see, the implementations live separately from the
    code that uses them, so it's quite easy to add new ones without the risk of introducing
    bugs in other parts of our system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式帮助我们能够在运行时更改实现。此外，如您所见，实现与使用它们的代码是分开的，因此很容易添加新的实现，而不会在其他系统部分引入错误。
- en: What it is not so good for
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么
- en: Even though, in the long run, the Scala way of implementing the strategy pattern
    that uses functions could save a lot on code, sometimes it affects readability
    and maintainability. The fact that the methods could be stored in an object, class,
    case class, trait, and so on, indicates the fact that different people could prefer
    different approaches, and this is not always good while working in a big team.
    Apart from that, the strategy design pattern doesn't have any major flaws as long
    as it's used in the right way and in the right places.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从长远来看，使用函数实现的Scala策略模式可能会节省大量代码，但有时它会影响可读性和可维护性。方法可以存储在对象、类、case类、特质中等，这表明不同的人可能更喜欢不同的方法，而在大型团队中工作时不总是好的。除此之外，只要正确使用和放置，策略设计模式没有任何重大缺陷。
- en: The command design pattern
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: Sometimes in our applications, we might need to pass information to other objects
    about how to perform some action. Usually, this action will be executed at a later
    time based on some kind of event. The object that will execute our commands is
    called **invoker**, and it might not even be aware of the command it actually
    runs. It just knows about the interface, which means that it knows how to trigger
    the command. The command design pattern helps us to achieve this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，有时我们可能需要将有关如何执行某些操作的信息传递给其他对象。通常，这个操作将在某种事件的基础上稍后执行。将执行我们命令的对象称为**调用者**，它甚至可能不知道它实际运行的命令。它只知道关于接口的信息，这意味着它知道如何触发命令。命令设计模式帮助我们实现这一点。
- en: The purpose of the command design pattern is to encapsulate the information
    needed to perform an action at a later stage and pass this information to the
    object that will be running the actual code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式的目的是在稍后阶段执行操作所需的信息进行封装，并将这些信息传递给将运行实际代码的对象。
- en: Usually, the command information will contain the object that owns the method,
    the method name, and the parameters that should be passed when invoking the method.
    The command design pattern is useful for many things, some of which include supporting
    undo actions, implementing parallel processing, or simply optimizing code by deferring,
    and possibly avoiding code execution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，命令信息将包含拥有方法的对象、方法名称以及调用方法时应传递的参数。命令设计模式在许多方面都很有用，其中包括支持撤销操作、实现并行处理，或者通过延迟和可能避免代码执行来优化代码。
- en: An example class diagram
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'When talking about the command design pattern, there are usually a couple of
    objects, each of which has its specific role:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论命令设计模式时，通常有几个对象，每个对象都有其特定的角色：
- en: '**Command**: We can think of this as the interface and its implementations
    that are being called by the invoker.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**: 我们可以将其视为调用者调用的接口及其实现。'
- en: '**Receiver**: This is the object that actually knows how commands are executed.
    Think of this as an object that is being passed to the command and then used in
    the interface method.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收者**: 这是实际知道如何执行命令的对象。可以将其想象为一个被传递给命令并在接口方法中使用的对象。'
- en: '**Invoker**: It invokes the commands by calling their interface method. As
    we mentioned earlier, it might not even know what commands are being invoked.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用者**: 它通过调用它们的接口方法来调用命令。正如我们之前提到的，它甚至可能不知道正在调用哪些命令。'
- en: '**Client**: It more or less guides which commands are executed when by using
    the invoker.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**: 它通过调用调用者来大致指导执行哪些命令。'
- en: 'Now that we know the most important objects and their roles in the command
    design pattern, we can take a look at an example. For the class diagram, let''s
    imagine that we have a robot, which can cook. We connect to it through a controller
    and send commands to our robot. Things are pretty simplified, but should be good
    enough to understand how this pattern works. Here is the class diagram:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了最重要的对象及其在命令设计模式中的角色，我们可以看看一个例子。对于类图，让我们想象我们有一个机器人，它可以烹饪。我们通过控制器连接到它并向我们的机器人发送命令。事情相当简化，但应该足以理解这个模式是如何工作的。以下是类图：
- en: '![](img/f4631968-eec5-4de7-afa4-4e05bb6679da.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4631968-eec5-4de7-afa4-4e05bb6679da.png)'
- en: We can quickly identify that here, the **RobotCommand** interface and its implementations
    are the command. The receiver is the **Robot** class as it knows how to run all
    the commands issued to it. The **RobotController** class is the invoker. It doesn't
    know what types of commands it executes, just runs them whenever needed. We haven't
    shown our client class in the preceding diagram, as it is simply represented by
    the example application that runs the code, which implements the previously shown
    class diagram.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速识别出，在这里，**RobotCommand** 接口及其实现是命令。接收者是 **Robot** 类，因为它知道如何运行所有发送给它的命令。**RobotController**
    类是调用者。它不知道它执行的是哪种类型的命令，只是在需要时运行它们。我们还没有在先前的图中展示我们的客户端类，因为它只是通过运行代码的示例应用程序来表示，该应用程序实现了之前显示的类图。
- en: You can easily see that if the code representing the preceding diagram is changed,
    it could easily add multithreaded support and support for undo.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地看到，如果代表先前图示的代码发生变化，它可以很容易地添加多线程支持和撤销功能。
- en: A code example
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Now, it's time to see the interesting part representing the previous diagram—the
    code. As always, we will be going through the individual classes and giving brief
    explanations where necessary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看代表先前图示的有趣部分——代码了。一如既往，我们将逐个查看各个类，并在必要时给出简要说明。
- en: 'The first piece of code that we will look at is the `Robot` class. We already
    mentioned that it acts as the receiver and knows how to execute some specific
    functionality:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一段代码是 `Robot` 类。我们之前提到过，它充当接收者并知道如何执行一些特定的功能：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ve kept the code simple and the methods just print different things to
    the command line. Next is the robot command with its different implementations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持了代码的简单性，方法只是将不同的内容打印到命令行。接下来是带有其不同实现的机器人命令：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is absolutely nothing special about the preceding code. It is a simple
    trait, which is implemented by different classes. It relies on the `Robot` receiver,
    which knows how to execute methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码绝对没有特殊之处。它是一个简单的特质，由不同的类实现。它依赖于 `Robot` 接收者，它知道如何执行方法。
- en: 'The `RobotController` class is our invoker and issues commands given to it
    according to the `RobotCommand` interface. It doesn''t need to know anything about
    the commands that it issues, as long as the interface is followed. We''ve decided
    to add some history of the commands that can be used for rollbacks later. The
    code for the invoker is shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`RobotController` 类是我们的调用者，根据 `RobotCommand` 接口发出命令。它不需要了解它发出的命令的任何信息，只要遵循接口即可。我们决定添加一些命令的历史记录，这些记录可以在以后进行回滚。调用者的代码如下所示：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s take a look at the example that uses all of the preceding classes.
    As we already mentioned earlier, it would actually act as a client. Here is the
    source code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用所有先前类的示例。正如我们之前提到的，它实际上将充当客户端。以下是源代码：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this application will be the same as in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的输出将与以下截图中的相同：
- en: '![](img/59a4ffe3-cc05-4d67-ba2e-ae2ce4a82a40.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59a4ffe3-cc05-4d67-ba2e-ae2ce4a82a40.png)'
- en: We can see that our invoker successfully saves the history of the events. This
    means that as long as our commands and then the receiver (`Robot`) have the undo
    methods, we can implement these and have extra functionality.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的调用者成功保存了事件的记录。这意味着只要我们的命令和接收者（`Robot`）有撤销方法，我们就可以实现这些方法并具有额外的功能。
- en: The command design pattern the Scala way
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 方式的命令设计模式
- en: The command design pattern is another example of a design pattern that can be
    implemented differently in Scala compared to other languages. We will show another
    implementation of the preceding example. This time, we will use the **by-name
    parameters** feature of the language. It is replaceable with passing functions
    as parameters (something we've already seen before for the strategy design pattern),
    but more verbose. Let's see what it will look like.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式是另一种设计模式，在 Scala 中与其他语言相比可以以不同的方式实现。我们将展示先前的示例的另一种实现。这次，我们将使用语言的 **按名参数**
    功能。它可以替换为传递函数作为参数（我们之前已经为策略设计模式看到过），但更冗长。让我们看看它将是什么样子。
- en: 'Not much of the application actually has to change. We''ve only refactored
    and renamed the `RobotController` and `RobotExample` classes. Here is the former
    class, now called `RobotByNameController`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，应用程序不需要做太多改变。我们只重构并重命名了 `RobotController` 和 `RobotExample` 类。以下是之前的类，现在称为
    `RobotByNameController`：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we don''t pass an actual command object but just a by-name
    parameter to the `issueCommand` method. What this method does is defer a call
    to whatever retrieves the value passed until it is actually needed. In order to
    make the preceding code work, we had to refactor our example code as well:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们并没有传递一个实际的命令对象，而是仅仅将一个按名传递的参数传递给`issueCommand`方法。这个方法所做的就是延迟对获取传递值的调用，直到实际需要时。为了使前面的代码能够工作，我们不得不对我们的示例代码进行重构：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The by-name parameters method is useful when we don't want to write extra code
    for the command interface and its implementations. We could just pass any function
    call (in this case, directly from the receiver) and it will be held off until
    the data is needed, or not called at all. The output will be the same as before,
    but with the exception that now we have functions, and the history printout will
    look slightly different.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不希望为命令接口及其实现编写额外代码时，按名参数方法很有用。我们只需传递任何函数调用（在这种情况下，直接从接收者传递）即可，它将被延迟到数据需要时，或者根本不调用。输出将与之前相同，但现在的区别是我们有了函数，历史打印输出将略有不同。
- en: What it is good for
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: The command design pattern is useful for cases where we want to delay, log,
    or sequence method calls for one reason or another. Another advantage is that
    it decouples the invoker from the object that actually performs the specific operations.
    This allows us to have modifications and to add new functionality pretty easily.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式适用于我们想要延迟、记录或按某种原因对方法调用进行排序的情况。另一个优点是它将调用者与实际执行特定操作的对象解耦。这使我们能够轻松地进行修改和添加新功能。
- en: What it is not so good for
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的缺点是什么
- en: Even though the by-name parameter method looks nice and could make our writing
    shorter, it might not be a great idea here. A big disadvantage compared with our
    previous example is that we could actually plug any `Unit` data there, which could
    possibly not be relevant to what the receivers are supposed to do. In other cases,
    though, the by-name parameter technique is quite useful and could dramatically
    improve our application performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管按名传递参数的方法看起来很优雅，并且可以使我们的写作更简洁，但在这里可能并不是一个好主意。与我们的前一个例子相比，一个很大的缺点是我们实际上可以插入任何`Unit`数据，这可能与接收者应该执行的操作不相关。然而，在其他情况下，按名传递参数技术非常有用，并且可以显著提高我们的应用程序性能。
- en: The chain of responsibility design pattern
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: Nowadays, with the growth of data sizes and the hype around big data, stream
    processing is something that many applications will have to be able to do. Stream
    processing is characterized by an endless stream of data, which is passed from
    one object to another while each of them could be doing some processing and then
    passing it on to the next one. In other cases, data could be moved on in the chain
    until it arrives at an object which knows how to process a certain command.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着数据规模的增长和大数据的热潮，流处理是许多应用程序必须能够执行的操作。流处理的特点是数据流的无尽流动，这些数据从一个对象传递到另一个对象，而每个对象都可以进行一些处理，然后将它传递给下一个对象。在其他情况下，数据可以在链中移动，直到到达一个知道如何处理特定命令的对象。
- en: The preceding behavior is really suitable for the chain of responsibility design
    pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行为非常适合责任链设计模式。
- en: The purpose of the chain of responsibility design pattern is to decouple the
    sender of a request from its receiver by giving multiple objects the chance to
    handle the request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链设计模式的目的是通过让多个对象有机会处理请求，从而将请求的发送者与其接收者解耦。
- en: There could be some variations to the chain of responsibility design pattern.
    The original pattern is that whenever a request reaches an object that can process
    it, it doesn't go any further. However, in some cases, we might need to push the
    request further or even multiply it and broadcast to other receivers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链设计模式可能会有一些变化。原始模式是，每当一个请求到达一个可以处理它的对象时，它就不会再进一步。然而，在某些情况下，我们可能需要进一步推动请求，甚至将其乘以并广播给其他接收者。
- en: It is worth noting that the chain of responsibility is not data-specific at
    all, and it can be used in any scenario where the preceding characteristics emerge.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，责任链模式根本不是数据特定的，它可以在任何出现上述特性的场景中使用。
- en: An example class diagram
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: A common example used to illustrate the chain of responsibility design pattern
    is about event handling in applications, depending on whether they come from a
    mouse or a keyboard action. For our class diagram and code example, let's take
    a look at something else that we use every day—ATMs. How do they return the right
    amount in different note combinations? The answer is, of course, the chain of
    responsibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 常用来说明责任链设计模式的一个例子是关于应用程序中的事件处理，这取决于事件是来自鼠标还是键盘操作。对于我们的类图和代码示例，让我们看看我们每天都会用到的东西——ATM。它们如何以不同的纸币组合返回正确的金额？答案是，当然，责任链。
- en: We will present two diagrams here—one of the classes that allow us to achieve
    the chain of responsibility pattern and another that will show how those classes
    are used together to build our ATM.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将展示两个图——一个显示允许我们实现责任链模式的类，另一个将展示这些类如何一起使用来构建我们的ATM。
- en: 'First, let''s take a look at our classes separately:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们单独看一下我们的类：
- en: '![](img/17307c75-3a65-4533-83fa-1df092000a90.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17307c75-3a65-4533-83fa-1df092000a90.png)'
- en: In the preceding diagram, we have a base class (represented as a trait in Scala),
    which is then extended by the different concrete dispensers. Each dispenser has
    an optional instance of the same class, and in this way, we can build a chain.
    The `dispense` method is the same for all the dispensers, and then each of the
    dispensers has a different amount and a different next element in the chain.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个基类（在Scala中用特质表示），然后由不同的具体分配器扩展。每个分配器都有一个相同类的可选实例，这样我们就可以构建一个链。对于所有分配器，`dispense`方法都是相同的，然后每个分配器都有一个不同的金额和链中的不同下一个元素。
- en: 'Things will get much clearer as we present our ATM implementation. It can be
    seen in the following diagram:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展示我们的ATM实现时，一切将会变得更加清晰。这可以在以下图中看到：
- en: '![](img/12206287-a157-4b02-80da-3c36a10fa97c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12206287-a157-4b02-80da-3c36a10fa97c.png)'
- en: The preceding diagram shows the actual chain that we have in our ATM. Whenever
    someone requests money, the ATM will go to the dispenser for 50 pound notes, then
    to a lower dispenser and so on until the request of the user is satisfied. In
    the following subsection, we will present our code step by step.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了我们在ATM中实际拥有的链。每当有人请求现金时，ATM将前往50英镑纸币的分配器，然后是下一个分配器，依此类推，直到满足用户的请求。在接下来的小节中，我们将逐步展示我们的代码。
- en: A code example
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s look at the code for the preceding example, one step at a time. First
    of all, we have defined a `Money` class that represents the amount the user requests.
    The definition looks like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看前一个示例的代码。首先，我们定义了一个`Money`类，它代表了用户请求的金额。其定义如下：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s have a look at the `Dispenser` trait. It is the one that the concrete
    dispensers extend, as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Dispenser`特质。这是具体分配器扩展的特质，如下所示：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we mentioned in the preceding section, the dispense method is the same for
    everyone who extends our `Dispenser`, but the amount and the next element of the
    chain are to be defined by whoever extends it. The `dispense` method tries to
    return as many notes as possible of the given nomination; after this, it passes
    the responsibility to the next dispenser if there is still money to be given.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于扩展我们的`Dispenser`的每个人，分配方法都是相同的，但金额和链中的下一个元素需要由扩展它的人定义。`dispense`方法尝试返回尽可能多的指定面额的纸币；在此之后，如果还有钱要分配，它将责任传递给下一个分配器。
- en: 'The following code block shows our implementations of the different dispensers—for
    notes of `50`, `20`, `10`, and `5` pounds:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了我们对不同分配器的实现——包括`50`、`20`、`10`和`5`英镑纸币的分配器：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What we have shown so far is the essence of the chain of responsibility design
    pattern. Using the defined classes, we will now build a chain that can be used
    easily.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所展示的是责任链设计模式的精髓。使用定义的类，我们现在将构建一个易于使用的链。
- en: 'Here is the code for our `ATM` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们`ATM`类的代码：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, we built the dispenser chain that will be used by our
    `ATM` class. The order here is really important for the correct functioning of
    the system. We have also done some sanity checks. The use of our `ATM` class is
    then pretty straightforward with the following application:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了将由我们的`ATM`类使用的分配器链。这里的顺序对于系统的正确运行至关重要。我们还进行了一些合理性检查。然后，使用我们的`ATM`类就相当直接，如下所示的应用程序：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is an interactive application that waits for the user input and then uses
    the ATM. Let''s see how an example run of this will look in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个交互式应用程序，它等待用户输入，然后使用ATM。让我们看看以下截图中的这个示例运行将如何显示：
- en: '![](img/f5e575c8-c2b6-4caa-adec-859ffd0f7c2e.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5e575c8-c2b6-4caa-adec-859ffd0f7c2e.png)'
- en: As you can see in the code, our ATM doesn't have the extra functionality that
    other ATMs have—check note availability. This, however, is a functionality that
    can be extended further.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所见，我们的ATM没有其他ATM具有的额外功能——检查钞票可用性。然而，这是一个可以进一步扩展的功能。
- en: The chain of responsibility design pattern the Scala way
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala风格的链式责任设计模式
- en: Looking more carefully at the code and the class diagram, you can see some similarities
    to the decorator design pattern. This means that here, we can use the same stackable
    traits, which use the `abstract override` construct. We've already seen an example
    of this and it will not provide you with any new information. However, there is
    another functionality of the Scala programming language that we can use in order
    to achieve the chain of responsibility design pattern—partial functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看代码和类图，您可以看到一些与装饰器设计模式的相似之处。这意味着在这里，我们可以使用相同的可堆叠特质，它们使用`abstract override`构造。我们已经看到了一个例子，这不会为您提供任何新的信息。然而，Scala编程语言中还有另一个功能，我们可以用来实现链式责任设计模式——部分函数。
- en: 'Using partial functions, we don''t need to define the specific dispenser classes
    separately. Our dispenser will change to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部分函数，我们不需要分别定义特定的分发器类。我们的分发器将变为以下：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, there are different ways to do this—we can have an abstract trait
    and then implement the partial function (something similar to the original example)
    and not specify the `dispenserAmount` parameter, or we can have one trait with
    different implementations of this function instead of passing the `dispenserAmount`
    parameter, and so on. Doing this, however, allows us to later simulate the existence
    of an infinite number of different notes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有不同的方式来完成这件事——我们可以有一个抽象特质，然后实现部分函数（类似于原始示例），并且不指定`dispenserAmount`参数，或者我们可以有一个具有该函数不同实现的特质，而不是传递`dispenserAmount`参数，等等。然而，这样做允许我们后来模拟无限数量的不同钞票的存在。
- en: 'After we have our new dispenser, which returns a `PartialFunction` instead
    of nothing (`Unit`), we can define our `ATM` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了新的分发器，它返回一个`PartialFunction`而不是什么也没有（`Unit`）之后，我们可以定义我们的`ATM`类：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The interesting part here is the `dispenser` field and the way we use it. In
    the preceding code, we chained multiple partial functions using the `andThen`
    method and finally, we used the result of them as a method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是`dispenser`字段以及我们使用它的方式。在前面的代码中，我们使用`andThen`方法链式连接多个部分函数，最后，我们将它们的输出作为方法使用。
- en: Depending on what chains the developer wants to create, they can use the `orElse`
    or `andThen` methods of the partial functions. The former is useful for single
    handlers and the latter for chaining.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 根据开发者想要创建的链，他们可以使用部分函数的`orElse`或`andThen`方法。前者对单个处理器很有用，后者用于链式操作。
- en: Running the original example, but with substituted ATM implementations, will
    yield absolutely identical results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行原始示例，但用ATM实现替换，将产生绝对相同的结果。
- en: As you saw in this subsection, using partial functions can make our application
    more flexible and will require us to write less code. However, it might be more
    demanding in terms of understanding advanced Scala language concepts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本小节中看到的那样，使用部分函数可以使我们的应用程序更加灵活，并且将需要我们编写更少的代码。然而，在理解高级Scala语言概念方面可能会更加要求严格。
- en: Just for completeness, it is worth mentioning that we can also implement the
    chain of responsibility design pattern using the Akka library. We will be looking
    into this library in the later chapters of this book, and you will hopefully be
    able to see how this design pattern can be moved to reactive programming with
    Scala.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，值得一提的是，我们还可以使用Akka库实现责任链设计模式。我们将在本书的后续章节中探讨这个库，你可能会看到这个设计模式如何用Scala转换为响应式编程。
- en: What it is good for
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点是什么
- en: The chain of responsibility design pattern should be used when we want to decouple
    a sender of a request from the receivers and have these receivers separated into
    their own entities. It is good for creating pipelines and handling events.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要解耦请求的发送者与接收者，并将这些接收者分离成它们自己的实体时，应该使用链式责任设计模式。这对于创建管道和处理事件很有用。
- en: What it is not so good for
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不擅长的地方
- en: As a negative and a possible pitfall of the chain of responsibility design pattern,
    we will talk about the implementation involving partial functions. This is because
    it might not always be able to achieve what the developers want, and this could
    further complicate code and affect readability.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为责任链设计模式的负面和可能的陷阱，我们将讨论涉及部分函数的实现。这是因为它可能无法总是实现开发者的期望，这可能会进一步复杂化代码并影响可读性。
- en: The interpreter design pattern
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器设计模式
- en: In modern programming, we sometimes have to deal with problems from well-understood
    and well-defined domains. In some cases, it makes sense to represent the domain
    with a language, which could then make it easy to solve problems using an interpreter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代编程中，我们有时必须处理来自理解良好和定义明确的领域的难题。在某些情况下，用语言表示领域是有意义的，这可以使得使用解释器解决问题变得容易。
- en: The interpreter design pattern is useful for specifying how to evaluate sentences
    in a language by representing it using classes and building syntax trees to evaluate
    the language expressions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式通过使用类来表示语言并构建语法树以评估语言表达式，用于指定如何评估语言中的句子。
- en: The interpreter design pattern makes use of the composite design pattern as
    well. Some common uses of interpreters are for language parsing, protocols, and
    so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式利用了组合设计模式。解释器的常见用途包括语言解析、协议等。
- en: An example class diagram
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'Creating a language and grammar is a complicated task and before getting into
    it, developers should be confident that it is actually worth the effort. It requires
    a really good understanding of the domain that is being modeled and usually takes
    some time. In this section, we will present the class diagram concerning the interpreter
    part of a program that parses and evaluates an expression in *reverse Polish notation*.
    This is an important concept in computer science and it shows how computers actually
    work in performing different operations. The screenshot is shown as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建语言和语法是一项复杂的工作，在深入之前，开发者应该确信这确实值得付出努力。它需要对正在建模的领域有很好的理解，通常需要一些时间。在本节中，我们将展示一个程序的解释器部分的类图，该程序以逆波兰表示法解析和评估表达式。这是计算机科学中的一个重要概念，它展示了计算机在执行不同操作时是如何实际工作的。截图如下所示：
- en: '![](img/d8c5b38f-8863-4513-bb8c-e39f34a7fe82.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8c5b38f-8863-4513-bb8c-e39f34a7fe82.png)'
- en: The main concept of our language is the `Expression`. Everything is an expression,
    which is being interpreted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们语言的主要概念是`表达式`。一切都是一个表达式，正在被解释。
- en: 'We can distinguish two main types of expressions in our diagram:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图中，我们可以区分两种主要的表达式类型：
- en: '**Terminal expression**: This is the `Number` class. It is a terminal in the
    sense that when building the syntax tree of an expression, it has no other children
    (leaf node).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端表达式**：这是`Number`类。在构建表达式语法树时，它没有其他子节点（叶节点）。'
- en: '**Nonterminal expression**: These are the `Add`, `Subtract`, and `Multiply`
    classes. They have children expressions and this is how the entire syntax tree
    is built.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非终端表达式**：这些是`Add`、`Subtract`和`Multiply`类。它们有子表达式，这就是整个语法树是如何构建的。'
- en: The preceding screenshot shows only those expressions into which the interpreter
    will be converting our language. In the following subsection, we will additionally
    show all the other classes that can make such an application work.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图只显示了解释器将转换成我们语言的那些表达式。在下一小节中，我们还将展示所有其他可以使此类应用程序工作的类。
- en: A code example
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Here, we will show the code of our interpreter application step by step. We
    currently have some limitations such as only supporting integers, not having a
    good error reporting mechanism, and only having three operations, but it is easy
    to add new ones. You could try and build on top of what we already have.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将逐步展示我们的解释器应用程序的代码。我们目前有一些限制，例如只支持整数，没有良好的错误报告机制，并且只有三种操作，但很容易添加新的操作。你可以尝试在我们已有的基础上进行构建。
- en: 'First of all, let''s see the base `Expression` trait:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看基本的`Expression`特质：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It is really simple and contains one method that other expressions will have
    to implement. The terminal expression, which is our `Number` class, looks like
    the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单，包含一个其他表达式必须实现的方法。终端表达式，即我们的`Number`类，如下所示：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It doesn''t do anything special—just returns the number it carries when `interpret`
    is called. The nonterminal expressions have a bit more code, but they are all
    really simple:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有做任何特别的事情——只是在`interpret`被调用时返回它携带的数字。非终端表达式有更多的代码，但它们都非常简单：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, this is everything that we showed in our diagram, and it is the essential
    part of the interpreter design pattern. Some people might notice that everywhere
    in the constructors, we have the right-hand expression first and then the left-hand
    one. This was done on purpose as it would make the code much cleaner later, when
    we actually implement our parser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是我们展示在图中的所有内容，它是解释器设计模式的基本部分。有些人可能会注意到，在所有构造函数中，我们首先有右边的表达式，然后是左边的表达式。这是故意为之，因为它会在我们实际实现解析器时使代码更加清晰。
- en: 'From now on, we will show how to parse and use the design pattern in real applications.
    First of all, we need to create a factory that is based on a token that decides
    which expression it should return:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将展示如何在实际应用程序中解析和使用设计模式。首先，我们需要创建一个基于标记的工厂，该标记决定它应该返回哪个表达式：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we applied some of the techniques and design patterns
    that we already went through—factory and by-name parameters. The latter are really
    important, as based on which case our code hit determines whether they will be
    evaluated or not.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们应用了一些我们已经讨论过的技术和设计模式——工厂模式和按名称传递参数。后者非常重要，因为根据我们的代码触发的哪个情况，它们将决定是否会被评估。
- en: 'We have a parser class that looks like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个看起来像下面的解析器类：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we relied on a `StringTokenizer` and a stack. We used the factory method
    we defined before, and this is where the interesting part is—`pop` will be called
    on the stack only if we fall in an operator case. It will be called in the order
    in which we use the parameters inside the factory.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依赖于`StringTokenizer`和栈。我们使用了之前定义的工厂方法，这是有趣的部分——只有在我们遇到运算符情况时，才会调用`pop`。它将按照我们在工厂内部使用参数的顺序被调用。
- en: Popping elements from the stack
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从栈中弹出元素
- en: As you can see from the preceding code, in the factory, we used by-name parameters
    and everywhere we first access the right parameter and then the left parameter.
    This, and the fact that our expression classes have the right parameter specified
    first, makes our code cleaner and makes sure that everything works as expected.
    The reason this is done is because of the fact that we rely on a stack and it
    reverses the operator order.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，在工厂中，我们使用了按名称传递的参数，并且在我们访问参数的地方，我们首先访问右边的参数，然后是左边的参数。这，以及我们的表达式类首先指定右参数的事实，使我们的代码更加清晰，并确保一切按预期工作。这样做的原因是因为我们依赖于栈，并且它反转了运算符的顺序。
- en: 'After we process an expression, if everything goes well, we should have only
    one element in the stack, which will have the complete tree. Then, we will have
    an interpreter class that just gets an expression and calls the `interpret` method
    on it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理完一个表达式后，如果一切顺利，我们应该只在栈中有一个元素，它将包含完整的树。然后，我们将有一个只获取表达式并在其上调用`interpret`方法的解释器类：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s see an application that uses our language and the interpreter
    design pattern:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一个使用我们的语言和解释器设计模式的应用程序：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this application will be the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的输出将是以下内容：
- en: '![](img/9480d85e-1b16-4b31-80ed-abe47cbdf2eb.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9480d85e-1b16-4b31-80ed-abe47cbdf2eb.png)'
- en: As you can see, our code correctly evaluates the expressions. There are, of
    course, some improvements that can be made and they are mainly related to error
    handling and parsing, but this is out of the scope of this subsection. In this
    subsection, we saw how to use the interpreter design pattern.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的代码正确地评估了表达式。当然，有一些改进可以做出，它们主要与错误处理和解析有关，但这超出了本小节的范围。在本小节中，我们看到了如何使用解释器设计模式。
- en: What it is good for
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的优点
- en: The interpreter design pattern is good for applications that deal with well-defined
    and well-understood domains. They could greatly simplify the application code.
    You should not confuse the interpreter design pattern with parsing, even though
    we needed parsing in order to build our expressions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器设计模式适用于处理定义明确且理解良好的领域的应用程序。它可以极大地简化应用程序代码。你不应该将解释器设计模式与解析混淆，尽管我们为了构建表达式需要解析。
- en: What it is not so good for
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的缺点
- en: Creating languages and grammar is not an easy job. Developers should thoroughly
    evaluate the problems they are trying to solve before deciding to use this design
    pattern.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建语言和语法不是一项容易的工作。开发者应该在决定使用这种设计模式之前，彻底评估他们试图解决的问题。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the first group of behavioral design patterns.
    We looked at the value object, null object, strategy, command, the chain of responsibility,
    and interpreter. As in the previous chapters, we saw that some of these patterns
    have better alternatives that use the more powerful and flexible features of Scala.
    In many cases, there are multiple different ways to implement the same design
    pattern. We've tried to show some good ones and we've also tried to avoid repetition
    in the cases where more design patterns can use the same features of the Scala
    programming language. By now, you should have enough knowledge in order to actually
    use an alternative implementation by yourself when told which approach to use,
    based on what we've already shown.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了第一组行为设计模式。我们研究了值对象、空对象、策略、命令、责任链和解释器。正如前几章所看到的，其中一些模式有更好的替代方案，它们使用了Scala更强大和灵活的特性。在许多情况下，实现相同的设计模式有多种不同的方法。我们试图展示一些好的方法，并且在更多设计模式可以使用Scala编程语言的相同功能的情况下，我们也试图避免重复。到目前为止，你应该已经拥有了足够的知识，以便在被告知使用哪种方法时，能够根据我们已经展示的内容自行使用替代实现。
- en: We've given some pointers that should help in figuring out what to look for
    when writing software and identifying potential places to apply behavioral design
    patterns.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一些指导，这些指导应该有助于在编写软件时确定要寻找的内容，以及识别潜在的应用行为设计模式的位置。
- en: In the following chapter, we will look at the next group of behavioral design
    patterns, which also puts an end to the *Gang of Four* design patterns we've been
    focusing on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨下一组行为设计模式，这也标志着我们一直关注的前四个设计模式的结束。
