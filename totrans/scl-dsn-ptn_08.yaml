- en: Behavioral Design Patterns – Part One
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our journey through the Scala design patterns has arrived at the group of **behavioral
    design patterns**. There are more members in this group than the others we''ve
    already been through, so we will split it into two separate parts. In this chapter,
    we will focus on the following behavioral design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Value object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain of responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter and the next one will give some clarity about what behavioral design
    patterns are, where they are useful, and how to implement them in Scala. We will
    be following a path similar to the previous chapters where we presented the patterns,
    showed a class diagram and a code example, and finally, gave a few hints about
    what to watch out for and where certain patterns are preferred to be used. Hopefully,
    you will get a feel for them and be able to confidently identify situations where
    they are applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Defining behavioral design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral design patterns, as the name suggests, are to do with behavior. Their
    purpose is to identify and implement common communication patterns between objects
    in an application. They define object interaction in such a way that the communication
    between objects is easy and coupling is still kept at a low level.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral design patterns describe how objects and classes interact with each
    other using messages. Contrary to creational and structural design patterns, the
    behavioral design patterns describe a **flow** or a **process**. This means that
    a developer should be really familiar with the actual process they are trying
    to implement. As with every other type of design pattern, behavioral design patterns
    exist in order to increase the testability, maintainability, and flexibility of
    the produced code.
  prefs: []
  type: TYPE_NORMAL
- en: The value object design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, there are different ways of comparing data. We can compare object
    identities or their values. These are useful in different scenarios and here,
    we will see what value objects are and when they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects are small and simple immutable objects. Their equality is based
    not on identity, but on value equality.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects are used to represent numbers, money, dates, and so on. They should
    be small and immutable; otherwise, changing values could cause bugs and unexpected
    behavior. They are quite useful in multithreaded applications due to their immutability.
    They are also commonly used as data transfer objects in enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In languages such as Java, there is no direct support for value objects. What
    developers end up doing is to declare the fields as final and implement the `hashCode`
    and `equals` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability, however, is a concept that is pretty much enforced in Scala.
    We already saw the **algebraic data types** (**ADTs**) earlier—they also fall
    in the value object category. Case classes and tuples are also immutable and they
    are used to achieve the value object design pattern. The following class diagram
    shows an example of the value object design pattern in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7245b962-065f-48a4-a276-328f2d2ca489.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram really doesn't do anything special. It is a representation of a
    case class called **Date**. This is everything we need to do in order to achieve
    immutability and be able to implement the value object design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our code example, we will use our `Date` class. Dates are quite commonly
    used in software products. Of course, there are libraries that provide complete
    functionality around date manipulations, but this should be good enough for an
    example. First of all, here is the `Date` class representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is everything we need in order to get a value object. Scala does everything
    for us in the background by creating default implementations for the `hashCode`,
    `equals`, and `toString` methods. Case classes give us extra power, but this is
    out of this section's scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use our `Date` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used our object as values. We should note that here, we
    have absolutely no validation of the parameters; however, it is something easy
    to add, but not relevant for the current example. If we run our code now, we will
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94f19c8a-5bd4-443e-b3d3-d092f2bba683.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just to prove that case classes allow us to implement the value object design
    pattern easily and normal classes don''t, let''s try and change our `Date` class
    to a normal one and then use it in the same example. Our class will change to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will take the same example; however this time, we will use the `BadDate`,
    and since it''s not a case class, we will create it with the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71d761db-03fc-4bc4-b29b-534a6c6891d9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding output, normal classes do not work in the
    same way as case classes and some extra work needs to be performed in order to
    implement the value object design pattern with them. The reason for the preceding
    result is that classes, by default, are compared with each other by their reference
    identities and not by the values they carry. In order to change this, `hashCode`
    and `equals` should be implemented. Scala also allows us to override the `==`
    operator for the class.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The value object design pattern can also be achieved with predefined tuple classes
    in Scala. In this case, we don't even need to create our class and we can write
    something like `(3, "March", 2016)`. This would automatically have the same characteristics
    as value objects. There are implementations of tuples of up to 22 elements, but
    using them in real applications is not recommended, as readability and quality
    can degrade dramatically. Moreover, two *n* element tuples can be considered equal,
    even if semantically they are different types of objects in our application. Last
    but not least, accessing elements using case classes is much easier and nicer
    to read than writing something like `tuple._3`.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned, the value object design pattern is good for multithreading
    and creating **data transfer objects** (**DTOs**). It is something extremely easy
    to achieve in Scala, and many people use it on a daily basis without even realizing
    that it actually is a design pattern. Value objects are another example of the
    fact that Scala is a really powerful language.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than using tuples to represent value objects in Scala, there are no other
    major drawbacks to using this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The null object design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most object-oriented languages have a way of specifying the nonexistence of
    some value. In Scala and Java, for example, this could be the `null` value that
    can be assigned to an object. Calling any method on an object that is `null` would
    result in a `NullPointerException`, hence developers should be careful and check
    whether there is such a possibility. These checks, however, could make the source
    code hard to follow and extend as developers should always be aware. This is where
    the null object design pattern is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the null object design pattern is to define an actual object
    that represents the `null` value and has neutral behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Using null objects removes the need to check whether something is set to `null`
    or not. The code becomes much more readable and easy to understand and makes bug
    occurrence harder.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram, let''s imagine that we have a system that has to poll
    a queue for messages. Of course, this queue might not always have anything to
    offer, so it would return nulls. Instead of checking for `null`, we could simply
    return special null objects that will have empty behavior. Let''s show these message
    classes in a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05ead116-8979-4772-b363-223aecce4e84.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the classes from the preceding diagram, whenever there is no number to
    print, we will return a **NullMessage** object with empty behavior. In some cases,
    for optimization purposes, people could have the **NullMessage** as a singleton
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we actually look at our code, we will note a few observations about the
    preceding diagram. It represents a classical case using the null object design
    pattern. However, nowadays, it is not really used this way in either Java or Scala.
    For example, Java now supports `Optional`, which is used instead (assuming people
    use new versions of the language). In Scala, things are similar—we can and do
    use `Option[Message]` instead of null objects. Additionally, we gain all the other
    nice features of `Option` such as the ability to use them in pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as mentioned previously, our code is not really going to use the hierarchy
    of the preceding class diagram. It just doesn''t need it and it will be much simpler.
    Instead, we will be using `Option[Message]`. First of all, let''s see the `Message`
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned that we will be polling a queue for messages and then displaying
    them. We have simulated a queue that is being randomly populated using a different
    thread in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows what will be run in a different thread. The queue will
    be populated with random values between 0 (inclusive) and 10 (exclusive) at random
    intervals. Then, `getMessage` can be called and whatever is in the queue can be
    read. Since it is possible for the queue to be empty, we return an `Option` of
    `Message` to the caller. It is probably worth mentioning that in Scala, `Option(null)`
    returns `None`. This is exactly what we took advantage of in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how everything comes together in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program creates a generator and makes it run on a different thread.
    Then, it randomly requests items from the generator and prints them if something
    is actually returned. Due to the use of random generators, the program will print
    different things every time. Here is an example run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7704895-c3d7-4eaa-b5b8-1c68814f69b8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from our example and the preceding output, we never actually
    check for nulls and our code just doesn't do anything when the queue returns `null`.
    This works nicely in large projects and it makes the source code look really elegant
    and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In real-life applications, code as in the previous example might not be a good
    idea. First of all, instead of calling `sleep` on a thread, we can use timers.
    Secondly, if we want to create producer–consumer applications, we can use libraries
    such as **Akka** ([https://akka.io/](https://akka.io/)), which allow us to do
    reactive programming and have really optimal code.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already saw, the null object design pattern is already incorporated in
    Scala (and newer versions of Java) through the use of `Option` (`Optional` in
    Java). This makes it really easy to use and shows the power of the language once
    more. Using null objects makes our code look much more readable and removes the
    need to take extra care when a value is `null`. It also reduces the risk of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no drawbacks of this design pattern that we can think of. One thing
    probably worth mentioning is this—use it only when it is actually needed, not
    everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite a common thing in enterprise applications to have different implementations
    of specific algorithms and choosing one to use while the application is running.
    Some examples might include different sorting algorithms that would have a different
    performance for different sizes or types of data, different parsers for various
    possible representations of data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern enables us to define a family of algorithms and
    select a specific one at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern helps with encapsulation as each algorithm can be
    separately defined and then injected into the classes that use it. The different
    implementations are also interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram, let''s imagine that we are writing an application that
    needs to load some data from a file and then use this data somehow. Of course,
    the data could be represented in different formats (CSV or JSON, in this case),
    and depending on the file type, we will be using a different parsing strategy.
    The class diagram that represents our parser is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95f2cea4-955a-49ff-bb2e-91625b566eea.png)'
  prefs: []
  type: TYPE_IMG
- en: We basically have an interface that the different classes implement, and then
    depending on which one is needed, **PersonApplication** gets injected with the
    right one.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding class diagram looks really similar to the one we saw earlier in
    the book for the bridge design pattern. Even though this is the case, both patterns
    have different purposes—the builder is concerned with structure, while here it's
    all about behavior. Also, the strategy design pattern looks somewhat more coupled.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we showed the class diagram of the example we will
    show here. As you can see, we used a model class called `Person`. It is just a
    case class with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there will be different formats available in our application, we have
    defined a common interface that all parsers will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the implementations. First is the `CSVParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It relies on a library called `scala-csv` (details in the `pom.xml/build.sbt`
    file), which reads each line as a list of strings. Then, they are mapped to the
    `Person` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the code for the `JsonParser` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It reads a JSON file and parses it using the `json4s` library. As you can see,
    even though both implementations do the same thing, they are quite different.
    We cannot apply the CSV one when we have a JSON file and vice versa. The files
    also look really different. Here is the CSV file we are using in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Both the preceding datasets contain exactly the same data, but the formats make
    them look completely different and they require different approaches in parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one extra thing we''ve done in our example. We''ve used a factory
    design pattern in order to pick the right implementation at runtime, depending
    on the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding factory is just an example. It only checks the file extension
    and of course, could be made much more robust. Using this factory, we can pick
    the right implementation of the parser for the application class to use, whose
    code is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The application class looks the same no matter what the implementation is. Different
    implementations could be plugged in, and as long as there are no errors, everything
    should run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can use our strategy design pattern in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s pretty simple. The output of the preceding application
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73e1d7b4-dbec-40ec-8400-d8a67d54e516.png)'
  prefs: []
  type: TYPE_IMG
- en: In both cases, our application coped just fine with the different formats. Adding
    new implementations for new formats is also straightforward—just implement the
    `Parser` interface and make sure the factory knows about them.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we showed the strategy design pattern using classes
    and traits. This is what it would look in a purely object-oriented language. However,
    Scala is also functional and provides more ways to achieve it by writing far less
    code. In this subsection, we will show the strategy design pattern by taking advantage
    of the fact that in Scala, functions are first-class objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that will change is that we will not need to have an interface
    and classes that implement it. Instead, our `Application` class will look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The most important thing to note here is that the strategy parameter is a function
    instead of a normal object. This instantly allows us to pass any function we want
    there without the need to implement specific classes, as long as it satisfies
    these requirements—one `String` parameter and returns a `List[T]`. If we have
    multiple methods in our strategy, we can use a case class or a tuple to group
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the current example, we''ve decided to have the function implementations
    somewhere so that they are grouped with the factory, which will choose which one
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has the same factory as before, but this time it returns
    methods, which can then be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is how to use the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding example will be absolutely the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy design pattern helps us when we want to be able to change implementations
    at runtime. Also, as we can see, the implementations live separately from the
    code that uses them, so it's quite easy to add new ones without the risk of introducing
    bugs in other parts of our system.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though, in the long run, the Scala way of implementing the strategy pattern
    that uses functions could save a lot on code, sometimes it affects readability
    and maintainability. The fact that the methods could be stored in an object, class,
    case class, trait, and so on, indicates the fact that different people could prefer
    different approaches, and this is not always good while working in a big team.
    Apart from that, the strategy design pattern doesn't have any major flaws as long
    as it's used in the right way and in the right places.
  prefs: []
  type: TYPE_NORMAL
- en: The command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in our applications, we might need to pass information to other objects
    about how to perform some action. Usually, this action will be executed at a later
    time based on some kind of event. The object that will execute our commands is
    called **invoker**, and it might not even be aware of the command it actually
    runs. It just knows about the interface, which means that it knows how to trigger
    the command. The command design pattern helps us to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the command design pattern is to encapsulate the information
    needed to perform an action at a later stage and pass this information to the
    object that will be running the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the command information will contain the object that owns the method,
    the method name, and the parameters that should be passed when invoking the method.
    The command design pattern is useful for many things, some of which include supporting
    undo actions, implementing parallel processing, or simply optimizing code by deferring,
    and possibly avoiding code execution.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about the command design pattern, there are usually a couple of
    objects, each of which has its specific role:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: We can think of this as the interface and its implementations
    that are being called by the invoker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver**: This is the object that actually knows how commands are executed.
    Think of this as an object that is being passed to the command and then used in
    the interface method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoker**: It invokes the commands by calling their interface method. As
    we mentioned earlier, it might not even know what commands are being invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: It more or less guides which commands are executed when by using
    the invoker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know the most important objects and their roles in the command
    design pattern, we can take a look at an example. For the class diagram, let''s
    imagine that we have a robot, which can cook. We connect to it through a controller
    and send commands to our robot. Things are pretty simplified, but should be good
    enough to understand how this pattern works. Here is the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4631968-eec5-4de7-afa4-4e05bb6679da.png)'
  prefs: []
  type: TYPE_IMG
- en: We can quickly identify that here, the **RobotCommand** interface and its implementations
    are the command. The receiver is the **Robot** class as it knows how to run all
    the commands issued to it. The **RobotController** class is the invoker. It doesn't
    know what types of commands it executes, just runs them whenever needed. We haven't
    shown our client class in the preceding diagram, as it is simply represented by
    the example application that runs the code, which implements the previously shown
    class diagram.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily see that if the code representing the preceding diagram is changed,
    it could easily add multithreaded support and support for undo.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to see the interesting part representing the previous diagram—the
    code. As always, we will be going through the individual classes and giving brief
    explanations where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first piece of code that we will look at is the `Robot` class. We already
    mentioned that it acts as the receiver and knows how to execute some specific
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve kept the code simple and the methods just print different things to
    the command line. Next is the robot command with its different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There is absolutely nothing special about the preceding code. It is a simple
    trait, which is implemented by different classes. It relies on the `Robot` receiver,
    which knows how to execute methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RobotController` class is our invoker and issues commands given to it
    according to the `RobotCommand` interface. It doesn''t need to know anything about
    the commands that it issues, as long as the interface is followed. We''ve decided
    to add some history of the commands that can be used for rollbacks later. The
    code for the invoker is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the example that uses all of the preceding classes.
    As we already mentioned earlier, it would actually act as a client. Here is the
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this application will be the same as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59a4ffe3-cc05-4d67-ba2e-ae2ce4a82a40.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our invoker successfully saves the history of the events. This
    means that as long as our commands and then the receiver (`Robot`) have the undo
    methods, we can implement these and have extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The command design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command design pattern is another example of a design pattern that can be
    implemented differently in Scala compared to other languages. We will show another
    implementation of the preceding example. This time, we will use the **by-name
    parameters** feature of the language. It is replaceable with passing functions
    as parameters (something we've already seen before for the strategy design pattern),
    but more verbose. Let's see what it will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not much of the application actually has to change. We''ve only refactored
    and renamed the `RobotController` and `RobotExample` classes. Here is the former
    class, now called `RobotByNameController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we don''t pass an actual command object but just a by-name
    parameter to the `issueCommand` method. What this method does is defer a call
    to whatever retrieves the value passed until it is actually needed. In order to
    make the preceding code work, we had to refactor our example code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The by-name parameters method is useful when we don't want to write extra code
    for the command interface and its implementations. We could just pass any function
    call (in this case, directly from the receiver) and it will be held off until
    the data is needed, or not called at all. The output will be the same as before,
    but with the exception that now we have functions, and the history printout will
    look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command design pattern is useful for cases where we want to delay, log,
    or sequence method calls for one reason or another. Another advantage is that
    it decouples the invoker from the object that actually performs the specific operations.
    This allows us to have modifications and to add new functionality pretty easily.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the by-name parameter method looks nice and could make our writing
    shorter, it might not be a great idea here. A big disadvantage compared with our
    previous example is that we could actually plug any `Unit` data there, which could
    possibly not be relevant to what the receivers are supposed to do. In other cases,
    though, the by-name parameter technique is quite useful and could dramatically
    improve our application performance.
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, with the growth of data sizes and the hype around big data, stream
    processing is something that many applications will have to be able to do. Stream
    processing is characterized by an endless stream of data, which is passed from
    one object to another while each of them could be doing some processing and then
    passing it on to the next one. In other cases, data could be moved on in the chain
    until it arrives at an object which knows how to process a certain command.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding behavior is really suitable for the chain of responsibility design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the chain of responsibility design pattern is to decouple the
    sender of a request from its receiver by giving multiple objects the chance to
    handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: There could be some variations to the chain of responsibility design pattern.
    The original pattern is that whenever a request reaches an object that can process
    it, it doesn't go any further. However, in some cases, we might need to push the
    request further or even multiply it and broadcast to other receivers.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the chain of responsibility is not data-specific at
    all, and it can be used in any scenario where the preceding characteristics emerge.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common example used to illustrate the chain of responsibility design pattern
    is about event handling in applications, depending on whether they come from a
    mouse or a keyboard action. For our class diagram and code example, let's take
    a look at something else that we use every day—ATMs. How do they return the right
    amount in different note combinations? The answer is, of course, the chain of
    responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: We will present two diagrams here—one of the classes that allow us to achieve
    the chain of responsibility pattern and another that will show how those classes
    are used together to build our ATM.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at our classes separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17307c75-3a65-4533-83fa-1df092000a90.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have a base class (represented as a trait in Scala),
    which is then extended by the different concrete dispensers. Each dispenser has
    an optional instance of the same class, and in this way, we can build a chain.
    The `dispense` method is the same for all the dispensers, and then each of the
    dispensers has a different amount and a different next element in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things will get much clearer as we present our ATM implementation. It can be
    seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12206287-a157-4b02-80da-3c36a10fa97c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the actual chain that we have in our ATM. Whenever
    someone requests money, the ATM will go to the dispenser for 50 pound notes, then
    to a lower dispenser and so on until the request of the user is satisfied. In
    the following subsection, we will present our code step by step.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the code for the preceding example, one step at a time. First
    of all, we have defined a `Money` class that represents the amount the user requests.
    The definition looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the `Dispenser` trait. It is the one that the concrete
    dispensers extend, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the preceding section, the dispense method is the same for
    everyone who extends our `Dispenser`, but the amount and the next element of the
    chain are to be defined by whoever extends it. The `dispense` method tries to
    return as many notes as possible of the given nomination; after this, it passes
    the responsibility to the next dispenser if there is still money to be given.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows our implementations of the different dispensers—for
    notes of `50`, `20`, `10`, and `5` pounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: What we have shown so far is the essence of the chain of responsibility design
    pattern. Using the defined classes, we will now build a chain that can be used
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for our `ATM` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we built the dispenser chain that will be used by our
    `ATM` class. The order here is really important for the correct functioning of
    the system. We have also done some sanity checks. The use of our `ATM` class is
    then pretty straightforward with the following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interactive application that waits for the user input and then uses
    the ATM. Let''s see how an example run of this will look in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5e575c8-c2b6-4caa-adec-859ffd0f7c2e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the code, our ATM doesn't have the extra functionality that
    other ATMs have—check note availability. This, however, is a functionality that
    can be extended further.
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking more carefully at the code and the class diagram, you can see some similarities
    to the decorator design pattern. This means that here, we can use the same stackable
    traits, which use the `abstract override` construct. We've already seen an example
    of this and it will not provide you with any new information. However, there is
    another functionality of the Scala programming language that we can use in order
    to achieve the chain of responsibility design pattern—partial functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using partial functions, we don''t need to define the specific dispenser classes
    separately. Our dispenser will change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there are different ways to do this—we can have an abstract trait
    and then implement the partial function (something similar to the original example)
    and not specify the `dispenserAmount` parameter, or we can have one trait with
    different implementations of this function instead of passing the `dispenserAmount`
    parameter, and so on. Doing this, however, allows us to later simulate the existence
    of an infinite number of different notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have our new dispenser, which returns a `PartialFunction` instead
    of nothing (`Unit`), we can define our `ATM` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part here is the `dispenser` field and the way we use it. In
    the preceding code, we chained multiple partial functions using the `andThen`
    method and finally, we used the result of them as a method.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what chains the developer wants to create, they can use the `orElse`
    or `andThen` methods of the partial functions. The former is useful for single
    handlers and the latter for chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Running the original example, but with substituted ATM implementations, will
    yield absolutely identical results.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in this subsection, using partial functions can make our application
    more flexible and will require us to write less code. However, it might be more
    demanding in terms of understanding advanced Scala language concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Just for completeness, it is worth mentioning that we can also implement the
    chain of responsibility design pattern using the Akka library. We will be looking
    into this library in the later chapters of this book, and you will hopefully be
    able to see how this design pattern can be moved to reactive programming with
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chain of responsibility design pattern should be used when we want to decouple
    a sender of a request from the receivers and have these receivers separated into
    their own entities. It is good for creating pipelines and handling events.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a negative and a possible pitfall of the chain of responsibility design pattern,
    we will talk about the implementation involving partial functions. This is because
    it might not always be able to achieve what the developers want, and this could
    further complicate code and affect readability.
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern programming, we sometimes have to deal with problems from well-understood
    and well-defined domains. In some cases, it makes sense to represent the domain
    with a language, which could then make it easy to solve problems using an interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter design pattern is useful for specifying how to evaluate sentences
    in a language by representing it using classes and building syntax trees to evaluate
    the language expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter design pattern makes use of the composite design pattern as
    well. Some common uses of interpreters are for language parsing, protocols, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a language and grammar is a complicated task and before getting into
    it, developers should be confident that it is actually worth the effort. It requires
    a really good understanding of the domain that is being modeled and usually takes
    some time. In this section, we will present the class diagram concerning the interpreter
    part of a program that parses and evaluates an expression in *reverse Polish notation*.
    This is an important concept in computer science and it shows how computers actually
    work in performing different operations. The screenshot is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8c5b38f-8863-4513-bb8c-e39f34a7fe82.png)'
  prefs: []
  type: TYPE_IMG
- en: The main concept of our language is the `Expression`. Everything is an expression,
    which is being interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish two main types of expressions in our diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminal expression**: This is the `Number` class. It is a terminal in the
    sense that when building the syntax tree of an expression, it has no other children
    (leaf node).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonterminal expression**: These are the `Add`, `Subtract`, and `Multiply`
    classes. They have children expressions and this is how the entire syntax tree
    is built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding screenshot shows only those expressions into which the interpreter
    will be converting our language. In the following subsection, we will additionally
    show all the other classes that can make such an application work.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will show the code of our interpreter application step by step. We
    currently have some limitations such as only supporting integers, not having a
    good error reporting mechanism, and only having three operations, but it is easy
    to add new ones. You could try and build on top of what we already have.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see the base `Expression` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It is really simple and contains one method that other expressions will have
    to implement. The terminal expression, which is our `Number` class, looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn''t do anything special—just returns the number it carries when `interpret`
    is called. The nonterminal expressions have a bit more code, but they are all
    really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, this is everything that we showed in our diagram, and it is the essential
    part of the interpreter design pattern. Some people might notice that everywhere
    in the constructors, we have the right-hand expression first and then the left-hand
    one. This was done on purpose as it would make the code much cleaner later, when
    we actually implement our parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, we will show how to parse and use the design pattern in real applications.
    First of all, we need to create a factory that is based on a token that decides
    which expression it should return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we applied some of the techniques and design patterns
    that we already went through—factory and by-name parameters. The latter are really
    important, as based on which case our code hit determines whether they will be
    evaluated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a parser class that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we relied on a `StringTokenizer` and a stack. We used the factory method
    we defined before, and this is where the interesting part is—`pop` will be called
    on the stack only if we fall in an operator case. It will be called in the order
    in which we use the parameters inside the factory.
  prefs: []
  type: TYPE_NORMAL
- en: Popping elements from the stack
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding code, in the factory, we used by-name parameters
    and everywhere we first access the right parameter and then the left parameter.
    This, and the fact that our expression classes have the right parameter specified
    first, makes our code cleaner and makes sure that everything works as expected.
    The reason this is done is because of the fact that we rely on a stack and it
    reverses the operator order.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we process an expression, if everything goes well, we should have only
    one element in the stack, which will have the complete tree. Then, we will have
    an interpreter class that just gets an expression and calls the `interpret` method
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see an application that uses our language and the interpreter
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this application will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9480d85e-1b16-4b31-80ed-abe47cbdf2eb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our code correctly evaluates the expressions. There are, of
    course, some improvements that can be made and they are mainly related to error
    handling and parsing, but this is out of the scope of this subsection. In this
    subsection, we saw how to use the interpreter design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interpreter design pattern is good for applications that deal with well-defined
    and well-understood domains. They could greatly simplify the application code.
    You should not confuse the interpreter design pattern with parsing, even though
    we needed parsing in order to build our expressions.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating languages and grammar is not an easy job. Developers should thoroughly
    evaluate the problems they are trying to solve before deciding to use this design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the first group of behavioral design patterns.
    We looked at the value object, null object, strategy, command, the chain of responsibility,
    and interpreter. As in the previous chapters, we saw that some of these patterns
    have better alternatives that use the more powerful and flexible features of Scala.
    In many cases, there are multiple different ways to implement the same design
    pattern. We've tried to show some good ones and we've also tried to avoid repetition
    in the cases where more design patterns can use the same features of the Scala
    programming language. By now, you should have enough knowledge in order to actually
    use an alternative implementation by yourself when told which approach to use,
    based on what we've already shown.
  prefs: []
  type: TYPE_NORMAL
- en: We've given some pointers that should help in figuring out what to look for
    when writing software and identifying potential places to apply behavioral design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will look at the next group of behavioral design
    patterns, which also puts an end to the *Gang of Four* design patterns we've been
    focusing on.
  prefs: []
  type: TYPE_NORMAL
