- en: Concurrency and Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered several **Java Enhancement Proposals** (**JEPs**)
    that were incorporated into the Java 9 platform. These JEPs represented a wide
    range of tools and updates to APIs to make developing with Java easier, with greater
    optimization possibilities for our Java applications. We looked at the new HTTP
    client, changes to Javadoc and the Doclet API, the new JavaScript parser, JAR
    and JRE changes, the new Java-level JVM compiler interface, the new support for
    TIFF images, platform logging, XML catalog support, collections, and the new platform-specific
    desktop features. We also looked at enhancements to method handling and the deprecation
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will cover concurrency enhancements introduced with the Java
    9 platform. Our primary focus will be the support for reactive programming, a
    concurrency enhancement that is provided by the `Flow` class API. Reactive programming
    is a new concept for Java 9, so we will take an exploratory approach to the topic.
    We will also explore additional concurrency enhancements introduced in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `Flow` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional concurrency updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spin-wait hints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactive programming is when applications react to an asynchronous data stream
    as it occurs. The following image illustrates the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5cf435c-d95d-4d94-8eb4-26e21fb59fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Reactive programming is not a fancy software engineering term only used by academics.
    It is, in fact, a programming model that can result in much greater efficiencies
    as opposed to the more common method of having applications iterate over data
    that is in memory.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to reactive programming. First, let's consider that the data stream
    is provided by a publisher in an asynchronous manner to the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Data streams are a binary input/output of strings and primitive data types.
    The `DataInput` interface is used for an input stream and the `DataOutput` interface
    is used for output streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processors, or a chain of processors, can be used to transform the data stream
    without the publisher or subscriber being impacted. In the following example,
    the **Processors** work on the stream of data without **Publisher** or **Subscriber**
    involvement, or even awareness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aa45ee8-9b19-457a-90fd-5f3a333864af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to greater efficiency, reactive programming represents several
    additional benefits, which are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code base can be less verbose, making it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to maintain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to read
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream processing results in memory efficiencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a solution for a variety of programming applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less boiler-plate code needs to be written, so development time can be focused
    on programming core functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following types of programming require less time and code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level threading
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming standardization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are standards in many aspects of software development, and reactive programming
    has not escaped this. There is a **Reactive Streams** initiative to standardize
    asynchronous stream processing. The specific focus, in the context of Java, is
    with the JVM and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reactive Streams initiative aims at tackling the issue of governing how
    the data stream is exchanged between threads. As you will recall from the previous
    section, the idea of processors is predicated on there being no impact on the
    publisher or receiver. This no-impact mandate stipulates that the following are
    not required:'
  prefs: []
  type: TYPE_NORMAL
- en: Data buffering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data translation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic semantics of the standard define the regulation of data stream element
    transmission. This standard was specifically established for delivery with the
    Java 9 platform. Reactive Streams includes a library that will help developers
    convert from `org.reactivestreams` and `java.util.concurrent.Flow` namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to being successful with reactive programming and the Reactive Streams
    standardization is understanding the relevant terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Demand | Demand refers to the subscriber''s request for more elements as
    well as referring to the total number of elements requested that have not been
    fulfilled by the publisher yet. |'
  prefs: []
  type: TYPE_TB
- en: '| Demand | Demand also refers to the total number of elements requested that
    have not been fulfilled by the publisher yet. |'
  prefs: []
  type: TYPE_TB
- en: '| External synchronization | External access coordination for thread safety.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Non-obstructing | Methods are said to be non-obstructing if they rapidly
    execute without the requirement for heavy computations. Non-obstructing methods
    do not delay a subscriber''s thread execution. |'
  prefs: []
  type: TYPE_TB
- en: '| NOP | NOP execution is execution that can be called repeatedly without impact
    to the calling thread. |'
  prefs: []
  type: TYPE_TB
- en: '| Responsivity | This term refers to a component''s ability to respond. |'
  prefs: []
  type: TYPE_TB
- en: '| Return normally | Return normally refers to when there are no errors--the
    normal condition. The `onError` method is the only way permitted by the standard
    to inform the subscriber of a failure. |'
  prefs: []
  type: TYPE_TB
- en: '| Signal | One of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cancel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the standard on Maven Central ([https://search.maven.org](https://search.maven.org)).
    Here is the standard from Maven Central as of the publication date of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the Flow APIs in the Java 9 platform, as
    they correspond to the Reactive Streams specification.
  prefs: []
  type: TYPE_NORMAL
- en: The New Flow API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Flow` class is part of the `java.util.concurrent` package. It helps developers
    incorporate reactive programming in their applications. The class has one method,
    `defaultBufferSize()`, and four interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `defaultBufferSize()` is a static method that returns the default buffer
    size for publishing and subscribing buffering. This default value is `256` and
    it is returned as an `int`. Let's look at the four interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The Flow.Publisher interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Flow.Publisher` interface is a functional interface. A `Publisher` is
    a producer of data sent to subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This functional interface can serve as a lambda expression assignment target.
    It only takes one argument--the subscribed item type `<T>`. It has one method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flow.Subscriber interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Flow.Subscriber` interface is used to receive messages and its implementation
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface is set up to receive messages. It only takes one argument--the
    subscribed item type `<T>`. It has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void onComplete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onError(Throwable throwable)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onNext(T item)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flow.Subscription interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Flow.Subscription` interface ensures that only subscribers receive what
    is requested. Also, as you will see here, a subscription can be cancelled at anytime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface does not take any arguments and is the linkage that controls
    the messages between instances of `Flow.Publisher` and `Flow.Subscriber`. It has
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void cancel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void request(long n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flow.Processor interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Flow.Processor` interface can serve as both a `Subscriber` and a `Publisher`.
    The implementation is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface takes two arguments--the subscribed item type `<T>` and the
    published item type `<R>`. It does not have its own methods, but does inherit
    the following method from `java.util.concurrent.Flow.Publisher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void subscribe(Flow.Subscriber<? super T> subscriber)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow.Processor` also inherits the following methods from the `java.util.concurrent.Flow.Subscriber`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void onComplete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onError(Throwable throwable)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onNext(T item)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void onSubscribe(Flow.Subscription subscription)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any given implementation of reactive programming, we will have a `Subscriber`
    that requests data and a `Publisher` that provides the data. Let''s first look
    at a sample `Subscriber` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, implementing the `Subscriber` is not difficult. The heavy work
    is done with the processors in-between the `Subscriber` and `Publisher`. Let''s
    look at a sample implementation where the `Publisher` publishes a data stream
    to subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Additional Concurrency Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **More Concurrency Updates** Java Enhancement Proposal, JEP 266, aimed
    to improve the use of concurrency in Java. In this section, we will briefly explore
    the concept of Java concurrency and look at related enhancements to the Java 9
    platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Java concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting Reactive Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletableFuture` API enhancements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start with a brief explanation of concurrency, then
    look at system configurations, cover Java threads, and then look at the concurrency
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrent processing has been around since the 1960s. In those formative years,
    we already had systems that permitted multiple processes to share a single processor.
    These systems are more clearly defined as pseudo-parallel systems because it only
    appeared that multiple processes were being simultaneously executed. Our computers
    today still operate in this manner. The difference between the 1960s and current
    day is that our computers can have multiple CPUs, each with multiple cores, which
    better supports concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism are often used as interchangeable terms. Concurrency
    is when multiple processes overlap, although the start and stop times could be
    different. Parallelism occurs when tasks start, run, and stop at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: System configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several different processor configurations that need to be considered.
    This section features two common configurations. The first configuration is that
    of shared memory and is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f1ef63e-003b-4a3a-973f-e82324ce684e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the shared memory system configuration has multiple processors
    that all share a common system memory. The second featured system configuration
    is a distributed memory system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f1b68be-2893-44ad-a1a9-adecc3d57894.png)'
  prefs: []
  type: TYPE_IMG
- en: With the distributed memory system, each processor has its own memory and each
    individual processor is fully linked with the other processors, making for a distributed
    system that is fully linked.
  prefs: []
  type: TYPE_NORMAL
- en: Java threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thread in Java is a program execution and is built into the JVM. The `Thread`
    class is part of the `java.lang` package (`java.lang.Thread`). Threads have priorities
    that control in what order the JVM executes them. While the concept is simple,
    implementation is not. Let's start by taking a close look at the `Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Thread` class has two nested classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static enum Thread.State`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static interface Thread.UncaughtExceptionHandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three instance variables for managing thread priorities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static final int MAX_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static final int MIN_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static final int NORM_PRIORITY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Thread` class has eight constructors, all of which allocate a new `Thread`
    object. Here are the constructor signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public Thread()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(Runnable target)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(Runnable target, String name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(String name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(ThreadGroup group, Runnable target)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(ThreadGroup group, Runnable target, String name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(ThreadGroup group, Runnable target, String name, long stackSize)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread(ThreadGroup group, String name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Thread` class also has 43 methods, six of which have been deprecated.
    The remaining methods are listed here, save for the accessors and mutators which
    are listed separately. You can consult the documentation for details about each
    of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static int activeCount()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void checkAccess()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected Object clone() throws CloneNotSupportedException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static Thread currentThread()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static void dumpStack()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static int enumerate(Thread[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static boolean holdsLock(Object obj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void interrupt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static boolean interrupted()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final boolean isAlive()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final boolean isDaemon()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean isInterrupted()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'join methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void join() throws InterruptedException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void join(long millis) throws InterruptedException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void join(long millis, int nano) throws InterruptedException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void run()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sleep methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static void sleep(long mills) throws InterruptedException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static void sleep(long mills, int nano) throws InterruptedException`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void start()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static void yield()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the list of accessors/getters and mutators/setters for the `Thread`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'accessors/getters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static Map<Thread, StackTraceElement[]> getAllStacktraces()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public ClassLoader getContextClassLoader()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public long getId()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final String getName()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final int getPriority()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public StackTraceElement[] getStackTrace()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread.State getState()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final ThreadGroup getThreadGroup()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Thread.UncaughtExceptionHandler getUncaughtExceptionHandler()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'mutators/setters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void setContextClassLoader(ClassLoader cl)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void setDaemon(boolean on)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler
    eh)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void setName(String name)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public final void setPriority(int newPriority)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Java, concurrency is commonly referred to as multithreading. As indicated
    earlier, managing threads, and especially multithreads, requires great fidelity
    in control. Java employs a couple of techniques including the use of locks. Code
    segments can be locked to ensure that only a single thread can execute that code
    at any given time. We can lock classes and method with the use of the `synchronized`
    keyword. Here is an example of how to lock an entire method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet demonstrates how to use the synchronized keyword to lock
    blocks of code within a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Concurrency improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to employ multiple threads in our Java applications stands to greatly
    improve efficiency and leverage the increasing processing capabilities of modern
    computers. The use of threads in Java gives us great granularity in our concurrency
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads are at the core of Java''s concurrency functionality. We can create
    a thread in Java by defining a `run` method and instantiating a `Thread` object.
    There are two methods of accomplishing this set of tasks. Our first option is
    to extend the `Thread` class and override the `Thread.run` method. Here is an
    example of that approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A second approach is to create a class that implements the `Runnable` interface
    and passing an instance of the class to the constructor of the `Thread`. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both of these methods work equally well, and which one you use is considered
    to be the developer's choice. Of course, if you are looking for additional flexibility,
    the second approach is probably a better one to use. You can experiment with both
    methods to help you make your determination.
  prefs: []
  type: TYPE_NORMAL
- en: CompletableFuture API enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CompleteableFuture<T>` class is part of the `java.util.concurrent` package.
    The class extends the `Object` class and implements the `Future<T>` and `CompletionStage<T>`
    interfaces. This class is used to annotate threads that can be completed. We can
    use the `CompletableFuture` class to represent a future result. When the complete
    method is used, that future result can be completed.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that if multiple threads attempt to simultaneously
    complete (finish or cancel), all but one will fail. Let's look at the class and
    then look at the enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Class details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CompleteableFuture<T>` class has one internal class that marks asynchronous
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The constructor for the `CompleteableFuture<T>` class has to be in sync with
    the provided constructor signature, and it takes no arguments. The class has the
    following methods organized by what they return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a `CompletionStage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other,
    Consumer<? super T> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends
    T> other, Consumer<? super T> action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T>
    other, Function<? super T, U> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends
    T> other, Function<? super T, U> fn, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <U> CompletedStage<U> completedStage(U value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <U> CompletionStage<U> failedStage(Throwable ex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ?
    extends U> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> handleAsync(BiFunction<? super T, Throwable,
    ? extends U> fn, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletionStage<T> minimalCompletionStage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable
    action)` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable
    action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
    Runnable action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable>
    action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T, ? super
    Throwable> action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods return a `CompletionStage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> thenAccept(Consumer<? super T> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action,
    Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends
    U> other, BiConsumer<? super T, ? super U> action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `public <U> CompletableFuture<U> thenApply(Function<? super T, ? extends
    U> fn)` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> thenApplyAsync(Function<? super T, ? extends
    U> fn, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U>
    other, BiFunction<? super T, ? super U, ? extends V> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends
    U> other, BiFunction<? super T, ? super U, ? extends V> fn, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> thenComposeAsync(Function<? super T, ? extends
    CompletionStage<U>> fn, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void> thenRun(Runnable action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void>thenRunAsync(Runnable action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<Void>thenRunAsync(Runnable action, Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods return a `CompleteableFuture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static CompletableFuture<Void> allOf(CompletableFuture<?>...cfs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier,
    Executor executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> completeAsync(Supplier<? extends T> supplier)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `public static <U> CompletableFuture<U> completedFuture(U value)` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit
    unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> copy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T>
    fn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <U> CompletableFuture<U> failedFuture(Throwable ex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public <U> CompletableFuture<U> newIncompeteFuture()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static ComletableFuture<Void> runAsync(Runnable runnable)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static CompletableFuture<Void> runAsync(Runnable runnable, Executor
    executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static <U> CompletableFuture<U> supplyAsync(Supplier<U. supplier, Executor
    executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public CompletableFuture<T> toCompletableFuture()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods return a `Executor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public Executor defaultExecutor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static Executor delayedExecutor(long delay, Timeunit unit, Executor
    executor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static Executor delayedExecutor(long delay, Timeunit unit)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods return a `boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean cancel(boolean mayInterruptIfRunning)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean complete(T value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean completeExceptionally(Throwable ex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean isCancelled()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean isCompletedExceptionally()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean isDone()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void obtrudeException(Throwable ex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void obtrudeValue(T value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException,
    TimeoutException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public T get() throws InterruptedException, ExecutionException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public T getNow(T valueIfAbsent)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int getNumberOfDependents()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public T join()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CompleteableFuture<T>` class received the following enhancements as part
    of the Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added time-based enhancements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enables completions based on lapsed time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayed executions are now also supported
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Significant enhancement to subclasses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `CompletableFuture` is easier
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclasses support alternative default executors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifically, the following methods were added in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '`newIncompleteFuture()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultExecutor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimalCompletionStage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completeAsync()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orTimeout()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `completeOnTimeout()` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delayedExecutor()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completedStage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failedFuture()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failedStage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spin-Wait Hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With concurrency, we need to ensure that threads waiting to be executed actually
    get executed. The concept of spin-wait is a process that continually checks for
    a true condition. The aim of Java Enhancement Proposal 285 was to create an API
    that permits Java code to issue hints that a spin loop is currently being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is not a feature that every Java developer will use, it can be useful
    for low-level programming. The hint system simply issues hints--indications, and
    performs no other actions. Justifications for adding these hints include the following
    assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: A spin loop's action time can be improved when using a spin hint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of spin hints will reduce thread-to-thread latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU power consumption will be reduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware threads will execute faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This hint functionality will be contained in a new `onSpinWait()` method as
    part of the `java.lang.Thread` class. Here is an example of implementing the `onSpinWait()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered concurrency enhancements introduced with the Java
    9 platform. We took a deep look at concurrency both as a core Java concept and
    with an eye to what Java 9 is delivering. We also explored the `Flow` class API
    that supports reactive programming, a new concept in Java 9\. In addition, we
    explored concurrency enhancements and the new spin-wait hints introduced in Java
    9.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will highlight the security enhancements introduced
    in Java 9 along with practical examples.
  prefs: []
  type: TYPE_NORMAL
