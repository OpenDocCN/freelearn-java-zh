<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functional Design Patterns – the Deep Theory</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Scala programming language is a hybrid between a functional and object-oriented language. Most of the object-oriented design patterns are still applicable. However, in order to facilitate the full power of Scala, you also need to be aware of the purely functional aspects of it. When using the language and reading tutorials or best practices, developers will most likely notice terms such as <strong>monoids</strong>, <strong>monads</strong>, and <strong>functors</strong> appearing more often as the problems become harder or the solutions are desired to be more elegant. In this chapter, we will focus on the following functional design patterns:</p>
<ul>
<li>Monoids</li>
<li>Functors</li>
<li>Monads</li>
</ul>
<p>There are a lot of resources on the preceding topics all over the internet. The problem is that many of them are extremely theoretical and hard to understand by someone who is not really familiar with mathematics, and more specifically, category theory. As it happens, in practice, many developers lack the deep mathematical background needed to grasp the topics, and it is not unusual to completely avoid these concepts in the code.</p>
<p>In my experience, most of the Scala developers I know have tried to read tutorials on the topics covered in this chapter, and they've found these topics difficult to understand and have given up. Expert mathematicians seem to find these concepts much easier. However, despite repeated attempts at understanding, most people admit that they are not completely comfortable with the deep functional programming theory. In this chapter, we will try and present this theory in a way that is easy to understand, and we will give an idea of how and when to apply the theory.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstraction and vocabulary</h1>
                </header>
            
            <article>
                
<p>A big part of programming is abstraction. We find common functionality, laws, and behavior and encapsulate them into classes, interfaces, functions, and so on, which are abstract and allow code reuse. Then, we refer to them and reuse them to minimize code duplication and the possibility of errors. Some of these abstractions are more common than others and are observed in different projects and used by more people. These abstractions lead to the creation of a common vocabulary, which additionally helps in communication and understanding. Everybody knows certain data structures such as trees and hash maps, and so there is no need to get into detail about them because their behavior and requirements are well-known. Similarly, when someone gains enough experience in design patterns, they can see them and easily apply the patterns to the problems they are trying to tackle.</p>
<p>In this chapter, we will try to look at monoids, monads, and functors from a point of view that will teach us how to recognize them and when to use them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids</h1>
                </header>
            
            <article>
                
<p>All monoids, monads, and functors are derived from mathematics. One thing about this subject is that similarly to programming, it tries to find abstractions. If we try to map mathematics to programming, we can think about the different datatypes we have—<kbd>Int</kbd>, <kbd>Double</kbd>, <kbd>Long</kbd>, or custom datatypes. Each type can be characterized by the operations it supports and the laws of these operations, and this is called the <em>algebra</em> of the type.</p>
<p>Now, if we think about it, we can identify the operations that are shared by multiple types, for example, addition, multiplication, subtraction, and so on. Different types can share the same operations and they can conform to exactly the same laws. This is something we can take advantage of because this allows us to write generic programs that apply to different types that follow some specific rules.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What are monoids?</h1>
                </header>
            
            <article>
                
<p>After the preceding brief introduction to monoids, let's get straight to business and look at a formal definition of a <em>monoid</em>:</p>
<div class="packt_infobox">A monoid is a purely algebraic structure, which means that it is defined only by its algebra. All monoids must conform to the so-called <strong>monoid laws</strong>.</div>
<p>The preceding definition is definitely not enough to have a good understanding of monoids, so let's break it into pieces in this section and try to come up with a better one.</p>
<p>First, let's clarify the term <strong>algebraic structure</strong>:</p>
<div class="packt_infobox"><strong>Algebraic</strong>: It is defined only by its algebra, for example, the operations it supports and the laws it conforms to.</div>
<p>Now that we know that monoids are defined only by the operations they support, let's have a look at the monoid laws:</p>
<ul>
<li>A monoid contains a <kbd>T</kbd> type.</li>
<li>A monoid contains one associative binary operation. This means that for any <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> of the <kbd>T</kbd> type, the following is true:<br/>
<kbd>op(op(x, y), z) == op(x, op(y, z))</kbd>.</li>
<li>A structure must have an <em>identity element</em>—<kbd>zero</kbd>. This element is characterized by the fact that the previous operation will always return the other element—<kbd>op(x, zero) == x</kbd> and <kbd>op(zero, x) == x</kbd>.</li>
</ul>
<p>Other than the preceding laws, different monoids might not have absolutely anything to do with each other—they can have any type. Now let's look at a better definition of a monoid that would actually mean more to you as a developer:</p>
<div class="packt_infobox">A monoid is a type with an associative binary operation over it, which also has an identity element.</div>
<p>The monoid rules are extremely simple but they give us great power to write polymorphic functions based just on the fact that monoids always conform to the same rules. With the use of monoids, we can easily facilitate parallel computation and build complex calculations from small pieces.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids in real life</h1>
                </header>
            
            <article>
                
<p>We use monoids all the time without realizing it—string concatenation, sums of integers, products, Boolean operations, lists, and so on—they are all examples of monoids. Let's look at integer addition:</p>
<ul>
<li><strong>Our type</strong>: <kbd>Int</kbd>.</li>
<li><strong>Our associative operation</strong>: <kbd>add</kbd>. It is indeed associative because <kbd>((1 + 2) + 3) == (1 + (2 + 3))</kbd>.</li>
<li><strong>Our identity element</strong>: <kbd>0</kbd>. It does nothing when added to another integer.</li>
</ul>
<p>We can easily come up with similar examples for string concatenation, where the identity element will be an empty string, or for list concatenation, where the identity element will be an empty list, and many others. Similar examples can be found absolutely everywhere.</p>
<p>Everything we mentioned previously takes us to the following Scala representation of a monoid:</p>
<pre><span>trait </span>Monoid[<span>T</span>] {<br/>  <span>def </span><span>op</span>(l: <span>T</span><span>, </span>r: <span>T</span>): <span>T<br/></span><span>  </span><span>def </span><span>zero</span>: <span>T<br/></span>}</pre>
<p>Starting from this base trait, we can define just about any monoid we want. The following are a few implementations of a integer addition monoid, integer multiplication monoid, and a string concatenation monoid:</p>
<pre><span>package object </span>monoids {<br/>  <span>val </span><span>intAddition</span>: Monoid[<span>Int</span>] = <span>new </span>Monoid[<span>Int</span>] {<br/>    <span>val </span><span>zero</span>: <span>Int </span>= <span>0<br/></span><span><br/></span><span>    </span><span>override def </span><span>op</span>(l: <span>Int, </span>r: <span>Int</span>): <span>Int </span>= l + r<br/>  }<br/>  <br/>  <span>val </span><span>intMultiplication</span>: Monoid[<span>Int</span>] = <span>new </span>Monoid[<span>Int</span>] {<br/>    <span>val </span><span>zero</span>: <span>Int </span>= <span>1<br/></span><span><br/></span><span>    </span><span>override def </span><span>op</span>(l: <span>Int, </span>r: <span>Int</span>): <span>Int </span>= l * r<br/>  }<br/>  <br/>  <span>val </span><span>stringConcatenation</span>: Monoid[<span>String</span>] = <span>new </span>Monoid[<span>String</span>] {<br/>    <span>val </span><span>zero</span>: <span>String </span>= <span>""<br/></span><span><br/></span><span>    </span><span>override def </span><span>op</span>(l: <span>String</span><span>, </span>r: <span>String</span>): <span>String </span>= l + r<br/>  }<br/>}</pre>
<p>Using the same framework as shown previously, we can define monoids for as many different types as we can think of, as long as they always satisfy the rules. However, you should note that not every operation follows the monoid rules. For example, integer division—<kbd>(6/3)/2 != 6/(3/2)</kbd>.</p>
<p>We saw how to write monoids. But how do we use them? What are they helpful for and can we just write generic functions based only on the rules we know? Of course we can, and we will see this in the following subsection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using monoids</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we already mentioned that monoids can be used for parallel computation and to build complex computations using small and simple chunks. Monoids can also be naturally used with lists and collections, in general.</p>
<p>In this subsection, we will look at different use cases with examples for monoids.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids and foldable collections</h1>
                </header>
            
            <article>
                
<p>To show how useful monoids are with collections that support the <kbd>foldLeft</kbd> and <kbd>foldRight</kbd> functions, let's take a look at the standard Scala list and the declarations of these two functions:</p>
<pre><span>def </span><span>foldLeft</span>[<span>B</span>](z: <span>B</span>)(f: (<span>B</span><span>, </span>A) =&gt; <span>B</span>): <span>B<br/></span><span><br/></span><span>def </span><span>foldRight</span>[<span>B</span>](z: <span>B</span>)(f: (A<span>, </span><span>B</span>) =&gt; <span>B</span>): <span>B</span></pre>
<p>Usually, the <kbd>z</kbd> parameter in these two functions is called the <kbd>zero</kbd> value, so if <kbd>A</kbd> and <kbd>B</kbd> are of the same type, we will end up with the following:</p>
<pre><span>def </span><span>foldLeft</span>[<span>A</span>](z: <span>A</span>)(f: (<span>A</span><span>, </span><span>A</span>) =&gt; <span>A</span>): <span>A<br/></span><span><br/></span><span>def </span><span>foldRight</span>[<span>A</span>](z: <span>A</span>)(f: (<span>A</span><span>, </span><span>A</span>) =&gt; <span>A</span>): <span>A</span></pre>
<p>Looking at the functions now, we can see that these are exactly monoid rules. This means that we can write an example as shown in the following code, which uses the monoids we created previously:</p>
<pre><span>object </span>MonoidFolding {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>strings = <span>List</span>(<span>"This is</span><span>\n</span><span>"</span><span>, </span><span>"a list of</span><span>\n</span><span>"</span><span>, </span><span>"strings!"</span>)<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    System.<span>out</span>.println(<span>s"Left folded:</span><span>\n</span><span>$</span>{strings.foldLeft(stringConcatenation.zero)(stringConcatenation.op)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Right folded:</span><span>\n</span><span>$</span>{strings.foldRight(stringConcatenation.zero)(stringConcatenation.op)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"6! is: </span><span>$</span>{numbers.foldLeft(intMultiplication.zero)(intMultiplication.op)}<span>"</span>)<br/>  }<br/>}</pre>
<p>Another thing to note in the preceding code is that it doesn't actually matter for the final result whether we use <kbd>foldLeft</kbd> or <kbd>foldRight</kbd> because our monoids have an associative operation. It does, however, matter in terms of performance.</p>
<p>The output of the preceding example is as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7686cb64-3b96-44cb-849d-1d0da21aad98.png" style="width:41.00em;height:15.33em;" width="724" height="271"/></div>
<p>Looking at the preceding example, you can see that we can write a generic function that will fold a list using a monoid and do different things depending on the monoid operation. Here is the code for it:</p>
<pre><span>object </span>MonoidOperations {<br/>  <span>def </span><span>fold</span>[<span>T</span>](list: <span>List</span>[<span>T</span>]<span>, </span>m: Monoid[<span>T</span>]): <span>T </span>= list.foldLeft(m.zero)(m.op)<br/>}</pre>
<p>We can now rewrite our example and use our generic function as follows:</p>
<pre><span>object </span>MonoidFoldingGeneric {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>strings = <span>List</span>(<span>"This is</span><span>\n</span><span>"</span><span>, </span><span>"a list of</span><span>\n</span><span>"</span><span>, </span><span>"strings!"</span>)<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    System.<span>out</span>.println(<span>s"Left folded:</span><span>\n</span><span>$</span>{MonoidOperations.<span>fold</span>(strings<span>,<br/>     </span>stringConcatenation)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Right folded:</span><span>\n</span><span>$</span>{MonoidOperations.<span>fold</span>(strings<span>,<br/>     </span>stringConcatenation)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"6! is: </span><span>$</span>{MonoidOperations.<span>fold</span>(numbers<span>,<br/>     </span>intMultiplication)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output, of course, will be exactly the same. However, things are much neater now, and this is how monoids can become useful when used together with lists.</p>
<p>In the preceding examples, we made the <kbd>A</kbd> and <kbd>B</kbd> types to be the same in the <kbd>foldLeft</kbd> and <kbd>foldRight</kbd> functions. However, we might build a different data structure with a different type, or our algorithm might rely on a different type that has a different monoid to the type of the list we have. In order to support such a scenario, we have to add the possibility of mapping the type of the original list to a different type:</p>
<pre><span>object </span>MonoidOperations {<br/>  <span>def </span><span>fold</span>[<span>T</span>](list: <span>List</span>[<span>T</span>]<span>, </span>m: Monoid[<span>T</span>]): <span>T </span>= <span>foldMap</span>(list<span>, </span>m)(<span>identity</span>)<br/><br/>  <span>def </span><span>foldMap</span>[<span>T</span><span>, </span><span>Y</span>](list: <span>List</span>[<span>T</span>]<span>, </span>m: Monoid[<span>Y</span>])(f: <span>T </span>=&gt; <span>Y</span>): <span>Y </span>=<br/>    list.foldLeft(m.zero) {<br/>      <span>case </span>(t<span>, </span>y) =&gt; m.op(t<span>, </span>f(y))<br/>    }<br/>}</pre>
<p>The preceding code shows how our fold functions will change. This would give us the possibility of implementing even more complex operations on top of our lists using different types of monoids.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids and parallel computations</h1>
                </header>
            
            <article>
                
<p>The fact that a monoid operation is associative means that if we have to chain multiple operations, we could probably do it in parallel. For example, if we have the numbers <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd> and wanted to find <kbd>4!</kbd>, we can use what we used previously, which would end up being evaluated to the following:</p>
<pre>op(op(op(1, 2), 3), 4)</pre>
<p>The associativity, however, would allow us to do the following:</p>
<pre>op(op(1, 2), op(3, 4))</pre>
<p>Here, the nested operations could be done independently and in parallel. This is also called <strong>balanced fold</strong>. An implementation of a balanced fold would look like the following:</p>
<pre><span>def </span><span>balancedFold</span>[<span>T</span><span>, </span><span>Y</span>](list: <span>IndexedSeq</span>[<span>T</span>]<span>, </span>m: Monoid[<span>Y</span>])(f: <span>T </span>=&gt; <span>Y</span>): <span>Y </span>=<br/>  <span>if </span>(list.length == <span>0</span>) {<br/>    m.zero<br/>  } <span>else if </span>(list.length == <span>1</span>) {<br/>    f(list(<span>0</span>))<br/>  } <span>else </span>{<br/>    <span>val </span>(left<span>, </span>right) = list.splitAt(list.length / <span>2</span>)<br/>    m.op(<span>balancedFold</span>(left<span>, </span>m)(f)<span>, </span><span>balancedFold</span>(right<span>, </span>m)(f))<br/>  }</pre>
<p>It is worth mentioning that we've used an <kbd>IndexedSeq</kbd> here, as it will guarantee that getting elements by index will be efficient. Also, this code is not parallel, but we've switched the order of the operations as we mentioned previously. In the case of integers, it might not make much of a difference but for other types such as strings, it will improve the performance. The reason is that strings are immutable and every concatenation will create a new string by allocating new space. So, if we are simply going from the left-hand side to the right-hand side, we will be allocating more and more space and throwing away the intermediate results all the time.</p>
<p>The next code listing shows how to use our <kbd>balancedFold</kbd> function:</p>
<pre><span>object </span>MonoidBalancedFold {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>numbers = <span>Array</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/>    System.<span>out</span>.println(<span>s"4! is: </span><span>$</span>{MonoidOperations.<span>balancedFold</span>(numbers<span>, </span>intMultiplication)(<span>identity</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The result would be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5334da2c-125d-4bd3-a363-e82e973f12a4.png" style="width:41.33em;height:4.17em;" width="723" height="73"/></div>
<p>There are a few ways to make this code parallel. The hard way would involve quite a lot of extra code writing in order to manage threads, and it is really advanced. It probably deserves a chapter (if not an entire book) of its own, and we will just mention it for the more curious readers—<em>purely functional parallelism</em>. There are some materials on GitHub (<a href="https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism">https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism</a>) that cover this concept nicely with examples.</p>
<p>We can also use the <kbd>par</kbd> method that most Scala collections have. Due to the laws that monoids conform to, we are guaranteed to always get the correct results, no matter how the underlying collections are parallelized. The following listing shows example implementations of our fold methods:</p>
<pre><span>def </span><span>foldPar</span>[<span>T</span>](list: <span>List</span>[<span>T</span>]<span>, </span>m: Monoid[<span>T</span>]): <span>T </span>=<br/>  <span>foldMapPar</span>(list<span>, </span>m)(<span>identity</span>)<br/><br/><span>def </span><span>foldMapPar</span>[<span>T</span><span>, </span><span>Y</span>](list: <span>List</span>[<span>T</span>]<span>, </span>m: Monoid[<span>Y</span>])(f: <span>T </span>=&gt; <span>Y</span>): <span>Y </span>=<br/>  list.par.foldLeft(m.zero) {<br/>    <span>case </span>(t<span>, </span>y) =&gt; m.op(t<span>, </span>f(y))<br/>  }</pre>
<p>The only difference between these methods and what we had before is the call to <kbd>par</kbd> before we use <kbd>foldLeft</kbd>. Using the methods is exactly the same as we did previously:</p>
<pre><span>object </span>MonoidFoldingGenericPar {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>strings = <span>List</span>(<span>"This is</span><span>\n</span><span>"</span><span>, </span><span>"a list of</span><span>\n</span><span>"</span><span>, </span><span>"strings!"</span>)<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    System.<span>out</span>.println(<span>s"Left folded:</span><span>\n</span><span>$</span>{MonoidOperations.<span>foldPar</span>(strings<span>,<br/>     </span>stringConcatenation)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Right folded:</span><span>\n</span><span>$</span>{MonoidOperations.<span>foldPar</span>(strings<span>,<br/>     </span>stringConcatenation)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"6! is: </span><span>$</span>{MonoidOperations.<span>foldPar</span>(numbers<span>,<br/>     </span>intMultiplication)}<span>"</span>)<br/>  }<br/>}</pre>
<p>As you would expect, the result here would be exactly the same as it was for the sequential example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids and composition</h1>
                </header>
            
            <article>
                
<p>So far, we have seen some examples where monoids are used to improve efficiency and write generic functions. They, however, are even more powerful. The reason is that they follow another useful rule:</p>
<div class="packt_infobox">Monoids support <em>composition</em>; if <kbd>A</kbd> and <kbd>B</kbd> are monoids, then their product <kbd>(A, B)</kbd> is also a monoid.</div>
<p>What does this mean exactly and how can we take advantage of this? Let's look at the following function:</p>
<pre><span>def </span><span>compose</span>[<span>T</span><span>, </span><span>Y</span>](a: Monoid[<span>T</span>]<span>, </span>b: Monoid[<span>Y</span>]): Monoid[(<span>T</span><span>, </span><span>Y</span>)] =<br/>  <span>new </span>Monoid[(<span>T</span><span>, </span><span>Y</span>)] {<br/>    <span>val </span><span>zero</span>: (<span>T</span><span>, </span><span>Y</span>) = (a.zero<span>, </span>b.zero)<br/><br/>    <span>override def </span><span>op</span>(l: (<span>T</span><span>, </span><span>Y</span>)<span>, </span>r: (<span>T</span><span>, </span><span>Y</span>)): (<span>T</span><span>, </span><span>Y</span>) =<br/>      (a.op(l._1<span>, </span>r._1)<span>, </span>b.op(l._2<span>, </span>r._2))<br/>  }</pre>
<p>In the preceding code, we showed a function that applies the composition exactly as we mentioned in our definition. This would now allow us to simultaneously apply multiple operations using a monoid, and we can compose even more and apply even more operations. Let's see an example that will calculate the sum and the factorial of the numbers given to it:</p>
<pre><span>object </span>ComposedMonoid {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>numbers = <span>Array</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    <span>val </span>sumAndProduct = compose(intAddition<span>, </span>intMultiplication)<br/>    System.<span>out</span>.println(<span>s"The sum and product is: </span><span>$</span>{MonoidOperations.<span>balancedFold</span>(numbers<span>, </span>sumAndProduct)(i =&gt; (i<span>, </span>i))}<span>"</span>)<br/>  }<br/>}</pre>
<p>In the preceding example, we took advantage of the <kbd>map</kbd> function as well because our new monoid expects a tuple of integers rather than just the single integers we have in our array. Running the example will yield the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4e95b3b7-ec3c-4c42-989c-5ca1612402d5.png" style="width:45.25em;height:3.58em;" width="721" height="57"/></div>
<p>The preceding <kbd>compose</kbd> function is really powerful, and we can do a lot of things with it. We can also efficiently calculate the mean of all items in a list—we just need to use the <kbd>intAddition</kbd> monoid twice and map the numbers to <kbd>(number, 1)</kbd> in order to have the count together with the sum.</p>
<p>So far, we have seen how to compose monoids with operations. However, monoids are quite useful for building data structures as well. Data structures can also form monoids as long as their values also form monoids.</p>
<p>Let's go through an example. In machine learning, we might need to extract the features from some text. Then, each feature will be weighted using a coefficient and a number equal to the number of times we've seen it. Let's try and get to a monoid that can be used to fold a collection and give us what we need—the count of each feature.</p>
<p>First of all, it is clear that we will be counting how many times we see each feature. Building a map of features to be counted sounds like a good idea! We will be incrementing the count for a feature every time we see it. So, if we imagine that each element in our feature list becomes a map of one element, we will have to fold these maps and use our integer sum monoid to sum the values for the same keys.</p>
<p>Let's build a function that can return a monoid, which can be used to fold items into a map and will apply any monoid to the values of the same key of the map:</p>
<pre><span>def </span><span>mapMerge</span>[<span>K</span><span>, </span><span>V</span>](a: Monoid[<span>V</span>]): Monoid[<span>Map</span>[<span>K</span><span>, </span><span>V</span>]] =<br/>  <span>new </span>Monoid[<span>Map</span>[<span>K</span><span>, </span><span>V</span>]] {<br/>    <span>override def </span><span>zero</span>: <span>Map</span>[<span>K</span><span>, </span><span>V</span>] = <span>Map</span>()<br/><br/>    <span>override def </span><span>op</span>(l: <span>Map</span>[<span>K</span><span>, </span><span>V</span>]<span>, </span>r: <span>Map</span>[<span>K</span><span>, </span><span>V</span>]): <span>Map</span>[<span>K</span><span>, </span><span>V</span>] =<br/>      (l.keySet ++ r.keySet).foldLeft(zero) {<br/>        <span>case </span>(res<span>, </span>key) =&gt; res.updated(key<span>, </span>a.op(l.getOrElse(key<span>,<br/>         </span>a.zero)<span>, </span>r.getOrElse(key<span>, </span>a.zero)))<br/>      }<br/>  }</pre>
<p>We can now use this monoid to do different aggregations—sums, multiplications, concatenations, and so on. For our features counting, we will have to use sums and here is how we've done it:</p>
<pre><span>object </span>FeatureCounting {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>features = <span>Array</span>(<span>"hello"</span><span>, </span><span>"features"</span><span>, </span><span>"for"</span><span>, </span><span>"ml"</span><span>, </span><span>"hello"</span><span>,<br/>     </span><span>"for"</span><span>, </span><span>"features"</span>)<br/>    <span>val </span>counterMonoid: Monoid[<span>Map</span>[<span>String</span><span>, Int</span>]] = mapMerge(intAddition)<br/>    System.<span>out</span>.println(<span>s"The features are: </span><span>$</span>{MonoidOperations.<span>balancedFold</span>(features<span>, </span>counterMonoid)(i =&gt; <span>Map</span>(i -&gt; <span>1</span>))}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of the preceding program will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/97ebe6ad-1973-4819-956a-5c689477ea5a.png" width="722" height="51"/></div>
<p>The <kbd>mapMerge</kbd> function that we defined previously can now take any monoid, and we can even easily create maps of maps and so on, without extra code writing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">When to use monoids</h1>
                </header>
            
            <article>
                
<p>In the preceding examples, we showed how to use monoids in order to achieve certain things. However, if we look at the previous example, we could simplify it in the following way:</p>
<pre><span>object </span>FeatureCountingOneOff {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>features = <span>Array</span>(<span>"hello"</span><span>, </span><span>"features"</span><span>, </span><span>"for"</span><span>, </span><span>"ml"</span><span>, </span><span>"hello"</span><span>,<br/>     </span><span>"for"</span><span>, </span><span>"features"</span>)<br/>    System.<span>out</span>.println(<span>s"The features are: </span><span>$</span>{<br/>      features.foldLeft(<span>Map</span>[<span>String</span><span>, Int</span>]()) {<br/>        <span>case </span>(res<span>, </span>feature) =&gt; res.updated(feature<span>,<br/>         </span>res.getOrElse(feature<span>, </span><span>0</span>) + <span>1</span>)<br/>      }<br/>    }<span>"</span>)<br/>  }<br/>}</pre>
<p>In fact, each example could be rewritten to a representation similar to the preceding code.</p>
<p>While someone might be tempted to do things this way, it might not always be scalable. As we already mentioned, the purpose of monoids is to actually allow us to write generic and reusable code. With the help of monoids, we can focus on simple operations and then just compose them together rather than build concrete implementations for everything we want. It might not be worth it for one-off functions, but using monoids would definitely have a positive effect when we are reusing functionality. Moreover, as you already saw, composition here is extremely easy, and with time it will save us from writing a huge amount of code (read less code duplication and possibilities to introduce bugs).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functors</h1>
                </header>
            
            <article>
                
<p>A <strong>functor</strong> is one of those terms that comes from category theory in mathematics and causes a lot of pain to developers who come into functional programming and have less of a mathematical background. It is a requirement for monads, and here we will try to explain it in a way that will be easy to understand.</p>
<p>What is a functor? In the preceding section, we looked at monoids as a way to abstract some computation and then used them in different ways for optimization or to create more complex computations. Even though some people might not agree with the correctness of this approach, let's look at functors from the same point of view—something that will abstract some specific computations.</p>
<div class="packt_infobox">In Scala, a functor is a class that has a  <kbd>map</kbd> method and conforms to a few laws. Let's call them <strong>functor laws</strong>.</div>
<p>The <kbd>map</kbd> method for a functor of the <kbd>F[T]</kbd> type takes a function from <kbd>T</kbd> to <kbd>Y</kbd> as a parameter and returns a <kbd>F[Y]</kbd> as a result. This will become much clearer in the next subsection, where we will show some actual code.</p>
<p>Functors also obey some functor laws:</p>
<ul>
<li><strong>Identity</strong>: Whenever the <kbd>identity</kbd> function is mapped over some data, it doesn't change it, in other words, <kbd>map(x)(i =&gt; i) == x</kbd>.</li>
<li><strong>Composition</strong>: Multiple maps must compose together. It should make no difference if we do this operation: <kbd><span>map(map(x)(i =&gt; y(i)))(i =&gt; z(i))</span></kbd> <span>or</span> <kbd><span>map(x)(i =&gt; z(y(i)))</span></kbd>.</li>
<li>The <kbd>map</kbd> function preserves the structure of the data, for example, it does not add or remove elements, change their order, and so on. It just changes the representation.</li>
</ul>
<p>The preceding laws give developers some grounds to assume certain things when performing different computations. For example, we can now safely postpone different mappings of data in time or just do them all together, and be sure that the final result will be the same.</p>
<p>From what we mentioned previously, we can actually come up with the conclusion that functors set a specific set of laws on their operations (<kbd>map</kbd>, in this case) that must be in place and allow us to automatically reason about their results and effects.</p>
<p>Now that we have a definition for functors and we showed the laws they should follow, in the next subsection we can create a base trait that all functors will be able to extend.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functors in real life</h1>
                </header>
            
            <article>
                
<p>Before we show an example functor trait based on the laws we showed in the preceding section, you can conclude that standard Scala types such as <kbd>List</kbd>, <kbd>Option</kbd>, and others that define a <kbd>map</kbd> method are functors.</p>
<div class="packt_tip">The <kbd>map</kbd> method in the built-in Scala types such as <kbd>List</kbd> has a different signature from the example we show here. In our examples, the first parameter is the functor and the second one is the transformation function we apply to it. In the standard Scala types, the first parameter doesn't need to be passed, as it is the actual object we're calling it on (<kbd>this</kbd>).</div>
<p>If we want to create our own types that follow the functor laws, we can create a base trait and make sure to implement it:</p>
<pre><span>trait </span>Functor[<span>F</span>[_]] {<br/>  <span>def </span><span>map</span>[<span>T</span><span>, </span><span>Y</span>](l: <span>F</span>[<span>T</span>])(f: <span>T </span>=&gt; <span>Y</span>): <span>F</span>[<span>Y</span>]<br/>}</pre>
<p>Now, let's create a list functor that will simply call the <kbd>map</kbd> function of the Scala <kbd>List</kbd>:</p>
<pre><span>package object </span>functors {<br/>  <span>val </span><span>listFunctor </span>= <span>new </span>Functor[<span>List</span>] {<br/>    <span>override def </span><span>map</span>[<span>T</span><span>, </span><span>Y</span>](l: <span>List</span>[<span>T</span>])(f: (<span>T</span>) =&gt; <span>Y</span>): <span>List</span>[<span>Y</span>] = l.map(f)<br/>  }<br/>}</pre>
<p>In the preceding code, the fact that an object is a functor simply allows us to assume that certain laws are in place.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using our functors</h1>
                </header>
            
            <article>
                
<p>A simple example of using our <kbd>listFunctor</kbd> that we defined in the preceding section can be seen as follows:</p>
<pre><span>object </span>FunctorsExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    <span>val </span>mapping = <span>Map</span>(<br/>      <span>1 </span>-&gt; <span>"one"</span><span>,<br/></span><span>      </span><span>2 </span>-&gt; <span>"two"</span><span>,<br/></span><span>      </span><span>3 </span>-&gt; <span>"three"</span><span>,<br/></span><span>      </span><span>4 </span>-&gt; <span>"four"</span><span>,<br/></span><span>      </span><span>5 </span>-&gt; <span>"five"</span><span>,<br/></span><span>      </span><span>6 </span>-&gt; <span>"six"<br/></span><span>    </span>)<br/>    System.<span>out</span>.println(<span>s"The numbers doubled are:<br/>     </span><span>$</span>{<span>listFunctor</span>.map(numbers)(_ * <span>2</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The numbers with strings are:<br/>     </span><span>$</span>{<span>listFunctor</span>.map(numbers)(i =&gt; (i<span>, </span>mapping(i)))}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of the preceding example is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2fcaad83-9593-40b8-bebd-d780b83c09f3.png" width="722" height="110"/></div>
<p>As you can see, functors don't really do much by themselves. They are not exciting at all. However, they set some specific rules that help us understand the results from specific operations. This means that we can define methods based on the abstract <kbd>map</kbd> inside the <kbd>Functor</kbd> trait, which rely on the rules we've stated previously.</p>
<p>Functors are an important concept that are required for monads, which we will look at in the following subsection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monads</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we defined functors. With their <kbd>map</kbd> methods, the standard Scala collections seem to be good examples of functors. We should, however, emphasize again that a functor doesn't mean a collection—it can be a container and any custom-defined class. Based on an abstract <kbd>map</kbd> method and the rules it follows, we can define other functions that will help us reduce code duplication. However, there are not many exciting things we can do based on a mapping only. In our programs, we will have different operations, some of which not only transform a collection or an object, but also modify it in some way.</p>
<p>Monads are another one of those scary terms that come from category theory, which we will try to explain in a way that you will be able to easily understand, identify, and use in your daily routine as a developer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a monad?</h1>
                </header>
            
            <article>
                
<p>We already talked about laws earlier in this chapter. The monoid is defined based on some laws it follows, and these laws allow us to implement generic functionality with certainty, just because we expect certain conditions to hold. If a law is broken, then there is no way for us to know for sure what to expect in terms of how something will behave. In such cases, things would most probably end up returning wrong results.</p>
<p>Similar to the other concepts we already saw in this chapter, monads are defined in terms of the laws they follow. In order for a structure to be considered a monad, it must satisfy all the rules. Let's start with a short definition, which we will expand on later:</p>
<div class="packt_infobox">Monads are functors that have the <kbd>unit</kbd> and <kbd>flatMap</kbd> methods and follow the <strong>monad rules</strong>.</div>
<p>So, what does the preceding definition mean? First of all, it means that monads follow all the rules we previously defined about functors. Additionally, they take things further and add support for two more methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The flatMap method</h1>
                </header>
            
            <article>
                
<p>Before we formally define the rules, let's have a brief discussion about <kbd>flatMap</kbd>. We assume that you are familiar with Scala collections and are aware of the existence of the <kbd>flatten</kbd> method. So, just the name of <kbd>flatMap</kbd> tells us that it maps and then flattens, as shown here:</p>
<pre>def flatMap[T](f: Y =&gt; Monad[T]) : Monad[T] = flatten(map(f))</pre>
<p>We don't have the monad definition we referred to in the preceding code yet, but that's fine. We will get there. For now, let's just look at it as another generic parameter. You should also know that <kbd>flatten</kbd> has the following declaration:</p>
<pre>def flatten[T](x: F[F[T]]): M[T]</pre>
<p>For example, if <kbd>F</kbd> is actually a <kbd>List</kbd>, <kbd>flatten</kbd> will convert a list of lists into a simple list of whatever the type of the internal one is. If <kbd>F</kbd> is an <kbd>Option</kbd>, then the ones with the <kbd>None</kbd> value in the nested option will disappear and the rest will remain. These two examples show us that the <kbd>flatten</kbd> result actually depends on the specifics of the type being flattened, but in any case, it is clear how it transforms our data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The unit method</h1>
                </header>
            
            <article>
                
<p>The other method we mentioned previously is <kbd>unit</kbd>. It actually doesn't matter how this method is called and it could be different for different languages based on their standards. What is important is its functionality. The signature of <kbd>unit</kbd> can be written in the following way:</p>
<pre>def unit[T](value: T): Monad[T]</pre>
<p>What does the preceding line mean? It is pretty simple—it takes a value of the <kbd>T</kbd> type and turns it into a monad of the <kbd>T</kbd> type. This is nothing more than a single argument constructor or just a factory method. In Scala, this can be expressed using a companion object with an <kbd>apply</kbd> method as well. As long as it does the right thing, the implementation doesn't really matter. In Scala, we have many of the collection types as examples—<kbd>List</kbd>, <kbd>Array</kbd>, <kbd>Seq</kbd>—they all have an <kbd>apply</kbd> method that supports the following:</p>
<pre>List(x)<br/>Array(x)<br/>Seq(x)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The connection between map, flatMap, and unit</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we showed how <kbd>flatMap</kbd> can be defined using <kbd>map</kbd> and <kbd>flatten</kbd>. We can, however, take a different approach and define <kbd>map</kbd> using <kbd>flatMap</kbd>. Here is what the definition would look like in our pseudo code:</p>
<pre>def map[T](f: Y =&gt; T): Monad[T] = flatMap { x =&gt; unit(f(x)) }</pre>
<p>The preceding definition is important because it draws the relationship between all the <kbd>map</kbd>, <kbd>flatMap</kbd>, and <kbd>unit</kbd> methods.</p>
<p>Depending on what kind of monads we implement, it could sometimes be easier to implement <kbd>map</kbd> first (usually, if we build collection-like monads) and then <kbd>flatMap</kbd> based on it and <kbd>flatten</kbd>, while other times it could be easier to first implement<br/>
<kbd>flatMap</kbd> instead. As long as the monad laws are satisfied, it shouldn't matter which approach we take.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The names of the methods</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we mentioned that it doesn't actually matter how the <kbd>unit</kbd> method is called. While it is true for <kbd>unit</kbd> and it could be propagated to any of the other methods, it is recommended that <kbd>map</kbd> and <kbd>flatMap</kbd> actually remain this way. It doesn't mean that it is not possible to make things work, but following common conventions would make things much simpler. Moreover, <kbd>map</kbd> and <kbd>flatMap</kbd> give us something extra—the possibility of using our classes in <em>for comprehensions</em>. Consider the following example, which is only here to illustrate how having methods with such names helps:</p>
<pre><span>case class </span>ListWrapper(list: <span>List</span>[<span>Int</span>]) {<br/>  <span>// just wrap<br/></span><span>  </span><span>def </span><span>map</span>[<span>B</span>](f: <span>Int </span>=&gt; <span>B</span>): <span>List</span>[<span>B</span>] = list.map(f)<br/><br/>  <span>// just wrap<br/></span><span>  </span><span>def </span><span>flatMap</span>[<span>B</span>](f: <span>Int </span>=&gt; GenTraversableOnce[<span>B</span>]): <span>List</span>[<span>B</span>] =<br/>    list.flatMap(f)<br/>}</pre>
<p>In the preceding example, we just wrap a list in an object and define the <kbd>map</kbd> and <kbd>flatMap</kbd> methods. If we didn't have the preceding object, we could have written something like this:</p>
<pre><span>object </span>ForComprehensionWithLists {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>l1 = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>)<br/>    <span>val </span>l2 = <span>List</span>(<span>5</span><span>, </span><span>6</span><span>, </span><span>7</span><span>, </span><span>8</span>)<br/>    <span>val </span>result = <span>for </span>{<br/>      x &lt;- l1<br/>      y &lt;- l2<br/>    } <span>yield </span>x * y<br/>    <span>// same as<br/></span><span>    // val result = l1.flatMap(i =&gt; l2.map(_ * i))<br/></span><span>    </span>System.<span>out</span>.println(<span>s"The result is: </span><span>$</span>{result}<span>"</span>)<br/>  }<br/>}</pre>
<p>With our wrapper object, we could do the same as follows:</p>
<pre><span>object </span>ForComprehensionWithObjects {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>wrapper1 = <span>ListWrapper</span>(<span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span>))<br/>    <span>val </span>wrapper2 = <span>ListWrapper</span>(<span>List</span>(<span>5</span><span>, </span><span>6</span><span>, </span><span>7</span><span>, </span><span>8</span>))<br/>    <span>val </span>result = <span>for </span>{<br/>      x &lt;- wrapper1<br/>      y &lt;- wrapper2<br/>    } <span>yield </span>x * y<br/>    System.<span>out</span>.println(<span>s"The result is: </span><span>$</span>{result}<span>"</span>)<br/>  }<br/>}</pre>
<p>Both applications do the same and will have exactly the same output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/d4083777-2904-4438-b4d5-495ac7548c79.png" style="width:38.58em;height:3.83em;" width="723" height="72"/></div>
<p>What the second application uses, however, is the fact that our wrapper class contains methods specifically with the names such as <kbd>map</kbd> and <kbd>flatMap</kbd>. If we rename any of them, we would get a compilation error—we could still manage to write the same code but it will not be able to use syntactic sugar in Scala. Another point here is that the <em>for comprehension</em> would work correctly in the case where both the methods actually follow the rules for <kbd>map</kbd> and <kbd>flatMap</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The monad laws</h1>
                </header>
            
            <article>
                
<p>After going a bit through the methods a monad is supposed to support, now we can formally define the monad laws. You already saw that monads are functors and they follow the functor laws. Being explicit is always better, so here we will mix the laws together:</p>
<ul>
<li><strong>Identity law</strong>: Doing <kbd>map</kbd> over the identity function doesn't change the data—<kbd>map(x)(i =&gt; i) == x</kbd>. Flat mapping over the <kbd>unit</kbd> function also keeps the data the same—<kbd>x.flatMap(i =&gt; unit(i)) == x</kbd>. The latter basically says that <kbd>flatMap</kbd> undoes <kbd>unit</kbd>. Using the connection between <kbd>map</kbd>, <kbd>flatMap</kbd>, and <kbd>unit</kbd> we defined earlier, we can derive one of these two rules from the other and vice versa. The <kbd>unit</kbd> method can be thought of as the zero element in monoids.</li>
<li><strong>The unit law</strong>: From the definition of <kbd>unit</kbd>, we can also say this: <kbd>unit(x).flatMap { y =&gt; f(y) } == f(x)</kbd>. From this, we will get <kbd>unit(x).map { y =&gt; f(x) } == unit(f(x))</kbd>. This gives us some interesting connections between all the methods.</li>
<li><strong>Composition</strong>: Multiple maps must be composed together. It should make no difference if we do <kbd>x.map(i =&gt; y(i)).map(i =&gt; z(i))</kbd> or <kbd>x.map(i =&gt; z(y(i)))</kbd>. Moreover, multiple <kbd>flatMap</kbd> calls must also compose, making the following true:<br/>
<kbd>x.flatMap(i =&gt; y(i)).flatMap(i =&gt; z(i)) == x.flatMap(i =&gt; y(i).flatMap(j =&gt; z(j)))</kbd>.</li>
</ul>
<p>Monads, similarly to monoids, also have a zero element. Some real-world examples of monadic zeros are <kbd>Nil</kbd> in the Scala List and the <kbd>None</kbd> option. However, here we can also have multiple zero elements, which are represented by an algebraic datatype with a constructor parameter to which we can pass different values. In order to be complete, we might not have zeros at all if there is no such concept for the monads we are modeling. In any case, the zero monad represents some kind of emptiness and follows some extra laws:</p>
<ul>
<li><strong>Zero identity</strong>: This one is pretty straightforward. It says that no matter what function we apply to a zero monad, it is still going to be zero—<kbd>zero.flatMap(i =&gt; f(i)) == zero</kbd> and <kbd>zero.map(i =&gt; f(i)) == zero</kbd>. <kbd>Zero</kbd> shouldn't be confused with <kbd>unit</kbd>, as they are different and the latter doesn't represent emptiness.</li>
<li><strong>Reverse zero</strong>: This is straightforward as well. Basically, if we replace everything with zero, our final result will also be zero—<kbd>x.flatMap(i =&gt; zero) == zero</kbd>.</li>
<li><strong>Commutativity</strong> : Monads can have a concept of addition, whether it is concatenation or something else. In any case, this kind of operation when done with the zero monad will be commutative, for example, <kbd>x plus zero == zero plus x == x</kbd>.</li>
</ul>
<div class="packt_tip"><span class="packt_screen">Monads and side effects<br/></span><br/>
When presenting the composition law, we kind of assumed that an operation has no side effects. We said the following:<br/>
<kbd>x.map(i =&gt; y(i)).map(i =&gt; z(i)) == x.map(i =&gt; z(y(i)))</kbd>.<br/>
However, let's now think about what would happen if <kbd>y</kbd> or <kbd>z</kbd> cause some side effects. On the left-hand side, we first run all <kbd>y</kbd>s and then all <kbd>z</kbd>s. On the right-hand side, however, we interleave them, doing <kbd>y</kbd> and <kbd>z</kbd> all the time. Now, if an operation causes a side effect, it would mean that the two might end up producing different results. That's why developers should prefer using the left-hand side version, especially when there might be side effects such as IO.</div>
<p>We have discussed the monad laws. For those who have more experience with Scala, monads might seem pretty close to the collection classes, and the rules we defined previously might seem logical. However, we are pointing out once more that it is not necessary for a monad to be a collection, and it is important that these rules are followed in order to be able to call an algebraic data structure a monad.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monads in real life</h1>
                </header>
            
            <article>
                
<p>After going through a lot of theory about monads, it would now be useful to go through some code that demonstrates how to implement and use the theoretical concepts, which real-world situations they are good for, and so on.</p>
<p>Let's now do something similar to what we did before, and show what a monad trait will look like in Scala. Before doing this, however, let's slightly change our functor definition:</p>
<pre><span>trait </span>Functor[<span>T</span>] {<br/>  <span>def </span><span>map</span>[<span>Y</span>](f: <span>T </span>=&gt; <span>Y</span>): Functor[<span>Y</span>]<br/>}</pre>
<p>In the preceding code, instead of passing the element that will be mapped, we assume that the type that mixes <kbd>Functor</kbd> will have a way to pass it to the <kbd>map</kbd> implementation. We also changed the return type so that we can chain multiple functors using <kbd>map</kbd>. After we've done this, we can show our <kbd>Monad</kbd> trait:</p>
<pre><span>trait </span>Monad[<span>T</span>] <span>extends </span>Functor[<span>T</span>] {<br/>  <span>def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): Monad[<span>Y</span>]<br/><br/>  <span>def </span><span>flatMap</span>[<span>Y</span>](f: <span>T </span>=&gt; Monad[<span>Y</span>]): Monad[<span>Y</span>]<br/><br/>  <span>override def </span><span>map</span>[<span>Y</span>](f: <span>T </span>=&gt; <span>Y</span>): Monad[<span>Y</span>] =<br/>    flatMap(i =&gt; unit(f(i)))<br/>}</pre>
<p>The preceding code follows a convention similar to what we used for monoids. The methods the monad has are exactly the same as we have already mentioned earlier in the theoretical part of this chapter. The signatures might be slightly different, but mapping them to the theoretical code, which was made to be understood easily, shouldn't cause any issues.</p>
<p>As you can see, the monads extend functors. Now, whenever we want to write monads, we just need to extend the preceding trait and implement the methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using monads</h1>
                </header>
            
            <article>
                
<p>Simply having a monad trait puts us in a framework that we can follow. We already went through the theory of monads and the laws that they follow. However, in order to understand how monads work and what they are useful for, looking at an actual example is invaluable.</p>
<p>However, how are we supposed to even use monads if we don't know what their purpose is? Let's call them computation builders, as this is exactly what they are used for. This gives the ordinary developer much more understanding about when and where to use monad's computation builder chain operations in some way, which are then performed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Option monad</h1>
                </header>
            
            <article>
                
<p>We have already mentioned a few times that the standard Scala <kbd>Option</kbd> is a monad. In this subsection, we will provide our own monadical implementation of this standard class and show one of the many possible uses of monads.</p>
<p>In order to show how useful the option is, we will see what happens if we don't have it. Let's imagine that we have the following classes:</p>
<pre><span>case class </span>Doer() {<br/>  <span>def </span><span>getAlgorithm</span>(isFail: <span>Boolean</span>) =<br/>    <span>if </span>(isFail) {<br/>      <span>null<br/></span><span>    </span>} <span>else </span>{<br/>      <span>Algorithm</span>()<br/>    }<br/>}<br/><br/><span>case class </span>Algorithm() {<br/>  <span>def </span><span>getImplementation</span>(isFail: <span>Boolean, </span>left: <span>Int, </span>right: <span>Int</span>): Implementation =<br/>    <span>if </span>(isFail) {<br/>      <span>null<br/></span><span>    </span>} <span>else </span>{<br/>      <span>Implementation</span>(left<span>, </span>right)<br/>    }<br/>}<br/><br/><span>case class </span>Implementation(left: <span>Int, </span>right: <span>Int</span>) {<br/>  <span>def </span><span>compute</span>: <span>Int </span>= left + right<br/>}</pre>
<p>In order to test, we have added a <kbd>Boolean</kbd> flag that will or will not fail to get the required objects. In reality, this could be some complicated function that, depending on parameters or something else, could return <kbd>null</kbd> in some specific cases. The following piece of code shows how the preceding classes should be used in order to be completely protected from failure:</p>
<pre><span>object </span>NoMonadExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"The result is: </span><span>$</span>{<span>compute</span>(<span>Doer</span>()<span>, </span><span>10</span><span>, </span><span>16</span>)}<span>"</span>)<br/>  }<br/><br/>  <span>def </span><span>compute</span>(doer: Doer<span>, </span>left: <span>Int, </span>right: <span>Int</span>): <span>Int </span>=<br/>    <span>if </span>(doer != <span>null</span>) {<br/>      <span>val </span>algorithm = doer.getAlgorithm(<span>false</span>)<br/>      <span>if </span>(algorithm != <span>null</span>) {<br/>        <span>val </span>implementation = algorithm.getImplementation(<span>false</span><span>,<br/></span><span>          </span>left<span>, </span>right)<br/>        <span>if </span>(implementation != <span>null</span>) {<br/>          implementation.compute<br/>        } <span>else </span>{<br/>          -<span>1<br/></span><span>        </span>}<br/>      } <span>else </span>{<br/>        -<span>1<br/></span><span>      </span>}<br/>    } <span>else </span>{<br/>      -<span>1<br/></span><span>    </span>}<br/>}</pre>
<p>The <kbd>compute</kbd> method in the <kbd>NoMonadExample</kbd> object looks really bad and hard to read. We shouldn't write code like that.</p>
<p>Looking at what's happening in the preceding code, we can see that we are actually trying to build a chain of operations, which can individually fail. Monads can help us and abstract this protective logic. Now, let's show a much better solution.</p>
<p>First of all, let's define our own <kbd>Option</kbd> monad:</p>
<pre><span>sealed trait </span>Option[<span>A</span>] <span>extends </span>Monad[<span>A</span>]<br/><br/><span>case class </span>Some[<span>A</span>](a: <span>A</span>) <span>extends </span>Option[<span>A</span>] {<br/>  <span>override def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): Monad[<span>Y</span>] = <span>Some</span>(value)<br/><br/>  <span>override def </span><span>flatMap</span>[<span>Y</span>](f: (<span>A</span>) =&gt; Monad[<span>Y</span>]): Monad[<span>Y</span>] = f(a)<br/>}<br/><br/><span>case class </span>None[<span>A</span>]() <span>extends </span>Option[<span>A</span>] {<br/>  <span>override def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): Monad[<span>Y</span>] = <span>None</span>()<br/><br/>  <span>override def </span><span>flatMap</span>[<span>Y</span>](f: (<span>A</span>) =&gt; Monad[<span>Y</span>]): Monad[<span>Y</span>] = <span>None</span>()<br/>}</pre>
<p>We have two concrete cases in the preceding code—one where we can get a value and other where the result will be empty. Now, let's rewrite our computation classes so that they use the new monad we just created:</p>
<pre><span>case class </span>Doer_v2() {<br/>  <span>def </span><span>getAlgorithm</span>(isFail: <span>Boolean</span>): Option[Algorithm_v2] =<br/>    <span>if </span>(isFail) {<br/>      <span>None</span>()<br/>    } <span>else </span>{<br/>      <span>Some</span>(<span>Algorithm_v2</span>())<br/>    }<br/>}<br/><br/><span>case class </span>Algorithm_v2() {<br/>  <span>def </span><span>getImplementation</span>(isFail: <span>Boolean, </span>left: <span>Int, </span>right: <span>Int</span>): Option[Implementation] =<br/>    <span>if </span>(isFail) {<br/>      <span>None</span>()<br/>    } <span>else </span>{<br/>      <span>Some</span>(<span>Implementation</span>(left<span>, </span>right))<br/>    }<br/>}</pre>
<p>Finally, we can use them in the following way:</p>
<pre><span>object </span>MonadExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"The result is: </span><span>$</span>{<span>compute</span>(<span>Some</span>(<span>Doer_v2</span>())<span>, </span><span>10</span><span>, </span><span>16</span>)}<span>"</span>)<br/>  }<br/><br/>  <span>def </span><span>compute</span>(doer: Option[Doer_v2]<span>, </span>left: <span>Int, </span>right: <span>Int</span>) =<br/>    <span>for </span>{<br/>      d &lt;- doer<br/>      a &lt;- d.getAlgorithm(<span>false</span>)<br/>      i &lt;- a.getImplementation(<span>false</span><span>, </span>left<span>, </span>right)<br/>    } <span>yield </span>i.compute<br/><br/>  <span>// OR THIS WAY:<br/></span><span>  //  doer.flatMap {<br/></span><span>  //    d =&gt;<br/></span><span>  //      d.getAlgorithm(false).flatMap {<br/></span><span>  //        a =&gt;<br/></span><span>  //          a.getImplementation(false, left, right).map {<br/></span><span>  //            i =&gt; i.compute<br/></span><span>  //          }<br/></span><span>  //      }<br/></span><span>  //  }<br/></span>}</pre>
<p>In the preceding code, we've shown a <em>for comprehension</em> usage of our monad, but the part that is commented out is also valid. The first one is preferred because it makes things look really simple, and some completely different computations end up looking the same, which is good for understanding and changing code.</p>
<p>Of course, everything we showed in our example can be implemented using the standard Scala <kbd>Option</kbd>. It is almost certain that you have already seen and used this class before, which means that you have actually used monads before, maybe without realizing this was the case.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A more advanced monad example</h1>
                </header>
            
            <article>
                
<p>The previous example was pretty simple, and it showed a great use of monads. We made our code much more straightforward, and we abstracted some logic inside the monads. Also, our code became much more readable than it was before.</p>
<p>In this subsection, let's see another use of monads, which is much more advanced this time. All the software we write becomes much more challenging and interesting whenever we add I/O to it. This can be reading and writing data to and from files, communicating with a user, making web requests, and so on. Monads can be used in order to write I/O applications in a purely functional way. There is a really important feature here: I/O has to deal with side effects, operations are usually performed in a sequence, and the result depends on a state. This state can be anything—if we ask the user what cars they like, the response would vary depending on the user, and if we ask them what they ate for breakfast, or what the weather is like, the responses to these question will also depend on the user. Even if we try and read the same file twice, there might be differences—we might fail, the file could be changed, and so on. Everything we have described so far is a state. Monads help us hide this state from the user and just expose the important parts as well as abstract the way we deal with errors, and so on.</p>
<p>There are a few important aspects about the state we will be using:</p>
<ul>
<li>The state changes between different I/O operations</li>
<li>The state is only one and we can't just create a new one whenever we want</li>
<li>At any moment in time, there can be only one state</li>
</ul>
<p>All of the previous statements are quite logical, but they will actually guide the way we implement our state and our monads.</p>
<p>We will write an example, which will read the lines from a file and then go through them and write them in a new file with all the letters capitalized. This can be written in a really easy and straightforward way with Scala, but as soon as some of the operations become more complex or we try to handle errors properly, it can become pretty difficult.</p>
<p>Throughout the example, we will try to show what steps we have taken in order to make sure the previous statements about our state are correct.</p>
<div class="packt_tip">The  following example we will show doesn't really need to use state. It just performs a file read and write in a monadic manner. The reader should have enough knowledge by now to take the state out of the code, if needed.<br/>
<br/>
We've decided to show a very simple usage of state, where we just increment a number. This can give the reader an idea of how a state can be used and wired up in applications that might actually need it. Additionally, the use of state can actually modify the behavior of our program and trigger different actions depending on it—for example, a vending machine and a user trying to request something that is out of stock.</div>
<p>Let's start with the state. For the current example, we don't really need a special state, but we have used one anyway. It is just to show how to handle cases when one is actually needed:</p>
<pre><span>sealed trait </span>State {<br/>  <span>def </span><span>next</span>: State<br/>}</pre>
<p>The preceding trait has a <kbd>next</kbd> method, which will return the next state when we move between different operations. Just by calling it when we pass a state, we make sure that different operations cause a change in state.</p>
<p>We need to make sure that our application has only one state and that nobody can create a state whenever they want. The fact that the trait is sealed helps us to make sure nobody can extend our state outside the file, where we have defined it. Being sealed is not enough, though. We need to make sure all the implementations of the state are hidden:</p>
<pre><span>abstract class </span>FileIO {<br/><br/>  <span>// this makes sure nobody can create a state<br/></span><span>  </span><span>private class </span>FileIOState(id: <span>Int</span>) <span>extends </span>State {<br/>    <span>override def </span><span>next</span>: State = <span>new </span>FileIOState(id + <span>1</span>)<br/>  }<br/><br/>  <span>def </span><span>run</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>action = runIO(args(<span>0</span>)<span>, </span>args(<span>1</span>))<br/>    action(<span>new </span>FileIOState(<span>0</span>))<br/>  }<br/><br/>  <span>def </span><span>runIO</span>(readPath: <span>String</span><span>, </span>writePath: <span>String</span>): IOAction[_]<br/>}</pre>
<p>The preceding code defines the state as a private class, and this means that nobody else will be able to create one. Let's ignore the other methods for now, as we will come back to them later.</p>
<p>The third rule we defined for our state earlier is much trickier to achieve. We have taken multiple steps in order to make sure the state behaves correctly. First of all, as can be seen from the previous listing, there is no clue of a state that the user can get to, except the private class that nobody can instantiate. Instead of loading the user with the burden of executing a task and passing a state, we only expose an <kbd>IOAction</kbd> to them, which is defined as follows:</p>
<pre><span>sealed abstract class </span>IOAction[<span>T</span>] <span>extends </span>((State) =&gt; (State<span>, </span><span>T</span>)) {<br/>  <span>// START: we don't have to extend. We could also do this...<br/></span><span>  </span><span>def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): IOAction[<span>Y</span>] = IOAction(value)<br/><br/>  <span>def </span><span>flatMap</span>[<span>Y</span>](f: (<span>T</span>) =&gt; IOAction[<span>Y</span>]): IOAction[<span>Y</span>] = {<br/>    <span>val </span>self = <span>this<br/></span><span>    new </span>IOAction[<span>Y</span>] {<br/>      <span>override def </span><span>apply</span>(state: State): (State<span>, </span><span>Y</span>) = {<br/>        <span>val </span>(state2<span>, </span>res) = self(state)<br/>        <span>val </span>action2 = f(res)<br/>        action2(state2)<br/>      }<br/><br/>    }<br/>  }<br/><br/>  <span>def </span><span>map</span>[<span>Y</span>](f: <span>T </span>=&gt; <span>Y</span>): IOAction[<span>Y</span>] =<br/>    flatMap(i =&gt; unit(f(i)))<br/><br/>  <span>// END: we don't have to extend. We could also do this...<br/></span>}</pre>
<p>First, let's focus only on the <kbd>IOAction</kbd> signature. It extends a function from an old state to a tuple of the new state and the result of the operation. So, it turns out that we are still exposing the state to our users in a way—it is just in the form of a class. However, we already saw that it is pretty straightforward to hide a state by creating a private class that nobody can instantiate. Our users will be working with the <kbd>IOAction</kbd> class, so we need to make sure they don't have to deal with states themselves. We have already defined the <kbd>IOAction</kbd> to be sealed. Additionally, we can create a factory object, which will help us create new instances:</p>
<pre><span>object </span>IOAction {<br/>  <span>def </span><span>apply</span>[<span>T</span>](result: =&gt; <span>T</span>): IOAction[<span>T</span>] =<br/>    <span>new </span>SimpleAction[<span>T</span>](result)<br/><br/>  <span>private class </span>SimpleAction[<span>T</span>](result: =&gt; <span>T</span>) <span>extends </span>IOAction[<span>T</span>] {<br/>    <span>override def </span><span>apply</span>(state: State): (State<span>, </span><span>T</span>) =<br/>      (state.next<span>, </span>result)<br/>  }<br/><br/>}</pre>
<p>The preceding code is quite important in terms of how things will get wired up later. First of all, we have a private implementation of <kbd>IOAction</kbd>. It only takes a by-name parameter, which means that it will only be evaluated when the <kbd>apply</kbd> method is called—this is really important. Moreover, in the preceding code, we have an <kbd>apply</kbd> method for the <kbd>IOAction</kbd> object, which allows the users to instantiate actions. Again, here the value is passed by name.</p>
<p>The preceding code, basically, enables us to define actions and only execute them whenever we have a state available.</p>
<p>If we now have a think, you can see that we've managed to satisfy all three requirements for our state. Indeed, by hiding the state behind a class, whose instance creations are controlled by us, we have managed to protect the state so that we don't have more than one at the same time.</p>
<p>Now that we have everything in place, we can make sure our <kbd>IOAction</kbd> is a monad. It will need to satisfy the monad laws and define the required methods. We've already shown them, but let's have a closer look at the methods again:</p>
<pre><span>// START: we don't have to extend. We could also do this...</span><span><br/></span><span>def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): IOAction[<span>Y</span>] = <span>IOAction</span>(value)<br/><br/><span>def </span><span>flatMap</span>[<span>Y</span>](f: (<span>T</span>) =&gt; IOAction[<span>Y</span>]): IOAction[<span>Y</span>] = {<br/>  <span>val </span>self = <span>this</span><span><br/></span><span>  new </span>IOAction[<span>Y</span>] {<br/>    <span>override def </span><span>apply</span>(state: State): (State<span>, </span><span>Y</span>) = {<br/>      <span>val </span>(state2<span>, </span>res) = self(state)<br/>      <span>val </span>action2 = f(res)<br/>      action2(state2)<br/>    }<br/><br/>  }<br/>}<br/><br/><span>def </span><span>map</span>[<span>Y</span>](f: <span>T </span>=&gt; <span>Y</span>): IOAction[<span>Y</span>] =<br/>  flatMap(i =&gt; unit(f(i)))<br/><br/><span>// END: we don't have to extend. We could also do this...</span></pre>
<p>We haven't specifically extended our <kbd>Monad</kbd> trait, but instead we have just defined the methods here. We already know that <kbd>map</kbd> can be defined using <kbd>flatMap</kbd> and <kbd>unit</kbd>. For the latter, we have used the factory method for the <kbd>SimpleAction</kbd>. Our implementation of the former is quite interesting—it performs the current operation first and then sequentially after that, based on the resulting state, the second operation. This allows us to chain multiple I/O operations together.</p>
<p>Let's look at our <kbd>IOAction</kbd> class again. Does it satisfy the monad rules? The answer is no, but there is a really easy fix. The problem is that our <kbd>unit</kbd> method, if we look into it, would change the state because it uses a <kbd>SimpleAction</kbd>. But it shouldn't. What we have to do is create another <kbd>IOAction</kbd> implementation that doesn't change the state, and we use it for <kbd>unit</kbd>:</p>
<pre><span>private class </span>EmptyAction[<span>T</span>](value: <span>T</span>) <span>extends </span>IOAction[<span>T</span>] {<br/>  <span>override def </span><span>apply</span>(state: State): (State<span>, </span><span>T</span>) =<br/>    (state<span>, </span>value)<br/>}</pre>
<p>Then, our <kbd>IOAction</kbd> object will get an extra function:</p>
<pre><span>def </span><span>unit</span>[<span>T</span>](value: <span>T</span>): IOAction[<span>T</span>] = <span>new </span>EmptyAction[<span>T</span>](value)</pre>
<p>We will also have to change the unit method in the <kbd>IOAction</kbd> abstract class:</p>
<pre><span>def </span><span>unit</span>[<span>Y</span>](value: <span>Y</span>): IOAction[<span>Y</span>] = IOAction.<span>unit</span>(value)</pre>
<p>So far, we have defined our monad, made sure the state is handled properly, and that the actions can be created by a user in a controlled manner. What we need to do now is just add some useful methods and try them out:</p>
<pre><span>package object </span>io {<br/>  <span>def </span><span>readFile</span>(path: <span>String</span>) =<br/>    <span>IOAction</span>(Source.<span>fromFile</span>(path).getLines())<br/><br/>  <span>def </span><span>writeFile</span>(path: <span>String</span><span>, </span>lines: <span>Iterator</span>[<span>String</span>]) =<br/>    <span>IOAction</span>({<br/>      <span>val </span>file = <span>new </span>File(path)<br/>      <span>printToFile</span>(file) { p =&gt; lines.foreach(p.println) }<br/>    })<br/><br/>  <span>private def </span><span>printToFile</span>(file: File)(writeOp: PrintWriter =&gt; <span>Unit</span>): <span>Unit </span>= {<br/>    <span>val </span>writer = <span>new </span>PrintWriter(file)<br/>    <span>try </span>{<br/>      writeOp(writer)<br/>    } <span>finally </span>{<br/>      writer.close()<br/>    }<br/>  }<br/>}</pre>
<p>The preceding is the code of a package object that reads and writes files and returns instances of <kbd>IOAction</kbd> (in the current case, <kbd>SimpleAction</kbd> is created using the <kbd>IOAction</kbd> <kbd>apply</kbd> method). Now that we have these methods and our monad, we can use the framework we have defined and wire everything up:</p>
<pre><span>abstract class </span>FileIO {<br/><br/>  <span>// this makes sure nobody can create a state<br/></span><span>  </span><span>private class </span>FileIOState(id: <span>Int</span>) <span>extends </span>State {<br/>    <span>override def </span><span>next</span>: State = <span>new </span>FileIOState(id + <span>1</span>)<br/>  }<br/><br/>  <span>def </span><span>run</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <strong>val action = runIO(args(0), args(1))</strong><br/>    action(<span>new </span>FileIOState(<span>0</span>))<br/>  }<br/><br/>  <span>def </span><span>runIO</span>(readPath: <span>String</span><span>, </span>writePath: <span>String</span>): IOAction[_]<br/>}</pre>
<p>The preceding code defines a framework that the users of our library will follow; they will have to extend <kbd>FileIO</kbd>, implement <kbd>runIO</kbd>, and call the <kbd>run</kbd> method whenever they are ready to use our application. By now, you should be familiar enough with monads and see that the only thing the highlighted code will do is <em>build a computation</em>. It can be thought of as a graph of operations that have to be performed. It will not execute anything until the next line, where it actually gets the state passed to it:</p>
<pre><span>object </span>FileIOExample <span>extends </span>FileIO {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    run(args)<br/>  }<br/><br/>  <span>override def </span><span>runIO</span>(readPath: <span>String</span><span>, </span>writePath: <span>String</span>): IOAction[_] =<br/>    <span>for </span>{<br/>      lines &lt;- readFile(readPath)<br/>      _ &lt;- writeFile(writePath<span>, </span>lines.map(_.toUpperCase))<br/>    } <span>yield </span>()<br/>}</pre>
<p>The preceding code shows an example usage of the <kbd>FileIO</kbd> library that we created. We can now run it with the following input file:</p>
<pre><span>this </span>is a file<span>, </span>which<br/>will be completely capitalized<br/>in a monadic way.<br/><br/>Enjoy!</pre>
<p>The command that we need to use is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/76ddb10f-b600-4719-b4a2-3942a6fbf7f2.png" width="721" height="54"/></div>
<p>As expected, the output file will contain the same text with all uppercase letters. You can, of course, try with different inputs and see how the code performs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monad intuition</h1>
                </header>
            
            <article>
                
<p>In this section, we went through some theory and real-world examples with monads. Hopefully, we have managed to give an easy to understand explanation of what is what, and how and why it works. Monads are not as scary as they initially seem to be and some time spent with them would give an even better understanding of how and why things work in a certain way.</p>
<div class="packt_infobox">The last example could seem pretty complicated, but some extra time spent with it using an IDE will make it clear and easy for you to realize how exactly everything gets wired up. Then, you will be able to easily spot and use monads on your own.</div>
<p>Of course, a developer can probably get away without monads, but using them can help with hiding details about exception handling, specific operations, and so on. Monads are actually good because of the extra work that happens inside them, and they can be used to implement some of the design patterns we saw earlier in this book. We can implement better states, rollbacks, and many, many more. It is also worth mentioning that it is likely that many times we use monads without even realizing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter was dedicated to some of the functional programming theories that seem to put many people off pure functional programming. Because the majority of explanations require a strong mathematical background, we see people avoiding the concepts covered in this chapter.</p>
<p>We talked about monoids, monads, and functors, and we showed some examples of how to use them and the difference between having and not having them. It turns out that we use these concepts more often than we think, but we just don't realize it.</p>
<p>We saw that monoids, functors, and monads can be used for a variety of purposes—performance optimization, abstraction, and removal of code duplication. Properly understanding these concepts and feeling comfortable with them might take some time initially, but after some practice, developers tend to get a much better understanding and use them much more often than before. Hopefully, this chapter has made monoids, monads, and functors look much simpler than you may have thought and you will make them a part of the production code more often.</p>
<p>In the next chapter, we will cover some functional programming design patterns that are specific to Scala, due to its expressiveness. Some of them will be new and previously unseen, while others we have already met, but we will look at  from a different perspective.</p>


            </article>

            
        </section>
    </div>



  </body></html>