<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Writing Play Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Writing Play Plugins</h1></div></div></div><p>In order to make our applications manageable, we break them down into independent modules. These modules can also be extracted into individual projects/libraries.</p><p>A Play plugin is nothing but another module with an additional ability—of binding tasks before starting, on starting and/or stopping a Play application. In this chapter, we will see how to write custom plugins.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Plugin definition</li><li class="listitem" style="list-style-type: disc">Plugin declaration</li><li class="listitem" style="list-style-type: disc">Exposing services through plugins</li><li class="listitem" style="list-style-type: disc">Tips for writing a plugin</li></ul></div><div class="section" title="Plugin definition"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec82"/>Plugin definition</h1></div></div></div><p>A Play plugin can be <a id="id465" class="indexterm"/>defined by extending <code class="literal">play.api.plugin</code>, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">trait Plugin {

  //Called when the application starts.
  def onStart() {}

  // Called when the application stops.
  def onStop() {}

  // Is the plugin enabled?
  def enabled: Boolean = true
}</pre></div><p>Now, we might be in a situation where we need to send an e-mail when an application is started or stopped so that the administrator can later use this time interval to monitor the application's performance and check why it stopped. We could define a plugin to do this for us:</p><div class="informalexample"><pre class="programlisting">class NotifierPlugin(app:Application) extends Plugin{ 

  private def notify(adminId:String,status:String):Unit = { 

    val time = new Date() 

    val msg = s"The app has been $status at $time" 

    //send email to admin with the msg

    log.info(msg)

  } 



  override def onStart() { 

    val emailId = app.configuration.getString("notify.admin.id").get 

    notify(emailId,"started") 

  } 



  override def onStop() {     

    val emailId = app.configuration.getString("notify.admin.id").get 

    notify(emailId,"stopped") 

  } 



  override def enabled: Boolean = true 

}</pre></div><p>We can also define plugins <a id="id466" class="indexterm"/>that make use of other libraries. We might need to build a plugin that builds a connection pool to <code class="literal">Cassandra</code> (a NoSQL database) on startup and allows users to use this pool later on. To build this plugin, we will use the <code class="literal">cassandra-driver</code> for Java. Our plugin will then be as follows:</p><div class="informalexample"><pre class="programlisting">class CassandraPlugin(app: Application) extends Plugin {

  private var _helper: Option[CassandraConnection] = None

  def helper = _helper.getOrElse(throw new RuntimeException("CassandraPlugin error: CassandraHelper initialization failed"))

  override def onStart() = {

    val appConfig = app.configuration.getConfig("cassandraPlugin").get
    val appName: String = appConfig.getString("appName").getOrElse("appWithCassandraPlugin")

    val hosts: Array[java.lang.String] = appConfig.getString("host").getOrElse("localhost").split(",").map(_.trim)
    val port: Int = appConfig.getInt("port").getOrElse(9042)

    val cluster = Cluster.builder()
      .addContactPoints(hosts: _*)
      .withPort(port).build()

    _helper = try {
      val session = cluster.connect()
      Some(CassandraConnection(hosts, port, cluster, session))
    } catch {
      case e: NoHostAvailableException =&gt;
        val msg =
          s"""Failed to initialize CassandraPlugin.
             |Please check if Cassandra is accessible at
             | ${hosts.head}:$port or update configuration""".stripMargin
        throw app.configuration.globalError(msg)
    }
  }

  override def onStop() = {
    helper.session.close()
    helper.cluster.close()
  }

  override def enabled = true
}</pre></div><p>Here, <code class="literal">CassandraConnection</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">private[plugin] case class CassandraConnection(hosts: Array[java.lang.String],
  port: Int,
  cluster: Cluster,
session: Session)</pre></div><p>The <code class="literal">cassandra-driver</code> <a id="id467" class="indexterm"/>node is declared as a library dependency and its classes are imported where they're required.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>The dependency on Play in the <code class="literal">build</code> definition of the plugin should be marked as provided, since the application using the plugin will already have a dependency on Play, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>libraryDependencies ++= Seq(</strong></span>
<span class="strong"><strong>  "com.datastax.cassandra" % "cassandra-driver-core" % "2.0.4",</strong></span>
<span class="strong"><strong>  "com.typesafe.play" %% "play" % "2.3.0" % "provided" )</strong></span>
</pre></div></div></div></div></div>
<div class="section" title="Plugin declaration"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec83"/>Plugin declaration</h1></div></div></div><p>Now that we have <a id="id468" class="indexterm"/>defined a plugin, let's see how the Play Framework identifies and enables it for the application. <code class="literal">ApplicationProvider</code> for the production and development mode (static and reloadable applications, respectively) both rely on <code class="literal">DefaultApplication</code>, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">class DefaultApplication(
  override val path: File,
  override val classloader: ClassLoader,
  override val sources: Option[SourceMapper],
  override val mode: Mode.Mode) extends Application with WithDefaultConfiguration with WithDefaultGlobal with WithDefaultPlugins</pre></div><p>The <code class="literal">trait WithDefaultPlugins</code> line is responsible for binding the plugins to application's life cycle. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">trait WithDefaultPlugins {
  self: Application =&gt;
  private[api] def pluginClasses: Seq[String] = {
    import scala.collection.JavaConverters._
    val PluginDeclaration = """([0-9_]+):(.*)""".r
<span class="strong"><strong>    val pluginFiles = self.classloader.getResources("play.plugins").asScala.toList ++ self.classloader.getResources("conf/play.plugins").asScala.toList</strong></span>

    pluginFiles.distinct.map { plugins =&gt;
      PlayIO.readUrlAsString(plugins).split("\n").map(_.replaceAll("#.*$", "").trim).filterNot(_.isEmpty).map {
        case PluginDeclaration(priority, className) =&gt; (priority.toInt, className)
      }
    }.flatten.sortBy(_._1).map(_._2)

  }
...
}</pre></div><p>So, we should declare our plugin class in a file with the <code class="literal">play.plugins</code> name. All the plugin declarations obtained from one or more <code class="literal">play.plugins</code> files are combined and sorted. Each declared plugin has a priority assigned to it, which is used for sorting. Once sorted, the plugins are loaded in order prior to the application's startup.</p><p>The priorities should be set <a id="id469" class="indexterm"/>based on the dependencies of a plugin. The suggested priorities are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">100</code>: This priority is set when a plugin has no dependencies, such as the messages plugin (used for <code class="literal">i18n</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">200</code>: This priority is set for the plugins that create and manage the DB connection pools</li><li class="listitem" style="list-style-type: disc"><code class="literal">300-500</code>: This priority is set for the plugins that depend on a database, such as JPA, Ebean, and evolutions</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>
<code class="literal">10000</code> is reserved for a global plugin intentionally so that it loads after all the other plugins have been loaded. This allows developers to use other plugins in the global object without additional configuration.</p></div></div><p>The default <code class="literal">play.plugins</code> file just has a basic plugin declaration:</p><div class="informalexample"><pre class="programlisting">1:play.core.system.MigrationHelper
100:play.api.i18n.DefaultMessagesPlugin
1000:play.api.libs.concurrent.AkkaPlugin
10000:play.api.GlobalPlugin</pre></div><p>A few more plugin declarations from the Play modules are as follows:</p><div class="informalexample"><pre class="programlisting">200:play.api.db.BoneCPPlugin
500:play.api.db.evolutions.EvolutionsPlugin
600:play.api.cache.EhCachePlugin
700:play.api.libs.ws.ning.NingWSPlugin</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>Generally, Play plugins need to be specified as library dependencies in the application's <code class="literal">build</code> <a id="id470" class="indexterm"/>definition. Some plugins are bundled with a <code class="literal">play.plugins</code> file. However, for those without it, we will need to set the priority in our application's <code class="literal">conf/play.plugins</code> file.</p></div></div></div>
<div class="section" title="Exposing services through plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec84"/>Exposing services through plugins</h1></div></div></div><p>Some plugins <a id="id471" class="indexterm"/>need to provide users with helper methods to simplify transactions, whereas others need not do anything besides some tasks to be <a id="id472" class="indexterm"/>added in the application's life cycle. For example, our <code class="literal">NotifierPlugin</code> just sends e-mails on start and stop. Then, the methods of our <code class="literal">CassandraPlugin</code> can be accessed using the <code class="literal">plugin</code> method of <code class="literal">play.api.Application</code>:</p><div class="informalexample"><pre class="programlisting">object CassandraHelper {
<span class="strong"><strong>  private val casPlugin = Play.application.plugin[CassandraPlugin].get</strong></span>

  //complete DB transactions with the connection pool started through the plugin
  def executeStmt(stmt:String) = {
    casPlugin.session.execute(stmt)
  }
  
}</pre></div><p>Alternatively, the plugin can also provide a helper object:</p><div class="informalexample"><pre class="programlisting">object Cassandra {
  private val casPlugin = Play.application.plugin[CassandraPlugin].get

  private val cassandraHelper = casPlugin.helper

  /**
   * gets the Cassandra hosts provided in the configuration
   */
  def hosts: Array[java.lang.String] = cassandraHelper.hosts

  /**
    * gets the port number on which Cassandra is running from the configuration
   */
  def port: Int = cassandraHelper.port

  /**
    * gets a reference of the started Cassandra cluster
    * The cluster is built with the configured set of initial contact points
   * and policies at startup
   */
  def cluster: Cluster = cassandraHelper.cluster

  /**
    * gets a reference of the started Cassandra session
    * A new session is created on the cluster at startup
    */
  def session: Session = cassandraHelper.session

  /**
    * executes CQL statements available in given file.
    * Empty lines or lines starting with `#` are ignored.
    * Each statement can extend over multiple lines and must end with a semi-colon.
   * @param fileName - name of the file
   */
  def loadCQLFile(fileName: String): Unit = {
    Util.loadScript(fileName, cassandraHelper.session)
  }

}</pre></div><p>A list of <a id="id473" class="indexterm"/>available modules is maintained at <a id="id474" class="indexterm"/>
<a class="ulink" href="https://www.playframework.com/documentation/2.3.x/Modules">https://www.playframework.com/documentation/2.3.x/Modules</a>.</p></div>
<div class="section" title="Tips for writing a plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec85"/>Tips for writing a plugin</h1></div></div></div><p>Here are some <a id="id475" class="indexterm"/>tips for writing a plugin:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Before you start writing a plugin, check if you really need one to solve your problem. If your problem does not require meddling with the application's life cycle, it's better to write a library.</li><li class="listitem" style="list-style-type: disc">While writing/updating a plugin, simultaneously build an example Play application that uses the plugin. This will allow you to check the functionality of it thoroughly with only the additional overheads of publishing the plugin locally for every change made.</li><li class="listitem" style="list-style-type: disc">If the plugin exposes some services, try to provide a helper object. This makes it easier to maintain the API's consistency and also simplifies the developer experience.<p>For example, most of the plugins provided by Play (such as <code class="literal">akka</code>, <code class="literal">jdbc</code>, <code class="literal">ws</code>, and so on) provide helper objects through which the API is available. Internal changes to the plugin do not affect the public API exposed through these objects.</p></li><li class="listitem" style="list-style-type: disc">If and where possible, try and back up the plugin with sufficient tests.</li><li class="listitem" style="list-style-type: disc">Document the <a id="id476" class="indexterm"/>API and/or special cases. This might come in handy in future for everyone who uses the plugin.</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec86"/>Summary</h1></div></div></div><p>The Play plugins provide us with the flexibility to perform specific tasks at a desired stage in the application's life cycle. Play has some plugins that are commonly required by most applications, such as web services, authentication, and so on. We discussed how the Play plugins work and how we can build custom plugins to meet different requirements.</p></div></body></html>