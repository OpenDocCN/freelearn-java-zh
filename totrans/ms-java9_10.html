<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Fine-Grained Stack Tracing</h1>
                </header>
            
            <article>
                
<p>Java 9 comes with a new stack walker API that lets the program walk the calling stack. This is a very special functionality that is rarely needed by ordinary programs. The API can be useful for some very special cases--for functionality that is delivered by framework. So, if you want an efficient means of stack walking that gives you filterable access to stack trace information, you will enjoy this new stack walker API.</p>
<p>The API gives fast and optimized access to the call stack, implementing lazy access to the individual frames.</p>
<p>In this chapter, we cover the following topics:</p>
<ul>
<li>Overview of the Java Stack</li>
<li>The importance of stack information</li>
<li>Using <kbd>StackWalker</kbd></li>
<li>The <kbd>StackFrame</kbd></li>
<li>Performance</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the Java Stack</h1>
                </header>
            
            <article>
                
<p>Before we dive into the stack walker, let's start by covering the Java Stack. This is basic stack information, not specific to the stack walker.</p>
<p>The Java runtime has a class named Stack, which can be used to store objects using the <strong>last-in-first-out</strong> (<strong>LIFO</strong>) policy.</p>
<p>When arithmetic expressions are calculated they are done using a stack. If we add <em>A</em> and <em>B</em> in our code first <em>A</em> is pushed on the <strong>Operand Stack</strong>, then <em>B</em> is pushed on the Operand Stack and finally the addition operation is executed, which fetches the two topmost elements of the Operand Stack and pushes the result, <em>A</em> + <em>B</em> there.</p>
<p>The JVM is written in C and executes calling C functions and returning from there. This call-return sequence is maintained using the Native Method Stack just like any other C program.</p>
<p>Finally, when the JVM creates a new thread it also allocates a call stack containing frames that in turn contain the local variables, reference to the previous frame, and reference to the class that contains the executing method. When a method is invoked a new frame is created. The frame is destroyed when a method finishes its execution, in other words, returns or throws an exception. This stack, the Java Virtual Machine Stack, is the one that the stack walker API manages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The importance of stack information</h1>
                </header>
            
            <article>
                
<p>Generally speaking we need the stack information when we want to develop caller dependent code. Having information about the caller allows our code to make decisions based on that information. In general practice, it is not a good idea to make functionality dependent on the caller. Information that affects the behavior of a method should be available via parameters. Caller dependent code development should be fairly limited.</p>
<p>The JDK accesses stack information with native methods that are not available to Java applications. The <kbd>SecurityManager</kbd> is a class that defines an application's security policy. This class checks that the caller of a reflection API is allowed to access the non-public members of another class. To do that it has to have access to the caller class and it does that through a protected native method.</p>
<p>This is an example of implementing some security measures without having to walk through a stack. We open our code for external developers to use it as a library. We also call methods of classes provided by the library user and they may call back to our code. There is some code that we want to allow library users to call but only if they were not called from our code. If we did not want to allow some of the code to be accessed directly by the library using code we could use Java 9's modular structure not exporting the package containing the classes not to be invoked. This is the reason we set the extra condition that the code is available for the callers from outside, except if they were called by our code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/27cc0ba9-edab-4795-b504-d73914b599a0.png"/></div>
<p>Another example is when we want to get access to a logger. Java applications use many different loggers and the logging system is usually very flexible so that the output of the different loggers can be switched on and off based on the actual need to introspect into the code. The most common practice is to use a different logger for each class and the name of the logger is usually the name of the class. The practice is so common that the logging framework even provides logger access methods that accept the reference to the class itself instead of the name. It essentially means that the call to get the handle of a logger looks something like the following:</p>
<pre>    private static final Logger LOG = Logger.getLogger(MyClass.class); </pre>
<p>A problem can arise when we create new classes from existing classes if we forget to alter the name of the class name in the call for getting a new logger. This is not a serious problem, but it is common. In that case our code will use the logger of the other class and it will actually work, but may create confusion when we analyze the log files. It would be much nicer if we had a method that returns the logger that is named as the class of the caller.</p>
<p>Let's continue our exploration of stack information in the next two sections with code snippet examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example - Restricting callers</h1>
                </header>
            
            <article>
                
<p>In this section we develop a sample library with two methods. The <kbd>hello()</kbd> method prints <kbd>hello</kbd> to the standard output. The <kbd>callMe()</kbd> method accepts a <kbd>Runnable</kbd> as an argument and runs it. The first method however is restricted. It executes only if the caller is purely outside of the library. It throws an <kbd>IllegalCallerException</kbd> if the caller obtained the control in a way that the library was calling out, presumably via the second method invoking the passed <kbd>Runnable</kbd>. The implementation of the API is simple:</p>
<pre>    package packt.java9.deep.stackwalker.myrestrictivelibrary; 
    public class RestrictedAPI { 
      public void hello(){ 
        CheckEligibility.itIsNotCallBack(); 
        System.out.println("hello"); 
      } 
      public void callMe(Runnable cb){ 
        cb.run(); 
      } 
    } </pre>
<p>The code that performs the eligibility checking is implemented in a separate class to keep things simple. We will examine that code shortly, but before that we look at the main code we use to start the demonstration. The main program code we use to demonstrate the functionality is the following:</p>
<pre>    package packt.java9.deep.stackwalker.externalcode; 
 
    import<br/>     packt.java9.deep.stackwalker.myrestrictivelibrary.RestrictedAPI; 
 
    public class DirectCall { 
 
      public static void main(String[] args) { 
        RestrictedAPI api = new RestrictedAPI(); 
        api.hello(); 
        api.callMe(() -&gt; { 
            api.hello(); 
        }); 
      } 
    } </pre>
<p>This code creates an instance of our API class and then directly invokes the <kbd>hello()</kbd> method. It should work and should print the characters <kbd>hello</kbd> on screen. The next code line asks the <kbd>callMe()</kbd> method to call back the <kbd>Runnable</kbd> provided in form of a lambda expression. In this case the call will fail, because the caller is outside but was called from inside the library.</p>
<p>Let's now look at how the eligibility check is implemented:</p>
<pre>    package packt.java9.deep.stackwalker.myrestrictivelibrary; 
 
    import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE; 
 
    public class CheckEligibility { 
      private static final String packageName 
        = CheckEligibility.class.getPackageName(); 
 
      private static boolean notInLibrary(StackWalker.StackFrame f) { 
        return !inLibrary(f); 
      } 
 
      private static boolean inLibrary(StackWalker.StackFrame f) { 
        return f.getDeclaringClass().getPackageName() 
         .equals(packageName); 
      } 
 
      public static void itIsNotCallBack() { 
        boolean eligible = StackWalker 
         .getInstance(RETAIN_CLASS_REFERENCE) 
         .walk(s -&gt; s.dropWhile(CheckEligibility::inLibrary) 
           .dropWhile(CheckEligibility::notInLibrary) 
           .count() == 0 
         ); 
         if (!eligible) { 
           throw new IllegalCallerException(); 
         } 
      } 
    } </pre>
<p>The <kbd>itIsNotCallBack()</kbd> method is the one called from the <kbd>hello()</kbd> method. This method creates a stack walker and invokes the <kbd>walk()</kbd> method. The argument of the <kbd>walk()</kbd> method is a <kbd>Function</kbd> that converts a <kbd>Stream</kbd> of <kbd>StackFrame</kbd> objects to some other value that the <kbd>walk()</kbd> method will return.</p>
<p>At first this argument setting might seem complex and difficult to understand. It would be more logical to return a <kbd>Stream</kbd> that provides the <kbd>StackFrame</kbd> objects instead of forcing the caller to define a <kbd>Function</kbd> that will get this as an argument.</p>
<p>The sample code uses a lambda expression to define the <kbd>Function</kbd> as an argument to the <kbd>walk()</kbd> method. The argument to the lambda expression <kbd>s</kbd> is the stream. Since the first element of this stream is the actual call we drop it. Because these calls should also be refused if the caller is not eligible even though the call to method <kbd>hello()</kbd> was through some other class and method that is already inside the library, we drop all elements from the frame that belong to classes inside the package of the class <kbd>CheckEligibility</kbd>. This package is <kbd>packt.java9.deep.stackwalker.myrestrictivelibrary</kbd> and in the code this string is stored in the field <kbd>packageName</kbd>. The resulting stream contains only the <kbd>StackFrame</kbd> objects that are from outside of the library. We drop these also until the stream exhausts or until we find a <kbd>StackFrame</kbd> that again belongs to the library. If all elements were dropped we are good. In this case the result of <kbd>count()</kbd> is zero. If we find some class in the <kbd>StackFrame</kbd> that belongs to the library it means that the outside code was called from the library and in this case we have to refuse working. In this case the variable eligible will be <kbd>false</kbd> and we throw an exception, as can be seen in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/33ee8105-e133-4af2-a10e-ea2ae43cf043.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example - Getting logger for caller</h1>
                </header>
            
            <article>
                
<p>To get a logger, Java 9 has a new API. Using this API a module can provide an implementation for the service <kbd>LoggerFinder</kbd>, which in turn can return a <kbd>Logger</kbd> implementing the <kbd>getLogger()</kbd> method. This eliminates the dependency of libraries on specific loggers or logger facades, which is a huge advantage. The smaller but still annoying issue requiring us to write the name of the class again as the parameter to the method <kbd>getLogger()</kbd> is still there.</p>
<p>To avoid this cumbersome task, we create a helper class that looks up the caller class and retrieves the logger that is suitable for the caller class and module. Because in this case there is no need for all the classes referenced in the stack trace we will call the <kbd>getCallerClass()</kbd> method of the <kbd>StackWalker</kbd> class. We create a class named <kbd>Labrador</kbd> in the package <kbd>packt.java9.deep.stackwalker.logretriever</kbd>:</p>
<pre>    package packt.java9.deep.stackwalker.logretriever; 
 
    import java.lang.System.Logger; 
    import java.lang.System.LoggerFinder; 
 
    import static java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE; 
 
    public class Labrador { 
      public static Logger retrieve() { 
        final Class clazz = StackWalker 
          .getInstance(RETAIN_CLASS_REFERENCE) 
          .getCallerClass(); 
        return LoggerFinder.getLoggerFinder().getLogger( 
          clazz.getCanonicalName(), clazz.getModule()); 
      } 
    } </pre>
<p>Before Java 9 the solution for this issue was getting the <kbd>StackTrace</kbd> array from the <kbd>Thread</kbd> class and looking up the name of the caller class from there. Another approach was extending the <kbd>SecurityManager</kbd> that has a protected method <kbd>getClassContext()</kbd> that returns an array of all the classes on the stack. Both solutions walk through the stack and compose an array although we only need one element from the array. In case of logger retrieval it may not be a significant performance penalty since loggers are usually stored in <kbd>private static final</kbd> fields and thus are initialized once per class during class initialization. In other use cases the performance penalty may be significant.</p>
<p>After we have seen two examples we will look at the details of <kbd>StackWalker</kbd> inner working.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with StackWalker</h1>
                </header>
            
            <article>
                
<p>In this section you will become more familiar with how to work with <kbd>StackWalker</kbd>. We will explore the following topics in this section:</p>
<ul>
<li>Getting an instance of <kbd>StackWalker</kbd></li>
<li>Stack walking options</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting an instance of StackWalker</h1>
                </header>
            
            <article>
                
<p>To perform the walking over the stack elements we need an instance of the stack walker. To do that, we invoke the <kbd>getInstance()</kbd> method. As shown here, there are four overloaded versions of this method:</p>
<ul>
<li><kbd>static StackWalker getInstance()</kbd></li>
<li><kbd>static StackWalker getInstance(StackWalker.Option option)</kbd></li>
<li><kbd>static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options)</kbd></li>
<li><kbd>static StackWalker getInstance(Set&lt;StackWalker.Option&gt; options, int estimateDepth)</kbd></li>
</ul>
<p>The first version does not take any arguments and returns a <kbd>StackWalker</kbd> instance that will let us walk through normal stack frames. This is usually what we would be interested in. The other versions of the method accept a <kbd>StackWalker.Option</kbd> value or values. The enum <kbd>StackWalker.Option,</kbd> as the name suggests, is inside the class <kbd>StackWalker</kbd> and has three values:</p>
<ul>
<li><kbd>RETAIN_CLASS_REFERENCE</kbd></li>
<li><kbd>SHOW_REFLECT_FRAMES</kbd></li>
<li><kbd>SHOW_HIDDEN_FRAMES</kbd></li>
</ul>
<p>These <kbd>enum</kbd> options have self-descriptive names and are explained in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RETAIN_CLASS_REFERENCE</h1>
                </header>
            
            <article>
                
<p>If we specify the first option <kbd>enum</kbd> constant, <kbd>RETAIN_CLASS_REFERENCE,</kbd> as an argument to the <kbd>getInstance()</kbd> method then the returned instance grants us access to the classes that the individual stack frames reference during the walking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SHOW_REFLECT_FRAMES</h1>
                </header>
            
            <article>
                
<p>The <kbd>SHOW_REFLECT_FRAMES enum</kbd> constant will generate a walker that includes the frames that source from some reflective calling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SHOW_HIDDEN_FRAMES</h1>
                </header>
            
            <article>
                
<p>Finally the <kbd>enum</kbd> constant option, <kbd>SHOW_HIDDEN_FRAMES</kbd> will include all the hidden frames, which contain reflective calls as well as call frames that are generated for lambda function calls.</p>
<p>Here is a simple demonstration of reflective and hidden frames:</p>
<pre>    package packt; 
    import static java.lang.StackWalker.Option.SHOW_HIDDEN_FRAMES; 
    import static java.lang.StackWalker.Option.SHOW_REFLECT_FRAMES; 
    public class Main { </pre>
<p>The main method allowing us to execute this code directly calls the method <kbd>simpleCall()</kbd>:</p>
<pre>    public static void main(String[] args) { 
      simpleCall(); 
    } </pre>
<p>The method <kbd>simpleCall()</kbd> simply calls on as the name suggests:</p>
<pre>    static void simpleCall() { 
      reflectCall(); 
    } </pre>
<p>The next method in the chain is a bit more complex. Although this also only calls the next one, it does so using reflection:</p>
<pre>    static void reflectCall() { 
      try { 
        Main.class.getDeclaredMethod("lambdaCall", 
          new Class[0]) 
           .invoke(null, new Object[0]); 
      } catch (Exception e) { 
          throw new RuntimeException(); 
      } 
    } </pre>
<p>In this next example, we have a method that calls using a lambda:</p>
<pre>    static void lambdaCall() { 
      Runnable r = () -&gt; { 
        walk(); 
      }; 
      r.run(); 
    } </pre>
<p>The last method before the actual walking is called <kbd>walk()</kbd>:</p>
<pre>    static void walk() { 
      noOptions(); 
      System.out.println(); 
      reflect(); 
      System.out.println(); 
      hidden(); 
    } </pre>
<p>The preceding <kbd>walk()</kbd> method calls three methods, one after the other. These methods are very similar to each other and provided here:</p>
<pre>    static void noOptions() { 
      StackWalker 
        .getInstance() 
        .forEach(System.out::println); 
    } 
 
    static void reflect() { 
      StackWalker 
        .getInstance(SHOW_REFLECT_FRAMES) 
        .forEach(System.out::println); 
    } 
 
    static void hidden() { 
      StackWalker 
        // shows also reflect frames 
        .getInstance(SHOW_HIDDEN_FRAMES) 
        .forEach(System.out::println); 
    } </pre>
<p>The preceding three methods print out the frames to the standard output. They use the <kbd>forEach()</kbd> method of the stack walker. Here is the output of the stack walking program:</p>
<pre><strong>stackwalker/packt.Main.noOptions(Main.java:45) 
stackwalker/packt.Main.walk(Main.java:34) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8)</strong> </pre>
<p>This output only contains the frames that belong to calls that are in our code. The <kbd>main()</kbd> method calls <kbd>simpleCall()</kbd>, which calls <kbd>reflectCall()</kbd>, that in turn calls <kbd>lambdaCall()</kbd>, which calls a lambda expression, that calls <kbd>walk()</kbd> and so on. The fact that we did not specify any option does not delete the lambda call from the stack. We performed that call, thus it must be there. What it deletes are the extra stack frames that are needed by the JVM to implement the lambda. We can see on the next output, when the option was <kbd>SHOW_REFLECT_FRAMES,</kbd> that the reflective frames are already there:</p>
<pre><strong>stackwalker/packt.Main.reflect(Main.java:58) 
stackwalker/packt.Main.walk(Main.java:36) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
java.base/java.lang.reflect.Method.invoke(Method.java:547) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8)</strong> </pre>
<p>In this case the difference is that we can see that the call from the <kbd>reflectCall()</kbd> method to <kbd>lambdaCall()</kbd> method is not direct. The <kbd>reflectCall()</kbd> method calls the <kbd>invoke()</kbd> method that calls another method of the same name defined in a different class that in turn calls the <kbd>invoke0()</kbd> method, which is a native method provided by the JVM. After that we finally get to the <kbd>lambdaCall()</kbd> method.</p>
<p>In the output we can also see that these reflective calls belong to the module <kbd>java.base</kbd> and not our <kbd>stackwalker</kbd> module.</p>
<p>If we include the hidden frames in addition to the reflective frames, specifying the option <kbd>SHOW_HIDDEN_FRAMES</kbd>, then we will see the following output:</p>
<pre><strong>stackwalker/packt.Main.hidden(Main.java:52) 
stackwalker/packt.Main.walk(Main.java:38) 
stackwalker/packt.Main.lambda$lambdaCall$0(Main.java:28) 
stackwalker/packt.Main$$Lambda$46/269468037.run(Unknown Source) 
stackwalker/packt.Main.lambdaCall(Main.java:30) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
java.base/java.lang.reflect.Method.invoke(Method.java:547) 
stackwalker/packt.Main.reflectCall(Main.java:19) 
stackwalker/packt.Main.simpleCall(Main.java:12) 
stackwalker/packt.Main.main(Main.java:8) </strong></pre>
<p>This includes an extra hidden frame that the JVM is using to execute the lambda call. In addition, the reflective frames are also included.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final thoughts on enum constants</h1>
                </header>
            
            <article>
                
<p>We can also specify more than one option giving a set of the options. The simplest way of doing that is to use the static <kbd>of()</kbd> method of the <kbd>java.util.Set</kbd> interface. This way the <kbd>RETAIN_CLASS_REFERENCE</kbd> option can be combined with either the <kbd>SHOW_REFLECT_FRAMES</kbd> option or the <kbd>SHOW_HIDDEN_FRAMES</kbd> option.</p>
<p>Although it is technically possible to combine <kbd>SHOW_REFLECT_FRAMES</kbd> and <kbd>SHOW_HIDDEN_FRAMES</kbd> as an option set, there is really no advantage in doing that. The latter includes the first, so the combination of the two is exactly same as the second.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing classes</h1>
                </header>
            
            <article>
                
<p>When we want to access the class objects during a stack walk, we have to specify the <kbd>RETAIN_CLASS_REFERENCE</kbd> option. Although the <kbd>StackFrame</kbd> interface defines the <kbd>getClassName()</kbd> method, that could be used to access a class of the name using the <kbd>Class.forName()</kbd> method, doing so would not guarantee that the class the <kbd>StackFrame</kbd> object refers to was loaded by the same class loader as the code calling <kbd>Class.forName()</kbd>. In some special cases, we could end up with two different classes of the same name loaded by two different class loaders.</p>
<p>When the option is not used during the creation of the <kbd>StackWalker</kbd> instance then the methods that otherwise return a class object will throw an <kbd>UnsupportedOperationException</kbd> exception. That way <kbd>getDeclaringClass()</kbd> cannot be used on the <kbd>StackFrame</kbd> and <kbd>getCallerClass()</kbd> on the <kbd>StackWalker</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Walking methods</h1>
                </header>
            
            <article>
                
<p>The <kbd>StackWalker</kbd> defines the <kbd>forEach()</kbd> method that expects a <kbd>Consumer</kbd> (preferably in the form of a lambda expression) that is invoked for each element of the stack trace walking up the stack. The argument to the <kbd>Consumer</kbd> method is a <kbd>StackFrame</kbd> object.</p>
<p>Although a method named <kbd>forEach</kbd> is also defined by the <kbd>Stream</kbd> interface and the method <kbd>walk()</kbd> passes a <kbd>Stream</kbd> object to the <kbd>Function</kbd> it gets as argument, we should not confuse the two. The <kbd>forEach()</kbd> method of <kbd>StackWalker</kbd> is a simpler, and most of the time less effective way to get through all the elements of the stack trace.</p>
<p>It is less effective, in most cases, because it forces the <kbd>StackWalker</kbd> instance to get all the elements of the stack trace so that the <kbd>forEach()</kbd> method can traverse through each element to the end. If we know that we will not traverse through the stack trace to the end we should use the <kbd>walk()</kbd> method that is accessing the stack the lazy way and thus leave more room for performance optimization.</p>
<p>The <kbd>StackWalker</kbd> class has the <kbd>walk()</kbd> method, which is the defining method that makes it a walker. The method accepts a <kbd>Function</kbd> that is called by the <kbd>StackWalker</kbd>. The return value of the <kbd>walk()</kbd> method will be the object returned by the <kbd>Function</kbd>. The argument to the <kbd>Function</kbd> is a <kbd>Stream&lt;StackFrame&gt;</kbd> that delivers the stack frames. The first frame is the one that contains the <kbd>walk()</kbd> method call, the next is the one that was calling method that contains the call to <kbd>walk()</kbd>, and so on.</p>
<p>The <kbd>Function</kbd> can be used to calculate some value based on the <kbd>StackFrame</kbd> objects that come from the stream and decide if a caller is eligible calling our code or not.</p>
<p>You might ponder, after reviewing the <kbd>walk()</kbd> method that needs a <kbd>Function</kbd> that in turn gets a <kbd>Stream&lt;StackFrame&gt;</kbd> as argument, why it is so complicated. We might wish we could get a <kbd>Stream&lt;StackFrame&gt;</kbd> from the <kbd>StackWalter</kbd> instance directly. The simplest approach would be to pass the stream back from the <kbd>Function</kbd>. Consider the following example:</p>
<pre>    // EXAMPLE OF WHAT NOT TO DO!!!! 
    public static void itIsNotCallBack() { 
      Stream&lt;StackWalker.StackFrame&gt; stream = 
        StackWalker 
          .getInstance(RETAIN_CLASS_REFERENCE) 
          .walk(s -&gt; s); 
      boolean eligible = // YOU GET EXCEPTION!!!! 
        stream.dropWhile(CheckEligibility::inLibrary) 
          .dropWhile(CheckEligibility::notInLibrary) 
          .count() == 0; 
      if (!eligible) { 
        throw new IllegalCallerException(); 
      } 
    } </pre>
<p>What we were doing is simply returning the stream directly from the walker call and walking through it afterwards doing the same calculation. Our results are an <kbd>IllegalStateException</kbd> exception instead of the eligibility check.</p>
<p>The reason for that is that the implementation of the <kbd>StackWalker</kbd> is highly optimized. It does not copy the whole stack to provide source information for the stream. It works from the actual, living stack. To do that it has to be sure that the stack is not modified while the stream is in use. This is something very similar to the <kbd>ConcurrentModificationException</kbd> that we might get if we alter a collection while we iterate over it. If we passed the stream up in the call stack and then wanted to get the <kbd>StackFrame</kbd> out of it, the stream would try to get the information from the stack frame that is long gone, since we returned from the method that it belonged to. That way the <kbd>StackWalker</kbd> does not make a snapshot of the whole stack but rather it works from the actual one and it must ensure that the part of the stack it needs does not change. We may call methods from the <kbd>Function</kbd> and that way we can dig deeper in the call chain but we cannot get higher while the stream is in use.</p>
<p>Also do not try to play other tricks, like extending the <kbd>StackWalker</kbd> class. You cannot. It is a <kbd>final</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">StackFrame</h1>
                </header>
            
            <article>
                
<p>In previous sections, we iterated through the <kbd>StackFrame</kbd> elements, and provided sample code snippets, but did not take the time to examine it more closely. <kbd>StackFrame</kbd> is an interface defined inside the <kbd>StackWalker</kbd> class. It defines accessors, and a converter that can be used to convert the information to <kbd>StackTraceElement</kbd>.</p>
<p>The accessors the interface defines are the following:</p>
<ul>
<li><kbd>getClassName()</kbd> will return the binary name of the class of the method represented by the <kbd>StackFrame</kbd>.</li>
<li><kbd>getMethodName()</kbd> will return the name of the method represented by the <kbd>StackFrame</kbd>.</li>
<li><kbd>getDeclaringClass()</kbd> will return the class of the method represented by the <kbd>StackFrame</kbd>. If the <kbd>Option.RETAIN_CLASS_REFERENCE</kbd> was not used during the creation of the <kbd>StackWalker</kbd> instance then the method will throw <kbd>UnsupportedOperationException</kbd>.</li>
<li><kbd>getByteCodeIndex()</kbd> gets the index to the code array containing the execution point of the method represented by the <kbd>StackFrame</kbd>. The use of this value can be helpful during bug hunting when looking at the disassembled Java code that the command line tool <kbd>javap</kbd> can give us. The programmatic use of this value can only be valuable for applications that have direct access to the byte code of the code, java agents or libraries that generate byte code during run-time. The method will return a negative number in case the method is native.</li>
<li><kbd>getFileName()</kbd> returns the name of the source file the method represented by the <kbd>StackFrame</kbd> was defined.</li>
<li><kbd>getLineNumber()</kbd> returns the line number of the source code.</li>
<li><kbd>isNativeMethod()</kbd> returns <kbd>true</kbd> if the method represented by the <kbd>StackFrame</kbd> is native and <kbd>false</kbd> otherwise.</li>
</ul>
<p>The <kbd>StackFrame</kbd> does not provide any means to access the object that the method belongs to. You cannot access the arguments and the local variables of the method represented by the <kbd>StackFrame</kbd> and there is no other way you can accomplish that. This is important. Such access would be too invasive and is not possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance</h1>
                </header>
            
            <article>
                
<p>Our coverage of <kbd>StackWalker</kbd> would not be complete without a look at performance considerations.</p>
<p><kbd>StackWalker</kbd> is highly optimized and does not create huge memory structures that go unused. That is the reason why we have to use that <kbd>Function</kbd> passed to the method <kbd>walker()</kbd> as an argument. This is also the reason why a <kbd>StackTrace</kbd> is not automatically converted to a <kbd>StackTraceElement</kbd> when created. This only happens if we query the method name, the line number of the specific <kbd>StackTraceElement</kbd>. It is important to understand that this conversion takes a significant amount of time and if it was used for some debug purpose in the code it should not be left there.</p>
<p>To make the <kbd>StackWalker</kbd> even faster we can provide an estimate about the number of <kbd>StackFrame</kbd> elements that we will work with in the stream. If we do not provide such an estimate, the current implementation in the JDK will use eight <kbd>StackFrame</kbd> objects pre-allocated and when that is exhausted, the JDK will allocate more. The JDK will allocate the number of elements based on our estimate unless we estimate a value larger than 256. In that case, the JDK will use 256.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to use the <kbd>StackWalker</kbd> and provided example code. Our detailed review of the API included different usage scenarios, options, and information. We explained the API's complexity and shared how and how not to use the class. We closed with some related performance issues that the user has to be aware of.</p>
<p>In our next chapter, we will cover over a dozen Java Enhancement Proposals that were incorporated in the Java 9 platform. The featured changes will cover a wide range of tools and updates to APIs that are aimed at making developing with Java easier and the ability to create optimized Java applications. We will look at the new HTTP client, changes to the Javadoc and Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level JVM compiler interface, support for TIFF images, platform logging, XML catalog support, collections, new platform-specific desktop features, and enhancements to method handling and the depreciation annotation.</p>


            </article>

            
        </section>
    </body></html>