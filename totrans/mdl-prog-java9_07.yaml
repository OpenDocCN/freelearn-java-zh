- en: Introducing Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍服务
- en: 'In this chapter, we''ll learn about yet another exciting new feature in Java
    modularity called **services**. Services offer an additional layer of indirection
    between modules when compared to direct dependencies, and we will see that they add
    extra flexibility to how we can get modules to work with each other. In this chapter,
    you will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java模块化中另一个令人兴奋的新特性，称为**服务**。与直接依赖相比，服务在模块之间提供了额外的间接层，我们将看到它们为我们如何使模块协同工作提供了额外的灵活性。在本章中，你将：
- en: Understand one of the limitations of module dependencies the way we have been
    doing things so far
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们迄今为止所做事情中模块依赖的一个限制
- en: Understand what services are and how they solve this problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务是什么以及它们如何解决这个问题
- en: Learn how to create and expose services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建和公开服务
- en: Learn how to consume services using the `ServiceLoader` API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`ServiceLoader` API消费服务
- en: Before we learn what services are, let's examine and understand the actual problem
    that they were created to solve. It's the problem of tight coupling between modules
    with direct dependencies, at least the way we've been hooking them up so far.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习服务是什么之前，让我们检查并理解它们被创造出来要解决的问题。这是模块之间直接依赖的紧密耦合问题，至少是我们迄今为止连接它们的方式。
- en: The problem of coupling
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耦合问题
- en: The phrase **tight coupling** in programming is referred to situations where
    two entities are so highly dependent on each other that in order to change either
    of their behavior or relationship, it is required to make actual code changes
    to one (or often both) of those entities. The term **loose coupling**, on the
    other hand, refers to the opposite scenario--entities that are not highly dependent.
    In such cases, entities ideally don't even know about each other's existence,
    but can still be made to interact with each other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的短语**紧密耦合**指的是两个实体之间高度依赖的情况，为了改变它们的行为或关系，需要对其中一个（或经常是两个）实体进行实际的代码更改。另一方面，**松散耦合**术语指的是相反的情况——实体之间没有高度依赖。在这种情况下，实体理想上甚至不知道彼此的存在，但仍然可以相互交互。
- en: 'With that in mind, what would you say the coupling of two modules in the Java
    module system could be called? When one module depends on another, are the two
    modules tightly coupled or loosely coupled? The answer is obviously that they
    are tightly coupled. Think of the following facts that apply to module relationships:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你认为Java模块系统中两个模块的耦合可以怎么称呼？当一个模块依赖于另一个模块时，这两个模块是紧密耦合还是松散耦合？答案很明显，它们是紧密耦合的。考虑以下适用于模块关系的事实：
- en: Modules need to explicitly state which other modules they depend on. In that
    sense, each module is *aware of* the existence of other modules it needs.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块需要明确声明它们依赖的其他模块。从这个意义上说，每个模块都*意识到*它需要的其他模块的存在。
- en: Modules are also coupled to and *aware of* the APIs exposed by the dependent
    modules. If module A reads module B and calls an API, it is by using the actual
    Java type that is available in and exported from module B. Thus, module A knows
    the internals of module B, at least as much as the types exported by module B
    and used by module A.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块还与依赖模块公开的API耦合，并且*意识到*这些API的存在。如果模块A读取模块B并调用一个API，它是通过使用模块B中可用并导出的实际Java类型来实现的。因此，模块A知道模块B的内部结构，至少与模块B导出并由模块A使用的类型一样多。
- en: Because of these two factors, it is obvious that this kind of tight coupling
    results in a very *strict* and *rigid* behavior of the modules at runtime. Consider
    the address book viewer application. The set of modules compiled is the exact
    set of modules that is involved in execution at runtime. Once modules are compiled,
    there's no way you can remove one of those modules, replace it with something
    else, and execute them. The modules involved have to be *exactly* the same. Although
    we get an impression of Java 9 modules being building blocks that can be assembled
    into multiple combinations, that advantage only applies to development time. What
    we've seen so far is that once the modules are coded and the dependencies established,
    the result is pretty much a cohesive, unalterable monolith.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个因素，很明显，这种紧密耦合导致模块在运行时表现出非常*严格*和*僵化*的行为。考虑地址簿查看器应用程序。编译的模块集合就是运行时涉及的模块集合。一旦模块被编译，你就无法移除其中的任何一个模块，用其他东西替换它，然后执行它们。涉及的模块必须*完全*相同。尽管我们有一种印象，即Java
    9模块是构建块，可以组装成多种组合，但这种优势仅适用于开发时间。到目前为止，我们所看到的是，一旦模块被编码并且建立了依赖关系，结果就是一个相当紧密、不可更改的单一实体。
- en: Now you might wonder, *Well, isn't that what we want?* The benefits of *reliable
    configuration* require a strict check to make sure the exact modules we intend
    to have are present, don't they? Well, yes, but we could still have runtime flexibility
    without giving up reliable configuration. An analogous example for that is in
    the Java language itself. Even though Java is strictly typed, you can achieve
    powerful runtime flexibility and loose coupling between types by using the concepts
    of polymorphism. The idea is that classes don't directly depend on each other.
    Instead, they depend on abstract classes or interfaces. At runtime, instances
    of those interfaces can be dynamically initialized and used anywhere the interface
    is used. Could we have something similar to this with modules? If so, how would
    it work?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会想，“嗯，这不就是我们想要的吗？”*可靠配置*的好处需要严格的检查以确保我们打算拥有的确切模块都存在，不是吗？嗯，是的，但我们仍然可以在不放弃可靠配置的情况下拥有运行时灵活性。一个类似的情况可以在Java语言本身中找到。尽管Java是严格类型化的，但你可以通过使用多态的概念来实现强大的运行时灵活性和类型之间的松散耦合。想法是类不直接相互依赖。相反，它们依赖于抽象类或接口。在运行时，这些接口的实例可以被动态初始化并在接口被使用的地方使用。我们能否在模块中拥有类似的东西？如果可以，它将如何工作？
- en: Let me give you an example. We have a sorting utility module called `packt.sortutil`
    that has an API to sort lists. We have configured the module to export an interface
    and encapsulate an implementation, but in reality, that distinction is currently
    useless. It has only one implementation, and all that the module can do now is
    bubble sort. What if we wanted to have multiple sorting modules and we let the
    consuming module choose which sorting algorithm to use?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子。我们有一个名为 `packt.sortutil` 的排序实用模块，它有一个用于排序列表的API。我们已经配置了该模块以导出接口并封装实现，但在现实中，这种区分目前是无用的。它只有一个实现，现在该模块能做的只是冒泡排序。如果我们想有多个排序模块，并且让消费模块选择使用哪种排序算法呢？
- en: 'Current:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当前：
- en: '![](img/00063.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: 'What we''d like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的：
- en: '![](img/00064.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: We'd like to be able to use multiple modules providing different implementations
    of sorting in our application. However, thanks to tight coupling, in order for
    a module to use another module, it has to *require* it. This means that the consumer
    `packt.addressbook` module has to declare `requires` on each and every one of
    those different implementation modules it might need, even though, at any time,
    it might possibly be using just one. Wouldn't it be nice if there was a way you
    could define an interface type somewhere and have the *consumer* module depend
    only on that? Then the different *provider* modules with different sorting algorithms
    just provide implementations of the interface that you can plug in at runtime
    without needing explicit dependencies, and with no coupling between the actual
    consumer and the various implementation modules?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望能够在我们的应用程序中使用提供不同排序实现的多个模块。然而，由于紧密耦合，为了一个模块能够使用另一个模块，它必须*要求*它。这意味着消费者`packt.addressbook`模块必须在其可能需要的每个不同实现模块上声明`requires`，即使在任何时候，它可能只使用一个。如果有一种方法可以定义一个接口类型并在运行时仅依赖于该接口，那不是很好吗？然后不同的*提供者*模块提供接口的实现，你可以在运行时插入这些实现，而不需要显式依赖，并且没有实际消费者和各个实现模块之间的耦合？ '
- en: 'The following diagram shows what we''d like. Rather than `packt.addressbook`
    requiring all of the modules that provide the implementation logic, it instead
    requires a single module that somehow acts as an interface, and has some mechanism
    to get the implementations dynamically:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们的期望。而不是让`packt.addressbook`需要所有提供实现逻辑的模块，它需要的是一个充当接口的单个模块，并且具有某种动态获取实现的机制：
- en: '![](img/00065.gif)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.gif)'
- en: By now you must have guessed that anytime I ask the *Wouldn't it be nice ...*
    question, it probably means that such a feature already exists! At least in this
    case, it's true. This is where services come in. The concept of services and the
    Service API together add a whole new layer of indirection on top of the existing
    modularity concepts you've learn so far. Let's dive into the details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经猜到，每当我问“*不是很好吗...*”这样的问题时，这通常意味着这样的功能已经存在！至少在这个案例中，这是真的。这就是服务介入的地方。服务和Service
    API的概念一起，在您迄今为止所学的现有模块化概念之上增加了一个全新的间接层。让我们深入了解细节。
- en: Understanding services
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务
- en: 'Let''s begin our journey of understanding services with a concept that you
    should be very familiar with as a Java developer--polymorphism. It starts with
    one interface and (possibly multiple) implementations of that interface. Although
    interfaces are not strictly *necessary* for services, they are still a good place
    to start. Let''s say you define a service interface called `MyServiceInterface`
    that looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从您作为Java开发者应该非常熟悉的概念开始我们的服务理解之旅——多态。它从一个接口和（可能多个）该接口的实现开始。尽管接口对于服务来说不是严格*必需的*，但它们仍然是一个好的起点。假设您定义了一个名为`MyServiceInterface`的服务接口，其外观如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you can have multiple modules containing classes that implement this interface.
    Since all those modules need access to this interface, let's throw this interface
    into a module of its own, called `service.api`, and expose the package that the
    interface `MyServiceInterface` is in. Then each implementation module can require
    the `service.api` module and implement `MyServiceInterface`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以拥有包含实现此接口的类的多个模块。由于所有这些模块都需要访问此接口，让我们将这个接口放入一个名为`service.api`的单独模块中，并公开接口`MyServiceInterface`所在的包。然后每个实现模块都可以要求`service.api`模块并实现`MyServiceInterface`。
- en: 'Consider there are three implementations of `MyServiceInterface` in three corresponding
    modules. Since they need the interface to implement it in the first place, all
    three implementation modules *read* the `service.api` module to get access to
    `MyServiceInterface`. Imagine each module does just that, and that each contains
    a class that implements `MyServiceInterface`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有三个模块实现了`MyServiceInterface`，分别位于三个相应的模块中。由于它们需要接口来首先实现它，所有三个实现模块*读取*`service.api`模块以访问`MyServiceInterface`。想象一下每个模块都这样做，并且每个模块都包含一个实现了`MyServiceInterface`的类：
- en: '![](img/00066.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: 'Now, the consumer module needs to call one of these implementations to actually
    run the service. The goal here is not to have the consumer module directly *read*
    the various implementation modules, since that''s tight coupling. What we want
    is for the consumer module to read just the *interface* module `service.api` and
    deal with the interface type only, but still somehow manage to get access to instances
    of that interface''s implementations. Remember, we *do not* want the consumer
    to require the individual implementation modules (the *Xs* in the following diagram):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消费者模块需要调用这些实现之一来实际运行服务。这里的目的是不希望消费者模块直接*读取*各种实现模块，因为那样会导致紧密耦合。我们希望消费者模块只读取*接口*模块`service.api`，并且只处理接口类型，但仍然能够以某种方式访问该接口实现的实例。记住，我们*不希望*消费者需要单独的实现模块（以下图中所示*Xs*）：
- en: '![](img/00067.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: The service registry
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表
- en: 'In order to cross this bridge between the consumer and the implementation without
    direct tight coupling, imagine a layer between them called *the service registry*.
    The service registry is a layer provided by the module system to record and register
    implementations of a given interface as *services*. Think of it as a kind of phone
    book or yellow pages, but for services. Any module that implements a service needs
    to register itself in the service registry. Once that''s done, the service registry
    has all the information about the different service implementations of the interface
    that are available. The following diagram illustrates this interaction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在消费者和实现之间建立桥梁而不直接紧密耦合，想象一个位于它们之间的层，称为*服务注册表*。服务注册表是模块系统提供的一个层，用于记录和注册给定接口的实现作为*服务*。把它想象成一种电话簿或黄页，但针对服务。任何实现服务的模块都需要在服务注册表中注册自己。一旦完成，服务注册表就拥有了关于接口的不同服务实现的所有信息。以下图表说明了这种交互：
- en: '![](img/00068.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00068.jpeg)'
- en: 'Now when the consumer needs an implementation, it uses the services API to
    talk to the service registry and get instances of the available implementations.
    The following diagram illustrates this interaction:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当消费者需要实现时，它使用服务API与服务注册表通信，并获取可用实现的实例。以下图表说明了这种交互：
- en: '![](img/00069.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00069.jpeg)'
- en: What the consumer module gets is an `Iterable` of instances of all available
    implementations. There doesn't have to be multiple instances, of course. There
    could be just one implementation! Either way, the Service API hands over the available
    instances to the consumer when accessed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模块得到的是所有可用实现实例的`Iterable`。当然，不一定需要多个实例。可能只有一个实现！无论如何，服务API在访问时将可用的实例交给消费者。
- en: As you can see, we have broken the coupling between the *provider* and the *consumer*.
    Every module in this figure reads just one module in common--the module containing
    the interface. The interface is the only **common** entity that all these different
    modules share, since that's the means of the interaction between them. Since the
    other modules are completely unaware of each other, you could pretty much remove
    one implementation module and drop in another. As long as it does the right things--that
    is, implements the right interface and registers with the service registry--it
    is available for the consumer to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们打破了*提供者*和*消费者*之间的耦合。这个图中的每个模块只读取一个共同的模块——包含接口的模块。接口是所有这些不同模块唯一**共同**的实体，因为那是它们之间交互的手段。由于其他模块对彼此一无所知，您可以几乎移除一个实现模块并替换另一个。只要它做正确的事情——也就是说，实现正确的接口并在服务注册表中注册——它就可以供消费者使用。
- en: Now that you've understood the concept of services at a high level, let's get
    into the specifics. How do the modules *register* their implementations? How does
    the consumer module access the instances from the registry? Let's look at the
    implementation details.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经从高层次上理解了服务的概念，让我们深入了解具体细节。模块如何*注册*它们的实现？消费者模块如何从注册表中访问实例？让我们看看实现细节。
- en: Creating and using services
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用服务
- en: 'Here are the end-to-end steps to create, register, and implement a service:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建、注册和实现服务的端到端步骤：
- en: '**Create the Java type that defines the service**: Every service is based off
    of a single Java type that defines the service API. The type could be an interface,
    an abstract class, or even a regular Java class. Most of the time, the service
    type will be an interface. Having an interface is ideal because that way, you
    can have multiple implementation types for it.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建定义服务的Java类型**：每个服务都基于一个单一的Java类型，该类型定义了服务API。这个类型可以是接口、抽象类，甚至是普通的Java类。大多数情况下，服务类型将是接口。拥有一个接口是理想的，因为这样你可以为它提供多个实现类型。'
- en: The service type is the means through which both the providers and consumers
    talk to each other. This begs the question of which module the service type should
    be in? Since it is shared by multiple modules, and we don't want the providers
    and consumers to be tightly coupled, the ideal solution is to create the service
    types in a separate module. This module exports the service type and is read by
    both the provider and consumer modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类型是提供者和消费者之间交流的手段。这引发了一个问题：服务类型应该在哪个模块中？由于它被多个模块共享，而且我们不希望提供者和消费者紧密耦合，理想的解决方案是在一个单独的模块中创建服务类型。这个模块导出服务类型，并由提供者和消费者模块读取。
- en: 'In our example, that would be the module `service.api`. It exports the package
    `service.api`, thereby exporting the interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这将是模块`service.api`。它导出`service.api`包，从而导出接口：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This module contains the interface `service.api.MyServiceInterface`, as previously
    shown. This fully qualified interface type name itself is the service type. Services
    in the Java module system don't have special names. They are simply referred to
    by the name of the Java type that acts as the service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块包含之前显示的`service.api.MyServiceInterface`接口。这个完全限定的接口类型名称本身是服务类型。在Java模块系统中，服务没有特殊名称。它们只是通过充当服务的Java类型的名称来引用。
- en: '**Create one or more implementation modules that read the interface module
    and implement the interface**: For example, if you need to have two modules `service.implA`
    and `service.implB` that provide two implementations of `MyServiceInterface`,
    both the modules will *require* the `service.api` module to access the interface.
    They each have an implementation of the `MyServiceInterface` interface. Each implementation
    of the service interface is referred to as a *service provider*.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个或多个实现模块，这些模块读取接口模块并实现接口**：例如，如果您需要有两个模块`service.implA`和`service.implB`，它们提供`MyServiceInterface`的两个实现，那么这两个模块都将*需要*`service.api`模块来访问接口。它们各自都有一个`MyServiceInterface`接口的实现。每个服务接口的实现被称为*服务提供者*。'
- en: '**Have the implementation modules register themselves as service providers**:
    This is the part where the implementation modules tell the service registry that
    they would like to register their implementation of the interface. This is done
    in the module descriptor by using a new keyword called  `provides` and specifying
    both the interface and the implementation type information. The syntax is as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让实现模块注册自己作为服务提供者**：这是实现模块告诉服务注册它们希望注册其接口实现的那个部分。这是通过在模块描述符中使用一个新的关键字`provides`并指定接口和实现类型信息来完成的。其语法如下：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, if the module `service.implA` has the implementation class `packt.service.impla.MyServiceImplA`
    that implements `MyServiceInterface`, the module definition should read:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果模块`service.implA`有一个实现类`packt.service.impla.MyServiceImplA`，它实现了`MyServiceInterface`，那么模块定义应该如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is sufficient for the module system to know that this module would like
    to register the `MyServiceImplA` class as a service that provides for the interface
    `MyServiceInterface`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于模块系统来说足够了，它知道这个模块希望注册`MyServiceImplA`类作为为`MyServiceInterface`接口提供服务的服务。
- en: 'A few observations here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些观察结果：
- en: Note the fully qualified name for both the interface and implementation types.
    This is important in order to avoid name conflicts and make sure the Java platform
    knows exactly which types you are referring to.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意接口和实现类型的完全限定名称。这对于避免名称冲突并确保Java平台确切知道您所引用的类型非常重要。
- en: Note that the interface type referred to in the `provides` clause does not belong
    to the module itself. It's in a completely different module that this module reads
    from (using the `requires` clause)! But that's okay; it works. However, it's important
    for the implementation class to be in the module that the module descriptor belongs
    to. This makes sense when you consider the fact that with the `provides` line
    of code, the module is essentially claiming to provide the implementation mentioned.
    So, it had better have it!
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意在`provides`子句中引用的接口类型不属于该模块本身。它位于一个完全不同的模块中，该模块通过`requires`子句读取！但是，这没关系；它仍然可以工作。然而，对于实现类位于模块描述符所属的模块中这一点很重要。当你考虑到使用`provides`代码行时，模块实际上是在声明提供所提到的实现这一事实时，这一点就变得有意义了。因此，它最好拥有它！
- en: This is an observation about what's *not* in the preceding module descriptor.
    Notice that we haven't added an `exports` clause here in order to make the `MyServiceImplA`
    class accessible to other modules. When providing services, you don't have to
    expose the implementation classes and make them accessible. This is because this
    class is not accessed with the usual module *readability* and *accessibility*
    relationships that we've been working with so far. The consumer module will get
    the instance of the implementation through the service APIs and does not read
    the module directly. That's the point of services after all, to avoid this tight
    coupling.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是对前一个模块描述符中未包含的内容的观察。请注意，我们没有在这里添加`exports`子句，以便使`MyServiceImplA`类对其他模块可访问。在提供服务时，您不必公开实现类并使其可访问。这是因为这个类不是通过我们迄今为止一直在使用的常规模块*可读性*和*可访问性*关系来访问的。消费者模块将通过服务API获取实现类的实例，而不是直接读取模块。这正是服务的作用所在，避免这种紧密耦合。
- en: With this step, we have now successfully registered the service providers with
    the module system. Every implementation that does this is now mapped to the service
    *name* which is, for all practical purposes, the fully qualified interface name--`service.api.MyServiceInterface`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一步，我们现在已成功将服务提供者注册到模块系统中。现在，所有执行此操作的实现都映射到服务*名称*上，这在所有实际目的上相当于完全限定的接口名称--`service.api.MyServiceInterface`。
- en: 'Now let''s turn our attention to the consumer module. Getting the consumer
    module to have access to the service implementation instances is a two-part process:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向消费者模块。让消费者模块能够访问服务实现实例是一个两步的过程：
- en: '**Have the consumer module register itself as a consumer of the service**:
    Just like the service providers *register* their intent to provide implementations,
    the service consumers need to *register* the fact that they''ll need to *use*
    the service. The module that needs the instances will have to formally declare
    this need in the module descriptor. This is done using the `uses` keyword. The
    syntax is:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让消费者模块将自己注册为服务的消费者**：就像服务提供者*注册*他们提供实现的意图一样，服务消费者需要*注册*他们需要*使用*服务的事实。需要实例的模块必须在模块描述符中正式声明这种需求。这是使用`uses`关键字完成的。语法如下：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our example, if we have a module named consumer that needs instances of
    `MyServiceInterface`, the module definition will read:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果我们有一个名为consumer的模块需要`MyServiceInterface`的实例，该模块的定义将如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is sufficient for the module system to know that this is a module that
    will use a service implementation instance of the mentioned interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于模块系统来说足够了，它知道这是一个将使用指定接口的服务实现实例的模块。
- en: 'A few observations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些观察结果：
- en: The consumer module too `requires` the module that exposes the interface. It
    has to, because when the module requests service instances from the service API,
    what it'll get back are instances that are of the same type as the interface.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者模块也需要`requires`暴露接口的模块。它必须这样做，因为当模块从服务API请求服务实例时，它将得到与接口相同类型的实例。
- en: Here, the `uses` clause is referring to a type that's not available in the module.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，`uses`子句指的是模块中不可用的类型。
- en: As you must have guessed, there's no direct dependency on any of the implementation
    modules. Loose coupling for the win!
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所料，对任何实现模块都没有直接依赖。松散耦合获胜！
- en: After this step, on the one hand, we have the provider modules register their
    implementations with the service registry. And on the other hand, we have the
    consumer module register that it is a consumer of the service. Now, how does the
    code in the consumer module get access to the instances of the provider implementations?
    This is the final step, and this involves calling the `ServiceLoader` API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，一方面，提供者模块将它们的实现注册到服务注册表中。另一方面，消费者模块注册它自己是服务的消费者。现在，消费者模块中的代码如何获取提供者实现实例的访问权限？这是最后一步，这涉及到调用`ServiceLoader`
    API。
- en: '**Call the** **ServiceLoader** **API to access the provider instances in the
    consumer module''s code**: With no direct dependencies, the service implementation
    types are completely unknown to the consumer. All it has is the interface type.
    So, there''s no way it can instantiate types using `new`.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在消费者模块的代码中调用** **ServiceLoader** **API以访问提供者实例**：由于没有直接依赖，服务实现类型对消费者来说是完全未知的。它所拥有的只是接口类型。因此，它无法使用`new`来实例化类型。'
- en: 'In order to access all registered implementations of the service, you''ll need
    to call the Java platform API `ServiceLoader.load()` method in the consumer module''s
    code. Here''s the code to get all registered service provider instances of the
    interface `MyServiceInterface`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问所有注册的服务实现，你需要在消费者模块的代码中调用Java平台API `ServiceLoader.load()`方法。以下是获取接口`MyServiceInterface`的所有注册服务提供者实例的代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What the API returns is an `Iterable` of all available implementations of the
    service that have been registered in the Service Registry. Thanks to the return
    type being `Iterable`, you can loop through the instances and maybe pick one of
    them. Or you could even use all! It really depends on the application need and
    what it's trying to do. What's important to note is that each one of the objects
    in this `Iterable` is an instance of the provider implementation types that were
    registered in step 3 of creating services mentioned earlier. There could be several
    other classes that implement the interface, but if they aren't registered using
    the `provides` syntax, they will not be considered in this process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: API返回的是在服务注册表中注册的所有可用服务实现的`Iterable`。由于返回类型是`Iterable`，你可以遍历实例并从中选择一个。或者，你甚至可以使用所有！这完全取决于应用程序的需求和它试图做什么。重要的是要注意，这个`Iterable`中的每个对象都是之前在创建服务的步骤3中注册的提供者实现类型的实例。可能有其他几个实现该接口的类，但如果它们没有使用`provides`语法进行注册，则不会在这个过程中被考虑。
- en: There's a common pattern in many Enterprise Java frameworks that's used to handle
    various implementations of services and is accessed through the interface. It's
    called *Dependency Injection*. This pattern is available in frameworks such as
    Spring, as well as Java EE technologies like EJB. This pattern requires the consumer
    classes to simply *declare* dependency on services. The framework then performs
    the job of creating instances and automatically *injecting* them to the consuming
    classes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多企业Java框架中存在一个常见的模式，用于处理服务的各种实现，并通过接口访问。它被称为*依赖注入*。这种模式在Spring等框架以及EJB等Java
    EE技术中都是可用的。这种模式要求消费者类简单地*声明*对服务的依赖。然后框架执行创建实例并自动*注入*到消费者类的任务。
- en: What we are doing here is ***not*** that. There's no automatic injection of
    instances to the consuming code. As you've noticed, you have to write code that
    uses `ServiceLoader` to *look up* provider instances. This is by design, and is
    an important distinction to make when compared to those other patterns. This is
    a *dependency lookup*, not *dependency injection*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的***不是***这样。没有自动将实例注入到消费者代码中。正如你所注意到的，你必须编写使用`ServiceLoader`来*查找*提供者实例的代码。这是设计的一部分，并且与那些其他模式相比，这是一个重要的区别。这是一个*依赖查找*，而不是*依赖注入*。
- en: Implementing sorting services
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现排序服务
- en: 'Now that we have an understanding of how to create and consume services, let''s
    put this to practice in the address book viewer application. We''ll create multiple
    sorting implementation modules and register these implementations as services.
    We''ll then update the `packt.addressbook` module to use the `ServiceLoader` API
    to get the sorting instances, and then use one of these instances to sort the
    contacts list. Let''s run through the five steps we''ve just learned in order
    to achieve this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建和消费服务，让我们在地址簿查看器应用程序中将其付诸实践。我们将创建多个排序实现模块，并将这些实现注册为服务。然后，我们将更新`packt.addressbook`模块以使用`ServiceLoader`
    API获取排序实例，然后使用这些实例之一对联系人列表进行排序。让我们回顾一下我们刚刚学到的五个步骤来实现这一点：
- en: '**Create the Java type that defines the service**: We''ll retain the interface
    `SortUtil` to be the common interface that various implementation types will use.
    The `packt.sortutil` module contains both the interface and implementation types
    now. We''ll remove the implementation and leave just the interface in there. We''ll
    also remove the default static dependency on `BubbleSortUtilImpl` and make this
    a pure and abstract interface:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建定义服务的Java类型**：我们将保留接口`SortUtil`作为各种实现类型将使用的通用接口。`packt.sortutil`模块现在包含接口和实现类型。我们将移除实现类型，只保留接口。我们还将移除对`BubbleSortUtilImpl`的默认静态依赖，使其成为一个纯净的抽象接口：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will be the only type in the `packt.sortutil` module. The module exports
    the `packt.util` package to make the interface available to both the providers
    and consumers. Here''s `module-info.java`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是`packt.sortutil`模块中唯一的类型。该模块导出`packt.util`包，以便提供者和消费者都可以使用该接口。以下是`module-info.java`文件：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Create one or more implementation modules that read the interface module
    and implement the interface**: Let''s create a couple of implementation modules--`packt.sort.bubblesort`,
    which provides the BubbleSort implementation, and `packt.sort.javasort`, which
    provides an implementation using the default sorting API of Java collections:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个或多个实现模块，该模块读取接口模块并实现接口**：让我们创建几个实现模块--`packt.sort.bubblesort`，它提供了冒泡排序的实现，以及`packt.sort.javasort`，它使用Java集合的默认排序API提供实现：'
- en: '![](img/00070.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: Make sure you don't put both the implementation classes in the two modules in
    the same package. For example, both the implementation classes cannot be in the
    same `packt.util.impl` package, because then you'll run into the problem of split
    packages, with both modules containing the same package, and the runtime will
    throw an error. We've covered the split packages problem in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你不会在两个模块中将实现类放在同一个包中。例如，实现类不能都在`packt.util.impl`包中，因为这样会导致包分割问题，两个模块都包含相同的包，运行时会抛出错误。我们已经在[第6章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)，“模块解析、可访问性和可读性”中讨论了包分割问题。
- en: Both the modules `requires` the module `packt.sortutil` in order to access the
    `packt.util.SortUtil` interface. Each has an implementation of the interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块`requires`模块`packt.sortutil`以访问`packt.util.SortUtil`接口。每个模块都有一个接口的实现。
- en: 'Here''s `BubbleSortUtilImpl`, which is a class we''ve already seen, so here''s
    the truncated version:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BubbleSortUtilImpl`，这是我们之前已经看到的一个类，所以这里提供的是截断版本：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s `JavaSortUtilImpl`, which simply uses the `Collections.sort` API:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`JavaSortUtilImpl`，它简单地使用了`Collections.sort` API：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Have the implementation modules register themselves as service providers**:
    Let''s register both the implementation modules as providers using the `provides`
    keyword. The service type is the interface `packt.util.SortUtil` and the implementation
    types are the two implementation classes in the two modules, respectively.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让实现模块将自己注册为服务提供者**：让我们使用`provides`关键字将两个实现模块都注册为提供者。服务类型是接口`packt.util.SortUtil`，而实现类型分别是两个模块中的两个实现类。'
- en: 'Here''s the `module-info.java` file for the `packt.sort.bubblesort` module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`packt.sort.bubblesort`模块的`module-info.java`文件：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here''s the `module-info.java` file for the `packt.sort.javasort` module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`packt.sort.javasort`模块的`module-info.java`文件：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Have the consumer module register itself as a consumer of the service**:
    We''ll be needing instances of `SortUtil` in the `packt.addressbook` and `packt.addressbook.ui`.
    I''ll showcase the steps in the `packt.addressbook` module alone here, because
    it has relatively fewer things going on. But the steps are the same and need to
    be applied to both modules.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让消费者模块将自己注册为服务的消费者**：在`packt.addressbook`和`packt.addressbook.ui`中，我们需要`SortUtil`的实例。在这里，我将仅展示`packt.addressbook`模块中的步骤，因为它涉及的内容相对较少。但步骤是相同的，并且需要应用到两个模块中。'
- en: 'Here''s the module descriptor of `packt.addressbook` with the `uses` clause:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`packt.addressbook`模块的模块描述符，其中包含`uses`子句：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Call the** **ServiceLoader** **API to access the provider instances in the
    consumer module''s code**: In `Main.java`, use the `ServiceLoader` API to get
    all provider instances of `SortUtil`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在消费者模块的代码中调用** **ServiceLoader** **API以访问提供者实例**：在`Main.java`中，使用`ServiceLoader`
    API获取所有`SortUtil`的提供者实例：'
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, iterating through, you can access each instance. I''ll loop through and
    sort the list using *both* of the sorting implementations. This is clearly unnecessary,
    but it''s just for illustration:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，迭代遍历，你可以访问每个实例。我将通过循环使用两种排序实现来对列表进行排序。这显然是不必要的，但只是为了说明：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And we are done! You've used the service mechanism to create, register, and
    use sorting service implementations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了！你已经使用了服务机制来创建、注册和使用排序服务实现。
- en: Make sure you apply the same changes to the `packt.addressbook.ui` module as
    well! If not, the compilation step will fail for that module, for obvious reasons.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你也将相同的更改应用到`packt.addressbook.ui`模块中！如果不这样做，该模块的编译步骤将因明显的原因而失败。
- en: 'Compiling and running the code now should work without any errors:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行代码应该不会出现任何错误：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see from the output, there have been two instances of `SortUtil`
    returned by `ServiceLoader`, corresponding to the two implementations we have
    registered.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中可以看到，`ServiceLoader` 返回了两个 `SortUtil` 实例，对应于我们已注册的两个实现。
- en: Drawing the module graph
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制模块图
- en: 'Let''s draw the module graph that represents the interaction between the service
    provider and consumer modules. We know how to represent *readability* relationships.
    How about service consumer and provider dependencies? The following diagram uses
    arrows to depict both the **uses** and **provides** dependencies, with labels
    to identify them:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制表示服务提供者和消费者模块之间交互的模块图。我们知道如何表示 *可读性* 关系。那么服务消费者和提供者依赖关系呢？以下图表使用箭头表示 **使用**
    和 **提供** 依赖关系，并使用标签来识别它们：
- en: '![](img/00071.gif)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.gif)'
- en: The lack of dependencies between the consumer and provider modules is the key
    to loose coupling that is enabled using services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模块和提供者模块之间没有依赖关系是使用服务实现松耦合的关键。
- en: Advanced services
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级服务
- en: The services concepts covered so far should address a lot of typical use cases,
    but there are a few additional features and concepts that might come in handy
    in certain special scenarios. We'll look at a few such concepts in this section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所涵盖的服务概念应该可以解决很多典型用例，但还有一些额外的功能和概念可能在某些特殊场景中很有用。在本节中，我们将探讨几个这样的概念。
- en: Supporting singleton and factory providers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持单例和工厂提供者
- en: Suppose your service instances cannot be created simply by a constructor. What
    if you need to reuse instances, maybe to have a singleton provider instance? Or
    maybe execute some logic whenever a new service instance is created? There is
    a handy feature of services that lets you create factory methods to get service
    instances. All you need to do is add a method with the name `provide()` in your
    provider classes. The method needs to be a public static method and it shouldn't
    take any arguments. Also, the return type should be the same as the type of the
    service being provided. If the `ServiceLoader` sees this method, it calls it,
    and uses the return of the method as the service instance. If it doesn't find
    such a method, it calls the public no-args constructor like we've already seen.
    This allows you to hook into the provider instance creation step, and here you
    can execute any necessary code, as well as get an opportunity to create the object
    that the `ServiceLoader` will use as the provider instance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的服务实例不能简单地通过构造函数创建。如果需要重用实例，比如拥有一个单例提供者实例？或者每当创建一个新的服务实例时执行一些逻辑？服务有一个方便的特性，允许您创建工厂方法来获取服务实例。您需要做的只是在其提供者类中添加一个名为
    `provide()` 的方法。该方法需要是一个公共静态方法，并且不应该接受任何参数。此外，返回类型应与提供的服务类型相同。如果 `ServiceLoader`
    看到了这个方法，它会调用它，并使用方法的返回值作为服务实例。如果没有找到这样的方法，它会调用我们之前看到的公共无参构造函数。这允许您在提供者实例创建步骤中挂钩，在这里您可以执行任何必要的代码，同时有机会创建
    `ServiceLoader` 将用作提供者实例的对象。
- en: Implementing service priorities
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务优先级
- en: In the last example, we got two instances of `SortUtil`, and we did something
    ridiculous with them--we sorted the list twice, once per implementation! You wouldn't
    typically do that. What you'll most likely need to do in applications when you
    receive more than one service implementation is something a bit trickier. You'll
    need to choose one!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们得到了两个 `SortUtil` 实例，并且对它们做了些荒谬的事情--我们对列表进行了两次排序，一次对应于每个实现！您通常不会这样做。当您在应用程序中接收到多个服务实现时，您最可能需要做的是一件更复杂的事情。您需要选择一个！
- en: Unfortunately there is no way you can give service implementations distinct
    priorities. So, there's no way you can say something like `BubbleSortUtilImpl`
    is your favorite sort implementation, and that's the implementation to be used
    if it's available, irrespective of whatever other implementations are found. As
    per design, it's not the responsibility of the service implementations to specify
    priority. It's the job of the consumer to decide what to do with the multiple
    implementations it receives from `ServiceLoader`, since the *best* service implementation
    for the job is usually dependent on the consuming application itself. What is
    the best service implementation for one consumer might not be ideal for another.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，您无法为服务实现指定不同的优先级。因此，您无法说像`BubbleSortUtilImpl`这样的排序实现是您最喜欢的，并且当它可用时，无论找到其他什么实现，都应该使用这个实现。根据设计，指定优先级不是服务实现的职责。决定如何处理从`ServiceLoader`接收到的多个实现是消费者的工作，因为最适合这项工作的服务实现通常取决于消费应用程序本身。对某个消费者来说最好的服务实现可能对另一个消费者来说并不理想。
- en: Now, how does the consumer choose one provider among all available ones? All
    it sees is a bunch of instances of the same interface! So, what we do is enhance
    the interface to contain methods that the consumer can use to query provider instances.
    The consumer calls these methods to find out more about the provider classes and
    thus make an informed decision about which provider instances it would like to
    go with.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消费者如何在所有可用的提供者中选择一个？他们看到的是同一接口的一堆实例！因此，我们增强接口以包含消费者可以使用的方法来查询提供者实例。消费者调用这些方法来了解更多关于提供者类的信息，从而做出明智的决定，选择它想要的提供者实例。
- en: Take the case of the `SortUtil` implementations. Let's assume we want to use
    the sorting algorithm depending on the size of the list. For instance, let's say
    we wish to choose bubble sort only if the list is very small, but use the `Collections`
    API sorting for larger lists.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以`SortUtil`实现为例。假设我们想根据列表的大小来使用排序算法。例如，假设我们只想在列表非常小的情况下使用冒泡排序，而对于较大的列表则使用`Collections`
    API排序。
- en: What we could do is add a method to the `SortUtil` interface called `getIdealInputLength()`.
    Each implementation then provides an integer length that it can deal with ideally.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的就是在`SortUtil`接口中添加一个名为`getIdealInputLength()`的方法。然后，每个实现都提供一个整数长度，表示它可以理想地处理的长度。
- en: Bubble sort is far from the best sorting algorithm you can use. It's an algorithm
    many programming courses use to teach sorting, but in reality it's horribly inefficient.
    For the sake of our simple example, let's say we use bubble sort on lists that
    are four elements or smaller, and use `Collections` sort for the rest. I'll admit
    this is a contrived example, but it'll let us implement a basic strategy for choosing
    providers. In reality, you'd almost always want to use the `Collections` API for
    sorting lists.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序绝不是您能使用的最佳排序算法。它是许多编程课程用来教授排序的算法，但在现实中它效率极低。为了我们简单的示例，让我们说我们只在列表有四个或更少的元素时使用冒泡排序，而对于其他情况则使用`Collections`排序。我必须承认这是一个人为的例子，但它将使我们能够实现选择提供者的基本策略。在现实中，您几乎总是想使用`Collections`
    API来排序列表。
- en: 'Here''s `SortUtil` with the new method declaration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有新方法声明的`SortUtil`：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the `BubbleSortUtilImpl` implementation of this method that returns
    `4` as the ideal maximum size of the input list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`BubbleSortUtilImpl`实现此方法，返回`4`作为输入列表的理想最大大小：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `JavaSortUtilImpl` is OK with any list size, so for the ideal maximum,
    we''ll just return the maximum integer value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`JavaSortUtilImpl`对任何列表大小都无所谓，所以对于理想的最大值，我们只需返回最大整数值：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that each provider has a method that can be used to choose one implementation
    over the other, the consumer can use this to identify which of the implementations
    it would like to use.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个提供者都有一个可以用来选择一个实现而不是另一个的方法，消费者可以使用这个方法来识别它想使用的实现。
- en: 'Here''s the section in `Main.java` (in both the `pack.addressbook` and `packt.addressbook.ui`
    modules) that loops through the providers to pick one:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Main.java`（在`pack.addressbook`和`packt.addressbook.ui`模块中）的章节，它遍历提供者以选择一个：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Given the size of the `contacts` list we'd like to sort, we'll check each provider
    to see if the list size is greater than the maximum size the provider would ideally
    like to handle. We then pick the first provider that passes this check, use that
    instance to sort the list, and `break` off the loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们想要排序的`contacts`列表的大小，我们将检查每个提供者，看列表大小是否大于提供者理想情况下希望处理的最大的大小。然后我们选择第一个通过这个检查的提供者，使用该实例来排序列表，并`break`出循环。
- en: 'Run the code and observe the output. If the `BubbleSortUtilImpl` is the first
    instance in the iterator, the logic skips it and moves to the `JavaSortUtilImpl`
    and uses it to sort:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并观察输出。如果`BubbleSortUtilImpl`是迭代器中的第一个实例，逻辑会跳过它并移动到`JavaSortUtilImpl`并使用它进行排序：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a simple example of how provider implementations give *clues* about
    the implementation to any consumers. Different consumers could then choose different
    implementations, depending on their unique needs and business problems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，说明了提供者实现如何向任何消费者提供*线索*关于实现的信息。不同的消费者可以根据他们独特的需求和业务问题选择不同的实现。
- en: Service interface provider lookup
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务接口提供者查找
- en: The lookup logic to get service instances is now in the Main classes in both
    the `packt.addressbook` and `packt.addressbook.ui` modules. This is less than
    ideal. We don't want to repeat the lookup logic in multiple places. One way to
    solve this is to move the logic to a common place that's accessible by all the
    consumers of the service. Now, what's the module that's shared by every consumer
    of the service? It's the module that exports the interface. Wouldn't it be a great
    idea to move the dependency lookup logic and tuck it away as a default method
    in the interface? Then none of the consumer modules would need to mess with the
    `ServiceLoader` APIs directly. They would just have to call the right interface
    method to look up the instances.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 获取服务实例的查找逻辑现在在`packt.addressbook`和`packt.addressbook.ui`模块的`Main`类中。这并不理想。我们不希望在多个地方重复查找逻辑。解决这个问题的方法之一是将逻辑移动到一个所有服务消费者都可以访问的通用位置。现在，共享每个服务消费者的模块是什么？是导出接口的模块。将依赖查找逻辑移动到接口中并作为一个默认方法隐藏起来，这不是一个好主意吗？这样，就没有消费者模块需要直接与`ServiceLoader`
    API打交道。他们只需要调用正确的接口方法来查找实例。
- en: Let's create two new methods on the `SortUtil` interface. One to get all service
    provider instances, and the second to get single instances based on the size of
    the list (which is a criterion that affects which instance is picked, like we've
    already seen).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`SortUtil`接口上创建两个新方法。一个用于获取所有服务提供者实例，另一个根据列表的大小（这是一个影响选择哪个实例的标准，就像我们已经看到的）获取单个实例。
- en: 'Here are the two new static methods on `SortUtil`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`SortUtil`上的两个新静态方法：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we are returning `null` if no service instances that matched our requirement
    were found. This could easily be enhanced to provide a default service in case
    a suitable instance wasn't found.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到符合我们要求的服务实例，我们将返回`null`。这可以很容易地增强以提供默认服务，以防找不到合适的实例。
- en: 'Now, `Main` doesn''t have to talk to `ServiceLoader` and loop through instances
    anymore:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Main`不需要再与`ServiceLoader`通信并遍历实例了：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I hope you'll agree that the consumption of the service has become much simpler
    now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会同意，现在服务的消费已经变得简单多了。
- en: 'One other change you''ll have to do is to move the  `uses` clause from the
    `packt.addressbook` and `packt.addressbook.ui` modules to the `packt.sortutil`
    module. That''s because the service is consumed and the `ServiceLoader` APIs are
    invoked from the `packt.sortutil` module now:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要做的另一件事是将`uses`子句从`packt.addressbook`和`packt.addressbook.ui`模块移动到`packt.sortutil`模块。这是因为服务现在是从`packt.sortutil`模块消费的，并且`ServiceLoader`
    API也是从该模块调用的：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compiling and running the code should give you the same output as before. But
    this time, the service lookup logic is now refactored into a common module usable
    by all consumers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行代码应该会给出与之前相同的输出。但这次，服务查找逻辑已经被重构为一个所有消费者都可以使用的通用模块。
- en: Selective service instantiation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择性服务实例化
- en: In the preceding examples, we have queried the `ServiceLoader` APIs to get *all*
    provider instances in an `Iterable`. We then looped through them and picked one.
    This is not a problem here because our services are simple and lightweight Java
    classes. That may not always be ideal. Imagine if services are more complex and
    need time and resources to instantiate. In such cases, you wouldn't want to instantiate
    every service provider when you know you won't use all of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经查询了`ServiceLoader` API以获取所有提供者实例的`Iterable`。然后我们遍历它们并选择一个。这在这里不是问题，因为我们的服务是简单且轻量级的Java类。但这并不总是理想的。想象一下，如果服务更复杂且需要时间和资源来实例化。在这种情况下，当你知道你不会使用所有服务时，你不想实例化每个服务提供者。
- en: The Java module system is quite smart about how it manages service instances
    in an application. First of all, all service instances are *lazily loaded*. In
    other words, service provider instances are not automatically instantiated when
    the application starts up. The runtime creates a service instance only when the
    type is needed, like when some consumer asks for instances of the service using
    `ServiceProvider.load()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java模块系统在管理应用程序中的服务实例方面非常智能。首先，所有服务实例都是**延迟加载**的。换句话说，服务提供者实例在应用程序启动时不会自动实例化。运行时仅在需要类型时创建服务实例，例如，当某些消费者使用`ServiceProvider.load()`请求服务实例时。
- en: Secondly, any service instances that are created during the lifetime of the
    application are always cached. The service loader maintains this cache and keeps
    track of all the service instances that have been created. When the second consumer
    requests the service, the instance is fetched off of the cache directly. It also
    intelligently makes sure that the order of the service instances returned always
    includes the cached instances first.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在应用程序的生命周期内创建的任何服务实例都始终被缓存。服务加载器维护这个缓存并跟踪所有已创建的服务实例。当第二个消费者请求服务时，实例直接从缓存中获取。它还智能地确保返回的服务实例顺序始终包括缓存实例。
- en: Caching is automatic with service instances. If you want to clear the entire
    service provider cache during application execution, you can do so using the `ServiceProvider.reload()`
    API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实例的缓存是自动的。如果你想在应用程序执行期间清除整个服务提供者缓存，可以使用`ServiceProvider.reload()` API。
- en: The `ServiceLoader` API has an option of streaming instances of an intermediate
    type called `Provider`, which can then be used to create service provider instances.
    Rather than getting all the service instances directly, what you get instead is
    `Provider` instances--one instance per service implementation found. You can then
    instantiate only the service providers you want by using the `Provider.get()` method
    on those instances.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceLoader` API有一个选项可以流式传输一个称为`Provider`的中间类型实例，然后可以使用它来创建服务提供者实例。你不会直接获取所有服务实例，而是获取`Provider`实例——每个找到的服务实现都有一个实例。然后，你可以通过在这些实例上使用`Provider.get()`方法来实例化你想要的服务提供者。'
- en: 'As an example, consider the `getProviderInstanceLazy()` method on `SortUtil`.
    Rather than directly use `ServiceLoader.load(SortUtil.class)`, we can instead
    use `ServiceLoader.load(SortUtil.class).stream()`, which returns a `Stream` of
    `Provider` instances:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以`SortUtil`上的`getProviderInstanceLazy()`方法为例。我们不是直接使用`ServiceLoader.load(SortUtil.class)`，而是可以使用`ServiceLoader.load(SortUtil.class).stream()`，它返回一个`Provider`实例的`Stream`：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Provider` instances can then be inspected for things such as annotations
    and other type information. Here, we are just sorting them by type name, which
    is silly, but it works as a minimal example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以检查`Provider`实例以获取诸如注解和其他类型信息等。在这里，我们只是按类型名称对它们进行排序，这很愚蠢，但作为一个最小示例它是有效的：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this time, no service instances are created. The actual instantiation of
    the service provider types happens when the `Provider.get` is called:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时刻，尚未创建任何服务实例。服务提供者类型的实际实例化发生在调用`Provider.get`时：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we call `Provider.get()` on each provider instance through
    the map function and pick one. This way, we can defer the creation of instances
    as well as selectively instantiate provider types by calling `Provider.get` only
    on the ones we need.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过map函数对每个提供者实例调用`Provider.get()`并选择一个。这样，我们可以延迟实例的创建，并通过仅在需要的实例上调用`Provider.get`来选择性地实例化提供者类型。
- en: Services and the module system goals
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务和模块系统目标
- en: Since services are a part of the Java module system, how do they align with
    the two goals of the module system--strong encapsulation and reliable configuration?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是Java模块系统的一部分，它们如何与模块系统的两个目标——强封装和可靠配置——相一致？
- en: Let's begin with strong encapsulation. Services provide an alternative way of
    having types in modules interact with one another, which does not involve having
    to expose types to all consuming modules. The service provider packages do not
    have to be `exported` and thus they are encapsulated even from modules that *read*
    the module containing the service! At the same time, they are published as implementations
    of a service type, and thus can be used by modules that do not even *read* the
    service implementation module. So, in a way, the types are still encapsulated,
    although not in the same way as what we've seen so far.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从强封装开始。服务提供了一种模块中类型之间交互的替代方式，这种方式不需要将类型暴露给所有消费模块。服务提供者包不需要被`导出`，因此它们甚至被封装在包含服务的模块*读取*者之外！同时，它们作为服务类型的实现被发布，因此可以被那些甚至*不读取*服务实现模块的模块使用。所以，从某种意义上说，类型仍然被封装，尽管不是我们之前看到的那种方式。
- en: How about reliable configuration? Since the service providers and the service
    consumers *declare* the fact that they are providing and consuming services respectively,
    it's easy for the runtime and the `ServiceProvider` API to make sure that the
    right consumers get the right services. However, you can easily compile a bunch
    of modules without any service implementations available in the module path.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那可靠配置呢？由于服务提供者和服务消费者*声明*了他们分别提供和消费服务的事实，运行时和`ServiceProvider` API可以很容易地确保正确的消费者获得正确的服务。然而，你可以轻松地编译一大堆模块，而模块路径中没有任何服务实现可用。
- en: 'For example, you can delete the `packt.sort.bubblesort` and `packt.sort.javasort`
    modules from your source code and compile the rest of the modules. It works! You
    can execute the `Main` module. It still works, although the `ServiceProvider`
    API does not find any service instances. We are returning `null` in our example,
    but we could easily handle this scenario by providing a default service implementation
    (assuming there''s a default implementation called  `DefaultSortImpl`) in case
    nothing is found:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以从你的源代码中删除`packt.sort.bubblesort`和`packt.sort.javasort`模块，并编译其余的模块。它工作得很好！你可以执行`Main`模块。尽管`ServiceProvider`
    API没有找到任何服务实例，它仍然可以工作。在我们的例子中，我们返回`null`，但我们可以很容易地通过提供默认服务实现（假设有一个名为`DefaultSortImpl`的默认实现）来处理这种情况，以防找不到任何实现：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Why is this? When there's a module that clearly declares itself as a service
    consumer, why do the compiler and runtime not check if at least one service implementation
    is available? The reason is, it is by design. Service dependencies are *meant*
    to be optional. Remember the concept of loose coupling we started the chapter
    with. We want to be able to plug-and-play service consumers and providers at runtime.
    This works perfectly well with services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？当一个模块明确声明自己是服务消费者时，为什么编译器和运行时不会检查是否至少有一个服务实现可用？原因是，这是设计上的考虑。服务依赖关系*旨在*是可选的。记住我们在本章开头提到的松耦合概念。我们希望能够在运行时插拔服务消费者和提供者。这对于服务来说工作得非常好。
- en: 'The reliable configuration checking of the platform, however, does come into
    play when there''s a service module that does not have some of its dependencies
    met. For example, let''s say we have a service consumer module **C**. You can
    compile and execute this module without the presence of a service provider. In
    the following picture, the Java platform won''t complain:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当服务模块没有满足其某些依赖关系时，平台的可靠配置检查确实会发挥作用。例如，假设我们有一个服务消费者模块**C**。你可以编译并执行这个模块，而不需要服务提供者的存在。在下面的图片中，Java平台不会抱怨：
- en: '![](img/00072.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00072.jpeg)'
- en: 'However, if you do add a provider module, you''ll need to make sure it has
    all the dependencies met. For instance, let''s say you drop in a provider module
    **P** that provides an implementation for the service that **C** needs. Now this
    provider module needs to follow all the rules for reliable configuration. If this
    module reads module **D** and module **D** doesn''t exist as an observable module,
    the platform complains:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你确实添加了一个提供者模块，你需要确保它满足了所有依赖关系。例如，假设你添加了一个提供者模块**P**，它为**C**所需的服务提供了实现。现在这个提供者模块需要遵循所有可靠的配置规则。如果这个模块读取模块**D**，而模块**D**作为一个可观察的模块不存在，平台会抱怨：
- en: '![](img/00073.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00073.jpeg)'
- en: It seems strange that while the platform was perfectly fine when there was no
    provider module available, it complains when a provider module exists, but it
    doesn't have a dependency met. Why could it not ignore module **P** then? The
    answer is, again, reliable configuration. The absence of a provider module could
    be intentional. But if the platform finds a module that it could technically use,
    but cannot, because of an unmet dependency, that indicates a *broken* state, and
    thus, it errors out accordingly. Even allowing loose coupling through services,
    the platform is essentially trying the best it can to provide reliable configuration
    for us.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很奇怪，当没有提供者模块可用时，平台运行良好，但当存在提供者模块但未满足依赖关系时，它却会抱怨。为什么它不能忽略模块 **P** 呢？答案是，又是可靠的配置。没有提供者模块可能是故意的。但如果平台发现了一个它技术上可以使用但无法使用（因为未满足依赖关系）的模块，这表明是一个
    *损坏* 的状态，因此它会相应地出错。即使通过服务允许松耦合，平台也在尽其所能为我们提供可靠的配置。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've taken a detailed look at the services feature in the
    Java module system. We've learned the disadvantages of tight coupling of modules,
    and how loose coupling provides more flexibility. We then dove right into the
    syntax of creating and using services and then implemented a sorting service with
    two provider implementations. We then looked at some advanced concepts related
    to services, such as mechanisms for prioritizing service instances, using the
    service interface itself to handle service lookup, and deferring service instance
    creation using the `Provider` type in the case of heavy-weight services.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了 Java 模块系统中的服务功能。我们学习了模块紧密耦合的缺点，以及松耦合如何提供更多灵活性。然后我们深入研究了创建和使用服务的语法，并实现了具有两个提供者实现的排序服务。接着，我们探讨了与服务相关的一些高级概念，例如优先级服务实例的机制、使用服务接口本身来处理服务查找，以及在重量级服务的情况下使用
    `Provider` 类型来延迟服务实例的创建。
- en: We then revisited the two goals of modularity--strong encapsulation and dependency
    injection--and evaluated how the services feature impacts those goals.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了模块化的两个目标——强封装和依赖注入——并评估了服务功能对这些目标的影响。
- en: In the next chapter, we'll learn about the new *linking* phase that now applies
    to Java development thanks to modularity features. We'll also revisit the problem
    of the monolithic JDK that we discussed in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*, How can we make that better? How can we leverage
    the concepts of modularity to create leaner and meaner runtimes that are smaller
    and perform better? The answers to these questions and much more can be found
    in the next chapter!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解由于模块化特性而新应用于 Java 开发的 *链接* 阶段。我们还将回顾在 [第 1 章](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb)
    中讨论的单一 JDK 的问题，*介绍 Java 9 模块化*，我们如何能做得更好？我们如何利用模块化的概念来创建更精简、性能更优的运行时？这些问题的答案以及更多内容将在下一章中找到！
