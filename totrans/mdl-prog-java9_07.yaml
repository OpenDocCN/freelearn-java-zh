- en: Introducing Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about yet another exciting new feature in Java
    modularity called **services**. Services offer an additional layer of indirection
    between modules when compared to direct dependencies, and we will see that they add
    extra flexibility to how we can get modules to work with each other. In this chapter,
    you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand one of the limitations of module dependencies the way we have been
    doing things so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what services are and how they solve this problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to create and expose services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to consume services using the `ServiceLoader` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we learn what services are, let's examine and understand the actual problem
    that they were created to solve. It's the problem of tight coupling between modules
    with direct dependencies, at least the way we've been hooking them up so far.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The phrase **tight coupling** in programming is referred to situations where
    two entities are so highly dependent on each other that in order to change either
    of their behavior or relationship, it is required to make actual code changes
    to one (or often both) of those entities. The term **loose coupling**, on the
    other hand, refers to the opposite scenario--entities that are not highly dependent.
    In such cases, entities ideally don't even know about each other's existence,
    but can still be made to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, what would you say the coupling of two modules in the Java
    module system could be called? When one module depends on another, are the two
    modules tightly coupled or loosely coupled? The answer is obviously that they
    are tightly coupled. Think of the following facts that apply to module relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules need to explicitly state which other modules they depend on. In that
    sense, each module is *aware of* the existence of other modules it needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are also coupled to and *aware of* the APIs exposed by the dependent
    modules. If module A reads module B and calls an API, it is by using the actual
    Java type that is available in and exported from module B. Thus, module A knows
    the internals of module B, at least as much as the types exported by module B
    and used by module A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these two factors, it is obvious that this kind of tight coupling
    results in a very *strict* and *rigid* behavior of the modules at runtime. Consider
    the address book viewer application. The set of modules compiled is the exact
    set of modules that is involved in execution at runtime. Once modules are compiled,
    there's no way you can remove one of those modules, replace it with something
    else, and execute them. The modules involved have to be *exactly* the same. Although
    we get an impression of Java 9 modules being building blocks that can be assembled
    into multiple combinations, that advantage only applies to development time. What
    we've seen so far is that once the modules are coded and the dependencies established,
    the result is pretty much a cohesive, unalterable monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Now you might wonder, *Well, isn't that what we want?* The benefits of *reliable
    configuration* require a strict check to make sure the exact modules we intend
    to have are present, don't they? Well, yes, but we could still have runtime flexibility
    without giving up reliable configuration. An analogous example for that is in
    the Java language itself. Even though Java is strictly typed, you can achieve
    powerful runtime flexibility and loose coupling between types by using the concepts
    of polymorphism. The idea is that classes don't directly depend on each other.
    Instead, they depend on abstract classes or interfaces. At runtime, instances
    of those interfaces can be dynamically initialized and used anywhere the interface
    is used. Could we have something similar to this with modules? If so, how would
    it work?
  prefs: []
  type: TYPE_NORMAL
- en: Let me give you an example. We have a sorting utility module called `packt.sortutil`
    that has an API to sort lists. We have configured the module to export an interface
    and encapsulate an implementation, but in reality, that distinction is currently
    useless. It has only one implementation, and all that the module can do now is
    bubble sort. What if we wanted to have multiple sorting modules and we let the
    consuming module choose which sorting algorithm to use?
  prefs: []
  type: TYPE_NORMAL
- en: 'Current:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we''d like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We'd like to be able to use multiple modules providing different implementations
    of sorting in our application. However, thanks to tight coupling, in order for
    a module to use another module, it has to *require* it. This means that the consumer
    `packt.addressbook` module has to declare `requires` on each and every one of
    those different implementation modules it might need, even though, at any time,
    it might possibly be using just one. Wouldn't it be nice if there was a way you
    could define an interface type somewhere and have the *consumer* module depend
    only on that? Then the different *provider* modules with different sorting algorithms
    just provide implementations of the interface that you can plug in at runtime
    without needing explicit dependencies, and with no coupling between the actual
    consumer and the various implementation modules?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what we''d like. Rather than `packt.addressbook`
    requiring all of the modules that provide the implementation logic, it instead
    requires a single module that somehow acts as an interface, and has some mechanism
    to get the implementations dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.gif)'
  prefs: []
  type: TYPE_IMG
- en: By now you must have guessed that anytime I ask the *Wouldn't it be nice ...*
    question, it probably means that such a feature already exists! At least in this
    case, it's true. This is where services come in. The concept of services and the
    Service API together add a whole new layer of indirection on top of the existing
    modularity concepts you've learn so far. Let's dive into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin our journey of understanding services with a concept that you
    should be very familiar with as a Java developer--polymorphism. It starts with
    one interface and (possibly multiple) implementations of that interface. Although
    interfaces are not strictly *necessary* for services, they are still a good place
    to start. Let''s say you define a service interface called `MyServiceInterface`
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now you can have multiple modules containing classes that implement this interface.
    Since all those modules need access to this interface, let's throw this interface
    into a module of its own, called `service.api`, and expose the package that the
    interface `MyServiceInterface` is in. Then each implementation module can require
    the `service.api` module and implement `MyServiceInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider there are three implementations of `MyServiceInterface` in three corresponding
    modules. Since they need the interface to implement it in the first place, all
    three implementation modules *read* the `service.api` module to get access to
    `MyServiceInterface`. Imagine each module does just that, and that each contains
    a class that implements `MyServiceInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the consumer module needs to call one of these implementations to actually
    run the service. The goal here is not to have the consumer module directly *read*
    the various implementation modules, since that''s tight coupling. What we want
    is for the consumer module to read just the *interface* module `service.api` and
    deal with the interface type only, but still somehow manage to get access to instances
    of that interface''s implementations. Remember, we *do not* want the consumer
    to require the individual implementation modules (the *Xs* in the following diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to cross this bridge between the consumer and the implementation without
    direct tight coupling, imagine a layer between them called *the service registry*.
    The service registry is a layer provided by the module system to record and register
    implementations of a given interface as *services*. Think of it as a kind of phone
    book or yellow pages, but for services. Any module that implements a service needs
    to register itself in the service registry. Once that''s done, the service registry
    has all the information about the different service implementations of the interface
    that are available. The following diagram illustrates this interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now when the consumer needs an implementation, it uses the services API to
    talk to the service registry and get instances of the available implementations.
    The following diagram illustrates this interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What the consumer module gets is an `Iterable` of instances of all available
    implementations. There doesn't have to be multiple instances, of course. There
    could be just one implementation! Either way, the Service API hands over the available
    instances to the consumer when accessed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have broken the coupling between the *provider* and the *consumer*.
    Every module in this figure reads just one module in common--the module containing
    the interface. The interface is the only **common** entity that all these different
    modules share, since that's the means of the interaction between them. Since the
    other modules are completely unaware of each other, you could pretty much remove
    one implementation module and drop in another. As long as it does the right things--that
    is, implements the right interface and registers with the service registry--it
    is available for the consumer to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've understood the concept of services at a high level, let's get
    into the specifics. How do the modules *register* their implementations? How does
    the consumer module access the instances from the registry? Let's look at the
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the end-to-end steps to create, register, and implement a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create the Java type that defines the service**: Every service is based off
    of a single Java type that defines the service API. The type could be an interface,
    an abstract class, or even a regular Java class. Most of the time, the service
    type will be an interface. Having an interface is ideal because that way, you
    can have multiple implementation types for it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service type is the means through which both the providers and consumers
    talk to each other. This begs the question of which module the service type should
    be in? Since it is shared by multiple modules, and we don't want the providers
    and consumers to be tightly coupled, the ideal solution is to create the service
    types in a separate module. This module exports the service type and is read by
    both the provider and consumer modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, that would be the module `service.api`. It exports the package
    `service.api`, thereby exporting the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This module contains the interface `service.api.MyServiceInterface`, as previously
    shown. This fully qualified interface type name itself is the service type. Services
    in the Java module system don't have special names. They are simply referred to
    by the name of the Java type that acts as the service.
  prefs: []
  type: TYPE_NORMAL
- en: '**Create one or more implementation modules that read the interface module
    and implement the interface**: For example, if you need to have two modules `service.implA`
    and `service.implB` that provide two implementations of `MyServiceInterface`,
    both the modules will *require* the `service.api` module to access the interface.
    They each have an implementation of the `MyServiceInterface` interface. Each implementation
    of the service interface is referred to as a *service provider*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Have the implementation modules register themselves as service providers**:
    This is the part where the implementation modules tell the service registry that
    they would like to register their implementation of the interface. This is done
    in the module descriptor by using a new keyword called  `provides` and specifying
    both the interface and the implementation type information. The syntax is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if the module `service.implA` has the implementation class `packt.service.impla.MyServiceImplA`
    that implements `MyServiceInterface`, the module definition should read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is sufficient for the module system to know that this module would like
    to register the `MyServiceImplA` class as a service that provides for the interface
    `MyServiceInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few observations here:'
  prefs: []
  type: TYPE_NORMAL
- en: Note the fully qualified name for both the interface and implementation types.
    This is important in order to avoid name conflicts and make sure the Java platform
    knows exactly which types you are referring to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the interface type referred to in the `provides` clause does not belong
    to the module itself. It's in a completely different module that this module reads
    from (using the `requires` clause)! But that's okay; it works. However, it's important
    for the implementation class to be in the module that the module descriptor belongs
    to. This makes sense when you consider the fact that with the `provides` line
    of code, the module is essentially claiming to provide the implementation mentioned.
    So, it had better have it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an observation about what's *not* in the preceding module descriptor.
    Notice that we haven't added an `exports` clause here in order to make the `MyServiceImplA`
    class accessible to other modules. When providing services, you don't have to
    expose the implementation classes and make them accessible. This is because this
    class is not accessed with the usual module *readability* and *accessibility*
    relationships that we've been working with so far. The consumer module will get
    the instance of the implementation through the service APIs and does not read
    the module directly. That's the point of services after all, to avoid this tight
    coupling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this step, we have now successfully registered the service providers with
    the module system. Every implementation that does this is now mapped to the service
    *name* which is, for all practical purposes, the fully qualified interface name--`service.api.MyServiceInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s turn our attention to the consumer module. Getting the consumer
    module to have access to the service implementation instances is a two-part process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Have the consumer module register itself as a consumer of the service**:
    Just like the service providers *register* their intent to provide implementations,
    the service consumers need to *register* the fact that they''ll need to *use*
    the service. The module that needs the instances will have to formally declare
    this need in the module descriptor. This is done using the `uses` keyword. The
    syntax is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, if we have a module named consumer that needs instances of
    `MyServiceInterface`, the module definition will read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is sufficient for the module system to know that this is a module that
    will use a service implementation instance of the mentioned interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few observations:'
  prefs: []
  type: TYPE_NORMAL
- en: The consumer module too `requires` the module that exposes the interface. It
    has to, because when the module requests service instances from the service API,
    what it'll get back are instances that are of the same type as the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the `uses` clause is referring to a type that's not available in the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you must have guessed, there's no direct dependency on any of the implementation
    modules. Loose coupling for the win!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this step, on the one hand, we have the provider modules register their
    implementations with the service registry. And on the other hand, we have the
    consumer module register that it is a consumer of the service. Now, how does the
    code in the consumer module get access to the instances of the provider implementations?
    This is the final step, and this involves calling the `ServiceLoader` API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Call the** **ServiceLoader** **API to access the provider instances in the
    consumer module''s code**: With no direct dependencies, the service implementation
    types are completely unknown to the consumer. All it has is the interface type.
    So, there''s no way it can instantiate types using `new`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to access all registered implementations of the service, you''ll need
    to call the Java platform API `ServiceLoader.load()` method in the consumer module''s
    code. Here''s the code to get all registered service provider instances of the
    interface `MyServiceInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What the API returns is an `Iterable` of all available implementations of the
    service that have been registered in the Service Registry. Thanks to the return
    type being `Iterable`, you can loop through the instances and maybe pick one of
    them. Or you could even use all! It really depends on the application need and
    what it's trying to do. What's important to note is that each one of the objects
    in this `Iterable` is an instance of the provider implementation types that were
    registered in step 3 of creating services mentioned earlier. There could be several
    other classes that implement the interface, but if they aren't registered using
    the `provides` syntax, they will not be considered in this process.
  prefs: []
  type: TYPE_NORMAL
- en: There's a common pattern in many Enterprise Java frameworks that's used to handle
    various implementations of services and is accessed through the interface. It's
    called *Dependency Injection*. This pattern is available in frameworks such as
    Spring, as well as Java EE technologies like EJB. This pattern requires the consumer
    classes to simply *declare* dependency on services. The framework then performs
    the job of creating instances and automatically *injecting* them to the consuming
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing here is ***not*** that. There's no automatic injection of
    instances to the consuming code. As you've noticed, you have to write code that
    uses `ServiceLoader` to *look up* provider instances. This is by design, and is
    an important distinction to make when compared to those other patterns. This is
    a *dependency lookup*, not *dependency injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sorting services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an understanding of how to create and consume services, let''s
    put this to practice in the address book viewer application. We''ll create multiple
    sorting implementation modules and register these implementations as services.
    We''ll then update the `packt.addressbook` module to use the `ServiceLoader` API
    to get the sorting instances, and then use one of these instances to sort the
    contacts list. Let''s run through the five steps we''ve just learned in order
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create the Java type that defines the service**: We''ll retain the interface
    `SortUtil` to be the common interface that various implementation types will use.
    The `packt.sortutil` module contains both the interface and implementation types
    now. We''ll remove the implementation and leave just the interface in there. We''ll
    also remove the default static dependency on `BubbleSortUtilImpl` and make this
    a pure and abstract interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the only type in the `packt.sortutil` module. The module exports
    the `packt.util` package to make the interface available to both the providers
    and consumers. Here''s `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Create one or more implementation modules that read the interface module
    and implement the interface**: Let''s create a couple of implementation modules--`packt.sort.bubblesort`,
    which provides the BubbleSort implementation, and `packt.sort.javasort`, which
    provides an implementation using the default sorting API of Java collections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you don't put both the implementation classes in the two modules in
    the same package. For example, both the implementation classes cannot be in the
    same `packt.util.impl` package, because then you'll run into the problem of split
    packages, with both modules containing the same package, and the runtime will
    throw an error. We've covered the split packages problem in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*.
  prefs: []
  type: TYPE_NORMAL
- en: Both the modules `requires` the module `packt.sortutil` in order to access the
    `packt.util.SortUtil` interface. Each has an implementation of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `BubbleSortUtilImpl`, which is a class we''ve already seen, so here''s
    the truncated version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s `JavaSortUtilImpl`, which simply uses the `Collections.sort` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Have the implementation modules register themselves as service providers**:
    Let''s register both the implementation modules as providers using the `provides`
    keyword. The service type is the interface `packt.util.SortUtil` and the implementation
    types are the two implementation classes in the two modules, respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the `module-info.java` file for the `packt.sort.bubblesort` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the `module-info.java` file for the `packt.sort.javasort` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Have the consumer module register itself as a consumer of the service**:
    We''ll be needing instances of `SortUtil` in the `packt.addressbook` and `packt.addressbook.ui`.
    I''ll showcase the steps in the `packt.addressbook` module alone here, because
    it has relatively fewer things going on. But the steps are the same and need to
    be applied to both modules.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the module descriptor of `packt.addressbook` with the `uses` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Call the** **ServiceLoader** **API to access the provider instances in the
    consumer module''s code**: In `Main.java`, use the `ServiceLoader` API to get
    all provider instances of `SortUtil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, iterating through, you can access each instance. I''ll loop through and
    sort the list using *both* of the sorting implementations. This is clearly unnecessary,
    but it''s just for illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And we are done! You've used the service mechanism to create, register, and
    use sorting service implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you apply the same changes to the `packt.addressbook.ui` module as
    well! If not, the compilation step will fail for that module, for obvious reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling and running the code now should work without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, there have been two instances of `SortUtil`
    returned by `ServiceLoader`, corresponding to the two implementations we have
    registered.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the module graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s draw the module graph that represents the interaction between the service
    provider and consumer modules. We know how to represent *readability* relationships.
    How about service consumer and provider dependencies? The following diagram uses
    arrows to depict both the **uses** and **provides** dependencies, with labels
    to identify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.gif)'
  prefs: []
  type: TYPE_IMG
- en: The lack of dependencies between the consumer and provider modules is the key
    to loose coupling that is enabled using services.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The services concepts covered so far should address a lot of typical use cases,
    but there are a few additional features and concepts that might come in handy
    in certain special scenarios. We'll look at a few such concepts in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting singleton and factory providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose your service instances cannot be created simply by a constructor. What
    if you need to reuse instances, maybe to have a singleton provider instance? Or
    maybe execute some logic whenever a new service instance is created? There is
    a handy feature of services that lets you create factory methods to get service
    instances. All you need to do is add a method with the name `provide()` in your
    provider classes. The method needs to be a public static method and it shouldn't
    take any arguments. Also, the return type should be the same as the type of the
    service being provided. If the `ServiceLoader` sees this method, it calls it,
    and uses the return of the method as the service instance. If it doesn't find
    such a method, it calls the public no-args constructor like we've already seen.
    This allows you to hook into the provider instance creation step, and here you
    can execute any necessary code, as well as get an opportunity to create the object
    that the `ServiceLoader` will use as the provider instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service priorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example, we got two instances of `SortUtil`, and we did something
    ridiculous with them--we sorted the list twice, once per implementation! You wouldn't
    typically do that. What you'll most likely need to do in applications when you
    receive more than one service implementation is something a bit trickier. You'll
    need to choose one!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately there is no way you can give service implementations distinct
    priorities. So, there's no way you can say something like `BubbleSortUtilImpl`
    is your favorite sort implementation, and that's the implementation to be used
    if it's available, irrespective of whatever other implementations are found. As
    per design, it's not the responsibility of the service implementations to specify
    priority. It's the job of the consumer to decide what to do with the multiple
    implementations it receives from `ServiceLoader`, since the *best* service implementation
    for the job is usually dependent on the consuming application itself. What is
    the best service implementation for one consumer might not be ideal for another.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how does the consumer choose one provider among all available ones? All
    it sees is a bunch of instances of the same interface! So, what we do is enhance
    the interface to contain methods that the consumer can use to query provider instances.
    The consumer calls these methods to find out more about the provider classes and
    thus make an informed decision about which provider instances it would like to
    go with.
  prefs: []
  type: TYPE_NORMAL
- en: Take the case of the `SortUtil` implementations. Let's assume we want to use
    the sorting algorithm depending on the size of the list. For instance, let's say
    we wish to choose bubble sort only if the list is very small, but use the `Collections`
    API sorting for larger lists.
  prefs: []
  type: TYPE_NORMAL
- en: What we could do is add a method to the `SortUtil` interface called `getIdealInputLength()`.
    Each implementation then provides an integer length that it can deal with ideally.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort is far from the best sorting algorithm you can use. It's an algorithm
    many programming courses use to teach sorting, but in reality it's horribly inefficient.
    For the sake of our simple example, let's say we use bubble sort on lists that
    are four elements or smaller, and use `Collections` sort for the rest. I'll admit
    this is a contrived example, but it'll let us implement a basic strategy for choosing
    providers. In reality, you'd almost always want to use the `Collections` API for
    sorting lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `SortUtil` with the new method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `BubbleSortUtilImpl` implementation of this method that returns
    `4` as the ideal maximum size of the input list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JavaSortUtilImpl` is OK with any list size, so for the ideal maximum,
    we''ll just return the maximum integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that each provider has a method that can be used to choose one implementation
    over the other, the consumer can use this to identify which of the implementations
    it would like to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the section in `Main.java` (in both the `pack.addressbook` and `packt.addressbook.ui`
    modules) that loops through the providers to pick one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Given the size of the `contacts` list we'd like to sort, we'll check each provider
    to see if the list size is greater than the maximum size the provider would ideally
    like to handle. We then pick the first provider that passes this check, use that
    instance to sort the list, and `break` off the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and observe the output. If the `BubbleSortUtilImpl` is the first
    instance in the iterator, the logic skips it and moves to the `JavaSortUtilImpl`
    and uses it to sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example of how provider implementations give *clues* about
    the implementation to any consumers. Different consumers could then choose different
    implementations, depending on their unique needs and business problems.
  prefs: []
  type: TYPE_NORMAL
- en: Service interface provider lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lookup logic to get service instances is now in the Main classes in both
    the `packt.addressbook` and `packt.addressbook.ui` modules. This is less than
    ideal. We don't want to repeat the lookup logic in multiple places. One way to
    solve this is to move the logic to a common place that's accessible by all the
    consumers of the service. Now, what's the module that's shared by every consumer
    of the service? It's the module that exports the interface. Wouldn't it be a great
    idea to move the dependency lookup logic and tuck it away as a default method
    in the interface? Then none of the consumer modules would need to mess with the
    `ServiceLoader` APIs directly. They would just have to call the right interface
    method to look up the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create two new methods on the `SortUtil` interface. One to get all service
    provider instances, and the second to get single instances based on the size of
    the list (which is a criterion that affects which instance is picked, like we've
    already seen).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two new static methods on `SortUtil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we are returning `null` if no service instances that matched our requirement
    were found. This could easily be enhanced to provide a default service in case
    a suitable instance wasn't found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `Main` doesn''t have to talk to `ServiceLoader` and loop through instances
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: I hope you'll agree that the consumption of the service has become much simpler
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other change you''ll have to do is to move the  `uses` clause from the
    `packt.addressbook` and `packt.addressbook.ui` modules to the `packt.sortutil`
    module. That''s because the service is consumed and the `ServiceLoader` APIs are
    invoked from the `packt.sortutil` module now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the code should give you the same output as before. But
    this time, the service lookup logic is now refactored into a common module usable
    by all consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Selective service instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we have queried the `ServiceLoader` APIs to get *all*
    provider instances in an `Iterable`. We then looped through them and picked one.
    This is not a problem here because our services are simple and lightweight Java
    classes. That may not always be ideal. Imagine if services are more complex and
    need time and resources to instantiate. In such cases, you wouldn't want to instantiate
    every service provider when you know you won't use all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The Java module system is quite smart about how it manages service instances
    in an application. First of all, all service instances are *lazily loaded*. In
    other words, service provider instances are not automatically instantiated when
    the application starts up. The runtime creates a service instance only when the
    type is needed, like when some consumer asks for instances of the service using
    `ServiceProvider.load()`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, any service instances that are created during the lifetime of the
    application are always cached. The service loader maintains this cache and keeps
    track of all the service instances that have been created. When the second consumer
    requests the service, the instance is fetched off of the cache directly. It also
    intelligently makes sure that the order of the service instances returned always
    includes the cached instances first.
  prefs: []
  type: TYPE_NORMAL
- en: Caching is automatic with service instances. If you want to clear the entire
    service provider cache during application execution, you can do so using the `ServiceProvider.reload()`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServiceLoader` API has an option of streaming instances of an intermediate
    type called `Provider`, which can then be used to create service provider instances.
    Rather than getting all the service instances directly, what you get instead is
    `Provider` instances--one instance per service implementation found. You can then
    instantiate only the service providers you want by using the `Provider.get()` method
    on those instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the `getProviderInstanceLazy()` method on `SortUtil`.
    Rather than directly use `ServiceLoader.load(SortUtil.class)`, we can instead
    use `ServiceLoader.load(SortUtil.class).stream()`, which returns a `Stream` of
    `Provider` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Provider` instances can then be inspected for things such as annotations
    and other type information. Here, we are just sorting them by type name, which
    is silly, but it works as a minimal example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, no service instances are created. The actual instantiation of
    the service provider types happens when the `Provider.get` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we call `Provider.get()` on each provider instance through
    the map function and pick one. This way, we can defer the creation of instances
    as well as selectively instantiate provider types by calling `Provider.get` only
    on the ones we need.
  prefs: []
  type: TYPE_NORMAL
- en: Services and the module system goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since services are a part of the Java module system, how do they align with
    the two goals of the module system--strong encapsulation and reliable configuration?
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with strong encapsulation. Services provide an alternative way of
    having types in modules interact with one another, which does not involve having
    to expose types to all consuming modules. The service provider packages do not
    have to be `exported` and thus they are encapsulated even from modules that *read*
    the module containing the service! At the same time, they are published as implementations
    of a service type, and thus can be used by modules that do not even *read* the
    service implementation module. So, in a way, the types are still encapsulated,
    although not in the same way as what we've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: How about reliable configuration? Since the service providers and the service
    consumers *declare* the fact that they are providing and consuming services respectively,
    it's easy for the runtime and the `ServiceProvider` API to make sure that the
    right consumers get the right services. However, you can easily compile a bunch
    of modules without any service implementations available in the module path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can delete the `packt.sort.bubblesort` and `packt.sort.javasort`
    modules from your source code and compile the rest of the modules. It works! You
    can execute the `Main` module. It still works, although the `ServiceProvider`
    API does not find any service instances. We are returning `null` in our example,
    but we could easily handle this scenario by providing a default service implementation
    (assuming there''s a default implementation called  `DefaultSortImpl`) in case
    nothing is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Why is this? When there's a module that clearly declares itself as a service
    consumer, why do the compiler and runtime not check if at least one service implementation
    is available? The reason is, it is by design. Service dependencies are *meant*
    to be optional. Remember the concept of loose coupling we started the chapter
    with. We want to be able to plug-and-play service consumers and providers at runtime.
    This works perfectly well with services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reliable configuration checking of the platform, however, does come into
    play when there''s a service module that does not have some of its dependencies
    met. For example, let''s say we have a service consumer module **C**. You can
    compile and execute this module without the presence of a service provider. In
    the following picture, the Java platform won''t complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if you do add a provider module, you''ll need to make sure it has
    all the dependencies met. For instance, let''s say you drop in a provider module
    **P** that provides an implementation for the service that **C** needs. Now this
    provider module needs to follow all the rules for reliable configuration. If this
    module reads module **D** and module **D** doesn''t exist as an observable module,
    the platform complains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It seems strange that while the platform was perfectly fine when there was no
    provider module available, it complains when a provider module exists, but it
    doesn't have a dependency met. Why could it not ignore module **P** then? The
    answer is, again, reliable configuration. The absence of a provider module could
    be intentional. But if the platform finds a module that it could technically use,
    but cannot, because of an unmet dependency, that indicates a *broken* state, and
    thus, it errors out accordingly. Even allowing loose coupling through services,
    the platform is essentially trying the best it can to provide reliable configuration
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken a detailed look at the services feature in the
    Java module system. We've learned the disadvantages of tight coupling of modules,
    and how loose coupling provides more flexibility. We then dove right into the
    syntax of creating and using services and then implemented a sorting service with
    two provider implementations. We then looked at some advanced concepts related
    to services, such as mechanisms for prioritizing service instances, using the
    service interface itself to handle service lookup, and deferring service instance
    creation using the `Provider` type in the case of heavy-weight services.
  prefs: []
  type: TYPE_NORMAL
- en: We then revisited the two goals of modularity--strong encapsulation and dependency
    injection--and evaluated how the services feature impacts those goals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the new *linking* phase that now applies
    to Java development thanks to modularity features. We'll also revisit the problem
    of the monolithic JDK that we discussed in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*, How can we make that better? How can we leverage
    the concepts of modularity to create leaner and meaner runtimes that are smaller
    and perform better? The answers to these questions and much more can be found
    in the next chapter!
  prefs: []
  type: TYPE_NORMAL
