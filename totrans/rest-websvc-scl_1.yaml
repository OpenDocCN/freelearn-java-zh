- en: Chapter 1. Getting Started with RESTful Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 使用RESTful Web服务入门
- en: Welcome to this book on how to create REST services with Scala. In this book,
    I'll introduce a couple of different Scala-based frameworks and show you how to
    create a RESTful service with them. Each of these frameworks has its own specific
    way of creating REST services; some are more functional, while others provide
    a rich **domain-specific language** (**DSL**). After reading this book and working
    through the examples, you'll be able to choose the approach that best suits you
    and your specific problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎阅读这本关于如何使用Scala创建REST服务的书籍。在这本书中，我将介绍几个不同的基于Scala的框架，并展示如何使用它们创建RESTful服务。每个框架都有其创建REST服务的特定方式；有些更注重函数式编程，而有些则提供了丰富的**领域特定语言**（**DSL**）。阅读完这本书并完成示例后，您将能够选择最适合您和您特定问题的方法。
- en: 'In this book, the following Scala frameworks will be discussed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将讨论以下Scala框架：
- en: '**Akka HTTP / DSL**: Akka HTTP is a new REST framework built on top of Akka
    Streams. It provides a DSL-based approach based on Spray. Spray is one of the
    best-known REST frameworks in the Scala world, and the newest version will run
    on top of Akka HTTP. We''ll explore the features of this DSL and show you how
    it can be used to create a REST service.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Akka HTTP / DSL**：Akka HTTP是在Akka Streams之上构建的一个新的REST框架。它提供了一个基于Spray的基于DSL的方法。Spray是Scala世界中最好的REST框架之一，其最新版本将在Akka
    HTTP之上运行。我们将探索这个DSL的功能，并展示如何使用它来创建REST服务。'
- en: '**Unfiltered**: Unfiltered is a little REST framework which provides a very
    structured approach of creating REST services. This framework provides direct
    access to all parts of the HTTP request, and doesn''t make assumptions on how
    you want to process REST services. This gives you complete control of how the
    request is processed and the response is produced.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unfiltered**：Unfiltered是一个小巧的REST框架，它提供了一种非常结构化的创建REST服务的方法。这个框架提供了对HTTP请求所有部分的直接访问，并且不对您如何处理REST服务做出假设。这使您能够完全控制请求的处理方式和响应的生成。'
- en: '**Play 2**: Play 2 is one of the most popular Scala frameworks, which provides
    functionality to create complete web applications. Play 2 also provides great
    support for creating standard REST services. We''ll focus on the REST-specific
    features of Play 2.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play 2**：Play 2是最受欢迎的Scala框架之一，它提供了创建完整Web应用程序的功能。Play 2还提供了创建标准REST服务的强大支持。我们将专注于Play
    2的REST特定功能。'
- en: '**Finagle** and **Finch**: Finagle and Finch both come from the people at Twitter.
    With Finagle and Finch, it is possible to create REST services using a clean,
    functional programming approach.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Finagle**和**Finch**：Finagle和Finch都来自Twitter团队。使用Finagle和Finch，您可以使用干净、函数式编程的方法创建REST服务。'
- en: '**Scalatra**: The last framework we''ll discuss is the Scalatra framework.
    Scalatra is a lightweight framework, based on the better-known Sinatra framework,
    with which it is very easy to create REST services.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scalatra**：我们将讨论的最后一个是Scalatra框架。Scalatra是一个轻量级框架，基于更为人所知的Sinatra框架，使用它来创建REST服务非常简单。'
- en: Besides these frameworks, in the last chapter of this book we'll also provide
    some guidelines on how to work with advanced topics such as HATEOAS, linking,
    and JSON processing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些框架之外，本书的最后一章还将提供一些关于如何处理高级主题（如HATEOAS、链接和JSON处理）的指导。
- en: 'In this first chapter, we are not going to explore a framework, but we''ll
    use this chapter to introduce some concepts and set up some tools:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会探索任何框架，而是将使用本章来介绍一些概念并设置一些工具：
- en: We'll first have to make sure you can run all the examples provided with this
    book, so we'll show you how to get the code and setup SBT and an IDE
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要确保您能够运行本书提供的所有示例，因此我们将向您展示如何获取代码并设置SBT和IDE
- en: We'll also do a short introduction into what RESTful services are
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将简要介绍RESTful服务是什么。
- en: And finally, we'll have a look at the API of the service that we'll implement
    using the different Scala frameworks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将查看我们将使用不同Scala框架实现的服务的API。
- en: There are many different definitions of REST, so before we look into the technical
    details, let's first look at the definition of REST we'll use in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST有很多不同的定义，所以在我们深入技术细节之前，让我们先看看本书中我们将使用的REST定义。
- en: Introduction to the REST framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST框架简介
- en: 'In this book, when we talk about REST, we talk about REST as described in the
    dissertation of Roy Fielding ([https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)).
    Basically, REST is a software architecture style, which, when following the guidelines,
    can be used to create performant, reliable, and maintainable services. To better
    understand what REST is, it is a good idea to start with the constraints a service
    must follow to be RESTful. In his dissertation, Roy Fielding defines the following
    set of constraints:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，当我们谈论REST时，我们谈论的是Roy Fielding的论文中描述的REST（[https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)）。基本上，REST是一种软件架构风格，遵循这些指南时，可以用来创建性能优良、可靠和可维护的服务。为了更好地理解REST是什么，一个好的起点是考虑一个服务必须遵循的约束，以成为RESTful的。在他的论文中，Roy
    Fielding定义了以下一组约束：
- en: '**Client-server**: This constraint means that clients and servers are separated
    from each other through a standardized interface. The advantage of this approach
    is that clients don''t need to worry about persistency, databases, messaging,
    scalability, and other server-side concepts; instead, they can focus on user-oriented
    functionality. Another advantage is that clients and servers can be developed
    independently since the only dependency between them is the standardized contract.
    Note that if you require a very strict contract between the client and the server,
    a WSDL/SOAP-based service might be a better option than going for a RESTful approach.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：这个约束意味着客户端和服务器通过一个标准化的接口相互分离。这种方法的优点是客户端不需要担心持久性、数据库、消息传递、可扩展性和其他服务器端概念；相反，它们可以专注于面向用户的功能。另一个优点是客户端和服务器可以独立开发，因为它们之间唯一的依赖关系是标准化的合同。请注意，如果您需要客户端和服务器之间非常严格的合同，基于WSDL/SOAP的服务可能比采用RESTful方法更好。'
- en: '**Stateless**: Besides having a separate client and server, communication between
    these two components will have to be stateless. This means that each request the
    client sends should contain all the information necessary for the server. Note
    that for authentication, the server can temporarily store some session/user information
    in a persistent store, but all the real application state should be stored at
    the client. The big advantage of this approach is that this way it is very easy
    to scale out the servers horizontally by just adding more instances.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：除了有独立的客户端和服务器之外，这两个组件之间的通信必须是状态无关的。这意味着客户端发送的每个请求都应该包含服务器所需的所有信息。请注意，对于认证，服务器可以暂时在持久存储中存储一些会话/用户信息，但所有真实的应用程序状态都应该存储在客户端。这种方法的一个大优点是，通过仅添加更多实例，可以非常容易地水平扩展服务器。'
- en: '**Cacheable**: In a RESTful architecture, clients are allowed to cache responses.
    It is up to the server side to indicate which responses might be cached and for
    how long. The goal of this constraint is to minimize interactions between the
    client and the server by avoiding sending requests, whose response will stay the
    same. This, of course, improves performance at the client side and reduces bandwidth.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：在RESTful架构中，客户端被允许缓存响应。由服务器端决定哪些响应可以被缓存以及缓存多长时间。这个约束的目的是通过避免发送那些响应将保持不变的请求，来最小化客户端和服务器之间的交互。这当然提高了客户端的性能并减少了带宽。'
- en: '**Layered system**: This constraint describes that in a RESTful architecture,
    it is possible to create a layered system, where each layer has its own specific
    functionality. For instance, in between the client and the server, there might
    be a firewall, a load balancer, a reverse proxy, and so on. The client, however,
    doesn''t notice these different layers.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：这个约束描述了在RESTful架构中，可以创建一个分层系统，其中每一层都有其特定的功能。例如，在客户端和服务器之间，可能会有防火墙、负载均衡器、反向代理等等。然而，客户端却不会注意到这些不同的层。'
- en: '**Uniform interface**: From all the constraints, this is perhaps the most interesting
    one. This constraint defines what a uniform interface (the contract between the
    client and the server) should look similar to. This constraint itself consists
    of the following four sections:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：在所有约束中，这可能是最有趣的一个。这个约束定义了统一接口（客户端和服务器之间的合同）应该看起来像什么。这个约束本身由以下四个部分组成：'
- en: '**Identification of resources**: In requests, each resource should be uniquely
    identified. Most often, this is done through a form of URI. Note that the technical
    representation of a resource doesn''t matter. A resource, identified through a
    URI, can be represented in JSON, CSV, XML, and PDF while still remaining the same
    resource.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的标识**：在请求中，每个资源都应该有唯一的标识。通常，这是通过一种URI形式来完成的。请注意，资源的技术表示并不重要。通过URI标识的资源可以用JSON、CSV、XML和PDF表示，同时仍然是同一资源。'
- en: '**Manipulation of resources through these representations**: When a client
    has a representation of a resource (for example, a JSON message), the client can
    modify this resource by updating the representation and sending it to the server.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过这些表示形式操作资源**：当客户端拥有资源的表示形式（例如，JSON消息）时，客户端可以通过更新表示形式并将其发送到服务器来修改这个资源。'
- en: '**Self-descriptive messages**: Each message sent between the client and the
    server should be self-descriptive. The client need not know anything else to be
    able to parse and process the message. It should be able to learn from the message
    exactly what it can do with the resource.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述消息**：客户端和服务器之间发送的每条消息都应该自描述。客户端不需要知道其他任何信息就能解析和处理消息。它应该能够从消息中确切地了解它可以对资源做什么。'
- en: '**Hypermedia as the engine of application state**: This constraint, also called
    **HATEOAS**, implies that a user of an API doesn''t need to know beforehand what
    it can do with a specific resource. Through the use of links in the resource and
    the definition of media-types, a client can explore and learn the actions it can
    take on a resource.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用状态引擎**：这个限制条件，也称为**HATEOAS**，意味着API的用户事先不需要知道它可以用特定的资源做什么。通过在资源中使用链接和定义媒体类型，客户端可以探索和学习它可以在资源上执行的操作。'
- en: '**Code on demand**: Code on demand is the only constraint that is optional.
    When comparing this constraint with the others, it is also one that is a bit different
    than the others. The idea behind this constraint is that servers could temporarily
    extend the functionality of clients by transferring executable code. In practice,
    this constraint is not seen that often though; most RESTful services deal with
    sending static responses, not executable code.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：按需代码是唯一可选的限制条件。当与其他限制条件进行比较时，它与其他限制条件也略有不同。这个限制条件背后的想法是，服务器可以通过传输可执行代码暂时扩展客户端的功能。在实践中，这个限制条件并不常见；大多数RESTful服务处理的是发送静态响应，而不是可执行代码。'
- en: It's important to note that these constraints don't say anything about an implementation
    technology.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些限制条件并没有说任何关于实现技术的事情。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Often, when talking about REST, people immediately focus on HTTP and JSON. A
    RESTful architecture doesn't force you to adopt these technologies. On the other
    hand, most often, RESTful architectures are implemented on top of HTTP and currently
    use JSON as the message format. In this book, we will also focus on using HTTP
    and JSON to implement RESTful services.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在讨论REST时，人们会立即关注HTTP和JSON。RESTful架构并不强迫你采用这些技术。另一方面，大多数情况下，RESTful架构是在HTTP之上实现的，目前使用JSON作为消息格式。在这本书中，我们也将关注使用HTTP和JSON来实现RESTful服务。
- en: The constraints mentioned here give an overview of how a service should act
    to be considered RESTful. However, when creating a service, it is often very hard
    to comply with all these constraints, and in some cases, not all the constraints
    might be that useful, or might be very hard to implement. Many people noticed
    this, and a couple of years ago, a more pragmatic view on REST was presented by
    Richardson's Maturity Model ([http://martinfowler.com/articles/richardsonMaturityModel.html](http://martinfowler.com/articles/richardsonMaturityModel.html)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的限制条件概述了服务应该如何行动才能被认为是RESTful的。然而，在创建服务时，通常很难遵守所有这些限制条件，在某些情况下，并非所有限制条件都可能非常有用，或者可能非常难以实现。许多人注意到了这一点，几年前，Richardson的成熟度模型（[http://martinfowler.com/articles/richardsonMaturityModel.html](http://martinfowler.com/articles/richardsonMaturityModel.html)）提出了一种更实际的REST观点。
- en: 'In Richardson''s Maturity Model, you don''t have to follow all the constraints
    to be considered RESTful; instead, a number of levels of maturity are defined
    that indicate how RESTful your service is. The higher the level, the more mature
    your service is, which will result in a more maintainable, more scalable, and
    easier-to-use service. This model defines the following levels:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Richardson 的成熟度模型中，您不必遵循所有约束才能被认为是 RESTful；相反，定义了多个成熟度级别，以表明您的服务有多 RESTful。级别越高，您的服务就越成熟，这将导致服务更易于维护、更易于扩展和更易于使用。此模型定义了以下级别：
- en: '![Introduction to the REST framework](img/00002.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![REST 框架简介](img/00002.jpeg)'
- en: 'The levels are described like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 级别是这样描述的：
- en: Level 0 describes the situation where you just send XML or JSON objects to a
    single HTTP endpoint. Basically, you're not doing REST, but you're doing RPC over
    HTTP.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 0 级描述了您仅向单个 HTTP 端点发送 XML 或 JSON 对象的情况。基本上，您没有做 REST，而是在 HTTP 上做 RPC。
- en: Level 1 tackles the question of handling complexity by using divide and conquer,
    breaking a large service endpoint down into multiple resources
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 1 级通过使用分而治之来处理复杂性，将大型服务端点分解成多个资源
- en: Level 2 introduces a standard set of verbs so that we can handle similar situations
    in the same way, removing unnecessary variation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 级引入了一套标准的动词，以便我们可以以相同的方式处理类似的情况，消除不必要的差异
- en: Level 3 introduces discoverability, providing a way of making a protocol more
    self-documenting
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 级引入了可发现性，提供了一种使协议更易于文档化的方法
- en: In this book, we'll mostly focus on supporting REST at Level 2\. So, we'll work
    with well-defined resources and use the appropriate HTTP verbs to indicate what
    we want to do with a resource.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将主要关注在第 2 级支持 REST。因此，我们将使用定义良好的资源，并使用适当的 HTTP 动词来指示我们对资源要做什么。
- en: In [Chapter 7](part0053_split_000.html#page "Chapter 7. JSON, HATEOAS, and Documentation"),
    *JSON, HATEOAS, and Documentation*, of this book, we'll address HATEOAS, which
    can help us reach maturity Level 3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第 7 章](part0053_split_000.html#page "第 7 章。JSON、HATEOAS 和文档")中，我们将讨论 HATEOAS，这可以帮助我们达到成熟度第
    3 级。
- en: Now that we've got the theory out of the way, let's get the code, set up your
    favorite IDE, and define the API for the REST service we'll implement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了理论问题，让我们获取代码，设置您最喜欢的 IDE，并定义我们将要实现的 REST 服务的 API。
- en: Getting the source code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源代码
- en: There are a couple of different ways of getting the code for this book. We provide
    a download link at the book's website ([https://www.packtpub.com/books/content/support/23321](https://www.packtpub.com/books/content/support/23321))
    from where you can download a ZIP file with the latest sources from GitHub ([https://github.com/josdirksen/rest-with-scala/archive/master.zip](https://github.com/josdirksen/rest-with-scala/archive/master.zip)),
    or even better, just use Git to clone the source repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取本书代码的方法有几个。我们在本书网站上提供了一个下载链接（[https://www.packtpub.com/books/content/support/23321](https://www.packtpub.com/books/content/support/23321)），您可以从那里下载
    GitHub（[https://github.com/josdirksen/rest-with-scala/archive/master.zip](https://github.com/josdirksen/rest-with-scala/archive/master.zip)）上的最新源代码的
    ZIP 文件，或者更好的是，直接使用 Git 克隆源代码库。
- en: Downloading the ZIP file
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载 ZIP 文件
- en: 'If you''ve downloaded the ZIP file, just unzip it to a directory of your choice:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已下载 ZIP 文件，只需将其解压到您选择的目录：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using Git to clone the repository
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Git 克隆仓库
- en: Cloning the repository is also very easy if you've already got Git installed.
    If you haven't got Git installed, follow the instructions at [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了 Git，克隆仓库也非常简单。如果您还没有安装 Git，请按照[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)中的说明操作。
- en: 'Once Git is installed, just run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Git，只需运行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, you've got the sources in a directory of your choice. Next, we
    need to make sure we can download all the frameworks' dependencies and run the
    samples. For this, we'll use SBT (more information can be found at [http://www.scala-sbt.org/](http://www.scala-sbt.org/)),
    which is the most common build tool for Scala-based projects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已将源代码放在您选择的目录中。接下来，我们需要确保我们可以下载所有框架的依赖项并运行示例。为此，我们将使用 SBT（更多信息可以在[http://www.scala-sbt.org/](http://www.scala-sbt.org/)找到），这是
    Scala 项目的最常用构建工具。
- en: Setting up Scala and SBT to run the examples
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Scala 和 SBT 以运行示例
- en: To run the examples provided in this book, we need to install Scala and SBT.
    Depending on your operating system, different steps need to be taken.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书中提供的示例，我们需要安装 Scala 和 SBT。根据你的操作系统，需要采取不同的步骤。
- en: Installing Java
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Java
- en: Before we can install SBT and Scala, we first need to install Java. Scala requires
    at least a Java Runtime version of 1.6 or higher. If you haven't installed Java
    on your system yet, follow the instructions at [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装 SBT 和 Scala 之前，我们首先需要安装 Java。Scala 至少需要 Java 运行时版本 1.6 或更高。如果你还没有在你的系统上安装
    Java，请按照 [http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)
    上的说明操作。
- en: Installing Scala and SBT
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Scala 和 SBT
- en: Once you have Java installed, installing Scala and SBT is just as easy. To install
    Scala, just go to [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)
    and download the binaries for your system. To install SBT, you can follow the
    instructions at [http://www.scala-sbt.org/download.html](http://www.scala-sbt.org/download.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Java，安装 Scala 和 SBT 就同样简单。要安装 Scala，只需访问 [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)
    并下载适合你系统的二进制文件。要安装 SBT，可以遵循 [http://www.scala-sbt.org/download.html](http://www.scala-sbt.org/download.html)
    上的说明。
- en: 'To check whether everything is installed, run the following commands in a terminal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否已安装所有内容，请在终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To exit SBT, hit *Ctrl* + *C*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 SBT，按 *Ctrl* + *C*。
- en: Running the examples
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Now that you''ve got Java, Scala, and SBT installed, we can run the examples.
    You can, of course, run the examples from your IDE (see the next section on how
    to set up IntelliJ IDEA and Eclipse), but often, using SBT directly is just as
    easy. To run the examples, take the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Java、Scala 和 SBT，我们可以运行示例。当然，你也可以从你的 IDE 中运行示例（参见下一节关于如何设置 IntelliJ
    IDEA 和 Eclipse），但通常直接使用 SBT 也很简单。要运行示例，请按照以下步骤操作：
- en: Open a terminal and go to the directory where you've extracted the source ZIP
    file or cloned the repository.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端并转到你提取源 ZIP 文件或克隆存储库的目录。
- en: 'To test the configuration, we''ve created a simple `HelloWorld` example. From
    the console, execute `sbt runCH01-HelloWorld`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试配置，我们创建了一个简单的 `HelloWorld` 示例。从控制台执行 `sbt runCH01-HelloWorld`：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might see a lot of output when the various dependencies are loaded, but
    after a while, you should see the message, `SBT successfully ran HelloWorld, configuration
    seems ok!`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当加载各种依赖项时，你可能会看到很多输出，但过一段时间后，你应该会看到消息，“SBT 成功运行 HelloWorld，配置看起来正常！”
- en: All the examples in this book wait for user input to terminate. So, once you're
    done playing around with the example, just hit *Enter* to terminate the running
    program.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书中的所有示例都等待用户输入以终止。所以，一旦你玩完示例，只需按 *Enter* 键即可终止正在运行的程序。
- en: 'In each chapter, we''ll see the `sbt` command we need to execute. If you want
    to know all the examples you can run, you can also run the `sbt` `alias` command,
    which generates the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章中，我们将看到需要执行的 `sbt` 命令。如果你想了解可以运行的所有示例，也可以运行 `sbt` `alias` 命令，它将生成以下输出：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Besides running the examples directly from the command line, it is also possible
    to run them from an IDE. In the following section, we'll see how to import the
    examples in IntelliJ IDEA and Eclipse.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接从命令行运行示例外，还可以从 IDE 中运行它们。在下一节中，我们将了解如何将示例导入 IntelliJ IDEA 和 Eclipse。
- en: Setting up the IDE
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 IDE
- en: With SBT and Scala installed, you have everything you need to run the examples.
    Sometimes, however, it is easier to play around and experiment with the examples
    directly from an IDE. The two most popular IDEs for working with Scala are IntelliJ
    IDEA and Eclipse. Both have great Scala plugins and excellent support for SBT.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 SBT 和 Scala 后，你就有了一切运行示例所需的东西。然而，有时直接从 IDE 中玩转和实验示例会更简单。Scala 工作中最受欢迎的两个
    IDE 是 IntelliJ IDEA 和 Eclipse。它们都有出色的 Scala 插件和优秀的 SBT 支持。
- en: Setting up IntelliJ IDEA
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 IntelliJ IDEA
- en: 'IntelliJ provides a community and a commercial version of its IDE, both of
    which can be used to run and play around with the examples in this book. The following
    steps are shown for the community edition, but can be applied in the same manner
    for the commercial variant:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 提供了其 IDE 的社区版和商业版，两者都可以用来运行和玩转本书中的示例。以下步骤适用于社区版，但也可以以相同的方式应用于商业版本：
- en: The first thing to do is download the IDE. You can download a version for your
    OS from [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
    Once downloaded, run the installer and start the IDE. When you run IntelliJ for
    the first time, you're asked whether you want to install the featured plugins.
    Scala is one of them:![Setting up IntelliJ IDEA](img/00003.jpeg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是下载 IDE。您可以从 [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)
    下载适用于您的操作系统的版本。下载后，运行安装程序并启动 IDE。当您第一次运行 IntelliJ 时，会询问您是否要安装特色插件。Scala 就是其中之一：![设置
    IntelliJ IDEA](img/00003.jpeg)
- en: From here, click on **Install** below the **Scala** column to install Scala
    support in IntelliJ. After installing, click on **Start using IntelliJ IDEA**.
    After IntelliJ is started, you're shown a screen where you can import an existing
    project:![Setting up IntelliJ IDEA](img/00004.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，点击**Scala**列下方的**安装**来在 IntelliJ 中安装 Scala 支持。安装完成后，点击**开始使用 IntelliJ IDEA**。IntelliJ
    启动后，你会看到一个屏幕，你可以从这里导入现有项目：![设置 IntelliJ IDEA](img/00004.jpeg)
- en: From here, select **Import Project**, and on the screen that opens, navigate
    to the directory where we extracted the downloaded sources, select that directory,
    and click on **OK**. On the screen that opens, select the **Import Project from
    external model** radio button and next, select **SBT**.![Setting up IntelliJ IDEA](img/00005.jpeg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，选择**导入项目**，在打开的屏幕上，导航到我们提取下载源代码的目录，选择该目录，然后点击**确定**。在打开的屏幕上，选择**从外部模型导入项目**单选按钮，然后选择**SBT**。![设置
    IntelliJ IDEA](img/00005.jpeg)
- en: 'Now click on **Next** and fill in the screen that opens:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**下一步**并填写打开的屏幕：
- en: Check the **Download sources and docs** checkbox.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中**下载源代码和文档**复选框。
- en: For **Project SDK**, click on **New**, select **JDK**, and navigate to the directory
    where you installed the JDK 1.8.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**项目 SDK**，点击**新建**，选择**JDK**，并导航到您安装 JDK 1.8 的目录。
- en: And finally, click on **Finish**.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**完成**。
- en: 'IntelliJ will now import all the projects and download all the required dependencies.
    Once done, you''re shown a screen like this, where you see all the projects and
    can run the examples directly from the IDE:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 现在将导入所有项目并下载所有必需的依赖项。完成后，你会看到一个类似这样的屏幕，其中显示了所有项目，可以直接从 IDE 中运行示例：
- en: '![Setting up IntelliJ IDEA](img/00006.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![设置 IntelliJ IDEA](img/00006.jpeg)'
- en: An alternative to using IntelliJ IDEA with great Scala support is Eclipse.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有出色 Scala 支持的 IntelliJ IDEA 的替代方案是 Eclipse。
- en: Setting up Eclipse
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Eclipse
- en: The Scala community provides a packaged version of Eclipse that contains everything
    you need for developing Scala.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 社区提供了一个包含您开发 Scala 所需一切内容的 Eclipse 打包版本。
- en: To install this version of Eclipse, first download the version for your OS from
    their download site at [http://scala-ide.org/download/sdk.html](http://scala-ide.org/download/sdk.html).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装此版本的 Eclipse，首先从他们的下载网站 [http://scala-ide.org/download/sdk.html](http://scala-ide.org/download/sdk.html)
    下载适用于您的操作系统的版本。
- en: Once downloaded, extract the archive to a directory of your choice, start Eclipse,
    and select a location to store your file. Once started, you'll see an empty editor:![Setting
    up Eclipse](img/00007.jpeg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，将存档解压到您选择的目录，启动 Eclipse，选择存储文件的地点。启动后，您将看到一个空白的编辑器：![设置 Eclipse](img/00007.jpeg)
- en: 'Before we can import the project, we must first create the required Eclipse
    project configuration. To do this, open a terminal and navigate to the directory
    where you extracted or cloned the sources. From that directory, run `sbt eclipse`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以导入项目之前，我们必须首先创建所需的 Eclipse 项目配置。为此，打开一个终端并导航到您提取或克隆源代码的目录。从该目录运行 `sbt eclipse`：
- en: '[PRE5]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we can import the project. Go to **File** | **Import** from the menu and
    choose to import **Existing projects into Workspace**. On the next screen, select
    the directory with the sources as the root directory, and Eclipse should show
    you all the projects:![Setting up Eclipse](img/00008.jpeg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以导入项目了。从菜单中选择**文件** | **导入**，然后选择将**现有项目导入工作空间**。在下一屏幕上，选择包含源代码的目录作为根目录，Eclipse
    应该会显示所有项目：![设置 Eclipse](img/00008.jpeg)
- en: Now click on **Finish**, and the projects will be imported. Now you can edit
    and run the samples directly from Eclipse.![Setting up Eclipse](img/00009.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**完成**，项目将被导入。现在您可以直接从 Eclipse 中编辑和运行示例。![设置 Eclipse](img/00009.jpeg)
- en: Testing the REST API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 REST API
- en: Before we look at the API of the service we're going to create, we'll have a
    quick look at how to test your REST API. We can, of course, create a REST client
    in Scala and use that, but since a big advantage of REST services is that they
    can be read and understood by humans, we'll use a simple browser-based (Chrome
    in this case) REST client called **Postman**. Note that you can, of course, also
    use different REST clients. The reason we chose Postman is that with Postman,
    it is easy to create different kinds of request; it has HATEOAS support and also
    allows us to share requests, so you don't have to make them by hand.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看将要创建的服务API之前，我们先快速了解一下如何测试你的REST API。当然，我们可以在Scala中创建一个REST客户端并使用它，但由于REST服务的最大优势之一是它们可以被人类阅读和理解，我们将使用一个简单的基于浏览器的（在这种情况下是Chrome）REST客户端，称为**Postman**。请注意，你当然也可以使用不同的REST客户端。我们选择Postman的原因是，使用Postman，创建不同类型的请求非常容易；它支持HATEOAS，并且还允许我们共享请求，因此你不必手动创建它们。
- en: Installing Postman
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Postman
- en: Postman runs as a Chrome plugin, so to use this REST client, you need to use
    Chrome. Once you've started Chrome, open the URL, [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en)
    in your browser (or just search on Google for Chrome Postman).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Postman作为一个Chrome插件运行，所以为了使用这个REST客户端，你需要使用Chrome。一旦你启动了Chrome，在浏览器中打开URL，[https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en)（或者直接在Google上搜索Chrome
    Postman）。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note that there are two versions of Postman: a simple Chrome plugin, which,
    at the time of writing, is version 0.8.4.14, and a Chrome app, which currently
    is at version 3.0.0.6\. For this book, we''ll use the simpler Chrome plugin, so
    make sure you install 0.8.4.14 in your browser.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Postman有两个版本：一个简单的Chrome插件，在撰写本文时，版本为0.8.4.14，以及一个Chrome应用，目前版本为3.0.0.6。对于这本书，我们将使用更简单的Chrome插件，所以请确保你在浏览器中安装了0.8.4.14。
- en: 'Once installed, open up this app by going to `chrome://apps` and selecting
    the application or clicking on the newly added button at the top-right of your
    screen. When you open this plugin, you should see the following window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，通过访问`chrome://apps`并选择应用程序或点击屏幕右上角新添加的按钮来打开此应用。当你打开这个插件时，你应该会看到以下窗口：
- en: '![Installing Postman](img/00010.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![安装Postman](img/00010.jpeg)'
- en: One interesting aspect of Postman is that you can very easily share REST queries.
    In the sources for this chapter, you can find a directory called `common`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Postman的一个有趣方面是你可以非常容易地共享REST查询。在本章的资源中，你可以找到一个名为`common`的目录。
- en: Importing request collection
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入请求集合
- en: 'In this directory, there are a number of files which contain the requests for
    each individual chapter. For instance, for this chapter, these are contained in
    the file, `ch01_requests.json`. Each file contains a number of requests that you
    can use to test the REST frameworks in this book. To import all these requests,
    take the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，有一些文件包含每个单独章节的请求。例如，对于这个章节，这些请求包含在文件`ch01_requests.json`中。每个文件都包含你可以用来测试本书中REST框架的多个请求。要导入所有这些请求，请按照以下步骤操作：
- en: On the left-hand side of the screen, click on the **Collections** tab.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的左侧，点击**集合**标签。
- en: To the right of this tab, two icons pop up. Click on the right icon, which is
    called **import collection**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此标签的右侧，会出现两个图标。点击右侧的图标，称为**导入集合**。
- en: On the screen that pops up, click on choose files, navigate to the `common`
    directory, and select all the `ch0#_requests.json` files and open them.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的屏幕上，点击**选择文件**，导航到`common`目录，并选择所有`ch0#_requests.json`文件然后打开它们。
- en: Now, you'll have a number of collections, one for each chapter, where you can
    find sample requests for the different chapters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将有一系列集合，每个章节一个，你可以在这里找到不同章节的示例请求。
- en: '![Importing request collection](img/00011.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![导入请求集合](img/00011.jpeg)'
- en: To run a request, just click on a collection. This will show all the requests
    for that chapter. Click on a request. Now clicking on the **Send** button will
    send the request to the server. In the upcoming chapters, we will see which request
    you can use to test the functionality of a specific Scala REST framework.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个请求，只需点击一个集合。这将显示该章节的所有请求。点击一个请求。现在点击**发送**按钮将请求发送到服务器。在接下来的章节中，我们将看到你可以使用哪个请求来测试特定Scala
    REST框架的功能。
- en: Testing the REST service
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试REST服务
- en: At this point, we've got Scala and SBT installed, and can use Postman as the
    REST client. The final step is to see whether everything is working correctly.
    For this, we'll start a very simple HTTP service, which echoes back a specific
    request parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经安装了Scala和SBT，并可以使用Postman作为REST客户端。最后一步是查看一切是否正常工作。为此，我们将启动一个非常简单的HTTP服务，该服务会回显特定的请求参数。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For this example, we've used HTTP4S. This is a basic HTTP server that allows
    you to quickly create HTTP services. If you're interested, you can find more information
    about this library at [http://http4s.org/](http://http4s.org/). The source code
    for our simple echo service can be found in the `chapter-01/src/main/scala` directory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用了HTTP4S。这是一个基本的HTTP服务器，允许您快速创建HTTP服务。如果您感兴趣，您可以在[http://http4s.org/](http://http4s.org/)找到更多关于这个库的信息。我们简单echo服务的源代码可以在`chapter-01/src/main/scala`目录中找到。
- en: 'To run this example, we need to take a couple of steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，我们需要采取几个步骤：
- en: First, open a console window and go to the directory where you downloaded and
    extracted the sources or cloned the Git repository.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个控制台窗口，转到您下载和提取源代码或克隆Git存储库的目录。
- en: 'From that directory, run the `sbt runCH01-EchoServer` command. This will start
    up the echo service:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那个目录中，运行`sbt runCH01-EchoServer`命令。这将启动echo服务：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Now that we've got a server running, open up your Chrome browser, and from there,
    open Postman (remember, either use the added button or the `chrome://apps` URL).
    In the list of collections, click on the request labeled **Echo 'hello'**. This
    will open the request. You can now run this request by clicking on the **Send**
    button. The result, if everything is configured correctly, will be something like
    this:![Testing the REST service](img/00012.jpeg)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经启动了服务器，打开您的Chrome浏览器，然后从那里打开Postman（记住，可以使用添加的按钮或`chrome://apps` URL）。在集合列表中，点击标记为**Echo
    'hello'**的请求。这将打开请求。您现在可以通过点击**发送**按钮来运行此请求。如果一切配置正确，结果将类似于以下内容：![测试REST服务](img/00012.jpeg)
- en: By changing the value of the `msg request` parameter, you can test that the
    server is really echoing the user's input.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更改`msg request`参数的值，您可以测试服务器是否真的在回显用户的输入。
- en: There are a couple of other requests in this collection that show some features
    of our current server. You can check what happens when the request parameter is
    omitted and when a call is made to an unknown URL.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此集合中还有一些其他请求，展示了我们当前服务器的一些功能。您可以检查当请求参数被省略时以及当调用未知URL时会发生什么。
- en: At this point, the only thing left to do in this chapter is to look at the API
    we'll create using the different frameworks outlined in the upcoming chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章剩下的唯一事情是查看我们将在即将到来的章节中概述的不同框架创建的API。
- en: The REST service and model
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST服务和模型
- en: To show the features of the various frameworks in this book and how they solve
    problems in a different manner, we'll define a simple API, which we'll implement
    with the REST frameworks. For this book, we'll implement a simple to-do list API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示本书中各种框架的特点以及它们以不同方式解决问题的方法，我们将定义一个简单的API，我们将使用REST框架来实现它。对于本书，我们将实现一个简单的待办事项列表API。
- en: API description
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API描述
- en: 'We want to create a RESTful API, so the most important part is to start with
    the description of the resources that can be managed through this API. For this
    API, we define the following resources:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个RESTful API，所以最重要的部分是从可以通過此API管理的资源描述开始。对于此API，我们定义以下资源：
- en: '| Entity | Description |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 实体 | 描述 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Task | A task is something that needs to be done. The JSON for a task looks
    similar to this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| 任务 | 任务是需要完成的事情。任务的JSON看起来类似于以下内容：'
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Project | A project will allow us to group tasks together, and by assigning
    persons to a project, we can determine who can work on a specific task:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| 项目 | 一个项目将允许我们将任务分组在一起，并且通过将人员分配到项目，我们可以确定谁可以处理特定的任务：'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Person | A person is someone who can work on a task and when done, close
    the task. A person can only work on those tasks to which he is assigned, or when
    he is part of the project to which a task belongs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| 人员 | 人员是可以完成任务并在完成后关闭任务的人。人员只能完成分配给他的任务，或者当他属于任务所属的项目时：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Note | Notes can be added to tasks to provide additional information on how
    the task should be performed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| 注意 | 可以给任务添加备注，以提供有关如何执行任务的额外信息：'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Without going into too much detail here, we want to support approximately the
    following functionality in our API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不深入细节，我们希望在API中支持以下功能：
- en: '**CRUD functionality**: We want to support some basic CRUD operations. It should
    be possible to perform the following actions:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRUD功能**：我们希望支持一些基本的CRUD操作。应该能够执行以下操作：'
- en: Create, update, and delete a new task, project, person, and note.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、更新和删除新的任务、项目、人员和备注。
- en: Get a list of tasks, projects, persons, and notes.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取任务、项目、人员和备注的列表。
- en: Search through a list of tasks.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务列表中进行搜索。
- en: Add a note to a task. It should also be possible to update and delete the existing
    notes.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给任务添加备注。还应该能够更新和删除现有的备注。
- en: '**Advanced functions**: Besides the standard CRUD-like functionality, we also
    want to provide some more advanced features:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级功能**：除了标准的CRUD-like功能外，我们还想提供一些更高级的功能：'
- en: Assign a task to a specific project
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务分配给特定项目
- en: Assign a person to a task
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将人员分配给任务
- en: Assign a person to a project
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将人员分配给项目
- en: Move a task from one project to another
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务从一个项目移动到另一个项目
- en: Note that we won't implement all the functionality for each framework. We'll
    mainly use this API to explain how we can use the various REST frameworks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不会为每个框架实现所有功能。我们将主要使用此API来解释我们如何使用各种REST框架。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's it for the first chapter. In this chapter, we introduced what REST is,
    and which level of the Robertsons Maturity Model we'll be aiming at (Level 2).
    We'll explain HATEOAS in the final chapter. At this point, you should have Scala
    and SBT installed, and should be able to run all the examples in this book using
    SBT and test them using the supplied requests in Postman. We also saw how to use
    IDEs to play around with the code. And finally, we introduced the high-level API
    that we'll implement in the upcoming chapters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章节到此结束。在本章中，我们介绍了REST是什么，以及我们将努力达到的Robertsons成熟度模型级别（第2级）。我们将在最后一章解释HATEOAS。到目前为止，你应该已经安装了Scala和SBT，并且应该能够使用SBT运行本书中的所有示例，并使用Postman中提供的请求进行测试。我们还看到了如何使用IDE来与代码互动。最后，我们介绍了将在接下来的章节中实现的高级API。
- en: In the next chapter, we'll dive into the first of the Scala frameworks we'll
    explore. The first one is Finch, which is a REST library on top of the networking
    library, Finagle. Both of these were initially created by Twitter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解我们将要探索的第一个Scala框架。第一个是Finch，它是一个建立在网络库Finagle之上的REST库。这两个都是最初由Twitter创建的。
