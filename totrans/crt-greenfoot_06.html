<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Scrolling and Mapped Worlds"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Scrolling and Mapped Worlds</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Already know you that which you need."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Yoda</em></span></span></td></tr></table></div><p>In Greenfoot, we<a id="id396" class="indexterm"/> can build worlds that are much larger than the confines of a single screen. Through scrolling techniques and dynamic actor generation, we can build side-scrolling games and map worlds that can seem endless. When you combine these large worlds with the techniques learned in the previous chapters, you will be able to create a truly compelling and immersive experience for your audience.</p><p>The techniques you will learn in this chapter are similar to the ones you learned in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, for animation. We will use illusion. Through very simple techniques, we can give the appearance that the user is moving through an expansive world. In this chapter, you will learn to create the following types of worlds:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Dynamically generated</li><li class="listitem">Mapped</li><li class="listitem">Tile-based</li></ul></div><p>As you learn more about Greenfoot and Java programming, you will notice repeating patterns and methods to accomplish specific tasks. While the content presented here warrants its own chapter, it is really a careful mixture of things you have already learned.</p><div class="section" title="Chapter scenario examples"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Chapter scenario examples</h1></div></div></div><p>In this chapter, we are going to look at four different methods to create large worlds for simulations, games, or animations. We are only going to present the code necessary to accomplish this and not elaborate further. <span class="emphasis"><em>You should combine the methods learned here with the topics presented in the previous chapters to develop complete applications</em></span>. In addition, we will use very simple graphics in our scenarios and assume that you would spend more time on art and story (as described in <a class="link" title="Chapter 5. Interactive Application Design and Theory" href="part0034.xhtml">Chapter 5</a>, <span class="emphasis"><em>Interactive Application Design and Theory</em></span>) for your own work.</p></div></div>
<div class="section" title="Dynamically generated worlds"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Dynamically generated worlds</h1></div></div></div><p>It would <a id="id397" class="indexterm"/>seem creating worlds that are dynamically generated and potentially endless would be the concluding topic of this chapter, instead of the introductory one. On the<a id="id398" class="indexterm"/> contrary, dynamically creating a world is easy, and we have already seen all the coding necessary to do so. In <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, we dynamically created enemies in Avoider Game that streamed down from the top, and later, in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, we added a dynamically generated star field. We will use the same techniques to create a seemingly endless world. Imagine that the enemies in Avoider Game were generated less frequently and looked like planets. It would look like we were travelling through space. Imagine we had a green background and used an image of a tree for our enemies. It would look like we were walking through a forest. Next, we will create a Greenfoot scenario that displays a user-controlled rocket flying through a cloudy sky.</p><div class="section" title="Side-scrolling"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Side-scrolling</h2></div></div></div><p>We are <a id="id399" class="indexterm"/>going to create the flying game depicted in <span class="emphasis"><em>Figure 1</em></span>. In this game, the user controls the rocket and attempts to avoid the walls. Why walls? Well, they are easy to draw and sufficiently illustrate the concepts. In <a id="id400" class="indexterm"/>your own scenario, you could spend some time and draw alien spaceships, birds, balloons, or anything else that makes sense to you.</p><div class="mediaobject"><img src="../Images/image00304.jpeg" alt="Side-scrolling"/><div class="caption"><p>Figure 1: This is a screenshot of the Clouds Greenfoot scenario.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Start by <a id="id401" class="indexterm"/>creating a new Greenfoot scenario, naming it <code class="literal">Clouds</code>, and saving it to disk. We will present<a id="id402" class="indexterm"/> the code for the world and actors next.</p><div class="section" title="The Rocket class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec36"/>The Rocket class</h3></div></div></div><p>In this <a id="id403" class="indexterm"/>example scenario, the user controls a rocket. You move the rocket by pressing the arrow keys. The movement of the rocket is restricted to stay<a id="id404" class="indexterm"/> inside the area of the screen. If the rocket hits a wall (which we will add soon), then the scenario will stop. There is no code in the <code class="literal">Rocket</code> class specific to generating a dynamic world, and it is all code we saw in the previous chapters. Create a new subclass of <code class="literal">Actor</code>, name it <code class="literal">Rocket</code>, associate the image of a rocket provided by Greenfoot with it, and enter the following code in its class file:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Rocket extends Actor {
  private int speedX = 1;
  private int speedY = 0;
  private static final int SPEED = 2;
  private static final int BOUNDARY = 20;
  
  public void act() {
    handleKeyPresses();
    boundedMove();
    checkForCrash();
  }
  
  private void handleKeyPresses() {
    handleArrowKey("down", 0, SPEED);
    handleArrowKey("up", 0, -SPEED);
    handleArrowKey("left", -SPEED, 0);
    handleArrowKey("right", SPEED, 0);
  }
  
  private void handleArrowKey(String k, int sX, int sY) {
    if( Greenfoot.isKeyDown(k) ) {
      speedX = sX;
      speedY = sY;
    }
  }
  
  private void boundedMove() {
    int newX = Math.max(BOUNDARY, speedX+getX());
    newX = Math.min(getWorld().getWidth()-BOUNDARY, newX);
    int newY = Math.max(BOUNDARY, speedY+getY());
    newY = Math.min(getWorld().getHeight()-BOUNDARY, newY);
    setLocation(newX,newY);
  }
  
  private void checkForCrash() {
    Actor w = getOneIntersectingObject(Obstacle.class);
    if( w != null ) {
      Greenfoot.stop();
    }
  }
}</pre></div><p>You should be <a id="id405" class="indexterm"/>very familiar with the code to handle key presses and moving actors. One additional concept I have added here, is <span class="emphasis"><em>functional decomposition</em></span> to remove code redundancy. Notice how the <code class="literal">handleArrowKey()</code> method<a id="id406" class="indexterm"/> can handle movement for all arrow keys. The code for <code class="literal">checkForCrash()</code> simply implements our standard template to detect collisions. We will add the <code class="literal">Obstacle</code> actor soon.</p><p>In <code class="literal">boundedMove()</code>, we have code that gets the user to not leave the screen. Without this code, the user could go off the screen and disappear from view in any direction. Using Java's <code class="literal">max()</code> and <code class="literal">min()</code> math library functions, <code class="literal">boundedMove()</code> ensures that the new <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> locations of the rocket stay within the confines of the screen. The <code class="literal">BOUNDARY</code> variable defines how close the rocket can get to an edge. We add this buffer to prevent the rocket from hiding a majority of its image off the sides.</p></div><div class="section" title="The CloudsWorld class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec37"/>The CloudsWorld class</h3></div></div></div><p>The<a id="id407" class="indexterm"/> main responsibility <a id="id408" class="indexterm"/>of our world class is to initially place the rocket on the screen and randomly generate clouds and walls. Create a new subclass of <code class="literal">World</code>, name it <code class="literal">CloudsWorld</code>, and assign a plain blue image to it for the background. You can either use the blue gradient background we used in <a class="link" title="Chapter 4. Projectiles" href="part0030.xhtml">Chapter 4</a>, <span class="emphasis"><em>Projectiles</em></span>, or create a new one using your favorite drawing program. As with the <code class="literal">Rocket</code> class, most of the code for <code class="literal">CloudsWorld</code> should be a review of previously provided code. Here is the code for <code class="literal">CloudsWorld</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class CloudsWorld extends World {
  
  public CloudsWorld() {
    super(600, 400, 1, false);
    prepare();
  }
  
  public void act() {
    generateBackgroundClouds();
    generateWalls();
  }
  
  private void generateBackgroundClouds() {
    generateActor(5, new Cloud1());
    generateActor(4, new Cloud2());
    generateActor(3, new Cloud3());
  }
  
  private void generateWalls() {
    generateActor(5, new Wall());
  }
  
  private void generateActor(int chance, Actor a) {
    if( Greenfoot.getRandomNumber(1000) &lt; chance) {
      int randY = Greenfoot.getRandomNumber(300) + 50;
      addObject(a, getWidth()+20, randY);
    }
  }
  
  private void prepare(){
    Rocket rocket = new Rocket();
    addObject(rocket, 90, 200);
  }
}</pre></div><p>Do you <a id="id409" class="indexterm"/>remember what the <code class="literal">act()</code> method <a id="id410" class="indexterm"/>looked liked in our latest version of Avoider Game? Here's what it looks like:</p><div class="informalexample"><pre class="programlisting">// NOTE: DO NOT PUT THIS CODE IN YOUR CLOUDSWORLD CLASS
public void act() {
  generateEnemies();
  generateStars(-1);
  generatePowerItems();
  increaseLevel();
}</pre></div><p>Doesn't it look similar to the <code class="literal">act()</code> method for <code class="literal">CloudsWorld</code>? We are going to use the same technique we used to generate enemies in Avoider Game to generate clouds in the Clouds application.</p><p>Let's start by<a id="id411" class="indexterm"/> looking at the <code class="literal">generateActor()</code> method. This method takes an actor (type <code class="literal">Actor</code>) and an integer (type <code class="literal">int</code>) as parameters. The integer represents the chance that we add the supplied <a id="id412" class="indexterm"/>actor to the world. The higher the number, the more likely that the actor will appear on screen. With this method, we can easily implement the <code class="literal">generateBackgroundClouds()</code> method and the <code class="literal">generateWalls()</code> method. In these methods, we simply call <code class="literal">generateActor()</code>, providing the chance for the actor to appear on screen as well as a new instance of the desired actor.</p></div><div class="section" title="Side-scrolling actors"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec38"/>Side-scrolling actors</h3></div></div></div><p>All of the other<a id="id413" class="indexterm"/> actors in our scenario are <a id="id414" class="indexterm"/>going to be subclasses of the <code class="literal">SideScrollingActor</code> class. Create this by subclassing <code class="literal">Actor</code>, but do not associate an image with it. With the following code, we are using inheritance to provide the side-scrolling behavior to a whole set of actors:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public abstract class SideScrollingActor extends Actor
{
  public int speed = -1; // Moves right to left
  private static final int BOUNDARY = 100;
  
  public void act()
  {
    move(speed);
    checkOffScreen();
  }
  
  private void checkOffScreen() {
    if( getX() &lt; -BOUNDARY || getX() &gt; getWorld().getWidth() + BOUNDARY) {
      getWorld().removeObject(this);
    }
  }
}</pre></div><p>To give the illusion that our rocket is moving from left to right, we make all of the scrolling actors move from right to left. That is why the speed variable is negative. In the <code class="literal">act()</code> method, we move the actor and then call <code class="literal">checkOffScreen()</code> to remove the actor after it has moved off screen. As we never intend to use the <code class="literal">SideScrollingActor</code> class to directly<a id="id415" class="indexterm"/> instantiate an object, we make it <code class="literal">abstract</code>. Next, we will discuss the actors that are going to<a id="id416" class="indexterm"/> the <code class="literal">SideScrollingActor</code> subclass.</p><div class="section" title="Clouds"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec25"/>Clouds</h4></div></div></div><p>We use<a id="id417" class="indexterm"/> three different images of clouds for our application, and we will make them travel at different, random speeds. This will provide enough variety to give a realistic feel to our flying rocket. The three images I used are shown in <span class="emphasis"><em>Figure 2</em></span>. You can draw your own or the ones supplied at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p><div class="mediaobject"><img src="../Images/image00305.jpeg" alt="Clouds"/><div class="caption"><p>Figure 2: These are images of clouds</p></div></div><p style="clear:both; height: 1em;"> </p><p>Create a cloud actor by subclassing <code class="literal">SideScrollingActor</code>, naming it <code class="literal">Cloud1</code>, and then assigning one of your cloud images to it. In the class file for <code class="literal">Cloud1</code>, put the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 

public class Cloud1 extends SideScrollingActor {
  private static final int SPEEDRANGE = 3;
  public Cloud1() {
    speed = -(Greenfoot.getRandomNumber(SPEEDRANGE) + 1);
  }
}</pre></div><p>In <code class="literal">Cloud1</code>, we assign a random value to the <code class="literal">speed</code> variable between <code class="literal">1</code> and <code class="literal">3</code>. We inherited the <code class="literal">speed</code> variable from the <code class="literal">SideScrollingActor</code> parent class.</p><p>To create two more cloud actors, repeat the preceding steps once, substituting <code class="literal">Cloud1</code> with <code class="literal">Cloud2</code> and again <a id="id418" class="indexterm"/>substituting <code class="literal">Cloud1</code> with <code class="literal">Cloud3</code>. For further variety, you could change the <code class="literal">SPEEDRANGE</code> constant in each actor. I recommend setting <code class="literal">SPEEDRANGE</code> to <code class="literal">3</code> (as shown in Figure 2) for <code class="literal">Cloud1</code>, <code class="literal">2</code> for <code class="literal">Cloud2</code>, and <code class="literal">5</code> for <code class="literal">Cloud3</code>.</p></div><div class="section" title="Walls"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec26"/>Walls</h4></div></div></div><p>The last thing <a id="id419" class="indexterm"/>we need to add is the wall obstacle. While we only have one obstacle in this example, we are going to write code that would allow us to easily add additional obstacles in the future. We are going to use inheritance, but this time, we are using it to group related types, as opposed to sharing code. In the <code class="literal">Rocket Actor</code> code, we check for a collision with an <code class="literal">Obstacle</code> class. We will now create this class by subclassing <code class="literal">SideScrollingActor</code>, naming the new subclass <code class="literal">Obstacle</code>, and not associating an image with it. Here is the code for the <code class="literal">Obstacle</code> actor:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Obstacle extends SideScrollingActor{
}</pre></div><p>Again, we are not using inheritance for code reuse and, therefore, there is very little code to add.</p><p>Now, to create the <code class="literal">Wall</code> actor, we create a subclass of <code class="literal">Obstacle</code>. I simply created a dark gray rectangle image for my wall. I am sure you can come up with something better. Here is the code for the <code class="literal">Wall</code> class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 
public class Wall extends Obstacle {
}</pre></div><p>Since <code class="literal">Obstacle</code> inherits from <code class="literal">SideScrollingActor</code>, the <code class="literal">Wall</code> actor will have the same movement as the <code class="literal">Cloud</code> actors. However, the <code class="literal">Rocket</code> class can now detect collision with the <code class="literal">Obstacle</code> class. If we did collision detection with the <code class="literal">SideScrollingActor</code> class, then we would collide with clouds too.</p></div></div><div class="section" title="Try it out"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec39"/>Try it out</h3></div></div></div><p>We have <a id="id420" class="indexterm"/>finished creating the world and actor classes for our Greenfoot scenario. <span class="emphasis"><em>Figure 3</em></span> shows the completed Greenfoot scenario. Make sure your class hierarchy is exactly the same.</p><div class="mediaobject"><img src="../Images/image00306.jpeg" alt="Try it out"/><div class="caption"><p>Figure 3: This shows the completed Clouds scenario</p></div></div><p style="clear:both; height: 1em;"> </p><p>Compile it <a id="id421" class="indexterm"/>and take care of any typos you created along the way. Spend some time running the scenario and observing how the moving clouds give the illusion of travelling across an expansive sky. Even knowing how it is done, it is hard to imagine that your rocket is actually the actor on screen moving the least.</p></div></div></div>
<div class="section" title="Mapped worlds"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Mapped worlds</h1></div></div></div><p>There are <a id="id422" class="indexterm"/>definitely times when you are going to want a specific background for your game or simulation. In these cases, it is not sufficient to randomly generate actors to simulate a moving background. The methods we will explore next consist of creating a background image that is much larger than the dimensions of the screen and moving it appropriately to simulate motion. In addition, we will learn how to place actors in this larger world.</p><div class="section" title="Side-scrolling"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Side-scrolling</h2></div></div></div><p>Our <a id="id423" class="indexterm"/>side-scrolling example is a scenario that allows the user to <a id="id424" class="indexterm"/>walk through a mountain forest to find a lake at the end. The user will only be able to walk left and right, not up and down. <span class="emphasis"><em>Figure 4</em></span> shows the completed application.</p><div class="mediaobject"><img src="../Images/image00307.jpeg" alt="Side-scrolling"/><div class="caption"><p>Figure 4: This is a screenshot of HikingWorld</p></div></div><p style="clear:both; height: 1em;"> </p><p>To create this<a id="id425" class="indexterm"/> side-scrolling world, we are going to need a large image to serve as the background. For this example, I have created a 2400 x 400 image shown in <span class="emphasis"><em>Figure 5</em></span>. Since our scenario has a viewable screen size of 600 x 400, the image is six times longer than our screen. Feel free to create your own 2400 x 400 image or use the one supplied at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p><div class="mediaobject"><img src="../Images/image00308.jpeg" alt="Side-scrolling"/><div class="caption"><p>Figure 5: This is a background image for HikingWorld that is 2400 pixels long and 400 pixels high. Note that the image in this figure is one-fourth the original size in order to fit on a page</p></div></div><p style="clear:both; height: 1em;"> </p><p>Next, we will describe the code for the world and actor classes.</p><div class="section" title="The HikingWorld class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec40"/>The HikingWorld class</h3></div></div></div><p>The main <a id="id426" class="indexterm"/>responsibility of our world class, <code class="literal">HikingWorld</code>, is to shift everything in the world relative to the user-controlled <code class="literal">Hiker</code> class. We will allow the user to move normally within the confines of a screen, but when a user tries to move further than the left boundary or the right boundary of the screen, we will move everything to the right-hand side or left-hand side, respectively. Figure 6 demonstrates what we will do if the user is at the right edge of the screen and tries to move to the right-hand side.</p><div class="mediaobject"><img src="../Images/image00309.jpeg" alt="The HikingWorld class"/><div class="caption"><p>Figure 6: If the player moves right at the right edge of the screen, we will shift everything to the left</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we understand what the <code class="literal">HikingWorld</code> class must do, let's take a look at the code. First, subclass <code class="literal">World</code> and name the new subclass <code class="literal">HikingWorld</code>. Do not associate an image with this new class; we will do that in the constructor function. Here is the code for what the <code class="literal">HikingWorld</code> class must do:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;

public class HikingWorld extends World {
  private int xOffset = 0;
  private final static int SWIDTH = 600;
  private final static int SHEIGHT = 400;
  private final static int WWIDTH = 2400;
  private GreenfootImage bimg;
  
  public HikingWorld() {
    super(SWIDTH, SHEIGHT, 1, false);
    bimg = new GreenfootImage("HikingWorldBackground.png");
    shiftWorld(0);
    prepare();
  }
  
  public void shiftWorld(int dx) {
    if( (xOffset + dx) &lt;= 0 &amp;&amp; (xOffset + dx) &gt;= SWIDTH - WWIDTH) {
      xOffset = xOffset + dx;
      shiftWorldBackground(dx);
      shiftWorldActors(dx);
    }
  }
  
  private void shiftWorldBackground(int dx) {
    GreenfootImage bkgd = new GreenfootImage(SWIDTH, SHEIGHT);
    bkgd.drawImage(bimg, xOffset, 0);
    setBackground(bkgd);
  }
  
  private void shiftWorldActors(int dx) {
    List&lt;ScrollingActor&gt; saList =
    getObjects(ScrollingActor.class);
    for( ScrollingActor a : saList ) {
      a.setAbsoluteLocation(dx);
    }
  }
  
  private void prepare() {
    HedgeHog hh1 = new HedgeHog();
    addObject(hh1, 900, 250);
    Lemur l = new Lemur();
    addObject(l, 1200, 300);
    HedgeHog hh2 = new HedgeHog();
    addObject(hh2, 1500, 250);
    Lake lake = new Lake();
    addObject(lake, 2100, 300);
    Hiker hiker = new Hiker();
    addObject(hiker, 90, 275);
  }
}</pre></div><p>At the<a id="id427" class="indexterm"/> beginning of the class, we create three constants to store the dimensions of the screen (<code class="literal">SWIDTH</code> and <code class="literal">SHEIGHT</code>) and the background image (<code class="literal">WWIDTH</code>). Since the image height and the screen height are the same, we don't need a <code class="literal">WHEIGHT</code> constant. We also declare the <code class="literal">xOffset</code> instance variable. We use this variable to keep track of how far the background image and actors are currently shifted. Last, we create an instance variable, <code class="literal">bimg</code>, to point to the background image.</p><p>In the constructor, we load our background image and call <code class="literal">shiftWorld()</code> with an offset of <code class="literal">0</code> to put everything at its starting location. We use the <code class="literal">prepare()</code> method in a standard way—to place our initial actors. One thing to notice is that we use <span class="emphasis"><em>y</em></span> positions larger than the screen size. So, some of our actors will be created, but placed off screen. Eventually, they will be shifted to be on screen and viewable by the user. The real work to make this world large is done in <code class="literal">shiftWorld()</code>.</p><p>Notice the first <code class="literal">if</code> statement in the <code class="literal">shiftWorld()</code> method. This <code class="literal">if</code> statement prevents us from shifting the background image to the point where we would see the blank white space behind it.</p><p>If we are not<a id="id428" class="indexterm"/> at the edges of the background image, then we record the new offset by adding the current shift (<code class="literal">dx</code>) to the current offset (<code class="literal">xOffset</code>). Then, we proceed to shift the background image using the <code class="literal">shiftWorldBackground()</code> method and all actors in the world using <code class="literal">shiftWorldActors()</code>. The <code class="literal">shiftWorldBackground()</code> method is fairly simple. We start by creating a new image the size of the screen. We then draw our background image into it, offset by <code class="literal">xOffset</code> (which has just had <code class="literal">dx</code> added to it), and then set this new image to be the background image.</p><p>The <code class="literal">shiftWorldActors()</code> method may have few lines, but it does a lot of work. There is a <code class="literal">World</code> method called <code class="literal">getObjects()</code>provided to us that will return all of the actors in the world of the supplied class. For us, we call <code class="literal">getObjects(ScrollingActor.class)</code> to get all objects that should be shifted. The class the user controls, <code class="literal">Hiker</code>, is not a subclass of <code class="literal">ScrollingActor</code>; therefore, it will not be shifted in this method. We then iterate through the returned Java <code class="literal">List</code> and call <code class="literal">setAbsoluteLocation()</code> on each instance of <code class="literal">ScrollingActor</code>. We will look at the implementation of the <code class="literal">ScrollingActor</code> class and <code class="literal">setAbsoluteLocation()</code> soon.</p><p>The majority of the work for creating a side-scrolling world is done in <code class="literal">HikingWorld</code>. Make sure you understand this code before moving on. The rest of the code for the remaining actors in this scenario is pretty straightforward.</p></div><div class="section" title="The Hiker class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec41"/>The Hiker class</h3></div></div></div><p>We will have <a id="id429" class="indexterm"/>one instance of the <code class="literal">Hiker</code> class that the user will control. In this scenario, we are only going to let the user move left and right. This amount of control is sufficient to demonstrate a side-scrolling scenario. The code for this class is almost identical to the code for the <code class="literal">Rocket</code> actor in the Clouds scenario we created at the beginning of this chapter. First, look at the code, and then we will discuss the differences:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Hiker extends Actor
{
  private int speedX = 1;
  private static final int SPEED = 2;
  private static final int BOUNDARY = 40;
  
  public void act() {
    handleKeyPresses();
    boundedMove();
    checkAtLake();
  }
  
  private void handleKeyPresses() {
    handleArrowKey("left", -SPEED);
    handleArrowKey("right", SPEED);
  }
  
  private void handleArrowKey(String k, int sX) {
    if( Greenfoot.isKeyDown(k) ) {
      speedX = sX;
    }
  }
  
  private void boundedMove() {
    if( speedX+getX() &lt;= BOUNDARY ) {
      setLocation(BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX);
    } else if( speedX+getX() &gt;= getWorld().getWidth()-BOUNDARY ) {
      setLocation(getWorld().getWidth()-BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX);
    } else {
      setLocation(getX()+speedX, getY());
    }
    speedX = 0;
  }
  
  private void checkAtLake() {
    // Do something cool if make it to the lake...
  }
}</pre></div><p>The main<a id="id430" class="indexterm"/> difference occurs in <code class="literal">boundedMove()</code>. In the <code class="literal">Rocket</code> class presented earlier, we had a similar method that confined the user movement to a rectangular area slightly smaller than the screen. We are doing the same here for horizontal movement, but with one added feature. When we detect that the user is at the edge of the screen (either the left-hand side or the right-hand side), we will call <code class="literal">shiftWorld()</code> to make it look as though the actor is continuing to move.</p><p>We also have the <code class="literal">checkAtLake()</code> method that has no implementation. It is an example of how you could have a goal at the end of your world that the user must get to. In our case, we are <a id="id431" class="indexterm"/>going to place a lake at the end of the hike. We would use this method if we wanted to do something once the user arrived at the lake.</p></div><div class="section" title="The ScrollingActor class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec42"/>The ScrollingActor class</h3></div></div></div><p>All <a id="id432" class="indexterm"/>of the actors we want to shift will subclass the <code class="literal">ScrollingActor</code> class. It provides both a convenient way to group these actors and allows us to define the <code class="literal">setAbsoluteLocation()</code> method in one place. Here's how it's done:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ScrollingActor extends Actor {
  public void setAbsoluteLocation(int dx) {
    setLocation(getX()+dx, getY());
  }
}</pre></div><p>In the <code class="literal">HikingWorld</code> class, we called <code class="literal">setAbsoluteLocation()</code> on all the actors we wanted to shift. This method is simply a wrapper for <code class="literal">setLocation()</code> and moves the actor by the <code class="literal">dx</code> amount.</p><p>The code for the <code class="literal">HedgeHog</code>, <code class="literal">Lemur</code>, and <code class="literal">Lake</code> actors are identical and very minimal. Those classes mainly exist to allow different images to be associated with them. The images for a hedgehog and lemur come with the default installation of Greenfoot. My lake is a simple blue oval created in a drawing program. These actors are placed in the world in the <code class="literal">prepare()</code> method of <code class="literal">HikingWorld</code>. Create each of these now and add the following code to each (make sure to substitute in the appropriate class name):</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class HedgeHog extends ScrollingActor {
}</pre></div></div><div class="section" title="Try it out"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec43"/>Try it out</h3></div></div></div><p>Congratulations! You <a id="id433" class="indexterm"/>have created a side-scrolling, mapped world. Compile it and try it out. For an extra challenge, implement the <code class="literal">checkAtLake()</code> method found in the <code class="literal">Hiker</code> class to reward the hiker for reaching their destination. You can also download a completed version of the scenario at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p></div></div><div class="section" title="2D scrolling"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>2D scrolling</h2></div></div></div><p>Creating <a id="id434" class="indexterm"/>an application that allows a user to explore a large map in both the <span class="emphasis"><em>x</em></span> (left and right) and <span class="emphasis"><em>y</em></span> (up and down) directions is an easy extension of the <a id="id435" class="indexterm"/>side-scrolling world we just created. The code will be exactly the same except we will also handle the case for up and down movement. We also need an image that is both longer and wider than the screen size of our scenario. The image I created is 1200 x 1200 pixels and shown in <span class="emphasis"><em>Figure 7</em></span>. You can create your own or download the image from <span class="emphasis"><em>Figure 7</em></span> at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>. The picture is meant to represent a top-down view of a terrain with trees.</p><div class="mediaobject"><img src="../Images/image00310.jpeg" alt="2D scrolling"/><div class="caption"><p>Figure 7: A background image for HikingWorld2D that is 1200 pixels long and 1200 pixels high. Note that the image shown in this figure has been scaled down to fit on the page.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Create a new scenario and name it <code class="literal">HikingWorld2D</code>. As this code is very similar to the <code class="literal">HikingWorld</code> scenario we just implemented in the previous section, we will only highlight the code necessary to handle up and down movement.</p><div class="section" title="The HikingWorld2D class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec44"/>The HikingWorld2D class</h3></div></div></div><p>Subclass<a id="id436" class="indexterm"/> <code class="literal">World</code> and name the new class <code class="literal">HikingWorld2D</code>, but do not associate an image with it. We will add the image shown in <span class="emphasis"><em>Figure 7</em></span> (or one like it that you create) in the constructor function of this class. Here is the code to accomplish all this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;

public class HikingWorld extends World {
  private int xOffset = 0;
  private int yOffset = 0;
  private final static int SWIDTH = 600;
  private final static int SHEIGHT = 400;
  private final static int WWIDTH = 1200;
  private final static int WHEIGHT = 1200;
  private GreenfootImage bimg;

  public HikingWorld() {  
    super(SWIDTH, SHEIGHT, 1, false); 
    bimg = new GreenfootImage("HikingWorldBackground2D.png");
    shiftWorld(0,0);    
    prepare();
  }

  public void shiftWorld(int dx, int dy) {
    if( (xOffset + dx) &lt;= 0 &amp;&amp; (xOffset + dx) &gt;= SWIDTH - WWIDTH) {
      xOffset = xOffset + dx;
      shiftWorldBackground(dx, 0);
      shiftWorldActors(dx, 0);
    }
    if( (yOffset + dy) &lt;= 0 &amp;&amp; (yOffset + dy) &gt;= SHEIGHT - WHEIGHT) {
      yOffset = yOffset + dy;
      shiftWorldBackground(0, dy);
      shiftWorldActors(0, dy);
    }
  }
  
  private void shiftWorldBackground(int dx, int dy) {
      GreenfootImage bkgd = new GreenfootImage(SWIDTH, SHEIGHT);
      bkgd.drawImage(bimg, xOffset, yOffset);
      setBackground(bkgd);
  }
  
  private void shiftWorldActors(int dx, int dy) {
    List&lt;ScrollingActor&gt; saList = getObjects(ScrollingActor.class);
    for( ScrollingActor a : saList ) {
      a.setAbsoluteLocation(dx, dy);
    }
  }

  private void prepare() {
    HedgeHog hh1 = new HedgeHog();
    addObject(hh1, 600, 600);
    Lemur l = new Lemur();
    addObject(l, 300, 900);
    HedgeHog hh2 = new HedgeHog();
    addObject(hh2, 900, 300);
    Lake lake = new Lake();
    addObject(lake, 900, 1100);
    Hiker hiker = new Hiker();
    addObject(hiker, 90, 275);
  }
}</pre></div><p>First, we <a id="id437" class="indexterm"/>get <code class="literal">WWIDTH</code> and <code class="literal">WHEIGHT</code> to be the dimensions of the background image. Previously, we did not need <code class="literal">WHEIGHT</code> as it was the same as <code class="literal">SHEIGHT</code>. The main difference between this class and the <code class="literal">HikingWorld</code> class in <code class="literal">HikingWorld,</code> is that we add an extra parameter (<code class="literal">dy</code>) to <code class="literal">shiftWorld()</code>, <code class="literal">shiftWorldBackground()</code>, and <code class="literal">shiftWorldActors()</code> that provides the change in the <span class="emphasis"><em>y</em></span> direction. The use of the new <code class="literal">dy</code> parameter mirrors the use of the <code class="literal">dx</code> parameter. We end up shifting the background image and other actors by both <code class="literal">dx</code> and <code class="literal">dy</code>.</p></div><div class="section" title="The Hiker class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec45"/>The Hiker class</h3></div></div></div><p>Create<a id="id438" class="indexterm"/> a new subclass of <code class="literal">Actor</code>, name it <code class="literal">Hiker</code>, and associate one of the default people images provided by Greenfoot. Here is the code for this new class:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Hiker extends Actor {
  private int speedX = 1;
  private int speedY = 1;
  private static final int SPEED = 2;
  private static final int BOUNDARY = 40;
  
  public void act() {
    handleKeyPresses();
    boundedMove();
    checkAtLake();
  }
  
  private void handleKeyPresses() {
    handleArrowKey("left", -SPEED, 0);
    handleArrowKey("right", SPEED, 0);
    handleArrowKey("up", 0, -SPEED);
    handleArrowKey("down", 0, SPEED);
  }
  
  private void handleArrowKey(String k, int sX, int sY) {
    if( Greenfoot.isKeyDown(k) ) {
      speedX = sX;
      speedY = sY;
    }
  }
  
  private void boundedMove() {
    
    if( speedX+getX() &lt;= BOUNDARY ) {
      setLocation(BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX, 0);
    } else if( speedX+getX() &gt;= getWorld().getWidth()-BOUNDARY ) {
      setLocation(getWorld().getWidth()-BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX, 0);
    } else {
      setLocation(getX()+speedX, getY());
    }
    
    if( speedY+getY() &lt;= BOUNDARY ) {
      setLocation(getX(), BOUNDARY);
      ((HikingWorld)getWorld()).shiftWorld(0, -speedY);
    } else if( speedY+getY() &gt;= getWorld().getHeight()-BOUNDARY ) {
      setLocation(getX(), getWorld().getHeight()-BOUNDARY);
      ((HikingWorld)getWorld()).shiftWorld(0, -speedY);
    } else {
      setLocation(getX(), getY()+speedY);
    }
    speedX = 0;
    speedY = 0;
  }
  
  private void checkAtLake() {
  }
}</pre></div><p>This class has <a id="id439" class="indexterm"/>also been augmented to handle moving in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> directions. In <code class="literal">handleKeyPresses()</code>, we added two more calls to <code class="literal">handleArrowKey()</code> to handle the up and down arrow keys being pressed. In <code class="literal">boundedMove()</code>, we add checks to make sure the actor does not move off the top or bottom of the screen and that it calls <code class="literal">shiftWorld()</code> at the appropriate times.</p></div><div class="section" title="The ScrollingActor class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec46"/>The ScrollingActor class</h3></div></div></div><p>Create<a id="id440" class="indexterm"/> a new subclass of <code class="literal">Actor</code> and name it <code class="literal">ScrollingActor</code>. You do not need to associate an image with it. As before, this class simply provides a wrapper for <code class="literal">setLocation()</code>. Now, it handles moving the actor in the <span class="emphasis"><em>y</em></span> direction as well. Here is the code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ScrollingActor extends Actor {
  public void setAbsoluteLocation(int dx, int dy) {
    setLocation(getX()+dx, getY()+dy);
  }
}</pre></div><p>The <code class="literal">HedgeHog</code>, <code class="literal">Lemur</code>, and <code class="literal">Lake</code> classes are exactly the same as they were in the <code class="literal">HikingWorld</code> scenario shown previously. Add them to <code class="literal">HikingWorld2D</code> as well.</p></div><div class="section" title="Try it out"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec47"/>Try it out</h3></div></div></div><p>With<a id="id441" class="indexterm"/> just a few changes, we have created a world worth exploring, and all it took were a few extensions to our already completed <code class="literal">HikingWorld</code> scenario. Now, it is time to compile and try your scenario out. Handle any typos/errors and then explore the map. You can also download a completed version of the scenario at <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>.</p></div></div></div>
<div class="section" title="Tile-based worlds"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Tile-based worlds</h1></div></div></div><p>Tile-based worlds <a id="id442" class="indexterm"/>are a happy incorporation between fully dynamically created worlds and worlds that use a large image for the background. With large images, you create a very detailed and predictable world, but it is very difficult to change. Dynamically created worlds are easy to generate but are often too random. Tile-based worlds let you easily create detailed, predictable worlds in a way such that they are easy to change or modify.</p><div class="section" title="Actors as tiles"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Actors as tiles</h2></div></div></div><p>Artists<a id="id443" class="indexterm"/> can <a id="id444" class="indexterm"/>create amazing images using small pieces of tile or glass. <span class="emphasis"><em>Figure 8</em></span> shows a simple tile mosaic. By strategically placing small pieces of colored tiles, you can generate many different types of images.</p><div class="mediaobject"><img src="../Images/image00311.jpeg" alt="Actors as tiles"/><div class="caption"><p>Figure 8: This is a simple mosaic, courtesy of pixabay.com at http://pixabay.com/en/uzbekistan-mosaic-pattern-artfully-196875/</p></div></div><p style="clear:both; height: 1em;"> </p><p>We will use a similar technique to create a world in Greenfoot, but we will use small actors instead of tiles. <span class="emphasis"><em>Figure 9</em></span> demonstrates how we will do this. We will create a set of actors that will serve as our tiles. Then, we will specify how to compose these actors to create images using an array of strings that uses letters to code the type of actor to place. For example, the letter <code class="literal">C</code> corresponds to the actor displaying a cloud with a blue background, and the letter <code class="literal">F</code> corresponds to the actor displaying a flower on a green background. <span class="emphasis"><em>Figure 9</em></span> shows a 4 x 3 matrix of letters that is used to specify the tile layout that creates the final image. In the matrix, the upper-left corner letter is an <code class="literal">S</code>; therefore, the upper-left corner of the image is solid blue.</p><div class="mediaobject"><img src="../Images/image00312.jpeg" alt="Actors as tiles"/><div class="caption"><p>Figure 9: This shows the mapping of individual actors to create a larger world</p></div></div><p style="clear:both; height: 1em;"> </p><p>Hopefully, you<a id="id445" class="indexterm"/> now have a sense of how tile-based world creation will work. In the coming snippet, we code the hiking world scenario again, but this time modified to use tile-based world creation. Much of the code is directly borrowed from the 2D-scrolling hiking world we built in the last section.</p><p>Create a new scenario and name it <code class="literal">HikingWorldTiled</code>. The world and actor classes for this scenario are described in the next section. We only highlight the additions pertinent to tile-based world creation. <span class="emphasis"><em>Figure 10</em></span> shows a screenshot from the completed scenario. I provide this now, so that you can quickly see all the classes we will implement and get a glimpse of part of the image we will be creating.</p><div class="mediaobject"><img src="../Images/image00313.jpeg" alt="Actors as tiles"/><div class="caption"><p>Figure 10: This is a screenshot of the completed HikingWorldTiled scenario</p></div></div><p style="clear:both; height: 1em;"> </p><div class="section" title="The HikingWorld class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec48"/>The HikingWorld class</h3></div></div></div><p>Create<a id="id446" class="indexterm"/> <code class="literal">HikingWorld</code> by subclassing <code class="literal">World</code>. We are dynamically creating a background image, so you don't want to associate an image with this class; here is the code to accomplish this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.util.List;

public class HikingWorld extends World {
  private int xOffset = 0;
  private final static int SWIDTH = 600;
  private final static int SHEIGHT = 400;
  private final static int WWIDTH = 1200;
  private final static int TWIDTH = 25;
  private final static int THEIGHT = 25;
  
  private final static String[] WORLD = {
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWUUWWUUWWUUWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWUUWWUUWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWUUUUUUWWUUWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWUUWWUUWWUUWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWUUWWUUWWUUWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB",
    "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
  };
  
  public HikingWorld() {
    super(SWIDTH, SHEIGHT, 1, false);
    createWorldFromTiles();
    shiftWorld(0);
    prepare();
  }
  
  public void shiftWorld(int dx) {
    if( (xOffset + dx) &lt;= 0 &amp;&amp; (xOffset + dx) &gt;= SWIDTH - WWIDTH) {
      xOffset = xOffset+dx;
      shiftWorldActors(dx);
    }
  }
  
  private void shiftWorldActors(int dx) {
    List&lt;ScrollingActor&gt; saList =
    getObjects(ScrollingActor.class);
    for( ScrollingActor a : saList ) {
      a.setAbsoluteLocation(dx);
    }
  }
  
  private void createWorldFromTiles() {
    for( int i=0; i &lt; WORLD.length; i++ ) {
      for( int j=0; j &lt; WWIDTH/TWIDTH; j++ ) {
        addActorAtTileLocation(WORLD[i].charAt(j), j, i);
      }
    }
  }
  
  private void addActorAtTileLocation(char c, int x, int y) {
    Actor tile = null;
    switch(c) {
      case 'W':
      tile = new WhiteBlock();
      break;
      case 'B':
      tile = new BlackBlock();
      break;
      case 'U':
      tile = new BlueBlock();
      break;
    }
    if( tile != null) 	addObject(tile, 12+x*TWIDTH, 12+y*THEIGHT);
  }
  
  private void prepare() {
    Lake lake = new Lake();
    addObject(lake, WWIDTH-300, 300);
    Hiker hiker = new Hiker();
    addObject(hiker, 90, 275);
  }
}</pre></div><p>The two new<a id="id447" class="indexterm"/> parts of this class are the array of strings, <code class="literal">WORLD</code>, declared at the top of the class, and the <code class="literal">createWorldFromTiles()</code> method, which uses the method <code class="literal">addActorAtTileLocation()</code> to assist in building the world from the existing actors. The <code class="literal">WORLD</code> array specifies where we are going to place each actor that makes up part of the background. We have three actors we will use for our background image; they are <code class="literal">BlackBlock</code>, <code class="literal">WhiteBlock</code>, and <code class="literal">BlueBlock</code>. These actors use images that are 25 x 25 pixels. This is a decent size for a tile—any smaller and your <code class="literal">WORLD</code> array will be too large and tedious to manage, and any larger and you will lose the ability to create detail.</p><p>The <code class="literal">WORLD</code> array has sixteen strings in it that each contain forty-eight characters, thus the size of the image we are creating is 1200 (48 x 25) x 400 (16 x 25). The letter <code class="literal">B</code> corresponds to the <code class="literal">BlackBlock</code> actor, the letter <code class="literal">W</code> corresponds to the <code class="literal">WhiteBlock</code> actor, and the letter <code class="literal">U</code> corresponds to the <code class="literal">BlueBlock</code> actor. This mapping is captured in the <code class="literal">switch</code> statement in the <code class="literal">addActorAtTileLocation()</code> method. Knowing the mapping, you can look at the <code class="literal">WORLD</code> array and see that the image will have a black border and white background, and will spell the word <code class="literal">Hi</code> in blue.</p><p>OK, let's go through <code class="literal">createWorldFromTilesMethod()</code>. This method iterates through every character of every string in <code class="literal">WORLD</code>. For each character, it calls <code class="literal">addActorAtTileLocation()</code>, supplying parameters that specify the character that indicates which tile should be placed as well as the location for that tile. In <code class="literal">addActorAtTileLocation()</code>, we create <a id="id448" class="indexterm"/>a new actor based on the character passed to it and then use the provided <code class="literal">x</code> and <code class="literal">y</code> values to place the new actor in the world.</p></div><div class="section" title="The Hiker class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec49"/>The Hiker class</h3></div></div></div><p>The<a id="id449" class="indexterm"/> code here is identical to the code we looked at earlier for the <code class="literal">Hiker</code> class in the dynamically created world. I reproduce it here for convenience and because it is relatively short:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Hiker extends Actor {
  private int speedX = 1;
  private static final int SPEED = 2;
  private static final int BOUNDARY = 40;
  
  public void act() {
    handleKeyPresses();
    boundedMove();
    checkAtLake();
  }
  
  private void handleKeyPresses() {
    handleArrowKey("left", -SPEED);
    handleArrowKey("right", SPEED);
  }
  
  private void handleArrowKey(String k, int sX) {
    if( Greenfoot.isKeyDown(k) ) {
      speedX = sX;
    }
  }
  
  private void boundedMove() {
    if( speedX+getX() &lt;= BOUNDARY ) {
      setLocation(BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX);
    } else if( speedX+getX() &gt;= getWorld().getWidth()-BOUNDARY ) {
      setLocation(getWorld().getWidth()-BOUNDARY, getY());
      ((HikingWorld)getWorld()).shiftWorld(-speedX);
    } else {
      setLocation(getX()+speedX, getY());
    }
    speedX = 0;
  }
  
  private void checkAtLake() {
  }
}</pre></div></div><div class="section" title="The ScrollingActor class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec50"/>The ScrollingActor class</h3></div></div></div><p>This code is<a id="id450" class="indexterm"/> also identical to the code provided for the first scenario we created in this chapter. <span class="emphasis"><em>It is important to note here, that the actors we are using to create the world could also have additional functionality and not simply be a passive background image</em></span>. For example, you could have a <span class="emphasis"><em>Fire</em></span> tile that would burn the hiker if it collided with it. Here's the code we are discussing:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ScrollingActor extends Actor {
  public void setAbsoluteLocation(int dx) {
    setLocation(getX()+dx, getY());
  }
}</pre></div><div class="section" title="Tiles"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec27"/>Tiles</h4></div></div></div><p>The code<a id="id451" class="indexterm"/> for the <code class="literal">BlackBlock</code>, <code class="literal">BlueBlock</code>, and <code class="literal">WhiteBlock</code> actors are nearly identical. The only difference is the name of the class and the associated image. Take a look at the code for <code class="literal">BlackBlock</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class BlackBlock extends ScrollingActor {
}</pre></div><p>It is important that the images for these actors are all the same size, to make them easy to compose into a larger image. In our case, the images are 25 pixel x 25 pixel colored squares.</p></div><div class="section" title="The Lake class"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec28"/>The Lake class</h4></div></div></div><p>The <a id="id452" class="indexterm"/><code class="literal">Lake</code> class is the same as in the first scenario. It is important to note that not all subclasses of <code class="literal">ScrollingActor</code> have to serve as tiles for the background image. The <code class="literal">Lake</code> actor represents our final destination This is how the <code class="literal">Lake</code> class is used:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class Lake extends ScrollingActor {
}</pre></div><p>You can just copy it and its associated image from the previous scenario.</p></div><div class="section" title="Try it out"><div class="titlepage"><div><div><h4 class="title"><a id="ch06lvl4sec29"/>Try it out</h4></div></div></div><p>Compile the scenario and run it. It should feel similar to the side-scrolling example we provided after the Clouds scenario, except now it is very easy to change the image of the world. Instead of <code class="literal">Hi</code> being spelled in the background, spell your name. For a challenge, change the <code class="literal">Hiker</code> class such that if it touches a blue block, the game ends.</p></div></div></div><div class="section" title="Other game sprites"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Other game sprites</h2></div></div></div><p>In our <a id="id453" class="indexterm"/>example, the tiles were very simple. The real strength of tile-based world creation comes from having a wide variety of tiles to choose from to create an interesting world. You can either create your own world, download some from sites that charge, such as <a class="ulink" href="http://cartoonsmartart.com">http://cartoonsmartart.com</a>, or download from 100 percent free sites, such as <a class="ulink" href="http://opengameart.org">http://opengameart.org</a>. <span class="emphasis"><em>Figure 11</em></span> shows an example of a free tile set from <a class="ulink" href="http://opengameart.org">http://opengameart.org</a>.</p><div class="mediaobject"><img src="../Images/image00314.jpeg" alt="Other game sprites"/><div class="caption"><p>Figure 11: This is a free tile sheet from opengameart.org provided by Kenny at http://opengameart.org/content/rpg-pack-base-set</p></div></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Summary</h1></div></div></div><p>By combining the techniques of large-world creation presented in this chapter, with the other concepts and techniques presented in previous chapters, you are fully equipped to create endless forms of information, entertainment, and immersive experiences using Greenfoot. In the next chapter, we will explore making actors in your applications behave intelligently to further enhance user experience.</p></div></body></html>