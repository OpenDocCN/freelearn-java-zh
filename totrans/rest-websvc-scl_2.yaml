- en: Chapter 2. A Functional-style REST Service with Finagle and Finch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to show you how you can create a REST service
    using the Finagle and Finch library. We''ll do this using the following set of
    examples:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '**Your first Finagle and Finch service**: In this section, we''ll create a
    minimal REST service, which will simply return a string.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP verb and URL matching**: An important part of any REST service is how
    to handle various URL paths and the different HTTP verbs. In this part, we''ll
    show you how Finch supports this through the use of matchers and extractors.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use RequestReaders to process incoming requests**: When creating a REST service,
    you usually need to get information from the incoming HTTP request. Finch uses
    `RequestReader` instances to access information from the request, which we''ll
    explain in this part.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON support**: REST services most often use JSON to represent resources.
    Finch supports a number of different JSON libraries. In this part, we''ll explore
    one of these JSON libraries and how to use it from a Finch service.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request validation and custom responses**: The final part of this chapter
    deals with validating incoming requests and creating custom responses. Finch has
    a very elegant way, using `RequestReader` instances and validation rules, to check
    whether incoming requests are valid and can be processed further.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start looking at the code, let's quickly look at what Finagle and
    Finch are for libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Finagle and Finch
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finagle and Finch are actually two different frameworks. Finagle is an RPC
    framework, created by Twitter, which you can use to easily create different types
    of service. On its website ([https://github.com/twitter/finagle](https://github.com/twitter/finagle)),
    the team behind Finagle explains it like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '*"Finagle is an extensible RPC system for the JVM, used to construct high-concurrency
    servers. Finagle implements uniform client and server APIs for several protocols,
    and is designed for high performance and concurrency. Most of Finagle''s code
    is protocol agnostic, simplifying the implementation of new protocols."*'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, while Finagle provides the plumbing required to create highly scalable services,
    it doesn't provide direct support for specific protocols. This is where Finch
    comes in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Finch ([https://github.com/finagle/finch](https://github.com/finagle/finch))
    provides an HTTP REST layer on top of Finagle. On their website, you can find
    a nice quote which summarizes what Finch aims to do:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '*"Finch is a thin layer of purely functional basic blocks atop of [http://twitter.github.io/finagle](http://twitter.github.io/finagle)
    for building composable REST APIs. Its mission is to provide the developers simple
    and robust REST API primitives being as close as possible to the bare metal Finagle
    API."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we'll only be talking about Finch. Note, though, that most
    of the concepts provided by Finch are based on underlying Finagle ideas. Finch
    provides a very nice REST-based set of functions to make working with Finagle
    very easy and intuitive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只将讨论 Finch。请注意，尽管如此，Finch 提供的大部分概念都是基于底层 Finagle 理念的。Finch 提供了一套非常棒的基于
    REST 的函数集，使得与 Finagle 一起工作变得非常简单和直观。
- en: Building your first Finagle and Finch REST service
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个 Finagle 和 Finch REST 服务
- en: 'Let''s start by building a minimal Finch REST service. The first thing we need
    to do is make sure we have the correct dependencies. Like we mentioned in the
    previous chapter, we use SBT to manage our dependencies. All the dependencies
    for the various chapters can be found in the `Dependencies.scala` file, which
    is located in the `project` directory in the location where you extracted your
    sources. For the Finch examples, which we will see in this chapter, we use the
    following dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个最小的 Finch REST 服务开始。我们首先需要确保我们拥有正确的依赖项。正如我们在上一章中提到的，我们使用 SBT 来管理我们的依赖项。各种章节的所有依赖项都可以在您提取源代码的位置的
    `project` 目录下的 `Dependencies.scala` 文件中找到。对于本章中我们将看到的 Finch 示例，我们使用以下依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This book uses a single SBT file (`build.sbt` located in the root) for all the
    chapters and uses a multimodule approach. Diving into the multimodule setup is
    a bit beyond the scope of this book. If you want to learn more about how we use
    SBT to manage and define the various modules, look at the `build.sbt` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用单个 SBT 文件（位于根目录的 `build.sbt`）来处理所有章节，并采用多模块方法。深入探讨多模块设置超出了本书的范围。如果您想了解更多关于我们如何使用
    SBT 来管理和定义各种模块的信息，请查看 `build.sbt` 文件。
- en: 'Now that we''ve got our library dependencies loaded, we can start coding our
    very first Finch service. The next code fragment (the source can be found at `chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala`)
    shows a minimal Finch service, which just responds with a `Hello, Finch!` message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了库依赖项，我们可以开始编写我们的第一个 Finch 服务。接下来的代码片段（源代码可以在 `chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala`
    找到）展示了一个最小的 Finch 服务，它只响应一个 `Hello, Finch!` 消息：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this service receives a `GET` request on the URL path, `hello`, it will
    respond with a `Hello, Finch!` message. Finch does this by creating a service
    (using the `toService` function) from a route (more on routes is explained in
    the next section) and using the `Httpx.serve` function to host the created service.
    To run this example, open a terminal window in the directory where you''ve extracted
    the sources. In that directory, run the `sbt runCH02-HelloFinch` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当此服务在 URL 路径 `hello` 上收到 `GET` 请求时，它将响应 `Hello, Finch!` 消息。Finch 通过从路由（下一节将详细介绍路由）创建一个服务（使用
    `toService` 函数）并使用 `Httpx.serve` 函数托管创建的服务来实现这一点。要运行此示例，请在您提取源代码的目录中打开一个终端窗口。在那个目录中，运行
    `sbt runCH02-HelloFinch` 命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we have an HTTP server running on port `8080`. When we make
    a call to `http://localhost:8080/hello`, this server will respond with the `Hello,
    Finch!` message. To test this service, we''ve provided an HTTP request in Postman
    (see the previous chapter on how to install Postman and load requests). You can
    use the `GET Hello Finch` request to test the Finch service we just created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个运行在端口 `8080` 上的 HTTP 服务器。当我们调用 `http://localhost:8080/hello` 时，此服务器将响应
    `Hello, Finch!` 消息。为了测试此服务，我们已在 Postman 中提供了一个 HTTP 请求（请参阅上一章了解如何安装 Postman 和加载请求）。您可以使用
    `GET Hello Finch` 请求来测试我们刚刚创建的 Finch 服务：
- en: '![Building your first Finagle and Finch REST service](img/00013.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![构建您的第一个 Finagle 和 Finch REST 服务](img/00013.jpeg)'
- en: HTTP verb and URL matching
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 动词和 URL 匹配
- en: 'An important part of every REST framework is the ability to easily match HTTP
    verbs and the various path segments of the URL. In this section, we''ll look at
    the tools Finch provide us with. Let''s start with getting the service up and
    running though. To run this service, you can use the `sbt runCH02-runCH02Step1`
    command from the source directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 REST 框架的一个重要部分是能够轻松匹配 HTTP 动词和 URL 的各种路径段。在本节中，我们将查看 Finch 提供给我们的工具。让我们先从启动服务开始。要运行此服务，您可以从源代码目录使用
    `sbt runCH02-runCH02Step1` 命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the server is started, you can once again use Postman to make requests
    to this service, using the requests from the **Chapter 02** collection. This service
    just returns a simple text message on each request:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，您就可以再次使用 Postman 向此服务发送请求，使用来自 **第二章** 集合的请求。此服务对每个请求只返回一个简单的文本消息：
- en: '![HTTP verb and URL matching](img/00014.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at some code and see how to do this with Finch (`chapter-02/src/main/scala/org/restwithscala/chapter2/steps/FinchStep1.scala`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code fragment, we create a number of `Router` instances that process
    the requests which we sent from Postman. Let''s start by looking at one of the
    routes of the `taskAPI` router, `Get / "tasks" / long /> (id => s"Get a single
    task with id: $id")`. The following table explains the various parts of the route:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '| Part | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `Get` | When writing routers, usually the first thing you do is determine
    which HTTP verb you want to match. In this case, this route will only match the
    `GET` verb. Besides the `Get` matcher, Finch also provides other matchers such
    as `Post`, `Patch`, `Delete`, `Head`, `Options`, `Put`, `Connect`, and `Trace`.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `"tasks"` | The next part of the route is a matcher that matches a URL path
    segment. In this case, we match the URL, `http://localhost:8080/tasks`. Finch
    will use an implicit conversion to convert this string object to a finch `Matcher`
    object. Finch also has two wildcard matchers: `*` and `**`. The `*` matcher allows
    any value for a single path segment, and the `**` matcher allows any value for
    multiple path segments. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `long` | The next part in the route is called an **extractor**. With an extractor,
    you turn part of the URL into a value which you can use to create the response
    (for example, retrieve an object from the database using the extracted ID). The
    `long` extractor, as the name implies, converts the matching path segment to a
    long value. Finch also provides an int, string, and boolean extractor. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `long => B` | The last part of the route is used to create the response message.
    Finch provides different ways of creating the response, which we''ll show in the
    other parts of this chapter. In this case, we need to provide Finch with a function
    that transforms the long value we extracted, and returns a value Finch can convert
    to a response (you will learn more on this later). In this example, we just return
    a string. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: 'If you''ve looked closely at the source code, you probably have noticed that
    Finch uses custom operators to combine the various parts of a route. Let''s look
    a bit closer at these. With Finch, we get the following operators (also called
    **combinators** in Finch terms):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`/` or `andThen`: With this combinator, you sequentially combine various matchers
    and extractors. Whenever the first part matches, the next one is called, for instance,
    `Get / "path" / long`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|` or `orElse`: This combinator allows you to combine two routers (or parts
    thereof) as long as they are of the same type. So, we could do `(Get | Post)`
    to create a matcher, which matches the `GET` and `POST` HTTP verbs. In the code
    sample, we''ve also used this to combine all the routes that returned a simple
    string to the `taskAPI` router.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/>` or `map`: With this combinator, we pass the request and any extracted
    values from the path to a function for further processing. The result of the function
    that is called is returned as the HTTP response. As you''ll see in the rest of
    the chapter, there are different ways of processing the HTTP request and creating
    a response.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:+:`: The final combinator allows you to combine two routers together of different
    types. In the example, we have two routers: `taskAPI`, which returns a simple
    string, and `taskCreateAPI`, which uses a `RequestReader` object (through the
    `body` function), to create the response. We can''t combine these with `|` since
    the result is created using two different approaches, so we use the `:+:` combinator.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we just return simple strings whenever we get a request. In the next
    section, we'll look at how you can use a `RequestReader` instance to convert the
    incoming HTTP requests to case classes and use those to create an HTTP response.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Processing incoming requests using RequestReaders
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven't done anything yet with the incoming request. In the previous
    example, we just returned a string without using any information from the request.
    Finch provides a very nice model using a **Reader monad**, which you can use to
    easily combine information from an incoming request to instantiate new objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Reader monad is a standard functional design pattern, which allows you to
    define functions that all access the same values. A great explanation of how Reader
    monads work can be found at [http://eed3si9n.com/learning-scalaz/Monad+transformers.html](http://eed3si9n.com/learning-scalaz/Monad+transformers.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code that uses a `RequestReader` to process incoming requests
    (the complete source code can be found in the `FinchStep2.scala` file):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we see a couple of new things. Instead of directly returning
    a string value, we use a case class that extends from `Service` to process the
    HTTP request and create a response. You can also run this service directly from
    SBT. Running the `sbt runCH02-runCH02Step2` command will start up the service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can test this service once again using Postman. Let''s start by testing
    whether we can create a new task. To do this, open up Postman and fire off the
    request **Step 02 – Create Task**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing incoming requests using RequestReaders](img/00015.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: The response we get back starts to look similar to real data. The text we entered
    in `body` as well as the `title` request parameter is used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the router we used to create a new task in detail to see how
    this works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the top of this code fragment, you can see how we define the router that
    handles the create task request we just made through Postman. Whenever a `POST`
    request is made to the `tasks` URL, this router matches and maps the request to
    the function to the right of the `/>` combinator. This time, however, we don''t
    map to a function that returns a string, but we map to a case class that extends
    from `Service`. In our own class, we have to implement the `def apply(request:
    Req): Future[Rep]` function from the abstract `Service` class. In this specific
    example, we specified the type parameters for this service as `Request` and `String`,
    so the `apply` function should transform the incoming `Request` instance to a
    `Future[String]` object.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the first type parameter, you normally specify `Request` (unless you apply
    filters before processing the request, as we'll explain in the last part of this
    chapter), and the second type parameter should be a type, which Finch can automatically
    convert to an HTTP response. To automatically convert, Finch looks for an implicit
    `EncodeResponse[A]` type-class in scope. Out of the box, Finch will transform
    strings to HTTP responses. It also supports a number of JSON libraries, where
    case classes are automatically converted to HTTP responses with JSON bodies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In the service for this route, we take a couple of steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `getRequestToTaskReader` function defined in the base class,
    with the ID of the task we want to create. Since we're creating a new one, we
    just specify `-1` as the ID and let the backend generate a real ID. The result
    from this call is a `RequestReader[Task]` instance, which can convert a request
    into a `Task` class.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then directly call the `apply` function on the returned `RequestReader[Task]`
    instance with the passed in request. This call returns a `Future[Task]` object,
    which we process further in the `for` comprehension.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the future from step 2 resolves, we have access to a task. We store this
    task using the `TaskService.insert` method. This call also returns a `Future`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we yield the stored `Task` object, as a `Future[Task]` instance.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step in the service is converting the `Future[Task]` object to a `Future[String]`
    object, which we just do by using a simple `map` function. The reason we need
    to do this is because Finch doesn't know how to automatically convert `Task` objects
    to an HTTP response.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, let''s look a bit closer at the `RequestReader[Task]`
    instance we used to convert a `Request` object to a Task object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this function, we combine various RequestReader (`body`, `param`, and `RequestReader.value`)
    using the `::` combinator (we''ll explain more about `body`, `param`, and `RequestReader.value`
    in the next section). When we pass in a `Request` to the result of this function,
    each `RequestReader` is executed against the request. The result of all these
    individual steps is combined using the `as[A]` function (you can also use `asTuple`
    to collect the results). Finch standard supports conversion to int, long, float,
    double, and boolean, and also allows you to convert to a case class. In this last
    case, you have to make sure the result from the individual `RequestReader` matches
    the constructor of your case class. In this example, `Task` is defined like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And this matches the results of the individual RequestReaders. Should you want
    to convert to a type that isn''t supported, you can very simply write your own,
    and just make sure it is in scope:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the example code so far, we''ve only used a couple of RequestReaders: `param`
    and `body`. Finch provides a number of other readers you can use to access information
    from the HTTP request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '| Reader | Description |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `param(name)` | This returns the request parameter as a string and throws
    a `NotPresent` exception when the parameter can''t be found. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `paramOption(name)` | This returns the request parameter as an `Option[String]`
    object. This call will always succeed. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `paramsNonEmpty(name)` | This returns a multivalue parameter as a `Seq[String]`
    object. If the parameter can''t be found, a `NotPresent` exception is thrown.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `params(name)` | This returns a multivalue parameter (for example, `?id=1,2,3&b=1&b=2`)
    as a `Seq[String]` object. If the parameter can''t be found, an empty list is
    returned. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `header(name)` | This returns a request header with the specified name as
    a string and throws a `NotPresent` exception when the header can''t be found.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `headerOption(name)` | This returns a request header with the specified name
    as an `Option[String]` object. This call will always succeed. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `cookie(name)` | This gets a `Cookie` object from the request. If the specified
    cookie isn''t present, a `NotPresent` exception is thrown. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `cookieOption(name)` | This gets a `Cookie` object from the request. This
    call will always succeed. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `body` | This returns the request body name as a string and throws a `NotPresent`
    exception when there is no body present. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `bodyOption` | This returns the body as an `Option[String]` object. This
    call will always succeed. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `binaryBody` | This returns the request body name as an `Array[Byte]` object
    and throws a `NotPresent` exception when there is no body present. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `binaryBodyOption` | This returns the body as an `Option[Array[Byte]]` object.
    This call will always succeed. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `fileUpload` | This `RequestReader` reads an upload (a multipart/form) parameter
    from the request and throws a `NotPresent` exception when the upload can''t be
    found. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `fileUploadOption` | This `RequestReader` reads an upload (a multipart/form)
    parameter from the request. This call will always succeed. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: 'As you can see from this table, a large number of RequestReaders types are
    already available, and in most cases, this should be enough to handle your requirements.
    If the `RequestReader` object does not provide the required functionality, a number
    of helper functions are available that you can use to create your own custom `RequestReader`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `value[A](value: A):``RequestReader[A]` | This function creates a `RequestReader`
    instance that always succeeds and returns the specified value. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `exception[A](exc: Throwable):``RequestReader[A]` | This function creates
    a `RequestReader` instance that always fails with the specified exception. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `const[A](value: Future[A]):``RequestReader[A]` | This `RequestReader` will
    just return the specified value. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `apply[A](f: HttpRequest => A):``RequestReader[A]` | This function returns
    a `RequestReader` instance that applies the provided function. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: There is one part of the `RequestReader` that we haven't discussed yet. What
    happens when a `RequestReader` fails? Finch has a very elegant mechanism to handle
    these validation errors. We'll come back to that in the last part of this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: JSON support
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve just worked with plain strings as responses. In this section,
    we''ll expand the previous sample and add JSON support and show you how you can
    control which HTTP response code should be used when handling a request. Using
    JSON with Finch is very straightforward since Finch already supports a number
    of JSON libraries out of the box:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Argonaut ([http://argonaut.io/](http://argonaut.io/)).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jackson ([https://github.com/FasterXML/Jackson](https://github.com/FasterXML/Jackson))
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Json4s ([http://json4s.org/](http://json4s.org/))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argonaut
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll look at how to use the Argonaut library to automatically
    convert our model (our case classes) to JSON. Should you want to use one of the
    other libraries, they work in pretty much the same manner.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by looking at the request and response message that our service
    should work with for this scenario. First, start up the server using the `sbt
    runCH02-runCH02Step3` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the server is started, open Postman and select the request **Step 03 –
    Create Task** from the **Chapter 02** collection. When you send this request,
    the server will parse this to a case class, store it, and return the stored task
    once again as JSON.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Argonaut](img/00016.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: If you send the message a couple of times, you'll notice that the ID of the
    response increases. The reason is that we generate a new ID for newly created
    tasks, so ignore the ID from the incoming JSON message.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created a number of new tasks, you can also get all the stored
    tasks by using the **Step 03 – Get Tasks** request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Argonaut](img/00017.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'When you''ve stored a number of messages, you can also use the API to delete
    tasks. Click on **Step 02 – Delete Task**, change the URL to the ID you want to
    delete (for example, `http://localhost:8080/tasks/3`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你存储了一定数量的消息后，你也可以使用API来删除任务。点击**步骤 02 – 删除任务**，将URL更改为你想删除的ID（例如，`http://localhost:8080/tasks/3`）：
- en: '![Argonaut](img/00018.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Argonaut](img/00018.jpeg)'
- en: If the task with the ID you want to delete exists, it will return **200 Ok**,
    if the ID doesn't exist, you'll see **404 Not Found**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除的任务ID存在，它将返回**200 Ok**，如果ID不存在，你将看到**404 Not Found**。
- en: 'To get this working, the first thing we need to do is get the required Argonaut
    dependencies. For this, we change the dependencies in our SBT build to this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，我们首先需要获取所需的Argonaut依赖项。为此，我们需要更改我们的SBT构建中的依赖项，如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Jackson and Json4s
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jackson 和 Json4s
- en: For Jackson and Json4s, you use the `finch-jackson` and `finch-json4s` modules
    instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Jackson和Json4s，你使用`finch-jackson`和`finch-json4s`模块。
- en: 'To automatically convert our case classes to and from JSON, we need to tell
    Argonaut how we can convert to our case classes and vice versa. For our example,
    we''ve done this in the `chapter2` package object (located in the `package.scala`
    file):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动将我们的case classes转换为JSON以及从JSON转换回来，我们需要告诉Argonaut如何将这些case classes转换为JSON以及反过来。在我们的例子中，我们已经在`chapter2`包对象中完成了这个操作（位于`package.scala`文件中）：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For each of the case classes we want to support, we need a set of implicit values.
    To convert from JSON, we need a `DecodeJson[A]` instance and to convert to JSON,
    a `EncodeJson[A]` instance. Argonaut already provides some helper methods you
    can use to easily create these instances, which we've used in the previous example.
    For instance, with `jdecode2L` (the `2` stands for two arguments), we convert
    two JSON values to a case class, and with `jencode2L`, we convert two parameters
    of a case class to JSON. To learn more about Argonaut, you can look at its website
    at [http://argonaut.io/](http://argonaut.io/); the part that deals with automatic
    conversion (as explained here) can be found at [http://argonaut.io/doc/codec/](http://argonaut.io/doc/codec/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要支持的每个case class，我们需要一组隐式值。为了从JSON转换，我们需要一个`DecodeJson[A]`实例，为了转换为JSON，需要一个`EncodeJson[A]`实例。Argonaut已经提供了一些辅助方法，你可以使用这些方法轻松地创建这些实例，我们在前面的例子中已经使用了这些方法。例如，使用`jdecode2L`（其中的`2`代表两个参数），我们将两个JSON值转换为case
    class，而使用`jencode2L`，我们将case class的两个参数转换为JSON。要了解更多关于Argonaut的信息，你可以查看其网站[http://argonaut.io/](http://argonaut.io/)；处理自动转换的部分（如这里所述）可以在[http://argonaut.io/doc/codec/](http://argonaut.io/doc/codec/)找到。
- en: 'Now that we''ve defined the mapping between JSON and the case classes we''re
    using, we can look at how this changes our implementation. In the following code
    fragment, we see the code that handles the **Create Task**, **Delete Task**, and
    **Get Tasks** requests:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了JSON和我们所使用的case classes之间的映射，我们可以看看这如何改变我们的实现。在下面的代码片段中，我们看到处理**创建任务**、**删除任务**和**获取任务**请求的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we'll look at the `CreateNewTask` class. As you can see, the code has
    become much simpler since we don't have to explicitly define how an incoming request
    is transformed to a `Task` anymore. This time, all we need to do in the `apply`
    function of the `CreateNewTask` service is use the body, `RequestReader`, and
    use `as[Task]` to automatically convert the provided request to a `Task`. This
    works since we implicitly defined a `DecodeJson[Task]` instance. Once the `Task`
    is created from the `Request`, we pass it into the `TaskService` to store it.
    The `TaskService` returns a `Future[Task]`, with the `Task` that is stored (this
    will have the correct ID filled in). Finally, we return `Ok` with the stored `Task`
    as a parameter. Finch will convert this `Ok` object to an `HttpResponse` with
    code 200, and it will convert the provided `Task` to JSON using the implicit `EncodeJson[Task]`
    instance. We'll look a bit closer at how to build and customize the HTTP response
    in the following section. The `GetAllTasks()` class works in pretty much the same
    manner. It retrieves a `Future[Seq[Task]]` object from the `TaskService` instance
    and Finch, together with the implicitly defined objects, and knows how to convert
    this sequence of tasks to the correct JSON message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section, let's quickly look at the `DeleteTask`
    class. As you can see in the code, this case class takes an additional parameter.
    This parameter will contain the long value, which was extracted by the `long`
    extractor in the router that mapped to this `Service`. If you have multiple extractors
    in the router, your case class should have the same amount of parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Request validation and custom responses
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we haven''t looked at what happens when one of our RequestReaders can''t
    read the required information. A header might be missing, a parameter might be
    in the incorrect format, or a cookie isn''t present. If, for instance, you rename
    some fields in the JSON for the **Step 03 – Create Task** request, and make the
    request, it will fail silently:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00019.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Finch, however, provides an elegant way to handle all the exceptions from the
    RequestReaders. First, we''ll look at the result we''ll be aiming for. First,
    start another `sbt` project like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open Postman and use **Step 03 – Create Task** to create some tasks in our database.
    For this example, we've added a search functionality that you can access through
    the **Step 04 – Search Tasks** request.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00020.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'To show how validation works, we''ve added a couple of rules to the request
    parameters. The `status` request parameter is required, and when the `text` parameter
    is used, its value should be at least five characters. To test how this works,
    either remove the `status` parameter or change the value of the `text` parameter
    to something smaller than five characters. The following screenshot shows the
    resulting error messages:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00021.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'The following code fragment shows the case class we use to search the database
    and show changes we have to make to our application to get these validation results:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When a request is passed into this `Service`, the `apply` function is invoked.
    In this function, we pass the request to a `RequestReader[SearchParams]` object
    that looks similar to this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When this `RequestReader` is called with a request, it will first try and get
    the `status` parameter. If this parameter can't be found, a `NotPresent` exception
    will be thrown. This, however, doesn't stop the processing of the request, and
    the `RequestReader` gets the value of the `text` parameter. If the `text` parameter
    is available, it should be longer than five characters (note that we also have
    a `shouldNot` function for when you want to check whether a rule doesn't apply).
    If it isn't, a `NotValid` exception will be thrown. In the previous examples,
    if this happened, the processing of the request would have stopped, and the service
    would not have returned any response. To process these exceptions, we need to
    call the `handle` function on the `Future[HttpResponse]` instance (or the `Future`
    returned from the `RequestReader()` function).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start working with Finch yourself, you might notice that it doesn't
    use the standard `scala.concurrent.Future` class from Scala, but uses `the Future`
    defined in `com.twitter.util.Future`. The reasons are that Finch (and Finagle,
    which is used internally by Finch) is a Twitter project, and that the Future from
    Twitter has a lot of additional functionality. For instance, the `handle` function,
    which is discussed in the next section, is a standard function on the Twitter
    `Future` object. The `TaskService` that we use in this book, however, uses standard
    Scala `Future` objects. To make sure we can easily interoperate between the Scala
    `Future` and Twitter `Future` objects, we've created some implicit conversions.
    If you're interested in how they look, you can find these implicit conversions
    in the `src/main/scala/org/restwithscala/chapter2/package.scala` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `handle` function takes a `partial` function, and in this scenario, it should
    return an `HttpResponse` instance. As you can see in the code, we just convert
    the validation related exceptions as a JSON object and wrap it in a `BadRequest`
    class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we showed we used the `beLongerThan` rule. Finch provides a
    number of standard rules out of the box that you can use to check whether the
    result from a specific `RequestReader` is valid:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Description |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `beLessThan(n: Int)` | This checks whether a numeric value is less than the
    specified integer. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `beGreaterThan(n: Int` | This checks whether a numeric value is greater than
    the specified integer. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `beShorterThan(n: Int)` | This checks whether the length of a string is shorter
    than the specified integer. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `beLongerThan(n: Int)` | This checks whether the length of a string is longer
    than the specified integer. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `and` | This combines two rules together. Both rules must be valid. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `or` | This combine two rules together. One of the rules must be valid. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: 'Creating a custom validation rule is very simple. For instance, the following
    code creates a new rule that checks whether a string contains any uppercase characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we now run a query, we also get a message if we use uppercase characters
    in our `text` parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00022.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'The last part that we''ll look at a bit closely before we move on to the next
    chapter is how to create HTTP responses. We''ve already seen a little bit of this
    with the `Ok`, `BadRequest`, and `NotFound` case classes. Finch also provides
    a number of additional functions to further customize the HTTP response message.
    You can use the following functions to create the response:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `withHeaders(headers: (String, String)*)` | This adds the provided headers
    to the response. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `withCookies(cookies: Cookie*)` | This adds the provided cookies to the response.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `withContentType(contentType: Option[String])` | This sets the content-type
    of the response to the specified `Option[String]` value. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `withCharset(charset: Option[String])` | This sets the character-set of the
    response to the provided `Option[String]` object. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: 'For example, if we wanted to create an `Ok` response with a custom character
    set, a custom content-type, some custom headers, and a string body, we''d do something
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the Finch framework. With the Finch framework,
    you can create REST services using a functional approach. Handling requests is
    done by mapping a request to a `Service`; validating and parsing requests is done
    using a Reader monad, the `RequestReader`; and all the parts are composable to
    create complex routes, RequestReaders, rules, and services from simple parts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive into a Scala REST framework that uses a different
    approach. We'll look at Unfiltered, which uses a pattern matching-based approach
    of defining REST services.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
