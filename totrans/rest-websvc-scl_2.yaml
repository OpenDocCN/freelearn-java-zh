- en: Chapter 2. A Functional-style REST Service with Finagle and Finch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.使用Finagle和Finch的函数式REST服务
- en: 'In this chapter, we''re going to show you how you can create a REST service
    using the Finagle and Finch library. We''ll do this using the following set of
    examples:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何使用Finagle和Finch库创建REST服务。我们将使用以下示例集来完成这项工作：
- en: '**Your first Finagle and Finch service**: In this section, we''ll create a
    minimal REST service, which will simply return a string.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的第一个Finagle和Finch服务**：在本节中，我们将创建一个最小的REST服务，它将简单地返回一个字符串。'
- en: '**HTTP verb and URL matching**: An important part of any REST service is how
    to handle various URL paths and the different HTTP verbs. In this part, we''ll
    show you how Finch supports this through the use of matchers and extractors.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP动词和URL匹配**：任何REST服务的一个重要部分是如何处理各种URL路径和不同的HTTP动词。在本部分中，我们将向您展示Finch如何通过使用匹配器和提取器来支持这一点。'
- en: '**Use RequestReaders to process incoming requests**: When creating a REST service,
    you usually need to get information from the incoming HTTP request. Finch uses
    `RequestReader` instances to access information from the request, which we''ll
    explain in this part.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RequestReaders处理传入请求**：当创建REST服务时，通常需要从传入的HTTP请求中获取信息。Finch使用`RequestReader`实例从请求中访问信息，这部分我们将进行解释。'
- en: '**JSON support**: REST services most often use JSON to represent resources.
    Finch supports a number of different JSON libraries. In this part, we''ll explore
    one of these JSON libraries and how to use it from a Finch service.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON支持**：REST服务通常使用JSON来表示资源。Finch支持多个不同的JSON库。在本部分中，我们将探讨其中一个JSON库以及如何在Finch服务中使用它。'
- en: '**Request validation and custom responses**: The final part of this chapter
    deals with validating incoming requests and creating custom responses. Finch has
    a very elegant way, using `RequestReader` instances and validation rules, to check
    whether incoming requests are valid and can be processed further.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求验证和自定义响应**：本章的最后部分处理验证传入请求和创建自定义响应。Finch使用`RequestReader`实例和验证规则，提供了一种非常优雅的方式来检查传入请求是否有效，并且可以进一步处理。'
- en: Before we start looking at the code, let's quickly look at what Finagle and
    Finch are for libraries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看代码之前，让我们快速了解一下Finagle和Finch对库的作用。
- en: An introduction to Finagle and Finch
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Finagle和Finch简介
- en: 'Finagle and Finch are actually two different frameworks. Finagle is an RPC
    framework, created by Twitter, which you can use to easily create different types
    of service. On its website ([https://github.com/twitter/finagle](https://github.com/twitter/finagle)),
    the team behind Finagle explains it like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Finagle和Finch实际上是两个不同的框架。Finagle是一个由Twitter创建的RPC框架，你可以用它轻松创建不同类型的服务。在其网站([https://github.com/twitter/finagle](https://github.com/twitter/finagle))上，Finagle背后的团队这样解释它：
- en: '*"Finagle is an extensible RPC system for the JVM, used to construct high-concurrency
    servers. Finagle implements uniform client and server APIs for several protocols,
    and is designed for high performance and concurrency. Most of Finagle''s code
    is protocol agnostic, simplifying the implementation of new protocols."*'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Finagle是一个用于JVM的可扩展RPC系统，用于构建高并发服务器。Finagle为几种协议实现了统一的客户端和服务器API，并设计用于高性能和高并发。Finagle的大部分代码与协议无关，简化了新协议的实现。"*'
- en: So, while Finagle provides the plumbing required to create highly scalable services,
    it doesn't provide direct support for specific protocols. This is where Finch
    comes in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然Finagle提供了创建高度可扩展服务所需的基础设施，但它并不直接支持特定协议。这正是Finch发挥作用的地方。
- en: 'Finch ([https://github.com/finagle/finch](https://github.com/finagle/finch))
    provides an HTTP REST layer on top of Finagle. On their website, you can find
    a nice quote which summarizes what Finch aims to do:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Finch([https://github.com/finagle/finch](https://github.com/finagle/finch))在Finagle之上提供了一个HTTP
    REST层。在其网站上，您可以找到一个很好的引言，总结了Finch的目标：
- en: '*"Finch is a thin layer of purely functional basic blocks atop of [http://twitter.github.io/finagle](http://twitter.github.io/finagle)
    for building composable REST APIs. Its mission is to provide the developers simple
    and robust REST API primitives being as close as possible to the bare metal Finagle
    API."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Finch是在[http://twitter.github.io/finagle](http://twitter.github.io/finagle)之上的一个薄层纯函数基本块，用于构建可组合的REST
    API。其使命是提供尽可能接近裸金属Finagle API的简单且健壮的REST API原语。"*'
- en: In this chapter, we'll only be talking about Finch. Note, though, that most
    of the concepts provided by Finch are based on underlying Finagle ideas. Finch
    provides a very nice REST-based set of functions to make working with Finagle
    very easy and intuitive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只将讨论 Finch。请注意，尽管如此，Finch 提供的大部分概念都是基于底层 Finagle 理念的。Finch 提供了一套非常棒的基于
    REST 的函数集，使得与 Finagle 一起工作变得非常简单和直观。
- en: Building your first Finagle and Finch REST service
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您的第一个 Finagle 和 Finch REST 服务
- en: 'Let''s start by building a minimal Finch REST service. The first thing we need
    to do is make sure we have the correct dependencies. Like we mentioned in the
    previous chapter, we use SBT to manage our dependencies. All the dependencies
    for the various chapters can be found in the `Dependencies.scala` file, which
    is located in the `project` directory in the location where you extracted your
    sources. For the Finch examples, which we will see in this chapter, we use the
    following dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个最小的 Finch REST 服务开始。我们首先需要确保我们拥有正确的依赖项。正如我们在上一章中提到的，我们使用 SBT 来管理我们的依赖项。各种章节的所有依赖项都可以在您提取源代码的位置的
    `project` 目录下的 `Dependencies.scala` 文件中找到。对于本章中我们将看到的 Finch 示例，我们使用以下依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This book uses a single SBT file (`build.sbt` located in the root) for all the
    chapters and uses a multimodule approach. Diving into the multimodule setup is
    a bit beyond the scope of this book. If you want to learn more about how we use
    SBT to manage and define the various modules, look at the `build.sbt` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用单个 SBT 文件（位于根目录的 `build.sbt`）来处理所有章节，并采用多模块方法。深入探讨多模块设置超出了本书的范围。如果您想了解更多关于我们如何使用
    SBT 来管理和定义各种模块的信息，请查看 `build.sbt` 文件。
- en: 'Now that we''ve got our library dependencies loaded, we can start coding our
    very first Finch service. The next code fragment (the source can be found at `chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala`)
    shows a minimal Finch service, which just responds with a `Hello, Finch!` message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了库依赖项，我们可以开始编写我们的第一个 Finch 服务。接下来的代码片段（源代码可以在 `chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala`
    找到）展示了一个最小的 Finch 服务，它只响应一个 `Hello, Finch!` 消息：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this service receives a `GET` request on the URL path, `hello`, it will
    respond with a `Hello, Finch!` message. Finch does this by creating a service
    (using the `toService` function) from a route (more on routes is explained in
    the next section) and using the `Httpx.serve` function to host the created service.
    To run this example, open a terminal window in the directory where you''ve extracted
    the sources. In that directory, run the `sbt runCH02-HelloFinch` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当此服务在 URL 路径 `hello` 上收到 `GET` 请求时，它将响应 `Hello, Finch!` 消息。Finch 通过从路由（下一节将详细介绍路由）创建一个服务（使用
    `toService` 函数）并使用 `Httpx.serve` 函数托管创建的服务来实现这一点。要运行此示例，请在您提取源代码的目录中打开一个终端窗口。在那个目录中，运行
    `sbt runCH02-HelloFinch` 命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we have an HTTP server running on port `8080`. When we make
    a call to `http://localhost:8080/hello`, this server will respond with the `Hello,
    Finch!` message. To test this service, we''ve provided an HTTP request in Postman
    (see the previous chapter on how to install Postman and load requests). You can
    use the `GET Hello Finch` request to test the Finch service we just created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个运行在端口 `8080` 上的 HTTP 服务器。当我们调用 `http://localhost:8080/hello` 时，此服务器将响应
    `Hello, Finch!` 消息。为了测试此服务，我们已在 Postman 中提供了一个 HTTP 请求（请参阅上一章了解如何安装 Postman 和加载请求）。您可以使用
    `GET Hello Finch` 请求来测试我们刚刚创建的 Finch 服务：
- en: '![Building your first Finagle and Finch REST service](img/00013.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![构建您的第一个 Finagle 和 Finch REST 服务](img/00013.jpeg)'
- en: HTTP verb and URL matching
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 动词和 URL 匹配
- en: 'An important part of every REST framework is the ability to easily match HTTP
    verbs and the various path segments of the URL. In this section, we''ll look at
    the tools Finch provide us with. Let''s start with getting the service up and
    running though. To run this service, you can use the `sbt runCH02-runCH02Step1`
    command from the source directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 REST 框架的一个重要部分是能够轻松匹配 HTTP 动词和 URL 的各种路径段。在本节中，我们将查看 Finch 提供给我们的工具。让我们先从启动服务开始。要运行此服务，您可以从源代码目录使用
    `sbt runCH02-runCH02Step1` 命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the server is started, you can once again use Postman to make requests
    to this service, using the requests from the **Chapter 02** collection. This service
    just returns a simple text message on each request:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，您就可以再次使用 Postman 向此服务发送请求，使用来自 **第二章** 集合的请求。此服务对每个请求只返回一个简单的文本消息：
- en: '![HTTP verb and URL matching](img/00014.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP 动词和 URL 匹配](img/00014.jpeg)'
- en: 'Now let''s look at some code and see how to do this with Finch (`chapter-02/src/main/scala/org/restwithscala/chapter2/steps/FinchStep1.scala`):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些代码，看看如何使用 Finch (`chapter-02/src/main/scala/org/restwithscala/chapter2/steps/FinchStep1.scala`)
    来实现这一点：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code fragment, we create a number of `Router` instances that process
    the requests which we sent from Postman. Let''s start by looking at one of the
    routes of the `taskAPI` router, `Get / "tasks" / long /> (id => s"Get a single
    task with id: $id")`. The following table explains the various parts of the route:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在此代码片段中，我们创建了一些 `Router` 实例来处理我们从 Postman 发送的请求。让我们先看看 `taskAPI` 路由器的一个路由，`Get
    / "tasks" / long /> (id => s"Get a single task with id: $id")`。以下表格解释了路由的各个部分：'
- en: '| Part | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 部分 | 描述 |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Get` | When writing routers, usually the first thing you do is determine
    which HTTP verb you want to match. In this case, this route will only match the
    `GET` verb. Besides the `Get` matcher, Finch also provides other matchers such
    as `Post`, `Patch`, `Delete`, `Head`, `Options`, `Put`, `Connect`, and `Trace`.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `Get` | 在编写路由器时，通常你做的第一件事是确定你想要匹配哪个 HTTP 动词。在这种情况下，这个路由将只匹配 `GET` 动词。除了 `Get`
    匹配器之外，Finch 还提供了其他匹配器，如 `Post`、`Patch`、`Delete`、`Head`、`Options`、`Put`、`Connect`
    和 `Trace`。|'
- en: '| `"tasks"` | The next part of the route is a matcher that matches a URL path
    segment. In this case, we match the URL, `http://localhost:8080/tasks`. Finch
    will use an implicit conversion to convert this string object to a finch `Matcher`
    object. Finch also has two wildcard matchers: `*` and `**`. The `*` matcher allows
    any value for a single path segment, and the `**` matcher allows any value for
    multiple path segments. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `"tasks"` | 路由的下一部分是一个匹配器，用于匹配 URL 路径段。在这种情况下，我们匹配 URL，`http://localhost:8080/tasks`。Finch
    将使用隐式转换将此字符串对象转换为 finch `Matcher` 对象。Finch 还提供了两个通配符匹配器：`*` 和 `**`。`*` 匹配器允许单个路径段有任意值，而
    `**` 匹配器允许多个路径段有任意值。|'
- en: '| `long` | The next part in the route is called an **extractor**. With an extractor,
    you turn part of the URL into a value which you can use to create the response
    (for example, retrieve an object from the database using the extracted ID). The
    `long` extractor, as the name implies, converts the matching path segment to a
    long value. Finch also provides an int, string, and boolean extractor. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 路由的下一部分被称为 **提取器**。使用提取器，你可以将 URL 的一部分转换为值，然后可以使用它来创建响应（例如，使用提取的
    ID 从数据库中检索对象）。`long` 提取器，正如其名称所暗示的，将匹配的路径段转换为长整型值。Finch 还提供了 int、string 和 boolean
    提取器。|'
- en: '| `long => B` | The last part of the route is used to create the response message.
    Finch provides different ways of creating the response, which we''ll show in the
    other parts of this chapter. In this case, we need to provide Finch with a function
    that transforms the long value we extracted, and returns a value Finch can convert
    to a response (you will learn more on this later). In this example, we just return
    a string. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `long => B` | 路由的最后一部分用于创建响应消息。Finch 提供了不同的方式来创建响应，我们将在本章的其他部分展示。在这种情况下，我们需要向
    Finch 提供一个函数，该函数将转换我们提取的长整型值，并返回一个 Finch 可以转换为响应的值（你将在后面了解更多）。在这个例子中，我们只返回一个字符串。'
- en: 'If you''ve looked closely at the source code, you probably have noticed that
    Finch uses custom operators to combine the various parts of a route. Let''s look
    a bit closer at these. With Finch, we get the following operators (also called
    **combinators** in Finch terms):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看源代码，你可能已经注意到 Finch 使用自定义运算符来组合路由的各个部分。让我们更仔细地看看这些运算符。在 Finch 中，我们得到以下运算符（在
    Finch 术语中也称为 **组合器**）：
- en: '`/` or `andThen`: With this combinator, you sequentially combine various matchers
    and extractors. Whenever the first part matches, the next one is called, for instance,
    `Get / "path" / long`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` 或 `andThen`：使用这个组合器，你可以顺序地组合各种匹配器和提取器。每当第一部分匹配时，就会调用下一个，例如，`Get / "path"
    / long`。'
- en: '`|` or `orElse`: This combinator allows you to combine two routers (or parts
    thereof) as long as they are of the same type. So, we could do `(Get | Post)`
    to create a matcher, which matches the `GET` and `POST` HTTP verbs. In the code
    sample, we''ve also used this to combine all the routes that returned a simple
    string to the `taskAPI` router.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|` 或 `orElse`：这个组合器允许你将两个路由器（或其部分）组合在一起，只要它们是同一类型。因此，我们可以使用 `(Get | Post)`
    来创建一个匹配器，该匹配器匹配 `GET` 和 `POST` HTTP 动词。在代码示例中，我们也使用了它来组合所有返回简单字符串给 `taskAPI` 路由器的路由。'
- en: '`/>` or `map`: With this combinator, we pass the request and any extracted
    values from the path to a function for further processing. The result of the function
    that is called is returned as the HTTP response. As you''ll see in the rest of
    the chapter, there are different ways of processing the HTTP request and creating
    a response.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/>` 或 `map`：使用这个组合器，我们将请求和从路径中提取的任何值传递给一个函数以进行进一步处理。调用函数的结果作为 HTTP 响应返回。正如您将在本章的其余部分看到的那样，有不同方式处理
    HTTP 请求并创建响应。'
- en: '`:+:`: The final combinator allows you to combine two routers together of different
    types. In the example, we have two routers: `taskAPI`, which returns a simple
    string, and `taskCreateAPI`, which uses a `RequestReader` object (through the
    `body` function), to create the response. We can''t combine these with `|` since
    the result is created using two different approaches, so we use the `:+:` combinator.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:+:`: 最终组合器允许您将不同类型的两个路由器组合在一起。在示例中，我们有两个路由器：`taskAPI`，它返回一个简单的字符串，以及 `taskCreateAPI`，它使用
    `RequestReader` 对象（通过 `body` 函数）来创建响应。由于结果是通过两种不同的方法创建的，所以我们不能使用 `|` 来组合它们，而是使用
    `:+:` 组合器。'
- en: So far, we just return simple strings whenever we get a request. In the next
    section, we'll look at how you can use a `RequestReader` instance to convert the
    incoming HTTP requests to case classes and use those to create an HTTP response.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每次收到请求时都只是返回简单的字符串。在下一节中，我们将探讨如何使用 `RequestReader` 实例将传入的 HTTP 请求转换为案例类，并使用这些案例类来创建
    HTTP 响应。
- en: Processing incoming requests using RequestReaders
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RequestReaders 处理传入请求
- en: So far, we haven't done anything yet with the incoming request. In the previous
    example, we just returned a string without using any information from the request.
    Finch provides a very nice model using a **Reader monad**, which you can use to
    easily combine information from an incoming request to instantiate new objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对传入的请求还没有做任何事情。在前面的示例中，我们只是返回了一个字符串，而没有使用请求中的任何信息。Finch 提供了一个非常棒的模型，使用
    **Reader monad**，您可以使用它轻松地将传入请求的信息组合起来以实例化新对象。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A Reader monad is a standard functional design pattern, which allows you to
    define functions that all access the same values. A great explanation of how Reader
    monads work can be found at [http://eed3si9n.com/learning-scalaz/Monad+transformers.html](http://eed3si9n.com/learning-scalaz/Monad+transformers.html).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Reader monad 是一个标准的函数式设计模式，它允许您定义所有访问相同值的函数。关于 Reader monad 的工作原理的精彩解释可以在 [http://eed3si9n.com/learning-scalaz/Monad+transformers.html](http://eed3si9n.com/learning-scalaz/Monad+transformers.html)
    找到。
- en: 'Let''s look at some code that uses a `RequestReader` to process incoming requests
    (the complete source code can be found in the `FinchStep2.scala` file):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用 `RequestReader` 处理传入请求的代码（完整的源代码可以在 `FinchStep2.scala` 文件中找到）：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we see a couple of new things. Instead of directly returning
    a string value, we use a case class that extends from `Service` to process the
    HTTP request and create a response. You can also run this service directly from
    SBT. Running the `sbt runCH02-runCH02Step2` command will start up the service:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们看到一些新事物。我们不是直接返回一个字符串值，而是使用一个从 `Service` 扩展的案例类来处理 HTTP 请求并创建响应。您也可以直接从
    SBT 运行此服务。运行 `sbt runCH02-runCH02Step2` 命令将启动服务：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can test this service once again using Postman. Let''s start by testing
    whether we can create a new task. To do this, open up Postman and fire off the
    request **Step 02 – Create Task**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Postman 再次测试此服务。让我们先测试一下我们是否可以创建一个新的任务。为此，打开 Postman 并执行请求 **步骤 02 – 创建任务**：
- en: '![Processing incoming requests using RequestReaders](img/00015.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用 RequestReaders 处理传入请求](img/00015.jpeg)'
- en: The response we get back starts to look similar to real data. The text we entered
    in `body` as well as the `title` request parameter is used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的响应开始看起来像真实数据。我们在 `body` 中输入的文本以及 `title` 请求参数都被使用了。
- en: 'Let''s look at the router we used to create a new task in detail to see how
    this works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看我们用来创建新任务的路由器，以了解它是如何工作的：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the top of this code fragment, you can see how we define the router that
    handles the create task request we just made through Postman. Whenever a `POST`
    request is made to the `tasks` URL, this router matches and maps the request to
    the function to the right of the `/>` combinator. This time, however, we don''t
    map to a function that returns a string, but we map to a case class that extends
    from `Service`. In our own class, we have to implement the `def apply(request:
    Req): Future[Rep]` function from the abstract `Service` class. In this specific
    example, we specified the type parameters for this service as `Request` and `String`,
    so the `apply` function should transform the incoming `Request` instance to a
    `Future[String]` object.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个代码片段的顶部，你可以看到我们是如何定义处理我们刚刚通过 Postman 发起的创建任务请求的路由器的。每当有 `POST` 请求发送到 `tasks`
    URL 时，这个路由器会匹配并将请求映射到 `/>` 组合符右侧的函数。然而，这一次，我们并没有映射到一个返回字符串的函数，而是映射到一个扩展自 `Service`
    的案例类。在我们的类中，我们必须实现从抽象 `Service` 类中继承的 `def apply(request: Req): Future[Rep]` 函数。在这个特定的例子中，我们为这个服务指定了类型参数为
    `Request` 和 `String`，因此 `apply` 函数应该将传入的 `Request` 实例转换为一个 `Future[String]` 对象。'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the first type parameter, you normally specify `Request` (unless you apply
    filters before processing the request, as we'll explain in the last part of this
    chapter), and the second type parameter should be a type, which Finch can automatically
    convert to an HTTP response. To automatically convert, Finch looks for an implicit
    `EncodeResponse[A]` type-class in scope. Out of the box, Finch will transform
    strings to HTTP responses. It also supports a number of JSON libraries, where
    case classes are automatically converted to HTTP responses with JSON bodies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个类型参数，你通常指定 `Request`（除非你在处理请求之前应用了过滤器，正如我们将在本章的最后部分解释的那样），第二个类型参数应该是 Finch
    可以自动转换为 HTTP 响应的类型。为了自动转换，Finch 会查找作用域中的隐式 `EncodeResponse[A]` 类型类。默认情况下，Finch
    会将字符串转换为 HTTP 响应。它还支持多个 JSON 库，其中案例类会自动转换为带有 JSON 体的 HTTP 响应。
- en: 'In the service for this route, we take a couple of steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个路由的服务的实现中，我们采取了一些步骤：
- en: First, we call the `getRequestToTaskReader` function defined in the base class,
    with the ID of the task we want to create. Since we're creating a new one, we
    just specify `-1` as the ID and let the backend generate a real ID. The result
    from this call is a `RequestReader[Task]` instance, which can convert a request
    into a `Task` class.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们调用在基类中定义的 `getRequestToTaskReader` 函数，并传入我们想要创建的任务的 ID。由于我们正在创建一个新的任务，我们只需指定
    `-1` 作为 ID，让后端生成一个真实的 ID。这个调用的结果是 `RequestReader[Task]` 实例，它可以把一个请求转换为一个 `Task`
    类。
- en: We then directly call the `apply` function on the returned `RequestReader[Task]`
    instance with the passed in request. This call returns a `Future[Task]` object,
    which we process further in the `for` comprehension.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后直接在返回的 `RequestReader[Task]` 实例上调用传入的 `apply` 函数。这个调用返回一个 `Future[Task]`
    对象，我们随后在 `for` 语句中进一步处理它。
- en: When the future from step 2 resolves, we have access to a task. We store this
    task using the `TaskService.insert` method. This call also returns a `Future`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当步骤 2 中的 `future` 解析时，我们就可以访问到一个任务。我们使用 `TaskService.insert` 方法存储这个任务。这个调用同样返回一个
    `Future`。
- en: Finally, we yield the stored `Task` object, as a `Future[Task]` instance.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们返回存储的 `Task` 对象，作为一个 `Future[Task]` 实例。
- en: The last step in the service is converting the `Future[Task]` object to a `Future[String]`
    object, which we just do by using a simple `map` function. The reason we need
    to do this is because Finch doesn't know how to automatically convert `Task` objects
    to an HTTP response.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务的最后一步是将 `Future[Task]` 对象转换为 `Future[String]` 对象，我们只是通过一个简单的 `map` 函数来完成这个操作。我们需要这样做的原因是
    Finch 不知道如何自动将 `Task` 对象转换为 HTTP 响应。
- en: 'Before we move on to the next section, let''s look a bit closer at the `RequestReader[Task]`
    instance we used to convert a `Request` object to a Task object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们更仔细地看看我们用来将 `Request` 对象转换为 `Task` 对象的 `RequestReader[Task]` 实例：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this function, we combine various RequestReader (`body`, `param`, and `RequestReader.value`)
    using the `::` combinator (we''ll explain more about `body`, `param`, and `RequestReader.value`
    in the next section). When we pass in a `Request` to the result of this function,
    each `RequestReader` is executed against the request. The result of all these
    individual steps is combined using the `as[A]` function (you can also use `asTuple`
    to collect the results). Finch standard supports conversion to int, long, float,
    double, and boolean, and also allows you to convert to a case class. In this last
    case, you have to make sure the result from the individual `RequestReader` matches
    the constructor of your case class. In this example, `Task` is defined like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`::`组合子将各种`RequestReader`（`body`、`param`和`RequestReader.value`）组合起来（我们将在下一节中详细解释`body`、`param`和`RequestReader.value`）。当我们向这个函数的结果传递一个`Request`时，每个`RequestReader`都会对请求执行。所有这些单独步骤的结果将使用`as[A]`函数组合（你也可以使用`asTuple`来收集结果）。Finch标准支持转换为int、long、float、double和boolean，还允许你转换为case类。在最后一种情况下，你必须确保来自单个`RequestReader`的结果与你的case类的构造函数匹配。在这个例子中，`Task`被定义为如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And this matches the results of the individual RequestReaders. Should you want
    to convert to a type that isn''t supported, you can very simply write your own,
    and just make sure it is in scope:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单个`RequestReader`的结果相匹配。如果你想要转换到不支持的数据类型，你可以非常简单地编写自己的，只需确保它在作用域内：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the example code so far, we''ve only used a couple of RequestReaders: `param`
    and `body`. Finch provides a number of other readers you can use to access information
    from the HTTP request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止的示例代码中，我们只使用了几个`RequestReader`：`param`和`body`。Finch提供了一些其他读者，你可以使用它们来访问HTTP请求中的信息：
- en: '| Reader | Description |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 读取器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `param(name)` | This returns the request parameter as a string and throws
    a `NotPresent` exception when the parameter can''t be found. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `param(name)` | 这将返回请求参数作为字符串，当参数找不到时抛出`NotPresent`异常。 |'
- en: '| `paramOption(name)` | This returns the request parameter as an `Option[String]`
    object. This call will always succeed. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `paramOption(name)` | 这将返回请求参数作为`Option[String]`对象。这个调用总是会成功。 |'
- en: '| `paramsNonEmpty(name)` | This returns a multivalue parameter as a `Seq[String]`
    object. If the parameter can''t be found, a `NotPresent` exception is thrown.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `paramsNonEmpty(name)` | 这将返回一个多值参数作为`Seq[String]`对象。如果参数找不到，将抛出`NotPresent`异常。
    |'
- en: '| `params(name)` | This returns a multivalue parameter (for example, `?id=1,2,3&b=1&b=2`)
    as a `Seq[String]` object. If the parameter can''t be found, an empty list is
    returned. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `params(name)` | 这将返回一个多值参数（例如，`?id=1,2,3&b=1&b=2`）作为`Seq[String]`对象。如果参数找不到，将返回一个空列表。
    |'
- en: '| `header(name)` | This returns a request header with the specified name as
    a string and throws a `NotPresent` exception when the header can''t be found.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `header(name)` | 这将返回一个指定名称的请求头作为字符串，当头找不到时抛出`NotPresent`异常。 |'
- en: '| `headerOption(name)` | This returns a request header with the specified name
    as an `Option[String]` object. This call will always succeed. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `headerOption(name)` | 这返回一个指定名称的请求头作为`Option[String]`对象。这个调用总是会成功。 |'
- en: '| `cookie(name)` | This gets a `Cookie` object from the request. If the specified
    cookie isn''t present, a `NotPresent` exception is thrown. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `cookie(name)` | 这从请求中获取一个`Cookie`对象。如果指定的cookie不存在，将抛出`NotPresent`异常。 |'
- en: '| `cookieOption(name)` | This gets a `Cookie` object from the request. This
    call will always succeed. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `cookieOption(name)` | 这从请求中获取一个`Cookie`对象。这个调用总是会成功。 |'
- en: '| `body` | This returns the request body name as a string and throws a `NotPresent`
    exception when there is no body present. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `body` | 这将返回请求体名称作为字符串，当没有请求体时抛出`NotPresent`异常。 |'
- en: '| `bodyOption` | This returns the body as an `Option[String]` object. This
    call will always succeed. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `bodyOption` | 这将返回请求体作为`Option[String]`对象。这个调用总是会成功。 |'
- en: '| `binaryBody` | This returns the request body name as an `Array[Byte]` object
    and throws a `NotPresent` exception when there is no body present. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `binaryBody` | 这将返回请求体名称作为`Array[Byte]`对象，当没有请求体时抛出`NotPresent`异常。 |'
- en: '| `binaryBodyOption` | This returns the body as an `Option[Array[Byte]]` object.
    This call will always succeed. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `binaryBodyOption` | 这将返回请求体作为`Option[Array[Byte]]`对象。这个调用总是会成功。 |'
- en: '| `fileUpload` | This `RequestReader` reads an upload (a multipart/form) parameter
    from the request and throws a `NotPresent` exception when the upload can''t be
    found. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `fileUpload` | 这个`RequestReader`从请求中读取上传（multipart/form）参数，当上传找不到时抛出`NotPresent`异常。
    |'
- en: '| `fileUploadOption` | This `RequestReader` reads an upload (a multipart/form)
    parameter from the request. This call will always succeed. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `fileUploadOption` | 这个 `RequestReader` 从请求中读取一个上传（一个多部分/表单）参数。这个调用总是会成功。|'
- en: 'As you can see from this table, a large number of RequestReaders types are
    already available, and in most cases, this should be enough to handle your requirements.
    If the `RequestReader` object does not provide the required functionality, a number
    of helper functions are available that you can use to create your own custom `RequestReader`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从表中看到的，已经有很多种 `RequestReader` 类型可用，在大多数情况下，这应该足以满足您的需求。如果 `RequestReader`
    对象不提供所需的功能，还有一些辅助函数可供您使用，以创建您自己的自定义 `RequestReader`：
- en: '| Function | Description |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `value[A](value: A):``RequestReader[A]` | This function creates a `RequestReader`
    instance that always succeeds and returns the specified value. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `value[A](value: A):``RequestReader[A]` | 此函数创建一个 `RequestReader` 实例，该实例始终成功并返回指定的值。|'
- en: '| `exception[A](exc: Throwable):``RequestReader[A]` | This function creates
    a `RequestReader` instance that always fails with the specified exception. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `exception[A](exc: Throwable):``RequestReader[A]` | 此函数创建一个 `RequestReader`
    实例，该实例始终失败并带有指定的异常。|'
- en: '| `const[A](value: Future[A]):``RequestReader[A]` | This `RequestReader` will
    just return the specified value. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `const[A](value: Future[A]):``RequestReader[A]` | 这个 `RequestReader` 将仅返回指定的值。|'
- en: '| `apply[A](f: HttpRequest => A):``RequestReader[A]` | This function returns
    a `RequestReader` instance that applies the provided function. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `apply[A](f: HttpRequest => A):``RequestReader[A]` | 此函数返回一个 `RequestReader`
    实例，该实例应用提供的函数。|'
- en: There is one part of the `RequestReader` that we haven't discussed yet. What
    happens when a `RequestReader` fails? Finch has a very elegant mechanism to handle
    these validation errors. We'll come back to that in the last part of this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestReader` 中还有一部分我们尚未讨论。当 `RequestReader` 失败时会发生什么？Finch 有一个非常优雅的机制来处理这些验证错误。我们将在本章的最后部分回到这一点。'
- en: JSON support
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 支持
- en: 'So far, we''ve just worked with plain strings as responses. In this section,
    we''ll expand the previous sample and add JSON support and show you how you can
    control which HTTP response code should be used when handling a request. Using
    JSON with Finch is very straightforward since Finch already supports a number
    of JSON libraries out of the box:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是使用纯字符串作为响应。在本节中，我们将扩展前面的示例并添加 JSON 支持，并展示您如何在处理请求时控制应使用哪个 HTTP 响应代码。由于
    Finch 已经支持许多 JSON 库，因此使用 JSON 与 Finch 非常简单：
- en: Argonaut ([http://argonaut.io/](http://argonaut.io/)).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argonaut ([http://argonaut.io/](http://argonaut.io/)).
- en: Jackson ([https://github.com/FasterXML/Jackson](https://github.com/FasterXML/Jackson))
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jackson ([https://github.com/FasterXML/Jackson](https://github.com/FasterXML/Jackson))
- en: Json4s ([http://json4s.org/](http://json4s.org/))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Json4s ([http://json4s.org/](http://json4s.org/))
- en: Argonaut
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Argonaut
- en: In this section, we'll look at how to use the Argonaut library to automatically
    convert our model (our case classes) to JSON. Should you want to use one of the
    other libraries, they work in pretty much the same manner.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 Argonaut 库自动将我们的模型（我们的案例类）转换为 JSON。如果您想使用其他库之一，它们的工作方式几乎相同。
- en: 'We''ll start by looking at the request and response message that our service
    should work with for this scenario. First, start up the server using the `sbt
    runCH02-runCH02Step3` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看我们的服务应该为这个场景处理请求和响应消息。首先，使用`sbt runCH02-runCH02Step3`命令启动服务器：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the server is started, open Postman and select the request **Step 03 –
    Create Task** from the **Chapter 02** collection. When you send this request,
    the server will parse this to a case class, store it, and return the stored task
    once again as JSON.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，打开 Postman 并从**第二章**集合中选择请求**步骤 03 – 创建任务**。当您发送此请求时，服务器将将其解析为案例类，存储它，并将存储的任务再次作为
    JSON 返回。
- en: '![Argonaut](img/00016.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Argonaut](img/00016.jpeg)'
- en: If you send the message a couple of times, you'll notice that the ID of the
    response increases. The reason is that we generate a new ID for newly created
    tasks, so ignore the ID from the incoming JSON message.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发送消息几次，您会注意到响应的 ID 会增加。原因是我们为新建的任务生成一个新的 ID，所以请忽略来自 JSON 消息的 ID。
- en: 'Once you''ve created a number of new tasks, you can also get all the stored
    tasks by using the **Step 03 – Get Tasks** request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了多个新任务，您也可以使用**步骤 03 – 获取任务**请求来获取所有存储的任务：
- en: '![Argonaut](img/00017.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Argonaut](img/00017.jpeg)'
- en: 'When you''ve stored a number of messages, you can also use the API to delete
    tasks. Click on **Step 02 – Delete Task**, change the URL to the ID you want to
    delete (for example, `http://localhost:8080/tasks/3`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你存储了一定数量的消息后，你也可以使用API来删除任务。点击**步骤 02 – 删除任务**，将URL更改为你想删除的ID（例如，`http://localhost:8080/tasks/3`）：
- en: '![Argonaut](img/00018.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Argonaut](img/00018.jpeg)'
- en: If the task with the ID you want to delete exists, it will return **200 Ok**,
    if the ID doesn't exist, you'll see **404 Not Found**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除的任务ID存在，它将返回**200 Ok**，如果ID不存在，你将看到**404 Not Found**。
- en: 'To get this working, the first thing we need to do is get the required Argonaut
    dependencies. For this, we change the dependencies in our SBT build to this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，我们首先需要获取所需的Argonaut依赖项。为此，我们需要更改我们的SBT构建中的依赖项，如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Jackson and Json4s
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jackson 和 Json4s
- en: For Jackson and Json4s, you use the `finch-jackson` and `finch-json4s` modules
    instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Jackson和Json4s，你使用`finch-jackson`和`finch-json4s`模块。
- en: 'To automatically convert our case classes to and from JSON, we need to tell
    Argonaut how we can convert to our case classes and vice versa. For our example,
    we''ve done this in the `chapter2` package object (located in the `package.scala`
    file):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动将我们的case classes转换为JSON以及从JSON转换回来，我们需要告诉Argonaut如何将这些case classes转换为JSON以及反过来。在我们的例子中，我们已经在`chapter2`包对象中完成了这个操作（位于`package.scala`文件中）：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For each of the case classes we want to support, we need a set of implicit values.
    To convert from JSON, we need a `DecodeJson[A]` instance and to convert to JSON,
    a `EncodeJson[A]` instance. Argonaut already provides some helper methods you
    can use to easily create these instances, which we've used in the previous example.
    For instance, with `jdecode2L` (the `2` stands for two arguments), we convert
    two JSON values to a case class, and with `jencode2L`, we convert two parameters
    of a case class to JSON. To learn more about Argonaut, you can look at its website
    at [http://argonaut.io/](http://argonaut.io/); the part that deals with automatic
    conversion (as explained here) can be found at [http://argonaut.io/doc/codec/](http://argonaut.io/doc/codec/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要支持的每个case class，我们需要一组隐式值。为了从JSON转换，我们需要一个`DecodeJson[A]`实例，为了转换为JSON，需要一个`EncodeJson[A]`实例。Argonaut已经提供了一些辅助方法，你可以使用这些方法轻松地创建这些实例，我们在前面的例子中已经使用了这些方法。例如，使用`jdecode2L`（其中的`2`代表两个参数），我们将两个JSON值转换为case
    class，而使用`jencode2L`，我们将case class的两个参数转换为JSON。要了解更多关于Argonaut的信息，你可以查看其网站[http://argonaut.io/](http://argonaut.io/)；处理自动转换的部分（如这里所述）可以在[http://argonaut.io/doc/codec/](http://argonaut.io/doc/codec/)找到。
- en: 'Now that we''ve defined the mapping between JSON and the case classes we''re
    using, we can look at how this changes our implementation. In the following code
    fragment, we see the code that handles the **Create Task**, **Delete Task**, and
    **Get Tasks** requests:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了JSON和我们所使用的case classes之间的映射，我们可以看看这如何改变我们的实现。在下面的代码片段中，我们看到处理**创建任务**、**删除任务**和**获取任务**请求的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we'll look at the `CreateNewTask` class. As you can see, the code has
    become much simpler since we don't have to explicitly define how an incoming request
    is transformed to a `Task` anymore. This time, all we need to do in the `apply`
    function of the `CreateNewTask` service is use the body, `RequestReader`, and
    use `as[Task]` to automatically convert the provided request to a `Task`. This
    works since we implicitly defined a `DecodeJson[Task]` instance. Once the `Task`
    is created from the `Request`, we pass it into the `TaskService` to store it.
    The `TaskService` returns a `Future[Task]`, with the `Task` that is stored (this
    will have the correct ID filled in). Finally, we return `Ok` with the stored `Task`
    as a parameter. Finch will convert this `Ok` object to an `HttpResponse` with
    code 200, and it will convert the provided `Task` to JSON using the implicit `EncodeJson[Task]`
    instance. We'll look a bit closer at how to build and customize the HTTP response
    in the following section. The `GetAllTasks()` class works in pretty much the same
    manner. It retrieves a `Future[Seq[Task]]` object from the `TaskService` instance
    and Finch, together with the implicitly defined objects, and knows how to convert
    this sequence of tasks to the correct JSON message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`CreateNewTask`类。正如你所见，由于我们不再需要显式定义如何将传入的请求转换为一个`Task`，代码已经变得简单多了。这次，在`CreateNewTask`服务的`apply`函数中，我们只需要使用正文、`RequestReader`，并使用`as[Task]`自动将提供的请求转换为`Task`。这之所以可行，是因为我们隐式地定义了一个`DecodeJson[Task]`实例。一旦从`Request`创建出`Task`，我们就将其传递给`TaskService`以存储它。`TaskService`返回一个`Future[Task]`，其中包含存储的`Task`（这将填充正确的ID）。最后，我们返回带有存储的`Task`作为参数的`Ok`。Finch将这个`Ok`对象转换为带有代码200的`HttpResponse`，并使用隐式的`EncodeJson[Task]`实例将提供的`Task`转换为JSON。我们将在下一节更详细地看看如何构建和自定义HTTP响应。`GetAllTasks()`类基本上以相同的方式工作。它从`TaskService`实例检索一个`Future[Seq[Task]]`对象，Finch以及隐式定义的对象，并且知道如何将这个任务序列转换为正确的JSON消息。
- en: Before we move on to the next section, let's quickly look at the `DeleteTask`
    class. As you can see in the code, this case class takes an additional parameter.
    This parameter will contain the long value, which was extracted by the `long`
    extractor in the router that mapped to this `Service`. If you have multiple extractors
    in the router, your case class should have the same amount of parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们快速看一下`DeleteTask`类。正如你在代码中所见，这个case类有一个额外的参数。这个参数将包含由映射到这个`Service`的`router`中的`long`提取器提取的长值。如果你在`router`中有多个提取器，你的case类应该有相同数量的参数。
- en: Request validation and custom responses
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求验证和自定义响应
- en: 'So far, we haven''t looked at what happens when one of our RequestReaders can''t
    read the required information. A header might be missing, a parameter might be
    in the incorrect format, or a cookie isn''t present. If, for instance, you rename
    some fields in the JSON for the **Step 03 – Create Task** request, and make the
    request, it will fail silently:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有查看当我们的某个RequestReader无法读取所需信息时会发生什么。一个头可能缺失，一个参数可能格式不正确，或者一个cookie不存在。例如，如果你将**步骤03
    – 创建任务**请求中的JSON字段的某些名称重命名，并发出请求，它将静默失败：
- en: '![Request validation and custom responses](img/00019.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![请求验证和自定义响应](img/00019.jpeg)'
- en: 'Finch, however, provides an elegant way to handle all the exceptions from the
    RequestReaders. First, we''ll look at the result we''ll be aiming for. First,
    start another `sbt` project like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Finch提供了一种优雅的方式来处理所有来自RequestReaders的异常。首先，我们将看看我们想要达到的结果。首先，启动另一个类似于这样的`sbt`项目：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open Postman and use **Step 03 – Create Task** to create some tasks in our database.
    For this example, we've added a search functionality that you can access through
    the **Step 04 – Search Tasks** request.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Postman并使用**步骤03 – 创建任务**来创建一些数据库中的任务。对于这个示例，我们添加了一个可以通过**步骤04 – 搜索任务**请求访问的搜索功能。
- en: '![Request validation and custom responses](img/00020.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![请求验证和自定义响应](img/00020.jpeg)'
- en: 'To show how validation works, we''ve added a couple of rules to the request
    parameters. The `status` request parameter is required, and when the `text` parameter
    is used, its value should be at least five characters. To test how this works,
    either remove the `status` parameter or change the value of the `text` parameter
    to something smaller than five characters. The following screenshot shows the
    resulting error messages:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示验证是如何工作的，我们在请求参数中添加了一些规则。`status`请求参数是必需的，当使用`text`参数时，其值应该至少有五个字符。为了测试这是如何工作的，你可以移除`status`参数，或者将`text`参数的值更改为小于五个字符的内容。下面的截图显示了产生的错误消息：
- en: '![Request validation and custom responses](img/00021.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![请求验证和自定义响应](img/00021.jpeg)'
- en: 'The following code fragment shows the case class we use to search the database
    and show changes we have to make to our application to get these validation results:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了用于搜索数据库和展示我们必须对我们的应用程序进行哪些更改以获得这些验证结果的case class：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When a request is passed into this `Service`, the `apply` function is invoked.
    In this function, we pass the request to a `RequestReader[SearchParams]` object
    that looks similar to this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个请求传递到这个`Service`时，会调用`apply`函数。在这个函数中，我们将请求传递给一个类似于下面的`RequestReader[SearchParams]`对象：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When this `RequestReader` is called with a request, it will first try and get
    the `status` parameter. If this parameter can't be found, a `NotPresent` exception
    will be thrown. This, however, doesn't stop the processing of the request, and
    the `RequestReader` gets the value of the `text` parameter. If the `text` parameter
    is available, it should be longer than five characters (note that we also have
    a `shouldNot` function for when you want to check whether a rule doesn't apply).
    If it isn't, a `NotValid` exception will be thrown. In the previous examples,
    if this happened, the processing of the request would have stopped, and the service
    would not have returned any response. To process these exceptions, we need to
    call the `handle` function on the `Future[HttpResponse]` instance (or the `Future`
    returned from the `RequestReader()` function).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个`RequestReader`被一个请求调用时，它将首先尝试获取`status`参数。如果这个参数找不到，将会抛出一个`NotPresent`异常。然而，这并不会停止请求的处理，`RequestReader`会获取`text`参数的值。如果`text`参数可用，它应该至少有五个字符长（注意，我们还有一个`shouldNot`函数，用于当你想要检查一个规则不适用时）。如果不是，将会抛出一个`NotValid`异常。在前面的例子中，如果发生这种情况，请求的处理将会停止，并且服务不会返回任何响应。为了处理这些异常，我们需要在`Future[HttpResponse]`实例（或`RequestReader()`函数返回的`Future`）上调用`handle`函数。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you start working with Finch yourself, you might notice that it doesn't
    use the standard `scala.concurrent.Future` class from Scala, but uses `the Future`
    defined in `com.twitter.util.Future`. The reasons are that Finch (and Finagle,
    which is used internally by Finch) is a Twitter project, and that the Future from
    Twitter has a lot of additional functionality. For instance, the `handle` function,
    which is discussed in the next section, is a standard function on the Twitter
    `Future` object. The `TaskService` that we use in this book, however, uses standard
    Scala `Future` objects. To make sure we can easily interoperate between the Scala
    `Future` and Twitter `Future` objects, we've created some implicit conversions.
    If you're interested in how they look, you can find these implicit conversions
    in the `src/main/scala/org/restwithscala/chapter2/package.scala` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始自己使用Finch时，你可能会注意到它不使用Scala的标准`scala.concurrent.Future`类，而是使用`com.twitter.util.Future`中定义的`Future`。原因在于Finch（以及Finch内部使用的Finagle，它是一个Twitter项目），Twitter的Future有很多额外的功能。例如，下一节中讨论的`handle`函数是Twitter
    `Future`对象上的标准函数。然而，我们在这本书中使用的`TaskService`使用标准的Scala `Future`对象。为了确保我们能够轻松地在Scala
    `Future`和Twitter `Future`对象之间进行交互，我们创建了一些隐式转换。如果你对它们的外观感兴趣，你可以在`src/main/scala/org/restwithscala/chapter2/package.scala`文件中找到这些隐式转换。
- en: The `handle` function takes a `partial` function, and in this scenario, it should
    return an `HttpResponse` instance. As you can see in the code, we just convert
    the validation related exceptions as a JSON object and wrap it in a `BadRequest`
    class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`函数接受一个部分函数，在这个场景中，它应该返回一个`HttpResponse`实例。正如你在代码中看到的，我们只是将验证相关的异常转换为JSON对象，并包装在`BadRequest`类中。'
- en: 'In the example, we showed we used the `beLongerThan` rule. Finch provides a
    number of standard rules out of the box that you can use to check whether the
    result from a specific `RequestReader` is valid:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们展示了我们使用了 `beLongerThan` 规则。Finch提供了一些标准规则，您可以使用这些规则来检查特定 `RequestReader`
    的结果是否有效：
- en: '| Rule | Description |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 规则 | 描述 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `beLessThan(n: Int)` | This checks whether a numeric value is less than the
    specified integer. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `beLessThan(n: Int)` | 这检查数值是否小于指定的整数。 |'
- en: '| `beGreaterThan(n: Int` | This checks whether a numeric value is greater than
    the specified integer. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `beGreaterThan(n: Int` | 这检查数值是否大于指定的整数。 |'
- en: '| `beShorterThan(n: Int)` | This checks whether the length of a string is shorter
    than the specified integer. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `beShorterThan(n: Int)` | 这检查字符串的长度是否小于指定的整数。 |'
- en: '| `beLongerThan(n: Int)` | This checks whether the length of a string is longer
    than the specified integer. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `beLongerThan(n: Int)` | 这检查字符串的长度是否大于指定的整数。 |'
- en: '| `and` | This combines two rules together. Both rules must be valid. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 这将两个规则组合在一起。两个规则都必须是有效的。 |'
- en: '| `or` | This combine two rules together. One of the rules must be valid. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 这将两个规则组合在一起。其中必须有一个规则是有效的。 |'
- en: 'Creating a custom validation rule is very simple. For instance, the following
    code creates a new rule that checks whether a string contains any uppercase characters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义验证规则非常简单。例如，以下代码创建了一个新规则，用于检查字符串是否包含任何大写字母：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we now run a query, we also get a message if we use uppercase characters
    in our `text` parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行查询时，如果我们使用大写字母作为 `text` 参数，我们也会收到一条消息：
- en: '![Request validation and custom responses](img/00022.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![请求验证和自定义响应](img/00022.jpeg)'
- en: 'The last part that we''ll look at a bit closely before we move on to the next
    chapter is how to create HTTP responses. We''ve already seen a little bit of this
    with the `Ok`, `BadRequest`, and `NotFound` case classes. Finch also provides
    a number of additional functions to further customize the HTTP response message.
    You can use the following functions to create the response:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一章之前，我们将更详细地研究最后一部分，即如何创建HTTP响应。我们已经通过 `Ok`、`BadRequest` 和 `NotFound`
    情况类看到了一些这方面的内容。Finch还提供了一些额外的函数来进一步自定义HTTP响应消息。您可以使用以下函数来创建响应：
- en: '| Function | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `withHeaders(headers: (String, String)*)` | This adds the provided headers
    to the response. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `withHeaders(headers: (String, String)*)` | 这会将提供的头添加到响应中。 |'
- en: '| `withCookies(cookies: Cookie*)` | This adds the provided cookies to the response.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `withCookies(cookies: Cookie*)` | 这会将提供的cookie添加到响应中。 |'
- en: '| `withContentType(contentType: Option[String])` | This sets the content-type
    of the response to the specified `Option[String]` value. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `withContentType(contentType: Option[String])` | 这将响应的内容类型设置为指定的 `Option[String]`
    值。 |'
- en: '| `withCharset(charset: Option[String])` | This sets the character-set of the
    response to the provided `Option[String]` object. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `withCharset(charset: Option[String])` | 这将响应的字符集设置为提供的 `Option[String]`
    对象。 |'
- en: 'For example, if we wanted to create an `Ok` response with a custom character
    set, a custom content-type, some custom headers, and a string body, we''d do something
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个具有自定义字符集、自定义内容类型、一些自定义头和字符串体的 `Ok` 响应，我们会这样做：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the Finch framework. With the Finch framework,
    you can create REST services using a functional approach. Handling requests is
    done by mapping a request to a `Service`; validating and parsing requests is done
    using a Reader monad, the `RequestReader`; and all the parts are composable to
    create complex routes, RequestReaders, rules, and services from simple parts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Finch框架。使用Finch框架，您可以使用函数式方法创建REST服务。请求处理是通过将请求映射到 `Service` 来完成的；使用
    `RequestReader` 验证和解析请求；所有部分都是可组合的，可以从简单部分创建复杂的路由、请求读取器、规则和服务。
- en: In the next chapter, we'll dive into a Scala REST framework that uses a different
    approach. We'll look at Unfiltered, which uses a pattern matching-based approach
    of defining REST services.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究一个采用不同方法的Scala REST框架。我们将探讨Unfiltered，它使用基于模式匹配的方法来定义REST服务。
