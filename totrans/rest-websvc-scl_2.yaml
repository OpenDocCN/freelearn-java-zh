- en: Chapter 2. A Functional-style REST Service with Finagle and Finch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to show you how you can create a REST service
    using the Finagle and Finch library. We''ll do this using the following set of
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your first Finagle and Finch service**: In this section, we''ll create a
    minimal REST service, which will simply return a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP verb and URL matching**: An important part of any REST service is how
    to handle various URL paths and the different HTTP verbs. In this part, we''ll
    show you how Finch supports this through the use of matchers and extractors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use RequestReaders to process incoming requests**: When creating a REST service,
    you usually need to get information from the incoming HTTP request. Finch uses
    `RequestReader` instances to access information from the request, which we''ll
    explain in this part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON support**: REST services most often use JSON to represent resources.
    Finch supports a number of different JSON libraries. In this part, we''ll explore
    one of these JSON libraries and how to use it from a Finch service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request validation and custom responses**: The final part of this chapter
    deals with validating incoming requests and creating custom responses. Finch has
    a very elegant way, using `RequestReader` instances and validation rules, to check
    whether incoming requests are valid and can be processed further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start looking at the code, let's quickly look at what Finagle and
    Finch are for libraries.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Finagle and Finch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finagle and Finch are actually two different frameworks. Finagle is an RPC
    framework, created by Twitter, which you can use to easily create different types
    of service. On its website ([https://github.com/twitter/finagle](https://github.com/twitter/finagle)),
    the team behind Finagle explains it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Finagle is an extensible RPC system for the JVM, used to construct high-concurrency
    servers. Finagle implements uniform client and server APIs for several protocols,
    and is designed for high performance and concurrency. Most of Finagle''s code
    is protocol agnostic, simplifying the implementation of new protocols."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, while Finagle provides the plumbing required to create highly scalable services,
    it doesn't provide direct support for specific protocols. This is where Finch
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finch ([https://github.com/finagle/finch](https://github.com/finagle/finch))
    provides an HTTP REST layer on top of Finagle. On their website, you can find
    a nice quote which summarizes what Finch aims to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Finch is a thin layer of purely functional basic blocks atop of [http://twitter.github.io/finagle](http://twitter.github.io/finagle)
    for building composable REST APIs. Its mission is to provide the developers simple
    and robust REST API primitives being as close as possible to the bare metal Finagle
    API."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we'll only be talking about Finch. Note, though, that most
    of the concepts provided by Finch are based on underlying Finagle ideas. Finch
    provides a very nice REST-based set of functions to make working with Finagle
    very easy and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first Finagle and Finch REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by building a minimal Finch REST service. The first thing we need
    to do is make sure we have the correct dependencies. Like we mentioned in the
    previous chapter, we use SBT to manage our dependencies. All the dependencies
    for the various chapters can be found in the `Dependencies.scala` file, which
    is located in the `project` directory in the location where you extracted your
    sources. For the Finch examples, which we will see in this chapter, we use the
    following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This book uses a single SBT file (`build.sbt` located in the root) for all the
    chapters and uses a multimodule approach. Diving into the multimodule setup is
    a bit beyond the scope of this book. If you want to learn more about how we use
    SBT to manage and define the various modules, look at the `build.sbt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got our library dependencies loaded, we can start coding our
    very first Finch service. The next code fragment (the source can be found at `chapter-02/src/main/scala/org/restwithscala/chapter2/gettingstarted/HelloFinch.scala`)
    shows a minimal Finch service, which just responds with a `Hello, Finch!` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When this service receives a `GET` request on the URL path, `hello`, it will
    respond with a `Hello, Finch!` message. Finch does this by creating a service
    (using the `toService` function) from a route (more on routes is explained in
    the next section) and using the `Httpx.serve` function to host the created service.
    To run this example, open a terminal window in the directory where you''ve extracted
    the sources. In that directory, run the `sbt runCH02-HelloFinch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have an HTTP server running on port `8080`. When we make
    a call to `http://localhost:8080/hello`, this server will respond with the `Hello,
    Finch!` message. To test this service, we''ve provided an HTTP request in Postman
    (see the previous chapter on how to install Postman and load requests). You can
    use the `GET Hello Finch` request to test the Finch service we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your first Finagle and Finch REST service](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTTP verb and URL matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important part of every REST framework is the ability to easily match HTTP
    verbs and the various path segments of the URL. In this section, we''ll look at
    the tools Finch provide us with. Let''s start with getting the service up and
    running though. To run this service, you can use the `sbt runCH02-runCH02Step1`
    command from the source directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is started, you can once again use Postman to make requests
    to this service, using the requests from the **Chapter 02** collection. This service
    just returns a simple text message on each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP verb and URL matching](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s look at some code and see how to do this with Finch (`chapter-02/src/main/scala/org/restwithscala/chapter2/steps/FinchStep1.scala`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment, we create a number of `Router` instances that process
    the requests which we sent from Postman. Let''s start by looking at one of the
    routes of the `taskAPI` router, `Get / "tasks" / long /> (id => s"Get a single
    task with id: $id")`. The following table explains the various parts of the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Part | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Get` | When writing routers, usually the first thing you do is determine
    which HTTP verb you want to match. In this case, this route will only match the
    `GET` verb. Besides the `Get` matcher, Finch also provides other matchers such
    as `Post`, `Patch`, `Delete`, `Head`, `Options`, `Put`, `Connect`, and `Trace`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `"tasks"` | The next part of the route is a matcher that matches a URL path
    segment. In this case, we match the URL, `http://localhost:8080/tasks`. Finch
    will use an implicit conversion to convert this string object to a finch `Matcher`
    object. Finch also has two wildcard matchers: `*` and `**`. The `*` matcher allows
    any value for a single path segment, and the `**` matcher allows any value for
    multiple path segments. |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | The next part in the route is called an **extractor**. With an extractor,
    you turn part of the URL into a value which you can use to create the response
    (for example, retrieve an object from the database using the extracted ID). The
    `long` extractor, as the name implies, converts the matching path segment to a
    long value. Finch also provides an int, string, and boolean extractor. |'
  prefs: []
  type: TYPE_TB
- en: '| `long => B` | The last part of the route is used to create the response message.
    Finch provides different ways of creating the response, which we''ll show in the
    other parts of this chapter. In this case, we need to provide Finch with a function
    that transforms the long value we extracted, and returns a value Finch can convert
    to a response (you will learn more on this later). In this example, we just return
    a string. |'
  prefs: []
  type: TYPE_TB
- en: 'If you''ve looked closely at the source code, you probably have noticed that
    Finch uses custom operators to combine the various parts of a route. Let''s look
    a bit closer at these. With Finch, we get the following operators (also called
    **combinators** in Finch terms):'
  prefs: []
  type: TYPE_NORMAL
- en: '`/` or `andThen`: With this combinator, you sequentially combine various matchers
    and extractors. Whenever the first part matches, the next one is called, for instance,
    `Get / "path" / long`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|` or `orElse`: This combinator allows you to combine two routers (or parts
    thereof) as long as they are of the same type. So, we could do `(Get | Post)`
    to create a matcher, which matches the `GET` and `POST` HTTP verbs. In the code
    sample, we''ve also used this to combine all the routes that returned a simple
    string to the `taskAPI` router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/>` or `map`: With this combinator, we pass the request and any extracted
    values from the path to a function for further processing. The result of the function
    that is called is returned as the HTTP response. As you''ll see in the rest of
    the chapter, there are different ways of processing the HTTP request and creating
    a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:+:`: The final combinator allows you to combine two routers together of different
    types. In the example, we have two routers: `taskAPI`, which returns a simple
    string, and `taskCreateAPI`, which uses a `RequestReader` object (through the
    `body` function), to create the response. We can''t combine these with `|` since
    the result is created using two different approaches, so we use the `:+:` combinator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we just return simple strings whenever we get a request. In the next
    section, we'll look at how you can use a `RequestReader` instance to convert the
    incoming HTTP requests to case classes and use those to create an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Processing incoming requests using RequestReaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven't done anything yet with the incoming request. In the previous
    example, we just returned a string without using any information from the request.
    Finch provides a very nice model using a **Reader monad**, which you can use to
    easily combine information from an incoming request to instantiate new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Reader monad is a standard functional design pattern, which allows you to
    define functions that all access the same values. A great explanation of how Reader
    monads work can be found at [http://eed3si9n.com/learning-scalaz/Monad+transformers.html](http://eed3si9n.com/learning-scalaz/Monad+transformers.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code that uses a `RequestReader` to process incoming requests
    (the complete source code can be found in the `FinchStep2.scala` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we see a couple of new things. Instead of directly returning
    a string value, we use a case class that extends from `Service` to process the
    HTTP request and create a response. You can also run this service directly from
    SBT. Running the `sbt runCH02-runCH02Step2` command will start up the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this service once again using Postman. Let''s start by testing
    whether we can create a new task. To do this, open up Postman and fire off the
    request **Step 02 – Create Task**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Processing incoming requests using RequestReaders](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The response we get back starts to look similar to real data. The text we entered
    in `body` as well as the `title` request parameter is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the router we used to create a new task in detail to see how
    this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of this code fragment, you can see how we define the router that
    handles the create task request we just made through Postman. Whenever a `POST`
    request is made to the `tasks` URL, this router matches and maps the request to
    the function to the right of the `/>` combinator. This time, however, we don''t
    map to a function that returns a string, but we map to a case class that extends
    from `Service`. In our own class, we have to implement the `def apply(request:
    Req): Future[Rep]` function from the abstract `Service` class. In this specific
    example, we specified the type parameters for this service as `Request` and `String`,
    so the `apply` function should transform the incoming `Request` instance to a
    `Future[String]` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the first type parameter, you normally specify `Request` (unless you apply
    filters before processing the request, as we'll explain in the last part of this
    chapter), and the second type parameter should be a type, which Finch can automatically
    convert to an HTTP response. To automatically convert, Finch looks for an implicit
    `EncodeResponse[A]` type-class in scope. Out of the box, Finch will transform
    strings to HTTP responses. It also supports a number of JSON libraries, where
    case classes are automatically converted to HTTP responses with JSON bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the service for this route, we take a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we call the `getRequestToTaskReader` function defined in the base class,
    with the ID of the task we want to create. Since we're creating a new one, we
    just specify `-1` as the ID and let the backend generate a real ID. The result
    from this call is a `RequestReader[Task]` instance, which can convert a request
    into a `Task` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then directly call the `apply` function on the returned `RequestReader[Task]`
    instance with the passed in request. This call returns a `Future[Task]` object,
    which we process further in the `for` comprehension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the future from step 2 resolves, we have access to a task. We store this
    task using the `TaskService.insert` method. This call also returns a `Future`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we yield the stored `Task` object, as a `Future[Task]` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step in the service is converting the `Future[Task]` object to a `Future[String]`
    object, which we just do by using a simple `map` function. The reason we need
    to do this is because Finch doesn't know how to automatically convert `Task` objects
    to an HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, let''s look a bit closer at the `RequestReader[Task]`
    instance we used to convert a `Request` object to a Task object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we combine various RequestReader (`body`, `param`, and `RequestReader.value`)
    using the `::` combinator (we''ll explain more about `body`, `param`, and `RequestReader.value`
    in the next section). When we pass in a `Request` to the result of this function,
    each `RequestReader` is executed against the request. The result of all these
    individual steps is combined using the `as[A]` function (you can also use `asTuple`
    to collect the results). Finch standard supports conversion to int, long, float,
    double, and boolean, and also allows you to convert to a case class. In this last
    case, you have to make sure the result from the individual `RequestReader` matches
    the constructor of your case class. In this example, `Task` is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And this matches the results of the individual RequestReaders. Should you want
    to convert to a type that isn''t supported, you can very simply write your own,
    and just make sure it is in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example code so far, we''ve only used a couple of RequestReaders: `param`
    and `body`. Finch provides a number of other readers you can use to access information
    from the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reader | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `param(name)` | This returns the request parameter as a string and throws
    a `NotPresent` exception when the parameter can''t be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `paramOption(name)` | This returns the request parameter as an `Option[String]`
    object. This call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: '| `paramsNonEmpty(name)` | This returns a multivalue parameter as a `Seq[String]`
    object. If the parameter can''t be found, a `NotPresent` exception is thrown.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `params(name)` | This returns a multivalue parameter (for example, `?id=1,2,3&b=1&b=2`)
    as a `Seq[String]` object. If the parameter can''t be found, an empty list is
    returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `header(name)` | This returns a request header with the specified name as
    a string and throws a `NotPresent` exception when the header can''t be found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `headerOption(name)` | This returns a request header with the specified name
    as an `Option[String]` object. This call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: '| `cookie(name)` | This gets a `Cookie` object from the request. If the specified
    cookie isn''t present, a `NotPresent` exception is thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `cookieOption(name)` | This gets a `Cookie` object from the request. This
    call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: '| `body` | This returns the request body name as a string and throws a `NotPresent`
    exception when there is no body present. |'
  prefs: []
  type: TYPE_TB
- en: '| `bodyOption` | This returns the body as an `Option[String]` object. This
    call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: '| `binaryBody` | This returns the request body name as an `Array[Byte]` object
    and throws a `NotPresent` exception when there is no body present. |'
  prefs: []
  type: TYPE_TB
- en: '| `binaryBodyOption` | This returns the body as an `Option[Array[Byte]]` object.
    This call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: '| `fileUpload` | This `RequestReader` reads an upload (a multipart/form) parameter
    from the request and throws a `NotPresent` exception when the upload can''t be
    found. |'
  prefs: []
  type: TYPE_TB
- en: '| `fileUploadOption` | This `RequestReader` reads an upload (a multipart/form)
    parameter from the request. This call will always succeed. |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see from this table, a large number of RequestReaders types are
    already available, and in most cases, this should be enough to handle your requirements.
    If the `RequestReader` object does not provide the required functionality, a number
    of helper functions are available that you can use to create your own custom `RequestReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `value[A](value: A):``RequestReader[A]` | This function creates a `RequestReader`
    instance that always succeeds and returns the specified value. |'
  prefs: []
  type: TYPE_TB
- en: '| `exception[A](exc: Throwable):``RequestReader[A]` | This function creates
    a `RequestReader` instance that always fails with the specified exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `const[A](value: Future[A]):``RequestReader[A]` | This `RequestReader` will
    just return the specified value. |'
  prefs: []
  type: TYPE_TB
- en: '| `apply[A](f: HttpRequest => A):``RequestReader[A]` | This function returns
    a `RequestReader` instance that applies the provided function. |'
  prefs: []
  type: TYPE_TB
- en: There is one part of the `RequestReader` that we haven't discussed yet. What
    happens when a `RequestReader` fails? Finch has a very elegant mechanism to handle
    these validation errors. We'll come back to that in the last part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: JSON support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve just worked with plain strings as responses. In this section,
    we''ll expand the previous sample and add JSON support and show you how you can
    control which HTTP response code should be used when handling a request. Using
    JSON with Finch is very straightforward since Finch already supports a number
    of JSON libraries out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Argonaut ([http://argonaut.io/](http://argonaut.io/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jackson ([https://github.com/FasterXML/Jackson](https://github.com/FasterXML/Jackson))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Json4s ([http://json4s.org/](http://json4s.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argonaut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll look at how to use the Argonaut library to automatically
    convert our model (our case classes) to JSON. Should you want to use one of the
    other libraries, they work in pretty much the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by looking at the request and response message that our service
    should work with for this scenario. First, start up the server using the `sbt
    runCH02-runCH02Step3` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the server is started, open Postman and select the request **Step 03 –
    Create Task** from the **Chapter 02** collection. When you send this request,
    the server will parse this to a case class, store it, and return the stored task
    once again as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '![Argonaut](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you send the message a couple of times, you'll notice that the ID of the
    response increases. The reason is that we generate a new ID for newly created
    tasks, so ignore the ID from the incoming JSON message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created a number of new tasks, you can also get all the stored
    tasks by using the **Step 03 – Get Tasks** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Argonaut](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you''ve stored a number of messages, you can also use the API to delete
    tasks. Click on **Step 02 – Delete Task**, change the URL to the ID you want to
    delete (for example, `http://localhost:8080/tasks/3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Argonaut](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the task with the ID you want to delete exists, it will return **200 Ok**,
    if the ID doesn't exist, you'll see **404 Not Found**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this working, the first thing we need to do is get the required Argonaut
    dependencies. For this, we change the dependencies in our SBT build to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Jackson and Json4s
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Jackson and Json4s, you use the `finch-jackson` and `finch-json4s` modules
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To automatically convert our case classes to and from JSON, we need to tell
    Argonaut how we can convert to our case classes and vice versa. For our example,
    we''ve done this in the `chapter2` package object (located in the `package.scala`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For each of the case classes we want to support, we need a set of implicit values.
    To convert from JSON, we need a `DecodeJson[A]` instance and to convert to JSON,
    a `EncodeJson[A]` instance. Argonaut already provides some helper methods you
    can use to easily create these instances, which we've used in the previous example.
    For instance, with `jdecode2L` (the `2` stands for two arguments), we convert
    two JSON values to a case class, and with `jencode2L`, we convert two parameters
    of a case class to JSON. To learn more about Argonaut, you can look at its website
    at [http://argonaut.io/](http://argonaut.io/); the part that deals with automatic
    conversion (as explained here) can be found at [http://argonaut.io/doc/codec/](http://argonaut.io/doc/codec/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve defined the mapping between JSON and the case classes we''re
    using, we can look at how this changes our implementation. In the following code
    fragment, we see the code that handles the **Create Task**, **Delete Task**, and
    **Get Tasks** requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll look at the `CreateNewTask` class. As you can see, the code has
    become much simpler since we don't have to explicitly define how an incoming request
    is transformed to a `Task` anymore. This time, all we need to do in the `apply`
    function of the `CreateNewTask` service is use the body, `RequestReader`, and
    use `as[Task]` to automatically convert the provided request to a `Task`. This
    works since we implicitly defined a `DecodeJson[Task]` instance. Once the `Task`
    is created from the `Request`, we pass it into the `TaskService` to store it.
    The `TaskService` returns a `Future[Task]`, with the `Task` that is stored (this
    will have the correct ID filled in). Finally, we return `Ok` with the stored `Task`
    as a parameter. Finch will convert this `Ok` object to an `HttpResponse` with
    code 200, and it will convert the provided `Task` to JSON using the implicit `EncodeJson[Task]`
    instance. We'll look a bit closer at how to build and customize the HTTP response
    in the following section. The `GetAllTasks()` class works in pretty much the same
    manner. It retrieves a `Future[Seq[Task]]` object from the `TaskService` instance
    and Finch, together with the implicitly defined objects, and knows how to convert
    this sequence of tasks to the correct JSON message.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section, let's quickly look at the `DeleteTask`
    class. As you can see in the code, this case class takes an additional parameter.
    This parameter will contain the long value, which was extracted by the `long`
    extractor in the router that mapped to this `Service`. If you have multiple extractors
    in the router, your case class should have the same amount of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Request validation and custom responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we haven''t looked at what happens when one of our RequestReaders can''t
    read the required information. A header might be missing, a parameter might be
    in the incorrect format, or a cookie isn''t present. If, for instance, you rename
    some fields in the JSON for the **Step 03 – Create Task** request, and make the
    request, it will fail silently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finch, however, provides an elegant way to handle all the exceptions from the
    RequestReaders. First, we''ll look at the result we''ll be aiming for. First,
    start another `sbt` project like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Open Postman and use **Step 03 – Create Task** to create some tasks in our database.
    For this example, we've added a search functionality that you can access through
    the **Step 04 – Search Tasks** request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To show how validation works, we''ve added a couple of rules to the request
    parameters. The `status` request parameter is required, and when the `text` parameter
    is used, its value should be at least five characters. To test how this works,
    either remove the `status` parameter or change the value of the `text` parameter
    to something smaller than five characters. The following screenshot shows the
    resulting error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code fragment shows the case class we use to search the database
    and show changes we have to make to our application to get these validation results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When a request is passed into this `Service`, the `apply` function is invoked.
    In this function, we pass the request to a `RequestReader[SearchParams]` object
    that looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When this `RequestReader` is called with a request, it will first try and get
    the `status` parameter. If this parameter can't be found, a `NotPresent` exception
    will be thrown. This, however, doesn't stop the processing of the request, and
    the `RequestReader` gets the value of the `text` parameter. If the `text` parameter
    is available, it should be longer than five characters (note that we also have
    a `shouldNot` function for when you want to check whether a rule doesn't apply).
    If it isn't, a `NotValid` exception will be thrown. In the previous examples,
    if this happened, the processing of the request would have stopped, and the service
    would not have returned any response. To process these exceptions, we need to
    call the `handle` function on the `Future[HttpResponse]` instance (or the `Future`
    returned from the `RequestReader()` function).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start working with Finch yourself, you might notice that it doesn't
    use the standard `scala.concurrent.Future` class from Scala, but uses `the Future`
    defined in `com.twitter.util.Future`. The reasons are that Finch (and Finagle,
    which is used internally by Finch) is a Twitter project, and that the Future from
    Twitter has a lot of additional functionality. For instance, the `handle` function,
    which is discussed in the next section, is a standard function on the Twitter
    `Future` object. The `TaskService` that we use in this book, however, uses standard
    Scala `Future` objects. To make sure we can easily interoperate between the Scala
    `Future` and Twitter `Future` objects, we've created some implicit conversions.
    If you're interested in how they look, you can find these implicit conversions
    in the `src/main/scala/org/restwithscala/chapter2/package.scala` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `handle` function takes a `partial` function, and in this scenario, it should
    return an `HttpResponse` instance. As you can see in the code, we just convert
    the validation related exceptions as a JSON object and wrap it in a `BadRequest`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we showed we used the `beLongerThan` rule. Finch provides a
    number of standard rules out of the box that you can use to check whether the
    result from a specific `RequestReader` is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `beLessThan(n: Int)` | This checks whether a numeric value is less than the
    specified integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `beGreaterThan(n: Int` | This checks whether a numeric value is greater than
    the specified integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `beShorterThan(n: Int)` | This checks whether the length of a string is shorter
    than the specified integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `beLongerThan(n: Int)` | This checks whether the length of a string is longer
    than the specified integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | This combines two rules together. Both rules must be valid. |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | This combine two rules together. One of the rules must be valid. |'
  prefs: []
  type: TYPE_TB
- en: 'Creating a custom validation rule is very simple. For instance, the following
    code creates a new rule that checks whether a string contains any uppercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we now run a query, we also get a message if we use uppercase characters
    in our `text` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request validation and custom responses](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last part that we''ll look at a bit closely before we move on to the next
    chapter is how to create HTTP responses. We''ve already seen a little bit of this
    with the `Ok`, `BadRequest`, and `NotFound` case classes. Finch also provides
    a number of additional functions to further customize the HTTP response message.
    You can use the following functions to create the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `withHeaders(headers: (String, String)*)` | This adds the provided headers
    to the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `withCookies(cookies: Cookie*)` | This adds the provided cookies to the response.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `withContentType(contentType: Option[String])` | This sets the content-type
    of the response to the specified `Option[String]` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `withCharset(charset: Option[String])` | This sets the character-set of the
    response to the provided `Option[String]` object. |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if we wanted to create an `Ok` response with a custom character
    set, a custom content-type, some custom headers, and a string body, we''d do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the Finch framework. With the Finch framework,
    you can create REST services using a functional approach. Handling requests is
    done by mapping a request to a `Service`; validating and parsing requests is done
    using a Reader monad, the `RequestReader`; and all the parts are composable to
    create complex routes, RequestReaders, rules, and services from simple parts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive into a Scala REST framework that uses a different
    approach. We'll look at Unfiltered, which uses a pattern matching-based approach
    of defining REST services.
  prefs: []
  type: TYPE_NORMAL
