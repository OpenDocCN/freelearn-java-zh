<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Anatomy of ImageJ Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Anatomy of ImageJ Plugins</h1></div></div></div><p>In this chapter, we will <a id="id418" class="indexterm"/>examine how a plugin is organized in ImageJ and how it is implemented in the main interface. We will examine both the legacy plugins (ImageJ1.x) and the new format based on SciJava's model (ImageJ2). The following topics will be discussed in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basic anatomy of a plugin in ImageJ1.x and ImageJ2</li><li class="listitem" style="list-style-type: disc">Types of plugins</li><li class="listitem" style="list-style-type: disc">Implementing a plugin</li><li class="listitem" style="list-style-type: disc">Combining macros and plugins</li><li class="listitem" style="list-style-type: disc">Running and debugging plugins</li><li class="listitem" style="list-style-type: disc">Examples of available plugins</li></ul></div><div class="section" title="The basic anatomy of a plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec41"/>The basic anatomy of a plugin</h1></div></div></div><p>A plugin within <a id="id419" class="indexterm"/>ImageJ has to adhere to specific rules. The syntax conforms to the Java language, but some of the elements are unique to ImageJ. In the following sections, I will discuss the conventions and constructs used by ImageJ1.x plugins (referred to as <span class="strong"><strong>legacy</strong></span> from here on) and the new SciJav-based conventions and constructs (referred to as <span class="strong"><strong>scijava</strong></span> from here on). Note that when using the scijava model, you are required to use Java 1.7.x or higher when running and compiling your plugins. Also, the scijava model was designed with the Maven and Git systems in mind. This means that it is advantageous to use those systems when developing plugins for the future releases of ImageJ. The following sections will look at the basic anatomy of a plugin in both formats.</p><div class="section" title="Legacy plugins"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Legacy plugins</h2></div></div></div><p>A plugin within ImageJ1.x <a id="id420" class="indexterm"/>has to adhere to specific rules. The syntax conforms to the <a id="id421" class="indexterm"/>Java language, but some of the elements are unique to ImageJ. The legacy plugin consists of three main types of plugins: the basic <code class="literal">PlugIn</code>, <code class="literal">PlugInFilter</code>, and <code class="literal">PlugInFrame</code>. A short description and use case for each of these types will follow in the <a id="id422" class="indexterm"/>upcoming <a id="id423" class="indexterm"/>sections.</p><div class="section" title="The PlugIn type"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec38"/>The PlugIn type</h3></div></div></div><p>The <code class="literal">PlugIn</code> type is <a id="id424" class="indexterm"/>used for basic plugins that do not require an image to be open by design. The <code class="literal">PlugIn</code> type is a Java interface, and it only has one method that needs to be overridden, which is the <code class="literal">run()</code> method. The <code class="literal">run()</code> method of the <code class="literal">PlugIn</code> <a id="id425" class="indexterm"/>type is the entry point for this type, and after that, it can be structured in any shape or form using Java syntax. This plugin is very basic, but can perform any task you can design. It can also deal with images. However, selecting an image or opening an image for processing needs to be handled explicitly by the programmer. Also, checking the image type before processing needs to be verified by the programmer explicitly.</p></div><div class="section" title="The PlugInFilter type"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec39"/>The PlugInFilter type</h3></div></div></div><p>This type of plugin <a id="id426" class="indexterm"/>requires an image to be open when the plugin is being executed, and the image also is an input parameter for the plugin. It has two methods that are required to be overridden by the programmer: the <code class="literal">setup()</code> method and the <code class="literal">run()</code> method. The setup method does a basic check on the image and allows for the <a id="id427" class="indexterm"/>plugin to verify that the current image meets the requirements that are necessary for the processing. It returns an integer value that indicates which types of images can be handled by the plugin. When you wish to specify an image type, you can use the fields defined for the <code class="literal">PlugInFilter</code> interface:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_ALL</code>: These are any type of image can be processed</li><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_8G</code>: These are the 8-bit gray scale images</li><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_16</code>: These are the 16-bit gray scale images</li><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_32</code>: These are the 32-bit float images</li><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_RGB</code>: These are the RGB images</li><li class="listitem" style="list-style-type: disc"><code class="literal">DOES_STACKS</code>: These are all types of stacks (channels, slices or frames)</li></ul></div><p>When using the <code class="literal">DOES_STACKS</code> field, be aware that any multidimensional image will be considered a stack, and processing will run over all the channels, slices, and/or frames that are present in the image. When using this field, you have to perform checks to make sure that your plugin will process the correct dimension. If the image does not fit the type specified by the field(s), the plugin will abort and give a warning that the image type is not supported by the plugin. If you wish to support different types, you can return the sum of the supported types. The <code class="literal">run()</code> method is the main entry point of this type, although you could also perform some preprocessing in the setup method.</p></div><div class="section" title="The PlugInFrame type"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec40"/>The PlugInFrame type</h3></div></div></div><p>This type of plugin <a id="id428" class="indexterm"/>is designed to create an interface for your plugin to show the user. There is no method to be overridden, and the only required element is the constructor for the class. The constructor is the entry point of the plugin. The <code class="literal">PlugInFrame</code> type extends the <span class="strong"><strong>Abstract Window Toolkit</strong></span> (<span class="strong"><strong>AWT</strong></span>) model for the user interface, which can be filled with controls or tabbed panels to allow for a clear user experience. This type does not assume that any images are open, and the developer needs to <a id="id429" class="indexterm"/>implement all the logic for the user interface.</p></div><div class="section" title="Implementing a legacy plugin"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec41"/>Implementing a legacy plugin</h3></div></div></div><p>Once you have <a id="id430" class="indexterm"/>decided on a plugin type, all you need to do is implement your plugin. This sounds simple, and it can be as well. There are a few things you need to consider before you start. ImageJ requires a plugin to have an underscore in the name in order for it to show up in the <span class="strong"><strong>Plugins</strong></span> menu if you use a single class file. This requirement is lifted when you develop the plugin as a <span class="strong"><strong>Java archive</strong></span> (<span class="strong"><strong>JAR</strong></span>) file. When creating your plugin, you need to adhere to the Java syntax. This means that you need to declare and initialize your variables. When creating functions, you need to specify the return type, if any, and the access type (public/private/protected). The regular coding advice applies to ImageJ plugins as well. Adding comments can be helpful. It is also possible to create documentation for your functions using the Javadoc system that was set up in <a class="link" href="ch07.html" title="Chapter 7. Explanation of ImageJ Constructs">Chapter 7</a>, <span class="emphasis"><em>Explanation of ImageJ Constructs</em></span>. This allows for a comprehensive documentation of your code, as well as being useful as an extended memory when you need to modify something later on.</p><p>When selecting a plugin type, you need to consider certain points. When using <code class="literal">PlugInFilter</code>, the active image will be used when the plugin is called, causing the image to be locked by ImageJ. When a command is issued on the image from outside of your plugin, the image is not accessible as it is locked by the plugin. This causes the <code class="literal">Image locked</code> error. If you wish to process images using macros from within a plugin, it is better to use the basic <code class="literal">PlugIn</code> (or <code class="literal">PlugInFrame</code>) type instead of the <code class="literal">PlugInFilter</code> type. In the next section, we will look at the constructs for scijava plugins.</p></div><div class="section" title="Combining macros and legacy plugins"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec42"/>Combining macros and legacy plugins</h3></div></div></div><p>It is possible to <a id="id431" class="indexterm"/>combine macros and plugins as well. The run command can be used from within a plugin to execute a specific macro or ImageJ command. The only difference is that you need to precede it with the root class <code class="literal">IJ</code>:</p><div class="informalexample"><pre class="programlisting">IJ.run("Green"); //ImageJ command
String status = IJ.runMacro("/PATH/TO/Macro"); //macro</pre></div><p>The first line will change the lookup table to green for the currently active image and channel. The second line will run a macro specified by a path. The <code class="literal">runMacro</code> method returns a string that contains the return value of the macro or <code class="literal">NULL</code> if the macro does not return a value. It returns <code class="literal">[Aborted]</code> when the macro was aborted or when it encountered an error. The <code class="literal">IJ</code> class contains a few useful methods that allow us to run macros and plugins as well as open images using an open dialog. Another useful method is the <code class="literal">IJ.log()</code> method, which accepts a string that will be displayed in the log window. This can be used to provide <a id="id432" class="indexterm"/>feedback for the user as well as aid in debugging a plugin, as will be shown in a later section. In <a class="link" href="ch09.html" title="Chapter 9. Creating ImageJ Plugins for Analysis">Chapter 9</a>, <span class="emphasis"><em>Creating ImageJ Plugins for Analysis</em></span> we will look at a basic implementation where we combine ImageJ commands within <code class="literal">PlugInFilter</code>.</p></div></div><div class="section" title="SciJava plugins"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>SciJava plugins</h2></div></div></div><p>Since ImageJ was <a id="id433" class="indexterm"/>developed, many plugins were built using the legacy system described earlier. However, certain shortcomings in the design of the legacy format necessitated a redesign of the ImageJ core. This new framework is the SciJava framework, which consists of scijava-common at its core (among other components). The following sections will describe how plugins are implemented in this new framework. It should be noted that the way plugins are developed in the SciJava framework does not split a plugin in the same types as the legacy system. There is no concept of a plugin that requires an image or that creates a user interface. In the framework, all plugins have the same construction, and they define the components that are required.</p><div class="section" title="The @Plugin annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec43"/>The @Plugin annotation</h3></div></div></div><p>In the SciJava <a id="id434" class="indexterm"/>framework, a plugin is a class that is annotated with the <code class="literal">@Plugin</code> annotation. Classes with this annotation are automatically recognized by ImageJ and indexed for use when the plugin is launched by the user. Under this framework, you will typically create one of two types of plugins: a service or a command. A service-type plugin will consist of utility methods for internal use in ImageJ. Services provide methods that can be used throughout the framework. Command-type plugins, on the other hand, are meant as plugins that execute a specific function with a specific goal. These are the types of plugins that the user will encounter when using the ImageJ interface: a menu item in ImageJ is a form of a command-type plugin. Command-type plugins can use Service methods to allow for common tasks such as opening images.</p><p>Whether you create a command or service-style plugin, either will run in what is called <code class="literal">Context</code>. <code class="literal">Context</code> in the SciJava framework describes the services and commands that the plugin will use. It functions as a type of sandbox. It is not possible to directly use the methods of services and commands within another plugin's context. If this is required, you have to inject your outside plugin into the context of the plugin of which you wish to use its methods. Alternatively, you can request a service from within a context using a special annotation to request an instance of a type in your plugin using the <code class="literal">@Parameter</code> annotation. For instance, if you wish to use <code class="literal">logService</code> in your plugin to allow for logging events, you could use the following annotation:</p><div class="informalexample"><pre class="programlisting">@Parameter
private logService logService;</pre></div><p>When the plugin is <a id="id435" class="indexterm"/>run, the context will automatically generate an instance of <code class="literal">logService</code> and give you access to its methods:</p><div class="informalexample"><pre class="programlisting">public void log(String msg) {
  logService.info(msg);
}</pre></div><p>In the upcoming sections, we will look at the two basic types of the <code class="literal">@Plugin</code> annotation in more detail.</p></div><div class="section" title="Services"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec44"/>Services</h3></div></div></div><p>The SciJava framework <a id="id436" class="indexterm"/>contains a large number of generic services that can be used to perform basic tasks and deal with datasets. Some of the more important ones include the following services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AppService</code>: This deals with applications (that is, ImageJ)</li><li class="listitem" style="list-style-type: disc"><code class="literal">EventService</code>: This deals with events such as mouse clicks</li><li class="listitem" style="list-style-type: disc"><code class="literal">PluginService</code>: This deals with the available plugins and their execution</li><li class="listitem" style="list-style-type: disc"><code class="literal">DatasetService</code>: This deals with tools to handle image data</li><li class="listitem" style="list-style-type: disc"><code class="literal">OverlayService</code>: This deals with tools for overlays and ROIs</li></ul></div><p>To create your own service, you will need to create a context for it and define its methods. If you wish to use the generic services available in the SciJava framework, you can add them as parameters to your own service. This allows for very extensible code that can be reused over and over consistently. In most cases, you will obtain a reference to these services using the <code class="literal">@Parameter</code> annotation in your plugins, giving you access to its methods and functionality.</p></div><div class="section" title="Commands"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec45"/>Commands</h3></div></div></div><p>When creating plugins <a id="id437" class="indexterm"/>yourself, the command type will be the most commonly used type. Commands describe plugins that face the user and describe an action that the user can perform by launching the command. When creating a plugin, you can specify the type as a <code class="literal">Command</code> class, and you can specify where the command will be placed in the menu structure:</p><div class="informalexample"><pre class="programlisting">@Plugin(type=Command.class, menuPath="Plugins&gt;My Menu&gt;My Plugin")
public class My_Plugin implements Command {
  //code for the plugin

}</pre></div><p>The type specifies that this plugin is concerned with a command interface, which it implements as stated in the class definition. The <code class="literal">menuPath</code> parameter allows you to set the menu position where the plugin will be placed when it is discovered. This allows for fine control and grouping <a id="id438" class="indexterm"/>of your plugins. In this case, in a predefined submenu (<span class="strong"><strong>My Menu</strong></span>) within the plugins menu of ImageJ.</p></div></div></div></div>
<div class="section" title="Running and debugging plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Running and debugging plugins</h1></div></div></div><p>Once you have <a id="id439" class="indexterm"/>created your code, you are ready to compile it. Java is not an interpreted language and requires that the source code is compiled into byte code that can be <a id="id440" class="indexterm"/>processed by the <span class="strong"><strong>Java Virtual Machine</strong></span> (<span class="strong"><strong>JVM</strong></span>). Depending on how you're developing the code, there are different ways to proceed. You can <a id="id441" class="indexterm"/>use ImageJ directly, use the Fiji Code Editor, or use the NetBeans IDE. How you proceed also depends on whether you are developing a legacy plugin or a scijava plugin. The following sections will look at the legacy plugins first.</p><div class="section" title="Compiling plugins"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Compiling plugins</h2></div></div></div><p>Compiling and running plugins differs a little between vanilla ImageJ and Fiji due to the fact that Fiji is based on <a id="id442" class="indexterm"/>the SciJava framework. Also, when using an IDE, there will be different steps involved in compiling and running your plugin.</p><p>When you have finished writing the source code for your plugin using vanilla ImageJ, you can run the plugin by first compiling it and then running it. To do so, go to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Compile and Run…</strong></span> and select your plugin. If your code was correctly written, it would compile and then run. If there were any errors during compilation, an error dialog would pop up indicating which line(s) contained error(s). Most of the time, error messages can be very cryptic and may not always point directly to the point where the code failed.</p><p>If you are using Fiji, you can compile and run your plugin using the <span class="strong"><strong>Run</strong></span> button at the bottom of the script editor window. The <span class="strong"><strong>Compile and Run…</strong></span> method is not available in Fiji! Any error messages will be displayed in the field below to indicate where and why the compilation or running failed.</p><p>If you are using an IDE for your development, you can use the compile function of the IDE. In NetBeans, you can compile your file by going to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Compile File</strong></span> or by pressing <span class="emphasis"><em>F9</em></span>. If there were no errors during compilation, you can run your plugin using <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Project</strong></span> from the menu or by pressing <span class="emphasis"><em>F6</em></span>. If no errors were found, a new instance of ImageJ will be started, and under the <span class="strong"><strong>Plugin</strong></span> menu, your developed plugin should show up. Errors in syntax will prevent the compilation, and the IDE will highlight these errors using a red symbol with a white exclamation mark (as well as a red wavy line):</p><div class="mediaobject"><img src="graphics/Insert_image_4909_08_01.jpg" alt="Compiling plugins"/></div><p>When hovering the pointer above the red symbol in the margin, a suggestion is given about the error. In this case, the message tells us that <code class="literal">;</code> was expected at the end of the statement. The symbol above it does not signify an error, but a warning. Warnings will not halt compilation or <a id="id443" class="indexterm"/>prevent the running of a plugin. However, they can cause problems during runtime. In this example, the warning tells us that the use of the keyword <code class="literal">this</code> used in the constructor is not advised and might cause problems. For plugins based on the SciJava framework, the procedures and results are the same. However, there are a few important things to consider. The next section will briefly explain some of the main points.</p><div class="section" title="Compiling SciJava plugins"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec46"/>Compiling SciJava plugins</h3></div></div></div><p>To compile <a id="id444" class="indexterm"/>plugins that implement the SciJava framework, you need to make sure that you have all the dependencies as well as that the ImageJ <a id="id445" class="indexterm"/>framework you will run the plugins on supports the framework. For Fiji, this is not a problem. It runs on the framework by default already. You can also use the vanilla ImageJ, but you must make sure it is the ImageJ2 variant and not the <span class="strong"><strong>ImageJ1.x</strong></span> variant.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>You can check which variant you're using by clicking on the status line of the main interface. If it reads something like <span class="emphasis"><em>ImageJ 2.0.0-[…]</em></span>, it indicates you are using ImageJ2. If it reads something similar to <span class="strong"><strong>ImageJ 1.50a</strong></span>, then you are running the <span class="strong"><strong>ImageJ1.x</strong></span> variant.</p></div></div><p>Due to the modular nature of the framework, it is strongly recommended that you use the Maven tools to create and compile your plugins. This will take care of all the dependencies required to build your plugin. To make this more streamlined and efficient, it is a best practice to use an IDE that supports Maven, although you can also use the <span class="strong"><strong>Command-line Interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) if you wish. To refresh your memory, refer to the previous chapter, which explains you how to set up your IDE <a id="id446" class="indexterm"/>with a Maven-based plugin.</p><p>To compile your plugin using NetBeans using a Maven-based project, you just need to select your project and go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Build Project</strong></span> or press <span class="emphasis"><em>F11</em></span>. To launch your plugin, go to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Project </strong></span>from the menu or press <span class="emphasis"><em>F6</em></span>. Problems that were encountered during compilation will be <a id="id447" class="indexterm"/>displayed in a similar way as described for <a id="id448" class="indexterm"/>the legacy plugins.</p></div></div><div class="section" title="Debugging plugins"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Debugging plugins</h2></div></div></div><p>As ImageJ is a tool to <a id="id449" class="indexterm"/>run the code, it does not have many utilities to debug code. This does not mean, however, that it is not possible to do some debugging. For legacy plugins, you can use the <code class="literal">IJ.log</code> method. It is possible to log statements to a log window or to look at the value of variables. For plugins built on the SciJava framework, you can use <code class="literal">logService</code> and use the <code class="literal">info()</code> and <code class="literal">warn()</code> methods after declaring <code class="literal">@Parameter</code> to create an instance to the required service. An example use of this method of debugging plugins can be as follows:</p><div class="informalexample"><pre class="programlisting">int someVar = 1;
int newVar = doSomething(someVar);

//legacy method
IJ.log("Old value: "+someVar+"; New value: "+newVar);

//SciJava method
logService.info("Old value: "+someVar+"; New value: "+newVar);</pre></div><p>When using this type of method, it can be useful to include a simple control statement such as the <code class="literal">if</code> statement. This allows you to easily disable or control the amount of logging that is done in your final incarnation of the plugin. Using a global variable that sets a debugging level, you can control to show a certain log message or not:</p><div class="informalexample"><pre class="programlisting">private static int dbglvl = 3;
...

//implement the logging based on the dbglvl value
if (dbglvl&gt; 2) {
  IJ.log("The current value is "+currValue);
}
...
//implement the logging based on the dbglvl value
if (dbglvl&gt; 4) {
  IJ.log("This statement was evaluated...");
}</pre></div><p>In this case, the global variable <code class="literal">dbglvl</code> will dictate which messages will be shown. The first <code class="literal">if</code> statement will be executed with the current debug level (set to <code class="literal">3</code>), while the second statement will not be displayed with the current level. In the final version of your plugin, you can change the value of <code class="literal">dbglvl</code> to <code class="literal">1</code> or <code class="literal">0</code> to disable all low-level debugging statements. Note that this assumes that a high value for <code class="literal">dbglvl</code> is associated with minor logging statements, and a low value will only show the most minimal statements. Finally, you might want to remove all the if statements when the code is working correctly. The evaluation of each statement does require a finite amount of time, so it will slow down your code in the end.</p><p>When using the NetBeans IDE to develop plugins, there are more options to debug and profile your code. The advantage of using an IDE such as NetBeans is you can set breakpoints where you wish <a id="id450" class="indexterm"/>to halt the execution of the plugin and look at the contents of the variables. To do so, click on the margin before the line where you wish to stop. A red square will be displayed, indicating a breakpoint:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_08_02.jpg" alt="Debugging plugins"/></div><p>The entire line is also colored red to indicate the line where the debugger will wait when you run it. Keep in mind that if you place a breakpoint in a statement that will never be executed, the debugger will never stop, and your code will run uninterrupted.</p><p>To run the code using the debugger, you can go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Debug Project (…)</strong></span> or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>F5</em></span> on the keyboard. When the debugger hits a breakpoint, the line will become green, and you can continue using the different step functions. In the variables tab at the bottom of the IDE, you will see all the variables that are available at the current breakpoint. Note that you can also evaluate expressions and change the values that are currently assigned to variables. Doing this may cause problems or may lead to infinite loops or crashes, so be careful when changing values!</p><p>There is also a profiler to help with identifying sections of code that are not efficient in terms of processing speed or memory usage. However, many of these advanced features are not always necessary when developing simple plugins. Once you start Profiler by selecting <span class="strong"><strong>Profile</strong></span> | <span class="strong"><strong>Profile Project (…)</strong></span>, you can select whether you wish to monitor the CPU processing, <span class="strong"><strong>garbage collection</strong></span> (<span class="strong"><strong>GC</strong></span>) and/or memory usage. You can use the telemetry to see whether there are problems with excessive CPU cycles as well as problems with garbage collection and memory management. The use of Profiler extends a little too far beyond the scope of this book. However, there are excellent resources available online on how to use and interpret the results from profiling.</p><p>As profiling an application is very close to an art form, use it carefully and only when you really notice very slow performance or memory problems in your application. Choosing how much development overhead you wish to dedicate for your plugin should always be weighed against the amount of time it gains. Spending hours of optimizing your code or algorithm so that it executes 1 second faster may not be worth it if it is called only once and is a part of a larger chain of commands. However, if you optimize code that is called hundreds of time within a loop, the optimization might be worth the extra development time many times over.</p><p>In the upcoming section, we <a id="id451" class="indexterm"/>will look at some plugins that are available and are used for scientific research.</p></div></div>
<div class="section" title="Examples of available plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Examples of available plugins</h1></div></div></div><p>In this section, I will <a id="id452" class="indexterm"/>discuss a few plugins that are available for ImageJ, most of which have also been published in scientific journals. They will show you how to use ImageJ for advanced image processing, with different degrees of automation and user interaction. They also provide a few examples of the design of a plugin, either with its own interface or just as a single command that executes. Some of these examples also have their source code available so that you can see how the developers implemented their algorithms. Be aware that having the source code and being able to understand it fully might be difficult: depending on the level of documentation or comments in the code. It might be very difficult to completely retrace the functioning of the code. As a program grows and new functions and algorithms are added, it deviates more from a single core algorithm to a more convoluted group of files. Developers using the Javadoc capabilities available in IDEs can create detailed documentation relatively easy, making the understanding of code slightly easier.</p><p>One point that is very important when trying to analyze source code is to realize which file or function is the entry point of the program. You can be sure that when the code executes, it will always go into this main entry point, and every user interaction or function will be set up in the main entry point. The entry points for the different types of plugins were indicated in the previous sections. Also, plugins developed using the SciJava framework generally have a <code class="literal">main()</code> method, which is not necessarily the entry point for the plugin. This depends on the way that the plugin was launched. When launched through the IDE using Maven, the <code class="literal">main()</code> method is used to instantiate ImageJ and launch the plugin. However, when launching the plugin from the ImageJ instance using the menu for example, the <code class="literal">main()</code> method will not be invoked.</p><p>When using an interface for your plugin, a lot of the action comes from the user pressing a button, adding a number to a field or selecting an option. The <code class="literal">main</code> interface just waits for the user to do something. In Java, this means that the <code class="literal">ActionPerformed() </code>method becomes the entry point for many algorithms or processing. When a user clicks a button, this will fire an action event that can be used by the programmer to catch it and connect it to further statements. First, we will look at some examples of plugins that are available on the ImageJ website (<a class="ulink" href="http://imagej.nih.gov/ij/plugins/index.html">http://imagej.nih.gov/ij/plugins/index.html</a>) to show how to develop ImageJ solutions to image processing problems.</p><div class="section" title="Example plugins available in ImageJ and Fiji"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Example plugins available in ImageJ and Fiji</h2></div></div></div><p>ImageJ has a <a id="id453" class="indexterm"/>large collection of plugins available that extend the core functionality. With the arrival of ImageJ2, the model for distribution of plugins is changing as well. In the older ImageJ1.x framework, you were required to download a source file of a plugin <a id="id454" class="indexterm"/>or a compiled .class file and place it in the plugins folder. When the plugin was updated, you would need to repeat the whole process again. With ImageJ2, an updating mechanism has been provided that uses a repository system. In this system, communication between ImageJ and the repository will determine whether there are updates available. When there are updates, the user can automatically install the updates without having to search for the plugin.</p><p>For most of the plugins that are available, the source code can be viewed or studied to look at the way other people have solved a particular image-processing problem. For the following example plugins, I will describe the specific problem or challenge they are designed to tackle. I will then show a bit of code to explain how the plugin tries to solve the problem. Feel free to view or download the source code where available to look at the complete implementation.</p><div class="section" title="MultipleKymograph"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec47"/>MultipleKymograph</h3></div></div></div><p>An example of <a id="id455" class="indexterm"/>such a plugin is the <span class="strong"><strong>MultipleKymograph</strong></span> plugin (<code class="literal">MultipleKymograph_.java</code>), which creates a kymograph along a (segmented) line selection. It was designed by Jens Rietdorf and Arne Seitz from the <span class="strong"><strong>European Molecular Biology Laboratory</strong></span> (<span class="strong"><strong>EMBL</strong></span>) in Heidelberg, Germany. It contains a small set of tools and macros that can be used to create and measure kymographs. We <a id="id456" class="indexterm"/>already saw kymographs back in <a class="link" href="ch05.html" title="Chapter 5. Basic Measurements with ImageJ">Chapter 5</a>, <span class="emphasis"><em>Basic Measurements with ImageJ,</em></span> where we saw how they visualized dynamics in time series. There, we used the <span class="strong"><strong>Reslice</strong></span> command to generate the kymograph, which worked OK, but there are a few small drawbacks of that method.</p><p>The first problem is that <span class="strong"><strong>Reslice</strong></span> only considers the pixels that are on the line that was selected. This makes it more sensitive to inaccurate placement of the line and pixel noise. The <span class="strong"><strong>MultipleKymograph</strong></span> plugin is a legacy plugin that tries to solve this problem by providing the user with an input field to ask for the line width to be used to create the averaged output pixels. When the user calls the plugin without a line selection or an open image, it generates an error message indicating that action needs to be taken by the user before calling the plugin. As the creation of the kymograph image itself hinges on the correct values for the pixels, I will focus on how the plugin calculates the average pixel intensity for the line that <a id="id457" class="indexterm"/>was placed by the user.</p><p>The main generation <a id="id458" class="indexterm"/>of the pixel values happens in the <code class="literal">sKymo(…)</code> method, which has the following definition:</p><div class="informalexample"><pre class="programlisting">public double[] sKymo(ImagePlus imp, ImageProcesso rip, Roi roi, int linewidth, int proflength){
  
  int numStacks=imp.getStackSize();
  int dimension = proflength*numStacks;
  double[] sum = new double [dimension];
  
  int roiType = roi.getType();
  int shift=0;
  int count=0;
  
  for (int i=1; i&lt;=numStacks; i++) {
    imp.setSlice(i);
    
    for (int ii=0;ii&lt;linewidth;ii++){
      shift=(-1*(linewidth-1)/2)+ii;
      
      if (roiType==Roi.LINE) {
        profile = getProfile(roi,ip,shift);
      }
      else {
        profile = getIrregularProfile(roi, ip,shift);
      }
      for (int j=0;j&lt;proflength;j++){
        count = (i-1)*proflength+j;
        sum[count]+=(profile[j]/linewidth);
      }
    }
  }
  return sum;
}</pre></div><p>The <code class="literal">sum</code> variable that is returned contains the result of the averaged profiles along the stack. The method requires five input parameters, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ImagePlus imp</code>: This is the source stack that we want to use for the calculations</li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageProcessor ip</code>: This is the image processor to access the pixels of the stack</li><li class="listitem" style="list-style-type: disc"><code class="literal">Roi roi</code>: This is the ROI that marks the line we wish to make into a kymograph</li><li class="listitem" style="list-style-type: disc"><code class="literal">int linewidth</code>: This is the width of the line as specified by the user input</li><li class="listitem" style="list-style-type: disc"><code class="literal">int proflength</code>: This is the length of the line specified by the user</li></ul></div><p>The method starts by declaring the parameters that will be needed for processing. Specifically, the output variable <code class="literal">sum</code> is defined as a <code class="literal">double[]</code> vector with a length equal to length of the line multiplied with the number of slices (or frames). The method then iterates over the slices in the stack (the outer for loop) and retrieves the profile using a method called <code class="literal">getProfile()</code> or <code class="literal">getIrregularProfile()</code>. These methods extract the pixel values from the selection, where the shift parameter determines how far the line is shifted compared to the <a id="id459" class="indexterm"/>selection. The only difference between the two is that one is meant to be used for straight lines (<code class="literal">getProfile</code>), while the <a id="id460" class="indexterm"/>other is used for segmented lines (<code class="literal">getIrregularProfile</code>). For the sake of brevity, I will only show the code for the former method:</p><div class="informalexample"><pre class="programlisting">double[] getProfile(Roi roi,ImageProcessor ip, int shift){
  double[] values;
  
  int x1=((Line)roi).x1;
  int x2=((Line)roi).x2;
  int y1=((Line)roi).y1;
  int y2=((Line)roi).y2;
  
  ((Line)roi).x1=x1+shift;
  ((Line)roi).x2=x2+shift;
  ((Line)roi).y1=y1+shift;
  ((Line)roi).y2=y2+shift;
  
  values=((Line)roi).getPixels();
  ((Line)roi).x1=x1;
  ((Line)roi).x2=x2;
  ((Line)roi).y1=y1;
  ((Line)roi).y2=y2;
  
  return values;
}</pre></div><p>This method takes the ROI that the user specified and shifts it by the amount specified in the <code class="literal">shift</code> parameter. It then uses the <code class="literal">getPixels()</code> method from the <code class="literal">Roi</code> class to extract the gray values and returns them. As a line is defined by only two points, each with an <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinate, this method is fairly brief. The irregular case requires that the line is moved along all the <span class="emphasis"><em>N</em></span> <a id="id461" class="indexterm"/>coordinates required to define the segmented <a id="id462" class="indexterm"/>line. Otherwise, it functions in the same way.</p></div><div class="section" title="ColorTransformer2"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec48"/>ColorTransformer2</h3></div></div></div><p>This legacy plugin is <a id="id463" class="indexterm"/>useful when dealing with color images such as those acquired by digital color cameras or videos from cameras such as webcams. It was originally <a id="id464" class="indexterm"/>developed by Maria E. Barilla as <span class="strong"><strong>ColorTransformer</strong></span> and modified by Russel Cottrell, resulting in the <span class="strong"><strong>ColorTransformer2</strong></span> plugin. The source code can be found at <a class="ulink" href="http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java">http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java</a>.</p><p>A problem with color images, such as RGB images, is that the intensity is not well-defined in the RGB color space. Light blue might appear more intense than dark blue, but the intensity value for the blue channel might be higher for dark blue than for light blue. In order to segment RGB images effectively based on specific colors, it is better that you transform it to a color space that is more suited for this purpose. The HSB color space separates an image in three components: <span class="strong"><strong>Hue</strong></span>, <span class="strong"><strong>Saturation</strong></span>, and <span class="strong"><strong>Brightness</strong></span> (sometimes also labeled as <span class="strong"><strong>Value</strong></span> or <span class="strong"><strong>Intensity</strong></span>). The hue indicates the color ranging from red to orange, yellow, green, cyan, blue, and magenta. See <a class="link" href="ch02.html" title="Chapter 2. Basic Image Processing with ImageJ">Chapter 2</a>, <span class="emphasis"><em>Basic Image Processing with ImageJ</em></span> for details on the use of the HSB color space.</p><p>This plugin implements a <code class="literal">PlugInFilter</code>, meaning that it overrides the <code class="literal">setup()</code> and <code class="literal">run()</code> methods, which form the entry points for the plugin. The setup method checks whether an image is open and screens the type of image that this plugin can process. The run method shows a dialog, which allows the user to choose the color space to convert from and to. The method I want to describe here is the conversion from RGB to HSI, which is a common format to use in segmentation of RGB images where segmentation needs to be performed based on color.</p><p>The main method that performs the actual RGB-to-HSI conversion is the <code class="literal">getHSI()</code> method. This method looks as follows:</p><div class="informalexample"><pre class="programlisting">public void getHSI(){
  for(int q=0; q&lt;size; q++){
    float var_Min = Math.min(rf[q], gf[q]); //Min. value of RGB
    var_Min = Math.min(var_Min, bf[q]);
    float var_Max = Math.max(rf[q], gf[q]); //Max. value of RGB
    var_Max = Math.max(var_Max, bf[q]);
    float del_Max = var_Max - var_Min;      //Delta RGB value
    
    c3[q] =  (rf[q] + gf[q] + bf[q])/3f;
    
    if ( del_Max == 0f ){ //This is a gray, no chroma...
      c1[q] =  0f; //HSL results = 0 ? 1
      c2[q] =  0f;
    }
    else{//Chromatic data...
      c2[q] = 1 - (var_Min / c3[q]);
      
      float del_R = (((var_Max-rf[q])/6f)+(del_Max/2f))/del_Max;
      float del_G = (((var_Max-gf[q])/6f)+(del_Max/2f))/del_Max;
      float del_B = (((var_Max-bf[q])/6f)+(del_Max/2f))/del_Max;
      
      if(rf[q] == var_Max) c1[q] = del_B - del_G;
      else if(gf[q] == var_Max) c1[q] = (1f/3f)+del_R-del_B;
      else if(bf[q] == var_Max) c1[q] = (2f/3f)+del_G-del_R;
      
      if (c1[q] &lt; 0)  c1[q] += 1;
      if (c1[q] &gt; 1)  c1[q] -= 1;
    }
  }
}</pre></div><p>These conversions are based on the methodology described in <span class="emphasis"><em>Color Vision and Colorimetry, Theory and Applications</em></span>, <span class="emphasis"><em>D Malacara</em></span>. The transformation is based on transforming the original RGB values stored in the <code class="literal">rf</code>, <code class="literal">gf</code>, and <code class="literal">bf</code> arrays, respectively. The transformed values <a id="id465" class="indexterm"/>are stored in the <code class="literal">c1</code>, <code class="literal">c2</code>, <code class="literal">c3</code>, and optionally, <code class="literal">c4</code> arrays. For the transformation to HSI, the <code class="literal">c4</code> array is not used, as an HSI image only has three channels. For example, the CMYK color space requires all four channels. At the end of <a id="id466" class="indexterm"/>the run method, the values for the channels are placed in a new image, which will be the transformed image.</p></div><div class="section" title="MtrackJ"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec49"/>MtrackJ</h3></div></div></div><p>This plugin is useful when <a id="id467" class="indexterm"/>you wish to track objects over time and, optionally, in three dimensions. It was developed by Eric Meijering at the University of Lausanne in Switzerland. The source code can be found on GitHub at <a class="ulink" href="https://github.com/fiji/MTrackJ/">https://github.com/fiji/MTrackJ/</a>. It was published in <span class="emphasis"><em>Methods in Enzymology</em></span>, <span class="emphasis"><em>vol 504</em></span> in February 2012. The <a id="id468" class="indexterm"/>main interface of the plugin consists of groups of buttons that allow you to add, delete, or move tracks or points and perform measurements or change settings:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_08_04.jpg" alt="MtrackJ"/></div><p>The function of this plugin is to track objects or particles over time in order to establish their speed and direction. Although automated tracking algorithms do exist, some data is just too difficult or too dense for automated tracking algorithms to cope with. For these types of challenges, this plugin will provide a tool that can help establish useful parameters for objects. The <a id="id469" class="indexterm"/>goal of this plugin is similar to that of the <span class="strong"><strong>MultipleKymograph</strong></span> plugin described earlier: measuring the velocity of multiple objects. When the tracks are created and measured, the results are presented in a results window. These results <a id="id470" class="indexterm"/>can then be used for direct plotting and analysis outside of ImageJ or as input for more advanced analysis.</p><p>As this plugin is quite extensive and has many features, I will focus on one very tiny detail that makes this interface great to track objects with amazing accuracy. In the options for tracking, accessed through the <span class="strong"><strong>Tracking</strong></span> button, you can set a snapping function for the mouse cursor. This type of feature might be familiar to many people. Many different applications use it to make it easier to align objects nice and evenly. When you check the <span class="strong"><strong>Apply local cursor snapping during tracking</strong></span> checkbox, you can choose a snap feature. This snap feature will determine when you position your mouse cursor over an object where the tracking point will be added. Without snapping, it would be placed at the pixel that you clicked. However, when using <span class="strong"><strong>bright centroid</strong></span> as the snap feature, something interesting will happen (when using fluorescent images). When you add a tracking point by clicking, <span class="strong"><strong>MtrackJ</strong></span> determines the centroid of the snap range that you defined. The centroid is the weighted intensity point and is not necessarily a single pixel, but it can be a position such as (<span class="emphasis"><em>x = 12.4, y = 13.45</em></span>). For image data with good signal-to-noise ratio, you can achieve better tracking resolution than the optical system can provide (so-called subpixel resolution). The location of the snap coordinates are calculated in a method called <code class="literal">snapcoords()</code>. I will <a id="id471" class="indexterm"/>not reproduce the entire method as it is quite extensive, but I <a id="id472" class="indexterm"/>will show you how it achieves the bright centroid calculation:</p><div class="informalexample"><pre class="programlisting">double ox=0, oy=0;
switch (settings.snapfeature) {
  
<span class="strong"><strong>  //other cases skipped</strong></span>
  
  case MTJSettings.BRIGHT_CENTROID: {
    // Make all weights &gt; 0:
    if (minval&lt;= 0) {
      final double offset = -minval + 1;
      for (int y=0; y&lt;snaprect.height; ++y)
        for (int x=0; x&lt;snaprect.width; ++x)
          snaproi[y][x] += offset;
        minval += offset;
        maxval += offset;
      }
      // Calculate Otsu threshold:
      double otsu = minval;
      final double maxi = OTSU_BINS;
      final double range = maxval - minval;
      double maxvari = -Double.MAX_VALUE;
      for (int i=1; i&lt;OTSU_BINS; ++i) {
        double sum1=0, sum2=0, n1=0, n2=0;
        final double thres = minval + (i/maxi)*range;
        // Notice that we always have minval&lt;thres&lt;maxval,
        // so sum1, sum2, n1, n2 are &gt; 0 after the loop:
        for (int y=0; y&lt;snaprect.height; ++y)
        for (int x=0; x&lt;snaprect.width; ++x) {
          final double val = snaproi[y][x];
          if (val&lt;thres) { ++n1; sum1 += val; }
          else { ++n2; sum2 += val; }
        }
        final double mean1 = sum1/n1;
        final double mean2 = sum2/n2;
        final double vari = n1*n2*(mean1-mean2)*(mean1-mean2);
        if (vari &gt; maxvari) {
          maxvari = vari;
          otsu = thres;
        }
      }
      // Calculate centroid &gt;= threshold:
      double val=0, sum=0;
      for (int y=0; y&lt;snaprect.height; ++y)
      for (int x=0; x&lt;snaprect.width; ++x) {
        val = snaproi[y][x];
        if (val&gt;= otsu) {
          val -= otsu;
          ox += x*val;
          oy += y*val;
          sum += val;
        }
      }
      ox /= sum; // sum can never be 0
      oy /= sum;
      break;
    }
  }
  snapos.x = snaprect.x + ox;
  snapos.y = snaprect.y + oy;</pre></div><p>As the plugin supports multiple methods for snapping, there are multiple cases in this <code class="literal">switch</code> statement, which I omitted for the sake of brevity. The goal of the method is to assign values to the <code class="literal">snapos.x</code> and <code class="literal">snapos.y</code> variables. For the bright centroid method, a threshold is used based on the <span class="strong"><strong>Otsu</strong></span> method. In the first loop using the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> indices, we went over the pixels of the snapping rectangle and sum all the pixel intensities (<code class="literal">val</code>) that are above the threshold value (<code class="literal">thres</code>) in <code class="literal">sum2</code> and the intensities below the threshold in <code class="literal">sum1</code>. We used these to calculate the variation, and if it exceeds the maximum value in the rectangle, we adjust the value and the Otsu threshold value.</p><p>In the second loop over the pixels in the snapping rectangle, the centroid is determined by summing the products of <a id="id473" class="indexterm"/>each pixel's <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates multiplied by the intensity <a id="id474" class="indexterm"/>above the Otsu threshold. A running sum of the intensities above the threshold is also kept and used to divide the final coordinates with. These final values are used in the <code class="literal">draw()</code> method function that shows the bright centroid in the image:</p><div class="informalexample"><pre class="programlisting">public void draw(final Graphics g) { try {
  
  if (!(g instanceofGraphics2D)) return;
  final Graphics2D g2d = (Graphics2D)g;
  
<span class="strong"><strong>  //some code skipped for brevity...</strong></span>
  
  // Draw snapping objects:
  if (snapping()) {
    g2d.setColor(settings.hilicolor);
    try { g2d.setComposite(settings.snapopacity); } catch
    (Throwable e) { }
    // Snap ROI:
    g2d.setStroke(settings.snapstroke);
    final int slx = (int)((snaprect.x-vof.x + 0.5)*mag);
    final int sly = (int)((snaprect.y-vof.y + 0.5)*mag);
    final int sux = (int)((snaprect.x+snaprect.width-vof.x-0.5)*mag);
    final int suy = (int)((snaprect.y+snaprect.height-vof.y-0.5)*mag);
    g2d.drawLine(slx,sly,sux,sly);
    g2d.drawLine(sux,sly,sux,suy);
    g2d.drawLine(sux,suy,slx,suy);
    g2d.drawLine(slx,suy,slx,sly);
    // Snap cursor:
    g2d.setStroke(settings.pointstroke);
    final int xi = (int)((snapos.x - vof.x + 0.5)*mag);
    final int suy = (int)((snapos.y - vof.y + 0.5)*mag);
    final int hps = 6;
    g2d.drawLine(xi,yi-hps,xi,yi+hps);
    g2d.drawLine(xi-hps,yi,xi+hps,yi);
  }
}</pre></div><p>This method uses a <code class="literal">Graphics2D</code> object referenced by <code class="literal">g2d</code> to create a square box indicating the snap region (the <code class="literal">// Snap ROI</code> section), whose size is determined by the values of the <code class="literal">snaprect</code> <a id="id475" class="indexterm"/>object. Finally, it draws a small <code class="literal">+</code> to indicate the snap coordinate <a id="id476" class="indexterm"/>defined by the <code class="literal">snapos.x</code> and <code class="literal">snapos.y</code> variables (the <code class="literal">// Snap cursor</code> section).</p></div><div class="section" title="Coloc2"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec50"/>Coloc2</h3></div></div></div><p>For certain types of <a id="id477" class="indexterm"/>research questions, it is important to know whether two objects overlap or colocalize. The <span class="strong"><strong>Coloc2</strong></span> is a plugin included in the <code class="literal">Colocalisation_Analysis.jar</code> file as developed by Daniel J. White, Tom Kazimiers, and Johannes Schindelin. The <a id="id478" class="indexterm"/>source is available on GitHub at <a class="ulink" href="https://github.com/fiji/Colocalisation_Analysis/">https://github.com/fiji/Colocalisation_Analysis/</a>. The Coloc2 command is used to measure colocalization between two images, usually representing different channels in fluorescent images.</p><p>The main functionality is placed in the <code class="literal">colocalise</code> method, which compares the pixel intensities between the two images using different methods. As an example of how this plugin functions, I will look at a more basic function that is used whenever a selection is present in the ROI manager and needs to be used for the colocalization analysis. The method is called <a id="id479" class="indexterm"/>
<code class="literal">createMasksFromRoiManager</code>, and it calls a second method <a id="id480" class="indexterm"/>called <code class="literal">createMasksAndRois</code>:</p><div class="informalexample"><pre class="programlisting">protected boolean createMasksFromRoiManager(int width, int height) {
  RoiManager roiManager = RoiManager.getInstance();
  if (roiManager == null) {
    IJ.error("Could not get ROI Manager instance.");
    return false;
  }
  Roi[] selectedRois = roiManager.getSelectedRoisAsArray();
  // create the ROIs
  createMasksAndRois(selectedRois, width, height);
  return true;
}

protected void createMasksAndRois(Roi[] rois, int width, int height) {
  // create empty list
  masks.clear();
  
  for (Roi r : rois ){
    MaskInfo mi = new MaskInfo();
    // add it to the list of masks/ROIs
    masks.add(mi);
    // get the ROIs/masks bounding box
    Rectangle rect = r.getBounds();
    mi.roi = new BoundingBox(
    new long[] {rect.x, rect.y} ,
    new long[] {rect.width, rect.height});
    ImageProcessor ipMask = r.getMask();
    // check if we got a regular ROI and return if so
    if (ipMask == null) {
      continue;
    }
    
    // create a mask processor of the same size as a slice
    ImageProcessor ipSlice = ipMask.createProcessor(width, height);
    // fill the new slice with black
    ipSlice.setValue(0.0);
    ipSlice.fill();
    // position the mask on the new  mask processor
    ipSlice.copyBits(ipMask, (int)mi.roi.offset[0],
    (int)mi.roi.offset[1], Blitter.COPY);
    // create an Image&lt;T&gt; out of it
    ImagePlus maskImp = new ImagePlus("Mask", ipSlice);
    // and remember it and the masks bounding box
    mi.mask = ImagePlusAdapter.&lt;T&gt;wrap( maskImp );
  }
}</pre></div><p>The first step is to retrieve the ROIs from the manager using the <code class="literal">getSelectedRoisAsArray()</code> method, which then passes the ROIs to the <code class="literal">createMasksAndRois</code> method. This method stores the regions in the <code class="literal">mi.mask</code> variable where it can be used by the <code class="literal">colocalise</code> method. This plugin uses some constructs derived from ImageJ2. The <code class="literal">ImagePlusAdapter</code> is a wrapper function from the <code class="literal">ImgLib2</code> library. This convenience method allows ImageJ1.x images to be placed inside an <code class="literal">ImgLib2</code> container as <a id="id481" class="indexterm"/>used by ImageJ2. These functions are essential during the transition between ImageJ1.x and ImageJ2 and allow for interoperability. Next, I will take a look at a plugin that was developed within the SciJava framework using the <a id="id482" class="indexterm"/>annotations and the <span class="strong"><strong>Command and Service framework</strong></span> specifically for ImageJ2.</p></div><div class="section" title="Goutte_pendante"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec51"/>Goutte_pendante</h3></div></div></div><p>The <span class="strong"><strong>Goutte_pendante</strong></span> <a id="id483" class="indexterm"/>plugin (pendant drop) is a plugin built under the SciJava framework by Adrian Daerr at the Université Paris Diderot. The source <a id="id484" class="indexterm"/>code can be found on GitHub at <a class="ulink" href="https://github.com/adaerr/pendent-drop">https://github.com/adaerr/pendent-drop</a>. This project is written using the Maven system, so I will briefly show the <code class="literal">pom.xml</code> file as an example of how to define a plugin within the framework:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0   http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;net.imagej&lt;/groupId&gt;
    &lt;artifactId&gt;pom-imagej&lt;/artifactId&gt;
    &lt;version&gt;7.1.0&lt;/version&gt;
    &lt;relativePath /&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;name.adriandaerr.imagejplugins.pendentdrop&lt;/groupId&gt;
  &lt;artifactId&gt;pendent_drop&lt;/artifactId&gt;
  &lt;version&gt;2.0.1&lt;/version&gt;
  &lt;name&gt;Pendent Drop ImageJ Plugin&lt;/name&gt;
  &lt;description&gt;Surface tension measurement through the pendent drop method.&lt;/description&gt;
  &lt;properties&gt;
    &lt;main-class&gt;Goutte_Pendante&lt;/main-class&gt;
  &lt;/properties&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;imagej.public&lt;/id&gt;
      &lt;url&gt;http://maven.imagej.net/content/groups/public&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.imagej&lt;/groupId&gt;
      &lt;artifactId&gt;imagej&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</pre></div><p>You can see that the project description is very simple using the POM model. The <code class="literal">&lt;parent&gt;</code> tag describes that this utilizes ImageJ. The dependencies state that the ImageJ2 code base should be used, as identified by the <code class="literal">&lt;artifactId&gt;</code> tag using <code class="literal">imagej</code> instead of <code class="literal">ij</code> for ImageJ1.x plugins. Plugins built for ImageJ2 also tend to have a <code class="literal">main</code> method. To illustrate its <a id="id485" class="indexterm"/>function, I will highlight some of the code from this <a id="id486" class="indexterm"/>plugins' <code class="literal">main</code> method:</p><div class="informalexample"><pre class="programlisting">public static void main(final String... args) throws Exception {
  final String testImagePath =
  "/home/adrian/Programmes/plugins_ImageJ_src/Traitement_Gouttes/src
  /test/resources/eauContrasteMaxStack.tif";
  
  // Launch ImageJ as usual.
  //final ImageJ ij = net.imagej.Main.launch(args);
  final ImageJ ij = new ImageJ();
  ij.ui().showUI();
  
  // Open test image.
  final ServiceHelper sh = new ServiceHelper(ij.getContext());
  final IOService io = sh.loadService(DefaultIOService.class);
  final Dataset dataset = (Dataset) io.open(testImagePath);
  
  // create a display for the dataset
  final ImageDisplay imageDisplay =
  (ImageDisplay) ij.display().createDisplay(dataset);
  
  // create a rectangle
  final RectangleOverlay rectangle = new
  RectangleOverlay(ij.getContext());
  rectangle.setOrigin(110, 0);
  rectangle.setOrigin(60, 1);
  rectangle.setExtent(340, 0);
  rectangle.setExtent(420, 1);
  rectangle.setLineColor(Colors.HONEYDEW);
  rectangle.setLineWidth(1);
  
  // add the overlays to the display
  final List&lt;Overlay&gt; overlays = new ArrayList&lt;Overlay&gt;();
  overlays.add(rectangle);
  ij.overlay().addOverlays(imageDisplay, overlays);
  for (final net.imagej.display.DataView view : imageDisplay) {
    if (view instanceofnet.imagej.display.OverlayView) {
      view.setSelected(true);
    }
  }
  
  // display the dataset
  ij.ui().show(imageDisplay);
  
  // Launch the "CommandWithPreview" command.
  ij.command().run(Goutte_pendante.class, true);
}</pre></div><p>This code is only used when testing the plugin and performs a few steps that are useful when testing code but not when actually using the plugin outside of the testing phase. It starts by defining a test <a id="id487" class="indexterm"/>image with a hard-coded path string. It then performs the <a id="id488" class="indexterm"/>step that all plugins for ImageJ will perform in their main method: launching an instance of ImageJ. It then goes on to open the image specified by the string using <code class="literal">IOService</code> and finally displaying it using the <code class="literal">ImageDisplay</code> service. The result of this process is the image of a drop hanging from an aperture:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_08_09.jpg" alt="Goutte_pendante"/></div><p>Next, a <code class="literal">rectangle</code> object is generated over the drop image that was opened. This image will be used as an initial search space for the plugin to detect the drop. This is done using the <code class="literal">RectangleOverlay</code> class in the <code class="literal">net.imagej.overlay</code> package. Finally, it adds the overlay to the display and displays the image before calling the plugin in the last statement of the method:</p><div class="informalexample"><pre class="programlisting">ij.command().run(Goutte_pendante.class, true);</pre></div><p>The used pattern in this <a id="id489" class="indexterm"/>plugin is similar to that described in the previous chapter. However, there are additional steps inserted here to make sure that the plugin works fast and correctly. If you would install the plugin using <span class="strong"><strong>Update site</strong></span> through Fiji and <a id="id490" class="indexterm"/>try to run it immediately by selecting <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Drop Analysis</strong></span> | <span class="strong"><strong>Pendant Drop</strong></span> from the menu, you will get an error message. This error message states that there is an error executing the <code class="literal">Goutte_pendante#paramInitializer</code> method. If you run <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Drop Analysis</strong></span> | <span class="strong"><strong>About Pendant Drop</strong></span>, you will see a brief explanation and a usage section for the plugin. In the usage section, there will be an explanation of why it failed. There was no rectangular ROI or image when you launched it. At the bottom of the about dialog, there are buttons with information and documentation, as well as a way to retrieve the image of the drop (bottom button).</p><p>The goal of this plugin is to fit the shape of the drop, and the parameters of that fit can be used to say something about the surface tension of the liquid. To do so, it needs a class that describes the shape of the drop that is defined as an object called <code class="literal">Contour</code> within the plugin. It needs to fit a polynomial to the drop shape in order to determine <code class="literal">Contour</code> parameters. To do so, it is necessary to determine the borders of the drop. This is achieved by a method called <code class="literal">findDropBorders()</code>. This function will find the shoulders of the drop and store the <a id="id491" class="indexterm"/>locations in arrays for the left and right <a id="id492" class="indexterm"/>borders:</p><div class="informalexample"><pre class="programlisting">private boolean findDropBorders(ImageProcessor ip) {
  leftBorder = null;
  rightBorder = null;
  
  for (int y = bounds.height - 1; y &gt;= 0; y--) {
    
    // find border positions with integer precision
    // left border first
    int xl = 0;
    while (xl &lt;bounds.width &amp;&amp;
      ip.getPixelValue(bounds.x + xl, bounds.y + y) &gt; threshold)
    xl ++;
    
    if (xl &gt;= bounds.width) {// drop not detected in this scanline
      if (leftBorder != null) {
        leftBorder[y]  = Double.NaN;
        rightBorder[y] = Double.NaN;
      }
      continue;
    } else if (leftBorder == null) {
      // allocate array on drop tip detection
      leftBorder = new double[y+1];
      rightBorder = new double[y+1];
    }
    
    // right border next
    int xr = bounds.width - 1;
    while (xr&gt; xl &amp;&amp;
      ip.getPixelValue(bounds.x + xr, bounds.y + y) &gt; threshold)
    xr --;
    xr ++; // so xl and xr point just to the right of the interface
    
    // don't go further if not enough pixels for subpixel-fitting
    if (xr - xl &lt;= voisinage ||
    xl - voisinage&lt; 0 || xr + voisinage&gt;bounds.width) {
      leftBorder[y]  = xl - 0.5;
      rightBorder[y] = xr - 0.5;
      continue;
    }
    
    // now determine drop borders with sub-pixel precision
    leftBorder[y]  = fitStep(ip, xl, y, voisinage, false);
    rightBorder[y] = fitStep(ip, xr, y, voisinage, true);
  } // end for y
  
  if (leftBorder == null)
    return false;
  else
    return true;
}</pre></div><p>This method performs a line scan method to find the index where the drop falls below the threshold. In this case, the drop has a low value compared to the background. It starts by going in the left-to-right direction. As soon as it has found that pixel, the variable <code class="literal">xl</code> will no longer increase and will be smaller than the width of the bounds. This will activate the <code class="literal">else if</code> clause and will allocate the arrays for the borders. The next step is to determine the index on the right-hand side using the same methodology. However, now, the search goes in the right-to-left direction, starting at the bounding box, and will determine <code class="literal">xr</code>.</p><p>The code mentioned in this method is generic Java code that is not specific for ImageJ2, but it performs the task in a similar way. It illustrates the fact that ImageJ2 plugins are not necessarily more <a id="id493" class="indexterm"/>complicated than or different from their legacy counterparts <a id="id494" class="indexterm"/>in terms of development. A difference between this plugin and a legacy plugin is the use of services such as the <code class="literal">LogService</code> interface. When the plugin is launched, it requests an instance of <code class="literal">LogService</code> using the <code class="literal">@Parameter</code> annotation:</p><div class="informalexample"><pre class="programlisting">@Parameter
private LogService log;</pre></div><p>In the functional part of the plugin, this service is called to perform the logging of errors and other messages. An example can be found in the <code class="literal">run()</code> method of the plugin:</p><div class="informalexample"><pre class="programlisting">public void run() {
  HashMap&lt;SHAPE_PARAM,Boolean&gt; fitMe = tagParamsToFit();
  if ( ! fitMe.containsValue(Boolean.TRUE) ) {
    log.error("At least one parameter must be selected !");
    return;
  }
  //code skipped for brevity...
}</pre></div><p>The log variable can be used to write messages to the log window. Based on the function used, they will be preceded <a id="id495" class="indexterm"/>by a label that indicates the type of the message. Methods such as <code class="literal">error</code>, <code class="literal">warn</code>, and <code class="literal">info</code> allow for different categories of <a id="id496" class="indexterm"/>messages to be reported.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we looked at the anatomy of plugins for ImageJ1.x and ImageJ2. We also looked at some of the specific constructs that are used in plugins for both frameworks. We examined how to compile, run, and debug our plugins using the tools provided by ImageJ or using the IDE. We looked at some established plugins and how they implemented plugins to perform a task in image processing.</p><p>This knowledge will be applied in the next chapter where we will create a plugin from scratch to perform image processing.</p></div></body></html>