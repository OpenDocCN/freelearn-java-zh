["```java\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-batch</artifactId>\n        <version>2.4.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jdbc</artifactId>\n        <version>2.4.0</version>\n    </dependency>\n    <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n        <version>42.3.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>2.0.0-alpha0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-log4j12</artifactId>\n        <version>2.0.0-alpha0</version>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n```", "```java\n@EnableConfigurationProperties\n@EnableScheduling\n@ComponentScan ({\"com.scalabledataarchitecture.etl.*\", \"com.scalabledataarchitecture.etl.config.*\"})\n@SpringBootApplication\npublic class EtlDatawarehouseApplication {\n    private static Logger LOGGER = LoggerFactory.getLogger(EtlDatawarehouseApplication.class);\n\n    @Autowired\n    JobLauncher jobLauncher;\n    @Autowired\n    Job etlJob;\n    public static void main(String[] args) {\n        try {\n            SpringApplication.run(EtlDatawarehouseApplication.class, args);\n        }catch (Throwable ex){\n            LOGGER.error(\"Failed to start Spring Boot application: \",ex);\n        }\n    }\n    @Scheduled(cron = \"0 */1 * * * ?\")\n    public void perform() throws Exception\n    {\n        JobParameters params = new JobParametersBuilder().addString(\"JobID\", String.valueOf(System.currentTimeMillis())).toJobParameters();\n        jobLauncher.run(etlJob, params);\n    }\n}\n```", "```java\n@Scheduled(fixedDelayString = \"${fixedDelay.in.milliseconds}\")\n@Scheduled(fixedRateString = \"${fixedRate.in.milliseconds}\")\n@Scheduled(cron = \"${cron.expression}\")\n```", "```java\n@Configuration\n@EnableBatchProcessing\npublic class BatchJobConfiguration {\n    @Bean\n    public Job etlJob(JobBuilderFactory jobs,\n                      Step fileCheck, Step fileMoveToProcess, Step processFile,Step fileMoveToArchive, Step fileMoveToError) {\n        return jobs.get(\"etlJob\")\n                .start(fileCheck).on(ExitStatus.STOPPED.getExitCode()).end()\n                .next(fileMoveToProcess)\n                .next(processFile).on(ExitStatus.COMPLETED.getExitCode()).to(fileMoveToArchive)\n                .from(processFile).on(ExitStatus.FAILED.getExitCode()).to(fileMoveToError)\n                .end()\n                .build();\n    }\n}\n```", "```java\npublic class FileCheckingTasklet implements Tasklet{\n//...\n}\n```", "```java\npublic RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception\n```", "```java\npublic interface StepExecutionListener extends StepListener {\n    void beforeStep(StepExecution var1);\n    @Nullable\n    ExitStatus afterStep(StepExecution var1);\n}\n```", "```java\npublic class FileCheckingTasklet implements Tasklet, StepExecutionListener {\n//...\n@Override\npublic RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {\n//...\n}\n@Override\npublic ExitStatus afterStep(StepExecution stepExecution) {\n//...\n}\n}\n```", "```java\n@Override\npublic ExitStatus afterStep(StepExecution stepExecution) {\n    Path dir = Paths.get(envFolderProperty.getRead());\n    LOGGER.debug(\"Checking if read directory {} contains some files...\", dir);\n    try {\n        List<Path> files = Files.list(dir).filter(p -> !Files.isDirectory(p)).collect(Collectors.toList());\n        if(files.isEmpty()) {\n            LOGGER.info(\"Read directory {} does not contain any file. The job is stopped.\", dir);\n            return ExitStatus.STOPPED;\n        }\n        LOGGER.info(\"Read directory {} is not empty. We continue the job.\", dir);\n        return ExitStatus.COMPLETED;\n    } catch (IOException e) {\n        LOGGER.error(\"An error occured while checking if read directory contains files.\", e);\n        return ExitStatus.FAILED;\n    }\n}\n```", "```java\npublic class FileCheckingTasklet implements Tasklet, StepExecutionListener {\n    private final static Logger LOGGER = LoggerFactory.getLogger(FileCheckingTasklet.class);\n    private final EnvFolderProperty envFolderProperty;\n    public FileCheckingTasklet(EnvFolderProperty envFolderProperty) {\n        this.envFolderProperty = envFolderProperty;\n    }\n    @Override\n    public void beforeStep(StepExecution stepExecution) {\n    }\n    @Override\n    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {\n        return RepeatStatus.FINISHED;\n    }\n    @Override\n    public ExitStatus afterStep(StepExecution stepExecution) {\n        // Source code as shown in previous discussion ...\n    }\n}\n```", "```java\n@Bean\npublic Tasklet fileCheckingTasklet(EnvFolderProperty envFolderProperty) {\n    return new FileCheckingTasklet(envFolderProperty);\n}\n```", "```java\n@Bean\npublic Step fileCheck(StepBuilderFactory stepBuilderFactory, Tasklet fileCheckingTasklet) {\n    return stepBuilderFactory.get(\"fileCheck\")\n            .tasklet(fileCheckingTasklet)\n            .build();\n}\n```", "```java\n@Configuration\npublic class FileCheckConfiguration {\n    @Bean\n    public Tasklet fileCheckingTasklet(EnvFolderProperty envFolderProperty) {\n        return new FileCheckingTasklet(envFolderProperty);\n    }\n    @Bean\n    public Step fileCheck(StepBuilderFactory stepBuilderFactory, Tasklet fileCheckingTasklet) {\n        return stepBuilderFactory.get(\"fileCheck\")\n                .tasklet(fileCheckingTasklet)\n                .build();\n    }\n}\n```", "```java\n@Override\npublic RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {\n    Path dir = Paths.get(envFolderProperty.getRead());\n    assert Files.isDirectory(dir);\n    List<Path> files = Files.list(dir).filter(p -> !Files.isDirectory(p)).collect(Collectors.toList());\n    if(!files.isEmpty()) {\n        Path file = files.get(0);\n        Path dest = Paths.get(envFolderProperty.getProcess() + File.separator + file.getFileName());\n        LOGGER.info(\"Moving {} to {}\", file, dest);\n        Files.move(file, dest);\n        filepath = dest;\n    }\n    return RepeatStatus.FINISHED;\n}\n```", "```java\n@Override\npublic ExitStatus afterStep(StepExecution stepExecution) {\n    if(filepath != null) {\n        stepExecution.getJobExecution().getExecutionContext().put(\"filepath\", filepath);\n        stepExecution.getJobExecution().getExecutionContext().put(\"filepathName\", filepath.toString());\n    }\n    return ExitStatus.COMPLETED;\n}\n```", "```java\npublic class FileMoveToProcessTasklet implements Tasklet, StepExecutionListener {\n    private final static Logger LOGGER = LoggerFactory.getLogger(FileMoveToProcessTasklet.class);\n    private final EnvFolderProperty envFolderProperty;\n    private Path filepath;\n    public FileMoveToProcessTasklet(EnvFolderProperty envFolderProperty) {\n        this.envFolderProperty = envFolderProperty;\n    }\n    @Override\n    public void beforeStep(StepExecution stepExecution) {\n    }\n    @Override\n    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {\n   // Source code as shown in previous discussion ...\n }\n    @Override\n    public ExitStatus afterStep(StepExecution stepExecution) {\n     // Source code as shown in previous discussion ...            \n    }\n}\n```", "```java\n@Configuration\npublic class FileMoveToProcessConfiguration {\n    @Bean\n    public Tasklet fileMoveToProcessTasklet(EnvFolderProperty envFolderProperty) {\n        return new FileMoveToProcessTasklet(envFolderProperty);\n    }\n    @Bean\n    public Step fileMoveToProcess(StepBuilderFactory stepBuilderFactory, Tasklet fileMoveToProcessTasklet) {\n        return stepBuilderFactory.get(\"fileMoveToProcess\")\n                .tasklet(fileMoveToProcessTasklet)\n                .build();\n    }\n}\n```", "```java\n@Bean\npublic Step processFile(StepBuilderFactory stepBuilderFactory, ItemReader<EventLogODL> csvRecordReader, JdbcBatchItemWriter<DeviceEventLogFact> jdbcWriter) {\n    return stepBuilderFactory.get(\"processFile\")\n            .<EventLogODL, DeviceEventLogFact>chunk(chunkSize)\n            .reader(csvRecordReader)\n            .processor(deviceEventProcessor)\n            .writer(jdbcWriter)\n            .build();\n}\n```", "```java\npublic class EventLogODL {\n    private String incidentNumber;\n    private String deviceSerialNum;\n    private String eventCode;\n    private String loggedTime;\n    private String closureTime;\n    private String status;\n    private String assignedTo;\n    private String resolutionComment;\n  // Getters and Setter of the instance fields\n } \n```", "```java\n@Bean\n@StepScope\npublic FlatFileItemReader<EventLogODL> csvRecordReader(@Value(\"#{jobExecutionContext['filepathName']}\")  String filePathName)\n        throws UnexpectedInputException, ParseException {\n    FlatFileItemReader<EventLogODL> reader = new FlatFileItemReader<EventLogODL>();\n    DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer();\n    String[] tokens = { \"incidentNumber\",\"deviceSerialNum\",\"eventCode\",\"loggedTime\",\"closureTime\",\"status\",\"assignedTo\",\"resolutionComment\" };\n    tokenizer.setNames(tokens);\n    reader.setResource(new FileSystemResource(filePathName));\n    reader.setLinesToSkip(1);\n    DefaultLineMapper<EventLogODL> lineMapper =\n            new DefaultLineMapper<EventLogODL>();\n    lineMapper.setLineTokenizer(tokenizer);\n    lineMapper.setFieldSetMapper(new BeanWrapperFieldSetMapper<EventLogODL>(){\n        {\n            setTargetType(EventLogODL.class);\n        }\n    });\n    reader.setLineMapper(lineMapper);\n    return reader;\n}\n```", "```java\n@Component\npublic class DeviceEventProcessor implements ItemProcessor<EventLogODL, DeviceEventLogFact> {\n    @Autowired\n    DeviceEventLogMapper deviceEventLogMapper;\n    @Override\n    public DeviceEventLogFact process(EventLogODL eventLogODL) throws Exception {\n        return deviceEventLogMapper.map(eventLogODL);\n    }\n}\n```", "```java\n@Component\npublic class DeviceEventLogMapper {\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n    public DeviceEventLogFact map(EventLogODL eventLogODL){\n        String sqlForMapper = createQuery(eventLogODL);\n        return jdbcTemplate.queryForObject(sqlForMapper,new BeanPropertyRowMapper<>(DeviceEventLogFact.class));\n    }\n    private String createQuery(EventLogODL eventLogODL){\n        return String.format(\"WITH DEVICE_DM AS\\n\" +\n                \"\\t(SELECT '%s' AS eventLogId \"+ ...,eventLogODL.getIncidentNumber(),eventLogODL.getDeviceSerialNum(),...);\n    }\n```", "```java\n@Bean\npublic JdbcBatchItemWriter<DeviceEventLogFact> jdbcWriter() {\n    JdbcBatchItemWriter<DeviceEventLogFact> writer = new JdbcBatchItemWriter<>();\n    writer.setItemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>());\n    writer.setSql(\"INSERT INTO chapter4.device_event_log_fact(eventlogid,deviceid,eventid,hourid,monthid,quarterid,eventtimestamp,closurestatus,closureduration) VALUES (:eventLogId, :deviceId, :eventId, :hourId, :monthId, :quarterId, :eventTimestamp, :closureStatus, :closureDuration)\");\n    writer.setDataSource(this.dataSource);\n    return writer;\n}\n```", "```java\n@Configuration\n@SuppressWarnings(\"SpringJavaAutowiringInspection\")\npublic class ProcessFileConfiguration {\n    private final static Logger LOGGER = LoggerFactory.getLogger(ProcessFileConfiguration.class);\n\n    @Value(\"${process.chunk_size:1}\")\n    int chunkSize;\n    @Autowired\n    DataSource dataSource;\n    @Autowired\n    DeviceEventProcessor deviceEventProcessor;\n\n    @Bean\n    @StepScope\n    public FlatFileItemReader<EventLogODL> csvRecordReader(@Value(\"#{jobExecutionContext['filepathName']}\")  String filePathName)\n            throws UnexpectedInputException, ParseException {\n        // Source code as shown in previous discussion ...\n    }\n    @Bean\n    public JdbcBatchItemWriter<DeviceEventLogFact> jdbcWriter() {\n// Source code as shown in previous discussion ...\n\n }\n    @Bean\n    public Step processFile(StepBuilderFactory stepBuilderFactory, ItemReader<EventLogODL> csvRecordReader, JdbcBatchItemWriter<DeviceEventLogFact> jdbcWriter) {\n\n    // Source code as shown in previous discussion ...\n    }\n}\n```", "```java\nspring:\n  datasource:\n    url: jdbc:postgresql://localhost:5432/sinchan\n    username: postgres\n    driverClassName: org.postgresql.Driver\n  batch:\n    initialize-schema: always\nenv:\n  folder:\n    read: /Users/sinchan/Documents/Personal_Docs/Careers/Book-Java_Data_Architect/chapter_4_pgrm/landing\n    process: /Users/sinchan/Documents/Personal_Docs/Careers/Book-Java_Data_Architect/chapter_4_pgrm/process\n    archive: /Users/sinchan/Documents/Personal_Docs/Careers/Book-Java_Data_Architect/chapter_4_pgrm/archive\n    error: /Users/sinchan/Documents/Personal_Docs/Careers/Book-Java_Data_Architect/chapter_4_pgrm/error\n```"]