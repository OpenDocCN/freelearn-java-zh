- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Tests in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you have learned about the importance of loggers, their
    concepts, and how they can help developers debug and maintain applications. You
    have learned about Log4j2, which is a third-party framework for Spring Boot that
    offers several features such as **Appenders**, **Filters**, and **Markers** that
    can assist in making log events categorized and formatted for developers. We have
    also discussed SLF4J, which is an abstraction of logging frameworks that allows
    us to switch between different frameworks during runtime or at deployment, and
    lastly, we have implemented and configured the logging frameworks with XML configuration
    and Lombok.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will now focus on writing unit tests for our Spring Boot application;
    we will discuss the most commonly used testing frameworks with Java, JUnit, and
    **AssertJ** and implement them in our application. We will also be integrating
    Mockito with our unit test for mocking objects and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JUnit and AssertJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests in a service using Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The link to the finished version of this chapter is here: [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JUnit and AssertJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After every development of an application, testing will always be the next step,
    and this is one of the most important tasks before delivering or deploying our
    application into production for the world. The testing phase is critical for companies,
    as this ensures the quality and effectiveness of their products.
  prefs: []
  type: TYPE_NORMAL
- en: As this is one of the essential processes, there should be little room for errors
    in testing, and manual testing is not enough, as this is prone to human errors
    and has a more significant chance of missing the existing issues in an application.
    This is where unit testing comes to the rescue – unit testing is automated testing
    that allows the developer to write tests for a single class or entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a form of **regression testing** that runs all of the tests to validate
    whether the code still passes the test cases after several changes or updates
    have been applied to the application code. Unit tests help maintain the quality
    of our applications, as they bring the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Unit testing will be less time-consuming compared to manual testing,
    as this is programmable and will deliver the results in a short period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost reduction**: Unit testing is automated, which means fewer testers will
    be required for testing the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fewer errors**: Unit testing will significantly reduce the number of errors
    made, as testing is not done manually by humans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmable**: Unit tests can produce sophisticated tests that detect hidden
    information in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are widely used now in both frontend and backend development, especially
    in Java, because of their advantages and testing. There are already several testing
    frameworks available in Java, but we will discuss the first and most commonly
    used framework, **JUnit**.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit is a regression testing framework mainly used for writing tests and assertions
    for single classes in a Java application; it promotes the idea of *first testing
    and then coding*, which states that we need to create test data for a piece of
    code to be tested before implementation. JUnit is also an open source framework,
    which makes it more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: There is a large community supporting the framework, it uses assertions to test
    expected results and annotations to identify the methods for testing, and it can
    be efficiently utilized and integrated with Maven and Gradle projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss the features of JUnit that we will use for writing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setUp()`: This method is executed *before* every test is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tearDown()`: This method is executed *after* every test is invoked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we can see that there are two test methods defined,
    which are `testSubtract()` and `testMultiply()`, before each method is called.
    The `setUp()` fixture will be called first to assign the values of the `value1`
    and `value2` variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith` and `@Suite` annotations to run the tests. Let’s have a look at
    the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have two defined classes with
    a method with the `@Test` annotation; the test methods will be executed together,
    as we have bundled them using the `@``Suite.SuiteClasses` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`runClasses()` method to run the test cases inside a specific class. Let’s
    have a look at a basic example here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Classes**: JUnit classes are mainly used for writing the tests for our application;
    these include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Includes the set of assert methods'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case**: Includes the test cases that contain the fixtures for running
    multiple tests'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test result**: Includes the methods to gather all of the results from an
    executed test case'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions in JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Assert` class, and some of the essential methods from Assert are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void assertTrue(boolean condition)`: Validates whether the condition is `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void assertFalse(boolean condition)`: Validates whether the condition is `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void assertNotNull(Object obj)`: Checks whether the object is not null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void assertNull(Object obj)`: Checks whether the object is null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void assertEquals(Object obj1, Object obj2)`: Checks whether two objects or
    primitives are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void assertArrayEquals(Array array1, Array array2)`: Validates whether two
    arrays are equal to each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Annotations** are meta tags that we add to methods and classes; this provides
    additional information to JUnit about which methods should run before and after
    the test methods and which will be ignored during the test execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the annotations that we can use in JUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Test`: This annotation is used for a `public void` method to signify that
    the method is a test case that can be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Ignore`: This annotation is used to ignore a test case not being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Before`: This annotation is used for a `public void` method to run the method
    before each test case method. This is commonly used if we want to declare similar
    objects used by all test cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@After`: The annotation is used for a `public void` method to run the method
    after each test case method; this is commonly used if we want to release or clean
    several resources before running a new test case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeClass`: The annotation allows a `public static void` method to run
    once before all of the test cases are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AfterClass`: The annotation allows a `public static void` method to run once
    all test cases are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s have an example test with annotations and their sequence of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have a `JunitAnnotationSequence` class that
    has several annotated methods. When we execute the test, we will have the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that the methods annotated with `@BeforeClass`
    and `@AfterClass` are only called once and they are called at the start and end
    of the test execution. On the other hand, the methods annotated with `@Before`
    and `@After` are called at the beginning and the end of each test method.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the basics of JUnit in unit testing; now, let’s discuss
    the concepts of AssertJ.
  prefs: []
  type: TYPE_NORMAL
- en: Using AssertJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just explored the concepts and features of JUnit in the last part, and
    we have learned that in JUnit alone, we can apply assertions using the `Assert`
    class, but we can make our assertions more fluent and flexible by using AssertJ.
    **AssertJ** is a library mainly used for writing assertions; its primary goal
    is to improve the readability of test code and make the maintenance of tests simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare how to write assertions in JUnit and AssertJ:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit checking whether the condition returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'AssetJ checking whether the condition returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding example that in AssertJ, we will always pass the
    object to be compared in the `assertThat()` method, and we will call the next
    method, which is the actual assertion. Let’s have a look at the different kinds
    of assertions we can use in AssertJ.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`true` or `false`. The assertion methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isTrue()`: Checks whether the condition is `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isFalse()`: Checks whether the condition is `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Character assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Character assertions** are used to compare the object to a character or check
    whether the character is in the Unicode table; the assertion methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isLowerCase()`: Reviews whether the given character is lowercase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isUpperCase()`: Checks whether the character is uppercase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isEqualTo()`: Checks whether the two given characters are equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isNotEqualTo()`: Checks whether the two given characters are not equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`inUnicode()`: Checks whether the character is included in the Unicode table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are just some of the assertions available under `AbstractCharacterAssert`.
    For the complete documentation, you can go to [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Class assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Class assertions** are used to check the fields, types, access modifiers,
    and annotations in a specific class. The following are some of the class assertion
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isNotInterface()`: Verifies that the class is not an interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isInterface()`: Verifies that the class is an interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isPublic()`: Verifies that the class is public:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isNotPublic()`: Verifies that the class is not public:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are just some of the assertions available under `AbstractClassAssert`.
    For the complete documentation, you can go to [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html).
  prefs: []
  type: TYPE_NORMAL
- en: Iterable assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Iterable assertions** are used to verify an iterable or array object based
    on its length and contents. The following are some of the iterable assertion methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contains()`: Demonstrates that the iterable has the given values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isEmpty()`: Verifies whether the given iterable has a length greater than
    `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isNotEmpty()`: Verifies whether the given iterable has a length of `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`hasSize()`: Verifies whether the length of the iterable is equal to the given
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These are just some of the assertions available under `AbstractIterableAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html).'
  prefs: []
  type: TYPE_NORMAL
- en: File assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**File assertions** are used to verify whether a file exists, can be written,
    or is readable, and also verify its contents. The following are some of the file
    assertion methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exists()`: Proves that the file or directory exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isFile()`: Verifies whether the given object is a file (providing a directory
    will result in a failed test):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`canRead()`: Verifies whether the given file is readable by the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`canWrite()`: Verifies whether the given file is modifiable by the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These are just some of the assertions available under `AbstractFileAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Map assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Map assertions** are used to check a map based on its entries, keys, and
    size. The following are some of the map assertion methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contains()`: Verifies whether the map contains the given entries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`containsAnyOf()`: Verifies whether the map contains at least one of the entries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`hasSize()`: Verifies that the size of the map is equal to the given value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isEmpty()`: Verifies that the given map is empty:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`isNotEmpty()`: Verifies that the given map is not empty:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These are just some of the assertions available under `AbstractMapAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the different assertion methods using AssertJ; now, we
    will implement and write our unit test in our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will now start writing our unit tests in our Spring Boot
    application. As we go back to our application, the **services** and **repository**
    are the essential parts of our application where we need to implement unit tests,
    as the services contain the business logic and can be modified often, especially
    when new features are added. The repository includes methods for CRUD and other
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing two approaches in writing our unit tests. The first
    method is using an in-memory database such as H2 to store our created data when
    running unit tests. The second method is mocking our objects and repository using
    the Mockito framework.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the H2 database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first approach that we will implement in writing our tests is using JUnit
    and AssertJ with the H2 database. The H2 database is an in-memory database that
    allows us to store data in the system memory. Once the application is closed,
    it will delete all the stored data. H2 is usually used for **Proof-of-Concept**
    or unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already added an H2 database in [*Chapter 4*](B18159_04.xhtml#_idTextAnchor079),
    *Setting Up the Database and Spring Data JPA*, but if you have missed this part,
    in order for us to add the H2 dependency, we will add the following into our `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully adding the dependency, we will add our `h2` configuration
    under our `test/java` folder. We will add a new resource bundle and create a new
    application to accomplish this. A properties file will be used for the unit tests
    and we will place the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example configuration, first, we have specified that we want
    to store our data in a `test.mv.db` file using the `spring.datasource.url` property.
    We can also override the username and password for our *H2* console using the
    `spring.datasource.username` and `spring.datasource.password` properties, and
    we have also specified that the tables will be created once the application starts
    and will be dropped when the application stops.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we will create a package under our `test/java` folder. This is where we
    will write our tests. We will create a similar package from our main folder. In
    this case, we will make `com.example.springbootsuperheroes.superheroes.antiHero.h2.service`.
    Under the newly created package, we will create a new class named `AntiHeroH2ServiceTest`,
    where we will start writing our tests for `AntiHeroService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we need to take is to annotate our class using the `@DataJpaTest`
    annotation. The annotation allows the service to focus only on the JPA components
    by disabling the full auto-configuration and just applying the configuration related
    to the tests. The next step is to add the dependency of our `AntiHeroService`,
    which is `AntiHeroRepository`. We will declare a new `AntiHeroRepository` and
    use the `@Autowired` annotation to inject the dependency, and we will also declare
    `AntiHeroService`, as this is the service that we need to test. We will have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'After injecting our dependency and annotating our class, the next thing we
    would want to consider is what the possible properties we want to have before
    running each of the tests are; in this case, we would like to have an instance
    of `AntiHeroService` created before running a test case. To accomplish this, we
    will make a method annotated with the `@BeforeEach` annotation, and create a new
    instance of `AntiHeroService` with `AutoWired AntiHeroRepository` as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write a test case for our service; our goal is to write a test for
    each method that `AntiHeroService` possesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have the list of the methods for `AntiHeroService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterable<AntiHeroEntity> findAllAntiHeroes`: Should return the list of anti-heroes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: Should add a new anti-hero
    entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: Should update the
    anti-hero based on the given ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AntiHeroEntity findAntiHeroById(UUID id)`: Should return the anti-hero with
    the given ID; if it is not found, it will return `NotFoundException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void removeAntiHeroById(UUID id)`: Should remove the anti-hero in the database
    based on the given ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first write a test for the `findAllAntiHeroes()` method. The possible
    test case for the method is to check whether the method retrieves all the anti-heroes
    successfully in the database. To test this scenario, we would want to add a single
    entity or a list of test anti-hero entities to our H2 database first. We can call
    the `findAllAntiHeroes()` method to retrieve the newly added entities in the database.
    Let’s see the example unit test here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created a new anti-hero
    instance to be an exemplary piece of data in the database memory first. We have
    added the data to our database using the `addAntiHero()` method. After successfully
    inserting the data, we can check or assert whether we can retrieve the newly created
    anti-hero using the `findAllAntiHeroes()` method. In the scenario here, we have
    retrieved the first data in our anti-hero list. We used `assertThat(savedAntiHero).isNotNull()`
    to validate that the first element of the list is not null.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write a test for the `addAntiHero()` method. The test that we will
    create for the following method is mostly similar to the test that we have created
    for the `findAllAntiHeroes()` method. The possible test case for the following
    method is to check whether the entity is being added to our database successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: We created a new anti-hero entity in the preceding code example and inserted
    it into our database using the `addAntiHero()` method. After adding the latest
    data, we can retrieve the list and validate whether our new data is in the database.
    In the given scenario, we retrieved the first piece of data in our anti-hero list,
    and we used `assertThat(antiHero).isEqualTo(savedAntiHero);` to check whether
    the data we retrieved was equal to the data we instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s now write the test for `updateAntiHeroMethod();`. The possible test
    case for the following method is to check whether the method successfully modifies
    a piece of information for a specific entity in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the example unit test that satisfies the test case here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We created a new anti-hero entity in the preceding code example and inserted
    it into our database using the `addAntiHero()` method. After adding the entity,
    we updated the added anti-hero’s house information to `"San Francisco"` and saved
    it in our database using `updateAntiHeroMethod()`. Lastly, we have retrieved the
    modified anti-hero using its ID and validated that the house information was modified
    by adding the `assertThat(foundAntiHero.getHouse()).isEqualTo("San` `Francisco");`
    assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we would now create a unit test for the `removeAntiHeroById()` method.
    The possible test case for the method is to validate whether an entity with a
    corresponding ID has successfully been deleted from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the example unit test that satisfies the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that we have added some additional elements
    in writing our unit test; we have created a new instance of `Executable()`, where
    we have placed our main code. We have asserted our `Executable()` with `NotFoundException.class`.
    The main reason for this is that we expect that `findAntiHeroByID()` will return
    the `NotFoundException` error, as we have deleted the entity in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when asserting errors, we should use `assertThrows()`.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully written a test for our services and now, we will implement
    unit tests at the repository level.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing a test for the repository of our application is mostly the same as how
    we write our tests at the service level; we also treat them as services and we
    test them if there are additional methods added to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example that we will take is writing a unit test for our `UserRepository`.
    Let’s have a recap of the methods that `UserRepository` possesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean selectExistsEmail(String email)`: Returns `true` when the user exists
    with the given email'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserEntity findByEmail(String email)`: Returns the user when the given email
    exists in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start writing our test, first, we will create a new package named `user.repository`
    under the `com.example.springbootsuperheroes.superheroes` package, and we will
    make a new class called `UserRepositoryTest`. After successfully creating the
    repository, we will annotate the class with `@DataJPATest` so that it focuses
    only on the JPA components and inject `AntiHeroRepostiory` using the `@``Autowired`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write our tests after successfully injecting the repository. First,
    we want to write a test for the `selectExistsEmail()` method. The possible test
    case for the method is that it should return `true` if the email exists in our
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: We have added an example user entity into our database in the example unit test.
    The `selectExistsEmail()` method is expected to return `true`. This should retrieve
    the added user with the given email.
  prefs: []
  type: TYPE_NORMAL
- en: The next test is for the `findByEmail()` method; this is almost similar to the
    test we have created for the `selectExistsEmail()` method. The only thing we need
    to modify is the assertion, as we are expecting a return value of the `User` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully written a test for our services and repository with JUnit,
    AssertJ, and the H2 database. In the next section, we will use the second implementation
    on writing unit tests using JUnit and AssertJ with Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests in a service using Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created our unit tests using the H2 database; in
    this approach, we will completely omit the use of the database and utilize the
    concept of mocking in creating sample data in our unit tests. We will achieve
    this by using **Mockito**. Mockito is a mocking framework in Java that allows
    us to test classes in isolation; it does not require any databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will enable us to return dummy data from a mocked object or service. Mockito
    is very useful, as this makes unit testing less complex, especially for larger
    applications, as we don’t want to test the services and dependencies simultaneously.
    The following are the other benefits of using Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supports return values**: Supports mocking return values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports exceptions**: Can handle exceptions in unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports annotation**: Can create mocks using annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe from refactoring**: Renaming method names or changing the order of parameters
    will not affect the tests, as mocks are created at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the different features of Mockito for writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mockito contains the `when()` method where we can mock the object return value.
    This is one of the most valuable features of Mockito, as we can define a dummy
    return value of a service or a repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have mocked `HeroService`
    in our test. We have done this to isolate the class and not test the functionality
    of `Heroservice` itself; what we want to test is just the functionality of `HeroApp`.
    We have added behavior for the `heroService.getHouse()` method by specifying a
    mock return `thenReturn()` method. In this case, we expect that the `getHouse()`
    method will return a value of `"``San Francisco"`.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next feature that we can use from Mockito is behavior verification in unit
    tests. This allows us to verify whether the mocked method is called and executed
    with parameters. This can be achieved using the `verify()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the same class example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have added `verify(heroService).getHouse()`
    to our code. This validates whether we have called the `getHouse()` method. We
    can also validate whether the method is called with some given parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`times(n)` method. At the same time, we can also validate whether it has been
    called using the `never()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have used the `times(2)` method
    to validate whether the `getName()` method from `heroService` has been called
    two times. We have also used the `never()` method, which checks that the `getPowers()`
    method has not been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mockito, other than `times()` and `never()`, also provides additional methods
    to validate the expected call counts, and these methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`atLeast (int min)`: Validates whether the method is called at least *n* times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeastOnce ()`: Validates whether the method is called at least once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atMost (int max)`: Validates whether the method is called at most *n* times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mockito also provides exception handling in unit tests; it allows us to throw
    exceptions on mocks to test errors in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have configured `heroService.getHouse()`, once
    it is called, to throw `RunTimeException`. This will allows us to test and cover
    the error blocks in our application.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the different features available in Mockito. Now, let’s
    proceed with writing our tests in our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito in Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will now implement Mockito for writing unit tests in our
    Spring Boot application. We will be writing tests for our service again, and we
    will create another package under our `test/java` folder, which will be used for
    our unit tests using Mockito; we will make `com.example.springbootsuperheroes.superheroes.antiHero.service`.
    Under the newly created package, we will create a new class named `AntiHeroServiceTest`,
    where we will start writing our tests for `AntiHeroService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating our class, we will need to annotate the class with
    `@ExtendWith(MockitoExtension.class)` to be able to use the Mockito methods and
    features. The next step is to mock our `AntiHeroRepository` and inject it into
    our `AntiHeroRepositoryService`. To accomplish this, we would use the `@Mock`
    annotation with the declared repository and the `@InjectMocks` annotation with
    the declared service, and our class would now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we successfully mocked our repository and injected
    it into our service. We can now start mocking our repository’s return values and
    behavior in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have some example tests in our `AntiHeroService`; in an example scenario,
    we will write a test for the `addAntiHero()` method. The possible test case for
    this one is to verify whether the `save()` method from the repository is called
    and the anti-hero is successfully added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the example code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first step is always to create a sample entity
    that we can use as a parameter for adding a new anti-hero; after invoking the
    `addAntiHero()` method that we are testing, we have verified whether the `save()`
    method of `AntiHeroRepository` has been invoked using the `verify()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used `ArgumentCaptor` to capture the argument values we have used
    in the previous way, which will be used for further assertions. In this case,
    we have asserted that the captured anti-hero is equal to the anti-hero instance
    we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned; you have learned about the concepts of JUnit,
    which is a testing framework that offers features such as fixtures, test suites,
    and classes to test the methods in our application. You have also learned about
    the application of AssertJ with JUnit, which provides a more flexible way of asserting
    objects in our unit tests; and lastly, you have also learned about the importance
    of Mockito, which provides us with the ability to mock objects and services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will now develop our frontend application using Angular.
    We will discuss how to organize our features and modules, structure our components
    inside our Angular file structure, and add Angular Material to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Frontend Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part contains a real-world scenario of developing an Angular 13 application.
    The following chapters are covered in this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18159_10.xhtml#_idTextAnchor188), *Setting Up Our Angular Project
    and Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18159_11.xhtml#_idTextAnchor203), *Building Reactive Forms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18159_12.xhtml#_idTextAnchor224), *Managing States with NgRx*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18159_13.xhtml#_idTextAnchor253), *Saving, Deleting, and Updating
    with NgRx*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18159_14.xhtml#_idTextAnchor275), *Adding Authentication in
    Angular*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18159_15.xhtml#_idTextAnchor293), *Writing Tests in Angular*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
