- en: Chapter 4. The Undertow Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at how to configure Undertow, the web
    server shipped with WildFly 8\. This will complete our overview of the standalone
    server configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at the structure of a typical enterprise application by creating,
    packaging, and deploying a sample Java EE 7 project. It will include JavaServer
    Faces components, Enterprise JavaBeans, and CDI, and will also use the **Java
    Persistence API** (**JPA**). This will give you a feel of working with a complete
    Java EE 7 application.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of Undertow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Undertow host configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The servlet container configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSP configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of session cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a simple web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Undertow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those of you who have worked with previous versions of WildFly will know that
    historically, JBoss has always included Tomcat, or a fork of Tomcat (named JBoss
    Web), as the application server's web container.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to replace JBoss Web came about as a new web container was required,
    one that supports new Java EE 7 requirements, such as web sockets and an HTTP
    upgrade. It was also decided that the new web server should be lightweight and
    flexible, and have better performance. The resulting server is super responsive,
    can scale to over a million connections, and has exceptional throughput.
  prefs: []
  type: TYPE_NORMAL
- en: The Undertow architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Undertow is written in Java and based on the **Non-blocking Input/Output** API
    (often referred to as **New Input/Output** or just **NIO**). With a composition-based
    architecture and built using a fluent builder API, Undertow can be easily configured,
    giving you as much or as little functionality as you need. By chaining handlers
    together, you can build anything from a simple HTTP handler to a full Java EE
    3.1 container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three core parts that make up the Undertow server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XNIO worker instances**: These instances form a thin abstraction layer over
    Java NIO, providing a channel API, management of IO and worker threads, and SSL
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listeners**: These handle incoming connections and the underlying protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlers**: These are chained together to provide the main functionality
    for Undertow. They define how incoming requests are handled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how these components fit together to create the
    web server, and demonstrates how the handlers are chained together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Undertow architecture](img/6232OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Undertow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to look at how to configure the different components
    of Undertow. Undertow is configured within the Undertow subsystem found in the
    `standalone.xml` file. Here''s an extract from the Undertow subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The majority of the Undertow web server is configured within the `server` and
    `servlet-container` elements, both of which we are going to look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the `server` element, you can configure hosts and listeners. The attributes
    to configure your main server instance are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `default-host` | This is the virtual host to be used if a request has a no
    host header |'
  prefs: []
  type: TYPE_TB
- en: '| `servlet-container` | This is the servlet container to be used, as configured
    in the `servlet-container` element |'
  prefs: []
  type: TYPE_TB
- en: Configuring the listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we stated earlier, Undertow is made up of listeners and handlers. The listeners
    are configured within the `server` element, as highlighted in the following code.
    The default configuration in the `standalone.xml` file has just a single connector
    defined, which is the HTTP connector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `socket-binding` attribute points to a configuration defined
    in the `socket-binding-group` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WildFly also supports AJP and HTTPS connection protocols; we will cover these
    in detail in [Chapter 9](ch09.html "Chapter 9. Load-balancing Web Applications"),
    *Load-balancing Web Applications* and [Chapter 10](ch10.html "Chapter 10. Securing
    WildFly"), *Securing WildFly*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of options when it comes to the configuration of the listener.
    The attributes for the HTTP listener element are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `allow-encoded-slash` | When set to true, this property allows the server
    to decode percent-encoded slash characters (%2F). Only enable this option if you
    have a legacy application that requires it, as it can have security implications
    due to different servers interpreting the slash differently. | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `always-set-keep-alive` | This property determines whether the `Connection:
    keep-alive` header should be added to all responses, even if not required by spec.
    | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `buffer-pipelined-data` | This property determines whether responses to HTTP
    pipelined requests should be buffered and sent out in a single write. This can
    improve performance if the HTTP pipelining is in use and responses are small.
    | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `buffer-pool` | This property references a buffer pool as defined in the
    I/O subsystem, which is used internally to read and write requests. In general,
    these should be at least 8 KB, unless you are in a memory-constrained environment.
    | `default` |'
  prefs: []
  type: TYPE_TB
- en: '| `certificate-forwarding` | If this property is enabled, then the listener
    will take the certificate from the `SSL_CLIENT_CERT` attribute. This property
    should only be enabled if the client is behind a proxy and the proxy is configured
    to always set these headers. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `decode-url` | This property determines whether the URL should be decoded.
    If this property is set to `false`, the percent-encoded characters in the URL
    will be left as is. | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `enabled` | This property states whether this listener is enabled | `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `max-cookies` | This property defines the maximum number of cookies allowed.
    If a client sends more cookies than this value, the connection will be closed.
    This exists to prevent DOS attacks based on hash collision. | `200` |'
  prefs: []
  type: TYPE_TB
- en: '| `max-header-size` | This property defines the maximum allowed HTTP header
    block size in bytes. Any request header with a value greater than this will be
    closed. | `5120` |'
  prefs: []
  type: TYPE_TB
- en: '| `max-headers` | This property defines the maximum number of headers allowed.
    It exists to prevent DOS attacks based on hash collision. | `200` |'
  prefs: []
  type: TYPE_TB
- en: '| `max-parameters` | This property defines the maximum number of query or path
    parameters allowed. If more parameters are sent, the connection will be closed.
    It exists to prevent DOS attacks based on hash collision. | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `max-post-size` | This property defines the maximum size allowed for incoming
    post requests. | `0` (unlimited) |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | This property defines the name given to the listener. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `proxy-address-forwarding` | This property enables `x-forwarded-host` and
    similar headers and sets a remote IP address and hostname. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect-socket` | This property, when enabled, automatically redirects
    a request to the specified socket binding port if the listener supports non-SSL
    requests and a request is received for which a matching security constraint requires
    SSL transport. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `socket-binding` | This property determines the address and port the listener
    listens on. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `url-charset` | This property defines the charset to decode the URL to. |
    `UTF-8` |'
  prefs: []
  type: TYPE_TB
- en: '| `worker` | This property references an XNIO worker as defined in the IO subsystem.
    The worker that is in use controls the IO and blocking thread pool. | `default`
    |'
  prefs: []
  type: TYPE_TB
- en: Configuring the host
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The host configuration within the `server` element corresponds to a virtual
    host and is nested directly under the `server` element, as shown in the following
    code. Virtual hosts allow you to group web applications according to the DNS names
    by which a machine running WildFly is known.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements nested within the host are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`location`: This element defines the URL path to the content, such as `welcome-content`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access-log`: This element allows you to configure the location and format
    of the access log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter-ref`: This element defines the filters that are applied to the current
    host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single-sign-on`: This element allows you to configure the cookies to use for
    authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The access log can be fully configured by changing the default attributes,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter-ref` element states the filters applied by referencing the name
    of the filters defined in the `filters` element, as shown in the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Serving static content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may not want to deploy all your static content with your application. These
    may be images, PDF documents, or other types of files. You can configure Undertow
    to look for these files on the local filesystem. This example shows you how to
    do this by adding a file handler and location to the Undertow subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this additional configuration, any request for resources to `www.yourdomain.com/contextroot/img`
    will be redirected to the filesystem on your hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the servlet container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An instance of a servlet container is defined within a single `servlet-container`
    element. You can have more than one `servlet-container` element if you wish to
    have multiple servlet containers; however, for most setups, a single instance
    will suffice. The default configuration in `standalone.xml` is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An explanation of the attributes available for the `servlet-container` are
    detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `allow-non-standard-wrappers` | This property relaxes the servlet specification,
    which requires applications to only wrap the request/response with wrapper classes
    that extend the `ServletRequestWrapper` and `ServletResponseWrapper` classes.
    | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `default-buffer-cache` | This is the buffer cache used to cache static resources
    in the default servlet. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `default-encoding` | This is the default encoding for the requests and responses.
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `eager-filter-initialization` | By setting this property to `true`, the init
    method of filters defined in your `web.xml` file are called upon the first request,
    and not on server startup. | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore-flush` | This ignores flushes on the servlet output stream. | `false`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stack-trace-on-error` | The available options for this property are `all`,
    `none`, or `local-only`. The `all` value will display all traces (should not be
    used in a production environment), while `none` means stack traces are not shown,
    and `local-only` means only requests from local addresses are shown and there
    are no headers to indicate that the request has been proxied. This feature uses
    the Undertow error page rather than the default error page specified in `web.xml`.
    | `local-only` |'
  prefs: []
  type: TYPE_TB
- en: '| `use-listener-encoding` | This uses the default encoding used by the listener
    that received the request. | `false` |'
  prefs: []
  type: TYPE_TB
- en: Several child elements can be added to the `servlet-container` element, which
    will allow you to configure your JSPs, session cookies, and persistent sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JSP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JSP element is provided in the default configuration. As no additional
    attributes are added, the default configuration is applied, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the session cookie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will probably be interested in configuring the Undertow session cookie.
    By default, there is no configuration text included in the `standalone.xml` file,
    so you will need to add it as a child element of the `servlet-container` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The possible attributes for the `session-cookie` element are shown in the following
    table. If you do not set these values explicitly, no value will be set, as there
    are no defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | This property defines the name of a cookie |   |'
  prefs: []
  type: TYPE_TB
- en: '| `domain` | This property defines the cookie domain |   |'
  prefs: []
  type: TYPE_TB
- en: '| `comment` | This property defines the cookie comment |   |'
  prefs: []
  type: TYPE_TB
- en: '| `http-only` | This property determines whether the cookie is HTTP-only |
    `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `secure` | This property determines whether the cookie is marked as secure
    | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `max-age` | This property defines the maximum age of a cookie (in minutes)
    | `0` (infinite) |'
  prefs: []
  type: TYPE_TB
- en: Saving the session state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saving sessions allows session data to be stored when the server is restarted
    or the application is redeployed. To enable this, you need to add the `persistent-sessions`
    element to the configuration file, as shown in the following code. This property
    should be used in your development environment rather than in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not specify the `path` variable, then the session will only be persistent
    across redeploys and not across server restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the buffer cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The buffer cache is used to cache content, for example, static files. A buffer
    cache consists of one or more regions, and each region is split into smaller buffers.
    Here''s an example configuration of the `buffer-cache` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The total cache size can be calculated by multiplying the buffer size by the
    buffers per region and the maximum number of regions. In our example, it would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1024 bytes * 2048 * 10 = 20971520 bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the application server provides a relatively straightforward
    way to configure the web container. In order to build and deploy a web application,
    it would be good for you to learn how to organize an application along with its
    specific configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly 8 is a Java EE 7 compliant application server and thus, can be used
    to deploy a wide range of web applications. One way of building a web application
    is to use the **JavaServer Faces** (**JSF**) technology, which is an evolution
    of the JSP technology. It is also part of Enterprise Java, meaning that WildFly
    supports it out of the box. WildFly 8 supports the JSF release 2.2 using the Mojarra
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of this example is to show you how to create, configure, and deploy
    a Java EE 7 application on WildFly 8\. If you want to learn more about the various
    Java EE 7 technologies, you should check out the many Java EE 7 examples created
    by Arun Gupta, which have been configured specifically for WildFly. The GitHub
    URL is [https://github.com/javaee-samples/javaee7-samples](https://github.com/javaee-samples/javaee7-samples).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to create a simple application. The purpose of this is to
    demonstrate how to configure each of the various enterprise components found within
    a typical enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Maven web project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways in which you can create a web application project using
    Eclipse. Since Maven is the de facto build tool, it makes sense to use the Maven
    project structure in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the project file structure. Go to **File** | **New**
    | **Maven Project**, select **skip archetype selection**, create a simple project,
    and proceed to the next page. Then, complete the artifact details as shown in
    the following screenshot, ensuring that you select **war** as the packaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new Maven web project](img/6232OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on **Finish**, Eclipse will generate a default folder structure
    for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new Maven web project](img/6232OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to use JSF to create the view. Configuring the JSF 2.2 web application
    requires very little effort. You can achieve this with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `web.xml` and place it in the `WEB-INF` folder of your
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `FacesServlet` to your `web.xml` file and specify what kind of URL patterns
    will be directed to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `faces-config.xml` file and place it in the `WEB-INF` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FacesServlet` is a servlet that manages the request processing life cycle
    for web applications that are utilizing JavaServer Faces to construct the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete `web.xml` file. You can see that we specified the URL
    patterns that the `FacesServlet` will process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you see a minimal JSF configuration file named `faces-config.xml`, which
    will be placed in the `WEB-INF` folder of your application. This file declares
    the JSF release that we are going to use, which in our case, is 2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Eclipse can create these configuration files for you. To do this, you will need
    to activate the **JavaServer** **Faces** **Facets**. Right-click on your project
    and select **Project** **Properties**. Here, you will find a set of configuration
    options that can be automatically added to your project under the **Project**
    **Facets** option. You may need to modify the files to ensure that the correct
    namespaces are used, and update the content of the `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to add the project dependencies to the Maven configuration
    file, the `pom.xml` file. Maven will then download and manage all your dependencies
    for you upon a project build. The complete content of `pom.xml` is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that the JBoss Nexus repository is being used rather than Maven
    Central. This is because since Java EE 6, JBoss has hosted its own EE API. The
    motivation for this was the unimplemented methods in Java EE 6\. To understand
    the full motivation, navigate to [https://developer.jboss.org/blogs/donnamishelly/2011/04/29/jboss-java-ee-api-specs-project](https://developer.jboss.org/blogs/donnamishelly/2011/04/29/jboss-java-ee-api-specs-project).
    I would recommend that you use the version hosted by JBoss, as it is identical
    to the code shipped with WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JSF components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of learning how to package a Java EE 7 application, we will
    show you how to combine JSF components, such as JSF views with Enterprise components
    like CDI and EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a simple caching system that uses an EJB singleton
    to handle the cache in memory. Then, we show you how to persist data to a database.
    Let''s start by adding a page named `index.xhtml` to your dynamic web project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn about JSF, please refer to the online tutorial at [http://docs.oracle.com/javaee/7/tutorial/doc/jsf-intro.htm](http://docs.oracle.com/javaee/7/tutorial/doc/jsf-intro.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The following code references a backing bean named `manager`, which is used
    to store and retrieve key/value pairs. Backing beans are simple Java classes which
    are used as models for UI components. You will also notice the `@RequestScoped`
    annotation in the `PropertyManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining the scope of a backing bean, you should only use the `javax.faces.bean.RequestScoped`
    annotation if you are not using CDI, which is highly unlikely. Instead, you should
    use the annotations found in the `javax.enterprise.context.*` package, which is
    part of the Context and Dependency Injection framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how to code the `PropertyManager` managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The most important part of this class is the `@Named` annotation. Annotating
    the class with `@Named` allows this class to be picked up as a CDI managed bean.
    The name passed into the annotation defines how this bean can be referenced via
    the Expression Language (EL). Next, the `@EJB` annotation is used to inject the
    `SingletonBean` into the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find out more about JSF managed beans at the Java EE tutorial here:
    [http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm](http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the EJB layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SingletonBean` is an EJB, which is marked with the special `@javax.ejb.Singleton`
    annotation. A class with such an annotation is guaranteed to be instantiated only
    once per application, and exists for the life cycle of the application. In the
    Java EE context, singleton beans are primarily used to store application-wide
    shared data. Now, we need to create a new class named `SingletonBean`. The aim
    of this class will be to save and retrieve key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last class we need to add is `Property`, which is a plain `JavaBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you reach this point, you should have a project containing the items shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the EJB layer](img/6232OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing the web context of the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, a web application inherits the web context name from the archive
    name, which is deployed on the application server. Maven uses the artifact ID,
    followed by the version to name the archive. So, in our example, if we deploy
    an archive named `chapter4-0.0.1-SNAPSHOT.war`, it will be accessible using the
    web context name `chapter4-0.0.1-SNAPSHOT`, as shown by the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing the web context of the application](img/6232OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The context name can be modified to something more meaningful. The simplest
    way to achieve this (without changing the archive name) is by adding a `jboss-web.xml`
    file to the `WEB-INF` folder of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing the web context of the application](img/6232OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The content of this file will include the custom web context, as specified
    by the `context-root` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are happy with your settings, you can deploy and verify your application.
    If you are deploying your application from within Eclipse, just right-click on
    the WildFly Runtime Server and choose the **Add** **and** **Remove** option (assuming
    you installed the WildFly runtime as shown in [Chapter 1](ch01.html "Chapter 1. Installing
    WildFly"), *Installing WildFly*). Next, add the web project to the list of deployed
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then deploy the application by right-clicking on the project and choosing
    **Full** **Publish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the web application](img/6232OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After publishing your application, you will notice that Eclipse will copy your
    web application archive (`chapter4-0.0.1-SNAPSHOT.war`) to the server. It will
    also create a file named `chapter4-0.0.1-SNAPSHOT.war.dodeploy`. As you will learn
    in [Chapter 6](ch06.html "Chapter 6. Application Structure and Deployment"), *Application
    Structure and Deployment*, expanded archives, by default, require a marker file
    in WildFly to trigger the deployment. Eclipse is aware of this and creates the
    file for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon successful deployment, the `chapter4-0.0.1-SNAPSHOT.war.dodeploy` file
    will be replaced by a `chapter4-0.0.1-SNAPSHOT.war.deployed` marker file, which
    indicates that you have successfully deployed the web application. You can verify
    that your application works correctly by pointing to the `index.xhtml` page at
    `http://localhost:8080/chapter4/index.xhtml`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying the web application](img/6232OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying a web application to the root context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our example, we have shown how to deploy the web application to a custom
    context using `jboss-web.xml`. One particular case of web context is the `root`
    context. This typically resolves to `http://localhost:8080` and is used to provide
    some welcome context by the web server. By default, WildFly has a root context
    that is mapped in the `JBOSS_HOME/welcome-content` folder. You can, however, override
    it by deploying one of your applications to the `root` context. This requires
    two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to remove the following line from your Undertow subsystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in your application, add a `jboss-web.xml` file that contains the `root`
    context for your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding a remote EJB client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before adding any code for the remote EJB client, we need to add two dependencies
    to `pom.xml`. This ensures that our code will compile and run without errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test our application with a remote client, we need to create a
    remote interface to the EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The concrete implementation of this interface is the `SingletonBeanRemoteImpl`
    class, which has the same Java method implementations as the `SingletonBean` class
    that we showed in the earlier section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'EJB remote invocation happens through the **Remoting** framework, which uses
    **Simple** **Authentication** **and** **Security** **Layer** (**SASL**) for client-server
    authentication. You need to explicitly set the security provider by adding the
    following specification to the test client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is quite tricky. We need to determine the **Java Naming and Directory
    Interface** (**JNDI**) name of the EJB, for which we will need to look up the
    remote EJB. The JNDI name varies depending on whether the EJB is stateful or stateless.
    The following table outlines the syntax for both SLSBs and SFSBs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| EJB type | JNDI syntax |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Stateless EJB | `ejb:<app-name>/<module-name>/<distinct-name>/<bean-name>!<fully-qualified-classname-of-the-remote-interface>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Stateful EJB | `ejb:<app-name>/<module-name>/<distinct-name>/<bean-name>!<fully-qualified-classname-of-the-remote-interface>?stateful`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following table bisects each of these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app-name` | This is the application name and is used in the event that the
    application has been deployed as an Enterprise archive. It typically corresponds
    to the Enterprise archive name without `.ear`. Since we packed our application
    in a web archive, this parameter will not be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `module-name` | This is the module within which the EJBs are contained. Since
    we deployed the application in a file named `chapter4-0.0.1-SNAPSHOT.war`, it
    corresponds to `chapter4-0.0.1-SNAPSHOT`. |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct-name` | This is an optional name that can be assigned to distinguish
    between different EJB implementations. It''s not used in our example. |'
  prefs: []
  type: TYPE_TB
- en: '| `bean-name` | This is the EJB name, which, by default, is the class name
    of the bean implementation class, in our case, `SingletonBeanRemoteImpl`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fully-qualified-classname-of-the-remote-interface` | This obviously corresponds
    to the fully qualified class name of the interface you are looking up, in our
    case, `com.packtpub.chapter4.ejb.SingletonBeanRemote`. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please notice that stateful EJBs require an additional `?stateful` parameter
    to be added to the JNDI lookup name.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information on the JNDI namespace, you will be ready to understand
    the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the major complexity of the remote EJB client code is related
    to the JNDI lookup section. You might have noticed that in the highlighted section,
    we initialized the JNDI context with a property named `Context.URL_PKG_PREFIXES`
    to specify the list of package prefixes to be used when loading URL context factories.
    In our case, we set it to `org.jboss.ejb.client.naming` so that the JNDI API knows
    which classes are in charge of handling the `ejb:` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the client using a properties file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, you might wonder how the client actually knows the server location
    where the remote EJBs are hosted. This can be solved by adding the following client-side
    property file named `jboss-ejb-client.properties` to the client classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Within this file, you can specify a set of properties prefixed by `remote.connectionprovider.create.options`,
    which will be used during the remote connection. In our example, we just set the
    `org.xnio.Options.SSL_ENABLED` property to `false`, which means that a clear text
    transmission will be used to connect the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: The `remote.connections` property is used to specify a set of one or more connections
    that map to an EJB receiver. In our case, there is a single remote connection
    named `default`, which maps to the `localhost` and the remoting port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to specify that an SASL anonymous connection will be used;
    otherwise, without an authentication, our connection will be refused.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the client programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to configure the client''s connection properties is to configure
    them programmatically. Here, we create a `Properties` object and populate it with
    the same key/value pairs that are in the `jboss-ejb-client.properties` configuration
    file. The important parts of the code are highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring data persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now further enhance our application by storing the key/value pairs in
    a relational database instead of keeping them in memory. To do this, we will need
    to create a **persistence** **context**. Again, let me remind you that its purpose
    is not to teach the theory behind data persistence, but rather to show how to
    configure it within your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persistence subsystem is included, by default, within all server configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The JPA module is not loaded by default in the application server. However,
    as soon as the application server detects that your application has `persistence.xml`
    or persistence annotations, the JPA module will be automatically started.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the JPA `persistence.xml` configuration file to our project,
    which will reference the data source used to map our entities to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The key attributes of this file are the persistence unit's `name`, which will
    identify its unique name, and the `jta-data-source`, which must match a valid
    datasource definition. In the earlier chapter, we defined this datasource bound
    to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `persistence.xml` file can specify either a JTA datasource or a non-JTA
    datasource. Within a Java EE environment, you have to use a JTA datasource (even
    when reading data without an active transaction).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `properties` element can contain any configuration property for
    the underlying persistence provider. Since WildFly uses Hibernate as the EJB persistence
    provider, you can pass any Hibernate options here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, this file needs to be placed in the `META-INF` folder of your
    `source/main/resources` folder, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring data persistence](img/6232OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The real path of the persistence.xml file**'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the content of the `Eclipse src/main/resources` directory will
    be placed in the `WEB-INF/classes` directory of your web application when Maven
    builds it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a default datasource for the JPA subsystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are referencing the datasource from within the `persistence.xml`
    file, thus following a canonical approach well-known to many developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, choose a default datasource for all your JPA applications
    by adding the `default-datasource` element into the JPA subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way, all JPA applications that haven't defined the `jta-data-source` element
    in `persistence.xml` will use the default datasource configured in the main server
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your persistence configuration is defined, the only change we need to
    make in our application is to add the `javax.persistence` annotations to our entity
    class. The `@Entity` annotation means that the class will be registered as a JPA
    entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our session bean needs to be changed, as well. Instead of reading and writing
    to the in-memory cache, we will write to both the cache and the database, and
    read only from the in-memory cache. When the application is restarted, the in-memory
    cache will be populated with data queried from the database. Although this is
    nothing fancy, for the sake of this demonstration, it is just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Sections of the preceding code have been highlighted to show you where the code
    has been modified to use data persistence. The most relevant section is the `@javax.persistence.PersistenceContext`
    annotation, which references a JPA context defined in the `persistence.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Once deployed, this application will persist data to your MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring persistence in other application archives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our example, we created a Java EE 7 application that is made of web components
    and EJBs using a single web application archive. This is absolutely fine and expected,
    as Java EE allows the mixing and matching of frontend components and server-side
    components within a single web archive.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, deploy an application where the web layer is separated from
    the business service layer. For example, suppose you were to deploy your entities
    in a separate JAR file; the correct place for the `persistence.xml` file would
    be beneath the `META-INF` folder of your JAR archive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To confirm, if you are placing your JPA entities inside a WAR file, the `persistence.xml`
    file should be placed in the `WEB-INF/classes/META-INF` folder. If you package
    your JPA entities within a JAR file inside a web application, you should place
    the `persistence.xml` file in the `META-INF` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically speaking, if you have multiple JAR files in your application, you
    can deploy the `persistence.xml` file in a single archive and refer to the persistence
    unit using the `jarName#unitName` notation. For example, this application''s persistence
    unit could be referenced from another JAR file using the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Switching to a different provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, WildFly 8.1 uses Hibernate 4.3.5 as a persistence provider. The
    Hibernate JARs are included under the `modules` folder in the `org.hibernate`
    path. If, however, your application requires a different version of Hibernate,
    such as 3.5, you can still bundle the JARs into your application by adding the
    dependency to your `pom.xml` file and setting the scope to `runtime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this, you need to set the `jboss.as.jpa.providerModule` property to
    `hibernate3-bundled` in your `persistence.xml` configuration file. The JPA deployer
    will detect the presence of a different version of the persistence provider and
    activate that version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using Jipijapa
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the Jipijapa project to simplify switching to a different
    JPA provider. If you use Jipijapa, you will need to ensure that your persistence
    provider is included as a runtime dependency in your `pom.xml` file, and you will
    also need to include the correct Jipijapa integration JAR file. To use Hibernate
    3, you will need to add the following dependency in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With Jipijapa, you can easily switch to a different version of Hibernate, or
    to a different ORM provider such as EclipseLink or OpenJPA. For more details on
    using the Jipijapa project, you can refer to the WildFly docs at [https://docs.jboss.org/author/display/WFLY8/JPA+Reference+Guide#JPAReferenceGuide-BackgroundontheJipijapaproject](https://docs.jboss.org/author/display/WFLY8/JPA+Reference+Guide#JPAReferenceGuide-BackgroundontheJipijapaproject).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Undertow subsystem configuration, which is
    found within the main configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Undertow server configuration is broken into two main parts: server configuration,
    which is used to configure static resources, such as HTML pages, images, listeners,
    and hosts, and the servlet container configuration, which is used to configure
    dynamic resources such as JSPs.'
  prefs: []
  type: TYPE_NORMAL
- en: We then went through an example application that demonstrated how to package
    and deploy a Java EE 7 web module on the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the JPA subsystem and showed you how to add data persistence
    to the initial example. We outlined the correct location of the `persistence.xml`
    file, which is required to be placed in the `WEB-INF/classes/META-INF` folder
    of your web application or in the `META-INF` folder of your JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the application server standalone configuration, we will now
    move on to the next chapter and look at how to configure application server domains.
  prefs: []
  type: TYPE_NORMAL
