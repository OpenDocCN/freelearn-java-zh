- en: The Publisher and Subscriber APIs in a Reactor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor中的发布者和订阅者API
- en: The previous chapter provided you with a brief introduction to the evolution
    of the reactive paradigm. In that chapter, we discussed how Reactive Streams enable
    us to perform reactive modeling in imperative languages, such as Java. We also
    discussed the key components in reactive—the publisher and subscriber. In this
    chapter, we will cover these two components in detail. Since Reactive Streams
    is a specification, it does not provide any implementations of the two components.
    It only lists the responsibilities of the individual components. It is left to
    implementation libraries, such as Reactor, to provide concrete implementations
    for the interfaces. Reactor also provides different methods for instantiating
    publisher and subscriber objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章为您简要介绍了反应范式的发展历程。在那章中，我们讨论了如何通过反应流在命令式语言（如Java）中执行反应式建模。我们还讨论了反应式中的关键组件——发布者和订阅者。在本章中，我们将详细介绍这两个组件。由于反应流是一个规范，它不提供这两个组件的实现。它只列出了各个组件的责任。具体实现留给实现库，如Reactor，为接口提供具体实现。Reactor还提供了不同的方法来实例化发布者和订阅者对象。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Comparing streams to existing Java APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将流与现有的Java API进行比较
- en: Understanding the Flux API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Flux API
- en: Understanding the Mono API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Mono API
- en: Building subscribers to Flux and Mono publishers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Flux和Mono发布者构建订阅者
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE, 2018.1 or above
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE，2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的GitHub链接为[https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02)。
- en: Stream publisher
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流发布者
- en: 'As we discussed in the previous chapter, the publisher is responsible for the
    generation of unbounded asynchronous events, and it pushes them to the associated
    subscribers. It is represented by the `org.reactivestreams.Publisher` interface,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中讨论的，发布者负责生成无界异步事件，并将它们推送到相关的订阅者。它由以下`org.reactivestreams.Publisher`接口表示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The interface provides a single `subscribe` method. The method is invoked by
    any party that is interested in listening to events published by the publisher.
    The interface is quite simple, and it can be used to publish any type of event,
    be it a UI event (like a mouse-click) or a data event.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口提供了一个单一的`subscribe`方法。该方法由任何有兴趣监听发布者发布的事件的任何一方调用。该接口非常简单，可以用来发布任何类型的事件，无论是UI事件（如鼠标点击）还是数据事件。
- en: 'Since the interface is simple, let''s add an implementation for our custom
    `FibonacciPublisher`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口很简单，让我们为我们的自定义`FibonacciPublisher`添加一个实现：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This implementation may look good, but does it comply to publisher behavior
    according to the specification? The specification prescribes rules that describe
    publisher behavior. A publisher must generate the following four types of events:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现看起来可能不错，但它是否符合规范中规定的发布者行为？规范规定了描述发布者行为的规则。发布者必须生成以下四种类型的事件：
- en: Subscription event
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅事件
- en: Data of type `T`, as declared by the publisher
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者声明的类型`T`的数据
- en: Completion event
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成事件
- en: Error event
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误事件
- en: According to the specification, a publisher can emit any number of data events.
    However, it must publish only one event for completion, error, and subscription.
    Once a completion or an error event is published, the publisher can no longer
    send data events back to a subscriber.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，发布者可以发出任意数量的数据事件。然而，它必须只发布一个完成、错误和订阅事件。一旦发布完成或错误事件，发布者就不能再向订阅者发送数据事件。
- en: As backpressure is an important aspect of the specification, a publisher cannot
    push an arbitrary number of events to a subscriber. Instead, the subscriber must
    specify how many events it can receive, and a publisher must publish events equal
    to, or less than, the specified number.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于背压是规范的重要方面，发布者不能向订阅者推送任意数量的事件。相反，订阅者必须指定它可以接收多少事件，发布者必须发布等于或小于指定数量的事件。
- en: 'In order to validate a publisher, the Reactive Streams API has published a
    test compatibility kit. Let''s add the `reactive-streams-tck` in the `build.gradle`
    to our project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证发布者，反应式流API已发布了一个测试兼容性套件。让我们将`reactive-streams-tck`添加到我们的`build.gradle`项目中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **Technology Compatibility Kit** (**TCK**) provides a `PublisherVerifier`
    interface that must be implemented in order to validate a publisher. It provides
    the following two methods:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术兼容性套件**（**TCK**）提供了一个必须实现的`PublisherVerifier`接口，以验证发布者。它提供了以下两个方法：'
- en: '`createPublisher(long)`: This method must provide an instance of the publisher
    that can produce the specified number of events'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createPublisher(long)`: 此方法必须提供一个发布者实例，该实例可以产生指定的数量的事件'
- en: '`createFailedPublisher()`: This method must try to build a publisher that has
    raised an error event'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createFailedPublisher()`: 此方法必须尝试构建一个已引发错误事件的发布者'
- en: 'Let''s add the following implementation to test our `FibonacciPublisher`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加以下实现来测试我们的`FibonacciPublisher`：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s run the test case to determine whether we comply with the Reactive
    Streams publisher specification:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行测试用例以确定我们是否符合反应式流发布者规范：
- en: '![](img/64bd8359-3a1e-4033-8489-59ddb5c94b89.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64bd8359-3a1e-4033-8489-59ddb5c94b89.png)'
- en: As shown in the preceding screenshot, there are around 20 test failures and
    16 skipped tests. We could fix each one of them, but the aim here is to understand
    that even a simple interface of a publisher is governed by many behavior specifications.
    Therefore, it is overkill to build a custom publisher. As service builders, we
    can use the Reactor framework. This provides publisher implementations capable
    of publishing any kind of data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，大约有20个测试失败和16个跳过的测试。我们可以修复每一个，但这里的目的是理解即使是一个简单的发布者接口也受到许多行为规范的约束。因此，构建自定义发布者是不必要的。作为服务构建者，我们可以使用Reactor框架。它提供了能够发布任何类型数据的发布者实现。
- en: Stream subscriber
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流订阅者
- en: 'A subscriber is used to listen to events generated by a publisher. When a subscriber
    registers to a publisher, it receives events in the following order:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者用于监听由发布者生成的事件。当订阅者向发布者注册时，它按以下顺序接收事件：
- en: '![](img/513711fa-108a-4652-8a8e-ced8dbefd186.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/513711fa-108a-4652-8a8e-ced8dbefd186.jpg)'
- en: 'As a result, the subscriber has the following interface to handle all of these
    events:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，订户有以下界面来处理所有这些事件：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s cover each of these methods in detail, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明以下每个方法：
- en: '`onSubscribe(Subscription s)`: As soon as a publisher has received a subscriber,
    it generates a subscription event. The generated subscription event is then received
    in the specified method.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe(Subscription s)`: 一旦发布者收到订阅者，它就会生成一个订阅事件。然后，生成的订阅事件在指定方法中接收。'
- en: '`onNext (T)`: All data events generated by a publisher are received by the
    subscriber in the specified method. A publisher may or may not publish a data
    event before closing the stream.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext (T)`: 所有由发布者生成并由订阅者在指定方法中接收的数据事件。发布者在关闭流之前可能发布也可能不发布数据事件。'
- en: '`onCompletion()`: This refers to the completion event, which must be handled
    by a subscriber. Once a completion event is received, the subscription is considered
    void.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCompletion()`: 这指的是完成事件，订阅者必须处理此事件。一旦收到完成事件，订阅就视为无效。'
- en: '`onError()`: This refers to the error event, which must be handled by a subscriber.
    An error can occur at any moment—while building a subscription or while generating
    the next data event. In any case, the publisher must send the error event. Once
    the event is received, the subscription is considered void.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError()`: 这指的是错误事件，订阅者必须处理此事件。错误可能在任何时候发生——在构建订阅或生成下一个数据事件时。在任何情况下，发布者都必须发送错误事件。一旦收到事件，订阅就视为无效。'
- en: Subscription
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅
- en: The subscription is an important component in Reactive Streams. It provides
    the necessary control flow, so that publishers do not over-run a subscriber. This
    is known as backpressure.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是反应式流中的一个重要组成部分。它提供了必要的控制流，以确保发布者不会使订阅者过载。这被称为背压。
- en: Once the subscriber receives the subscription event, it must request that the
    publisher publish a specified count of events over their respective subscription.
    This is done by invoking the `request(long)` method of the subscription object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦订阅者收到订阅事件，它必须要求发布者在其各自的订阅中发布指定数量的事件。这是通过调用订阅对象的`request(long)`方法来完成的。
- en: 'As data events are generated, they are received by the subscriber. Once the
    limit has been reached, the publisher must stop publishing more events. As the
    subscriber processes these events, it must request additional events from the
    publisher:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据事件的生成，它们会被订阅者接收。一旦达到限制，发布者必须停止发布更多事件。随着订阅者处理这些事件，它必须从发布者请求更多事件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The subscription object allows a subscriber to control the events it wants to
    receive. Whenever the subscriber determines that it no longer wants the events,
    it can invoke the `cancel()` method of the subscription. Once invoked, a subscriber
    may receive fewer data events, in accordance with the demand raised before the
    cancellation. Post-cancellation, the subscription will become void, meaning that
    it cannot be used to request additional data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅对象允许订阅者控制它想要接收的事件。每当订阅者确定它不再想要接收事件时，它可以调用订阅的`cancel()`方法。一旦调用，订阅者可能会接收更少的数据事件，这符合取消之前提出的需求。取消后，订阅将变为无效，这意味着它不能用来请求更多数据。
- en: A value of `Long.MaxValue` for the request method would result in an infinite
    flow of events from the publisher.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法的`Long.MaxValue`值会导致发布者产生无限的事件流。
- en: A subscriber can cancel an active subscription with the `onSubscribe()` method
    before any demand can be raised using the request method. In this case, the publisher
    will drop the subscription without raising any events.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可以在使用请求方法提出任何需求之前，使用`onSubscribe()`方法取消一个活跃的订阅。在这种情况下，发布者将取消订阅而不会引发任何事件。
- en: 'Now that we have gone over the subscriber interface in detail, we can try to
    build a `FibonacciSubscriber`, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了订阅者接口，我们可以尝试构建一个`FibonacciSubscriber`，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding implementation does the following things:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的代码执行以下操作：
- en: Upon receiving the subscription event, a request is raised to handle `10` events.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到订阅事件后，会发起一个请求来处理`10`个事件。
- en: When received, all data events are printed to the output console.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到数据事件时，所有事件都会打印到输出控制台。
- en: After processing a single event, the subscriber cancels the subscription.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理单个事件之后，订阅者取消订阅。
- en: The `onCompletion` method sets the subscription to `null`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onCompletion`方法将订阅设置为`null`。'
- en: The `onError` method prints the error message to the console and sets the subscription
    as `null`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onError`方法将错误信息打印到控制台并将订阅设置为`null`。'
- en: 'Now, let''s validate the subscriber by using the `SubscriberBlackboxVerification<T>`
    abstract class. We need to implement the `createSubsciber()` method, as shown
    in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`SubscriberBlackboxVerification<T>`抽象类来验证订阅者。我们需要实现`createSubscriber()`方法，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s run the test case to determine whether our subscriber meets the Reactive
    Streams criteria:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试用例以确定我们的订阅者是否符合Reactive Streams标准：
- en: '![](img/f3a2076d-7cf3-48bd-a595-41feec222b65.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3a2076d-7cf3-48bd-a595-41feec222b65.png)'
- en: Here, we can also find a large number of broken test cases. These broken test
    cases define the behavior for a subscriber. We could fix these, but the better
    option would be to use Reactor to create our services. In the following section,
    we will describe the publisher and subscriber implementations available in Reactor.
    These implementations conform to the specification behaviors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也可以找到大量的损坏测试用例。这些损坏的测试用例定义了订阅者的行为。我们可以修复这些用例，但更好的选择是使用Reactor来创建我们的服务。在下一节中，我们将描述Reactor中可用的发布者和订阅者实现。这些实现符合规范行为。
- en: Reactive Streams comparison
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactive Streams比较
- en: Before we jump into Reactor, let's compare the Streams model with some of the
    existing similar APIs, such as the `java.util.Observable` interface and the JMS
    API. We will try to determine the similarities and the key differences between
    the APIs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究Reactor之前，让我们比较Streams模型与一些现有的类似API，例如`java.util.Observable`接口和JMS API。我们将尝试确定API之间的相似之处和关键差异。
- en: The Observable interface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable接口
- en: 'The `java.util.Observable` interface implements the Observer pattern, which
    can be co-related here. However, all similarities end here. If we look at the
    `Observable` interface, we have the following methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Observable`接口实现了观察者模式，这在此处可以相关联。然而，所有相似之处到此为止。如果我们查看`Observable`接口，我们有以下方法：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s look at the `Observer` interface before we determine the differences:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确定差异之前，让我们看看`Observer`接口：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we look at the `Observable` and `Observer` interfaces, we can see that they
    are all about a single event and its state. The Observable API has the responsibility
    of determining a change and publishing it to all interested parties. On the other
    hand, the `Observer` only listens to the change. This is not what we are modeling
    with the `Publisher` and `Subscriber` interface. The `Publisher` interface is
    responsible for generating unbounded events, unlike the Observable, which is all
    about single entity state changes. The `Subscriber`, on the other hand, lists
    all kinds of events, such as data, error, and completion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Observable`和`Observer`接口，我们可以看到它们都是关于单个事件及其状态。`Observable` API负责确定变化并将其发布给所有感兴趣的一方。另一方面，`Observer`只监听变化。这并不是我们用`Publisher`和`Subscriber`接口建模的内容。`Publisher`接口负责生成无界事件，与只关注单一实体状态变化的`Observable`不同。另一方面，`Subscriber`列出了所有种类的事件，如数据、错误和完成。
- en: Furthermore, the `Observable` maintains an active list of observers. It has
    the responsibility of removing observers that are no longer interested in the
    event. This is not the same as the `Publisher`, which is only responsible for
    subscriptions. The `Subscriber` makes the decision to close the subscription,
    at its will.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Observable`维护一个活跃的观察者列表。它有责任移除不再对事件感兴趣的观察者。这不同于`Publisher`，`Publisher`只负责订阅。`Subscriber`决定是否关闭订阅，由其自行决定。
- en: Java Messaging Service API
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java消息服务API
- en: 'Let''s look at how Reactive Streams compares to the **Java Messaging Service
    (JMS)** API. The JMS specification describes a `Queue` and a `Topic`, to which
    a producer and a consumer can connect:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看响应式流与**Java消息服务（JMS）API**的比较。JMS规范描述了一个`Queue`和一个`Topic`，生产者和消费者可以连接到这些队列或主题：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the producer is responsible for generating unbounded events on the queue
    or topics, while the consumer actively consumes the events. The producer and consumer
    are working in isolation, at their own rates. The task of managing the subscription
    is taken care of by the JMS broker. This is different from the Subscription API,
    where backpressure plays a major role in event generation. There is also no event
    modeling, like subscription, error, or completion. The JMS connection is like
    a never-ending stream of data. It cannot provide completion or error events. If
    we need to support this, custom objects must be modeled first.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，生产者负责在队列或主题上生成无界事件，而消费者积极消费事件。生产者和消费者在各自的速率下独立工作。管理订阅的任务由JMS代理负责。这与订阅API不同，在事件生成中，背压起着重要作用。也没有像订阅、错误或完成这样的事件建模。JMS连接就像一个永不结束的数据流。它不能提供完成或错误事件。如果我们需要支持这一点，必须首先建模自定义对象。
- en: Learning about the Reactor Core API
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Reactor 核心API
- en: The Reactor project is divided into different modules. The `reactor-core` module
    is the central library, aimed at providing implementations for Reactive Streams.
    The library provides Flux and Mono, which are two different implementations of
    the `Publisher` interface. The two publishers are different in terms of the number
    of events that they can emit. Flux can emit infinite sequences of elements, but
    the Mono API makes it possible to emit a maximum of one element. Let's cover these
    APIs in detail, in the following sections.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 项目被划分为不同的模块。`reactor-core` 模块是核心库，旨在为响应式流提供实现。该库提供了Flux和Mono，它们是`Publisher`接口的两种不同实现。这两个发布者在其可以发出的事件数量方面有所不同。Flux可以发出无限序列的元素，但Mono
    API使得最多只能发出一个元素。让我们在接下来的章节中详细介绍这些API。
- en: The Flux API
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux API
- en: '`Flux<T>` is a general purpose reactive publisher. It represents a stream of
    asynchronous events with zero or more values, optionally terminated by either
    a completion signal or an error. It is important to note that a Flux emits the
    following three events:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux<T>`是一个通用响应式发布者。它表示一个异步事件流，包含零个或多个值，可选地由完成信号或错误终止。重要的是要注意，Flux发出以下三个事件：'
- en: '**Value** refers to the values generated by the publisher'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**指的是发布者生成的值'
- en: '**Completion** refers to a normal termination of the stream'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**指的是流的正常终止'
- en: '**Error** refers to an erroneous termination of the stream:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**指的是流的错误终止：'
- en: '![](img/0f8368f4-1139-401a-9893-4795107b1b22.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f8368f4-1139-401a-9893-4795107b1b22.jpg)'
- en: 'All of the preceding events are optional. This can lead to streams of the following
    types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述事件都是可选的。这可能导致以下类型的流：
- en: '**Infinite stream**: A publisher generating only value events, and no terminal
    events (completion and error)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限流**：仅生成值事件，没有终端事件（完成和错误）'
- en: '**Infinite empty stream**: A stream generating no value events and no terminating
    events'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限空流**：一个不生成值事件和不终止事件的流'
- en: '**Finite stream**: A publisher generating *N* finite values, followed by a
    terminal event'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限流**：生成 *N* 个有限值，然后是终端事件'
- en: '**Empty stream**: A publisher generating no value events, and only terminal
    events'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空流**：一个不生成值事件，只生成终端事件的发布者'
- en: Flux supports the generation of all preceding variations, so it can be used
    for most of the generic use cases. It can also generate sequences of alerts for
    an application. The alerts are an infinite stream of values, with no terminal.
    Flux can also be used to stream order data from an order database. The order values
    get terminated at the last order value. It may be the case that there are no orders
    for a particular product type, making the stream empty for that type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 支持生成所有前面的变体，因此它可以用于大多数通用用例。它还可以为应用程序生成一系列警报。警报是一个无限值的流，没有终端。Flux 还可以用于从订单数据库流式传输订单数据。订单值在最后一个订单值处终止。可能存在没有特定产品类型的订单，使得该类型的流为空。
- en: Generating the Flux API
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 Flux API
- en: The `Flux<T>` API supports stream generation from various sources, such as individual
    values, collections, Java 8 streams, and more. It can also be used to generate
    a stream from a custom logic, or from an existing reactive publisher. We will
    discuss all of these options in detail in upcoming sections.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux<T>` API 支持从各种来源生成流，例如单个值、集合、Java 8 流等。它还可以用于从自定义逻辑或现有的响应式发布者生成流。我们将在接下来的章节中详细讨论所有这些选项。'
- en: The Flux.just method
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux.just 方法
- en: 'This is the simplest method for Flux generation. It takes a set of values,
    such as `var-args`, and generates a finite Flux stream with them. Each of the
    values specified as `var-args` forms a value event of the Flux. A completion event
    is published after publishing all of the specified values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成 Flux 的最简单方法。它接受一组值，例如 `var-args`，并使用这些值生成一个有限的 Flux 流。指定的每个 `var-args`
    值形成一个 Flux 的值事件。在发布所有指定的值之后，发布一个完成事件：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Flux.from methods
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux.from 方法
- en: 'The `From` methods can be used to generate a Flux from various sources, such
    as arrays, collections, and so on. In this case, all of the values are identified
    as multi-valued datasets beforehand. The generated Flux publishes the value events
    for each value in the original dataset, followed by a completion event. The offered
    methods have the following variants:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`From` 方法可以用于从各种来源生成 Flux，例如数组、集合等。在这种情况下，所有值事先都被识别为多值数据集。生成的 Flux 为原始数据集中的每个值发布值事件，然后是一个完成事件。提供的方法有以下变体：'
- en: '`Flux.fromArray`: This is used to build a stream from an array of a type.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.fromArray`：这是用于从一个类型的数组构建流。'
- en: '`Flux.fromIterable`: This is used to build a stream from collections. All collections
    are of the `Iterable<T>` type, which can be passed to this to generate the intended
    stream.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.fromIterable`：这是用于从集合构建流。所有集合都是 `Iterable<T>` 类型，可以传递给此方法以生成预期的流。'
- en: '`Flux.fromStream`: This is used to build a Flux from an existing Java 8 stream
    or a Java 8 stream supplier. Consider the following code:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.fromStream`：这是用于从一个现有的 Java 8 流或 Java 8 流提供者构建 Flux。考虑以下代码：'
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Utility methods
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具方法
- en: 'Flux offers methods to generate infinite streams and empty streams, or to convert
    an existing Reactive Stream publisher to Flux. These methods are required to generate
    streams that can be combined with other streams, using the available operators,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 提供了生成无限流和空流的方法，或者将现有的响应式流发布者转换为 Flux。这些方法需要生成可以与其他流结合的流，如下所示：
- en: '`Flux.empty`: This method generates an empty stream with no values and only
    completion.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.empty`：此方法生成一个没有值且只有完成的空流。'
- en: '`Flux.error`: This method generates an error stream with no values and only
    specified errors.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.error`：此方法生成一个没有值且只有指定错误的错误流。'
- en: '`Flux.never`: This method generates a stream with no events at all. It does
    not generate events of any type.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.never`：此方法生成一个没有任何事件的流。它不生成任何类型的事件。'
- en: '`Flux.from`: This method takes an existing reactive publisher and generates
    a Flux from it.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.from`：此方法接受一个现有的响应式发布者，并从中生成一个 Flux。'
- en: '`Flux.defer`: This method is used to build a lazy reactive publisher. The method
    takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream
    publisher. The publisher instance is only generated when a subscriber makes a
    subscription to the Flux.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.defer`：此方法用于构建一个懒加载的响应式发布者。该方法接受一个 Java 8 供应商来实例化一个特定订阅的响应式流发布者。发布者实例仅在订阅者订阅
    Flux 时生成。'
- en: The Flux.generate method
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux.generate 方法
- en: Flux supports programmatic event generation. In the previous chapter, we used
    the API to generate Fibonacci events. This is an advanced usage method of the
    API, and it involves some more components. We will cover these in detail in the
    following sections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 支持程序化事件生成。在上一章中，我们使用了该 API 生成斐波那契事件。这是 API 的高级使用方法，涉及更多组件。我们将在以下部分中详细介绍这些内容。
- en: SynchronousSink
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SynchronousSink
- en: The sink gets bounded to a subscriber of the publisher. It gets invoked via
    the consumer function, when a subscriber asks for data. For each invocation, the
    sink can be used to generate a maximum of one value event at a time. The sink
    can raise additional `onCompletion` or error events during the invocation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该汇（sink）被绑定到发布者的订阅者。当订阅者请求数据时，通过消费者函数调用它。对于每次调用，汇（sink）可以一次生成最多一个值事件。在调用过程中，汇（sink）可以引发额外的
    `onCompletion` 或错误事件。
- en: 'It is important to note that the events generated by sink are synchronously
    consumed at the subscriber end. Let''s reflect on the Fibonacci test that we wrote
    in the previous chapter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，由汇（sink）生成的事件在订阅者端是同步消费的。让我们回顾一下我们在上一章中编写的斐波那契（Fibonacci）测试：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generating more that one event in the sink leads to `java.lang.IllegalStateException:
    More than one call to onNext`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '在汇（sink）中生成多于一个事件会导致 `java.lang.IllegalStateException: More than one call to
    onNext`。'
- en: 'We have added additional print statements while generating and consuming numbers.
    Let''s run our tests to see the output, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成和消费数字时，我们添加了额外的打印语句。让我们运行我们的测试以查看输出，如下所示：
- en: '![](img/1ae70d0b-1dc7-4672-9610-fd500cf07597.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ae70d0b-1dc7-4672-9610-fd500cf07597.png)'
- en: The consumer and producer statements are generated in an alternative manner.
    We can easily deduce that each number is consumed before the next number is generated.
    The Generate API is offered in multiple variants, and the sink can be used with
    or without an initial state. In our `FibonacciGenerator`, we used this with a
    state that is initialized on a per-subscriber basis. Optionally, we can also provide
    a terminal function, which gets invoked upon the termination of the events stream.
    This means that it will occur after the sink invokes an error or completion event.
    The terminal function can be used to perform any cleanup associated with the state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者和生产者语句以不同的方式生成。我们可以很容易地推断出每个数字在生成下一个数字之前被消费。Generate API 提供了多种变体，汇（sink）可以带或不带初始状态使用。在我们的
    `FibonacciGenerator` 中，我们使用的是基于每个订阅者的初始化状态。可选地，我们还可以提供一个终端函数，该函数在事件流终止时被调用。这意味着它将在汇（sink）调用错误或完成事件之后发生。终端函数可以用于执行与状态相关的任何清理操作。
- en: Flux.create
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux.create
- en: '`Flux.create` is another mechanism for generating events programmatically.
    It takes a `FluxSink`, which is capable of generating any number of events. The
    API is more generic than the `Generate` methods discussed in the previous section.
    The `FluxSink` is capable of generating events asynchronously. Moreover, it does
    not take subscription cancellation or backpressure into account. This means that
    even if the subscriber has cancelled its subscription, the create API will continue
    to generate events. All implementations must listen for the `cancel` event and
    explicitly initiate stream closure.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux.create` 是另一种用于程序化生成事件的机制。它接受一个 `FluxSink`，该 `FluxSink` 能够生成任意数量的事件。与上一节中讨论的
    `Generate` 方法相比，该 API 更加通用。`FluxSink` 能够异步生成事件。此外，它不考虑订阅取消或背压。这意味着即使订阅者已经取消了订阅，创建
    API 也会继续生成事件。所有实现都必须监听 `cancel` 事件并显式启动流关闭。'
- en: As for backpressure, the producer keeps generating the events without looking
    into any demand from the subscriber. These events are buffered and dropped by
    default if the subscription is lost.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于背压，生产者持续生成事件，而不考虑订阅者的任何需求。如果订阅丢失，这些事件将被缓冲并默认丢弃。
- en: 'To see how the two are different, let''s modify our `FibonacciGenerator` to
    use a `FluxSink`. Some of the key differences are highlighted as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这两个的不同之处，让我们修改我们的 `FibonacciGenerator` 以使用 `FluxSink`。以下是一些关键差异的突出显示：
- en: There is no initial seed state in the API
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 中没有初始种子状态
- en: The `FluxSink` keeps generating the events, irrespective of the subscription
    state
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FluxSink` 不论订阅状态如何，都会持续生成事件'
- en: We can generate any number of events in the sink
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在汇集中生成任意数量的事件
- en: The `OnDispose` event can be listened to in order to perform any cleanup, or
    to stop publishing events
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以监听 `OnDispose` 事件来执行任何清理操作，或者停止发布事件
- en: All events that are generated are buffered and dropped once the subscription
    is cancelled
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有生成的事件都会被缓冲，一旦取消订阅就会丢弃
- en: 'It is important to note that the `FluxSink` provides lifecycle callback methods,
    which can be used to perform additional cleanups, or any other action, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`FluxSink` 提供了生命周期回调方法，可以用来执行额外的清理操作，或者执行任何其他操作，如下所示：
- en: '`OnCancel`*:* This method gets invoked when the subscription is cancelled.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCancel`：当订阅被取消时，此方法被调用。'
- en: '`OnDispose`: This method gets invoked when the subscription is closed due to
    a cancel, close, or error event.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDispose`：当由于取消、关闭或错误事件关闭订阅时，此方法被调用。'
- en: '`OnRequest`: This method is invoked with the value specified by the subscriber.
    It can be used to build a pull data model. When the method is invoked, the next
    method can be invoked for the specified number of the values:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnRequest`：此方法使用订阅者指定的值调用。它可以用来构建拉数据模型。当方法被调用时，可以调用下一个方法来指定值的数量：'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s check the output that''s generated, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查生成的输出，如下所示：
- en: '![](img/8d554e76-906e-43f3-9558-95d0437731c1.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d554e76-906e-43f3-9558-95d0437731c1.png)'
- en: '`Flux` also provides a `Push` method. This is similar to the `create` method,
    but the process of how error and complete events are invoked varies. These events
    must be invoked in a synchronous manner, from a single thread producer.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux` 还提供了一个 `Push` 方法。这与 `create` 方法类似，但错误和完成事件的调用过程不同。这些事件必须以同步方式，从单个线程生产者调用。'
- en: The Mono API
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono API
- en: 'Now that we have covered the Flux API, let''s look at Mono. It is capable of
    generating a maximum of one event. This is a specific use case for Flux, capable
    of handling one response model, such as data aggregation, HTTP request-response,
    service invocation response, and so on. It is important to note that a Mono emits
    the following three events:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Flux API，让我们看看 Mono。它能够生成最多一个事件。这是 Flux 的一个特定用例，能够处理一个响应模型，例如数据聚合、HTTP
    请求-响应、服务调用响应等。需要注意的是，Mono 会发出以下三个事件：
- en: '**Value** refers to the single value generated by the publisher'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**指的是发布者生成的单个值'
- en: '**Completion** refers to a normal termination of the stream'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**指的是流的正常终止'
- en: '**Error** refers to an erroneous termination of the stream'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**指的是流的错误终止'
- en: '![](img/16f7f796-cf40-4de3-b977-6ef7876bb97b.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16f7f796-cf40-4de3-b977-6ef7876bb97b.jpg)'
- en: Since Mono is a subset of Flux, it supports a subset of Flux operators. Let's
    look at how to build a Mono.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Mono 是 Flux 的子集，它支持 Flux 操作符的子集。让我们看看如何构建一个 Mono。
- en: Generating a Mono
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个 Mono
- en: The `Mono<T>` API supports stream generation from various single-value sources,
    like individual values, method invocations, Java 8 supplier functions, and so
    on. It can also be used to generate a stream from a custom logic or from an existing
    reactive publisher. We will now discuss these in detail.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono<T>` API 支持从各种单值源生成流，如单个值、方法调用、Java 8 供应函数等。它还可以用于从自定义逻辑或现有响应式发布者生成流。我们现在将详细讨论这些。'
- en: The Mono.just method
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono.just 方法
- en: 'The `Mono.just` method is the simplest method for Mono generation. It takes
    a single value and generates a finite Mono stream from it. A completion event
    is published after publishing the specified value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono.just` 方法是生成 Mono 最简单的方法。它接受一个值，并从中生成一个有限的 Mono 流。在发布指定的值之后，会发布一个完成事件：'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Mono.from method
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono.from 方法
- en: 'The `From` methods are used to build a Flux when the value can be determined
    from an existing source. Unlike the Flux methods, where the sources are multi-valued,
    the sources for Mono are single-valued. These methods are offered in the following
    variants:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当值可以从现有源确定时，使用 `From` 方法来构建 Flux。与 Flux 方法不同，其中源是多值的，Mono 的源是单值的。这些方法提供了以下变体：
- en: '`fromCallable`: This method generates Mono with one value, followed by the
    completion event. If multi-valued datasets, like arrays or collections, are returned
    from `Callable`, then the complete dataset is pushed as an object in the single
    event.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromCallable`: 此方法生成一个包含一个值，随后是完成事件的 Mono。如果 `Callable` 返回多值数据集，如数组或集合，则完整的数据集将作为单个事件中的对象推送。'
- en: '`fromFuture`: This method generates Mono with one value, followed by the completion
    event.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFuture`: 此方法生成一个包含一个值，随后是完成事件的 Mono。'
- en: '`fromSupplier`: This method generates Mono with one value, followed by the
    completion event.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromSupplier`: 此方法生成一个包含一个值，随后是完成事件的 Mono。'
- en: '`fromRunnable`: This method generates Mono with no value and only a completion
    event. This can be explained by using the following code:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromRunnable`: 此方法生成一个没有值，只包含完成事件的 Mono。这可以通过以下代码解释：'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Utility methods
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具方法
- en: 'Mono offers methods to generate empty/error streams or to convert an existing
    Reactive Stream publisher to Mono. These methods are required to generate streams
    that can be combined with others by using the available operators, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Mono 提供了生成空/错误流或将现有的响应式流发布者转换为 Mono 的方法。这些方法需要生成可以与其他流通过可用运算符组合的流，如下所示：
- en: '`Mono.empty`: Generates a stream with no value and only a completion.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono.empty`：生成一个没有值，只包含完成事件的流。'
- en: '`Mono.error`*:* Generates a stream with no value and only a specified error.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono.error`：生成一个没有值，只包含指定错误的流。'
- en: '`Mono.never`: Generates a stream with no events at all. It does not generate
    an event of any type.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono.never`：生成一个没有任何事件的流。它不会生成任何类型的事件。'
- en: '`Mono.from`: Generates a Mono stream from an existing stream publisher.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono.from`: 从现有的流发布者生成 Mono 流。'
- en: '`Mono.defer`: This method is used to build a lazy reactive publisher. It also
    takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream
    publisher. The publisher instance is only generated when a subscriber makes a
    subscription to the Mono.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mono.defer`: 此方法用于构建一个懒加载的响应式发布者。它还接受一个 Java 8 供应商来实例化特定订阅的响应式流发布者。发布者实例仅在订阅者对
    Mono 进行订阅时生成。'
- en: 'It is important to note that a Mono can be generated by using a Flux source.
    In that case, Mono uses the first event published from the Flux, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可以使用 Flux 源生成 Mono。在这种情况下，Mono 使用 Flux 发布的第一个事件，如下所示：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Mono.create
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono.create
- en: In addition to the `Flux.create` methods, there is a `Mono.create` method. This
    method provides a `MonoSink`, which can be used to generate a value, completion,
    or error event. Unlike the Flux methods, where we are generating *N* events, if
    we generate more events in Mono, they are dropped. There is also no handling for
    backpressure, as there is only one event.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Flux.create` 方法外，还有一个 `Mono.create` 方法。此方法提供了一个 `MonoSink`，可以用来生成值、完成或错误事件。与
    Flux 方法不同，我们在生成 *N* 个事件，如果我们在 Mono 中生成更多事件，它们将被丢弃。也没有处理背压，因为只有一个事件。
- en: The API does not take subscription cancellations into account. This means that
    even if the subscriber has cancelled its subscription, the create method still
    generates its event. Implementors must register custom hooks to lifecycle events
    and perform stream closures.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: API 不考虑订阅取消。这意味着即使订阅者已取消其订阅，创建方法仍然生成其事件。实现者必须注册自定义钩子以处理生命周期事件并执行流关闭。
- en: Building subscribers to Flux and Mono
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Flux 和 Mono 的订阅者
- en: 'Reactor Flux and Mono provide a wide choice of subscribe methods. Reactive
    publishers raise four types of events, namely subscription, value, completion,
    and error. Individual functions can be registered for each of the events. We can
    also register a subscriber without listening to any kind of event. Let''s look
    at all of the possible variants offered, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor Flux 和 Mono 提供了广泛的订阅方法。响应式发布者引发四种类型的事件，即订阅、值、完成和错误。可以为每个事件注册单独的函数。我们还可以注册一个订阅者，而不监听任何类型的事件。让我们看看所有可能提供的变体，如下所示：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code shows all of the `Subscribe` methods:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了所有的 `Subscribe` 方法：
- en: No event is consumed, as shown in line `1`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如第 `1` 行所示，没有事件被消费。
- en: Only value events are consumed, as shown in line `2`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只消费值事件，如第 `2` 行所示。
- en: Along with value events, we also print error stack-trace, as shown in line `3`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了值事件外，我们还打印错误堆栈跟踪，如第 `3` 行所示。
- en: We can listen to value, error, and completion events, as shown in line `4`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以监听值、错误和完成事件，如第 `4` 行所示。
- en: We can listen to value, error, completion, and subscription events, as shown
    in line `5`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以监听值、错误、完成和订阅事件，如第 `5` 行所示。
- en: All `Subscribe` methods return a `Disposable` type. This type can also be used
    to cancel the subscription.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Subscribe` 方法都返回 `Disposable` 类型。此类型也可以用于取消订阅。
- en: 'At times, we may determine that the `Subscribe` methods are not good enough.
    We must create a custom subscriber with its own handling. Reactor provides a `reactor.core.publisher.BaseSubsciber<T>`
    for these situations. Instead of implementing the Reactive Stream `Subscriber`,
    reactor recommends implementing the `BaseSubscriber` abstract class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会认为 `Subscribe` 方法不够好。我们必须创建一个具有自己处理的自定义订阅者。Reactor 为这些情况提供了 `reactor.core.publisher.BaseSubscriber<T>`。而不是实现响应式流的
    `Subscriber`，Reactor 建议实现 `BaseSubscriber` 抽象类：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we look at the `BaseSubscriber` implementation, we will see the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `BaseSubscriber` 的实现，我们将看到以下内容：
- en: Each individual event can be handled in a separate hook method.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单独的事件都可以通过单独的钩子方法来处理。
- en: It captures the subscription and makes it accessible by using the upstream method.
    This method can be invoked in any lifecycle method.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它捕获订阅并使其通过上游方法可访问。此方法可以在任何生命周期方法中调用。
- en: It also handles backpressure by providing `request(long)` methods. The default
    method is to request values one by one. However, the subscriber can raise additional
    demands by using the `request` method.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还通过提供 `request(long)` 方法来处理背压。默认方法是逐个请求值。然而，订阅者可以通过使用 `request` 方法提出额外的需求。
- en: It also presents the `requestUnbound()` method, which disables backpressures.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还提供了 `requestUnbound()` 方法，该方法禁用背压。
- en: Once we have the custom subscriber, it can be invoked by using the `subscribe()`
    method, available with Flux and Mono.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了自定义订阅者，就可以使用 Flux 和 Mono 中的 `subscribe()` 方法来调用它。
- en: Lifecycle hooks
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期钩子
- en: 'The publisher-subscriber communication generates events throughout the lifecycle
    of a Reactive Stream. Reactor provides corresponding lifecycle methods that can
    be used to hook custom logic to each of the said events, as shown in the following
    table:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者-订阅者通信在整个响应式流的生命周期中生成事件。Reactor 提供了相应的生命周期方法，可以用来将自定义逻辑钩接到每个事件上，如下表所示：
- en: '| **Event** | **Method** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | **方法** |'
- en: '| Subscribe event | `doOnSubscribe` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 订阅事件 | `doOnSubscribe` |'
- en: '| Request event, for *N* items from the subscriber | `doOnRequest` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 请求事件，从订阅者请求 *N* 个项目 | `doOnRequest` |'
- en: '| Value event, for all generated values | `doOnNext` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 值事件，对于所有生成的值 | `doOnNext` |'
- en: '| Error event, for any error by the publisher | `doOnError` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 错误事件，由发布者产生的任何错误 | `doOnError` |'
- en: '| Completion event | `doOnCompletion` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 完成事件 | `doOnCompletion` |'
- en: '| Cancel event, for cancellation by the subscriber | `doOnCancel` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 取消事件，由订阅者取消 | `doOnCancel` |'
- en: 'In addition to the preceding methods, there are the following methods:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的方法之外，还有以下方法：
- en: '`doOnEach`: This method is executed for all publisher events raised in the
    stream processing.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach`：此方法在流处理中引发的所有发布者事件上执行。'
- en: '`doOnTerminate`: This method is executed for stream closure due to an error
    or completion. It does not take cancellation into account.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnTerminate`：此方法在由于错误或完成而关闭流时执行。它不考虑取消。'
- en: '`doFinally`: This method is executed for stream closures due to errors, completions,
    or cancellations.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFinally`：此方法在由于错误、完成或取消而关闭流时执行。'
- en: Trying a hands-on project
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一个动手项目
- en: 'Now that we have discussed Reactor interfaces in detail, let''s try to generate
    a factorial series using Reactor. Given a number, we want to generate a factorial
    of all numbers less than or equal to the provided number. In number theory, a
    factorial is described as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细讨论了 Reactor 接口，让我们尝试使用 Reactor 生成一个阶乘序列。给定一个数字，我们希望生成小于或等于提供的数字的所有数字的阶乘。在数论中，阶乘被描述如下：
- en: '"The factorial of a positive number ''n'' is defined as n! = n(n-1)(n-2)...2.1
    For example, 5 ! = 5 × 4 × 3 × 2 × 1 = 120."'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"正数 ''n'' 的阶乘定义为 n! = n(n-1)(n-2)...2.1 例如，5! = 5 × 4 × 3 × 2 × 1 = 120。"'
- en: 'Now, let''s try to build a factorial stream function that takes a number and
    attempts to generate a factorial for every number, from 0 to *N*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试构建一个阶乘流函数，它接受一个数字并尝试为从 0 到 *N* 的每个数字生成阶乘：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we performed the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行了以下操作：
- en: The initial `factorialNumber` was set to `0`, with the factorial as `1`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始的 `factorialNumber` 被设置为 `0`，阶乘为 `1`。
- en: We then checked whether the `factorialNumber` was less than or equal to the
    passed number, and published the factorial value for it.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查了 `factorialNumber` 是否小于或等于传入的数字，并为它发布了阶乘值。
- en: If `factorialNumber` is more than the passed number, then we publish the completion.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `factorialNumber` 大于传入的数字，则发布完成信号。
- en: We incremented the `factorialNumber` and computed the factorial for it.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们增加了 `factorialNumber` 并计算了它的阶乘。
- en: 'The preceding flow is quite simple, but it makes it possible to utilize various
    Flux components. Since the factorial service is ready, we need to validate it
    by subscribing to it. In the following test case, we do the following things:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 上述流程相当简单，但它使得利用各种 Flux 组件成为可能。由于阶乘服务已经就绪，我们需要通过订阅它来验证它。在下面的测试用例中，我们做以下事情：
- en: Invoke the generator for factorial numbers up to `10`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用生成阶乘数的生成器，直到 `10`。
- en: Display each generated number by using the `doOnNext()` lifecycle hook.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `doOnNext()` 生命周期钩子显示每个生成的数字。
- en: Use the `last()` operator to get the last value. We will cover operators in
    the next chapter.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `last()` 操作符来获取最后一个值。我们将在下一章介绍操作符。
- en: 'Compare and assert the value in the subscriber value event function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订阅者的值事件函数中比较和断言值：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s run the test case to view the output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行测试用例来查看输出：
- en: '![](img/c60ccc9f-5f0d-4172-ac28-11183fe94bb5.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c60ccc9f-5f0d-4172-ac28-11183fe94bb5.png)'
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided a detailed discussion of the publisher and the
    subscriber interfaces of Reactive Streams. We attempted to implement these interfaces
    to illustrate that there are many non-explicit rules for them. These rules have
    been converted into the Reactive Streams TCK, against which all implementations
    should be validated. We also compared the publisher-subscriber pattern with the
    existing Observer and JMS patterns used in Java. Next, we took a detailed look
    at the Flux and Mono implementations available in Reactor. We looked at methods
    for creating them, and then subscribed to the generated streams.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了 Reactive Streams 的发布者和订阅者接口。我们尝试实现这些接口来展示它们有许多非显式规则。这些规则已被转换为 Reactive
    Streams TCK，所有实现都应通过它进行验证。我们还比较了发布者-订阅者模式与 Java 中使用的现有 Observer 和 JMS 模式。接下来，我们详细研究了
    Reactor 中可用的 Flux 和 Mono 实现。我们研究了创建它们的方法，然后订阅了生成的流。
- en: In the next chapter, we will look at the operators that can be used to modify
    the generated streams.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可以用来修改生成的流的操作符。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we validate Reactive Stream publisher and subscriber implementations?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何验证 Reactive Stream 发布者和订阅者实现？
- en: How is the Reactive Stream publisher-subscriber model different from the JMS
    API?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactive Stream 发布者-订阅者模型与 JMS API 有何不同？
- en: How is the Reactive Stream publisher-subscriber model different from the Observer
    API?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactive Stream 发布者-订阅者模型与 Observer API 有何不同？
- en: What is the difference between Flux and Mono?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux 和 Mono 之间有什么区别？
- en: What is the difference between `SynchronousSink` and `FluxSink`?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SynchronousSink` 和 `FluxSink` 之间有什么区别？'
- en: What are the different lifecycle hooks available in Reactor?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor 中有哪些不同的生命周期钩子可用？
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the video under the Reactive Streams
    specification, as this is part of Java 9: [https://www.packtpub.com/application-development/reactive-java-9-video](https://www.packtpub.com/application-development/reactive-java-9-video)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅 Reactive Streams 规范下的视频，因为这部分是 Java 9 的内容：[https://www.packtpub.com/application-development/reactive-java-9-video](https://www.packtpub.com/application-development/reactive-java-9-video)
- en: 'To gain in-depth knowledge on building microservices using Akka as a Reactive
    Streams library, please refer to the following video: [https://www.packtpub.com/application-development/building-microservice-akka-http-video](https://www.packtpub.com/application-development/building-microservice-akka-http-video)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解使用 Akka 作为 Reactive Streams 库构建微服务的知识，请参阅以下视频：[https://www.packtpub.com/application-development/building-microservice-akka-http-video](https://www.packtpub.com/application-development/building-microservice-akka-http-video)
