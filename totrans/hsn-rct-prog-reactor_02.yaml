- en: The Publisher and Subscriber APIs in a Reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter provided you with a brief introduction to the evolution
    of the reactive paradigm. In that chapter, we discussed how Reactive Streams enable
    us to perform reactive modeling in imperative languages, such as Java. We also
    discussed the key components in reactive—the publisher and subscriber. In this
    chapter, we will cover these two components in detail. Since Reactive Streams
    is a specification, it does not provide any implementations of the two components.
    It only lists the responsibilities of the individual components. It is left to
    implementation libraries, such as Reactor, to provide concrete implementations
    for the interfaces. Reactor also provides different methods for instantiating
    publisher and subscriber objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing streams to existing Java APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Flux API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Mono API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building subscribers to Flux and Mono publishers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE, 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Stream publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the previous chapter, the publisher is responsible for the
    generation of unbounded asynchronous events, and it pushes them to the associated
    subscribers. It is represented by the `org.reactivestreams.Publisher` interface,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The interface provides a single `subscribe` method. The method is invoked by
    any party that is interested in listening to events published by the publisher.
    The interface is quite simple, and it can be used to publish any type of event,
    be it a UI event (like a mouse-click) or a data event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the interface is simple, let''s add an implementation for our custom
    `FibonacciPublisher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation may look good, but does it comply to publisher behavior
    according to the specification? The specification prescribes rules that describe
    publisher behavior. A publisher must generate the following four types of events:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscription event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data of type `T`, as declared by the publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completion event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the specification, a publisher can emit any number of data events.
    However, it must publish only one event for completion, error, and subscription.
    Once a completion or an error event is published, the publisher can no longer
    send data events back to a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: As backpressure is an important aspect of the specification, a publisher cannot
    push an arbitrary number of events to a subscriber. Instead, the subscriber must
    specify how many events it can receive, and a publisher must publish events equal
    to, or less than, the specified number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to validate a publisher, the Reactive Streams API has published a
    test compatibility kit. Let''s add the `reactive-streams-tck` in the `build.gradle`
    to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Technology Compatibility Kit** (**TCK**) provides a `PublisherVerifier`
    interface that must be implemented in order to validate a publisher. It provides
    the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createPublisher(long)`: This method must provide an instance of the publisher
    that can produce the specified number of events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createFailedPublisher()`: This method must try to build a publisher that has
    raised an error event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the following implementation to test our `FibonacciPublisher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the test case to determine whether we comply with the Reactive
    Streams publisher specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bd8359-3a1e-4033-8489-59ddb5c94b89.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, there are around 20 test failures and
    16 skipped tests. We could fix each one of them, but the aim here is to understand
    that even a simple interface of a publisher is governed by many behavior specifications.
    Therefore, it is overkill to build a custom publisher. As service builders, we
    can use the Reactor framework. This provides publisher implementations capable
    of publishing any kind of data.
  prefs: []
  type: TYPE_NORMAL
- en: Stream subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A subscriber is used to listen to events generated by a publisher. When a subscriber
    registers to a publisher, it receives events in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/513711fa-108a-4652-8a8e-ced8dbefd186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, the subscriber has the following interface to handle all of these
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s cover each of these methods in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onSubscribe(Subscription s)`: As soon as a publisher has received a subscriber,
    it generates a subscription event. The generated subscription event is then received
    in the specified method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext (T)`: All data events generated by a publisher are received by the
    subscriber in the specified method. A publisher may or may not publish a data
    event before closing the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCompletion()`: This refers to the completion event, which must be handled
    by a subscriber. Once a completion event is received, the subscription is considered
    void.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: This refers to the error event, which must be handled by a subscriber.
    An error can occur at any moment—while building a subscription or while generating
    the next data event. In any case, the publisher must send the error event. Once
    the event is received, the subscription is considered void.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The subscription is an important component in Reactive Streams. It provides
    the necessary control flow, so that publishers do not over-run a subscriber. This
    is known as backpressure.
  prefs: []
  type: TYPE_NORMAL
- en: Once the subscriber receives the subscription event, it must request that the
    publisher publish a specified count of events over their respective subscription.
    This is done by invoking the `request(long)` method of the subscription object.
  prefs: []
  type: TYPE_NORMAL
- en: 'As data events are generated, they are received by the subscriber. Once the
    limit has been reached, the publisher must stop publishing more events. As the
    subscriber processes these events, it must request additional events from the
    publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The subscription object allows a subscriber to control the events it wants to
    receive. Whenever the subscriber determines that it no longer wants the events,
    it can invoke the `cancel()` method of the subscription. Once invoked, a subscriber
    may receive fewer data events, in accordance with the demand raised before the
    cancellation. Post-cancellation, the subscription will become void, meaning that
    it cannot be used to request additional data.
  prefs: []
  type: TYPE_NORMAL
- en: A value of `Long.MaxValue` for the request method would result in an infinite
    flow of events from the publisher.
  prefs: []
  type: TYPE_NORMAL
- en: A subscriber can cancel an active subscription with the `onSubscribe()` method
    before any demand can be raised using the request method. In this case, the publisher
    will drop the subscription without raising any events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have gone over the subscriber interface in detail, we can try to
    build a `FibonacciSubscriber`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the subscription event, a request is raised to handle `10` events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When received, all data events are printed to the output console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After processing a single event, the subscriber cancels the subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onCompletion` method sets the subscription to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onError` method prints the error message to the console and sets the subscription
    as `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s validate the subscriber by using the `SubscriberBlackboxVerification<T>`
    abstract class. We need to implement the `createSubsciber()` method, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the test case to determine whether our subscriber meets the Reactive
    Streams criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3a2076d-7cf3-48bd-a595-41feec222b65.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can also find a large number of broken test cases. These broken test
    cases define the behavior for a subscriber. We could fix these, but the better
    option would be to use Reactor to create our services. In the following section,
    we will describe the publisher and subscriber implementations available in Reactor.
    These implementations conform to the specification behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into Reactor, let's compare the Streams model with some of the
    existing similar APIs, such as the `java.util.Observable` interface and the JMS
    API. We will try to determine the similarities and the key differences between
    the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.util.Observable` interface implements the Observer pattern, which
    can be co-related here. However, all similarities end here. If we look at the
    `Observable` interface, we have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the `Observer` interface before we determine the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the `Observable` and `Observer` interfaces, we can see that they
    are all about a single event and its state. The Observable API has the responsibility
    of determining a change and publishing it to all interested parties. On the other
    hand, the `Observer` only listens to the change. This is not what we are modeling
    with the `Publisher` and `Subscriber` interface. The `Publisher` interface is
    responsible for generating unbounded events, unlike the Observable, which is all
    about single entity state changes. The `Subscriber`, on the other hand, lists
    all kinds of events, such as data, error, and completion.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `Observable` maintains an active list of observers. It has
    the responsibility of removing observers that are no longer interested in the
    event. This is not the same as the `Publisher`, which is only responsible for
    subscriptions. The `Subscriber` makes the decision to close the subscription,
    at its will.
  prefs: []
  type: TYPE_NORMAL
- en: Java Messaging Service API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how Reactive Streams compares to the **Java Messaging Service
    (JMS)** API. The JMS specification describes a `Queue` and a `Topic`, to which
    a producer and a consumer can connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the producer is responsible for generating unbounded events on the queue
    or topics, while the consumer actively consumes the events. The producer and consumer
    are working in isolation, at their own rates. The task of managing the subscription
    is taken care of by the JMS broker. This is different from the Subscription API,
    where backpressure plays a major role in event generation. There is also no event
    modeling, like subscription, error, or completion. The JMS connection is like
    a never-ending stream of data. It cannot provide completion or error events. If
    we need to support this, custom objects must be modeled first.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the Reactor Core API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Reactor project is divided into different modules. The `reactor-core` module
    is the central library, aimed at providing implementations for Reactive Streams.
    The library provides Flux and Mono, which are two different implementations of
    the `Publisher` interface. The two publishers are different in terms of the number
    of events that they can emit. Flux can emit infinite sequences of elements, but
    the Mono API makes it possible to emit a maximum of one element. Let's cover these
    APIs in detail, in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Flux API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flux<T>` is a general purpose reactive publisher. It represents a stream of
    asynchronous events with zero or more values, optionally terminated by either
    a completion signal or an error. It is important to note that a Flux emits the
    following three events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value** refers to the values generated by the publisher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Completion** refers to a normal termination of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error** refers to an erroneous termination of the stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0f8368f4-1139-401a-9893-4795107b1b22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All of the preceding events are optional. This can lead to streams of the following
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infinite stream**: A publisher generating only value events, and no terminal
    events (completion and error)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinite empty stream**: A stream generating no value events and no terminating
    events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finite stream**: A publisher generating *N* finite values, followed by a
    terminal event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Empty stream**: A publisher generating no value events, and only terminal
    events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux supports the generation of all preceding variations, so it can be used
    for most of the generic use cases. It can also generate sequences of alerts for
    an application. The alerts are an infinite stream of values, with no terminal.
    Flux can also be used to stream order data from an order database. The order values
    get terminated at the last order value. It may be the case that there are no orders
    for a particular product type, making the stream empty for that type.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Flux API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Flux<T>` API supports stream generation from various sources, such as individual
    values, collections, Java 8 streams, and more. It can also be used to generate
    a stream from a custom logic, or from an existing reactive publisher. We will
    discuss all of these options in detail in upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Flux.just method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the simplest method for Flux generation. It takes a set of values,
    such as `var-args`, and generates a finite Flux stream with them. Each of the
    values specified as `var-args` forms a value event of the Flux. A completion event
    is published after publishing all of the specified values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Flux.from methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `From` methods can be used to generate a Flux from various sources, such
    as arrays, collections, and so on. In this case, all of the values are identified
    as multi-valued datasets beforehand. The generated Flux publishes the value events
    for each value in the original dataset, followed by a completion event. The offered
    methods have the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux.fromArray`: This is used to build a stream from an array of a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.fromIterable`: This is used to build a stream from collections. All collections
    are of the `Iterable<T>` type, which can be passed to this to generate the intended
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.fromStream`: This is used to build a Flux from an existing Java 8 stream
    or a Java 8 stream supplier. Consider the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Utility methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux offers methods to generate infinite streams and empty streams, or to convert
    an existing Reactive Stream publisher to Flux. These methods are required to generate
    streams that can be combined with other streams, using the available operators,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flux.empty`: This method generates an empty stream with no values and only
    completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.error`: This method generates an error stream with no values and only
    specified errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.never`: This method generates a stream with no events at all. It does
    not generate events of any type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.from`: This method takes an existing reactive publisher and generates
    a Flux from it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flux.defer`: This method is used to build a lazy reactive publisher. The method
    takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream
    publisher. The publisher instance is only generated when a subscriber makes a
    subscription to the Flux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flux.generate method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux supports programmatic event generation. In the previous chapter, we used
    the API to generate Fibonacci events. This is an advanced usage method of the
    API, and it involves some more components. We will cover these in detail in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: SynchronousSink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sink gets bounded to a subscriber of the publisher. It gets invoked via
    the consumer function, when a subscriber asks for data. For each invocation, the
    sink can be used to generate a maximum of one value event at a time. The sink
    can raise additional `onCompletion` or error events during the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the events generated by sink are synchronously
    consumed at the subscriber end. Let''s reflect on the Fibonacci test that we wrote
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating more that one event in the sink leads to `java.lang.IllegalStateException:
    More than one call to onNext`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added additional print statements while generating and consuming numbers.
    Let''s run our tests to see the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ae70d0b-1dc7-4672-9610-fd500cf07597.png)'
  prefs: []
  type: TYPE_IMG
- en: The consumer and producer statements are generated in an alternative manner.
    We can easily deduce that each number is consumed before the next number is generated.
    The Generate API is offered in multiple variants, and the sink can be used with
    or without an initial state. In our `FibonacciGenerator`, we used this with a
    state that is initialized on a per-subscriber basis. Optionally, we can also provide
    a terminal function, which gets invoked upon the termination of the events stream.
    This means that it will occur after the sink invokes an error or completion event.
    The terminal function can be used to perform any cleanup associated with the state.
  prefs: []
  type: TYPE_NORMAL
- en: Flux.create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flux.create` is another mechanism for generating events programmatically.
    It takes a `FluxSink`, which is capable of generating any number of events. The
    API is more generic than the `Generate` methods discussed in the previous section.
    The `FluxSink` is capable of generating events asynchronously. Moreover, it does
    not take subscription cancellation or backpressure into account. This means that
    even if the subscriber has cancelled its subscription, the create API will continue
    to generate events. All implementations must listen for the `cancel` event and
    explicitly initiate stream closure.'
  prefs: []
  type: TYPE_NORMAL
- en: As for backpressure, the producer keeps generating the events without looking
    into any demand from the subscriber. These events are buffered and dropped by
    default if the subscription is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the two are different, let''s modify our `FibonacciGenerator` to
    use a `FluxSink`. Some of the key differences are highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no initial seed state in the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FluxSink` keeps generating the events, irrespective of the subscription
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can generate any number of events in the sink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnDispose` event can be listened to in order to perform any cleanup, or
    to stop publishing events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All events that are generated are buffered and dropped once the subscription
    is cancelled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to note that the `FluxSink` provides lifecycle callback methods,
    which can be used to perform additional cleanups, or any other action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnCancel`*:* This method gets invoked when the subscription is cancelled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDispose`: This method gets invoked when the subscription is closed due to
    a cancel, close, or error event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRequest`: This method is invoked with the value specified by the subscriber.
    It can be used to build a pull data model. When the method is invoked, the next
    method can be invoked for the specified number of the values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the output that''s generated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d554e76-906e-43f3-9558-95d0437731c1.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Flux` also provides a `Push` method. This is similar to the `create` method,
    but the process of how error and complete events are invoked varies. These events
    must be invoked in a synchronous manner, from a single thread producer.'
  prefs: []
  type: TYPE_NORMAL
- en: The Mono API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have covered the Flux API, let''s look at Mono. It is capable of
    generating a maximum of one event. This is a specific use case for Flux, capable
    of handling one response model, such as data aggregation, HTTP request-response,
    service invocation response, and so on. It is important to note that a Mono emits
    the following three events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value** refers to the single value generated by the publisher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Completion** refers to a normal termination of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error** refers to an erroneous termination of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/16f7f796-cf40-4de3-b977-6ef7876bb97b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since Mono is a subset of Flux, it supports a subset of Flux operators. Let's
    look at how to build a Mono.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Mono<T>` API supports stream generation from various single-value sources,
    like individual values, method invocations, Java 8 supplier functions, and so
    on. It can also be used to generate a stream from a custom logic or from an existing
    reactive publisher. We will now discuss these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Mono.just method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Mono.just` method is the simplest method for Mono generation. It takes
    a single value and generates a finite Mono stream from it. A completion event
    is published after publishing the specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Mono.from method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `From` methods are used to build a Flux when the value can be determined
    from an existing source. Unlike the Flux methods, where the sources are multi-valued,
    the sources for Mono are single-valued. These methods are offered in the following
    variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromCallable`: This method generates Mono with one value, followed by the
    completion event. If multi-valued datasets, like arrays or collections, are returned
    from `Callable`, then the complete dataset is pushed as an object in the single
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromFuture`: This method generates Mono with one value, followed by the completion
    event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromSupplier`: This method generates Mono with one value, followed by the
    completion event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromRunnable`: This method generates Mono with no value and only a completion
    event. This can be explained by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Utility methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mono offers methods to generate empty/error streams or to convert an existing
    Reactive Stream publisher to Mono. These methods are required to generate streams
    that can be combined with others by using the available operators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mono.empty`: Generates a stream with no value and only a completion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono.error`*:* Generates a stream with no value and only a specified error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono.never`: Generates a stream with no events at all. It does not generate
    an event of any type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono.from`: Generates a Mono stream from an existing stream publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mono.defer`: This method is used to build a lazy reactive publisher. It also
    takes a Java 8 supplier to instantiate a subscription-specific Reactive Stream
    publisher. The publisher instance is only generated when a subscriber makes a
    subscription to the Mono.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to note that a Mono can be generated by using a Flux source.
    In that case, Mono uses the first event published from the Flux, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Mono.create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the `Flux.create` methods, there is a `Mono.create` method. This
    method provides a `MonoSink`, which can be used to generate a value, completion,
    or error event. Unlike the Flux methods, where we are generating *N* events, if
    we generate more events in Mono, they are dropped. There is also no handling for
    backpressure, as there is only one event.
  prefs: []
  type: TYPE_NORMAL
- en: The API does not take subscription cancellations into account. This means that
    even if the subscriber has cancelled its subscription, the create method still
    generates its event. Implementors must register custom hooks to lifecycle events
    and perform stream closures.
  prefs: []
  type: TYPE_NORMAL
- en: Building subscribers to Flux and Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor Flux and Mono provide a wide choice of subscribe methods. Reactive
    publishers raise four types of events, namely subscription, value, completion,
    and error. Individual functions can be registered for each of the events. We can
    also register a subscriber without listening to any kind of event. Let''s look
    at all of the possible variants offered, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows all of the `Subscribe` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: No event is consumed, as shown in line `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only value events are consumed, as shown in line `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with value events, we also print error stack-trace, as shown in line `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can listen to value, error, and completion events, as shown in line `4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can listen to value, error, completion, and subscription events, as shown
    in line `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All `Subscribe` methods return a `Disposable` type. This type can also be used
    to cancel the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, we may determine that the `Subscribe` methods are not good enough.
    We must create a custom subscriber with its own handling. Reactor provides a `reactor.core.publisher.BaseSubsciber<T>`
    for these situations. Instead of implementing the Reactive Stream `Subscriber`,
    reactor recommends implementing the `BaseSubscriber` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the `BaseSubscriber` implementation, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Each individual event can be handled in a separate hook method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It captures the subscription and makes it accessible by using the upstream method.
    This method can be invoked in any lifecycle method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also handles backpressure by providing `request(long)` methods. The default
    method is to request values one by one. However, the subscriber can raise additional
    demands by using the `request` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also presents the `requestUnbound()` method, which disables backpressures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the custom subscriber, it can be invoked by using the `subscribe()`
    method, available with Flux and Mono.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The publisher-subscriber communication generates events throughout the lifecycle
    of a Reactive Stream. Reactor provides corresponding lifecycle methods that can
    be used to hook custom logic to each of the said events, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Method** |'
  prefs: []
  type: TYPE_TB
- en: '| Subscribe event | `doOnSubscribe` |'
  prefs: []
  type: TYPE_TB
- en: '| Request event, for *N* items from the subscriber | `doOnRequest` |'
  prefs: []
  type: TYPE_TB
- en: '| Value event, for all generated values | `doOnNext` |'
  prefs: []
  type: TYPE_TB
- en: '| Error event, for any error by the publisher | `doOnError` |'
  prefs: []
  type: TYPE_TB
- en: '| Completion event | `doOnCompletion` |'
  prefs: []
  type: TYPE_TB
- en: '| Cancel event, for cancellation by the subscriber | `doOnCancel` |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the preceding methods, there are the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doOnEach`: This method is executed for all publisher events raised in the
    stream processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnTerminate`: This method is executed for stream closure due to an error
    or completion. It does not take cancellation into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doFinally`: This method is executed for stream closures due to errors, completions,
    or cancellations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying a hands-on project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have discussed Reactor interfaces in detail, let''s try to generate
    a factorial series using Reactor. Given a number, we want to generate a factorial
    of all numbers less than or equal to the provided number. In number theory, a
    factorial is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The factorial of a positive number ''n'' is defined as n! = n(n-1)(n-2)...2.1
    For example, 5 ! = 5 × 4 × 3 × 2 × 1 = 120."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to build a factorial stream function that takes a number and
    attempts to generate a factorial for every number, from 0 to *N*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we performed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial `factorialNumber` was set to `0`, with the factorial as `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then checked whether the `factorialNumber` was less than or equal to the
    passed number, and published the factorial value for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `factorialNumber` is more than the passed number, then we publish the completion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We incremented the `factorialNumber` and computed the factorial for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding flow is quite simple, but it makes it possible to utilize various
    Flux components. Since the factorial service is ready, we need to validate it
    by subscribing to it. In the following test case, we do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke the generator for factorial numbers up to `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display each generated number by using the `doOnNext()` lifecycle hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `last()` operator to get the last value. We will cover operators in
    the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compare and assert the value in the subscriber value event function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the test case to view the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c60ccc9f-5f0d-4172-ac28-11183fe94bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided a detailed discussion of the publisher and the
    subscriber interfaces of Reactive Streams. We attempted to implement these interfaces
    to illustrate that there are many non-explicit rules for them. These rules have
    been converted into the Reactive Streams TCK, against which all implementations
    should be validated. We also compared the publisher-subscriber pattern with the
    existing Observer and JMS patterns used in Java. Next, we took a detailed look
    at the Flux and Mono implementations available in Reactor. We looked at methods
    for creating them, and then subscribed to the generated streams.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the operators that can be used to modify
    the generated streams.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we validate Reactive Stream publisher and subscriber implementations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Reactive Stream publisher-subscriber model different from the JMS
    API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Reactive Stream publisher-subscriber model different from the Observer
    API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between Flux and Mono?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `SynchronousSink` and `FluxSink`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different lifecycle hooks available in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, please refer to the video under the Reactive Streams
    specification, as this is part of Java 9: [https://www.packtpub.com/application-development/reactive-java-9-video](https://www.packtpub.com/application-development/reactive-java-9-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To gain in-depth knowledge on building microservices using Akka as a Reactive
    Streams library, please refer to the following video: [https://www.packtpub.com/application-development/building-microservice-akka-http-video](https://www.packtpub.com/application-development/building-microservice-akka-http-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
