- en: Contexts and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Contexts** **and** **Dependency** **Injection** (**CDI**) was added to the
    Java EE specification in Java EE 6\. Java EE 8 includes a new version of CDI,
    which adds new features such as asynchronous events and event ordering. CDI provides
    several advantages that were previously unavailable to Java EE developers, such
    as allowing any JavaBean to be used as a JSF managed bean, including stateless
    and stateful session beans. As its name implies, CDI simplifies dependency injection
    in Java EE applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the next section), and to easily refer to them from JSF pages via
    the unified expression language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the `@Named` annotation in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase; in our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we had wanted to
    use the name `customerBean` for the bean above, we could have done so by modifying
    the `@Named` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the `value` attribute name does not need to be specified, if we don't
    use an attribute name, then `value` is implied.
  prefs: []
  type: TYPE_NORMAL
- en: 'This name can be used to access our bean from JSF pages using the unified expression
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, named beans are accessed from JSF pages exactly as standard JSF
    managed beans are. This allows JSF to access any named bean, decoupling the Java
    code from the JSF API.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deployed and executed, our simple application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71173338-a1f7-4e86-b055-90fda1e1e4a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency injection** is a technique for supplying external dependencies
    to a Java class. Java EE 5 introduced dependency injection via the `@Resource`
    annotation, however, this annotation is limited to injecting resources such as
    database connections, JMS resources, and so on. CDI includes the `@Inject` annotation,
    which can be used to inject instances of Java classes into any dependent objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF applications typically follow the **Model-View-Controller** (**MVC**) design
    pattern. As such, often some JSF managed beans take the role of controllers in
    the pattern, while others take the role of the model. This approach typically
    requires the controller managed bean to have access to one or more of the model-managed
    beans. CDI''s dependency injection capabilities make injecting beans into one
    another very simple, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all we had to do to initialize our `Customer` instance was to decorate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some instances, the type of bean we wish to inject into our code may be an
    interface or a Java superclass, but we may be interested in injecting a specific
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers we can use to indicate the specific type we wish to inject into our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation we wish to qualify. Additionally, the injected field
    in the client code needs to be decorated with the qualifier as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle those
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, qualifiers are standard annotations; they typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the above example. The only difference between a qualifier and
    a standard annotation is that qualifiers are decorated with the `@Qualifier` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have decorated the specific instance we need to qualify, we can use
    our qualifiers in the `client` code to specify the exact type of dependency we
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we used our `@Premium` qualifier to decorate the customer field, an instance
    of `PremiumCustomer` is injected into that field, as this class is also decorated
    with the `@Premium` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as our JSF pages go, we simply access our named bean as usual, using
    its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simple application renders and acts just like a "plain" JSF application,
    as far as the user is concerned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcb8f159-b667-4101-9b0a-4d8d42b453ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Named bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like JSF managed beans, CDI named beans are scoped. This means that CDI
    beans are contextual objects. When a named bean is needed, either because of injection
    or because it is referred from a JSF page, CDI looks for an instance of the bean
    in the scope it belongs to and injects it into the dependent code. If no instance
    is found, one is created and stored in the appropriate scope for future use. The
    different scopes are the context in which the bean exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the different valid CDI scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scope** | **Annotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Request | `@RequestScoped` | request-scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Conversation | `@ConversationScoped` | The conversation scope can span multiple
    requests but is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: '| Session | `@SessionScoped` | session-scoped beans are shared across all requests
    in an HTTP session. Each user of an application gets their own instance of a session
    scoped bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Application | `@ApplicationScoped` | application-scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dependent | `@Dependent` | dependent-scoped beans are not shared; any time
    a dependent scoped bean is injected, a new instance is created. |'
  prefs: []
  type: TYPE_TB
- en: As we can see, CDI includes most scopes supported by JSF, and also adds a couple
    of its own. CDI's **request scope** differs from JSF's request scope, in which
    a request does not necessarily refer to an HTTP request; it could simply be an
    invocation on an EJB method, a web service invocation, or sending a JMS message
    to a message-driven bean.
  prefs: []
  type: TYPE_NORMAL
- en: The **conversation scope** does not exist in JSF. This scope is similar to JSF's
    flow scope, since it is longer than the request scope but shorter than the session
    scope, and typically spans three or more pages. Classes wishing to access a conversation-scoped
    bean must have an instance of `javax.enterprise.context.Conversation` injected.
    At the point where we want to start the conversation, the `begin()` method must
    be invoked on this object. At the point where we want to end the conversation,
    the `end()` method must be invoked on it.
  prefs: []
  type: TYPE_NORMAL
- en: CDI's **session scope** behaves just like its JSF counterpart. The lifecycle
    of session-scoped beans are tied to the life of an HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: CDI's **application scope** also behaves just like the equivalent scope in JSF.
    Application-scoped beans are tied to the life of an application. A single instance
    of each application-scoped bean exists per application, which means that the same
    instance is accessible to all HTTP sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the conversation scope, CDI's **dependent scope** does not exist in
    JSF. New dependent scope beans are instantiated every time it is needed; usually
    when it is injected into a class that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to have a user enter some data that would be stored in a
    single named bean, but that bean has several fields. Therefore, we would like
    to split the data entry into several pages. This is a fairly common situation
    and one that was not easy to handle using previous versions of Java EE (JSF 2.2
    added Faces Flows to solve this problem; refer to [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces* ), or the servlet API for that matter. The reason this situation
    was not easy to manage using those technologies is that you could either put a
    class in the request scope, in which case the class would be destroyed after every
    single request, losing its data in the process, or in the session scope, in which
    the class would stick around in memory long after it was needed. For cases like
    this, CDI''s conversation scope is a good solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation-scoped beans also need to implement `java.io.Serializable`.
    Other than those two requirements, there is nothing special about our code; it
    is a simple JavaBean with private properties and corresponding `getter` and `setter`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the Apache `commons-lang` library in our code to easily implement
    a `toString()` method for our bean. `commons-lang` has several `utility` methods
    like this that implement frequently needed, tedious to code functionality. `commons-lang`
    is available in the central `Maven` repositories and at [http://commons.apache.org/lang](http://commons.apache.org/lang).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to having our conversation-scoped bean injected, our client code
    must also have an instance of `javax.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Conversations can be either **long-running** or **transient**. Transient conversations
    end at the end of a request, while long-running conversations span multiple requests.
    In most cases, we use long-running conversations to hold a reference to a conversation-scoped
    bean across multiple HTTP requests in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: A long-running conversation starts when the `begin()` method is invoked in the
    injected `Conversation` instance, and it ends when we invoke the `end()` method
    on the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF pages simply access our CDI beans as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we navigate from one page to the next, we keep the same instance of our conversation-scoped
    bean; therefore, all user entered data remains. When the `end()` method is called
    on our conversation bean, the conversation ends and our conversation-scoped bean
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping our bean in the conversation scope simplifies the task of implementing
    *wizard-style* user interfaces, where data can be entered across several pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f71e195a-79d1-4843-936e-68d055e382bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In our example, after clicking the Next button on the first page, we can see
    our partially populated bean in the application server log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the second page in our simple wizard is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af93b45-060c-46d6-933e-8ab3f3a15e55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click Next, we can see that additional fields are populated in our
    conversation-scoped bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we submit the third page in our wizard (not shown), additional bean properties
    corresponding to the fields on that page are populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are at the point where we don''t need to keep the customer information
    in memory anymore, we need to call the `end()` method on the `Conversation` bean
    that was injected into our code. This is exactly what we do in our code before
    displaying the confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After the request to show the confirmation page is completed, our conversation-scoped
    bean is destroyed, since we invoked the `end()` method in our injected `Conversation`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We should note that, since the conversation, scope requires an instance of `javax.enterprise.context.Conversation`
    to be injected, this scope requires that the action in the command button or link
    used to navigate between pages be an expression resolving to a named bean method.
    Using static navigation won't work, since the `Conversation` instance won't be
    injected anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: CDI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI provides event handling facilities. Events allow loosely-coupled communication
    between different CDI beans. A CDI bean can fire an event, then one or more event
    listeners handle the event.
  prefs: []
  type: TYPE_NORMAL
- en: Firing CDI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example is a new version of the `CustomerInfoController` class
    we discussed in the previous section. The class has been modified to fire an event
    every time the user navigates to a new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, to create an event, we inject an instance of `javax.enterprise.event.Event`.
    This class uses generics, therefore, we need to specify its type; the type of
    the `Event` class can be any class implementing `java.io.Serializable`. In our
    case, we are passing an instance of a simple POJO we wrote as the type parameter.
    Our POJO is called `NavigationInfo` and has two properties: one `Customer`type,
    and a `String` containing the page the user is navigating to. Recall from the
    previous sections that each of the methods on our `CustomerInfoController` class
    triggers navigation from one page in the application to another. In this version
    of the controller, a CDI event is fired every time we navigate to a new page.
    In each case, we create a new instance of `NavigationInfo`, populate it, then
    fire the event by invoking the `fire()` method on our instance of `javax.enterprise.event.Event`.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling CDI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle CDI events, the CDI bean handling the event needs to implement an
    `observer` method. The `observer` method accepts a parameter of the type that
    was used to fire the event, that is, the generic type used to create the event
    that was fired. In our example, the generic type of our event is an instance of
    a class named `NavigationInfo`, as can be seen in the declaration of our event
    in the preceding section. To handle the event, the observer method needs to annotate
    the corresponding parameter with the `@Observes` annotation, as illustrated in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example event handler, the `handleNavigationEvent()` method takes an
    instance of `NavigationInfo` as a parameter. Notice that this parameter is annotated
    with `@Observes`; this causes the method to be invoked automatically by CDI every
    time a `NavigationInfo` type event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have only one event listener, but in practice, we can have
    as many event listeners as we need.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CDI 2.0 introduced the ability to fire events asynchronously. Firing events
    asynchronously can help with performance, since various observer methods can be
    invoked concurrently. Firing an event asynchronously is very similar to firing
    an event synchronously, the only difference is that, instead of invoking the `fire()`
    method in our `Event` instance, we invoke its `fireAsync()` method. The following
    example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Observer methods to handle asynchronous events are identical to their synchronous
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Event ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another new feature introduced in CDI 2.0 is the ability to specify in which
    order our `observer` methods handle CDI events. This can be accomplished via the
    `@Priority` annotation, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `@Priority` annotation takes an argument of type `int`. This argument specifies
    the priority for the `observer` method. The highest priority is defined by the
    `APPLICATION` constant defined in the `Interceptor.Priority` class. This is the
    priority we gave to the `observer` method in our example. Lower priority values
    take precedence; the default priority is `Interceptor.Priority.APPLICATION + 100`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an introduction to Contexts and Dependency Injection
    (CDI). We covered how JSF pages can access CDI named beans as if they were JSF
    managed beans. We also covered how CDI makes it easy to inject dependencies into
    our code via the `@Inject` annotation. Additionally, we explained how we can use
    qualifiers to determine which specific implementation of a dependency to inject
    into our code. Finally, we covered all the scopes that a CDI bean can be placed
    into, which include equivalents to all the JSF scopes, plus an additional two
    not included in JSF, namely, the conversation scope and the dependent scope.
  prefs: []
  type: TYPE_NORMAL
