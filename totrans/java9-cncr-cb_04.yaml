- en: Thread Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread executor and controlling its rejected tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing tasks in an executor that returns a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing the first result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing all the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor after a delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor periodically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task in an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a task finishing in an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the launching of tasks and the processing of their results in an
    executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, when you develop a simple, concurrent programming application in Java,
    first you create some `Runnable` objects and then the corresponding `Thread` objects
    to execute them. If you have to develop a program that runs a lot of concurrent
    tasks, this approach will present the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You will have to implement all of the code-related information to manage `Thread`
    objects (creating, ending, and obtaining results).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to create a `Thread` object per task. Executing a huge number
    of tasks can affect the throughput of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to control and manage the resources of the computer efficiently.
    If you create too many threads, you could saturate the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Java 5, the Java concurrency API provides a mechanism that aims to resolve
    these problems. This mechanism is called the **Executor framework** and is around
    the `Executor` interface, its subinterface `ExecutorService`, and the `ThreadPoolExecutor`
    class that implements both these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mechanism separates task creation and execution. With an executor, you
    only have to implement either `Runnable` or `Callable` objects and send them to
    the executor. It is responsible for their execution, running them with the necessary
    threads. But it goes beyond this; it improves performance using a pool of threads.
    When you send a task to the executor, it tries to use a pooled thread for the
    execution of the task. It does so to avoid the continuous spawning of threads.
    Another important advantage of the `Executor` framework is the `Callable` interface.
    It''s similar to the `Runnable` interface but offers two improvements, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The main method of this interface, named `call()`, may return a result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you send a `Callable` object to an executor, you get an object that implements
    the `Future` interface. You can use this object to control the status and the
    result of the `Callable` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter presents nine recipes that show you how to work with the `Executor`
    framework using the classes mentioned earlier and other variants provided by the
    Java Concurrency API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread executor and controlling its rejected tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step toward working with the `Executor` framework is to create an
    object of the `ThreadPoolExecutor` class. You can use the four constructors provided
    by this class or use a factory class named `Executors`, which creates `ThreadPoolExecutor`.
    Once you have an executor, you can send `Runnable` or `Callable` objects to be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to finish the execution of an executor, use the `shutdown()` method.
    The executor waits for the completion of tasks that are either running or waiting
    for their execution. Then, it finishes the execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you send a task to an executor between the `shutdown()` method and the end
    of its execution, the task will be rejected. This is because the executor no longer
    accepts new tasks. The `ThreadPoolExecutor` class provides a mechanism, which
    is called when a task is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `Executors` class to create a
    new `ThreadPoolExecutor` object, how to send tasks to the `Executor`, and how
    to control the rejected tasks of the `Executor` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should read the *Creating, running, and setting the characteristics of a
    thread*Â recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Management*, to learn the basic mechanism of thread creation in Java.
    You can compare both the mechanisms and select one, depending on the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, implement the tasks that will be executed by the server. Create a class
    named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `Date` attribute named `initDate` to store the creation date of the
    task and a `String` attribute called `name` to store the name of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes both the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, write the `initDate` attribute and the actual date, which is the starting
    date of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, put the task to sleep for a random period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the completion date of the task in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `RejectedTaskController` that implements the `RejectedExecutionHandler`
    interface. Implement the `rejectedExecution()` method of this interface. Then
    write the name of the task that has been rejected and the name and status of the
    executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `Server` class that will execute every task it receives using
    an executor. Create a class named `Server`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `ThreadPoolExecutor` attribute named `executor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the `ThreadPoolExecutor`
    object using the `Executors` class, and establish a handler for rejected tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `executeTask()` method. It receives a `Task` object as a parameter
    and sends it to the executor. First, write a message to the console indicating
    that a new task has arrived:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the `execute()` method of the executor and send it to the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write some executor data to the console to see its status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `endServer()` method. In this method, call the `shutdown()`
    method of the executor to finish its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it. First, create 100 tasks and send them to `Executor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then call the `endServer()` method of `Server` to shut down the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, send a new task. This task will be rejected, so we will see how this
    mechanism works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key of this example is the `Server` class. This class creates and uses `ThreadPoolExecutor`
    to execute tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The first important point is the creation of `ThreadPoolExecutor` in the constructor
    of the `Server` class. The `ThreadPoolExecutor` class has four different constructors,
    but due to their complexity, the Java concurrency API provides the `Executors`
    class to construct executors and other related objects. Although you can create
    `ThreadPoolExecutor` directly using one of its constructors, it's recommended
    that you use the `Executors` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you created a cached thread pool using the `newFixedThreadPool()`
    method of the `Executors` class in order to create the executor. This method creates
    an executor with the maximum number of threads. If the number of tasks you send
    is more than the number of threads, the remaining tasks will be blocked until
    there is a free thread available to process them. This method receives the maximum
    number of threads you want to have in your executor as parameters. In our case,
    we used the `availableProcessors()` method of the `Runtime` class that returns
    the number of processors available to JVM. Normally, this number matches the number
    of cores of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Reutilization of threads has the advantage that it reduces the time taken for
    thread creation. The cached thread pool, however, has theÂ disadvantage of having
    constant lying threads for new tasks. Therefore, if you send too many tasks to
    this executor, you could overload the system.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the executor, you can send tasks of the `Runnable` or
    `Callable` type for execution using the `execute()` method. In this case, you
    sent objects of the `Task` class that implements the `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also printed some log messages with information about the executor. Specifically,
    you used the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returned the actual number of threads in the pool
    of the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveCount()`: This method returned the number of threads that were executing
    tasks in the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTaskCount()`: This method returned the number of tasks that were scheduled
    for execution. The returned value is only an approximation because it changes
    dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCompletedTaskCount()`: This method returned the number of tasks completed
    by the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One critical aspect of the `ThreadPoolExecutor` class, and of executors in general,
    is that you have to end them explicitly. If you don't do this, the executor will
    continue its execution and the program won't end. If the executor doesn't have
    tasks to execute, it continues waiting for new tasks and doesn't end its execution.
    A Java application won't end until all its non-daemon threads finish their execution.
    So, if you don't terminate the executor, your application will never end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To indicate to the executor that you want to finish it, use the `shutdown()`
    method of the `ThreadPoolExecutor` class. When the executor finishes the execution
    of all the pending tasks, it finishes its execution as well. After you call the
    `shutdown()` method, if you try to send another task to the executor, it will
    be rejected and the executor will throw a `RejectedExecutionException` exception,
    unless you have implemented a manager for rejected tasks, as in our case. To manage
    the rejected tasks of an executor, you need to create a class that implements
    the `RejectedExecutionHandler` interface. This interface has a method called `rejectedExecution()`
    with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Runnable` object that stores the task that has been rejected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Executor` object that stores the executor that rejected the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called for every task that is rejected by the executor. You need
    to establish the handler of the rejected tasks using the `setRejectedExecutionHandler()`
    method of the `ThreadPoolExecutor` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.gif)'
  prefs: []
  type: TYPE_IMG
- en: See that when the last task arrives at the executor, both the number of threads
    in the pool and the number of threads that are being executed are represented
    by 4\. This refers to the number of cores of the PC on which the example was executed,
    and it is the number returned by the `availableProcessors()` method. Once this
    is done, we shut down the executor and the next task is rejected. `RejectedTaskController`
    writes information about the task and the executor in the console.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Executors` class provides other methods to create `ThreadPoolExecutor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`newCachedThreadPool()`: This method returns an `ExecutorService` object, so
    it''s been cast to `ThreadPoolExecutor` to have access to all its methods. The
    cached thread pool you created creates new threads, if needed, to execute new
    tasks. Plus, it reuses the existing ones if they have finished the execution of
    the tasks they were running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newSingleThreadExecutor()`: This is an extreme case of a fixed-size thread
    executor. It creates an executor with only one thread so it can only execute one
    task at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ThreadPoolExecutor` class provides a lot of methods to obtain information
    about its status. We used the `getPoolSize()`, `getActiveCount()`, and `getCompletedTaskCount()`
    methods in the example to obtain information about the size of the pool, the number
    of threads, and the number of completed tasks of the executor. You can also use
    the `getLargestPoolSize()` method; it returns the maximum number of threads that
    have been in the pool at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThreadPoolExecutor` class also provides other methods related to the finalization
    of the executor. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shutdownNow()`: This shuts down the executor immediately. It doesn''t execute
    pending tasks. It returns a list with all the pending tasks. Tasks that are running
    when you call this method continue with their execution, but the method doesn''t
    wait for their finalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns true if you call either theÂ `shutdown()`
    or `shutdownNow()` method; the executor finishes the process of shutting it down
    accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isShutdown()`: This method returns `true` if you call the `shutdown()` method
    of the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitTermination(long timeout, TimeUnit unit)`: This method blocks the calling
    thread until the tasks of the executor end or a timeout occurs. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to wait for the completion of tasks, regardless of their duration,
    use a big timeout, for example, `DAYS`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Monitoring an Executor framework* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing tasks in an executor that returns a result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the advantages of the `Executor` framework is that it allows you to
    run concurrent tasks that return a result. The Java Concurrency API achieves this
    with the following two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Callable`: This interface has the `call()` method. In this method, you have
    to implement the logic of the task. The `Callable` interface is a parameterized
    interface, meaning you have to indicate the type of data the `call()` method will
    return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future`: This interface has some methods to obtain the result generated by
    a `Callable` object and manage its state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement tasks that return a result and
    run them on an executor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `FactorialCalculator`. Specify that it implements the
    `Callable` interface parameterized by the `Integer` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Integer` attribute called `number` to store the number that
    this task will use for its calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the attribute of the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method. This method returns the factorial of the number
    attribute of `FactorialCalculator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, create and initialize the internal variables used in the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number is `0` or `1`, return `1`. Otherwise, calculate the factorial
    of the number. Between two multiplications, for educational purposes, put this
    task to sleep for 20 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console with the result of the operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the result of the operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ThreadPoolExecutor` to run the tasks using the `newFixedThreadPool()`
    method of the `Executors` class. Pass `2` as the parameter, that is, as the number
    of threads in the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `Future<Integer>` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a random number generator with the `Random` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a loop with ten steps. In every step, we generate a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `FactorialCalculator` object passing the generated random
    number as parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `submit()` method of the executor to send the `FactorialCalculator`
    task to the executor. This method returns a `Future<Integer>` object to manage
    the task and eventually get its result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Future` object to the list created before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `do` loop to monitor the status of the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First, write a message to the console indicating the number of completed tasks,
    using the `getCompletedTaskNumber()` method of the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for the 10 `Future` objects in the list, write a message indicating whether
    the tasks that it manages have finished or not. Do this using the `isDone()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 50 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this loop when the number of completed tasks of the executor is less
    than 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console, write the results obtained by each task. For each `Future`
    object, get the `Integer` object returned by its task, using the `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, print the number to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the `shutdown()` method of the executor to finalize its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned how to use the `Callable` interface to launch concurrent
    tasks that return a result. You implemented the `FactorialCalculator` class that
    implements the `Callable` interface with `Integer` as the type of the result.
    Hence, the `call()` method returns an `Integer` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other critical point of this example is the `Main` class. You sent a `Callable`
    object to be executed in an executor using the `submit()` method. This method
    receives a `Callable` object as a parameter and returns a `Future` object that
    you can use with two main objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: You can control the status of the task you can cancel the task and check whether
    it has finished or not. For this purpose, you used the `isDone()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the result returned by the `call()` method. For this purpose, you
    used the `get()` method. This method waits until the `Callable` object has finished
    the execution of the `call()` method and has returned its result. If the thread
    is interrupted while the `get()` method is waiting for the result, it throws an
    `InterruptedException` exception. If the `call()` method throws an exception,
    then the `get()` method throws an `ExecutionException` exception as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you call the `get()` method of a `Future` object and the task controlled
    by this object hasn''t finished yet, the method is blocked until the task is finished.
    The `Future` interface provides another version of the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get` method, if the
    result of the task isn''t available, waits for the specified time. If the specified
    period of time passes and the result is still not available, it throws a `TimeoutException`
    exception. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a thread executor and controlling its rejected tasks*, *Running
    multiple tasks and processing the first result*, andÂ *Running multiple tasks and
    processing all the resultsÂ recipes* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing the first result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem in concurrent programming arises when you have various concurrent
    tasks available to solve a problem, but you are only interested in the first result.
    For example, you want to sort an array. You have various sort algorithms. You
    can launch all of them and get the result of the first one that sorts the array,
    that is, the fastest sorting algorithm for a given array.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement this scenario using the `ThreadPoolExecutor`
    class. You are going to use two mechanisms to try and validate a user. The user
    will be validated if one of these mechanisms is able to validate it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `UserValidator` that will implement the process of user
    validation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the user validation system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `validate()` method. It receives two `String` parameters with
    the name and password of the user you want to validate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Random` object named `random`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a random period of time to simulate the process of user validation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a random `Boolean` value. The `validate()` method returns `true` when
    the user is validated, and `false` otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `getName()`. This method returns the value of the name attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a class named `ValidatorTask` that will execute a validation process
    with the `UserValidation` object as a concurrent task. Specify that it implements
    the `Callable` interface parameterized by the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `UserValidator` attribute named `validator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `String` attributes, named `user` and `password`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that will initialize all the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method that will return a `String` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user is not validated by the `UserValidator` object, write a message
    to the console indicating this and throw `Exception`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, write a message to the console indicating that the user has been
    validated and return the name of the `UserValidator` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the main class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `String` objects named `user` and `password` and initialize them
    with the test value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `UserValidator` objects, named `ldapValidator` and `dbValidator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `TaskValidator` objects, named `ldapTask` and `dbTask`. Initialize
    them with `ldapValidator` and `dbValidator`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `TaskValidator` objects and add to it the two objects that
    you have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `ThreadPoolExecutor` object using the `newCachedThreadPool()`
    method of the `Executors` class and a string variable named `result`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `invokeAny()` method of the executor object. This method receives
    `taskList` as a parameter and returns `String`. Also, it writes the `String` object
    that is returned to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate the executor using the `shutdown()` method and write a message to
    the console to indicate that the program has ended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key of the example is in the `Main` class. The `invokeAny()` method of the
    `ThreadPoolExecutor` class receives a list of tasks, then launches them, and returns
    the result of the first task that finishes without throwing an exception. This
    method returns the same data type that the `call()` method of the tasks returns.
    In this case, it returned a `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example when
    one of the tasks validates the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.gif)'
  prefs: []
  type: TYPE_IMG
- en: The example has two `UserValidator` objects that return a random Boolean value.
    Each `UserValidator` object is used by a `Callable` object, implemented by the
    `TaskValidator` class. If the `validate()` method of the `UserValidator` class
    returns a false value, the `TaskValidator` class throws `Exception`. Otherwise,
    it returns the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have two tasks that can return the `true` value or throw `Exception`.
    You can have the following four possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Both tasks return the `true` value. Here, the result of the `invokeAny()` method
    is the name of the task that finishes in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first task returns the `true` value and the second one throws `Exception`.
    Here, the result of the `invokeAny()` method is the name of the first task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first task throws `Exception` and the second one returns the `true` value.
    Here, the result of the `invokeAny()` method is the name of the second task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both tasks throw `Exception`. In such a class, the `invokeAny()` method throws
    an `ExecutionException` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you run the examples several times, you will get each of the four possible
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the application when both the
    tasks throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.gif)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ThreadPoolExecutor` class provides another version of the `invokeAny()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method executes all the tasks and returns the result of the first
    one that finishes without throwing an exception, if it does so before the given
    timeout is passed. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running multiple tasks and processing all the results* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing all the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework allows you to execute concurrent tasks without worrying
    about thread creation and execution. It provides you with the `Future` class,
    whichÂ you can use to control the status and get the results of any task executed
    in an executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to wait for the finalization of a task, you can use the following
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `isDone()` method of the `Future` interface returns `true` if the task has
    finished its execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `awaitTermination()` method of the `ThreadPoolExecutor` class puts the thread
    to sleep until all the tasks have finished their execution after a call to the
    `shutdown()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two methods have some drawbacks. With the first one, you can only control
    the completion of a task. With the second one, you have to shut down the executor
    to wait for a thread; otherwise, the method's call is returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThreadPoolExecutor` class provides a method that allows you to send a list
    of tasks to the executor and wait for the finalization of all the tasks in the
    list. In this recipe, you will learn how to use this feature by implementing an
    example with 10 tasks executed and their results printed out when they have finished.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Result` to store the results generated in the concurrent
    tasks of this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private attributes, namely a `String` attribute called `name` and
    an `int` attribute named `value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the corresponding `get()` and `set()` methods to set and return the
    value of the name and value attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` that implements the `Callable` interface parameterized
    by the `Result` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method of the class. In this case, the method will return
    a `Result` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'First, write a message to the console to indicate that the task is getting
    started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, wait for a random period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate an `int` value to be returned in the `Result` object, calculate
    the sum of five random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Result` object and initialize it with the name of this `Task` object
    and the result of the operation done earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console to indicate that the task has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the `Result` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `Task` objects. Create 10 `Task` objects and save them on
    this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `Future` objects. These objects are parameterized by the `Result`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `invokeAll()` method of the `ThreadPoolExecutor` class. This class
    will return the list of the `Future` objects created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finalize the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the results of the tasks processing the list of `Future` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you learned how to send a list of tasks to an executor and wait
    for the finalization of all of them using the `invokeAll()` method. This method
    receives a list of `Callable` objects and returns a list of `Future` objects.
    This list will have a `Future` object per task. The first object in the list of
    `Future` objects will be the object that controls the first task in the list of
    `Callable` objects, the second object the second task, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first point to take into consideration is that the type of data used for
    the parameterization of the `Future` interface in the declaration of the list
    that stores the result objects must be compatible with the one used to parameterize
    `Callable` objects. In this case, you used the same type of data: the `Result`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important point about the `invokeAll()` method is that you will use
    `Future` objects only to get the results of the tasks. As the method finishes
    when all the tasks finish, if you call the `isDone()` method of `Future` objects
    that are returned, all the calls will return the true value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ExecutorService` class provides another version of the `invokeAll()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method executes all the tasks and returns the result of their execution
    when all of them are finished, that is, if they finish before the given timeout
    has passed. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result*Â and *Running multiple
    tasks and processing the first result* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor after a delay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework provides the `ThreadPoolExecutor` class to execute
    `Callable` and `Runnable` tasks with a pool of threads, which helps you avoid
    all thread creation operations. When you send a task to the executor, it's executed
    as soon as possible, according to the configuration of the executor. There are
    use cases when you are not interested in executing a task as soon as possible.
    You may want to execute a task after a period of time or do it periodically. For
    these purposes, the Executor framework provides the `ScheduledExecutorService`
    interface along with its implementation, namely the `ScheduledThreadPoolExecutor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create `ScheduledThreadPoolExecutor` and
    use it to schedule the execution of a task after a given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that implements the `Callable` interface parameterized
    by the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the name attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method. Write a message to the console with the actual
    date and return some text, for example, `Hello, world`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an executor of the `ScheduledThreadPoolExecutor` class using the `newScheduledThreadPool()`
    method of the `Executors` class, passing `1` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize and start a few tasks (five in our case) with the `schedule()` method
    of the `ScheduledThreadPoolExecutor` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Request the finalization of the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of all the tasks using the `awaitTermination()` method
    of the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to indicate the time when the program will finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key point of this example is the `Main` class and the management of `ScheduledThreadPoolExecutor`.
    As with the `ThreadPoolExecutor` class, to create a scheduled executor, Java recommends
    that you utilize the `Executors` class. In this case, you used the `newScheduledThreadPool()`
    method. You passed the number `1` as a parameter to this method. This parameter
    refers to the number of threads you want to have in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a task in this scheduled executor after a period of time, you have
    to use the `schedule()` method. This method receives the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The task you want to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The period of time you want the task to wait before its execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit of the period of time, specified as a constant of the `TimeUnit` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, each task will wait for a number of seconds (`TimeUnit.SECONDS`)
    equal to its position in the array of tasks plus one.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to execute a task at a given time, calculate the difference between
    that date and the current date and use the difference as the delay of the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the tasks start their execution, one per second. All the tasks
    are sent to the executor at the same time but with a delay of 1 second later than
    the previous task.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use the `Runnable` interface to implement the tasks because the
    `schedule()` method of the `ScheduledThreadPoolExecutor` class accepts both types
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `ScheduledThreadPoolExecutor` class is a child class of the `ThreadPoolExecutor`
    class (and therefore inherits all its features), Java recommends that you use
    `ScheduledThreadPoolExecutor` only for scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can configure the behavior of the `ScheduledThreadPoolExecutor`
    class when you call the `shutdown()` method, and there are pending tasks waiting
    for the end of their delay time. The default behavior is that these tasks will
    be executed despite the finalization of the executor. You can change this behavior
    using the `setExecuteExistingDelayedTasksAfterShutdownPolicy()` method of the
    `ScheduledThreadPoolExecutor` class. If you call the `setExecuteExistingDelayedTasksAfeterShutdownsPolicy()`Â passing
    the `false` value as parameter, pending tasks won't be executed after you call
    the `shutdown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor periodically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute concurrent
    tasks using a pool of threads that helps you avoid all thread creation operations.
    When you send a task to the executor, it executes the task as soon as possible
    according to its configuration. When it ends, the task is deleted from the executor,
    and if you want to execute it again, you have to send it to the executor again.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Executor framework provides the possibility of executing periodic
    tasks through the `ScheduledThreadPoolExecutor` class. In this recipe, you will
    learn how to use this functionality of the class to schedule a periodic task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Write a message to the console with the actual
    date to verify that the task is executed within the specified period:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ScheduledExecutorService` using the `newScheduledThreadPool()` method
    of the `Executors` class. Pass `1` to this method as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console with the actual date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Task` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Send this object to the executor using the `scheduledAtFixRate()` method. Use
    the tasks created earlier as parameters: the number one, the number two, and the
    constant `TimeUnit.SECONDS`. This method returns a `ScheduledFuture` object that
    you can use to control the status of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with 10 steps to write the time remaining for the next execution
    of the task. In the loop, use the `getDelay()` method of the `ScheduledFuture`
    object to get the number of milliseconds until the next execution of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Sleep the thread during 500 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 5 seconds to verify that the periodic tasks have
    finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to indicate the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to execute a periodic task using the Executor framework, you need
    a `ScheduledExecutorService` object. To create it (as with every executor), Java
    recommends the use of the `Executors` class. This class works as a factory of
    executor objects. In this case, you used the `newScheduledThreadPool()` method
    to create a `ScheduledExecutorService` object. This method receives the number
    of threads of the pool as a parameter. Since you had only one task in this example,
    you passed `1` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you had the executor needed to execute a periodic task, you sent the task
    to the executor. You used the `scheduledAtFixedRate()` method. This method accepts
    four parameters: the task you want to execute periodically, the delay of time
    until the first execution of the task, the period between two executions, and
    the time unit of the second and third parameters. It''s a constant of the `TimeUnit`
    class. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs: []
  type: TYPE_NORMAL
- en: An important point to consider is that the period between two executions is
    the period of time between the start of those two executions. If you have a periodic
    task that takes 5 seconds to execute and you put in a period of 3 seconds, you
    will have two instances of the task executing at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The `scheduleAtFixedRate()` method returns a `ScheduledFuture` object, which
    extends the `Future` interface, with methods to work with scheduled tasks. `ScheduledFuture`
    is a parameterized interface. In this example, as your task was a `Runnable` object
    that was not parameterized, you had to parameterize them with the `?` symbol as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You used one method of the `ScheduledFuture` interface. The `getDelay()` method
    returns the time until the next execution of the task. This method receives a
    `TimeUnit` constant with the time unit in which you want to receive the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the task being executed every 2 seconds (denoted by Task: prefix)
    and the delay written in the console every 500 milliseconds. That''s how long
    the main thread has been put to sleep. When you shut down the executor, the scheduled
    task ends its execution and you don''t see any more messages in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ScheduledThreadPoolExecutor` provides other methods to schedule periodic tasks.
    It is the `scheduleWithFixedRate()` method. It has the same parameters as the
    `scheduledAtFixedRate()` method, but there is a difference worth noticing. In
    the `scheduledAtFixedRate()` method, the third parameter determines the period
    of time between the starting of two executions. In the `scheduledWithFixedRate()`
    method, the parameter determines the period of time between the end of an execution
    of the task and its beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure the behavior of an instance of the `ScheduledThreadPoolExecutor`
    class with the `shutdown()` method. The default behavior is that the scheduled
    tasks finish when you call this method. You can change this behavior using the
    `setContinueExistingPeriodicTasksAfterShutdownPolicy()` method of the `ScheduledThreadPoolExecutor`
    class with a true value. Periodic tasks won't finish upon calling the `shutdown()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a thread executor and controlling its rejected tasks*Â and *Running
    a task in an executor after a delayÂ *recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task in an executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with an executor, you don't have to manage threads. You only implement
    `Runnable` or `Callable` tasks and send them to the executor. It's the executor
    that's responsible for creating threads, managing them in a thread pool, and finishing
    them if they are not needed. Sometimes, you may want to cancel a task that you
    send to the executor. In that case, you can use the `cancel()` method of `Future`,
    whichÂ allows you to make the cancelation operation. In this recipe, you will learn
    how to use this method to cancel tasks that you have sent to an executor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` and specify that it implements the `Callable` interface
    parameterized by the `String` class. Implement the `call()` method. Write a message
    to the console and put it to sleep for `100` milliseconds inside an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Task` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the task to the executor using the `submit()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the main task to sleep for 2 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Cancel the execution of the task using the `cancel()` method of the `Future`
    object, named `result`, returned by the `submit()` method. Pass the true value
    as a parameter of the `cancel()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the result of a call to the `isCancelled()` and `isDone()` methods to
    the console. This is to verify that the task has been canceled, and hence, already
    done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the executor with the `shutdown()` method and write a message indicating
    the finalization of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You use the `cancel()` method of the `Future` interface when you want to cancel
    a task that you have sent to an executor. Depending on the parameter of the `cancel()`
    method and the status of the task, the behavior of this method is different:'
  prefs: []
  type: TYPE_NORMAL
- en: If the task has finished or has been canceled earlier, or it can't be cancelled
    due to any other reason, the method will return the `false` value and the task
    won't be canceled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the task is waiting in the executor to get a `Thread` object that will execute
    it, the task is canceled and will never begin its execution. If the task is already
    running, it depends on the parameter of the method. The `cancel()` method receives
    a Boolean value as a parameter. If the value of this parameter is `true` and the
    task is running, it will be canceled. If the value of the parameter is false and
    the task is running, it won't be canceled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use the `get()` method of a `Future` object that controls a task that
    has been canceled, the `get()` method will throw a `CancellationException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a task finishing in an executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java API provides the `FutureTask` class as a cancelable asynchronous computation.
    It implements the `Runnable` and `Future` interfaces and provides the basic implementation
    of the `Future` interface. We can create a `FutureTask` class using a `Callable`
    or `Runnable` object `(Runnable` objects doesn't return a result, so we have to
    pass as parameter too in this case the result that the `Future` object will return).
    It provides methods to cancel the execution and obtain the result of the computation.
    It also provides a method called `done()` that allows you to execute some code
    after the finalization of a task executed in an executor. It can be used to make
    some postprocess operations, such as generating a report, sending results by e-mail,
    or releasing some resources. This method is called internally by the `FutureTask`
    class when the execution of the task that this `FutureTask` object is controlling
    finishes. The method is called after the result of the task is set and its status
    is changed to `isDone`, regardless of whether the task has been canceled or finished
    normally.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this method is empty. You can override the `FutureTask` class and
    implement this method to change the behavior. In this recipe, you will learn how
    to override this method to execute code after the finalization of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ExecutableTask` and specify that it implements the `Callable`
    interface parameterized by the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name`. It will store the name
    of the task. Implement the `getName()` method to return the value of this attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize the name of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method. Put the task to sleep for a random period of
    time and return a message with the name of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a class named `ResultTask` that extends the `FutureTask` class parameterized
    by the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name`. It will store the name
    of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It has to receive a `Callable` object
    as a parameter. Call the constructor of the parent class and initialize the name
    attribute using the attribute of the task received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `done()` method. Check the value of the `isCancelled()` method
    and write a different message to the console, depending on the returned value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ExecutorService` using the `newCachedThreadPool()` method of the `Executors`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array to store five `ResultTask` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `ResultTask` objects. For each position in the array, first
    you have to create `ExecutorTask` and then `ResultTask` using the object. Then,
    send `ResultTask` to the executor using the `submit()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the main thread to sleep for 5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Cancel all the tasks you have sent to the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the result of those tasks that haven''t been canceled to the console,
    using the `get()` method of the `ResultTask` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `done()` method is called by the `FutureTask` class when the task that is
    being controlled finishes its execution. In this example, you implemented a `Callable`
    object, the `ExecutableTask` class, and then a subclass of the `FutureTask` class
    that controls the execution of the `ExecutableTask` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `done()` method is called internally by the `FutureTask` class after establishing
    the return value and changing the status of the task to `isDone`. You can't change
    the result value of the task or change its status, but you can close resources
    used by the task, write log messages, or send notifications. The `FutureTask`
    class might be used to ensure that a specific task is run only once, as calling
    its `run()` method will execute its wrapped `Runnable`/`Callable` interface only
    once (and the result can be fetched with `get` when it's available).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the launching of tasks and the processing of their results in an
    executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when you execute concurrent tasks using an executor, you will send
    `Runnable` or `Callable` tasks to the executor and get `Future` objects to control
    the method. You can find situations where you need to send the tasks to the executor
    in one object and process the results in another one. For such situations, the
    Java Concurrency API provides the `CompletionService` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `CompletionService` class has a method to send tasks to an executor and
    a method to get the `Future` object for the next task that has finished its execution.
    Internally, it uses an `Executor` object to execute the tasks. This behavior has
    the advantage of sharing a `CompletionService` object and sending tasks to the
    executor so others can process the results. The limitation is that the second
    object can only get the `Future` objects for those tasks that have finished their
    execution, so these Future objects can only be used to get the results of the
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CompletionService` class to separate
    the process of launching tasks in an executor from the processing of their results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ReportGenerator` and specify that it implements the `Callable`
    interface parameterized by the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `String` attributes named `sender` and `title`. These attributes
    will represent the data of the report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `call()` method. First, put the thread to sleep for a random
    period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, generate the report as a string with the `sender` and `title` attributes
    and return that string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `ReportRequest` and specify that it implements the `Runnable`
    interface. Thiss class will simulate some report requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute called `name` to store the name of `ReportRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `CompletionService` attribute named `service`. The `CompletionService`
    interface is a parameterized interface. Use the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Create three `ReportGenerator` objects and send
    them to the `CompletionService` object using the `submit()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `ReportProcessor`. This class will get the results of
    the `ReportGenerator` tasks. Specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `CompletionService` attribute named `service`. As the `CompletionService`
    interface is a parameterized interface, use the `String` class as a parameter
    of this `CompletionService` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Boolean` attribute named `end`. Add the `volatile` keyword
    to ensure that all the threads have access to the actual value of the attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize the two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. While the `end` attribute is false, call the
    `poll()` method of the `CompletionService` interface to get the `Future` object
    of the next task executed by the completion service that has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get the results of the task using the `get()` method of the `Future`
    object and write the results to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `stopProcessing()` method that modifies the value of the `end`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `CompletionService` using the executor created earlier as a parameter
    of the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two `ReportRequest` objects and the threads to execute them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ReportProcessor` object and the thread to execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the three threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the `ReportRequest` threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the executor using the `shutdown()` method and wait for the finalization
    of the tasks with the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the execution of the `ReportSender` object setting the value of its
    `end` attribute to true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the main class of the example, you created `ThreadPoolExecutor` using the
    `newCachedThreadPool()` method of the `Executors` class. Then, you used that `Executor`
    object to initialize a `CompletionService` object because the completion service
    uses an executor to execute its tasks. To execute a task using the completion
    service, use the `submit()` method, as in the `ReportRequest` class.
  prefs: []
  type: TYPE_NORMAL
- en: When one of these tasks is executed when the completion service finishes its
    execution, the service stores the `Future` object used to control its execution
    in a queue. The `poll()` method accesses this queue to check whether there is
    any task that has finished its execution; if yes, it returns the first element
    of the queue, which is a `Future` object of a task that has finished its execution.
    When the `poll()` method returns a `Future` object, it deletes it from the queue.
    In this case, you passed two attributes to the method to indicate the time you
    want to wait for the finalization of a task, in case the queue with the results
    of the finished tasks is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `CompletionService` object is created, you create two `ReportRequest`
    objects that execute a `ReportGenerator` task, execute a `ReportGenerator` task
    using the `CompletionService` object create before and passed as parameter to
    the constructor of the `ReportRequest` objects
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CompletionService` class can execute `Callable` or `Runnable` tasks. In
    this example, you used `Callable`, but you could have also sent `Runnable` objects.
    Since `Runnable` objects don't produce a result, the philosophy of the `CompletionService`
    class doesn't apply in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class also provides two other methods to obtain the `Future` objects of
    the finished tasks. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`poll()`: The version of the `poll()` method without arguments checks whether
    there are any `Future` objects in the queue. If the queue is empty, it returns
    null immediately. Otherwise, it returns its first element and removes it from
    the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method, without arguments, checks whether there are any `Future`
    objects in the queue. If it is empty, it blocks the thread until the queue has
    an element. If the queue has elements, it returns and deletes its first element
    from the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we used the `poll()` method with a timeout to control when we would
    like to end the execution of the `ReportProcessor` task.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
