- en: Thread Executors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程执行器
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a thread executor and controlling its rejected tasks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线程执行器并控制其拒绝的任务
- en: Executing tasks in an executor that returns a result
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中执行返回结果的任务
- en: Running multiple tasks and processing the first result
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个任务并处理第一个结果
- en: Running multiple tasks and processing all the results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个任务并处理所有结果
- en: Running a task in an executor after a delay
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在延迟后运行执行器中的任务
- en: Running a task in an executor periodically
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期在执行器中运行任务
- en: Canceling a task in an executor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中取消任务
- en: Controlling a task finishing in an executor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制执行器中任务完成
- en: Separating the launching of tasks and the processing of their results in an
    executor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行器中分离任务的启动和结果处理
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Usually, when you develop a simple, concurrent programming application in Java,
    first you create some `Runnable` objects and then the corresponding `Thread` objects
    to execute them. If you have to develop a program that runs a lot of concurrent
    tasks, this approach will present the following disadvantages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你用Java开发一个简单的并发编程应用程序时，首先创建一些`Runnable`对象，然后创建相应的`Thread`对象来执行它们。如果你必须开发一个运行大量并发任务的应用程序，这种方法将带来以下缺点：
- en: You will have to implement all of the code-related information to manage `Thread`
    objects (creating, ending, and obtaining results).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将不得不实现所有与代码相关的信息来管理`Thread`对象（创建、结束和获取结果）。
- en: You will have to create a `Thread` object per task. Executing a huge number
    of tasks can affect the throughput of the application.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将不得不为每个任务创建一个`Thread`对象。执行大量任务可能会影响应用程序的吞吐量。
- en: You will have to control and manage the resources of the computer efficiently.
    If you create too many threads, you could saturate the system.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将需要有效地控制和管理工作站的资源。如果你创建太多线程，可能会使系统饱和。
- en: Since Java 5, the Java concurrency API provides a mechanism that aims to resolve
    these problems. This mechanism is called the **Executor framework** and is around
    the `Executor` interface, its subinterface `ExecutorService`, and the `ThreadPoolExecutor`
    class that implements both these interfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 5以来，Java并发API提供了一种旨在解决这些问题的机制。这个机制被称为**执行器框架**，它围绕`Executor`接口、其子接口`ExecutorService`以及实现这两个接口的`ThreadPoolExecutor`类。
- en: 'This mechanism separates task creation and execution. With an executor, you
    only have to implement either `Runnable` or `Callable` objects and send them to
    the executor. It is responsible for their execution, running them with the necessary
    threads. But it goes beyond this; it improves performance using a pool of threads.
    When you send a task to the executor, it tries to use a pooled thread for the
    execution of the task. It does so to avoid the continuous spawning of threads.
    Another important advantage of the `Executor` framework is the `Callable` interface.
    It''s similar to the `Runnable` interface but offers two improvements, which are
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制将任务创建和执行分离。使用执行器，你只需实现`Runnable`或`Callable`对象并将它们发送到执行器。它负责它们的执行，使用必要的线程运行它们。但不仅如此；它通过线程池来提高性能。当你向执行器发送任务时，它会尝试使用池中的线程来执行任务。这样做是为了避免不断创建线程。`Executor`框架的另一个重要优点是`Callable`接口。它与`Runnable`接口类似，但提供了两个改进，具体如下：
- en: The main method of this interface, named `call()`, may return a result.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该接口的主要方法名为`call()`，可能返回一个结果。
- en: When you send a `Callable` object to an executor, you get an object that implements
    the `Future` interface. You can use this object to control the status and the
    result of the `Callable` object.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你向执行器发送`Callable`对象时，你会得到一个实现了`Future`接口的对象。你可以使用此对象来控制`Callable`对象的状态和结果。
- en: This chapter presents nine recipes that show you how to work with the `Executor`
    framework using the classes mentioned earlier and other variants provided by the
    Java Concurrency API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了九个菜谱，展示了如何使用前面提到的类和其他Java并发API提供的变体来使用`Executor`框架。
- en: Creating a thread executor and controlling its rejected tasks
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程执行器并控制其拒绝的任务
- en: The first step toward working with the `Executor` framework is to create an
    object of the `ThreadPoolExecutor` class. You can use the four constructors provided
    by this class or use a factory class named `Executors`, which creates `ThreadPoolExecutor`.
    Once you have an executor, you can send `Runnable` or `Callable` objects to be
    executed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Executor`框架的第一步是创建`ThreadPoolExecutor`类的对象。你可以使用这个类提供的四个构造函数，或者使用名为`Executors`的工厂类来创建`ThreadPoolExecutor`。一旦你有了执行器，你就可以发送`Runnable`或`Callable`对象去执行。
- en: When you want to finish the execution of an executor, use the `shutdown()` method.
    The executor waits for the completion of tasks that are either running or waiting
    for their execution. Then, it finishes the execution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要完成执行器的执行时，使用`shutdown()`方法。执行器会等待正在运行或等待执行的任务完成。然后，它完成执行。
- en: If you send a task to an executor between the `shutdown()` method and the end
    of its execution, the task will be rejected. This is because the executor no longer
    accepts new tasks. The `ThreadPoolExecutor` class provides a mechanism, which
    is called when a task is rejected.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个执行器的`shutdown()`方法和执行结束之间发送一个任务，该任务将被拒绝。这是因为执行器不再接受新的任务。`ThreadPoolExecutor`类提供了一个机制，当任务被拒绝时会被调用。
- en: In this recipe, you will learn how to use the `Executors` class to create a
    new `ThreadPoolExecutor` object, how to send tasks to the `Executor`, and how
    to control the rejected tasks of the `Executor` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`Executors`类创建一个新的`ThreadPoolExecutor`对象，如何向`Executor`发送任务，以及如何控制`Executor`类的拒绝任务。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the *Creating, running, and setting the characteristics of a
    thread* recipe in [Chapter 1](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Management*, to learn the basic mechanism of thread creation in Java.
    You can compare both the mechanisms and select one, depending on the problem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该阅读[第1章](part0026.html#OPEK0-69b77957c9a14e36a0bec5f5a1363736)中关于*创建、运行和设置线程特性*的菜谱，学习Java中线程创建的基本机制。你可以比较这两种机制，并根据问题选择一个。
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, implement the tasks that will be executed by the server. Create a class
    named `Task` that implements the `Runnable` interface:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，实现服务器将要执行的任务。创建一个名为`Task`的类，该类实现了`Runnable`接口：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `Date` attribute named `initDate` to store the creation date of the
    task and a `String` attribute called `name` to store the name of the task:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`initDate`的`Date`属性来存储任务的创建日期，以及一个名为`name`的`String`属性来存储任务的名称：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the constructor of the class that initializes both the attributes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化两个属性：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `run()` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, write the `initDate` attribute and the actual date, which is the starting
    date of the task:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，写入`initDate`属性和实际日期，即任务的开始日期：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, put the task to sleep for a random period of time:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让任务随机休眠一段时间：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, write the completion date of the task in the console:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将任务的完成日期写入控制台：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `RejectedTaskController` that implements the `RejectedExecutionHandler`
    interface. Implement the `rejectedExecution()` method of this interface. Then
    write the name of the task that has been rejected and the name and status of the
    executor:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RejectedTaskController`的类，该类实现了`RejectedExecutionHandler`接口。实现这个接口的`rejectedExecution()`方法。然后写入被拒绝的任务名称以及执行器的名称和状态：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now implement the `Server` class that will execute every task it receives using
    an executor. Create a class named `Server`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`Server`类，该类将使用执行器执行它接收到的每个任务。创建一个名为`Server`的类：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a `ThreadPoolExecutor` attribute named `executor`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`executor`的`ThreadPoolExecutor`属性：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the constructor of the class that initializes the `ThreadPoolExecutor`
    object using the `Executors` class, and establish a handler for rejected tasks:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，使用`Executors`类初始化`ThreadPoolExecutor`对象，并设置拒绝任务的处理器：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `executeTask()` method. It receives a `Task` object as a parameter
    and sends it to the executor. First, write a message to the console indicating
    that a new task has arrived:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`executeTask()`方法。它接收一个`Task`对象作为参数并将其发送到执行器。首先，向控制台写入一条消息，表明已到达一个新的任务：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, call the `execute()` method of the executor and send it to the task:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用执行器的`execute()`方法并将其发送到任务：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, write some executor data to the console to see its status:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将一些执行器数据写入控制台以查看其状态：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, implement the `endServer()` method. In this method, call the `shutdown()`
    method of the executor to finish its execution:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`endServer()`方法。在此方法中，调用执行器的`shutdown()`方法来完成其执行：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it. First, create 100 tasks and send them to `Executor`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类。首先，创建100个任务并将它们发送到`Executor`：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then call the `endServer()` method of `Server` to shut down the executor:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`Server`的`endServer()`方法来关闭执行器：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, send a new task. This task will be rejected, so we will see how this
    mechanism works:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发送一个新的任务。此任务将被拒绝，因此我们将看到这个机制是如何工作的：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of this example is the `Server` class. This class creates and uses `ThreadPoolExecutor`
    to execute tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的关键是`Server`类。此类创建并使用`ThreadPoolExecutor`来执行任务。
- en: The first important point is the creation of `ThreadPoolExecutor` in the constructor
    of the `Server` class. The `ThreadPoolExecutor` class has four different constructors,
    but due to their complexity, the Java concurrency API provides the `Executors`
    class to construct executors and other related objects. Although you can create
    `ThreadPoolExecutor` directly using one of its constructors, it's recommended
    that you use the `Executors` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重要点是`Server`类的构造函数中创建`ThreadPoolExecutor`。`ThreadPoolExecutor`类有四个不同的构造函数，但由于它们的复杂性，Java并发API提供了`Executors`类来构建执行器和相关对象。虽然您可以直接使用其构造函数之一创建`ThreadPoolExecutor`，但建议您使用`Executors`类。
- en: In this case, you created a cached thread pool using the `newFixedThreadPool()`
    method of the `Executors` class in order to create the executor. This method creates
    an executor with the maximum number of threads. If the number of tasks you send
    is more than the number of threads, the remaining tasks will be blocked until
    there is a free thread available to process them. This method receives the maximum
    number of threads you want to have in your executor as parameters. In our case,
    we used the `availableProcessors()` method of the `Runtime` class that returns
    the number of processors available to JVM. Normally, this number matches the number
    of cores of the computer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您使用`Executors`类的`newFixedThreadPool()`方法创建了一个缓存线程池来创建执行器。此方法创建了一个具有最大线程数的执行器。如果您发送的任务数量超过线程数，剩余的任务将阻塞，直到有可用的空闲线程来处理它们。此方法接收您希望执行器中拥有的最大线程数作为参数。在我们的例子中，我们使用了`Runtime`类的`availableProcessors()`方法，它返回JVM可用的处理器数量。通常，这个数字与计算机的核心数相匹配。
- en: Reutilization of threads has the advantage that it reduces the time taken for
    thread creation. The cached thread pool, however, has the disadvantage of having
    constant lying threads for new tasks. Therefore, if you send too many tasks to
    this executor, you could overload the system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的重用具有减少线程创建时间的优势。然而，缓存线程池的缺点是对于新任务有恒定的空闲线程。因此，如果您向此执行器发送过多的任务，可能会超载系统。
- en: Once you have created the executor, you can send tasks of the `Runnable` or
    `Callable` type for execution using the `execute()` method. In this case, you
    sent objects of the `Task` class that implements the `Runnable` interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了执行器，您可以使用`execute()`方法发送`Runnable`或`Callable`类型的任务进行执行。在这种情况下，您发送了实现了`Runnable`接口的`Task`类的对象。
- en: 'You also printed some log messages with information about the executor. Specifically,
    you used the following methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您还打印了一些包含执行器信息的日志消息。具体来说，您使用了以下方法：
- en: '`getPoolSize()`: This method returned the actual number of threads in the pool
    of the executor.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回执行器池中的实际线程数。'
- en: '`getActiveCount()`: This method returned the number of threads that were executing
    tasks in the executor.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回在执行器中执行任务的线程数量。'
- en: '`getTaskCount()`: This method returned the number of tasks that were scheduled
    for execution. The returned value is only an approximation because it changes
    dynamically.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTaskCount()`: 此方法返回已安排执行的任务数量。返回的值仅是一个近似值，因为它会动态变化。'
- en: '`getCompletedTaskCount()`: This method returned the number of tasks completed
    by the executor.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 此方法返回执行器完成的任务数量。'
- en: One critical aspect of the `ThreadPoolExecutor` class, and of executors in general,
    is that you have to end them explicitly. If you don't do this, the executor will
    continue its execution and the program won't end. If the executor doesn't have
    tasks to execute, it continues waiting for new tasks and doesn't end its execution.
    A Java application won't end until all its non-daemon threads finish their execution.
    So, if you don't terminate the executor, your application will never end.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor` 类以及一般执行器的一个关键方面是，你必须显式地结束它们。如果你不这样做，执行器将继续执行，程序将不会结束。如果执行器没有要执行的任务，它将继续等待新任务，并且不会结束其执行。Java
    应用程序不会结束，直到所有非守护线程完成它们的执行。因此，如果你不终止执行器，你的应用程序将永远不会结束。'
- en: 'To indicate to the executor that you want to finish it, use the `shutdown()`
    method of the `ThreadPoolExecutor` class. When the executor finishes the execution
    of all the pending tasks, it finishes its execution as well. After you call the
    `shutdown()` method, if you try to send another task to the executor, it will
    be rejected and the executor will throw a `RejectedExecutionException` exception,
    unless you have implemented a manager for rejected tasks, as in our case. To manage
    the rejected tasks of an executor, you need to create a class that implements
    the `RejectedExecutionHandler` interface. This interface has a method called `rejectedExecution()`
    with two parameters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要向执行器指示你想要结束它，请使用 `ThreadPoolExecutor` 类的 `shutdown()` 方法。当执行器完成所有挂起任务的执行后，它也会结束其执行。在你调用
    `shutdown()` 方法后，如果你尝试向执行器发送另一个任务，它将被拒绝，并且执行器将抛出 `RejectedExecutionException`
    异常，除非你已经实现了拒绝任务的经理，就像在我们的案例中一样。要管理执行器的拒绝任务，你需要创建一个实现 `RejectedExecutionHandler`
    接口的类。此接口有一个名为 `rejectedExecution()` 的方法，它有两个参数：
- en: A `Runnable` object that stores the task that has been rejected
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储已拒绝的任务的 `Runnable` 对象
- en: An `Executor` object that stores the executor that rejected the task
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储拒绝任务的执行器的 `Executor` 对象
- en: This method is called for every task that is rejected by the executor. You need
    to establish the handler of the rejected tasks using the `setRejectedExecutionHandler()`
    method of the `ThreadPoolExecutor` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行器拒绝的每个任务，都会调用此方法。你需要使用 `ThreadPoolExecutor` 类的 `setRejectedExecutionHandler()`
    方法来建立拒绝任务的处理器。
- en: 'The following screenshot shows part of an execution of this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例执行的部分：
- en: '![](img/00027.gif)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00027.gif)'
- en: See that when the last task arrives at the executor, both the number of threads
    in the pool and the number of threads that are being executed are represented
    by 4\. This refers to the number of cores of the PC on which the example was executed,
    and it is the number returned by the `availableProcessors()` method. Once this
    is done, we shut down the executor and the next task is rejected. `RejectedTaskController`
    writes information about the task and the executor in the console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当最后一个任务到达执行器时，池中的线程数和正在执行的线程数都表示为 4。这指的是执行示例的 PC 的核心数，这是 `availableProcessors()`
    方法返回的数值。一旦完成，我们关闭执行器，下一个任务将被拒绝。`RejectedTaskController` 将任务和执行器的信息写入控制台。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Executors` class provides other methods to create `ThreadPoolExecutor`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors` 类提供了其他方法来创建 `ThreadPoolExecutor`：'
- en: '`newCachedThreadPool()`: This method returns an `ExecutorService` object, so
    it''s been cast to `ThreadPoolExecutor` to have access to all its methods. The
    cached thread pool you created creates new threads, if needed, to execute new
    tasks. Plus, it reuses the existing ones if they have finished the execution of
    the tasks they were running.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 此方法返回一个 `ExecutorService` 对象，因此它已被转换为 `ThreadPoolExecutor`
    以访问其所有方法。你创建的缓存线程池在需要时创建新线程来执行新任务。此外，如果它们已经完成了正在运行的任务的执行，它将重用它们。'
- en: '`newSingleThreadExecutor()`: This is an extreme case of a fixed-size thread
    executor. It creates an executor with only one thread so it can only execute one
    task at a time.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 这是一个固定大小线程执行器的极端情况。它创建一个只有一个线程的执行器，因此一次只能执行一个任务。'
- en: The `ThreadPoolExecutor` class provides a lot of methods to obtain information
    about its status. We used the `getPoolSize()`, `getActiveCount()`, and `getCompletedTaskCount()`
    methods in the example to obtain information about the size of the pool, the number
    of threads, and the number of completed tasks of the executor. You can also use
    the `getLargestPoolSize()` method; it returns the maximum number of threads that
    have been in the pool at a time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor` 类提供了许多方法来获取有关其状态的信息。我们在示例中使用了 `getPoolSize()`、`getActiveCount()`
    和 `getCompletedTaskCount()` 方法来获取有关池大小、线程数和执行器完成任务的数量的信息。您还可以使用 `getLargestPoolSize()`
    方法；它返回一次在池中达到的最大线程数。'
- en: 'The `ThreadPoolExecutor` class also provides other methods related to the finalization
    of the executor. These methods are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor` 类还提供了与执行器最终化相关的一些其他方法。这些方法包括：'
- en: '`shutdownNow()`: This shuts down the executor immediately. It doesn''t execute
    pending tasks. It returns a list with all the pending tasks. Tasks that are running
    when you call this method continue with their execution, but the method doesn''t
    wait for their finalization.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`: 这将立即关闭执行器。它不会执行挂起的任务。它返回一个包含所有挂起任务的列表。当您调用此方法时正在运行的任务将继续执行，但该方法不会等待它们的最终化。'
- en: '`isTerminated()`: This method returns true if you call either the `shutdown()`
    or `shutdownNow()` method; the executor finishes the process of shutting it down
    accordingly.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 此方法返回 true，如果您调用了 `shutdown()` 或 `shutdownNow()` 方法；执行器将相应地完成关闭过程。'
- en: '`isShutdown()`: This method returns `true` if you call the `shutdown()` method
    of the executor.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 如果您调用了执行器的 `shutdown()` 方法，此方法返回 `true`。'
- en: '`awaitTermination(long timeout, TimeUnit unit)`: This method blocks the calling
    thread until the tasks of the executor end or a timeout occurs. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitTermination(long timeout, TimeUnit unit)`: 此方法阻塞调用线程，直到执行器的任务结束或发生超时。`TimeUnit`
    类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: If you want to wait for the completion of tasks, regardless of their duration,
    use a big timeout, for example, `DAYS`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想等待任务完成，无论它们的持续时间如何，请使用大超时，例如，`DAYS`。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Monitoring an Executor framework* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 9 章 [“监控 Executor 框架”配方](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736)，*测试并发应用程序*
- en: Executing tasks in an executor that returns a result
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在返回结果的执行器中执行任务
- en: 'One of the advantages of the `Executor` framework is that it allows you to
    run concurrent tasks that return a result. The Java Concurrency API achieves this
    with the following two interfaces:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 框架的一个优点是它允许您运行返回结果的并发任务。Java 并发 API 通过以下两个接口实现这一点：'
- en: '`Callable`: This interface has the `call()` method. In this method, you have
    to implement the logic of the task. The `Callable` interface is a parameterized
    interface, meaning you have to indicate the type of data the `call()` method will
    return.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`：此接口有一个 `call()` 方法。在此方法中，您必须实现任务的逻辑。`Callable` 接口是一个参数化接口，这意味着您必须指明
    `call()` 方法将返回的数据类型。'
- en: '`Future`: This interface has some methods to obtain the result generated by
    a `Callable` object and manage its state.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`：此接口有一些方法可以获取 `Callable` 对象生成的结果并管理其状态。'
- en: In this recipe, you will learn how to implement tasks that return a result and
    run them on an executor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何实现返回结果的任务并在执行器上运行它们。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `FactorialCalculator`. Specify that it implements the
    `Callable` interface parameterized by the `Integer` type:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FactorialCalculator` 的类。指定它实现由 `Integer` 类型参数化的 `Callable` 接口：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare a private `Integer` attribute called `number` to store the number that
    this task will use for its calculations:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `number` 的私有 `Integer` 属性，用于存储此任务将用于其计算的数字：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the constructor of the class that initializes the attribute of the
    class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化类的属性：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the `call()` method. This method returns the factorial of the number
    attribute of `FactorialCalculator`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`call()`方法。此方法返回`FactorialCalculator`的数字属性的阶乘：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, create and initialize the internal variables used in the method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建并初始化方法中使用的内部变量：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the number is `0` or `1`, return `1`. Otherwise, calculate the factorial
    of the number. Between two multiplications, for educational purposes, put this
    task to sleep for 20 milliseconds:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是`0`或`1`，则返回`1`。否则，计算数字的阶乘。为了教育目的，在两次乘法之间让这个任务休眠20毫秒：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write a message to the console with the result of the operation:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用操作的结果向控制台发送一条消息：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Return the result of the operation:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回操作的结果：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create `ThreadPoolExecutor` to run the tasks using the `newFixedThreadPool()`
    method of the `Executors` class. Pass `2` as the parameter, that is, as the number
    of threads in the executor:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newFixedThreadPool()`方法创建`ThreadPoolExecutor`来运行任务。将`2`作为参数传递，即作为执行器中的线程数：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a list of `Future<Integer>` objects:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Future<Integer>`对象的列表：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a random number generator with the `Random` class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Random`类创建一个随机数生成器：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Make a loop with ten steps. In every step, we generate a random number:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含十个步骤的循环。在每一步中，我们生成一个随机数：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we create a `FactorialCalculator` object passing the generated random
    number as parameter:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`FactorialCalculator`对象，将生成的随机数作为参数传递：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Call the `submit()` method of the executor to send the `FactorialCalculator`
    task to the executor. This method returns a `Future<Integer>` object to manage
    the task and eventually get its result:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行器的`submit()`方法将`FactorialCalculator`任务发送到执行器。此方法返回一个`Future<Integer>`对象来管理任务，并最终获取其结果：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the `Future` object to the list created before:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Future`对象添加到之前创建的列表中：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a `do` loop to monitor the status of the executor:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`do`循环来监控执行器的状态：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, write a message to the console indicating the number of completed tasks,
    using the `getCompletedTaskNumber()` method of the executor:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用执行器的`getCompletedTaskNumber()`方法向控制台发送一条消息，指示已完成任务的数目：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, for the 10 `Future` objects in the list, write a message indicating whether
    the tasks that it manages have finished or not. Do this using the `isDone()` method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于列表中的10个`Future`对象，使用`isDone()`方法写一条消息，指示它管理的任务是否已完成：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Put the thread to sleep for 50 milliseconds:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠50毫秒：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Repeat this loop when the number of completed tasks of the executor is less
    than 10:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行器的已完成任务数少于10时，重复此循环：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the console, write the results obtained by each task. For each `Future`
    object, get the `Integer` object returned by its task, using the `get()` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台，写出每个任务获得的结果。对于每个`Future`对象，使用`get()`方法获取其任务返回的`Integer`对象：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, print the number to the console:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将数字打印到控制台：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, call the `shutdown()` method of the executor to finalize its execution:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用执行器的`shutdown()`方法来最终化其执行：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you learned how to use the `Callable` interface to launch concurrent
    tasks that return a result. You implemented the `FactorialCalculator` class that
    implements the `Callable` interface with `Integer` as the type of the result.
    Hence, the `call()` method returns an `Integer` value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你学习了如何使用`Callable`接口启动返回结果的并发任务。你实现了`FactorialCalculator`类，该类实现了`Callable`接口，并将`Integer`作为结果类型。因此，`call()`方法返回一个`Integer`值。
- en: 'The other critical point of this example is the `Main` class. You sent a `Callable`
    object to be executed in an executor using the `submit()` method. This method
    receives a `Callable` object as a parameter and returns a `Future` object that
    you can use with two main objectives:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此例中的另一个关键点是`Main`类。你使用`submit()`方法向执行器发送了一个要执行的对象。此方法接收一个`Callable`对象作为参数，并返回一个`Future`对象，你可以用它实现两个主要目标：
- en: You can control the status of the task you can cancel the task and check whether
    it has finished or not. For this purpose, you used the `isDone()` method.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以控制任务的状况，你可以取消任务并检查它是否已经完成。为此，你使用了`isDone()`方法。
- en: You can get the result returned by the `call()` method. For this purpose, you
    used the `get()` method. This method waits until the `Callable` object has finished
    the execution of the `call()` method and has returned its result. If the thread
    is interrupted while the `get()` method is waiting for the result, it throws an
    `InterruptedException` exception. If the `call()` method throws an exception,
    then the `get()` method throws an `ExecutionException` exception as well.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以获取 `call()` 方法返回的结果。为此，您使用了 `get()` 方法。此方法等待 `Callable` 对象完成 `call()` 方法的执行并返回其结果。如果在
    `get()` 方法等待结果时线程被中断，它将抛出一个 `InterruptedException` 异常。如果 `call()` 方法抛出异常，则 `get()`
    方法也会抛出一个 `ExecutionException` 异常。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'When you call the `get()` method of a `Future` object and the task controlled
    by this object hasn''t finished yet, the method is blocked until the task is finished.
    The `Future` interface provides another version of the `get()` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用 `Future` 对象的 `get()` 方法，并且由该对象控制的任务尚未完成时，该方法将被阻塞，直到任务完成。`Future` 接口提供了
    `get()` 方法的另一个版本：
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get` method, if the
    result of the task isn''t available, waits for the specified time. If the specified
    period of time passes and the result is still not available, it throws a `TimeoutException`
    exception. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long timeout, TimeUnit unit)`: 这个版本的 `get` 方法，如果任务的输出不可用，将等待指定的时间。如果在指定的时间内过去，结果仍然不可用，它将抛出一个
    `TimeoutException` 异常。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: See also
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a thread executor and controlling its rejected tasks*, *Running
    multiple tasks and processing the first result*, and *Running multiple tasks and
    processing all the results recipes* in this chapter
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*创建线程执行器并控制其拒绝的任务*、*运行多个任务并处理第一个结果*以及*运行多个任务并处理所有结果*的食谱
- en: Running multiple tasks and processing the first result
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个任务并处理第一个结果
- en: A common problem in concurrent programming arises when you have various concurrent
    tasks available to solve a problem, but you are only interested in the first result.
    For example, you want to sort an array. You have various sort algorithms. You
    can launch all of them and get the result of the first one that sorts the array,
    that is, the fastest sorting algorithm for a given array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，当您有各种并发任务可供解决问题，但您只对第一个结果感兴趣时，会出现一个常见问题。例如，您想对一个数组进行排序。您有多种排序算法。您可以启动所有这些算法，并获取第一个排序数组的算法的结果，即给定数组的最快排序算法。
- en: In this recipe, you will learn how to implement this scenario using the `ThreadPoolExecutor`
    class. You are going to use two mechanisms to try and validate a user. The user
    will be validated if one of these mechanisms is able to validate it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用 `ThreadPoolExecutor` 类实现此场景。您将使用两种机制来尝试验证用户。如果其中一种机制能够验证用户，则用户将被验证。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `UserValidator` that will implement the process of user
    validation:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `UserValidator` 的类，该类将实现用户验证的过程：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the user validation system:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `name` 的私有 `String` 属性，该属性将存储用户验证系统的名称：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the constructor of the class that initializes its attributes:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化其属性：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the `validate()` method. It receives two `String` parameters with
    the name and password of the user you want to validate:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为 `validate()` 的方法。它接收两个 `String` 参数，即您想要验证的用户的名字和密码：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a `Random` object named `random`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `random` 的 `Random` 对象：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Wait for a random period of time to simulate the process of user validation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待一个随机的时间段以模拟用户验证的过程：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Return a random `Boolean` value. The `validate()` method returns `true` when
    the user is validated, and `false` otherwise:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个随机的 `Boolean` 值。当用户被验证时，`validate()` 方法返回 `true`，否则返回 `false`：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement `getName()`. This method returns the value of the name attribute:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getName()`方法。此方法返回名称属性的值：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, create a class named `ValidatorTask` that will execute a validation process
    with the `UserValidation` object as a concurrent task. Specify that it implements
    the `Callable` interface parameterized by the `String` class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`ValidatorTask`的类，该类将以`UserValidation`对象作为并发任务执行验证过程。指定它实现了由`String`类参数化的`Callable`接口：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare a private `UserValidator` attribute named `validator`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`validator`的私有`UserValidator`属性：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare two private `String` attributes, named `user` and `password`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`user`和`password`的私有`String`属性：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the constructor of the class that will initialize all the attributes:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，该构造函数将初始化所有属性：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `call()` method that will return a `String` object:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将返回`String`对象的`call()`方法：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If the user is not validated by the `UserValidator` object, write a message
    to the console indicating this and throw `Exception`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户没有被`UserValidator`对象验证，向控制台发送一条消息表明这一点，并抛出`Exception`：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Otherwise, write a message to the console indicating that the user has been
    validated and return the name of the `UserValidator` object:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，向控制台发送一条消息，表明用户已验证，并返回`UserValidator`对象的名称：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now implement the main class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create two `String` objects named `user` and `password` and initialize them
    with the test value:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`user`和`password`的`String`对象，并用测试值初始化它们：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create two `UserValidator` objects, named `ldapValidator` and `dbValidator`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`ldapValidator`和`dbValidator`的`UserValidator`对象：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create two `TaskValidator` objects, named `ldapTask` and `dbTask`. Initialize
    them with `ldapValidator` and `dbValidator`, respectively:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`ldapTask`和`dbTask`的`TaskValidator`对象。分别用`ldapValidator`和`dbValidator`初始化它们：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a list of `TaskValidator` objects and add to it the two objects that
    you have created:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TaskValidator`对象列表，并将你创建的两个对象添加到其中：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a new `ThreadPoolExecutor` object using the `newCachedThreadPool()`
    method of the `Executors` class and a string variable named `result`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法和一个名为`result`的字符串变量创建一个新的`ThreadPoolExecutor`对象：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Call the `invokeAny()` method of the executor object. This method receives
    `taskList` as a parameter and returns `String`. Also, it writes the `String` object
    that is returned to the console:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用执行器对象的`invokeAny()`方法。此方法接收`taskList`作为参数，并返回`String`。同时，它将返回的`String`对象写入控制台：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Terminate the executor using the `shutdown()` method and write a message to
    the console to indicate that the program has ended:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法终止执行器，并向控制台发送一条消息，表明程序已结束：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of the example is in the `Main` class. The `invokeAny()` method of the
    `ThreadPoolExecutor` class receives a list of tasks, then launches them, and returns
    the result of the first task that finishes without throwing an exception. This
    method returns the same data type that the `call()` method of the tasks returns.
    In this case, it returned a `String` value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的关键在`Main`类中。`ThreadPoolExecutor`类的`invokeAny()`方法接收一个任务列表，然后启动它们，并返回第一个完成且未抛出异常的任务的结果。此方法返回与任务`call()`方法返回的数据类型相同。在这种情况下，它返回了一个`String`值。
- en: 'The following screenshot shows the output of an execution of the example when
    one of the tasks validates the user:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当其中一个任务验证用户时的示例执行输出：
- en: '![](img/00028.gif)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.gif)'
- en: The example has two `UserValidator` objects that return a random Boolean value.
    Each `UserValidator` object is used by a `Callable` object, implemented by the
    `TaskValidator` class. If the `validate()` method of the `UserValidator` class
    returns a false value, the `TaskValidator` class throws `Exception`. Otherwise,
    it returns the `true` value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 示例有两个返回随机布尔值的`UserValidator`对象。每个`UserValidator`对象由`TaskValidator`类实现的`Callable`对象使用。如果`UserValidator`类的`validate()`方法返回一个假值，则`TaskValidator`类抛出`Exception`。否则，它返回`true`值。
- en: 'So, we have two tasks that can return the `true` value or throw `Exception`.
    You can have the following four possibilities:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个可以返回`true`值或抛出`Exception`的任务。你可以有以下四种可能性：
- en: Both tasks return the `true` value. Here, the result of the `invokeAny()` method
    is the name of the task that finishes in the first place.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个任务都返回`true`值。在这里，`invokeAny()`方法的结果是首先完成的任务名称。
- en: The first task returns the `true` value and the second one throws `Exception`.
    Here, the result of the `invokeAny()` method is the name of the first task.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务返回`true`值，而第二个任务抛出`Exception`。在这里，`invokeAny()`方法的结果是第一个任务的名字。
- en: The first task throws `Exception` and the second one returns the `true` value.
    Here, the result of the `invokeAny()` method is the name of the second task.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务抛出`Exception`，而第二个任务返回`true`值。在这里，`invokeAny()`方法的结果是第二个任务的名字。
- en: Both tasks throw `Exception`. In such a class, the `invokeAny()` method throws
    an `ExecutionException` exception.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个任务都抛出`Exception`。在这个类中，`invokeAny()`方法抛出`ExecutionException`异常。
- en: If you run the examples several times, you will get each of the four possible
    solutions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行示例，你将得到四种可能解决方案中的每一个。
- en: 'The following screenshot shows the output of the application when both the
    tasks throw an exception:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当两个任务都抛出异常时应用程序的输出：
- en: '![](img/00029.gif)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00029.gif)'
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ThreadPoolExecutor` class provides another version of the `invokeAny()`
    method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类提供了`invokeAny()`方法的另一个版本：'
- en: '`invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method executes all the tasks and returns the result of the first
    one that finishes without throwing an exception, if it does so before the given
    timeout is passed. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`：此方法执行所有任务，并在给定超时之前，如果没有抛出异常，返回第一个完成任务的的结果。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: See also
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Running multiple tasks and processing all the results* recipe in this chapter
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*运行多个任务并处理所有结果*菜谱
- en: Running multiple tasks and processing all the results
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个任务并处理所有结果
- en: The `Executor` framework allows you to execute concurrent tasks without worrying
    about thread creation and execution. It provides you with the `Future` class,
    which you can use to control the status and get the results of any task executed
    in an executor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`框架允许你在不担心线程创建和执行的情况下执行并发任务。它为你提供了`Future`类，你可以使用这个类来控制任务的状态并获取在执行器中执行的任务的结果。'
- en: 'When you want to wait for the finalization of a task, you can use the following
    two methods:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要等待一个任务的最终完成时，你可以使用以下两种方法：
- en: The `isDone()` method of the `Future` interface returns `true` if the task has
    finished its execution
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`接口的`isDone()`方法如果任务已完成其执行，则返回`true`。'
- en: The `awaitTermination()` method of the `ThreadPoolExecutor` class puts the thread
    to sleep until all the tasks have finished their execution after a call to the
    `shutdown()` method
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类的`awaitTermination()`方法在调用`shutdown()`方法后，将线程置于休眠状态，直到所有任务完成执行。'
- en: These two methods have some drawbacks. With the first one, you can only control
    the completion of a task. With the second one, you have to shut down the executor
    to wait for a thread; otherwise, the method's call is returned immediately.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法有一些缺点。使用第一种方法，你只能控制任务的完成。使用第二种方法，你必须关闭执行器以等待线程；否则，方法的调用将立即返回。
- en: The `ThreadPoolExecutor` class provides a method that allows you to send a list
    of tasks to the executor and wait for the finalization of all the tasks in the
    list. In this recipe, you will learn how to use this feature by implementing an
    example with 10 tasks executed and their results printed out when they have finished.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类提供了一个方法，允许你向执行器发送一个任务列表，并等待列表中所有任务的最终完成。在这个菜谱中，你将通过实现一个包含10个任务执行并打印它们完成后的结果的示例来学习如何使用这个功能。'
- en: Getting ready
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例已经使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Result` to store the results generated in the concurrent
    tasks of this example:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Result`的类来存储这个示例中并发任务生成的结果：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare two private attributes, namely a `String` attribute called `name` and
    an `int` attribute named `value`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有属性，即一个名为`name`的`String`属性和一个名为`value`的`int`属性：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the corresponding `get()` and `set()` methods to set and return the
    value of the name and value attributes:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现相应的`get()`和`set()`方法以设置和返回名称和值属性：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a class named `Task` that implements the `Callable` interface parameterized
    by the `Result` class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类实现了由`Result`类参数化的`Callable`接口：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Declare a private `String` attribute called `name`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the constructor of the class that initializes its attribute:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the `call()` method of the class. In this case, the method will return
    a `Result` object:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`call()`方法。在这种情况下，该方法将返回一个`Result`对象：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'First, write a message to the console to indicate that the task is getting
    started:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向控制台发送一条消息以指示任务开始：
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, wait for a random period of time:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，等待一个随机的时间段：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To generate an `int` value to be returned in the `Result` object, calculate
    the sum of five random numbers:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在`Result`对象中返回一个`int`值，计算五个随机数的总和：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create a `Result` object and initialize it with the name of this `Task` object
    and the result of the operation done earlier:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Result`对象并用此`Task`对象的名称和之前执行的操作的结果初始化它：
- en: '[PRE75]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Write a message to the console to indicate that the task has finished:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台发送一条消息以指示任务已完成：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Return the `Result` object:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`Result`对象：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE78]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个`ThreadPoolExecutor`对象：
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a list of `Task` objects. Create 10 `Task` objects and save them on
    this list:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象的列表。创建10个`Task`对象并将它们保存在这个列表中：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a list of `Future` objects. These objects are parameterized by the `Result`
    class:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Future`对象列表。这些对象由`Result`类参数化：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Call the `invokeAll()` method of the `ThreadPoolExecutor` class. This class
    will return the list of the `Future` objects created earlier:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ThreadPoolExecutor`类的`invokeAll()`方法。这个类将返回之前创建的`Future`对象列表：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finalize the executor using the `shutdown()` method:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法终止执行器：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Write the results of the tasks processing the list of `Future` objects:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理`Future`对象列表的任务结果写入控制台：
- en: '[PRE84]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you learned how to send a list of tasks to an executor and wait
    for the finalization of all of them using the `invokeAll()` method. This method
    receives a list of `Callable` objects and returns a list of `Future` objects.
    This list will have a `Future` object per task. The first object in the list of
    `Future` objects will be the object that controls the first task in the list of
    `Callable` objects, the second object the second task, and so on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你学习了如何使用`invokeAll()`方法将任务列表发送到执行器，并等待所有任务的最终完成。该方法接收一个`Callable`对象列表，并返回一个`Future`对象列表。这个列表将包含每个任务的`Future`对象。`Future`对象列表中的第一个对象将控制`Callable`对象列表中的第一个任务，第二个对象控制第二个任务，依此类推。
- en: 'The first point to take into consideration is that the type of data used for
    the parameterization of the `Future` interface in the declaration of the list
    that stores the result objects must be compatible with the one used to parameterize
    `Callable` objects. In this case, you used the same type of data: the `Result`
    class.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是，用于声明存储结果对象的列表中`Future`接口参数化的数据类型必须与用于参数化`Callable`对象的数据类型兼容。在这种情况下，你使用了相同的数据类型：`Result`类。
- en: Another important point about the `invokeAll()` method is that you will use
    `Future` objects only to get the results of the tasks. As the method finishes
    when all the tasks finish, if you call the `isDone()` method of `Future` objects
    that are returned, all the calls will return the true value.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`invokeAll()`方法的一个重要观点是，你将仅使用`Future`对象来获取任务的结果。因为当所有任务完成时，该方法才会结束，所以如果你调用返回的`Future`对象的`isDone()`方法，所有调用都将返回true值。
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ExecutorService` class provides another version of the `invokeAll()` method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`类提供了`invokeAll()`方法的另一个版本：'
- en: '`invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: This method executes all the tasks and returns the result of their execution
    when all of them are finished, that is, if they finish before the given timeout
    has passed. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
    unit)`: 此方法执行所有任务，并在所有任务完成时返回它们的执行结果，即如果它们在给定的超时时间之前完成。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: See also
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Executing tasks in an executor that returns a result* and *Running multiple
    tasks and processing the first result* recipes in this chapter
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *在返回结果的执行器中执行任务* 和 *运行多个任务并处理第一个结果* 菜单
- en: Running a task in an executor after a delay
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在延迟后运行任务
- en: The `Executor` framework provides the `ThreadPoolExecutor` class to execute
    `Callable` and `Runnable` tasks with a pool of threads, which helps you avoid
    all thread creation operations. When you send a task to the executor, it's executed
    as soon as possible, according to the configuration of the executor. There are
    use cases when you are not interested in executing a task as soon as possible.
    You may want to execute a task after a period of time or do it periodically. For
    these purposes, the Executor framework provides the `ScheduledExecutorService`
    interface along with its implementation, namely the `ScheduledThreadPoolExecutor`
    class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 框架提供了 `ThreadPoolExecutor` 类，用于使用线程池执行 `Callable` 和 `Runnable` 任务，这有助于您避免所有线程创建操作。当您向执行器发送任务时，它会根据执行器的配置尽可能快地执行。在某些情况下，您可能不希望立即执行任务。您可能希望在一段时间后执行任务或定期执行。为此，Executor
    框架提供了 `ScheduledExecutorService` 接口及其实现，即 `ScheduledThreadPoolExecutor` 类。'
- en: In this recipe, you will learn how to create `ScheduledThreadPoolExecutor` and
    use it to schedule the execution of a task after a given period of time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，您将学习如何创建 `ScheduledThreadPoolExecutor` 并使用它来安排在给定时间后的任务执行。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` that implements the `Callable` interface parameterized
    by the `String` class:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，该类实现了由 `String` 类参数化的 `Callable` 接口：
- en: '[PRE85]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the task:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `name` 的私有 `String` 属性，用于存储任务的名称：
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Implement the constructor of the class that initializes the name attribute:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化名称属性：
- en: '[PRE87]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implement the `call()` method. Write a message to the console with the actual
    date and return some text, for example, `Hello, world`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该 `call()` 方法。向控制台发送一条包含实际日期的消息，并返回一些文本，例如，`Hello, world`：
- en: '[PRE88]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create an executor of the `ScheduledThreadPoolExecutor` class using the `newScheduledThreadPool()`
    method of the `Executors` class, passing `1` as a parameter:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Executors` 类的 `newScheduledThreadPool()` 方法创建一个 `ScheduledThreadPoolExecutor`
    类型的执行器，将 `1` 作为参数传递：
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Initialize and start a few tasks (five in our case) with the `schedule()` method
    of the `ScheduledThreadPoolExecutor` instance:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ScheduledThreadPoolExecutor` 实例的 `schedule()` 方法初始化和启动一些任务（在我们的例子中是五个）：
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Request the finalization of the executor using the `shutdown()` method:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法请求执行器的最终化：
- en: '[PRE92]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Wait for the finalization of all the tasks using the `awaitTermination()` method
    of the executor:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用执行器的 `awaitTermination()` 方法等待所有任务的最终化：
- en: '[PRE93]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Write a message to indicate the time when the program will finish:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序完成的时间：
- en: '[PRE94]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key point of this example is the `Main` class and the management of `ScheduledThreadPoolExecutor`.
    As with the `ThreadPoolExecutor` class, to create a scheduled executor, Java recommends
    that you utilize the `Executors` class. In this case, you used the `newScheduledThreadPool()`
    method. You passed the number `1` as a parameter to this method. This parameter
    refers to the number of threads you want to have in the pool.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的关键点是`Main`类和`ScheduledThreadPoolExecutor`的管理。与`ThreadPoolExecutor`类一样，要创建预定执行器，Java建议您使用`Executors`类。在这种情况下，您使用了`newScheduledThreadPool()`方法。您将数字`1`作为参数传递给此方法。此参数指的是您想要在池中拥有的线程数。
- en: 'To execute a task in this scheduled executor after a period of time, you have
    to use the `schedule()` method. This method receives the following three parameters:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要在预定执行器中经过一段时间后执行任务，您必须使用`schedule()`方法。此方法接收以下三个参数：
- en: The task you want to execute
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要执行的任务
- en: The period of time you want the task to wait before its execution
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务在执行前需要等待的时间段
- en: The unit of the period of time, specified as a constant of the `TimeUnit` class
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间段的单位，指定为`TimeUnit`类的常量
- en: In this case, each task will wait for a number of seconds (`TimeUnit.SECONDS`)
    equal to its position in the array of tasks plus one.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个任务将等待与任务数组中的位置相等的秒数（`TimeUnit.SECONDS`）加一。
- en: If you want to execute a task at a given time, calculate the difference between
    that date and the current date and use the difference as the delay of the task.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在特定时间执行任务，计算该日期与当前日期之间的差异，并使用该差异作为任务的延迟。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行输出：
- en: '![](img/00030.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00030.jpeg)'
- en: You can see how the tasks start their execution, one per second. All the tasks
    are sent to the executor at the same time but with a delay of 1 second later than
    the previous task.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到任务是如何开始执行的，每个任务每秒一个。所有任务都是同时发送到执行器，但比前一个任务晚1秒。
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can also use the `Runnable` interface to implement the tasks because the
    `schedule()` method of the `ScheduledThreadPoolExecutor` class accepts both types
    of tasks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Runnable`接口来实现任务，因为`ScheduledThreadPoolExecutor`类的`schedule()`方法接受这两种类型的任务。
- en: Although the `ScheduledThreadPoolExecutor` class is a child class of the `ThreadPoolExecutor`
    class (and therefore inherits all its features), Java recommends that you use
    `ScheduledThreadPoolExecutor` only for scheduled tasks.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`ScheduledThreadPoolExecutor`类是`ThreadPoolExecutor`类的子类（因此继承了所有其功能），但Java建议您仅使用`ScheduledThreadPoolExecutor`类来执行预定任务。
- en: Finally, you can configure the behavior of the `ScheduledThreadPoolExecutor`
    class when you call the `shutdown()` method, and there are pending tasks waiting
    for the end of their delay time. The default behavior is that these tasks will
    be executed despite the finalization of the executor. You can change this behavior
    using the `setExecuteExistingDelayedTasksAfterShutdownPolicy()` method of the
    `ScheduledThreadPoolExecutor` class. If you call the `setExecuteExistingDelayedTasksAfeterShutdownsPolicy()` passing
    the `false` value as parameter, pending tasks won't be executed after you call
    the `shutdown()` method.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您调用`shutdown()`方法时，您可以配置`ScheduledThreadPoolExecutor`类的行为，并且有挂起的任务正在等待它们的延迟时间结束。默认行为是，即使执行器最终化，这些任务也会被执行。您可以使用`ScheduledThreadPoolExecutor`类的`setExecuteExistingDelayedTasksAfterShutdownPolicy()`方法更改此行为。如果您将`setExecuteExistingDelayedTasksAfterShutdownsPolicy()`方法调用为传递`false`作为参数，则在调用`shutdown()`方法后，挂起的任务将不会执行。
- en: See also
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于“在返回结果的执行器中执行任务”的配方
- en: Running a task in an executor periodically
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行器中定期运行任务
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute concurrent
    tasks using a pool of threads that helps you avoid all thread creation operations.
    When you send a task to the executor, it executes the task as soon as possible
    according to its configuration. When it ends, the task is deleted from the executor,
    and if you want to execute it again, you have to send it to the executor again.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架提供了`ThreadPoolExecutor`类，用于使用线程池执行并发任务，这有助于您避免所有线程创建操作。当您向执行器发送任务时，它会根据其配置尽可能快地执行任务。当任务结束时，任务将从执行器中删除，如果您想再次执行它，您必须再次将其发送到执行器。
- en: However, the Executor framework provides the possibility of executing periodic
    tasks through the `ScheduledThreadPoolExecutor` class. In this recipe, you will
    learn how to use this functionality of the class to schedule a periodic task.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Executor框架通过`ScheduledThreadPoolExecutor`类提供了执行周期性任务的可能性。在这个菜谱中，你将学习如何使用这个类的这个功能来安排周期性任务。
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口：
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Declare a private `String` attribute called `name` that will store the name
    of the task:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性，该属性将存储任务的名称：
- en: '[PRE96]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Implement the constructor of the class that initializes the attribute:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化属性：
- en: '[PRE97]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Implement the `run()` method. Write a message to the console with the actual
    date to verify that the task is executed within the specified period:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。向控制台写入实际日期的消息以验证任务是否在指定期间执行：
- en: '[PRE98]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE99]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Create `ScheduledExecutorService` using the `newScheduledThreadPool()` method
    of the `Executors` class. Pass `1` to this method as a parameter:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newScheduledThreadPool()`方法创建`ScheduledExecutorService`。将`1`作为参数传递给这个方法：
- en: '[PRE100]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Write a message to the console with the actual date:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入实际日期的消息：
- en: '[PRE101]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create a new `Task` object:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象：
- en: '[PRE102]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Send this object to the executor using the `scheduledAtFixRate()` method. Use
    the tasks created earlier as parameters: the number one, the number two, and the
    constant `TimeUnit.SECONDS`. This method returns a `ScheduledFuture` object that
    you can use to control the status of the task:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scheduledAtFixRate()`方法将此对象发送到executor。使用之前创建的任务作为参数：第一个数字、第二个数字和`TimeUnit.SECONDS`常量。此方法返回一个`ScheduledFuture`对象，你可以使用它来控制任务的状态：
- en: '[PRE103]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Create a loop with 10 steps to write the time remaining for the next execution
    of the task. In the loop, use the `getDelay()` method of the `ScheduledFuture`
    object to get the number of milliseconds until the next execution of the task:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用10步循环来编写下一次任务执行剩余时间。在循环中，使用`ScheduledFuture`对象的`getDelay()`方法来获取下一次任务执行前的毫秒数：
- en: '[PRE104]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Sleep the thread during 500 milliseconds.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程休眠500毫秒。
- en: '[PRE105]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Finish the executor using the `shutdown()` method:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法结束executor：
- en: '[PRE106]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Put the thread to sleep for 5 seconds to verify that the periodic tasks have
    finished:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠5秒以验证周期性任务已完成：
- en: '[PRE107]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Write a message to indicate the end of the program:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序结束：
- en: '[PRE108]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you want to execute a periodic task using the Executor framework, you need
    a `ScheduledExecutorService` object. To create it (as with every executor), Java
    recommends the use of the `Executors` class. This class works as a factory of
    executor objects. In this case, you used the `newScheduledThreadPool()` method
    to create a `ScheduledExecutorService` object. This method receives the number
    of threads of the pool as a parameter. Since you had only one task in this example,
    you passed `1` as a parameter.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用Executor框架执行周期性任务时，你需要一个`ScheduledExecutorService`对象。为了创建它（就像创建每个executor一样），Java推荐使用`Executors`类。这个类作为executor对象的工厂。在这种情况下，你使用了`newScheduledThreadPool()`方法来创建一个`ScheduledExecutorService`对象。这个方法接收池中线程的数量作为参数。由于在这个例子中只有一个任务，你传递了`1`作为参数。
- en: 'Once you had the executor needed to execute a periodic task, you sent the task
    to the executor. You used the `scheduledAtFixedRate()` method. This method accepts
    four parameters: the task you want to execute periodically, the delay of time
    until the first execution of the task, the period between two executions, and
    the time unit of the second and third parameters. It''s a constant of the `TimeUnit`
    class. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了执行周期性任务所需的执行器，你就将任务发送到执行器。你使用了`scheduledAtFixedRate()`方法。此方法接受四个参数：你想要周期性执行的任务、任务首次执行前的延迟时间、两次执行之间的周期，以及第二和第三个参数的时间单位。它是`TimeUnit`类的一个常量。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。
- en: An important point to consider is that the period between two executions is
    the period of time between the start of those two executions. If you have a periodic
    task that takes 5 seconds to execute and you put in a period of 3 seconds, you
    will have two instances of the task executing at a time.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要考虑的重要点是，两次执行之间的周期是这两个执行开始之间的时间间隔。如果你有一个执行时间为5秒的周期性任务，并且你设置了3秒的周期，你将同时有两个任务实例在执行。
- en: The `scheduleAtFixedRate()` method returns a `ScheduledFuture` object, which
    extends the `Future` interface, with methods to work with scheduled tasks. `ScheduledFuture`
    is a parameterized interface. In this example, as your task was a `Runnable` object
    that was not parameterized, you had to parameterize them with the `?` symbol as
    a parameter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduleAtFixedRate()`方法返回一个`ScheduledFuture`对象，它扩展了`Future`接口，并具有处理计划任务的方法。`ScheduledFuture`是一个参数化接口。在这个例子中，由于你的任务是一个未参数化的`Runnable`对象，你必须使用`?`符号作为参数来参数化它们。'
- en: You used one method of the `ScheduledFuture` interface. The `getDelay()` method
    returns the time until the next execution of the task. This method receives a
    `TimeUnit` constant with the time unit in which you want to receive the results.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了`ScheduledFuture`接口的一个方法。`getDelay()`方法返回任务下一次执行的时间。此方法接收一个`TimeUnit`常量，表示你想要接收结果的时间单位。
- en: 'The following screenshot shows the output of an execution of the example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例执行的输出：
- en: '![](img/00031.jpeg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'You can see the task being executed every 2 seconds (denoted by Task: prefix)
    and the delay written in the console every 500 milliseconds. That''s how long
    the main thread has been put to sleep. When you shut down the executor, the scheduled
    task ends its execution and you don''t see any more messages in the console.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到任务每2秒执行一次（以Task: 前缀表示）和每500毫秒在控制台写入的延迟。这就是主线程被休眠的时间。当你关闭执行器时，计划中的任务结束执行，你将不再在控制台看到任何消息。'
- en: There's more...
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: '`ScheduledThreadPoolExecutor` provides other methods to schedule periodic tasks.
    It is the `scheduleWithFixedRate()` method. It has the same parameters as the
    `scheduledAtFixedRate()` method, but there is a difference worth noticing. In
    the `scheduledAtFixedRate()` method, the third parameter determines the period
    of time between the starting of two executions. In the `scheduledWithFixedRate()`
    method, the parameter determines the period of time between the end of an execution
    of the task and its beginning.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`提供了其他方法来安排周期性任务。它是`scheduleWithFixedRate()`方法。它具有与`scheduledAtFixedRate()`方法相同的参数，但有一个值得注意的差异。在`scheduledAtFixedRate()`方法中，第三个参数确定两次执行开始之间的时间间隔。在`scheduledWithFixedRate()`方法中，参数确定任务执行结束和开始之间的时间间隔。'
- en: You can also configure the behavior of an instance of the `ScheduledThreadPoolExecutor`
    class with the `shutdown()` method. The default behavior is that the scheduled
    tasks finish when you call this method. You can change this behavior using the
    `setContinueExistingPeriodicTasksAfterShutdownPolicy()` method of the `ScheduledThreadPoolExecutor`
    class with a true value. Periodic tasks won't finish upon calling the `shutdown()`
    method.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`shutdown()`方法配置`ScheduledThreadPoolExecutor`类的实例的行为。默认行为是在你调用此方法时，计划中的任务完成。你可以使用`ScheduledThreadPoolExecutor`类的`setContinueExistingPeriodicTasksAfterShutdownPolicy()`方法通过传递一个true值来更改此行为。周期性任务在调用`shutdown()`方法时不会结束。
- en: See also
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a thread executor and controlling its rejected tasks* and *Running
    a task in an executor after a delay *recipes in this chapter
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建线程执行器并控制其拒绝的任务*和*在执行器中延迟运行任务*的食谱
- en: Canceling a task in an executor
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行器中取消任务
- en: When you work with an executor, you don't have to manage threads. You only implement
    `Runnable` or `Callable` tasks and send them to the executor. It's the executor
    that's responsible for creating threads, managing them in a thread pool, and finishing
    them if they are not needed. Sometimes, you may want to cancel a task that you
    send to the executor. In that case, you can use the `cancel()` method of `Future`,
    which allows you to make the cancelation operation. In this recipe, you will learn
    how to use this method to cancel tasks that you have sent to an executor.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与执行器一起工作时，您不需要管理线程。您只需实现 `Runnable` 或 `Callable` 任务并将它们发送到执行器。执行器负责创建线程、在线程池中管理它们，并在不需要时结束它们。有时，您可能想要取消发送到执行器的任务。在这种情况下，您可以使用
    `Future` 的 `cancel()` 方法，这允许您执行取消操作。在本菜谱中，您将学习如何使用此方法取消发送到执行器的任务。
- en: Getting ready
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` and specify that it implements the `Callable` interface
    parameterized by the `String` class. Implement the `call()` method. Write a message
    to the console and put it to sleep for `100` milliseconds inside an infinite loop:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现由 `String` 类参数化的 `Callable` 接口。实现 `call()` 方法。在无限循环中向控制台写入一条消息，并使其休眠
    `100` 毫秒：
- en: '[PRE109]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE110]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Executors` 类的 `newCachedThreadPool()` 方法创建一个 `ThreadPoolExecutor` 对象：
- en: '[PRE111]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create a new `Task` object:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Task` 对象：
- en: '[PRE112]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Send the task to the executor using the `submit()` method:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `submit()` 方法将任务发送到执行器：
- en: '[PRE113]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Put the main task to sleep for 2 seconds:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使主任务休眠 2 秒：
- en: '[PRE114]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Cancel the execution of the task using the `cancel()` method of the `Future`
    object, named `result`, returned by the `submit()` method. Pass the true value
    as a parameter of the `cancel()` method:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `result` 对象的 `cancel()` 方法取消任务的执行，`result` 是由 `submit()` 方法返回的 `Future` 对象。将
    true 值作为 `cancel()` 方法的参数传递：
- en: '[PRE115]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Write the result of a call to the `isCancelled()` and `isDone()` methods to
    the console. This is to verify that the task has been canceled, and hence, already
    done:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对 `isCancelled()` 和 `isDone()` 方法的调用结果写入控制台。这是为了验证任务已被取消，因此已经完成：
- en: '[PRE116]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finish the executor with the `shutdown()` method and write a message indicating
    the finalization of the program:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法结束执行器，并写入一条消息以指示程序的最终化：
- en: '[PRE117]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You use the `cancel()` method of the `Future` interface when you want to cancel
    a task that you have sent to an executor. Depending on the parameter of the `cancel()`
    method and the status of the task, the behavior of this method is different:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要取消发送到执行器的任务时，您使用 `Future` 接口的 `cancel()` 方法。根据 `cancel()` 方法的参数和任务的状态，此方法的行为不同：
- en: If the task has finished or has been canceled earlier, or it can't be cancelled
    due to any other reason, the method will return the `false` value and the task
    won't be canceled.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务已完成或之前已被取消，或者由于任何其他原因无法取消，则方法将返回 `false` 值，并且任务不会被取消。
- en: If the task is waiting in the executor to get a `Thread` object that will execute
    it, the task is canceled and will never begin its execution. If the task is already
    running, it depends on the parameter of the method. The `cancel()` method receives
    a Boolean value as a parameter. If the value of this parameter is `true` and the
    task is running, it will be canceled. If the value of the parameter is false and
    the task is running, it won't be canceled.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任务正在执行器中等待获取执行它的 `Thread` 对象，则任务将被取消，并且永远不会开始执行。如果任务已经在运行，则取决于方法参数。`cancel()`
    方法接收一个布尔值作为参数。如果此参数的值为 `true` 且任务正在运行，则任务将被取消。如果参数的值为 `false` 且任务正在运行，则任务不会被取消。
- en: 'The following screenshot shows the output of an execution of this example:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行输出：
- en: '![](img/00032.jpeg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: There's more...
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: If you use the `get()` method of a `Future` object that controls a task that
    has been canceled, the `get()` method will throw a `CancellationException` exception.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用控制已取消任务的 `Future` 对象的 `get()` 方法，`get()` 方法将抛出 `CancellationException`
    异常。
- en: See also
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于 *在执行器中执行返回结果的任务* 的配方
- en: Controlling a task finishing in an executor
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制在执行器中完成任务的执行
- en: The Java API provides the `FutureTask` class as a cancelable asynchronous computation.
    It implements the `Runnable` and `Future` interfaces and provides the basic implementation
    of the `Future` interface. We can create a `FutureTask` class using a `Callable`
    or `Runnable` object `(Runnable` objects doesn't return a result, so we have to
    pass as parameter too in this case the result that the `Future` object will return).
    It provides methods to cancel the execution and obtain the result of the computation.
    It also provides a method called `done()` that allows you to execute some code
    after the finalization of a task executed in an executor. It can be used to make
    some postprocess operations, such as generating a report, sending results by e-mail,
    or releasing some resources. This method is called internally by the `FutureTask`
    class when the execution of the task that this `FutureTask` object is controlling
    finishes. The method is called after the result of the task is set and its status
    is changed to `isDone`, regardless of whether the task has been canceled or finished
    normally.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 提供了 `FutureTask` 类作为可取消的异步计算。它实现了 `Runnable` 和 `Future` 接口，并提供了 `Future`
    接口的基本实现。我们可以使用 `Callable` 或 `Runnable` 对象（`Runnable` 对象不返回结果，因此在这种情况下我们必须传递 `Future`
    对象将返回的结果作为参数）。它提供了取消执行和获取计算结果的方法。它还提供了一个名为 `done()` 的方法，允许你在执行器中执行的任务最终化后执行一些代码。它可以用来进行一些后处理操作，例如生成报告、通过电子邮件发送结果或释放一些资源。当
    `FutureTask` 类内部调用控制此 `FutureTask` 对象的任务执行完成时，将调用此方法。该方法在设置任务的结果并将其状态更改为 `isDone`
    后调用，无论任务是否已取消或正常完成。
- en: By default, this method is empty. You can override the `FutureTask` class and
    implement this method to change the behavior. In this recipe, you will learn how
    to override this method to execute code after the finalization of the tasks.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此方法为空。你可以覆盖 `FutureTask` 类并实现此方法以更改行为。在本配方中，你将学习如何覆盖此方法以在任务最终化后执行代码。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `ExecutableTask` and specify that it implements the `Callable`
    interface parameterized by the `String` class:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ExecutableTask` 的类，并指定它实现由 `String` 类参数化的 `Callable` 接口：
- en: '[PRE118]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Declare a private `String` attribute called `name`. It will store the name
    of the task. Implement the `getName()` method to return the value of this attribute:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `name` 的私有 `String` 属性。它将存储任务的名称。实现 `getName()` 方法以返回此属性的值：
- en: '[PRE119]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implement the constructor of the class to initialize the name of the task:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化任务的名称：
- en: '[PRE120]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Implement the `call()` method. Put the task to sleep for a random period of
    time and return a message with the name of the task:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的 `call()` 方法。让任务随机休眠一段时间，并返回一个包含任务名称的消息：
- en: '[PRE121]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Implement a class named `ResultTask` that extends the `FutureTask` class parameterized
    by the `String` class:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `ResultTask` 的类，该类扩展了由 `String` 类参数化的 `FutureTask` 类：
- en: '[PRE122]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Declare a private `String` attribute called `name`. It will store the name
    of the task:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `name` 的私有 `String` 属性。它将存储任务的名称：
- en: '[PRE123]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Implement the constructor of the class. It has to receive a `Callable` object
    as a parameter. Call the constructor of the parent class and initialize the name
    attribute using the attribute of the task received:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它必须接收一个 `Callable` 对象作为参数。调用父类的构造函数并使用接收到的任务属性初始化 `name` 属性：
- en: '[PRE124]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Override the `done()` method. Check the value of the `isCancelled()` method
    and write a different message to the console, depending on the returned value:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `done()` 方法。检查 `isCancelled()` 方法的值，并根据返回值向控制台写入不同的消息：
- en: '[PRE125]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE126]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Create `ExecutorService` using the `newCachedThreadPool()` method of the `Executors`
    class:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建`ExecutorService`：
- en: '[PRE127]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Create an array to store five `ResultTask` objects:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数组来存储五个`ResultTask`对象：
- en: '[PRE128]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Initialize the `ResultTask` objects. For each position in the array, first
    you have to create `ExecutorTask` and then `ResultTask` using the object. Then,
    send `ResultTask` to the executor using the `submit()` method:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`ResultTask`对象。对于数组中的每个位置，首先你必须使用该对象创建`ExecutorTask`然后创建`ResultTask`。然后，使用`submit()`方法将`ResultTask`发送到执行器：
- en: '[PRE129]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Put the main thread to sleep for 5 seconds:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主线程休眠5秒：
- en: '[PRE130]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Cancel all the tasks you have sent to the executor:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消你发送到执行器的所有任务：
- en: '[PRE131]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Write the result of those tasks that haven''t been canceled to the console,
    using the `get()` method of the `ResultTask` objects:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ResultTask`对象的`get()`方法将那些未被取消的任务的结果写入控制台：
- en: '[PRE132]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Finish the executor using the `shutdown()` method:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法结束执行器：
- en: '[PRE133]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: How it works...
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `done()` method is called by the `FutureTask` class when the task that is
    being controlled finishes its execution. In this example, you implemented a `Callable`
    object, the `ExecutableTask` class, and then a subclass of the `FutureTask` class
    that controls the execution of the `ExecutableTask` objects.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当被控制的任务完成执行时，`FutureTask`类会调用`done()`方法。在这个例子中，你实现了`Callable`对象，`ExecutableTask`类，然后是控制`ExecutableTask`对象执行的`FutureTask`类的子类。
- en: The `done()` method is called internally by the `FutureTask` class after establishing
    the return value and changing the status of the task to `isDone`. You can't change
    the result value of the task or change its status, but you can close resources
    used by the task, write log messages, or send notifications. The `FutureTask`
    class might be used to ensure that a specific task is run only once, as calling
    its `run()` method will execute its wrapped `Runnable`/`Callable` interface only
    once (and the result can be fetched with `get` when it's available).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`done()`方法在`FutureTask`类内部被调用，在建立返回值并更改任务状态为`isDone`之后。你不能更改任务的结果值或更改其状态，但你可以关闭任务使用的资源，写入日志消息或发送通知。`FutureTask`类可以用来确保一个特定的任务只运行一次，因为调用它的`run()`方法将只执行其包装的`Runnable`/`Callable`接口一次（当结果可用时，可以使用`get`方法获取结果）。'
- en: See also
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*在执行器中执行返回结果的任务*菜谱
- en: Separating the launching of tasks and the processing of their results in an
    executor
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行器中分离任务的启动和结果的处理
- en: Normally, when you execute concurrent tasks using an executor, you will send
    `Runnable` or `Callable` tasks to the executor and get `Future` objects to control
    the method. You can find situations where you need to send the tasks to the executor
    in one object and process the results in another one. For such situations, the
    Java Concurrency API provides the `CompletionService` class.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你使用执行器执行并发任务时，你会向执行器发送`Runnable`或`Callable`任务，并获取`Future`对象来控制方法。你可以找到需要将任务发送到执行器在一个对象中，并在另一个对象中处理结果的情况。对于这种情况，Java并发API提供了`CompletionService`类。
- en: The `CompletionService` class has a method to send tasks to an executor and
    a method to get the `Future` object for the next task that has finished its execution.
    Internally, it uses an `Executor` object to execute the tasks. This behavior has
    the advantage of sharing a `CompletionService` object and sending tasks to the
    executor so others can process the results. The limitation is that the second
    object can only get the `Future` objects for those tasks that have finished their
    execution, so these Future objects can only be used to get the results of the
    tasks.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionService`类有一个方法可以发送任务到执行器，还有一个方法可以获取已完成执行的下个任务的`Future`对象。内部，它使用一个`Executor`对象来执行任务。这种行为的好处是共享一个`CompletionService`对象并将任务发送到执行器，以便其他人可以处理结果。限制是第二个对象只能获取已完成执行的任务的`Future`对象，因此这些`Future`对象只能用来获取任务的结果。'
- en: In this recipe, you will learn how to use the `CompletionService` class to separate
    the process of launching tasks in an executor from the processing of their results.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`CompletionService`类来分离在执行器中启动任务的过程和其结果的处理。
- en: Getting ready
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `ReportGenerator` and specify that it implements the `Callable`
    interface parameterized by the `String` class:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ReportGenerator` 的类，并指定它实现由 `String` 类参数化的 `Callable` 接口：
- en: '[PRE134]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Declare two private `String` attributes named `sender` and `title`. These attributes
    will represent the data of the report:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `sender` 和 `title` 的私有 `String` 属性。这些属性将代表报告的数据：
- en: '[PRE135]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Implement the constructor of the class that initializes the two attributes:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化两个属性：
- en: '[PRE136]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Implement the `call()` method. First, put the thread to sleep for a random
    period of time:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `call()` 方法。首先，让线程随机休眠一段时间：
- en: '[PRE137]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Then, generate the report as a string with the `sender` and `title` attributes
    and return that string:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `sender` 和 `title` 属性生成报告字符串，并返回该字符串：
- en: '[PRE138]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Create a class named `ReportRequest` and specify that it implements the `Runnable`
    interface. Thiss class will simulate some report requests:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ReportRequest` 的类，并指定它实现 `Runnable` 接口。此类将模拟一些报告请求：
- en: '[PRE139]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Declare a private `String` attribute called `name` to store the name of `ReportRequest`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `name` 的私有 `String` 属性，用于存储 `ReportRequest` 的名称：
- en: '[PRE140]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Declare a private `CompletionService` attribute named `service`. The `CompletionService`
    interface is a parameterized interface. Use the `String` class:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `service` 的私有 `CompletionService` 属性。`CompletionService` 接口是一个参数化接口。使用
    `String` 类：
- en: '[PRE141]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Implement the constructor of the class that initializes the two attributes:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化两个属性：
- en: '[PRE142]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Implement the `run()` method. Create three `ReportGenerator` objects and send
    them to the `CompletionService` object using the `submit()` method:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。创建三个 `ReportGenerator` 对象，并使用 `submit()` 方法将它们发送到 `CompletionService`
    对象：
- en: '[PRE143]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Create a class named `ReportProcessor`. This class will get the results of
    the `ReportGenerator` tasks. Specify that it implements the `Runnable` interface:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ReportProcessor` 的类。此类将获取 `ReportGenerator` 任务的输出。指定它实现 `Runnable` 接口：
- en: '[PRE144]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Declare a private `CompletionService` attribute named `service`. As the `CompletionService`
    interface is a parameterized interface, use the `String` class as a parameter
    of this `CompletionService` interface:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `service` 的私有 `CompletionService` 属性。由于 `CompletionService` 接口是一个参数化接口，因此使用
    `String` 类作为此 `CompletionService` 接口的参数：
- en: '[PRE145]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Declare a private `Boolean` attribute named `end`. Add the `volatile` keyword
    to ensure that all the threads have access to the actual value of the attribute:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `end` 的私有 `Boolean` 属性。添加 `volatile` 关键字以确保所有线程都能访问属性的真正值：
- en: '[PRE146]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Implement the constructor of the class to initialize the two attributes:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化两个属性：
- en: '[PRE147]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Implement the `run()` method. While the `end` attribute is false, call the
    `poll()` method of the `CompletionService` interface to get the `Future` object
    of the next task executed by the completion service that has finished:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。当 `end` 属性为 `false` 时，调用 `CompletionService` 接口的 `poll()` 方法以获取完成服务已执行的任务的下一个
    `Future` 对象：
- en: '[PRE148]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Then, get the results of the task using the `get()` method of the `Future`
    object and write the results to the console:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `Future` 对象的 `get()` 方法获取任务的输出，并将结果写入控制台：
- en: '[PRE149]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Implement the `stopProcessing()` method that modifies the value of the `end`
    attribute:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个修改 `end` 属性值的 `stopProcessing()` 方法：
- en: '[PRE150]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE151]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Executors` 类的 `newCachedThreadPool()` 方法创建 `ThreadPoolExecutor`：
- en: '[PRE152]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Create `CompletionService` using the executor created earlier as a parameter
    of the constructor:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前创建的执行器作为构造函数的参数创建 `CompletionService`：
- en: '[PRE153]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Create two `ReportRequest` objects and the threads to execute them:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个 `ReportRequest` 对象和执行它们的线程：
- en: '[PRE154]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Create a `ReportProcessor` object and the thread to execute it:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ReportProcessor` 对象和执行它的线程：
- en: '[PRE155]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Start the three threads:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动三个线程：
- en: '[PRE156]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Wait for the finalization of the `ReportRequest` threads:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 `ReportRequest` 线程的最终化：
- en: '[PRE157]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Finish the executor using the `shutdown()` method and wait for the finalization
    of the tasks with the `awaitTermination()` method:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法完成执行器，并使用`awaitTermination()`方法等待任务的最终化：
- en: '[PRE158]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Finish the execution of the `ReportSender` object setting the value of its
    `end` attribute to true:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成对`ReportSender`对象的执行，将它的`end`属性设置为true：
- en: '[PRE159]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: How it works...
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the main class of the example, you created `ThreadPoolExecutor` using the
    `newCachedThreadPool()` method of the `Executors` class. Then, you used that `Executor`
    object to initialize a `CompletionService` object because the completion service
    uses an executor to execute its tasks. To execute a task using the completion
    service, use the `submit()` method, as in the `ReportRequest` class.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的主类中，您使用`Executors`类的`newCachedThreadPool()`方法创建了`ThreadPoolExecutor`。然后，您使用该`Executor`对象初始化一个`CompletionService`对象，因为完成服务使用执行器来执行其任务。要使用完成服务执行任务，请使用`submit()`方法，如`ReportRequest`类中所示。
- en: When one of these tasks is executed when the completion service finishes its
    execution, the service stores the `Future` object used to control its execution
    in a queue. The `poll()` method accesses this queue to check whether there is
    any task that has finished its execution; if yes, it returns the first element
    of the queue, which is a `Future` object of a task that has finished its execution.
    When the `poll()` method returns a `Future` object, it deletes it from the queue.
    In this case, you passed two attributes to the method to indicate the time you
    want to wait for the finalization of a task, in case the queue with the results
    of the finished tasks is empty.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些任务之一在完成服务完成其执行时执行，服务将用于控制其执行的`Future`对象存储在队列中。`poll()`方法访问此队列以检查是否有任何任务已完成其执行；如果是，它返回队列的第一个元素，这是一个已完成执行的任务的`Future`对象。当`poll()`方法返回一个`Future`对象时，它将其从队列中删除。在这种情况下，您向方法传递了两个属性以指示您想要等待任务最终化的时间，以防已完成任务的队列中没有结果。
- en: Once the `CompletionService` object is created, you create two `ReportRequest`
    objects that execute a `ReportGenerator` task, execute a `ReportGenerator` task
    using the `CompletionService` object create before and passed as parameter to
    the constructor of the `ReportRequest` objects
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`CompletionService`对象，您就创建了两个`ReportRequest`对象，这些对象执行一个`ReportGenerator`任务，使用之前创建并作为参数传递给`ReportRequest`对象构造函数的`CompletionService`对象执行`ReportGenerator`任务
- en: There's more...
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `CompletionService` class can execute `Callable` or `Runnable` tasks. In
    this example, you used `Callable`, but you could have also sent `Runnable` objects.
    Since `Runnable` objects don't produce a result, the philosophy of the `CompletionService`
    class doesn't apply in such cases.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionService`类可以执行`Callable`或`Runnable`任务。在这个例子中，您使用了`Callable`，但您也可以发送`Runnable`对象。由于`Runnable`对象不产生结果，`CompletionService`类的哲学在这种情况下不适用。'
- en: 'This class also provides two other methods to obtain the `Future` objects of
    the finished tasks. These methods are as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此类还提供了两个其他方法来获取已完成任务的`Future`对象。这些方法如下：
- en: '`poll()`: The version of the `poll()` method without arguments checks whether
    there are any `Future` objects in the queue. If the queue is empty, it returns
    null immediately. Otherwise, it returns its first element and removes it from
    the queue.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`：不带参数的`poll()`方法检查队列中是否有任何`Future`对象。如果队列为空，它将立即返回null。否则，它返回其第一个元素并将其从队列中删除。'
- en: '`take()`: This method, without arguments, checks whether there are any `Future`
    objects in the queue. If it is empty, it blocks the thread until the queue has
    an element. If the queue has elements, it returns and deletes its first element
    from the queue.'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`：此方法不带参数，检查队列中是否有任何`Future`对象。如果队列为空，它将阻塞线程，直到队列中有元素。如果队列中有元素，它将返回并从队列中删除其第一个元素。'
- en: In our case, we used the `poll()` method with a timeout to control when we would
    like to end the execution of the `ReportProcessor` task.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用带超时的`poll()`方法来控制何时结束`ReportProcessor`任务的执行。
- en: See also
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Executing tasks in an executor that returns a result* recipe in this chapter
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*在返回结果的执行器中执行任务*的配方
