["```java\nIJ.run(\"Green\"); //ImageJ command\nString status = IJ.runMacro(\"/PATH/TO/Macro\"); //macro\n```", "```java\n@Parameter\nprivate logService logService;\n```", "```java\npublic void log(String msg) {\n  logService.info(msg);\n}\n```", "```java\n@Plugin(type=Command.class, menuPath=\"Plugins>My Menu>My Plugin\")\npublic class My_Plugin implements Command {\n  //code for the plugin\n\n}\n```", "```java\nint someVar = 1;\nint newVar = doSomething(someVar);\n\n//legacy method\nIJ.log(\"Old value: \"+someVar+\"; New value: \"+newVar);\n\n//SciJava method\nlogService.info(\"Old value: \"+someVar+\"; New value: \"+newVar);\n```", "```java\nprivate static int dbglvl = 3;\n...\n\n//implement the logging based on the dbglvl value\nif (dbglvl> 2) {\n  IJ.log(\"The current value is \"+currValue);\n}\n...\n//implement the logging based on the dbglvl value\nif (dbglvl> 4) {\n  IJ.log(\"This statement was evaluated...\");\n}\n```", "```java\npublic double[] sKymo(ImagePlus imp, ImageProcesso rip, Roi roi, int linewidth, int proflength){\n\n  int numStacks=imp.getStackSize();\n  int dimension = proflength*numStacks;\n  double[] sum = new double [dimension];\n\n  int roiType = roi.getType();\n  int shift=0;\n  int count=0;\n\n  for (int i=1; i<=numStacks; i++) {\n    imp.setSlice(i);\n\n    for (int ii=0;ii<linewidth;ii++){\n      shift=(-1*(linewidth-1)/2)+ii;\n\n      if (roiType==Roi.LINE) {\n        profile = getProfile(roi,ip,shift);\n      }\n      else {\n        profile = getIrregularProfile(roi, ip,shift);\n      }\n      for (int j=0;j<proflength;j++){\n        count = (i-1)*proflength+j;\n        sum[count]+=(profile[j]/linewidth);\n      }\n    }\n  }\n  return sum;\n}\n```", "```java\ndouble[] getProfile(Roi roi,ImageProcessor ip, int shift){\n  double[] values;\n\n  int x1=((Line)roi).x1;\n  int x2=((Line)roi).x2;\n  int y1=((Line)roi).y1;\n  int y2=((Line)roi).y2;\n\n  ((Line)roi).x1=x1+shift;\n  ((Line)roi).x2=x2+shift;\n  ((Line)roi).y1=y1+shift;\n  ((Line)roi).y2=y2+shift;\n\n  values=((Line)roi).getPixels();\n  ((Line)roi).x1=x1;\n  ((Line)roi).x2=x2;\n  ((Line)roi).y1=y1;\n  ((Line)roi).y2=y2;\n\n  return values;\n}\n```", "```java\npublic void getHSI(){\n  for(int q=0; q<size; q++){\n    float var_Min = Math.min(rf[q], gf[q]); //Min. value of RGB\n    var_Min = Math.min(var_Min, bf[q]);\n    float var_Max = Math.max(rf[q], gf[q]); //Max. value of RGB\n    var_Max = Math.max(var_Max, bf[q]);\n    float del_Max = var_Max - var_Min;      //Delta RGB value\n\n    c3[q] =  (rf[q] + gf[q] + bf[q])/3f;\n\n    if ( del_Max == 0f ){ //This is a gray, no chroma...\n      c1[q] =  0f; //HSL results = 0 ? 1\n      c2[q] =  0f;\n    }\n    else{//Chromatic data...\n      c2[q] = 1 - (var_Min / c3[q]);\n\n      float del_R = (((var_Max-rf[q])/6f)+(del_Max/2f))/del_Max;\n      float del_G = (((var_Max-gf[q])/6f)+(del_Max/2f))/del_Max;\n      float del_B = (((var_Max-bf[q])/6f)+(del_Max/2f))/del_Max;\n\n      if(rf[q] == var_Max) c1[q] = del_B - del_G;\n      else if(gf[q] == var_Max) c1[q] = (1f/3f)+del_R-del_B;\n      else if(bf[q] == var_Max) c1[q] = (2f/3f)+del_G-del_R;\n\n      if (c1[q] < 0)  c1[q] += 1;\n      if (c1[q] > 1)  c1[q] -= 1;\n    }\n  }\n}\n```", "```java\ndouble ox=0, oy=0;\nswitch (settings.snapfeature) {\n\n //other cases skipped\n\n  case MTJSettings.BRIGHT_CENTROID: {\n    // Make all weights > 0:\n    if (minval<= 0) {\n      final double offset = -minval + 1;\n      for (int y=0; y<snaprect.height; ++y)\n        for (int x=0; x<snaprect.width; ++x)\n          snaproi[y][x] += offset;\n        minval += offset;\n        maxval += offset;\n      }\n      // Calculate Otsu threshold:\n      double otsu = minval;\n      final double maxi = OTSU_BINS;\n      final double range = maxval - minval;\n      double maxvari = -Double.MAX_VALUE;\n      for (int i=1; i<OTSU_BINS; ++i) {\n        double sum1=0, sum2=0, n1=0, n2=0;\n        final double thres = minval + (i/maxi)*range;\n        // Notice that we always have minval<thres<maxval,\n        // so sum1, sum2, n1, n2 are > 0 after the loop:\n        for (int y=0; y<snaprect.height; ++y)\n        for (int x=0; x<snaprect.width; ++x) {\n          final double val = snaproi[y][x];\n          if (val<thres) { ++n1; sum1 += val; }\n          else { ++n2; sum2 += val; }\n        }\n        final double mean1 = sum1/n1;\n        final double mean2 = sum2/n2;\n        final double vari = n1*n2*(mean1-mean2)*(mean1-mean2);\n        if (vari > maxvari) {\n          maxvari = vari;\n          otsu = thres;\n        }\n      }\n      // Calculate centroid >= threshold:\n      double val=0, sum=0;\n      for (int y=0; y<snaprect.height; ++y)\n      for (int x=0; x<snaprect.width; ++x) {\n        val = snaproi[y][x];\n        if (val>= otsu) {\n          val -= otsu;\n          ox += x*val;\n          oy += y*val;\n          sum += val;\n        }\n      }\n      ox /= sum; // sum can never be 0\n      oy /= sum;\n      break;\n    }\n  }\n  snapos.x = snaprect.x + ox;\n  snapos.y = snaprect.y + oy;\n```", "```java\npublic void draw(final Graphics g) { try {\n\n  if (!(g instanceofGraphics2D)) return;\n  final Graphics2D g2d = (Graphics2D)g;\n\n //some code skipped for brevity...\n\n  // Draw snapping objects:\n  if (snapping()) {\n    g2d.setColor(settings.hilicolor);\n    try { g2d.setComposite(settings.snapopacity); } catch\n    (Throwable e) { }\n    // Snap ROI:\n    g2d.setStroke(settings.snapstroke);\n    final int slx = (int)((snaprect.x-vof.x + 0.5)*mag);\n    final int sly = (int)((snaprect.y-vof.y + 0.5)*mag);\n    final int sux = (int)((snaprect.x+snaprect.width-vof.x-0.5)*mag);\n    final int suy = (int)((snaprect.y+snaprect.height-vof.y-0.5)*mag);\n    g2d.drawLine(slx,sly,sux,sly);\n    g2d.drawLine(sux,sly,sux,suy);\n    g2d.drawLine(sux,suy,slx,suy);\n    g2d.drawLine(slx,suy,slx,sly);\n    // Snap cursor:\n    g2d.setStroke(settings.pointstroke);\n    final int xi = (int)((snapos.x - vof.x + 0.5)*mag);\n    final int suy = (int)((snapos.y - vof.y + 0.5)*mag);\n    final int hps = 6;\n    g2d.drawLine(xi,yi-hps,xi,yi+hps);\n    g2d.drawLine(xi-hps,yi,xi+hps,yi);\n  }\n}\n```", "```java\nprotected boolean createMasksFromRoiManager(int width, int height) {\n  RoiManager roiManager = RoiManager.getInstance();\n  if (roiManager == null) {\n    IJ.error(\"Could not get ROI Manager instance.\");\n    return false;\n  }\n  Roi[] selectedRois = roiManager.getSelectedRoisAsArray();\n  // create the ROIs\n  createMasksAndRois(selectedRois, width, height);\n  return true;\n}\n\nprotected void createMasksAndRois(Roi[] rois, int width, int height) {\n  // create empty list\n  masks.clear();\n\n  for (Roi r : rois ){\n    MaskInfo mi = new MaskInfo();\n    // add it to the list of masks/ROIs\n    masks.add(mi);\n    // get the ROIs/masks bounding box\n    Rectangle rect = r.getBounds();\n    mi.roi = new BoundingBox(\n    new long[] {rect.x, rect.y} ,\n    new long[] {rect.width, rect.height});\n    ImageProcessor ipMask = r.getMask();\n    // check if we got a regular ROI and return if so\n    if (ipMask == null) {\n      continue;\n    }\n\n    // create a mask processor of the same size as a slice\n    ImageProcessor ipSlice = ipMask.createProcessor(width, height);\n    // fill the new slice with black\n    ipSlice.setValue(0.0);\n    ipSlice.fill();\n    // position the mask on the new  mask processor\n    ipSlice.copyBits(ipMask, (int)mi.roi.offset[0],\n    (int)mi.roi.offset[1], Blitter.COPY);\n    // create an Image<T> out of it\n    ImagePlus maskImp = new ImagePlus(\"Mask\", ipSlice);\n    // and remember it and the masks bounding box\n    mi.mask = ImagePlusAdapter.<T>wrap( maskImp );\n  }\n}\n```", "```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0   http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>net.imagej</groupId>\n    <artifactId>pom-imagej</artifactId>\n    <version>7.1.0</version>\n    <relativePath />\n  </parent>\n  <groupId>name.adriandaerr.imagejplugins.pendentdrop</groupId>\n  <artifactId>pendent_drop</artifactId>\n  <version>2.0.1</version>\n  <name>Pendent Drop ImageJ Plugin</name>\n  <description>Surface tension measurement through the pendent drop method.</description>\n  <properties>\n    <main-class>Goutte_Pendante</main-class>\n  </properties>\n  <repositories>\n    <repository>\n      <id>imagej.public</id>\n      <url>http://maven.imagej.net/content/groups/public</url>\n    </repository>\n  </repositories>\n  <dependencies>\n    <dependency>\n      <groupId>net.imagej</groupId>\n      <artifactId>imagej</artifactId>\n    </dependency>\n  </dependencies>\n</project>\n```", "```java\npublic static void main(final String... args) throws Exception {\n  final String testImagePath =\n  \"/home/adrian/Programmes/plugins_ImageJ_src/Traitement_Gouttes/src\n  /test/resources/eauContrasteMaxStack.tif\";\n\n  // Launch ImageJ as usual.\n  //final ImageJ ij = net.imagej.Main.launch(args);\n  final ImageJ ij = new ImageJ();\n  ij.ui().showUI();\n\n  // Open test image.\n  final ServiceHelper sh = new ServiceHelper(ij.getContext());\n  final IOService io = sh.loadService(DefaultIOService.class);\n  final Dataset dataset = (Dataset) io.open(testImagePath);\n\n  // create a display for the dataset\n  final ImageDisplay imageDisplay =\n  (ImageDisplay) ij.display().createDisplay(dataset);\n\n  // create a rectangle\n  final RectangleOverlay rectangle = new\n  RectangleOverlay(ij.getContext());\n  rectangle.setOrigin(110, 0);\n  rectangle.setOrigin(60, 1);\n  rectangle.setExtent(340, 0);\n  rectangle.setExtent(420, 1);\n  rectangle.setLineColor(Colors.HONEYDEW);\n  rectangle.setLineWidth(1);\n\n  // add the overlays to the display\n  final List<Overlay> overlays = new ArrayList<Overlay>();\n  overlays.add(rectangle);\n  ij.overlay().addOverlays(imageDisplay, overlays);\n  for (final net.imagej.display.DataView view : imageDisplay) {\n    if (view instanceofnet.imagej.display.OverlayView) {\n      view.setSelected(true);\n    }\n  }\n\n  // display the dataset\n  ij.ui().show(imageDisplay);\n\n  // Launch the \"CommandWithPreview\" command.\n  ij.command().run(Goutte_pendante.class, true);\n}\n```", "```java\nij.command().run(Goutte_pendante.class, true);\n```", "```java\nprivate boolean findDropBorders(ImageProcessor ip) {\n  leftBorder = null;\n  rightBorder = null;\n\n  for (int y = bounds.height - 1; y >= 0; y--) {\n\n    // find border positions with integer precision\n    // left border first\n    int xl = 0;\n    while (xl <bounds.width &&\n      ip.getPixelValue(bounds.x + xl, bounds.y + y) > threshold)\n    xl ++;\n\n    if (xl >= bounds.width) {// drop not detected in this scanline\n      if (leftBorder != null) {\n        leftBorder[y]  = Double.NaN;\n        rightBorder[y] = Double.NaN;\n      }\n      continue;\n    } else if (leftBorder == null) {\n      // allocate array on drop tip detection\n      leftBorder = new double[y+1];\n      rightBorder = new double[y+1];\n    }\n\n    // right border next\n    int xr = bounds.width - 1;\n    while (xr> xl &&\n      ip.getPixelValue(bounds.x + xr, bounds.y + y) > threshold)\n    xr --;\n    xr ++; // so xl and xr point just to the right of the interface\n\n    // don't go further if not enough pixels for subpixel-fitting\n    if (xr - xl <= voisinage ||\n    xl - voisinage< 0 || xr + voisinage>bounds.width) {\n      leftBorder[y]  = xl - 0.5;\n      rightBorder[y] = xr - 0.5;\n      continue;\n    }\n\n    // now determine drop borders with sub-pixel precision\n    leftBorder[y]  = fitStep(ip, xl, y, voisinage, false);\n    rightBorder[y] = fitStep(ip, xr, y, voisinage, true);\n  } // end for y\n\n  if (leftBorder == null)\n    return false;\n  else\n    return true;\n}\n```", "```java\n@Parameter\nprivate LogService log;\n```", "```java\npublic void run() {\n  HashMap<SHAPE_PARAM,Boolean> fitMe = tagParamsToFit();\n  if ( ! fitMe.containsValue(Boolean.TRUE) ) {\n    log.error(\"At least one parameter must be selected !\");\n    return;\n  }\n  //code skipped for brevity...\n}\n```"]