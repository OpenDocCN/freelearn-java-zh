<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Server-Sent Events (SSEs)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, <span class="calibre10">we're going to take a look at <strong class="calibre8">Server-Sent Events</strong> (<strong class="calibre8">SSE</strong>). We will have a look at the characteristics of some usage scenarios, and then we'll be implementing and sending simple SSEs on the server side using JAX-RS. Next up, we'll be implementing SSEs on the client-side using JAX-RS engine HTML and finally, we will have a look at sending and receiving server-sent broadcast events to implement something like a simple HTML chat client.</span></p>
<p class="calibre6">This chapter includes the following sections:</p>
<ul class="calibre14">
<li class="calibre15">What are SSEs?</li>
<li class="calibre15">Implementing SSE on the server-side</li>
<li class="calibre15">Implementing SSE REST clients</li>
<li class="calibre15">Implementing and sending SSE broadcasts</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What are SSEs?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at SSEs, and take a look at some of its usage scenarios. We'll then be implementing and sending a simple SSE on the server side using JAX-RS. Next up, we'll implement SSE on the client-side using JAX-RS and HTML. Finally, we will have a look at sending and receiving server-sent broadcast events to implement something like a simple HTML chat client. </p>
<p class="calibre6">We're going to take a look at SSEs, what they are, and some usage scenarios. We will also have a look at some differences to other related technologies like WebSockets, Polling, and Long Polling.</p>
<p class="calibre6">So, what are SSEs, exactly? They are a very simple HTTP-based API, dedicated to Push communication, and currently SSEs are implemented in most recent browsers like Firefox, Chrome, Safari, and Opera. Unfortunately, SSEs are currently not implemented in Internet Explorer or Edge.</p>
<p class="calibre6">SSE allows you to send simple text data from the server to the client. One important thing: SSEs are one-way in communication. You might be thinking, <em class="calibre18">hey, well I've used Polling and Long Polling in the past, and they kind of do the same thing</em>. The main difference is that with Polling and Long Polling, it is the client that occasionally tries to load new data. With SSE, it's not the client Polling, it's always the server pushing data to the client.</p>
<p class="calibre6">You might have heard of WebSockets before, but WebSockets are a totally different thing. First up, they are TCP-based. They provide a full duplex communication link between the client and the server. Using a WebSocket, the client can always send data to the server and the server can always send data to the client. In SSE, you can think of an event-stream of really simple text data. The text data must be encoded using UTF-8. What we can do in the event-stream is send simple messages and encode these messages. These messages may even be in JSON or you maybe you can only send messages that are plain string or perhaps primitive data. Messages in the event-stream are separated by a pair of newline characters (<kbd class="calibre17">"\n"</kbd>).</p>
<p class="calibre6">Remember: SSEs are simple Push communication mechanisms, and you can send an event-stream from the server to the client without the client leading to Polling.</p>
<p class="calibre6">In the next section, we're going to have a look at implementing SSE on the server-side using JAX-RS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing SSE on the server-side</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at opening SSE sinks using the text/event-stream media type. We'll be sending simple data and also JSON data events. Finally, we'll be closing and disconnecting the SSE sink which we previously opened.</p>
<p class="calibre6">Let's get started, dive into the code, and open our IDE. As usual, we prepare a small template to get us started. Open the <kbd class="calibre17">EventsResource.java</kbd> file. The first thing we need to do is implement the opening of the event-stream. We can do that by implementing a plain HTTP <kbd class="calibre17">@GET</kbd> method, though the first thing is going to be the parameter, which is where we pass the <kbd class="calibre17">@Context</kbd> of type <kbd class="calibre17">SseEventSink</kbd>.</p>
<p class="calibre6">This is the object that we can use later to send events down to the client. You can also see the <kbd class="calibre17">@Produces</kbd> annotation, which is where we use <kbd class="calibre17">text/event-stream</kbd> as the <kbd class="calibre17">MediaType</kbd>. This is the special media type used to designate SSE:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces(MediaType.SERVER_SENT_EVENTS)<br class="calibre2"/>    public void openEventStream(<br class="calibre2"/>      @Context final SseEventSink eventSink) {<br class="calibre2"/>        this.eventSink = eventSink;<br class="calibre2"/>    }</pre>
<p class="calibre6">Once we've opened the SSE event-stream, we can implement the sending of events. First up, we start with a simple <kbd class="calibre17">@POST</kbd> method. Again, mind the second parameter, which is a <kbd class="calibre17">@Context</kbd> object of type <kbd class="calibre17">Sse</kbd>. We use this <kbd class="calibre17">Sse</kbd> interface later to construct new events. Let's send the first simple event down the event-stream. We do that using the <kbd class="calibre17">sse</kbd> context and construct a <kbd class="calibre17">newEvent</kbd> using the string <kbd class="calibre17">message</kbd>, and we use the <kbd class="calibre17">send</kbd> method on the <kbd class="calibre17">eventSink</kbd> and send this to the <kbd class="calibre17">event</kbd>:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    public void sendEvent(String message, @Context Sse sse) {<br class="calibre2"/>        final SseEventSink localSink = eventSink;<br class="calibre2"/>        if (localSink == null) return;<br class="calibre2"/><br class="calibre2"/>        // send simple event<br class="calibre2"/>        OutboundSseEvent event = sse.newEvent(message);<br class="calibre2"/>        localSink.send(event);</pre>
<p class="calibre6">We can also send named events which can give your events some names. Again, we are using the <kbd class="calibre17">sse</kbd> context in order to construct a <kbd class="calibre17">newEvent</kbd>. We can see here that we gave it a name (<kbd class="calibre17">stringEvent</kbd>) and that we passed in the <kbd class="calibre17">message</kbd> as data. Again, we used the <kbd class="calibre17">localSink</kbd> and the <kbd class="calibre17">send</kbd> method to send this <kbd class="calibre17">event</kbd>:</p>
<pre class="calibre22">        // send simple string event<br class="calibre2"/>        OutboundSseEvent stringEvent = sse.newEvent(<br class="calibre2"/>          "stringEvent", message + " From server.");<br class="calibre2"/>        localSink.send(stringEvent);</pre>
<p class="calibre6">This also works for other primitive data. Perhaps we want to send the current time in milliseconds. As you can see, there's also a <kbd class="calibre17">newEventBuilder</kbd> available in the <kbd class="calibre17">sse</kbd> context. We use <kbd class="calibre17">sse.newEventBuilder</kbd>, <kbd class="calibre17">name</kbd>, and <kbd class="calibre17">data</kbd> and call the <kbd class="calibre17">build</kbd> method on it. We then call the <kbd class="calibre17">send</kbd> method as follows:</p>
<pre class="calibre22">        // send primitive long event using builder<br class="calibre2"/>        OutboundSseEvent primitiveEvent = sse.newEventBuilder()<br class="calibre2"/>                .name("primitiveEvent")</pre>
<pre class="calibre22">                .data(System.currentTimeMillis()).build();<br class="calibre2"/>        localSink.send(primitiveEvent);</pre>
<p class="calibre6">And finally, we can also send JSON events. For example, what we have is a simple POJO implementation using some <kbd class="calibre17">@JsonbPropertyOrder</kbd> annotation:</p>
<pre class="calibre22">    @JsonbPropertyOrder({"time", "message"})<br class="calibre2"/>    public static class JsonbSseEvent {<br class="calibre2"/>        String message;<br class="calibre2"/>        LocalDateTime today = LocalDateTime.now();<br class="calibre2"/>        public JsonbSseEvent(String message) {<br class="calibre2"/>            this.message = message;}<br class="calibre2"/>        public String getMessage() {<br class="calibre2"/>            return message;}<br class="calibre2"/>        public void setMessage(String message) {<br class="calibre2"/>            this.message = message;}<br class="calibre2"/>        public LocalDateTime getToday() {<br class="calibre2"/>            return today;}<br class="calibre2"/>        public void setToday(LocalDateTime today) {<br class="calibre2"/>            this.today = today;}<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">Let's send this down the wire. We used the <kbd class="calibre17">newEventBuilder</kbd>, we gave it a <kbd class="calibre17">name</kbd>, and we passed in an instance of our POJO as <kbd class="calibre17">data</kbd>. We can specify the <kbd class="calibre17">mediaType</kbd> of this event, which in our case is the application JSON. We can use <kbd class="calibre17">.build</kbd> and send it down the event-stream:</p>
<pre class="calibre22">        // send JSON-B marshalling to send event<br class="calibre2"/>        OutboundSseEvent jsonbEvent = sse.newEventBuilder()<br class="calibre2"/>                .name("jsonbEvent")<br class="calibre2"/>                .data(new JsonbSseEvent(message))<br class="calibre2"/>                .mediaType(MediaType.APPLICATION_JSON_TYPE)<br class="calibre2"/>                .build();<br class="calibre2"/>        localSink.send(jsonbEvent);<br class="calibre2"/>    }</pre>
<p class="calibre6">That's all there is to sending events. The last thing we need to do is close the event-stream. We can use the HTTP <kbd class="calibre17">DELETE</kbd> method for this one. If we call HTTP <kbd class="calibre17">DELETE</kbd> on this resource, we can simply call a <kbd class="calibre17">close</kbd> method on the <kbd class="calibre17">eventSink</kbd> and we're done:</p>
<pre class="calibre22">    @DELETE<br class="calibre2"/>    public void closeEventStream() throws IOException {<br class="calibre2"/>        final SseEventSink localSink = eventSink;<br class="calibre2"/>        if (localSink != null) {<br class="calibre2"/>            this.eventSink.close();<br class="calibre2"/>        }<br class="calibre2"/>        this.eventSink = null;<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's put this to the test. Open a browser and navigate to the <kbd class="calibre17">GET</kbd> endpoint. As we can see, this call does not return, as it is waiting for events, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/edbc67de-85eb-4571-b694-1537551a713d.png" width="363" height="91" class="calibre61"/></p>
<p class="calibre6">Now, we open our Postman to send some events and click <span class="calibre10">Send</span> a few times. Let's go back to our browser. As we can see, our events have arrived, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/e12279f6-aa7d-4dd7-bea4-44aedb87ac61.png" width="777" height="566" class="calibre62"/></p>
<p class="calibre6">That's all there is to implementing services and events on the client-side.</p>
<p class="calibre6">In the next section, we will be talking about implementing service and event REST clients as well as HTTP clients.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing SSE REST clients</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at registering an JAX-RS client instance to receive SSE. We're going to send messages to the SSE service endpoint, and we want to receive those messages in our JAX-RS client. Finally, we will look at implementing a simple HTML client using JSP.</p>
<p class="calibre6">There's a lot of ground to cover in this section. Let's begin and switch to our IDE. As usual, we will prepare a template project to get us started. What we need to do is implement a small JUnit integration test that we can use as our JAX-RS client. In the <kbd class="calibre17">setUp</kbd> method, we will first construct an executor (you'll see in a bit why we need one). In order to do this, we will use the JAX-RS <kbd class="calibre17">clientBuilder</kbd> and construct a <kbd class="calibre17">newBuilder</kbd>. We wll specify the <kbd class="calibre17">connectTimeout</kbd> and the <kbd class="calibre17">readTimeout</kbd> and call the <kbd class="calibre17">.build</kbd>:</p>
<pre class="calibre22">    @Before<br class="calibre2"/>    public void setUp() {<br class="calibre2"/>        client = ClientBuilder.newBuilder()<br class="calibre2"/>                .connectTimeout(5, TimeUnit.SECONDS)<br class="calibre2"/>                .readTimeout(30, TimeUnit.SECONDS)<br class="calibre2"/>                .build();<br class="calibre2"/><br class="calibre2"/>        executorService = Executors.newSingleThreadScheduledExecutor();<br class="calibre2"/>    }</pre>
<p class="calibre6">What's left is that we need to construct and open the <kbd class="calibre17">webTarget</kbd> for our REST endpoint. What we do here is use the <kbd class="calibre17">client</kbd>, we specify the <kbd class="calibre17">target</kbd> as <kbd class="calibre17">localhost:8080</kbd> in this case, and we implement the <kbd class="calibre17">path</kbd> in the <kbd class="calibre17">events</kbd> endpoint like we did in the <em class="calibre18">Implementing SSE on the server-side</em> section:</p>
<pre class="calibre22">        webTarget = client.target("http://localhost:8080")<br class="calibre2"/>                    .path("/sse-service/api/events");</pre>
<p class="calibre6">In the <kbd class="calibre17">tearDown</kbd> method, we close the client and call the <kbd class="calibre17">executorService</kbd>:</p>
<pre class="calibre22">    @After<br class="calibre2"/>    public void tearDown() {<br class="calibre2"/>        client.close();<br class="calibre2"/>        executorService.shutdown();<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's implement the receiving of SSE. First, what we need to do is send some solid SSE so that we can try and implement an event loop. We send messages to an endpoint and we receive those messages which are sent. This is what we use the <kbd class="calibre17">executorService</kbd> for. Therefore in <kbd class="calibre17">executorService</kbd>, we occasionally send events every 500 milliseconds. We use <kbd class="calibre17">executorService.scheduleWithFixedDelay</kbd>, and <kbd class="calibre17">webTarget.requests</kbd>, we call <kbd class="calibre17">post</kbd>, and we enter some plain text data to our JAX-RS endpoint. As you can see, we have an initial delay of <kbd class="calibre17">250</kbd> milliseconds, and we do that every <kbd class="calibre17">500</kbd> milliseconds:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void receiveSse() throws Exception {<br class="calibre2"/><br class="calibre2"/>        executorService.scheduleWithFixedDelay(() -&gt; {<br class="calibre2"/>            webTarget.request().post(Entity.entity(<br class="calibre2"/>              "Hello SSE JAX-RS client.", <br class="calibre2"/>              MediaType.TEXT_PLAIN_TYPE));<br class="calibre2"/>        }, 250, 500, TimeUnit.MILLISECONDS);</pre>
<p class="calibre6">Now comes the interesting bit: let's receive those events. First, what we need to do is obtain an <kbd class="calibre17">SseEventSource</kbd>. We use <kbd class="calibre17">SseEventSource.target</kbd>, we give it the <kbd class="calibre17">webTarget</kbd> we previously constructed, and we call <kbd class="calibre17">.build</kbd>. This gives us an instance of <kbd class="calibre17"><span class="calibre4">SseEventSource</span></kbd>. Let's interact with <kbd class="calibre17">eventSource</kbd>. The first thing we need to do is register a handler that is called whenever we receive an event. To do that, we use <kbd class="calibre17">eventSource.register</kbd>, and all we do is log the event name and read the data of the event. All that's left is that we need to start receiving those events. To do that, we need to call the <kbd class="calibre17">open</kbd> method on the <kbd class="calibre17">eventSource</kbd>. Just to make sure that this test doesn't return immediately, we put in a sleeve of <kbd class="calibre17">5</kbd> seconds in here:</p>
<pre class="calibre22">        try (SseEventSource eventSource = SseEventSource<br class="calibre2"/>          .target(webTarget).build()) {<br class="calibre2"/>            eventSource.register((e) -&gt; LOGGER.log(Level.INFO, <br class="calibre2"/>                    "Recieved event {0} with data {1}.",<br class="calibre2"/>                    new Object[]{e.getName(), e.readData()}));<br class="calibre2"/>            eventSource.open();<br class="calibre2"/><br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's see if that works. We'll build and run this integration test, which will take some time to compile. We can see that it's receiving the <kbd class="calibre17">JsonbEvent</kbd>, a simple message, a <kbd class="calibre17">primitiveEvent</kbd>, and also the <kbd class="calibre17">stringEvent</kbd> we just expected, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/01e9a48e-077e-465b-afaa-f4b7520ce1db.png" class="calibre63"/></p>
<div class="mce-root">Output of integration tests showing events </div>
<p class="calibre6">This is all there is to sending and receiving SSE using the JAX-RS client. Let's look at one more bit, and that is regarding how you can consume these SSEs using plain HTML and JSP. We will prepare a small JSP showcase and, since most modern browsers support this, it's going to be a good showcase. The first thing you need to do is add some JavaScript, and you need to open the <kbd class="calibre17">EventSource</kbd>. In JavaScript, you can open the <kbd class="calibre17">EventSource</kbd> by using <kbd class="calibre17">new EventSource</kbd>, and we give it the endpoint of our <kbd class="calibre17">events</kbd> endpoint. To receive normal unnamed events, we have to use the <kbd class="calibre17">onmessage</kbd>. We register <kbd class="calibre17">function</kbd> <span class="calibre10">in </span><kbd class="calibre17">source.onmessage</kbd> and append the <kbd class="calibre17">event.data</kbd> to a <kbd class="calibre17">div</kbd> that we defined at the start of the file:</p>
<pre class="calibre22">&lt;h2&gt;Messages&lt;/h2&gt;<br class="calibre2"/>&lt;div id="messages"&gt;&lt;/div&gt;<br class="calibre2"/>&lt;script&gt;<br class="calibre2"/>    if (typeof(EventSource) !== "undefined") {<br class="calibre2"/>        var source = new EventSource(<br class="calibre2"/>          "http://localhost:8080/sse-service/api/events");<br class="calibre2"/>        source.onmessage = function (event) {<br class="calibre2"/>            document.getElementById("messages").innerHTML += <br class="calibre2"/>              event.data + "&lt;br&gt;";<br class="calibre2"/>        };</pre>
<p class="calibre6">For any named events, we have to do this in a slightly different manner. Here, we have to use a different method called the <kbd class="calibre17">addEventListener</kbd> method on our <kbd class="calibre17">source</kbd>. We register <kbd class="calibre17">addEventListener</kbd> for <kbd class="calibre17">"sringEvent"</kbd>, <kbd class="calibre17">"primitiveEvent"</kbd>, and <kbd class="calibre17">jsonEvent</kbd>. We append the data received from the event to the <kbd class="calibre17">div</kbd> tags we defined at the top of the JSP file:</p>
<pre class="calibre22">&lt;script&gt;<br class="calibre2"/>    if (typeof(EventSource) !== "undefined") {<br class="calibre2"/>        var source = new EventSource(<br class="calibre2"/>           "http://localhost:8080/sse-service/api/events");<br class="calibre2"/>        source.onmessage = function (event) {<br class="calibre2"/>            document.getElementById("messages")<br class="calibre2"/>            .innerHTML += event.data + "&lt;br&gt;";<br class="calibre2"/>        };<br class="calibre2"/>    ...<br class="calibre2"/>    ...<br class="calibre2"/>        source.addEventListener("jsonbEvent", function (e) {<br class="calibre2"/>            document.getElementById("jsonbEvents")<br class="calibre2"/>            .innerHTML += e.data + "&lt;br&gt;";<br class="calibre2"/>        }, false);<br class="calibre2"/>    } else {<br class="calibre2"/>        document.getElementById("jsonbEvents").innerHTML = <br class="calibre2"/>        "Sorry, your browser does not support server-sent events...";<br class="calibre2"/>    }</pre>
<p class="calibre6">Now, let's open a browser and go to the URL (<kbd class="calibre17"><span class="calibre4">localhost:8080/sse-service/events.jsp</span></kbd>). This is what our simple UI should look like:</p>
<p class="cdpaligncenter"><img src="Images/d1bbba3a-bf7c-4b4f-972f-16aaa522c2d3.png" width="387" height="364" class="calibre64"/></p>
<p class="calibre6">I know it's not very pretty, but it does the job. In the background, the SSE channel to our server has already been opened. If we open our Postman and start to <kbd class="calibre17">POST</kbd> some events and go back to our browser page, we can see that those events will appear, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/bdd2ccbb-0b6f-4486-ab0b-b15a9c2b3a85.png" width="357" height="632" class="calibre65"/></p>
<p class="calibre6">We invoke these by sending them three times, and you can see here that we have three times the different messages.</p>
<p class="calibre6">That's all for this section. In the next section, we will talk about implementing and sending SSE broadcasts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing and sending SSE broadcasts</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at creating SSE broadcaster instances. We're going to register SSE event sinks with this SSE broadcaster, and then we're going broadcast events to all registered sinks. Finally, we'll implement a simple HTML chat leveraging SSE.</p>
<p class="calibre6">There's a lot of ground to cover in this section. Let's get started and open our IDE. As usual, to get started, we will prepare a small skeleton project. First up, we will implement the <kbd class="calibre17">BroadcastResource</kbd> class, which is the server side for sending SSE broadcasts. We have a few things to do. We will inject the SSE <kbd class="calibre17">@Context</kbd> which we need to construct new events. The next thing we need to do is initialize an SSE broadcaster. For this, we will use the <kbd class="calibre17">@Context</kbd> we just injected and we'll define an <kbd class="calibre17">SseBroadcaster</kbd> so that this is the main instance. We will also use a <kbd class="calibre17">@PostConstruct</kbd> initializer to create a <kbd class="calibre17">newBroadcaster</kbd> using the <kbd class="calibre17">sse</kbd> context:</p>
<pre class="calibre22">    @Context<br class="calibre2"/>    private Sse sse;<br class="calibre2"/>    private SseBroadcaster sseBroadcaster;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void initialize() {<br class="calibre2"/>        sseBroadcaster = sse.newBroadcaster();<br class="calibre2"/>    }</pre>
<p class="calibre6">The next thing we need to implement is the registering of SSE event sinks with this broadcaster. We will implement a simple <kbd class="calibre17">@GET</kbd> method for that, but remember it's annotated with the media type <kbd class="calibre17">text/event-stream</kbd>. All we need to do is call <kbd class="calibre17">sseBroadcaster.register</kbd> with the <kbd class="calibre17">sseEventSink</kbd> instance:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces(MediaType.SERVER_SENT_EVENTS)<br class="calibre2"/>    public void fetch(@Context SseEventSink sseEventSink) {<br class="calibre2"/>        sseBroadcaster.register(sseEventSink);<br class="calibre2"/>    }</pre>
<p class="calibre6">The last bit that is missing is that we need to be able to broadcast and send SSE events. What we do here is define a <kbd class="calibre17">POST</kbd> method that we can use to consume an HTML form (<kbd class="calibre17">APPLICATION_FORM_URLENCODED</kbd>) and the <kbd class="calibre17">@FormParam</kbd> called <kbd class="calibre17">"message"</kbd>. We use this to construct an outbound SSE event (<kbd class="calibre17">OutboundSseEvent</kbd>) like we did in the previous section. We do this by using <kbd class="calibre17">sse.newEvent</kbd>, giving it a name, and passing it the <kbd class="calibre17">message</kbd>, and then we use the <kbd class="calibre17">broadcast</kbd> method on the <kbd class="calibre17">sseBroadcaster</kbd> instance to broadcast the event and we return <kbd class="calibre17">noContent</kbd>:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)<br class="calibre2"/>    public Response broadcast(@FormParam("message") String message) {<br class="calibre2"/>        OutboundSseEvent broadcastEvent = sse.newEvent(<br class="calibre2"/>          "message", message);<br class="calibre2"/>        sseBroadcaster.broadcast(broadcastEvent);<br class="calibre2"/>        return Response.noContent().build();<br class="calibre2"/>    }</pre>
<p class="calibre6">That's all for the server side. Let's have a quick look on the HTML side. Again, we will use a really simple plain JSP file for that like we did in a previous section. We will construct an <kbd class="calibre17">EventSource</kbd> and we will register an event listener (<kbd class="calibre17">addEventListener</kbd>) for our messages. That's all, with only one minor bit missing<span class="calibre10">—</span>we need a simple <kbd class="calibre17">form</kbd> to post messages to our <kbd class="calibre17">BroadcastResource</kbd>:</p>
<pre class="calibre22">&lt;form action="/sse-service/api/broadcast" method="post"&gt;<br class="calibre2"/>    Message &lt;input type="text" name="message"/&gt;<br class="calibre2"/>    &lt;input type="submit" value="Submit"/&gt;<br class="calibre2"/>&lt;/form&gt;</pre>
<p class="calibre6">Let's put this to the test. We will open up a couple of browser instances to see our super fancy HTML chat client:</p>
<p class="cdpaligncenter"><img src="Images/dc934f2e-b921-4d2e-978a-28812645f950.png" width="453" height="211" class="calibre66"/></p>
<p class="calibre6"/>
<p class="calibre6">Let's enter <kbd class="calibre17">Hello Window 1</kbd> and click on <span class="calibre10">Submit</span>, as follows:</p>
<p class="cdpaligncenter"><img src="Images/2fd1eea2-6977-4380-b5a4-7d951516ff60.png" width="449" height="257" class="calibre67"/></p>
<p class="calibre6">What we expect is to see this message in the second window. You should see the same message in the second window. From the second window, we will type a message <kbd class="calibre17">Hello from Window 2</kbd> and click <span class="calibre10">Submit</span>. Now, if we switch tabs to the first window, we should be able to see the <span class="calibre10">Hello from Window 2</span> message sent from the second window, as follows:</p>
<p class="cdpaligncenter"><img src="Images/68de5d84-8073-429b-9817-e38c5d6496dc.png" width="451" height="277" class="calibre68"/></p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">You might think that this is faked, but it isn't. Let's open Postman and use it to also send messages to this broadcast resource. If you look at <span class="calibre10">Headers</span>, we have the <kbd class="calibre17">Content-Type</kbd> already mentioned, and we have a <kbd class="calibre17">message</kbd> under the <span class="calibre10">Body</span> tab. We will use Postman to send those events, and what we expect is to see this message in the browser windows. Let's click once, maybe twice, maybe three times. Let's switch back to our browser and you will see <span class="calibre10">Hello SSE broadcast from Postman</span>, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/a7e3e68b-0940-4b0c-bc3c-8fc1fec315a5.png" width="450" height="354" class="calibre69"/></p>
<p class="calibre6">This proves that we have verified that this is a real broadcast working over several client types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">That's it for this chapter. So, what did we have a look at? First up, we had to look at usage scenarios of service and events and we talked about what SSEs are and other related technologies. Next up, we implemented the sending of services events on the server side with JAX-RS. Then, we had a look at implementing SSE clients and receiving those events using JAX-RS client APIs as well as HTML. Finally, we implemented the sending of SSE broadcasts on the server side and we implemented a small HTML chat client.</p>
<p class="calibre6">In the next and final chapter, we will have a look at advanced REST APIs.</p>


            </article>

            
        </section>
    </div>



  </body></html>