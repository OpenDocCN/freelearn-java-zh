<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;The Java Message Service"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. The Java Message Service</h1></div></div></div><p>The <span class="strong"><strong>Java Message Service </strong></span>(<span class="strong"><strong>JMS</strong></span>)<span class="strong"><strong> API</strong></span> provides a mechanism for Java EE applications to send messages to each other. Java EE 7 introduces JMS 2.0, a new version of <a id="id721" class="indexterm"/>JMS that greatly simplifies the development of applications involving messaging functionality.</p><p>JMS applications do not communicate directly; instead, message producers send messages to a destination, and message consumers receive that message from the destination.</p><p>The message destination is a message queue when the <span class="strong"><strong>Point-to-Point</strong></span> (<span class="strong"><strong>PTP</strong></span>) messaging<a id="id722" class="indexterm"/> domain is used, and a message topic when the Publish/Subscribe (pub/sub) messaging<a id="id723" class="indexterm"/> domain is used.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up GlassFish for JMS</li><li class="listitem" style="list-style-type: disc">Working with message queues</li><li class="listitem" style="list-style-type: disc">Working with message topics</li></ul></div><div class="section" title="Setting up GlassFish for JMS"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Setting up GlassFish for JMS</h1></div></div></div><p>Before we can start<a id="id724" class="indexterm"/> writing code to take advantage of the JMS API, we need to configure some GlassFish resources. Specifically, we need to set up a JMS Connection Factory, <a id="id725" class="indexterm"/>a message queue, and a message topic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Java EE 7<a id="id726" class="indexterm"/> requires all compliant application servers to provide a default JMS connection factory. GlassFish, which is a fully compliant Java EE 7 application server (and the Java EE 7 reference implementation), complies with this requirement; so strictly speaking, we don't really need to set up a connection factory, however, in many cases we may need to set one up. Therefore, in the following section we illustrate<a id="id727" class="indexterm"/> how set up can be done.</p></div></div><div class="section" title="Setting up a JMS connection factory"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Setting up a JMS connection factory</h2></div></div></div><p>The easiest way to set up<a id="id728" class="indexterm"/> a JMS connection <a id="id729" class="indexterm"/>factory is via GlassFish's web console. Recall from <a class="link" href="ch01.html" title="Chapter 1. Getting Started with GlassFish">Chapter 1</a>, <span class="emphasis"><em>Getting Started with GlassFish</em></span>, that the web console can be accessed by starting our domain by entering the following command<a id="id730" class="indexterm"/> in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong> asadmin start-domain domain1</strong></span>
</pre></div><p>Then, go to <code class="literal">http://localhost:4848</code> and log in.</p><div class="mediaobject"><img src="graphics/6886EN_08_01.jpg" alt="Setting up a JMS connection factory"/></div><p>A connection factory can be added by expanding the <span class="strong"><strong>Resources</strong></span> node in the tree to the left-hand side of the web console; to do this, expand the <span class="strong"><strong>JMS Resources</strong></span> node, click on the <span class="strong"><strong>Connection Factories</strong></span> node, and then click on the <span class="strong"><strong>New...</strong></span> button in the main area of the web console.</p><div class="mediaobject"><img src="graphics/6886EN_08_02.jpg" alt="Setting up a JMS connection factory"/></div><p>For our purposes, we can <a id="id731" class="indexterm"/>maintain most of the defaults; the only thing we need to do is enter a pool name in the <span class="strong"><strong>JNDI Name</strong></span> field and pick<a id="id732" class="indexterm"/> a resource type for our connection<a id="id733" class="indexterm"/> factory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>It is always a good idea to use a pool name starting with <code class="literal">"jms/"</code> when naming JMS resources. This way, JMS resources can be easily identified when browsing a JNDI tree.</p></div></div><p>In the field labeled <span class="strong"><strong>JNDI Name</strong></span>, enter <code class="literal">jms/GlassFishBookConnectionFactory</code>. Our code examples later in this<a id="id734" class="indexterm"/> chapter will use this JNDI name to obtain a reference to<a id="id735" class="indexterm"/> this connection factory.</p><p>The <span class="strong"><strong>Resource Type</strong></span> dropdown has the following three options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>javax.jms.TopicConnectionFactory</strong></span>: This option is used to create a connection factory that creates JMS topics for JMS<a id="id736" class="indexterm"/> clients using the pub/sub messaging domain</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>javax.jms.QueueConnectionFactory</strong></span>: This option is used to create a connection factory that creates <a id="id737" class="indexterm"/>JMS queues for JMS clients using the PTP messaging domain</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>javax.jms.ConnectionFactory</strong></span>: This <a id="id738" class="indexterm"/>option is used to create a connection factory that creates either JMS topics or JMS queues</li></ul></div><p>For our example, we will select <span class="strong"><strong>javax.jms.ConnectionFactory</strong></span>; this way, we can use the same connection factory for all of our examples, those using the PTP messaging domain and the pub/sub messaging domain.</p><p>After entering the pool name in the <span class="strong"><strong>JNDI Name</strong></span> field for our connection factory, selecting a connection factory type, and optionally entering a description for our connection factory, we need to click on the <span class="strong"><strong>OK</strong></span> button for the changes to take effect.</p><p>We should then see our newly<a id="id739" class="indexterm"/> created connection factory (<span class="strong"><strong>jms/GlassFishBookConnectionFactory</strong></span>) listed in the main area of the GlassFish web console, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_08_03.jpg" alt="Setting up a JMS connection factory"/></div></div><div class="section" title="Setting up a JMS queue"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Setting up a JMS queue</h2></div></div></div><p>A JMS  queue can be added by going through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> <a id="id740" class="indexterm"/>Expand the <span class="strong"><strong>Resources</strong></span> node in the tree at the left-hand side of the web console<a id="id741" class="indexterm"/>.</li><li class="listitem">Enter a value in the <span class="strong"><strong>JNDI Name</strong></span> field.</li><li class="listitem">Enter a value in the <span class="strong"><strong>Physical Destination Name</strong></span> field.</li><li class="listitem">Select <span class="strong"><strong>javax.jms.Queue</strong></span> in the <span class="strong"><strong>Resource Type</strong></span> field.</li><li class="listitem">Click on the <a id="id742" class="indexterm"/><span class="strong"><strong>OK</strong></span> button.<div class="mediaobject"><img src="graphics/6886EN_08_04.jpg" alt="Setting up a JMS queue"/></div></li></ol></div><p>In our example, the JNDI name of the message queue is <code class="literal">jms/GlassFishBookQueue</code>. The resource type<a id="id743" class="indexterm"/> for message queues must be <code class="literal">javax.jms.Queue</code>. Additionally, a value must be entered in the <span class="strong"><strong>Physical Destination Name</strong></span> field. In<a id="id744" class="indexterm"/> our example, we use <code class="literal">GlassFishBookQueue</code> as the value for this field.</p><p>After clicking on the <span class="strong"><strong>OK</strong></span> button, we should see the newly created queue, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_08_05.jpg" alt="Setting up a JMS queue"/></div></div><div class="section" title="Setting up a JMS topic"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Setting up a JMS topic</h2></div></div></div><p>Setting up a JMS topic<a id="id745" class="indexterm"/> in GlassFish is very similar to <a id="id746" class="indexterm"/>setting up a message queue. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Expand the JMS <span class="strong"><strong>Resources</strong></span> node.</li><li class="listitem">Click on the <span class="strong"><strong>Destination</strong></span> node.</li><li class="listitem">Click on the <span class="strong"><strong>New...</strong></span> button in<a id="id747" class="indexterm"/> the main area of the web console.</li><li class="listitem">Enter a name for our topic in the <span class="strong"><strong>JNDI Name</strong></span> field.</li><li class="listitem">Enter a physical destination name for our topic in the <span class="strong"><strong>Physical Destination Name</strong></span> field.</li><li class="listitem">Select <span class="strong"><strong>javax.jms.Topic</strong></span> from the <span class="strong"><strong>Resource Type</strong></span> dropdown.</li><li class="listitem">Click on the <span class="strong"><strong>OK</strong></span> button, shown in the following screenshot:</li></ol></div><div class="mediaobject"><img src="graphics/6886EN_08_06.jpg" alt="Setting up a JMS topic"/></div><p>Our examples will use <code class="literal">jms/GlassFishBookTopic</code> in the <span class="strong"><strong>JNDI Name</strong></span> field. Since this is a message topic, <span class="strong"><strong>Resource Type</strong></span> must be set to <code class="literal">javax.jms.Topic</code>. The <span class="strong"><strong>Description</strong></span> field is optional. The <span class="strong"><strong>Physical Destination Name</strong></span> property<a id="id748" class="indexterm"/> is required; for our example, we will use <code class="literal">GlassFishBookTopic</code> as the value for this property.</p><p>After clicking on the <span class="strong"><strong>OK</strong></span> button, we can see our newly created message topic as follows:</p><div class="mediaobject"><img src="graphics/6886EN_08_07.jpg" alt="Setting up a JMS topic"/></div><p>Now that we have set<a id="id749" class="indexterm"/> up a connection factory,<a id="id750" class="indexterm"/> a message queue, and a message topic, we are ready to start writing code <a id="id751" class="indexterm"/>using the JMS API.</p></div></div></div>
<div class="section" title="Working with message queues"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Working with message queues</h1></div></div></div><p>Like we mentioned earlier, message queues are used when our JMS code uses the <span class="strong"><strong>Point-To-Point</strong></span> (<span class="strong"><strong>PTP</strong></span>) messaging domain. For the PTP<a id="id752" class="indexterm"/> messaging domain, there is usually one message producer and one message consumer. The message producer and the message consumer don't need to be <a id="id753" class="indexterm"/>running concurrently in order to communicate. The messages placed in the message queue by the message producer will stay there until the message consumer executes and requests for the messages from the queue.</p><div class="section" title="Sending messages to a message queue"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Sending messages to a message queue</h2></div></div></div><p>Sending messages to a JMS queue consists of injecting a few resources to our code and making a few simple JMS API calls.<a id="id754" class="indexterm"/> </p><p>The following example illustrates how to add messages to a message queue:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSContext;
import javax.jms.JMSProducer;
import javax.jms.Queue;

public class MessageSender {

<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")</strong></span>
<span class="strong"><strong>    private static ConnectionFactory connectionFactory;</strong></span>

<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookQueue")</strong></span>
<span class="strong"><strong>    private static Queue queue;</strong></span>

    public void produceMessages() {

        JMSContext jmsContext = connectionFactory.createContext();
        JMSProducer jmsProducer = jmsContext.createProducer();

        String msg1 = "Testing, 1, 2, 3. Can you hear me?";
        String msg2 = "Do you copy?";
        String msg3 = "Good bye!";

        System.out.println("Sending the following message: "
                + msg1);
<span class="strong"><strong>        jmsProducer.send(queue, msg1);</strong></span>
        System.out.println("Sending the following message: "
                + msg2);
<span class="strong"><strong>        jmsProducer.send(queue, msg2);</strong></span>
        System.out.println("Sending the following message: "
                + msg3);
<span class="strong"><strong>        jmsProducer.send(queue, msg3);</strong></span>
    }

    public static void main(String[] args) {
        new MessageSender().produceMessages();
    }
}</pre></div><p>Before delving into the details of our code, alert readers may have noticed that the <code class="literal">MessageSender</code> class<a id="id755" class="indexterm"/> is a standalone Java application, since it contains a main method. Since this class is standalone, it is executed outside of the application server; yet, we can see that some<a id="id756" class="indexterm"/> resources are injected into it, specifically the connection factory object and the queue. The reason we can inject resources into this code even though it runs outside the application server is because GlassFish includes a utility called <code class="literal">appclient</code>.</p><p>This utility allows us to "wrap" an<a id="id757" class="indexterm"/> executable JAR file and allow it to have access to the application server resources. To execute our code, assuming it is packaged in an executable JAR file called <code class="literal">jmsptpproducer.jar</code>, we would type the following in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client jmsptpproducer.jar</strong></span>
</pre></div><p>We would then see, after some GlassFish log entries, the following output on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Sending the following message: Testing, 1, 2, 3. Can you hear me?</strong></span>
<span class="strong"><strong>Sending the following message: Do you copy?</strong></span>
<span class="strong"><strong>Sending the following message: Good bye!</strong></span>
</pre></div><p>The <code class="literal">appclient</code> executable script can be found under <code class="literal">[GlassFish installation directory]/glassfish/bin</code>; our example assumes that this directory is in the <code class="literal">PATH</code> variable and if it isn't, the complete path to the <code class="literal">appclient</code> script must be typed in the command line.</p><p>With that out of the way, we can now explain the code.</p><p>The <code class="literal">produceMessages()</code> method<a id="id758" class="indexterm"/><a id="id759" class="indexterm"/> performs all the necessary steps to send messages to a message queue.</p><p>The first thing this method does is create an instance of <code class="literal">javax.jms.JMSContext</code> by invoking the <code class="literal">createContext()</code> method<a id="id760" class="indexterm"/> on the injected instance of <code class="literal">javax.jms.ConnectionFactory</code>. Notice that the <code class="literal">mappedName</code> attribute<a id="id761" class="indexterm"/> of the <code class="literal">@Resource</code> annotation decorating the connection factory object matches the JNDI name of the connection factory we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made using this name to obtain the connection factory object.</p><p>Next, we create an instance of <code class="literal">javax.jms.JMSProducer</code> by invoking the <code class="literal">createProducer()</code> method<a id="id762" class="indexterm"/> on the <code class="literal">JMSContext</code> instance we just created.</p><p>After obtaining an instance of <code class="literal">JMSProducer</code>, the code sends a series of text messages by invoking its <code class="literal">send()</code> method;<a id="id763" class="indexterm"/> this method takes the message destination as its first parameter, and a string containing the message text as its second parameter.</p><p>There are several overloaded <a id="id764" class="indexterm"/>versions of the <code class="literal">send()</code> method in <code class="literal">JMSProducer</code>; the one we used in our example is a convenience method that creates an instance of <code class="literal">javax.jms.TextMessage</code> and sets its text to the string we provide as the second parameter in the method invocation.</p><p>Although our example sends only text messages to the queue, we are not limited to sending only this type of message. The JMS API provides several types of messages that can be sent and received by JMS applications. All message types are defined as interfaces in the <code class="literal">javax.jms</code> package. </p><p>The following table lists all of the available message types:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Message Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BytesMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows <a id="id765" class="indexterm"/>sending an array of bytes as a message. <code class="literal">JMSProducer</code> has a convenience <code class="literal">send()</code> method<a id="id766" class="indexterm"/> that takes an array of bytes as one of its parameters; this method creates an instance of <code class="literal">javax.jms.BytesMessage</code> on the fly as the message is being sent.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MapMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows sending an implementation of <code class="literal">java.util.Map</code> as a message. <code class="literal">JMSProducer</code> has a convenience <a id="id767" class="indexterm"/>
<code class="literal">send()</code> method that takes a <code class="literal">Map</code> as one of<a id="id768" class="indexterm"/> its parameters; this method creates an instance of <code class="literal">javax.jms.MapMessage</code> on the fly as the message is being sent.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ObjectMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows sending any Java object implementing <code class="literal">java.io.Serializable</code> as a message. <code class="literal">JMSProducer</code> has a convenience <code class="literal">send()</code> method that takes an instance of a class implementing <a id="id769" class="indexterm"/>
<code class="literal">java.io.Serializable</code> as its second parameter; this method creates an instance of <code class="literal">javax.jms.ObjectMessage</code> on the fly as the message is being sent.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">StreamMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows sending <a id="id770" class="indexterm"/>an array of bytes as a message. Differs from <code class="literal">BytesMessage</code> in that it stores the type of each primitive type added to the stream.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TextMessage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows sending <code class="literal">java.lang.String</code> as a message. As seen in our example, <code class="literal">JMSProducer</code> has a convenience <code class="literal">send()</code> method that takes <a id="id771" class="indexterm"/>
<code class="literal">String</code> type as its second parameter; this method creates an instance of <code class="literal">javax.jms.TextMessage</code> on the fly as the message is being sent.</p>
</td></tr></tbody></table></div><p>For more information on all <a id="id772" class="indexterm"/>JMS message types, consult <a id="id773" class="indexterm"/>their JavaDoc documentation at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/">http://docs.oracle.com/javaee/7/api/</a>.</p></div><div class="section" title="Retrieving messages from a message queue"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Retrieving messages from a message queue</h2></div></div></div><p>Of course, there is no point in <a id="id774" class="indexterm"/>sending messages from a queue if nothing is going to receive them. The following example illustrates how to<a id="id775" class="indexterm"/> retrieve messages from a JMS message queue:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSConsumer;
import javax.jms.JMSContext;
import javax.jms.Queue;

public class MessageReceiver {

<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")</strong></span>
<span class="strong"><strong>    private static ConnectionFactory connectionFactory;</strong></span>
<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookQueue")</strong></span>
<span class="strong"><strong>    private static Queue queue;</strong></span>

    public void getMessages() {
        String message;
        boolean goodByeReceived = false;

<span class="strong"><strong>        JMSContext jmsContext = connectionFactory.createContext();</strong></span>
<span class="strong"><strong>        JMSConsumer jMSConsumer = jmsContext.createConsumer(queue);</strong></span>

        System.out.println("Waiting for messages...");
        while (!goodByeReceived) {
<span class="strong"><strong>            message = jMSConsumer.receiveBody(String.class);</strong></span>

            if (message != null) {
                System.out.print("Received the following message: ");
                System.out.println(message);
                System.out.println();
                if (message.equals("Good bye!")) {
                    goodByeReceived = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        new MessageReceiver().getMessages();
    }
}</pre></div><p>Just like in the previous example, an instance of <code class="literal">javax.jms.ConnectionFactory</code> and an instance of <code class="literal">javax.jms.Queue</code> are <a id="id776" class="indexterm"/>injected using<a id="id777" class="indexterm"/> the <code class="literal">@Resource</code> annotation.</p><p>In our code, we get an instance of <code class="literal">javax.jms.JMSContext</code> by invoking the <code class="literal">createContext()</code> method<a id="id778" class="indexterm"/> of <code class="literal">ConnectionFactory</code>, just like in the previous example.</p><p>In this example, we obtain<a id="id779" class="indexterm"/> an instance of <code class="literal">javax.jms.JMSConsumer</code> by calling the <code class="literal">createConsumer()</code> method<a id="id780" class="indexterm"/> on our <code class="literal">JMSContext</code> instance.</p><p>Messages are received by invoking the <code class="literal">receiveBody()</code> method<a id="id781" class="indexterm"/> on our instance of <code class="literal">JMSConsumer</code>. This method takes the type of the message we are expecting as its sole parameter (<code class="literal">String.class</code> in our example). This method returns an object of the type specified in its parameter (an instance of <code class="literal">java.lang.String</code> in our example).</p><p>In this particular example, we placed this method call in a <code class="literal">while</code> loop since we are expecting a message that<a id="id782" class="indexterm"/> will let us know that no more messages are coming. Specifically, we are looking for a message containing the text <code class="literal">"Good bye!"</code>. Once we receive that message, we<a id="id783" class="indexterm"/> break out of the loop and continue with further processing. In this particular case, there is no more processing left to do, therefore, execution ends after we break out of the loop.</p><p>Just like in the previous example, using the <code class="literal">appclient</code> utility allows us to inject resources into the code and prevents us from having to add any libraries to the CLASSPATH. After executing the code through the <code class="literal">appclient</code> utility<a id="id784" class="indexterm"/>, we should see the following output in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client target/jmsptpconsumer.jar </strong></span>
<span class="strong"><strong>Waiting for messages...</strong></span>
<span class="strong"><strong>Received the following message: Testing, 1, 2, 3. Can you hear me?</strong></span>

<span class="strong"><strong>Received the following message: Do you copy?</strong></span>

<span class="strong"><strong>Received the following message: Good bye!</strong></span>
</pre></div><p>The previous example placed some messages on the queue. This example retrieves the messages. If the previous example has not been executed yet, then there are no messages to retrieve.</p></div><div class="section" title="Asynchronously receiving messages from a message queue"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Asynchronously receiving messages from a message queue</h2></div></div></div><p>The <code class="literal">JMSConsumer.receiveBody()</code> method<a id="id785" class="indexterm"/> has a disadvantage: it blocks execution until a message is received from the queue. We worked around this limitation in our previous example by breaking out of the loop once<a id="id786" class="indexterm"/> we received a specific<a id="id787" class="indexterm"/> message (<code class="literal">"Good bye!"</code>).</p><p>We can prevent our JMS consumer code from blocking execution by receiving messages asynchronously via an implementation of the <code class="literal">javax.jms.MessageListener</code> interface.</p><p>The <code class="literal">javax.jms.MessageListener</code> interface contains a single method called <code class="literal">onMessage</code>, it takes an instance of a class implementing the <code class="literal">javax.jms.Message</code> interface as its sole parameter. The following<a id="id788" class="indexterm"/> example illustrates a typical implementation of this interface:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleMessageListener implements MessageListener {

  @Override
  public void onMessage(Message message) {
    TextMessage textMessage = (TextMessage) message;

    try {
      System.out.print("Received the following message: ");
      System.out.println(textMessage.getText());
      System.out.println();
    } catch (JMSException e) {
      e.printStackTrace();
    }
  }
}</pre></div><p>In this case, the <code class="literal">onMessage()</code> method<a id="id789" class="indexterm"/> simply outputs the message text to the console. Recall that behind the scenes, the JMS API creates instances of <code class="literal">javax.jms.TextMessage</code> when<a id="id790" class="indexterm"/> we invoke <code class="literal">JMSProducer.send()</code> with a <code class="literal">String</code> as its second parameter; our <code class="literal">MessageListener</code> implementation casts the <code class="literal">Message</code> instance it receives as a parameter to <code class="literal">TextMessage</code>, and then gets the <code class="literal">String message</code> sent by the <code class="literal">JMSProducer</code> variable, invoking its <code class="literal">getText()</code> method<a id="id791" class="indexterm"/>.</p><p>Our main code can now delegate message retrieval to our custom <code class="literal">MessageListener</code> implementation:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSConsumer;
import javax.jms.JMSContext;
import javax.jms.Queue;

public class AsynchMessReceiver {

<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")</strong></span>
<span class="strong"><strong>    private static ConnectionFactory connectionFactory;</strong></span>
<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookQueue")</strong></span>
<span class="strong"><strong>    private static Queue queue;</strong></span>

    public void getMessages() {
        try {
            JMSContext jmsContext = connectionFactory.createContext();
            JMSConsumer jMSConsumer = jmsContext.createConsumer(queue);

<span class="strong"><strong>            jMSConsumer.setMessageListener(</strong></span>
<span class="strong"><strong>                new ExampleMessageListener());</strong></span>

            System.out.println("The above line will allow the "
                    + "MessageListener implementation to "
                    + "receiving and processing messages"
                    + " from the queue.");
            Thread.sleep(1000);
            System.out.println("Our code does not have to block "
                    + "while messages are received.");
            Thread.sleep(1000);
            System.out.println("It can do other stuff "
                    + "(hopefully something more useful than sending "
                    + "silly output to the console. :)");
            Thread.sleep(1000);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new AsynchMessReceiver().getMessages();
    }
}</pre></div><p>The only relevant difference between this example and the one in the previous section is that in this case, we are <a id="id792" class="indexterm"/>calling the <code class="literal">setMessageListener()</code> method<a id="id793" class="indexterm"/> on the instance of <code class="literal">javax.jms.JMSConsumer</code> obtained from the JMS context. We pass an instance of our custom implementation of <code class="literal">javax.jms.MessageListener</code> to this method; its <code class="literal">onMessage()</code> method<a id="id794" class="indexterm"/> is automatically called whenever there is a message waiting in the queue. Using this approach, <a id="id795" class="indexterm"/> the main code does not block execution while it is waiting to receive messages.</p><p>Executing the preceding<a id="id796" class="indexterm"/> example (using, of course, GlassFish's <code class="literal">appclient</code> utility), results in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client target/jmsptpasynchconsumer.jar </strong></span>
<span class="strong"><strong>The above line will allow the MessageListener implementation to receive and process messages from the queue.</strong></span>

<span class="strong"><strong>Received the following message: Testing, 1, 2, 3. Can you hear me?</strong></span>

<span class="strong"><strong>Received the following message: Do you copy?</strong></span>

<span class="strong"><strong>Received the following message: Good bye!</strong></span>

<span class="strong"><strong>Our code does not have to block while messages are received.</strong></span>

<span class="strong"><strong>It can do other stuff (hopefully something more useful than sending silly output to the console. :)</strong></span>
</pre></div><p>Notice how the messages were received and processed while the main thread was executing. We can tell that this is the case because the output of our <code class="literal">MessageListener</code> class' <code class="literal">onMessage()</code> method<a id="id797" class="indexterm"/> can be seen between calls to <code class="literal">System.out.println()</code> in the primary class.</p></div><div class="section" title="Browsing message queues"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Browsing message queues</h2></div></div></div><p>JMS provides a way to browse message<a id="id798" class="indexterm"/> queues without actually removing the messages from the queue. The following example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.util.Enumeration;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSContext;
import javax.jms.JMSException;
import javax.jms.Queue;
import javax.jms.QueueBrowser;
import javax.jms.TextMessage;

public class MessageQueueBrowser {

<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")</strong></span>
<span class="strong"><strong>    private static ConnectionFactory connectionFactory;</strong></span>
<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookQueue")</strong></span>
<span class="strong"><strong>    private static Queue queue;</strong></span>

    public void browseMessages() {
        try {
            Enumeration messageEnumeration;
            TextMessage textMessage;
            JMSContext jmsContext = connectionFactory.createContext();
<span class="strong"><strong>            QueueBrowser browser = jmsContext.createBrowser(queue);</strong></span>

<span class="strong"><strong>            messageEnumeration = browser.getEnumeration();</strong></span>

            if (messageEnumeration != null) {
                if (!messageEnumeration.hasMoreElements()) {
                    System.out.println("There are no messages "
                            + "in the queue.");
                } else {
                    System.out.println(
                             "The following messages are "
                             + "in the queue");
<span class="strong"><strong>                    while (messageEnumeration.hasMoreElements()) {</strong></span>
<span class="strong"><strong>                        textMessage = (TextMessage) messageEnumeration.nextElement();</strong></span>
<span class="strong"><strong>                        System.out.println(textMessage.getText());</strong></span>
                    }
                }
            }
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        new MessageQueueBrowser().browseMessages();
    }
}</pre></div><p>As we can see, the procedure to browse messages in a message queue is straightforward. We obtain a JMS connection factory, a JMS queue,<a id="id799" class="indexterm"/> and a JMS context in the usual way, and then invoke the <code class="literal">createBrowser()</code> method<a id="id800" class="indexterm"/> on the JMS context object. This method returns an implementation of the <code class="literal">javax.jms.QueueBrowser</code> interface, containing a <code class="literal">getEnumeration()</code> method<a id="id801" class="indexterm"/> that we can invoke to obtain an <code class="literal">Enumeration</code> containing all messages in the queue. To examine the messages in the queue, we simply traverse this enumeration and obtain the messages one by one. In our <a id="id802" class="indexterm"/>example, we simply invoked the <code class="literal">getText()</code> method<a id="id803" class="indexterm"/> of each message in the queue.</p></div></div>
<div class="section" title="Working with message topics"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Working with message topics</h1></div></div></div><p>Message topics are used <a id="id804" class="indexterm"/>when our JMS code uses the Publish/Subscribe (pub/sub) messaging domain. When using this messaging domain, the same message can be sent to all subscribers of a topic.</p><div class="section" title="Sending messages to a message topic"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Sending messages to a message topic</h2></div></div></div><p>Sending messages to a JMS topic<a id="id805" class="indexterm"/> is very similar to sending <a id="id806" class="indexterm"/>messages to a queue; simply inject the required resources and make some simple JMS API calls.</p><p>The following example illustrates how to send messages to a message topic:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSContext;
import javax.jms.JMSProducer;
import javax.jms.Topic;

public class MessageSender {

    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")
    private static ConnectionFactory connectionFactory;
<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookTopic")</strong></span>
    private static Topic topic;

    public void produceMessages() {
        JMSContext jmsContext = connectionFactory.createContext();
        JMSProducer jmsProducer = jmsContext.createProducer();

        String msg1 = "Testing, 1, 2, 3. Can you hear me?";
        String msg2 = "Do you copy?";
        String msg3 = "Good bye!";

        System.out.println("Sending the following message: "
                + msg1);
<span class="strong"><strong>        jmsProducer.send(topic, msg1);</strong></span>
        System.out.println("Sending the following message: "
                + msg2);
<span class="strong"><strong>        jmsProducer.send(topic, msg2);</strong></span>
        System.out.println("Sending the following message: "
                + msg3);
        jmsProducer.send(topic, msg3);

    }

    public static void main(String[] args) {
        new MessageSender().produceMessages();
    }
}</pre></div><p>As we can see, this example is nearly identical to the <code class="literal">MessageSender</code> class<a id="id807" class="indexterm"/> we saw when we discussed <a id="id808" class="indexterm"/>Point-To-Point messaging. As a matter of fact, the only lines of code that are different are those that are highlighted. The JMS API was designed this way so that application<a id="id809" class="indexterm"/> developers do not have to learn two different APIs for the PTP and pub/sub domains.</p><p>Since the code is nearly identical to the <a id="id810" class="indexterm"/>corresponding example in the <span class="emphasis"><em>Working with message queues</em></span> section, we will only explain the differences between the two examples. In this example, instead of declaring an instance of a class implementing <code class="literal">javax.jms.Queue</code>, we declare an instance of a class implementing <code class="literal">javax.jms.Topic</code>. We will then pass this instance of <code class="literal">javax.jms.Topic</code> as the first parameter of the <code class="literal">send()</code> method<a id="id811" class="indexterm"/> of our <code class="literal">JMSProducer</code> object, along with the message we wish to send.</p></div><div class="section" title="Receiving messages from a message topic"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Receiving messages from a message topic</h2></div></div></div><p>Just as sending messages to a message topic is<a id="id812" class="indexterm"/> nearly identical to sending<a id="id813" class="indexterm"/> messages to a message queue, receiving messages from a message topic is nearly identical to receiving messages from a message queue, as can be seen in the following example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.ConnectionFactory;
import javax.jms.JMSConsumer;
import javax.jms.JMSContext;
import javax.jms.Topic;

public class MessageReceiver {

    @Resource(mappedName = "jms/GlassFishBookConnectionFactory")
    private static ConnectionFactory connectionFactory;
<span class="strong"><strong>    @Resource(mappedName = "jms/GlassFishBookTopic")</strong></span>
<span class="strong"><strong>    private static Topic topic;</strong></span>

    public void getMessages() {
        String message;
        boolean goodByeReceived = false;

        JMSContext jmsContext = connectionFactory.createContext();
<span class="strong"><strong>        JMSConsumer jMSConsumer = jmsContext.createConsumer(topic);</strong></span>

        System.out.println("Waiting for messages...");
        while (!goodByeReceived) {
<span class="strong"><strong>            message = jMSConsumer.receiveBody(String.class);</strong></span>

            if (message != null) {
                System.out.print("Received the following message: ");
                System.out.println(message);
                System.out.println();
                if (message.equals("Good bye!")) {
                    goodByeReceived = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        new MessageReceiver().getMessages();
    }
}</pre></div><p>Once again, the differences between this code and the corresponding code for PTP messaging are simple. Instead of declaring an instance of a class implementing <code class="literal">javax.jms.Queue</code>, we declare<a id="id814" class="indexterm"/> a class implementing <code class="literal">javax.jms.Topic</code>. We use the <code class="literal">@Resource</code> annotation<a id="id815" class="indexterm"/> to inject an instance of this class into our code using the JNDI name we used when creating it in the GlassFish web console. We<a id="id816" class="indexterm"/> then obtain an instance of <code class="literal">JMSContext</code> and <code class="literal">JMSConsumer</code> as we did before, and then receive the messages from the topic by invoking the <code class="literal">receiveBody()</code> method<a id="id817" class="indexterm"/> on <code class="literal">JMSConsumer</code>.</p><p>Using the pub/sub messaging domain as illustrated in this section has the advantage that messages can be sent to several message consumers. This can be easily tested by concurrently executing two instances of the <code class="literal">MessageReceiver</code> class<a id="id818" class="indexterm"/> we developed in this section, and then<a id="id819" class="indexterm"/> executing the <code class="literal">MessageSender</code> class we developed in the previous section. We should see the console output for each instance, indicating that both instances received all messages.</p><p>Just like with message queues, messages can be retrieved asynchronously from a message topic. The procedure to do so is so<a id="id820" class="indexterm"/> similar to the message queue version that we will not show an example. To convert the asynchronous example shown<a id="id821" class="indexterm"/> earlier in this chapter to use a message topic, simply replace the <code class="literal">javax.jms.Queue</code> variable with an instance of <code class="literal">javax.jms.Topic</code> and inject the appropriate instance using <code class="literal">"jms/GlassFishBookTopic"</code> as the value of the <code class="literal">mappedName</code> attribute of the <code class="literal">@Resource</code> annotation decorating the instance of <code class="literal">javax.jms.Topic</code>.</p></div><div class="section" title="Creating durable subscribers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Creating durable subscribers</h2></div></div></div><p>The disadvantage of<a id="id822" class="indexterm"/> using the pub/sub messaging domain is that message consumers must be running when the messages are sent to the topic. If the message consumer is not running at the time, it will not receive the messages; whereas, in PTP, <a id="id823" class="indexterm"/>messages are kept in the queue until the message consumer runs. Fortunately, the JMS API provides a way to use the pub/sub messaging domain and keep messages in the topic until all subscribed message consumers run and receive the message. This can be accomplished by <a id="id824" class="indexterm"/>creating durable subscribers for a JMS topic.</p><p>In order to be able to serve durable subscribers, we need to set the <code class="literal">ClientId</code> property of our JMS connection factory. Each durable subscriber must have a unique client ID; therefore, a unique connection factory must be declared for each potential durable subscriber.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>
<span class="strong"><strong>InvalidClientIdException?</strong></span><a id="id825" class="indexterm"/>
</p><p>Only one JMS client can connect to a topic for a specific client ID. If more than one JMS client attempts to obtain a JMS connection using the same connection factory, a <code class="literal">JMSException</code> stating that the Client ID is already in use will be thrown. The solution is to create a connection factory for each potential client that will be receiving messages from the durable topic.</p></div></div><p>Like we mentioned before, the easiest way to add a connection factory is through the GlassFish web console, as shown in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Expand<a id="id826" class="indexterm"/> the <span class="strong"><strong>Resources</strong></span> node to the left-hand side of the web console.</li><li class="listitem">Expand the <span class="strong"><strong>JMS Resources</strong></span> node.</li><li class="listitem">Click on the <span class="strong"><strong>Connection Factories</strong></span> node.</li><li class="listitem">Click on the <span class="strong"><strong>New...</strong></span> button in the main area of the page.</li></ol></div><p>Our next example will use the<a id="id827" class="indexterm"/> settings displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_08_08.jpg" alt="Creating durable subscribers"/></div><p>Before clicking on the <span class="strong"><strong>OK</strong></span> button, we need to scroll to the bottom of the page, click on the <span class="strong"><strong>Add Property</strong></span> button<a id="id828" class="indexterm"/>, <a id="id829" class="indexterm"/>and enter a new property named <code class="literal">ClientId</code>. Our example will use <code class="literal">ExampleId</code> as the value for this property, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_08_09.jpg" alt="Creating durable subscribers"/></div><p>Now that we have set up GlassFish to be able to provide durable subscriptions, we are ready to write some code to take advantage of them:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.annotation.Resource;
import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSConsumer;
import javax.jms.JMSContext;
import javax.jms.JMSException;
import javax.jms.MessageConsumer;
import javax.jms.Session;
import javax.jms.TextMessage;
import javax.jms.Topic;

public class MessageReceiver {

<span class="strong"><strong>    @Resource(mappedName</strong></span>
<span class="strong"><strong>            = "jms/GlassFishBookDurableConnectionFactory")</strong></span>
    private static ConnectionFactory connectionFactory;
    @Resource(mappedName = "jms/GlassFishBookTopic")
    private static Topic topic;

    public void getMessages() {
        String message;
        boolean goodByeReceived = false;

        JMSContext jmsContext = connectionFactory.createContext();
<span class="strong"><strong>        JMSConsumer jMSConsumer =</strong></span>
<span class="strong"><strong>            jmsContext.createDurableConsumer(topic, "Subscriber1");</strong></span>

        System.out.println("Waiting for messages...");
        while (!goodByeReceived) {
            message = jMSConsumer.receiveBody(String.class);

            if (message != null) {
                System.out.print("Received the following message: ");
                System.out.println(message);
                System.out.println();
                if (message.equals("Good bye!")) {
                    goodByeReceived = true;
                }
            }
        }

    }

    public static void main(String[] args) {
        new MessageReceiver().getMessages();
    }
}</pre></div><p>As we can see, this code is not very different from the previous examples of code, the purpose of which was to retrieve messages. There are only two differences from previous examples: the<a id="id830" class="indexterm"/> instance of <code class="literal">ConnectionFactory</code> that we are injecting is the one we set up earlier in this section to handle durable subscriptions, and instead of calling the <code class="literal">createConsumer()</code> method<a id="id831" class="indexterm"/> on the JMS context object, we <a id="id832" class="indexterm"/>are calling <code class="literal">createDurableConsumer()</code>. The <code class="literal">createDurableConsumer()</code> method<a id="id833" class="indexterm"/> takes two arguments: a JMS topic object <a id="id834" class="indexterm"/>to retrieve messages from and a <code class="literal">String</code> designating a name for this subscription. This second<a id="id835" class="indexterm"/> parameter must be unique across all subscribers to that durable topic.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we covered how to set up JMS connection factories, JMS message queues, and JMS message topics in GlassFish using the GlassFish web console.</p><p>We also covered how to send messages to a message queue via the <code class="literal">javax.jms.JMSProducer</code> interface.</p><p>Additionally, we covered how to receive messages from a message queue via the <code class="literal">javax.jms.JMSConsumer</code> interface. We also covered how to asynchronously receive messages from a message queue by implementing the <code class="literal">javax.jms.MessageListener</code> interface.</p><p>We also saw how to use these interfaces to send and receive messages to and from a JMS message topic.</p><p>We also covered how to browse messages in a message queue without removing them from the queue via the <code class="literal">javax.jms.QueueBrowser</code> interface.</p><p>Finally, we saw how to set up and interact with durable subscriptions to JMS topics.</p><p>In the next chapter, we will cover how to secure Java EE applications.</p></div></body></html>