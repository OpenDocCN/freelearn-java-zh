<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Build Automation"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Build Automation</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing VirtualBox</li><li class="listitem" style="list-style-type: disc">Preparing SSH keys</li><li class="listitem" style="list-style-type: disc">Preparing VirtualBox machines with Linux</li><li class="listitem" style="list-style-type: disc">Preparing VirtualBox machines with Mac OS X</li><li class="listitem" style="list-style-type: disc">Preparing VirtualBox machines with Windows</li><li class="listitem" style="list-style-type: disc">Automating builds</li><li class="listitem" style="list-style-type: disc">Building cross-platform installers</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec100"/>Introduction</h1></div></div></div><p>Automated builds are widely used in cross-platform software development. <span class="emphasis"><em>Build farm</em></span> with build machines for each supported operating systems is required to build projects remotely and run tests on all platforms. With the rising popularity of software virtualization tools, it became possible to deploy a <span class="emphasis"><em>virtual build farm</em></span> using a single physical machine.</p><p>Besides the build environment in each OS, the essential part of an automated build is the communication between the <span class="emphasis"><em>master</em></span> machine and the <span class="emphasis"><em>build</em></span> machines. The following communication jobs might be required:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The master should prepare and start the build machine</li><li class="listitem" style="list-style-type: disc">The master should send the source code directly to the build machine or fire sources fetching process from the build machine itself</li><li class="listitem" style="list-style-type: disc">The master should start the build process</li><li class="listitem" style="list-style-type: disc">The build machine should send build logs to the master during the build</li><li class="listitem" style="list-style-type: disc">The build machine should send result binaries to the master</li><li class="listitem" style="list-style-type: disc">The master should shut down the build machine</li></ul></div><p>In this chapter, we will prepare the OpenJDK build environment for Windows, Linux, and Mac OS X. This task can be done using a high-level build automation (or Continuous Integration) tool. However, such tools can be limited in functionality and inflexible for our task. While all such tools should do similar jobs (as listed previously), different tools can have different configurations and peculiarities, and the knowledge of one tool can be less useful for another. Also, such tools bring in an additional level of complexity with possible tool-specific problems.</p><p>You will learn how to perform build automation using the most basic tools for a better understanding of the process. The bash shell is already used for OpenJDK builds on all platforms (natively on Linux/Mac and through Cygwin on Windows), so we will use bash scripts for setting up and starting to build virtual machines. For communication (sending commands and data), we will use the SSH protocol; implementation for this is usually preinstalled on Unix-like operating systems and can also be installed on Windows. For virtualization, we will use the popular VirtualBox tool from Oracle.</p></div></div>
<div class="section" title="Installing VirtualBox"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec101"/>Installing VirtualBox</h1></div></div></div><p>VirtualBox <a id="id633" class="indexterm"/>is a popular virtualization toolbox from Oracle Corporation that allows us to run <span class="emphasis"><em>virtual</em></span> instances of other operating systems on top of the <span class="emphasis"><em>host</em></span> operating <a id="id634" class="indexterm"/>system. In this recipe, we will install VirtualBox and configure host network interfaces. Such a configuration will allow us to connect from host to guest and back during the automated builds.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec324"/>Getting ready</h2></div></div></div><p>For this recipe, we will require the Ubuntu 12.04 amd64 operating system running.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec325"/>How to do it...</h2></div></div></div><p>The following procedure will help you to install VirtualBox:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the installation package from the VirtualBox website (<a class="ulink" href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>) and install it.</li><li class="listitem">Install the virtual network interface package:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo apt-get install uml-utilities</strong></span>
</pre></div></li><li class="listitem">Create a virtual interface <code class="literal">tap0</code> that will be used for connections to and from the guest machine:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo tunctl -t tap0 -u your_username</strong></span>
</pre></div></li><li class="listitem">Configure the interface <code class="literal">tap0</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo ifconfig tap0 192.168.42.2 up dstaddr 192.168.42.1 netmask 255.255.255.0</strong></span>
</pre></div></li><li class="listitem">Create an arbitrary VirtualBox machine using GUI forms.</li><li class="listitem">Navigate to <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Network form</strong></span> and check whether the <span class="strong"><strong>tap0</strong></span> network interface is available in the interfaces drop-down list when the <span class="strong"><strong>Bridged Adapter</strong></span> mode is used.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec326"/>How it works...</h2></div></div></div><p>VirtualBox supports <a id="id635" class="indexterm"/>different networking options for guest machines. One of them—Bridged Adapter—allows us to connect from host to guest and back using static IP addresses. To set up this mode on the host side, we need an additional virtual network interface with a separate address. The <code class="literal">tunctl</code> utility that comes as part of the <code class="literal">uml-utilities</code> package allows us to create a virtual interface such as <code class="literal">tap0</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec327"/>There's more...</h2></div></div></div><p>Multiple virtual interfaces can be created with different addresses to run multiple virtual machines simultaneously. Mac OS X can be used as a host machine, the <code class="literal">tuntaposx</code> kernel extensions are required to use the <code class="literal">tunctl</code> utility.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec328"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id636" class="indexterm"/>Oracle VirtualBox user manual at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li></ul></div></div></div>
<div class="section" title="Preparing SSH keys"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec102"/>Preparing SSH keys</h1></div></div></div><p>In this<a id="id637" class="indexterm"/> chapter, we will use virtual machines to build OpenJDK. During the build source code, control commands, logs, and result binaries should be sent between host and virtual machines. We will use the ubiquitous <span class="strong"><strong>Secure Shell</strong></span> (<span class="strong"><strong>SSH</strong></span>) protocol<a id="id638" class="indexterm"/> and its most popular implementation <span class="strong"><strong>OpenSSH</strong></span><a id="id639" class="indexterm"/> for these tasks.</p><p>SSH allows us to send data between the machines and run the commands remotely. When the client performs an SSH connection, it should be authenticated against the server. Besides the user/password authentication, OpenSSH also supports authentication using asymmetric cryptography (RSA or similar) keys. With SSH keys configured, a client can connect to server without manual intervention. This eases the scripting for copying multiple files or running remote tasks.</p><p>In this recipe, we will prepare a set of public and private keys and use these on all virtual machines and on the host machine during the build.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec329"/>Getting ready</h2></div></div></div><p>For this recipe, we will need a Unix-like operating system running with an OpenSSH server and client installed. For example, the Ubuntu 12.04 operating system can be used.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec330"/>How to do it...</h2></div></div></div><p>The following<a id="id640" class="indexterm"/> procedure will help us to install VirtualBox:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Generate client RSA keys pairs for the host and guest machines:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh-keygen -q -P "" -t rsa -f vmhost__id_rsa</strong></span>
<span class="strong"><strong>ssh-keygen -q -P "" -t rsa -f vmguest__id_rsa</strong></span>
</pre></div></li><li class="listitem">Generate server RSA key pairs for the host and guest machines:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh-keygen -q -P "" -t rsa -f vmhost__ssh_host_rsa_key</strong></span>
<span class="strong"><strong>ssh-keygen -q -P "" -t rsa -f vmguest__ssh_host_rsa_key</strong></span>
</pre></div></li><li class="listitem">Create a new user on the host machine that will be used to manage builds, and login under this user:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo adduser packt</strong></span>
</pre></div></li><li class="listitem">Run VirtualBox and configure networking as described in the previous recipe, <span class="emphasis"><em>Installing VirtualBox</em></span>, with the <code class="literal">192.168.42.2</code> host IP address and the <code class="literal">192.168.42.1</code> guest IP address.</li><li class="listitem">Create a user with the same name on the guest machine and login under this user:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo adduser packt</strong></span>
</pre></div></li><li class="listitem">Check whether the <code class="literal">ping</code> command works successfully from host to guest and back from guest to host:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ping 192.168.42.1</strong></span>
<span class="strong"><strong>    PING 192.168.42.2 (192.168.42.2) 56(84) bytes of data.</strong></span>
<span class="strong"><strong>    64 bytes from 192.168.42.2: icmp_req=1 ttl=64 time=0.181 ms</strong></span>
<span class="strong"><strong>    ...</strong></span>
</pre></div></li><li class="listitem">On the host machine, set up the client keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmhost__id_rsa.pub ~/.ssh/id_rsa.pub</strong></span>
<span class="strong"><strong>cp vmhost__id_rsa ~/.ssh/id_rsa</strong></span>
<span class="strong"><strong>chmod 600 ~/.ssh/id_rsa</strong></span>
</pre></div></li><li class="listitem">On the guest machine, set up server keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo rm -rf /etc/ssh/ssh_host_*</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key.pub /etc/ssh/ssh_host_rsa_key.pub</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key /etc/ssh/ssh_host_rsa_key</strong></span>
<span class="strong"><strong>sudo chmod 600 /etc/ssh/ssh_host_rsa_key</strong></span>
</pre></div></li><li class="listitem">On the guest machine, set up the host client public key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmhost__id_rsa.pub ~/.ssh/authorized_keys2</strong></span>
</pre></div></li><li class="listitem">On the <a id="id641" class="indexterm"/>host machine, try to connect to the guest and confirm the new guest server key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh packt@192.168.42.1</strong></span>
</pre></div></li><li class="listitem">On the host machine, save the obtained fingerprint of the guest server key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp ~/.ssh/kno</strong></span>
<span class="strong"><strong>wn_hosts vmhost__known_hosts</strong></span>
</pre></div></li><li class="listitem">On the host machine, check whether we can now connect from host to guest without any passwords or additional confirmations:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh packt@192.168.42.1</strong></span>
</pre></div></li><li class="listitem">Repeat steps 7 to 11, swapping host and guest sides to set up connections from guest to host.</li><li class="listitem">Save the following keys for use later during the builds:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">vmhost__id_rsa</code>: This<a id="id642" class="indexterm"/> is the host client private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmhost__id_rsa.pub</code>: This <a id="id643" class="indexterm"/>is the host client public key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmhost__ssh_host_rsa_key</code>: This<a id="id644" class="indexterm"/> is the host server private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmhost__ssh_host_rsa_key.pub</code>: This<a id="id645" class="indexterm"/> is the host server public key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmhost__known_hosts</code>: This is<a id="id646" class="indexterm"/> the guest server key fingerprint to be used on the host</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmguest__id_rsa</code>: This<a id="id647" class="indexterm"/> is the guest client private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmguest__id_rsa.pub</code>: This<a id="id648" class="indexterm"/> is the guest client private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmguest__ssh_host_rsa_key</code>: This<a id="id649" class="indexterm"/> is the guest server private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmguest__ssh_host_rsa_key.pub</code>: This<a id="id650" class="indexterm"/> is the guest server public key</li><li class="listitem" style="list-style-type: disc"><code class="literal">vmguest__known_hosts</code>: This <a id="id651" class="indexterm"/>is the host server key fingerprint to be used on guest</li></ul></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec331"/>How it works...</h2></div></div></div><p>The <code class="literal">ssh-keygen</code> command<a id="id652" class="indexterm"/> generates a pair of asymmetric cryptography (in our example, RSA) keys.</p><p>SSH supports passwordless authentication based on keys. We prepared the set of keys that can be loaded to host and guest side (for all guest machines) to allow seamless connections<a id="id653" class="indexterm"/> from host to guest and back. So, now we can a call script on the host machine that will connect (or send files) to the guest and will be able to connect back to the host from the same guest session.</p><p>All keys are deliberately generated with an empty passphrase to allow connections without manual passphrase input.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec332"/>There's more...</h2></div></div></div><p>Connections over SSH are secure and this can be useful if you want to perform builds using remote machines instead of local virtual ones. If security is not required, then other protocols can be used. They do not require authentication or a keys setup, for example, some custom protocol over HTTP with support for commands and sending files.</p><p>The DSA or ECDSA keys can be used instead of the RSA keys.</p><p>A shell automation tool like <code class="literal">expect</code> can be used to set up automated connections with passwords instead of client keys.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec333"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing VirtualBox</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The OpenSSH manual on key generation that is available at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li></ul></div></div></div>
<div class="section" title="Preparing VirtualBox machines with Linux"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec103"/>Preparing VirtualBox machines with Linux</h1></div></div></div><p>Many<a id="id654" class="indexterm"/> Linux-based operating systems<a id="id655" class="indexterm"/> have decent support for virtualization using VirtualBox. They also usually have an OpenSSH client and server preinstalled or available in the main packages repository.</p><p>In this recipe, we will set up an Ubuntu Linux virtual machine that can be used for automated OpenJDK builds.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec334"/>Getting ready</h2></div></div></div><p>For this<a id="id656" class="indexterm"/> recipe, we will require the Ubuntu 12.04 amd64 operating system with VirtualBox installed and a virtual network interface configured.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec335"/>How to do it...</h2></div></div></div><p>The following procedure will help us to prepare the Linux virtual machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Prepare the SSH keys as described in the recipe <span class="emphasis"><em>Preparing SSH keys</em></span>.</li><li class="listitem">Download the Ubuntu 12.04 server amd64 image from the Ubuntu<a id="id657" class="indexterm"/> website (<a class="ulink" href="http://www.ubuntu.com/">http://www.ubuntu.com/</a>).</li><li class="listitem">In <a id="id658" class="indexterm"/>VirtualBox, create a virtual machine instance using the IDE storage controller and default values for other settings.</li><li class="listitem">Install Ubuntu on to the virtual machine, set up networking as described in the recipe, <span class="emphasis"><em>Installing VirtualBox</em></span>, and boot the virtual machine.</li><li class="listitem">Create a user with the same name on the host machine, and login under this user:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo adduser packt</strong></span>
</pre></div></li><li class="listitem">Set up the client keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__id_rsa.pub ~/.ssh/id_rsa.pub</strong></span>
<span class="strong"><strong>cp vmguest__id_rsa ~/.ssh/id_rsa</strong></span>
<span class="strong"><strong>chmod 600 ~/.ssh/id_rsa</strong></span>
</pre></div></li><li class="listitem">Set up the server keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo rm -rf /etc/ssh/ssh_host_*</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key.pub /etc/ssh/ssh_host_rsa_key.pub</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key /etc/ssh/ssh_host_rsa_key</strong></span>
<span class="strong"><strong>sudo chmod 600 /etc/ssh/ssh_host_rsa_key</strong></span>
</pre></div></li><li class="listitem">Set up the host client public key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmhost__id_rsa.pub ~/.ssh/authorized_keys2</strong></span>
</pre></div></li><li class="listitem">Set up the host key fingerprint:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__known_hosts ~/.ssh/known_hosts</strong></span>
</pre></div></li><li class="listitem">Check whether the connection from host to guest and back works seamlessly:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh packt@192.168.42.1</strong></span>
</pre></div></li><li class="listitem">Complete the manual build of OpenJDK using the recipe, <span class="emphasis"><em>Building OpenJDK 8 Ubuntu Linux 12.04 LTS</em></span>, from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec336"/>How it works...</h2></div></div></div><p>In this recipe, we<a id="id659" class="indexterm"/> created a virtual machine instance with Ubuntu Linux and configured SSH keys to enable seamless automated connections to it.</p><p>The manual build was done on this VM to be ensure all environment the is correct.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec337"/>There's more...</h2></div></div></div><p>Other <a id="id660" class="indexterm"/>Linux-based OSs can be used instead of Ubuntu 12.04. Other protocols/tools can be used for interaction between the host and guest machine instead of OpenSSH.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec338"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building OpenJDK 8 Ubuntu Linux 12.04</em></span><span class="emphasis"><em> LTS</em></span> recipe from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing VirtualBox</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing SSH keys</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The Oracle VirtualBox user manual at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li></ul></div></div></div>
<div class="section" title="Preparing VirtualBox machines with Mac OS X"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec104"/>Preparing VirtualBox machines with Mac OS X</h1></div></div></div><p>Modern <a id="id661" class="indexterm"/>versions of the Mac OS X operating system support run in a virtualized environment using VirtualBox. Instructions<a id="id662" class="indexterm"/> to prepare the Mac OS X image for virtualization might differ vastly depending on the Mac OS X version and the host operating system. Exact instructions lie outside the scope of this book and can be found on the Internet.</p><p>Please note that running a guest Mac OS X on a non-Mac host operating system can violate your end user license agreement with Apple Inc., it's better to consult your lawyer about this.</p><p>Mac OS X has an OpenSSH client and server preinstalled.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec339"/>Getting ready</h2></div></div></div><p>For this recipe, we will require a ready-to-use Mac OS X image (for VirtualBox-VDI) Version 10.7 or later.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec340"/>How to do it...</h2></div></div></div><p>The following<a id="id663" class="indexterm"/> procedure will help us to prepare the Mac OS X virtual machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Prepare SSH keys as described in the <span class="emphasis"><em>Preparing SSH keys</em></span> recipe in this chapter.</li><li class="listitem">In VirtualBox, create a virtual machine instance using at least 2048 RAM, PIIX3 Chipset, disabled UEFI, single CPU, and IDE storage controller.</li><li class="listitem">Set up networking as described in the <span class="emphasis"><em>Installing VirtualBox</em></span> recipe in this chapter and boot the virtual machine.</li><li class="listitem">Create a user with the same name on the host machine and login under this user.</li><li class="listitem">Set up the client keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__id_rsa.pub ~/.ssh/id_rsa.pub</strong></span>
<span class="strong"><strong>cp vmguest__id_rsa ~/.ssh/id_rsa</strong></span>
<span class="strong"><strong>chmod 600 ~/.ssh/id_rsa</strong></span>
</pre></div></li><li class="listitem">Set up the server keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo rm -rf /etc/ssh_host_*</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key.pub /etc/ssh_host_rsa_key.pub</strong></span>
<span class="strong"><strong>sudo cp vmguest__ssh_host_rsa_key /etc/ssh_host_rsa_key</strong></span>
<span class="strong"><strong>sudo chmod 600 /etc/ssh_host_rsa_key</strong></span>
</pre></div></li><li class="listitem">Set up the host client public key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmhost__id_rsa.pub ~/.ssh/authorized_keys2</strong></span>
</pre></div></li><li class="listitem">Set up the host key fingerprint:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__known_hosts ~/.ssh/known_hosts</strong></span>
</pre></div></li><li class="listitem">Check whether the connection from host to guest and back works seamlessly:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh packt@192.168.42.1</strong></span>
</pre></div></li><li class="listitem">Complete the manual build of OpenJDK using the <span class="emphasis"><em>Building OpenJDK 8 on Mac OS X</em></span> recipe from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec341"/>How it works...</h2></div></div></div><p>In this recipe, we<a id="id664" class="indexterm"/> created a virtual machine instance with Mac OS X and configured SSH keys to enable seamless automated connections to it.</p><p>The manual build <a id="id665" class="indexterm"/>was done on this VM to ensure that the environment setup was correct.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec342"/>There's more...</h2></div></div></div><p>In some Mac OS X versions, the preinstalled OpenSSH might not support the ECDSA SSH keys. This won't prevent us from finishing this recipe as we have used the RSA SSH keys. However, if you want to use ECDSA keys you can update the OpenSSH installation relatively easily using the Homebrew packaging system and its system duplicates repository, <code class="literal">homebrew/dupes</code>.</p><p>Other protocols/tools can be used for interaction between the host and the guest machine instead of OpenSSH.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec343"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building OpenJDK 8 on</em></span><span class="emphasis"><em> Mac OS X</em></span> recipe from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing VirtualBox</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing SSH keys</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The Oracle VirtualBox user manual at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li></ul></div></div></div>
<div class="section" title="Preparing VirtualBox machines with Windows"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec105"/>Preparing VirtualBox machines with Windows</h1></div></div></div><p>Popular <a id="id666" class="indexterm"/>virtualization tools have very <a id="id667" class="indexterm"/>good support for virtualizing Windows. The VirtualBox setup for Windows can be easier than with Mac OS X. However, the SSH protocol is less popular on Windows than on Unix-like operating systems, and the SSH server's setup on Windows might be complex.</p><p>In this recipe, you will learn how to set up a Windows virtual machine for automated builds. A set of in-depth instructions about configuration of free SSH servers on Windows will constitute a significant part of the recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec344"/>Getting ready</h2></div></div></div><p>For this recipe, we will require a Windows 7 virtual machine VirtualBox image.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec345"/>How to do it...</h2></div></div></div><p>The following procedure will help us to prepare the Windows virtual machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Prepare the SSH keys as described in the <span class="emphasis"><em>Preparing SSH keys</em></span> recipe in this chapter.</li><li class="listitem">Download the Copssh SSH server implementation Version 3.1.4. Unfortunately, it was removed from public downloads by the authors, but still can be found on the Internet with these file details:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Copssh_3.1.4_Installer.exe</strong></span>
<span class="strong"><strong>size: 5885261 bytes</strong></span>
<span class="strong"><strong>sha1: faedb8ebf88285d7fe3e141bf5253cfa70f94819</strong></span>
</pre></div></li><li class="listitem">Install <a id="id668" class="indexterm"/>Copssh into any Windows instance using the default installation parameters and copy the installed files somewhere for later usage.</li><li class="listitem">In VirtualBox, create a virtual machine instance using the IDE storage controller and the default values for other settings.</li><li class="listitem">Set up networking as described in the <span class="emphasis"><em>Installing VirtualBox</em></span> recipe in this chapter and boot the virtual machine.</li><li class="listitem">Create a user with the same name on the host machine and login under this user (we will use the name <code class="literal">packt</code>).</li><li class="listitem">Download <a id="id669" class="indexterm"/>Windows Server 2003 Resource Kit Tools from the Microsoft website and extract <code class="literal">ntrights</code>, <code class="literal">instsrv</code>, and <code class="literal">srvany</code> utilities from it.</li><li class="listitem">Copy the extracted Copssh files into the <code class="literal">c:\ssh</code> directory.</li><li class="listitem">Set up users and rights for the SSH service using the following script:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>net user sshd sshd /ADD</strong></span>
<span class="strong"><strong>net user SvcCOPSSH SvcCOPSSH /ADD</strong></span>
<span class="strong"><strong>net localgroup Administrators SvcCOPSS</strong></span>
<span class="strong"><strong>H /add</strong></span>
<span class="strong"><strong>ntrights +r SeTcbPrivilege -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeIncreaseQuotaPrivilege -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeCreateTokenPrivilege -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeServiceLogonRight -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeAssignPrimaryTokenPrivilege -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeDenyInteractiveLogonRight -u SvcCOPSSH</strong></span>
<span class="strong"><strong>ntrights +r SeDenyNetworkLogonRight -u SvcCOPSSH</strong></span>
</pre></div></li><li class="listitem">Generate internal Copssh login and password information, and register Copssh as a Windows service:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>c:\copssh\bin\mkpasswd -l &gt; c:\obf\copssh\etc\passwd</strong></span>
<span class="strong"><strong>c:\copssh\bin\cygrunsrv.exe --install OpenSSHServer --args "-D" --path /bin/sshd</strong></span>
<span class="strong"><strong> --env "CYGWIN=binmode ntsec tty" -u SvcCOPSSH -w SvcCOPSSH</strong></span>
</pre></div></li><li class="listitem">Install the Cygwin tools and run the bash shell.</li><li class="listitem">Set up the client keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__id_rsa.pub /cygdrive/c/ssh/home/packt/.ssh/id_rsa.pub</strong></span>
<span class="strong"><strong>cp vmguest__id_rsa /cygdrive/c/ssh/home/packt/.ssh/id_rsa</strong></span>
<span class="strong"><strong>chmod 600 /cygdrive/c/ssh/home/packt/.ssh/id_rsa</strong></span>
</pre></div></li><li class="listitem">Set up<a id="id670" class="indexterm"/> the server keys:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>rm -rf /cygdrive/c/ssh/etc/ssh_host_*</strong></span>
<span class="strong"><strong>cp vmguest__ssh_host_rsa_key.pub /cygdrive/c/ssh/etc/ssh_host_rsa_key.pub</strong></span>
<span class="strong"><strong>cp vmguest__ssh_host_rsa_key /cygdrive/c/ssh/etc/ssh_host_rsa_key</strong></span>
<span class="strong"><strong>chmod 600 /cygdrive/c/ssh/etc/ssh_host_rsa_key</strong></span>
</pre></div></li><li class="listitem">Set up the host client public key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmhost__id_rsa.pub /cygdrive/c/ssh/home/packt/.ssh/authorized_keys2</strong></span>
</pre></div></li><li class="listitem">Set up the host key fingerprint:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cp vmguest__known_hosts /cygdrive/c/ssh/home/packt/.ssh/known_hosts</strong></span>
</pre></div></li><li class="listitem">Check <a id="id671" class="indexterm"/>whether the connection from host to guest and back works seamlessly:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh packt@192.168.42.1</strong></span>
</pre></div></li><li class="listitem">Register the Windows service that will be used to start the build process using the <code class="literal">instsrv</code> and <code class="literal">srvany</code> utilities:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>instsrv.exe packt_build c:\path\to\srvany.exe</strong></span>
<span class="strong"><strong>reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\packt_build\Parameters" /v Application /t reg_sz /d "C:\packt\build.bat"</strong></span>
</pre></div></li><li class="listitem">Configure the service to avoid starting automatically on OS boot:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sc config obf_build start= demand</strong></span>
</pre></div></li><li class="listitem">Complete the manual build of OpenJDK using the <span class="emphasis"><em>Building OpenJDK 8 on Windows 7 SP1</em></span> recipe from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span>.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec346"/>How it works...</h2></div></div></div><p>In this <a id="id672" class="indexterm"/>recipe, we created a virtual machine instance with Windows and configured the SSH server to enable seamless automated connections to it.</p><p>Binaries of <a id="id673" class="indexterm"/>Copssh SSH server Version 3.1.4 were released by the authors as free software under the terms of GNU General Public License Version 3. This means that we can publish or use unchanged binaries for any purposes without additional licensing limitations.</p><p>Copssh uses the Cygwin environment and the OpenSSH server under the hood. It also provides integration with the Windows user rights system.</p><p>Authorization roles given to the SvcCOPSSH user are required to support the SSH key authentication.</p><p>We used Cygwin to set up key files to support the proper setting of Cygwin file rights.</p><p>Copssh uses parts of the old version of the Cygwin environment and we need the additional full Cygwin installation for the OpenJDK build process. Different Cygwin versions running on the same machine might interfere with each other causing errors. Although during heavy use of such a setup, I never observed any problems, it is better to keep this point in mind for instances of cryptic Cygwin/Copssh errors/crashes.</p><p>Two additional Windows users for the SSH server (sshd and SvcCOPSSH) are used internally by Copssh.</p><p>The <code class="literal">ntrighs</code> utility<a id="id674" class="indexterm"/> was used to assign additional roles to the SvcCOPSSH user. This utility is not officially supported in the newer versions of Windows but should work fine anyway.</p><p>Windows service registration will be required for automated builds to start the actual build process over an SSH connection. For a proper environment setup, the build process on Windows should be started from the <code class="literal">cmd.exe</code> shell (usually running a batch file). It cannot be started directly from the SSH session that works in the guest Windows machine inside the Cygwin environment. The <code class="literal">instsrv</code> and <code class="literal">ntrighs</code> utilities allowed us to create a Windows service that will run the batch file (that in turn will start the actual build process) on a path preconfigured in the registry. This <code class="literal">packt_build</code> service can be started from the SSH session using the <code class="literal">net start </code>command, effectively starting the build process.</p><p>The Manual build was done on this VM to ensure that the environment setup was correct.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec347"/>There's more...</h2></div></div></div><p>Other SSH servers can be used in theory, although I am not aware of other free (as in "free speech") SSH server implementations for Windows, which support key authentication.</p><p>Other protocols/tools can be used for interaction between the host and guest machine instead of OpenSSH.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec348"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building OpenJDK 8 on Windows 7 SP1</em></span> recipe from <a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing Cygwin for Windows builds</em></span> recipe from <a class="link" href="ch02.html" title="Chapter 2. Building OpenJDK 6">Chapter 2</a>, <span class="emphasis"><em>Building OpenJDK 6</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing VirtualBox</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing SSH keys</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The Oracle VirtualBox user manual at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li><li class="listitem" style="list-style-type: disc">The Copssh website at <a class="ulink" href="https://www.itefix.net/copssh">https://www.itefix.net/copssh</a></li></ul></div></div></div>
<div class="section" title="Automating builds"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec106"/>Automating builds</h1></div></div></div><p>This recipe<a id="id675" class="indexterm"/> joins together all the previous recipes in this chapter. Prepared virtual machine images and SSH with key authentication will allow us to build OpenJDK in fully automated mode using simple bash scripts without additional tools.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec349"/>Getting ready</h2></div></div></div><p>For this recipe, we will require a Linux or Mac OS host machine running.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec350"/>How to do it...</h2></div></div></div><p>The following procedure will help us to prepare the Windows virtual machine:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Prepare SSH keys as described in the <span class="emphasis"><em>Preparing SSH keys</em></span> recipe in this chapter.</li><li class="listitem">Set up the VirtualBox installation and its network settings as described in the <span class="emphasis"><em>Installing VirtualBox</em></span> recipe in this chapter.</li><li class="listitem">Prepare the virtual machine images as described in the previous recipes in this chapter.</li><li class="listitem">For each VM image, prepare a list of environment variables, which will be used by the build script (for example, Windows):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>export VM_ADDRESS=192.168.42.1</strong></span>
<span class="strong"><strong>export VM_NAME=jdk7-windows-amd64</strong></span>
<span class="strong"><strong>export VM_OSTYPE=Windows7_64</strong></span>
<span class="strong"><strong>export VM_MEMORY=1780</strong></span>
<span class="strong"><strong>export VM_IOAPIC=on</strong></span>
<span class="strong"><strong>export VM_NICTYPE=82545EM</strong></span>
<span class="strong"><strong>export VM_MACADDR=auto</strong></span>
<span class="strong"><strong>export VM_OBF_DIR=/cygdrive/c/packt</strong></span>
<span class="strong"><strong>export VM_START_BUILD="net start obf_build &gt;&gt; build.log 2&gt;&amp;1"</strong></span>
<span class="strong"><strong>export VM_SHUTDOWN="shutdown /L /T:00 /C /Y"</strong></span>
<span class="strong"><strong>export VM_IDE_CONTROLLER=PIIX4</strong></span>
</pre></div></li><li class="listitem">Add the snippets from the following steps (steps 6 to 12) to the main build script.</li><li class="listitem">Create a virtual machine instance using the <code class="literal">VBoxManage</code> utility:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd )"</strong></span>
<span class="strong"><strong>VBoxManage createvm --name "$VM_NAME" --register --basefolder "$SCRIPT_DIR"/target &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --ostype "$VM_OSTYPE" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --memory "$VM_MEMORY" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --nic1 bridged --bridgeadapter1 tap0 &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --nictype1 "$VM_NICTYPE" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --macaddress1 "$VM_MACADDR" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --cpus 1 &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --audio none &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --usb off &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --vrde on</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --ioapic "$VM_IOAPIC" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --mouse usbtablet &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage modifyvm "$VM_NAME" --keyboard usb &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage setextradata global GUI/SuppressMessages remindAboutAutoCapture,remindAboutMouseIntegrationOn,showRuntimeError.warning.HostAudioNotResponding,remindAboutGoingSeamless,remindAboutInputCapture,remindAboutGoingFullscreen,remindAboutMouseIntegrationOff,confirmGoingSeamless,confirmInputCapture,remindAboutPausedVMInput,confirmVMReset,confirmGoingFullscreen,remindAboutWrongColorDepth &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage storagectl "$VM_NAME" --name "IDE" --add ide &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage internalcommands sethduuid "$SCRIPT_DIR"/target/$VM_NAME.vdi &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage storageattach "$VM_NAME" --storagectl "IDE" --port 0 --device 0 --type hdd --medium "$SCRIPT_DIR"/target/"$VM_NAME".vdi &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>VBoxManage storagectl "$VM_NAME" --name "IDE" --controller "$VM_IDE_CONTROLLER"</strong></span>
</pre></div></li><li class="listitem">Start up<a id="id676" class="indexterm"/> the virtual machine instance:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>VBoxManage startvm "$VM_NAME" --type headless &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>ssh "$VM_ADDRESS" "ls" &gt; /dev/null 2&gt;&amp;1</strong></span>
<span class="strong"><strong>while [ $? -ne 0 ]; do</strong></span>
<span class="strong"><strong>echo "Waiting for VM ..."</strong></span>
<span class="strong"><strong>    sleep 10</strong></span>
<span class="strong"><strong>    ssh "$VM_ADDRESS" "ls" &gt; /dev/null 2&gt;&amp;1</strong></span>
<span class="strong"><strong>done</strong></span>
<span class="strong"><strong>echo "VM started"</strong></span>
</pre></div></li><li class="listitem">Enable remote logging back to the host machine over SSH:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh "$VM_ADDRESS" "cd "$VM_OBF_DIR" &amp;&amp; echo 'Starting build' &gt; build.log"</strong></span>
<span class="strong"><strong>nohup ssh "$VM_ADDRESS" "tail -f "$VM_OBF_DIR"/build.log | ssh 192.168.42.2 'cat &gt;&gt; "$SCRIPT_DIR"/build.log'" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1 &amp;</strong></span>
<span class="strong"><strong>LOGGER_PID="$!"</strong></span>
</pre></div></li><li class="listitem">Copy the <a id="id677" class="indexterm"/>OpenJDK sources into the build VM and start the build:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scp "$SCRIPT_DIR"/openjdk.zip "$VM_ADDRESS":"$VM_OBF_DIR"</strong></span>
<span class="strong"><strong>ssh "$VM_ADDRESS" "cd "$VM_OBF_DIR" &amp;&amp; unzip -q openjdk.zip &gt;&gt; build.log 2&gt;&amp;1"</strong></span>
<span class="strong"><strong>ssh "$VM_ADDRESS" "cd "$VM_OBF_DIR" &amp;&amp; "$VM_START_BUILD""</strong></span>
</pre></div></li><li class="listitem">Poll the build machine periodically looking for the <code class="literal">build_finished.flag</code> file that should be created after the build is finished:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ssh "$VM_ADDRESS" "if [ ! -f "$VM_OBF_DIR"/build_finished.flag ]; then exit 1; else exit 0; fi" &gt; /dev/null 2&gt;&amp;1</strong></span>
<span class="strong"><strong>while [ $? -ne 0 ]; do</strong></span>
<span class="strong"><strong>    echo "Waiting for build ..."</strong></span>
<span class="strong"><strong>    sleep 300</strong></span>
<span class="strong"><strong>ssh "$VM_ADDRESS" "if [ ! -f "$VM_OBF</strong></span>
<span class="strong"><strong>_DIR"/build_finished.flag ]; then exit 1; else exit 0; fi" &gt; /dev/null 2&gt;&amp;1</strong></span>
<span class="strong"><strong>done</strong></span>
</pre></div></li><li class="listitem">Copy the build results, stop the logger, shut down the virtual machine instance, and unregister it from VirtualBox:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scp -r "$VM_ADDRESS":"$VM_OBF_DIR"/dist/* "$SCRIPT_DIR"/dist</strong></span>
<span class="strong"><strong>kill -9 $LOGGER_PID &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1</strong></span>
<span class="strong"><strong>ssh "$VM_ADDRESS" "$VM_SHUTDOWN" &gt;&gt; "$SCRIPT_DIR"/build.log 2&gt;&amp;1 || true</strong></span>
<span class="strong"><strong>sleep 15</strong></span>
<span class="strong"><strong>VBoxManage controlvm "$VM_NAME" poweroff &gt; /dev/null 2&gt;&amp;1 || true</strong></span>
<span class="strong"><strong>VBoxManage unregistervm "$VM_NAME" &gt;&gt; "$SCRIPT_DIR"/build.log</strong></span>
</pre></div></li><li class="listitem">To start the <a id="id678" class="indexterm"/>build with the chosen virtual machine image, use the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>. windows_amd64.env # please not the dot before the command</strong></span>
<span class="strong"><strong>nohup build.sh &gt;&gt; build.log 2&gt;&amp;1 &amp;</strong></span>
<span class="strong"><strong>echo "$!" &gt; .pid</strong></span>
<span class="strong"><strong>tail -F "$SCRIPT_DIR"/build.log</strong></span>
</pre></div></li><li class="listitem">After the build is finished, the OpenJDK binaries will be copied back to the host machine.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec351"/>How it works...</h2></div></div></div><p>We use the low-level VBoxManage tool to manipulate virtual machine instances for better control over this process.</p><p>To ensure that the virtual machine instance actually starts, we poll it periodically over SSH and stop polling after the first successful connection.</p><p>For remote logging, we run the <code class="literal">tail -f</code> process on the build machine that sends its output back to the host machine immediately over SSH. We start this process with a connection from the host machine in the background using the <code class="literal">nohup</code> utility and write the host process <code class="literal">pid</code> to the <code class="literal">.pid</code> file to kill the process after the build.</p><p>We use <code class="literal">scp</code> to copy sources to a build machine and commands over SSH to decompress the sources and start the build.</p><p>After the build is started, we poll the build machine periodically over SSH to look for the <code class="literal">build_finished.flag</code> file that should be created by the build script on the build machine.</p><p>After the build is finished, we copy OpenJDK binaries back to the host machine and shut down the virtual machine instance gracefully before unregistering it.</p><p>Different <a id="id679" class="indexterm"/>virtual machine configuration and environment options are listed in the <code class="literal">.env</code> file for each virtual machine image. We use the "dot first" syntax to import variables from the <code class="literal">env</code> file to the current shell. This allows us to use a generic build script for all virtual machine images.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec352"/>There's more...</h2></div></div></div><p>This recipe can be seen as a basic example of build automation. Different commands, tools, and protocols can be used to achieve the same goal.</p><p>The <code class="literal">build_finished.flag</code> file (with custom content) can also be used to end the build prematurely after the error.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec353"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing VirtualBox</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing SSH keys</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing VirtualBox machines with Linux</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing VirtualBox machines with Mac OS X</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Preparing VirtualBox machines with Windows</em></span> recipe</li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span></li><li class="listitem" style="list-style-type: disc">The Oracle VirtualBox user manual at <a class="ulink" href="https://www.virtualbox.org/manual/UserManual.html">https://www.virtualbox.org/manual/UserManual.html</a></li></ul></div></div></div>
<div class="section" title="Building cross-platform installers"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec107"/>Building cross-platform installers</h1></div></div></div><p>When<a id="id680" class="indexterm"/> cloud services became the ubiquitous way to install desktop software, classic GUI installers became almost obsolete. Cloud package repositories or stores can be much more convenient to install and, in the first place, update the desktop application.</p><p>At the same time, GUI installers are still widely used for various free and commercial applications. Especially for cross-platform applications, GUI installers should show the same behavior on all supported platforms despite not being fully native on those platforms. Some applications require complex environment changes at the time of installation, for example, registering themselves as Windows services or setting environment variables.</p><p>In this recipe, we will prepare a cross-platform installer for OpenJDK that will work on all supported platforms (Windows, Linux, and Mac OS X). We will use a popular open-source installation tool, <code class="literal">IzPack</code>, written in Java.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec354"/>Getting ready</h2></div></div></div><p>For this recipe we will require the OpenJDK binaries (to wrap into the installer).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec355"/>How to do it...</h2></div></div></div><p>The following procedure will help us in preparing the installer:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download IzPack compiler Version 4.3.5 from the IzPack website (<a class="ulink" href="http://izpack.org/">http://izpack.org/</a>) and install it.</li><li class="listitem">Download the sample installation config file from the documentation section of the Izpack website.</li><li class="listitem">Move the <code class="literal">jre</code> directory from the OpenJDK image one level up, next to the <code class="literal">openjdk</code> directory.</li><li class="listitem">Add the <code class="literal">jre</code> directory to the installer configuration as a "loose" pack using the following configuration snippet:<div class="informalexample"><pre class="programlisting">&lt;pack name="OpenJDK RE" required="yes" loose="true"&gt;
    &lt;description&gt;OpenJDK Runtime Environment&lt;/description&gt;
    &lt;file src="jre" targetdir="$INSTALL_PATH"/&gt;
&lt;/pack&gt;</pre></div></li><li class="listitem">Add<a id="id681" class="indexterm"/> the <code class="literal">openjdk</code> directory (that now does not contain JRE) as a normal pack:<div class="informalexample"><pre class="programlisting">&lt;pack name="OpenJDK DK" required="no"&gt;
    &lt;description&gt;OpenJDK Development Kit&lt;/description&gt;
    &lt;fileset dir="openjdk" targetdir="$INSTALL_PATH"/&gt;
    &lt;file src="uninstall" targetdir="$INSTALL_PATH"/&gt;
&lt;/pack&gt;</pre></div></li><li class="listitem">Adjust labels, GUI forms, locale, and icons as you like.</li><li class="listitem">Run the IzPack compiler:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./izcomp/bin/compile ./config.xml -h ./izcomp -o installer.jar</strong></span>
</pre></div></li><li class="listitem">Put the generated <code class="literal">install.jar</code> and <code class="literal">jre</code> directory in the <code class="literal">openjdk-installer</code> directory.</li><li class="listitem">Add the bash/batch script to the <code class="literal">openjdk-installer</code> directory which will allow us to run the installer using the relative path to the <code class="literal">jre</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./jre/bin/java -jar install.jar</strong></span>
</pre></div></li><li class="listitem">Compress the <code class="literal">openjdk-installer</code> directory—it now contains the OpenJDK installer.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec356"/>How it works...</h2></div></div></div><p>The main feature of our installer is that the installer itself runs on the same version of Java that it will install. The <code class="literal">loose="true"</code> configuration in the JRE pack instructs the installer to find this pack on a relative path outside of the main installation <code class="literal">.jar</code> file, without duplicating the contents of the <code class="literal">jre</code> directory.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec357"/>There's more...</h2></div></div></div><p>The IzPack installer supports a lot of configuration options, we highlighted only the basic one in this recipe. Besides the GUI and installation forms customizations, the one feature that can be useful, especially for OpenJDK, is running scripts at installation time. We can prepare scripts to adjust the environment and add them to the corresponding packs using the executable configuration element. On simple Unix-like operating systems, such scripts can simply<a id="id682" class="indexterm"/> append the <code class="literal">PATH</code> variable changes to <code class="literal">~/.bashrc</code> or <code class="literal">~/.bash_profile</code> files. On Windows, utilities such as <code class="literal">pathman</code>, <code class="literal">setx</code>, and <code class="literal">reg</code> can be used to adjust the environment variables or the Windows Registry.</p><p>Instead of running scripts at the time of installation, you can extend the IzPack itself (adding new forms, and so on) and perform environment registration directly from Java code.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec358"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch02.html" title="Chapter 2. Building OpenJDK 6">Chapter 2</a>, <span class="emphasis"><em>Building OpenJDK 6</em></span></li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch03.html" title="Chapter 3. Building OpenJDK 7">Chapter 3</a>, <span class="emphasis"><em>Building OpenJDK 7</em></span></li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch04.html" title="Chapter 4. Building OpenJDK 8">Chapter 4</a>, <span class="emphasis"><em>Building OpenJDK 8</em></span></li><li class="listitem" style="list-style-type: disc">The IzPack installer website at <a class="ulink" href="http://izpack.org/">http://izpack.org/</a></li></ul></div></div></div></body></html>