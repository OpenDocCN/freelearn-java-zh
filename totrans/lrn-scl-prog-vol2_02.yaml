- en: Shaping our Scala Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"I conclude that there are two ways of constructing a software design: One
    way is to make it so simple that there are obviously no deficiencies and the other
    way is to make it so complicated that there are no obvious deficiencies. The first
    method is far more difficult."'
  prefs: []
  type: TYPE_NORMAL
- en: '- C. A. R. Hoare'
  prefs: []
  type: TYPE_NORMAL
- en: A program is a solution specific to a problem. The solution we write is broken
    down to different tasks. Tasks can be specific to a step or a part of the solution.
    While coding for such tasks, we use constructs as tools to make them easier, readable,
    and performant. These tools make it possible to shape up your program at hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Looping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`, `while`, and `do while` loops'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `for` expressions: a quick go-through'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`, and `if else`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standing in front of a printer, you give it an instruction to print pages with
    indexes 2 to 16 from your book. The printer, which is programmed to do so, uses
    an algorithm to print pages for you; it checks for the document and the number
    of pages you asked to print. It sets the starting point as 2 and the last point
    as 16, and it starts printing till the last point is reached. Printing pages we
    can call repetitive, thus printing each page from your document can be well programmed
    using a looping construct. As in any other language, Scala supports `for`*,* `while`,
    and `do while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have created an object named `PagePrinter`. We use the syntax `/* ... */`
    to declare multi-line comments and `//` for single line comments in Scala. We
    declared three methods, which are supposed to do what the comment says. These
    methods are yet to be defined and we have communicated that to the Scala compiler,
    how? Using the syntax "???", that is, three question mark symbols, we tell the
    Scala compiler we're yet to define the method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's come back to our methods. The first one takes a document, the number of
    pages to print as arguments, and prints pages up to the passed index. The second
    one takes the start and end indexes of pages to print and does so. The third method
    can take random indexes to print and prints pages from those indexes. In the third
    method, we've used an asterisk `*` to make our Int argument a vararg, that is,
    a variable argument. Now, the task is to define these methods. We can also see
    that to define what a document is, we have used a case class—we'll learn about
    case classes when we go deeper into Scala's object-oriented part in the next few
    chapters. For now, it'll be helpful to know that a case class let's you create
    a class with all the boilerplate code already available for you; it means you
    can access the members, in our case, `numOfPages` and `typeOfDoc`. Well, there's
    a lot to know about case classes, but we'll go through it later. We'll use our
    looping constructs to define our `PagePrinter`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at our looping constructs. We'll first go through the `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, a `for` loop, also called `for` comprehension takes a sequence of
    elements, and performs an operation on each of them. One of the ways we can use
    them is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a list named stocks with a few stock names. Then we used a simple
    `for` loop to print out each stock from that list. Take a look at the syntax:
    we have `stock <- stocks` that represents a single value from the list at the
    left-hand side of the generator sign `<-` and the list or sequence at the right-hand
    side. Then finally, we can provide any operation to be performed, in our case
    we printed the names. Now that we''ve seen how to write a simple `for` loop, let''s
    define our set of `printPages` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have a utility `print` method, which does nothing but print a simple string
    with index numbers, you're free to imagine a real printer printing the pages though.
  prefs: []
  type: TYPE_NORMAL
- en: Our definition for `printPages` method version 1 merely consists of a condition
    check that the document consists of the pages to be printed. That's done via an
    `if` conditional statement. More on `if` statements later in this chapter. After
    the conditional statement, there's a loop on indexes which ranges from 1 to the
    `lastIndex` passed. The same way the other method version 2 is also defined that
    takes `startIndex` and `lastIndex` and prints pages for you. For the last method
    version 3 of `printPages`*,* we're looping on the indexes passed and we have a
    condition guard that starts with an `if` statement*.* This checks whether the
    page index is less than the number of pages in the document passed as an argument,
    and prints it. Finally, we got the result expected from our methods.
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like in most other languages, the `while` loop is another looping construct
    used. The `while` loop can do any repetitive task until a condition is satisfied.
    It means that the condition provided has to be true for the code execution to
    stop. Generic syntax for the `while` loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition to be checked is going to be a Boolean expression. It gets terminated
    when the condition is `false`. One of the ways we can use them is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've used our list of stocks with a few stock names. Then we called the `iterator`
    method on the list to get an iterator for our sequence. Here `iteraatorForStocks`
    of `Type Iterator[String]` is a non-empty iterator that we can use to iterate
    over the list. Iterators have `hasNext` methods to check if there's a component
    remaining in sequence. Calling `next` on the iterator gives the resulting element.
    We've printed by iterating over the elements of our stock list. Let's take a look
    at `do while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The do while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `do while` loop does not differ a lot from the `while` loop. Generic syntax
    for `do while` loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `do while` loop ensures that the code in block gets executed at least once
    and then checks for the condition defined in a `while` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple example where our statement is getting printed just once before
    the condition passed to the `while` loop is `false`*.* This is how we can use
    `do while` loops in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to try out the `PagePrinter` example using the `while` and `do
    while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The for expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen the `for` loops, and how simple it is to use them in Scala. There''s
    much more we can do with the `for` syntax. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used a generator, definitions, and filters in the
    `for` expression. We used a `for` expression on a list of persons. We proposed
    a gift hamper for a person whose name starts with `A` and who is older than 20
    years of age.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first expression in `for` is a generator expression which generates a new
    person from the persons list and assigns to person. Second is age and name definitions.
    Then finally we apply filters using the `if` statement to put conditions for our
    winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The for expressions
  prefs: []
  type: TYPE_NORMAL
- en: What if we want a couple more prizes for our people. In that case we may want
    to get a sub list of winners. That's possible by introducing `yield`*.*
  prefs: []
  type: TYPE_NORMAL
- en: The for yield expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an example of a `for yield` expression where we''re listing the names
    of winners. The criteria for winning a prize is the age, which should be more
    than 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following is the result**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `yield` does the trick and results in a list of people with satisfying
    criteria. That's how `for yield` expressions work in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: But these iterations are not what Scala or any other functional programming
    language recommends. Let's check out why this is and the alternative to iterative
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is a function''s call to itself. In simple words, a recursive function
    is a function which calls itself. Functional programming recommends use of recursion
    over the use of iterative looping constructs. For the same obvious reasons, Scala
    also recommends use of **recursion**. Let''s first take a look at a recursive
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a function `power2toN` which expects an integer `n`, checks for
    `n` value and if it's not 0, the function calls itself, decrementing `n` integer's
    value till the number `n` becomes `0`. Then comes multiplying the value with 2
    with each recursive call to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Scala compiler gives an error stating `Recursive method power2N needs result
    type`*.* This is a required condition by the Scala compiler. We have to explicitly
    define the response type of a recursive function—that's the reason we have to
    give the return type with the method definition.
  prefs: []
  type: TYPE_NORMAL
- en: Why recursion over iteration?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the statement *functional programming recommends recursion over iteration*,
    let''s discuss why this is the case. If you take a closer look at our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function definition consists of some conditional statement and finally a
    call to itself. There's no mutation of states for any variables. Functional programming
    recommends pure functions, which means functions with no side effects. Side effects
    can be mutating a state of a variable, performing I/O operations. This is not
    possible in iteration. Iteration, consists of mutation of its counter/index variable
    mutating over repetitions. Recursion, on the other hand, can be done without performing
    any such state changes. This makes it powerful and usable in functional languages.
    Operations via recursive functions can be performed with all the power of multiple
    cores executing them without the worry of the same variable state change by different
    threads. Hence recursion is recommended. But there's a glitch in recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With smaller repetitions or fewer levels of calling functions, recursion is
    considered to be ok, but with more levels it ends up  filling the stack. What's
    that?
  prefs: []
  type: TYPE_NORMAL
- en: A function call in a program adds a new element to call a stack. A call stack
    keeps track of information about the function call. For each recursive call, a
    new call gets added to a stack, hence it works fine for a smaller number of recursive
    calls. But as the level goes deeper for recursive calls, the call stack reaches
    its limits and the program gets terminated. That's something unintended and breaks
    our program. So, shall we avoid *recursion* or use it?
  prefs: []
  type: TYPE_NORMAL
- en: The ideal way to write recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complication with *recursion* is filling up the space of the call stack.
    If we find a way which can free up the current stack for each recursive call and
    use it for all subsequent recursive calls, we can somewhat optimize the use of
    a call stack and that can result in better performance of recursive functions.
    Let''s try to understand it this way: we have the definition of our recursive
    function `power2N`*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the definition, after a call to itself, `power2toN` needs to keep
    track of its call stack, because the result of it needs to get multiplied by 2
    to finalize the step and get the desired result. To avoid this and make an efficient
    use of the call stack, we can define a helper function as the very last step to
    be executed in the recursive function. In other words, if we make our function
    call a tail call, we will be able to optimize the use of call stack, hence resulting
    in better recursion. This phenomenon is called tail call optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Above is the *tail optimized* version of our method `power2toN`*.* The annotation
    used here `@tailrec` is to explicitly tell the Scala compiler to recognize a tail
    recursive function and optimize accordingly. What's different here is the use
    of a nested, `helper` method, that's recursive and contains a tail call. After
    a call to `helper(n-1, currentVal * 2)`, there's no further need for that call
    stack. Hence, the Scala compiler is free to optimize accordingly. More on tail
    recursion and tail call optimization in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs.*
  prefs: []
  type: TYPE_NORMAL
- en: This is the preferred way of writing recursive functions in Scala. It takes
    more effort in understanding the requirement and writing one than simply writing
    an iterative version of your method. But it's worth it in the functional world.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already used conditionals many times. It's hard to have your program make
    sense without a conditional or logical statement. These statements help keep the
    flow of the program intact. Moreover, logic implementation is also easier with
    the use of these. Scala supports `if` and `else` conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: The if else conditional expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, you can use `if else` to control program flow. The generic syntax
    for an `if else` statement goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we defined a variable `age` with value 17\. In the next line, we checked
    a condition `age > 18`. If age is greater than 18 then we printed some string.
    You''re now a responsible adult, or some other string. Instead of just printing
    out strings, we can perform any operation as part of the control flow. In Scala,
    we can also declare and assign a value to our variables using `if else` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we assigned a value to a variable `performance` on the fly using conditional
    expressions. We checked if marks are greater than 90, or in between 60 to 90,
    or less than 90 and based on that assigned the value for performance. This happens
    because in Scala, conditionals are expressions—the result of an `if` statement,
    is an expression.
  prefs: []
  type: TYPE_NORMAL
- en: There's another way to control the flow of our program in Scala that uses matching
    of an expression or construct to a value and evaluation of a corresponding block
    of code on a successful match. We call it pattern matching in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is more like Java's `switch` statements with a few differences.
    With one expression/value to match against several case statements, whenever a
    match happens, the corresponding block of code is executed. This gives more than
    one option for our program flow to follow. Java's switch is a fall-through statement,
    which means it executes all the statements after the very first match until it
    confronts a `break` statement. In Scala, there's no `break` statement. Also, there's
    no default case in Scala's pattern matching. Instead, a wildcard "_" is used that
    matches against any other case that has not been covered in previous `case` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the syntactical difference between Java''s switch and
    Scala''s pattern matching statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The difference is obvious, as we already discussed. In Scala, we have to provide
    a case matching to our expression, otherwise the compiler will throw an error, `MatchError`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we didn''t cover all cases possible so the compiler
    gave this error back. To cover all the cases, we can add the wildcard "_" as the
    last `case` clause. This will work fine. Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After covering every `case` clause, pattern matching works a charm. We got a
    response; for value 1 we got a corresponding `One`, and for 5 we got `Not in Range
    1 to 4`. There's more to pattern matching in Scala. We'll go through pattern matching
    in detail and learn several constructs to match against in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can conclude our chapter; let''s go through what we have learned. We started
    learning about looping constructs in Scala. We discussed native looping constructs
    such as `for`*,* `while`*,* and `do while` loops. After that, we saw `for` expressions*,*
    along with `for yield` expressions. Then we understood alternatives to iteration,
    that is, *recursion.* We wrote a few recursive functions as well. Finally, we
    looked at `if else` conditional statements and pattern matching. We know there''s
    much more to come, but with these concepts we''re on our way to understanding
    Scala language constructs better. We''ll continue doing that in our next chapter.
    There we''ll take a look at the core of functional programming: functions. We
    will see how functions are defined and used. It''ll show the variety of functional
    constructs we have available in Scala. We''ll try to give meaning to our programs
    using functions*.*'
  prefs: []
  type: TYPE_NORMAL
