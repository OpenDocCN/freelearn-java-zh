<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Getting Started with Spring Batch Jobs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Getting Started with Spring Batch Jobs</h1></div></div></div><p>In the previous chapter, we learned about batch applications, the offerings and architecture of Spring Batch, and how to build a Spring Batch application to run a batch job. It is important to understand the details of a framework and its components to be able to effectively configure them for business needs. XML- and annotation-based configurations have made programming more efficient and flexible with Spring Batch.</p><p>Some applications expect the configuration to be flexible to the style of programming they follow. Different programs need the ability to trigger a batch job in different ways, including command line and schedulers, or a part of the program itself. It is also important to stop executing batch jobs elegantly if needed.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spring Batch XML features</li><li class="listitem" style="list-style-type: disc">Configuring jobs, transactions, and repositories</li><li class="listitem" style="list-style-type: disc">EL and listeners</li><li class="listitem" style="list-style-type: disc">Executing jobs from command line and web applications</li><li class="listitem" style="list-style-type: disc">Schedulers</li></ul></div><div class="section" title="Spring Batch XML features"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Spring Batch XML features</h1></div></div></div><p>Spring Batch XML <a id="id37" class="indexterm"/>configuration is the most important aspect of Spring Batch programming. Spring Batch has a unique XML terminology and namespace. Understanding these terminologies and using the right set of entities helps to build an efficient batch application.</p><div class="section" title="Spring Batch XML namespace"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Spring Batch XML namespace</h2></div></div></div><p>Spring Batch has <a id="id38" class="indexterm"/>dedicated XML namespace support to provide comfortable configurations. The Spring XML application context file needs to <a id="id39" class="indexterm"/>have the following declaration to activate the namespace:</p><div class="informalexample"><pre class="programlisting">&lt;beans xmlns:<span class="strong"><strong>batch</strong></span>="http://www.springframework.org/schema/batch"

 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
http://www.springframework.org/schema/batch 
http://www.springframework.org/schema/batch/spring-batch-3.0.xsd"&gt;

&lt;<span class="strong"><strong>batch</strong></span>:job id="readDetailsJob"&gt; 
... 
&lt;/<span class="strong"><strong>batch</strong></span>:job&gt;

&lt;/beans&gt;</pre></div><p>The namespace configuration provides the prefix that can be used to configure the details in the context file. In the preceding example, we have <code class="literal">batch</code> as a prefix to configure a job. The prefixes are the identifiers specific to this document only. One can use any valid names as a prefix for the namespace configuration. If any namespace is configured without a prefix, it is considered as the default namespace, and one should configure the elements without a prefix to configure using the default prefix. In the previous chapter, we configured <code class="literal">batch</code> as the default prefix and, hence, we directly configured the job and the step.</p></div><div class="section" title="Spring Batch XML tags"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Spring Batch XML tags</h2></div></div></div><p>Spring Batch XML <a id="id40" class="indexterm"/>configuration defines the flow of the batch job. Following are the important Spring Batch tags and their descriptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">job</code>: This defines a <a id="id41" class="indexterm"/>job composed of a set of steps and transitions between the steps. The job will be exposed in the enclosing bean factory as a component of type <code class="literal">Job</code> that can be launched using <code class="literal">JobLauncher</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">step</code>: This defines a <a id="id42" class="indexterm"/>stage in job processing backed by a step.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tasklet</code>: This <a id="id43" class="indexterm"/>declares the implementation of the tasklet strategy (the strategy for processing in a step). It can be done by <a id="id44" class="indexterm"/>configuring a chunk or by configuring a reference to the <code class="literal">Tasklet</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">chunk</code>: This <a id="id45" class="indexterm"/>declares that the owning step will perform chunk-oriented processing (reading data one at a time and creating groups to be written), delegate what defines a chunk, and configure the chunk-oriented components.</li><li class="listitem" style="list-style-type: disc"><code class="literal">job-repository</code>: This <a id="id46" class="indexterm"/>configures <code class="literal">JobRepository</code> (the repository responsible for persistence of batch metadata entities) using a relational data store. It is needed by other components such as the <code class="literal">job</code> and <code class="literal">step</code> implementations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">flow</code>: This defines a flow <a id="id47" class="indexterm"/>composed of a <a id="id48" class="indexterm"/>set of steps and transitions between steps.</li></ul></div></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Configuring jobs, transactions, and repositories"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Configuring jobs, transactions, and repositories</h1></div></div></div><p>As <a id="id49" class="indexterm"/>mentioned in the previous section, we can configure Spring Batch <a id="id50" class="indexterm"/>jobs conveniently through XML configuration <a id="id51" class="indexterm"/>itself. <span class="strong"><strong>Job</strong></span> is the primary element and the following figure shows the hierarchy of the components in the configuration:</p><div class="mediaobject"><img src="Images/3372OS_02_01.jpg" alt="Configuring jobs, transactions, and repositories" width="600" height="386"/></div><p>Each job can <a id="id52" class="indexterm"/>contain multiple steps, each step contains tasklets, and each tasklet contains chunks. Each component has individual elements that are defined as subelements of the other. The <a id="id53" class="indexterm"/>following is the syntax for one such <a id="id54" class="indexterm"/>batch job:</p><div class="informalexample"><pre class="programlisting">&lt;beans xmlns:batch ... &gt;
&lt;batch:job id="jobId"&gt;
  &lt;batch:step id="stepId"&gt;
    &lt;batch:tasklet ref="beanReference"&gt;
      &lt;batch:chunk reader="dataReader" 
        processor="dataProcessor" 
        writer="dataWriter" commit-interval="500" /&gt;
    &lt;/batch:tasklet&gt;
  &lt;/batch:step&gt;
  &lt;batch:step&gt;
  ...
  &lt;/batch:step&gt;
&lt;/batch:job&gt;
&lt;/beans&gt;</pre></div><div class="section" title="Job configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Job configuration</h2></div></div></div><p>Job is the root element <a id="id55" class="indexterm"/>in batch application configuration. A job defines the batch job to be executed with the configurations of job repository, and properties such as restartable or not. The following are the attributes of the <code class="literal">job</code> element:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is a unique <a id="id56" class="indexterm"/>identifier for the <code class="literal">job</code> element.</li><li class="listitem" style="list-style-type: disc"><code class="literal">abstract</code>: This is <a id="id57" class="indexterm"/>used to configure if the job is abstract, that is, it is not meant to be instantiated by itself, but rather it is just serving as a parent for concrete child job definitions. By default it is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">increment</code>: This is a <a id="id58" class="indexterm"/>reference to a <code class="literal">JobParametersIncrementer</code> bean definition. This will be used to provide a new set of parameters by altering the previous set of parameters to be eligible for a fresh run as the <code class="literal">next</code> instance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">job-repository</code>: This is <a id="id59" class="indexterm"/>the bean name of the <code class="literal">JobRepository</code> that is to be used. This attribute is not mandatory, and it defaults to the <code class="literal">jobRepository</code> bean.</li><li class="listitem" style="list-style-type: disc"><code class="literal">parent</code>: This is the <a id="id60" class="indexterm"/>name of the parent job from which a job should inherit.</li><li class="listitem" style="list-style-type: disc"><code class="literal">restartable</code>: This defines <a id="id61" class="indexterm"/>whether the job should be retartable or not in the case of failure. Set this to <code class="literal">false</code> if the job should not be restarted. By default it is <code class="literal">true</code>.</li></ul></div><p>A validator of type <code class="literal">DefaultJobParametersValidator</code> can be configured as a part of the job configuration to validate simple and optional parameters. The following is a snippet of such a configuration:</p><div class="informalexample"><pre class="programlisting">&lt;beans xmlns:batch ... &gt;
&lt;batch:job id="jobId"&gt;
  &lt;batch:step id="stepId"&gt;
    ...
  &lt;/batch:step&gt;
  &lt;batch:validator ref="validatorId"/&gt;
&lt;/batch:job&gt;

&lt;bean id="validatorId" class="beans.JobParametersValidator"&gt;
  &lt;property name="Keys"&gt;
    &lt;set&gt;
      &lt;value&gt;keyValues&lt;/value&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;</pre></div><p>For complex constraints, the <a id="id62" class="indexterm"/>
<code class="literal">validator</code> interface can also be implemented.</p></div><div class="section" title="Step configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Step configuration</h2></div></div></div><p>Step is the first subelement of a <a id="id63" class="indexterm"/>job. A job can contain multiple steps. The following are different approaches in which multiple steps can be configured:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Multithreaded step (single process):</strong></span> Spring Batch allows you to execute chunks of <a id="id64" class="indexterm"/>work in parallel as a part <a id="id65" class="indexterm"/>of a single process. Each chunk processes a set of records when there is a large amount of data to process in threads.<div class="mediaobject"><img src="Images/3372OS_02_02.jpg" alt="Step configuration" width="600" height="379"/></div><p>The simplest <a id="id66" class="indexterm"/>way to start parallel <a id="id67" class="indexterm"/>processing is by adding <code class="literal">taskExecutor</code> to your step configuration as an attribute of the tasklet.</p><div class="informalexample"><pre class="programlisting">&lt;step id="loading"&gt;
  &lt;tasklet task-executor="taskExecutor"&gt;...&lt;/tasklet&gt;
&lt;/step&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parallel step (single process)</strong></span>: This <a id="id68" class="indexterm"/>is the mechanism <a id="id69" class="indexterm"/>of processing multiple steps in a single process.<div class="mediaobject"><img src="Images/3372OS_02_03.jpg" alt="Step configuration" width="500" height="270"/></div><p>The following is the snippet to configure parallel steps:</p><div class="informalexample"><pre class="programlisting">&lt;job id="jobId"&gt;
  &lt;split id="splitId" task-executor="taskExecutor"
    next="step3"&gt;
    &lt;flow&gt;
      &lt;step id="step1" next="step2"/&gt;
      &lt;step id="step2"/&gt;
    &lt;/flow&gt;
  &lt;/split&gt;
  &lt;step id="step3"/&gt;
&lt;/job&gt;
&lt;beans:bean id="taskExecutor" class="TaskExecutor"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Remote chunking of step (multiprocess)</strong></span>: This splits the step processing across <a id="id70" class="indexterm"/>multiple processes, communicating with each other through a middleware. A step of Spring Batch <a id="id71" class="indexterm"/>acts as the master and the listeners of corresponding middleware act as the slaves. While the master component runs as a single process, slaves are the multiple remote processes.<div class="mediaobject"><img src="Images/3372OS_02_04.jpg" alt="Step configuration" width="412" height="613"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Partitioning a step (single process or multiprocess)</strong></span>: Partitioning is the process in <a id="id72" class="indexterm"/>which one step is <a id="id73" class="indexterm"/>configured to have sub steps. The super step is the master and the sub steps are the slaves. Slave steps have to complete the execution to consider the master step as completed.<div class="mediaobject"><img src="Images/3372OS_02_05.jpg" alt="Step configuration" width="600" height="318"/></div></li></ul></div><p>The following are the attributes of the step element:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code>: This is the <a id="id74" class="indexterm"/>unique identifier for the <code class="literal">step</code> element</li><li class="listitem" style="list-style-type: disc"><code class="literal">next</code>: This is a <a id="id75" class="indexterm"/>shortcut to specify the next step to execute after the current step</li><li class="listitem" style="list-style-type: disc"><code class="literal">parent</code>: This <a id="id76" class="indexterm"/>is the name of the parent step from which a job should inherit</li><li class="listitem" style="list-style-type: disc"><code class="literal">allow-start-if-complete</code>: This is set to <code class="literal">true</code> to allow a step to be started even <a id="id77" class="indexterm"/>if it is already complete</li></ul></div><p>The following is a sample step configuration:</p><div class="informalexample"><pre class="programlisting">&lt;step id="firstBatchStepOne"&gt; 
  &lt;tasklet ref="firstBatch"/&gt; 
&lt;/step&gt; 
&lt;job id="firstBatchJob"&gt; 
  &lt;step id="stepOne" parent="firstBatchStepOne"/&gt; 
&lt;/job&gt;
&lt;bean id="firstBatch" class="FirstBatch"/&gt;</pre></div></div><div class="section" title="Tasklet configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Tasklet configuration</h2></div></div></div><p>Tasklet is the <a id="id78" class="indexterm"/>subelement of the step element that can be used to specify the step process that is repeatable and transactional as part of a step.</p><p>The following are the attributes of the <code class="literal">tasklet</code> element:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ref</code>: This is the <a id="id79" class="indexterm"/>reference to a bean definition that implements the <code class="literal">Tasklet</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allow-start-if-complete</code>: This is set to <code class="literal">true</code> to allow a step to be started <a id="id80" class="indexterm"/>even if it is already complete.</li><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: This is the <a id="id81" class="indexterm"/>method specification for the tasklet execution.</li><li class="listitem" style="list-style-type: disc"><code class="literal">start-limit</code>: This is the <a id="id82" class="indexterm"/>maximum number of times a step may be started.</li><li class="listitem" style="list-style-type: disc"><code class="literal">task-executor</code>: The <a id="id83" class="indexterm"/>task executor is responsible for the execution of the task.</li><li class="listitem" style="list-style-type: disc"><code class="literal">throttle-limit</code>: This is the <a id="id84" class="indexterm"/>maximum number of tasks that can be queued for concurrent processing to prevent thread pools from being overwhelmed. The default value is <code class="literal">4</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transaction-manager</code>: This is the bean name of the transaction manager that is to <a id="id85" class="indexterm"/>be used. Default is <code class="literal">transactionManager</code>, if not specified.</li></ul></div><p>The following is the sample job configuration with tasklet:</p><div class="informalexample"><pre class="programlisting">&lt;step id="firstBatchStepOne"&gt; 
  &lt;tasklet ref="firstBatch" start-limit="6"&gt;
  ...
  &lt;/tasklet&gt; 
&lt;/step&gt; 
&lt;job id="firstBatchJob"&gt; 
  &lt;step id="stepOne" parent="firstBatchStepOne"/&gt; 
&lt;/job&gt;
&lt;bean id="firstBatch" class="FirstBatch"/&gt;</pre></div></div><div class="section" title="Chunk configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Chunk configuration</h2></div></div></div><p>Chunk is the child <a id="id86" class="indexterm"/>element of tasklet that can be used to perform read-write processing. Chunk configuration involves more data beans compared to other element's configuration.</p><p>The following are the attributes of the chunk element:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reader</code>: This is the <a id="id87" class="indexterm"/>bean name of the item reader that is to be used for the process and implements the <code class="literal">ItemReader</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">processor</code>: This is the <a id="id88" class="indexterm"/>bean name of the item processor that is to be used for the process and implements the <code class="literal">ItemProcessor</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">writer</code>: This is the bean <a id="id89" class="indexterm"/>name of the item writer that is to be used for the process and implements the <code class="literal">ItemWriter</code> interface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cache-capacity</code>: This <a id="id90" class="indexterm"/>is the capacity of the cache in the retry policy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">chunk-completion-policy</code>: A transaction will be committed when this policy <a id="id91" class="indexterm"/>decides to complete. Defaults to <code class="literal">SimpleCompletionPolicy</code> with the chunk size equal to the <code class="literal">commit-interval</code> attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">commit-interval</code>: The <a id="id92" class="indexterm"/>number of items that will be processed before <code class="literal">commit</code> is called for the transaction. Set either this or the <code class="literal">chunk-completion-policy</code> attribute, but not both.</li><li class="listitem" style="list-style-type: disc"><code class="literal">processor-transactional</code>: This determines whether the processor is transaction <a id="id93" class="indexterm"/>aware or not.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reader-transactional-queue</code>: This determines whether the reader is a transactional <a id="id94" class="indexterm"/>queue.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retry-limit</code>: This is <a id="id95" class="indexterm"/>the maximum number of times the processing of an item will be retried.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retry-policy</code>: This <a id="id96" class="indexterm"/>is the bean specification of the retry policy. If specified, then the <code class="literal">retry-limit</code> and <code class="literal">retryable</code> exceptions are ignored.</li><li class="listitem" style="list-style-type: disc"><code class="literal">skip-limit</code>: This is the <a id="id97" class="indexterm"/>maximum number of items that will be allowed to be skipped.</li><li class="listitem" style="list-style-type: disc"><code class="literal">skip-policy</code>: This is the <a id="id98" class="indexterm"/>bean specification of skip policy. If specified, then the <code class="literal">skip-limit</code> and <code class="literal">skippable</code> exceptions are ignored.</li></ul></div><p>The following is the sample job configuration with the tasklet chunk:</p><div class="informalexample"><pre class="programlisting">&lt;step id="firstBatchStepOne"&gt; 
  &lt;tasklet ref="firstBatch"&gt;
    &lt;chunk reader="itemReader" processor="itemProcessor" writer="itermWriter" commit-interval="150"/&gt;
  &lt;/tasklet&gt; 
&lt;/step&gt; 
&lt;job id="firstBatchJob"&gt; 
  &lt;step id="stepOne" parent="firstBatchStepOne"/&gt; 
&lt;/job&gt;
&lt;bean id="firstBatch" class="FirstBatch"/&gt;
&lt;bean id="itemReader" class="ItemReader"/&gt;
&lt;bean id="itemProcessor" class="ItemProcessor"/&gt;
&lt;bean id="itemWriter" class="ItemProcessor"/&gt;</pre></div><p>The chunk configuration <a id="id99" class="indexterm"/>can have the exception skip and retry elements added as its child components. The <code class="literal">skippable-exception-classes</code> and <code class="literal">retryable-exception-classes</code> elements for the skip and retry configurations. The bean configuration can as well be annotated to keep the Spring Batch configuration simpler.</p></div><div class="section" title="Transaction configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Transaction configuration</h2></div></div></div><p>Transaction <a id="id100" class="indexterm"/>configuration is one of the key aspects of Spring Batch. The Spring transaction manager is the configuration for transactions. Spring provides diverse transaction managers for diverse specifications; for JDBC it is <code class="literal">DataSourceTransactionManager</code> and for JPA it is <code class="literal">JpaTransactionManager</code>.</p><p>Spring Batch lets us configure the <code class="literal">transaction-attributes</code> element as a child element of the chunk, to set the isolation and propagation levels of the transaction.</p><p>The exceptions for which the rollback operation need not be performed can be chosen. These exceptions can be configured using the <code class="literal">include</code> element as a child of the <code class="literal">no-rollback-exception-classes</code> element, which is a child element of the tasklet.</p><p>The following is a sample job configuration with the transaction manager:</p><div class="informalexample"><pre class="programlisting">&lt;step id="firstBatchStepOne"&gt; 
  &lt;tasklet ref="firstBatch" transaction-manager="transactionManager"&gt;
  ...
  &lt;/tasklet&gt; 
&lt;/step&gt; 
&lt;job id="firstBatchJob"&gt; 
  &lt;step id="stepOne" parent="firstBatchStepOne"/&gt; 
&lt;/job&gt;
&lt;bean id="firstBatch" class="FirstBatch"/&gt;
&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="DataSource"/&gt;
&lt;/bean&gt;</pre></div></div><div class="section" title="Job repository configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Job repository configuration</h2></div></div></div><p>The job repository maintains the <a id="id101" class="indexterm"/>information related to the job execution. It also maintains the state of the batch job. Job repositories are available in two types from Spring Batch: in-memory repository and persistent repository.</p><p>
<span class="strong"><strong>In-memory repository</strong></span> lets <a id="id102" class="indexterm"/>the job run again for the <a id="id103" class="indexterm"/>same job configuration and parameters multiple times. In-memory repository is volatile and so, it does not allow restart between JVM instances. It also cannot guarantee that any two job instances with the same parameters will be launched concurrently, hence, it is not suitable in a multithreaded job or in a locally partitioned step. It can be configured using <code class="literal">MapJobRepositoryFactoryBean</code>.</p><p>It requires the transaction manager for rollback semantics within the repository and to handle the business logic defined in the transactional database.</p><p>The following is a sample in-memory repository configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean"&gt;
  &lt;property name="transactionManager-ref" 
    ref="transactionManager"/&gt;
&lt;/bean&gt;
&lt;bean id="transactionManager"
class="org.springframework.batch.support.transaction.ResourcelessTransactionManager"/&gt;
&lt;job id="deductionsJob" job-repository="jobRepository"&gt;
...
&lt;/job&gt;</pre></div><p>
<span class="strong"><strong>Persistent </strong></span><a id="id104" class="indexterm"/>
<span class="strong"><strong>repository</strong></span> can be configured using the <code class="literal">job-repository</code> <a id="id105" class="indexterm"/>element to perform persistent database operations on a database. The datasource can be configured using any API, for example, we have used Apache commons <code class="literal">BasicDataSource</code> in the following configurations.</p><p>The following is a sample persistent repository configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; 
  &lt;property name="driverClassName" value="${batch.jdbc.driver}" /&gt; 
  &lt;property name="url" value="${batch.jdbc.url}" /&gt; 
  &lt;property name="username" value="${batch.jdbc.user}" /&gt; 
  &lt;property name="password" value="${batch.jdbc.password}" /&gt; 
&lt;/bean&gt; 
&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" lazy-init="true"&gt; 
  &lt;property name="dataSource" ref="dataSource" /&gt; 
&lt;/bean&gt; 
&lt;job-repository id="jobRepository" data-source="dataSource" 
transaction-manager="transactionManager"/&gt;</pre></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="EL and listeners"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>EL and listeners</h1></div></div></div><p>Spring Batch provides an <a id="id106" class="indexterm"/>interesting feature starting from version 3: <span class="strong"><strong>Expression Language</strong></span> (<span class="strong"><strong>EL</strong></span>). <span class="strong"><strong>Spring Expression Language</strong></span> (<span class="strong"><strong>SpEL</strong></span>) lets us make XML configuration <a id="id107" class="indexterm"/>dynamic by capturing the values at runtime from execution context. SpEL can resolve the expressions from both properties and <a id="id108" class="indexterm"/>beans. This runtime capturing behavior lets the job access late binding configurations as well.</p><p>The following is a sample SpEL configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="processBean" class="JobProcessBean" scope="step"&gt; 
  &lt;property name="name" value="#{jobParameters[name]}"/&gt; 
&lt;/bean&gt;</pre></div><div class="section" title="Listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Listeners</h2></div></div></div><p>Spring Batch can be configured to <a id="id109" class="indexterm"/>have a set of additional events identified with the help of listeners. Listeners can be used in different combinations to identify the events at different levels. The following are the various listener types provided by Spring Batch for batch processing.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Job listeners: They identify the job level events</li><li class="listitem" style="list-style-type: disc">Step listeners: They identify the step level events</li><li class="listitem" style="list-style-type: disc">Item listeners: They identify the item repetition and retry events</li></ul></div></div><div class="section" title="Job listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Job listeners</h2></div></div></div><p>Job listeners identify the <a id="id110" class="indexterm"/>events occurring at the job level. Job listeners can be configured by the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Implementing JobExecutionListener</strong></span>: The following is the sample listener configuration <a id="id111" class="indexterm"/>using <code class="literal">JobExecutionListener</code> implementation:<div class="informalexample"><pre class="programlisting">import org.springframework.batch.core.JobExecution; 
import org.springframework.batch.core.JobExecutionListener; 
public class JobStatusListener implements JobExecutionListener {
public void beforeJob(JobExecution jobExecution) { 
  System.out.println("Job: " + 
  jobExecution.getJobInstance().getJobName() + " is beginning"); 
} 
public void afterJob(JobExecution jobExecution) { 
  System.out.println("Job: " + jobExecution.getJobInstance(). 
  getJobName() + " has completed");
  System.out.println("The Job Execution status is: " + 
  jobExecution.getStatus()); 
}
}</pre></div><p>The XML <a id="id112" class="indexterm"/>configuration for the preceding defined listener is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;job id="employeeDeductionsJob"&gt;
  &lt;listeners&gt;
    &lt;listener ref="jobStatusListener"/&gt;
  &lt;/listeners&gt;
&lt;/job&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Using annotations</strong></span>: The <a id="id113" class="indexterm"/>following is the sample listener configuration using annotations:<div class="informalexample"><pre class="programlisting">import org.springframework.batch.core.JobExecution; 
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.annotation.AfterJob;
import org.springframework.batch.core.annotation.BeforeJob; 
public class JobStatusListener { 
@BeforeJob 
public void beforeJob(JobExecution jobExecution) { 
  System.out.println("Job: " + 
  jobExecution.getJobInstance().getJobName() + " is 
  beginning");
} 
@AfterJob 
public void afterJob(JobExecution jobExecution) { 
  System.out.println("Job: " + jobExecution.getJobInstance().getJobName() + " has completed");
  System.out.println("The Job Execution status is: " + 
  jobExecution.getStatus());  
}
}</pre></div></li></ul></div><p>The way to configure the <a id="id114" class="indexterm"/>annotated listener is same as the <code class="literal">JobExecutionListener</code> configuration.</p></div><div class="section" title="Step listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Step listeners</h2></div></div></div><p>Just like job listeners <a id="id115" class="indexterm"/>capture the execution status of jobs, steps have certain listeners to capture different events. The way of implementing this set of listeners is the same as the job listeners (by implementing the corresponding interface or by using annotations), except that the listener element has to be configured as the child element of the <code class="literal">step</code> element.</p><p>The following is a list of step listeners with the methods to override:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">StepExecutionListener</code>: This identifies the before and after of step execution events <a id="id116" class="indexterm"/>using the <code class="literal">beforeStep</code> <a id="id117" class="indexterm"/>and <code class="literal">afterStep</code> methods respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">ChunkListener</code>: This <a id="id118" class="indexterm"/>identifies the before and after of chunk execution events using the <code class="literal">beforeChunk</code> and <code class="literal">afterChunk</code> <a id="id119" class="indexterm"/>methods respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemReadListener</code>: This <a id="id120" class="indexterm"/>identifies if the before and after item is read and when an exception occurs, it reads an item event using the <a id="id121" class="indexterm"/><code class="literal">beforeRead</code>, <code class="literal">afterRead</code>, and <code class="literal">onReadError</code> methods respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemProcessListener</code>: This identifies the state before and after <code class="literal">ItemProcessor</code> <a id="id122" class="indexterm"/>gets an item and when an exception <a id="id123" class="indexterm"/>is thrown by the processor using the <code class="literal">beforeProcess</code>, <code class="literal">afterProcess</code>, and <code class="literal">onProcessError</code> methods respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">ItemWriteListener</code>: This identifies the before and after of when an item is written and when <a id="id124" class="indexterm"/>an exception occurs, writing an <a id="id125" class="indexterm"/>item event using the <code class="literal">beforeWrite</code>, <code class="literal">afterWrite</code>, and <code class="literal">onWriteError</code> methods respectively</li><li class="listitem" style="list-style-type: disc"><code class="literal">SkipListener</code>: This identifies the skip event of reading, processing, or writing an <a id="id126" class="indexterm"/>item using the <code class="literal">onSkipInRead</code>, <code class="literal">onSkipInProcess</code>, and <a id="id127" class="indexterm"/><code class="literal">onSkipInWrite</code> methods <a id="id128" class="indexterm"/>respectively</li></ul></div></div><div class="section" title="Item listeners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Item listeners</h2></div></div></div><p>Item listeners identify the <a id="id129" class="indexterm"/>retry and repeat events. These listeners can be <a id="id130" class="indexterm"/>configured in the same way as job or step listeners.</p><p>The following are the item listeners with the methods to override:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RepeatListener</code>: This <a id="id131" class="indexterm"/>identifies the before and after of each repeat event using the <code class="literal">before</code> and <code class="literal">after</code> methods respectively. It <a id="id132" class="indexterm"/>identifies the first and last repeat event using the <code class="literal">open</code> and <code class="literal">close</code> methods respectively. It also identifies every failure event using the <code class="literal">onError</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RetryListener</code>: This identifies the first and last try event, irrespective of whether the retry is a <a id="id133" class="indexterm"/>success or a failure, using the <a id="id134" class="indexterm"/><code class="literal">open</code> and <code class="literal">close</code> methods respectively. It also identifies the every failure event using the <code class="literal">onError</code> method.</li></ul></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Executing jobs from the command line and web applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Executing jobs from the command line and web applications</h1></div></div></div><p>In the first <a id="id135" class="indexterm"/>chapter, we learned how to configure and <a id="id136" class="indexterm"/>run a simple batch job application using Spring Batch, by launching the job from a Java program. The Java-based API of Spring Batch makes the job launching very convenient through different ways of invoking the batch job. In this section, let's examine the concepts of launching a batch job in different ways and stopping the batch job elegantly.</p><div class="section" title="JobLauncher"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>JobLauncher</h2></div></div></div><p>Spring Batch makes <a id="id137" class="indexterm"/>it easier to launch a batch job with the help of the <code class="literal">JobLauncher</code>. <code class="literal">JobLauncher</code> represents a simple interface to launch a job with a given set of job parameters. The run method of <code class="literal">JobLauncher</code> takes <code class="literal">Job</code> and <code class="literal">JobParameters</code> of type Spring beans as parameters and invokes the batch job execution.</p><p>The following is the code snippet we have used in the previous chapter to launch a job using <code class="literal">JobLauncher</code>:</p><div class="informalexample"><pre class="programlisting">String[] springConfig  = {"batch/firstBatch.xml"};
context = new ClassPathXmlApplicationContext(springConfig);
JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher");
Job job = (Job) context.getBean("firstBatchJob");
JobExecution execution = jobLauncher.run(job, new JobParameters());
System.out.println("Exit Status : " + execution.getStatus());</pre></div><p>We can use <code class="literal">JobParametersBuilder</code> to build different types of <code class="literal">JobParameter</code>. A <code class="literal">JobLauncher</code> can be configured with a persistent job repository, using the following syntax:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="jobLauncher"
class="org.springframework.batch.core.launch.support.SimpleJobLauncher"&gt;
  &lt;property name="jobRepository" ref="jobRepository"/&gt;
&lt;/bean&gt;</pre></div><div class="mediaobject"><img src="Images/3372OS_02_06.jpg" alt="JobLauncher" width="600" height="309"/></div><p>Launching a job from the <code class="literal">run</code> method of <code class="literal">JobLauncher</code> calls <code class="literal">execute</code> on <code class="literal">job</code> and confirms the job execution status (<code class="literal">FINISHED</code> or <code class="literal">FAILED</code>) after execution, which is a synchronous process.</p><p>However, in certain business scenarios, we want the <code class="literal">JobLauncher</code> to invoke and handover the process to another controller to make it asynchronous so that multiple processes can be <a id="id138" class="indexterm"/>triggered. <code class="literal">TaskExecutor</code> helps in this scenario, if configured along with <code class="literal">JobLauncher</code>.</p><div class="mediaobject"><img src="Images/3372OS_02_07.jpg" alt="JobLauncher" width="600" height="309"/></div><p>The following is the <a id="id139" class="indexterm"/>syntax to configure <code class="literal">SimpleJobLauncher</code> with <code class="literal">taskExecutor</code> to make the process asynchronous:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="jobLauncher"
class="org.springframework.batch.core.launch.support.SimpleJobLauncher"&gt;
&lt;property name="jobRepository" ref="jobRepository"/&gt;
&lt;property name="taskExecutor"&gt;
&lt;bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/&gt;
&lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="section" title="Launching a job from a command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Launching a job from a command line</h2></div></div></div><p>A <a id="id140" class="indexterm"/>
<code class="literal">CommandLineJobRunner</code> makes it simple to launch a <a id="id141" class="indexterm"/>Spring Batch job from a command line. The following are the steps in which <code class="literal">CommandLineJobRunner</code> works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading the appropriate <code class="literal">ApplicationContext</code></li><li class="listitem" style="list-style-type: disc">Parsing command-line arguments into <code class="literal">JobParameters</code></li><li class="listitem" style="list-style-type: disc">Locating the appropriate job based on arguments</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">JobLauncher</code> provided in the application context to launch the job</li></ul></div><p>The following is the command to launch a job using <code class="literal">CommandLineJobRunner</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; java -classpath "/lib/*" org.springframework.batch.core.launch.support.CommandLineJobRunner firstBatch.xml firstBatchJob schedule.date(date)=2007/05/05</strong></span>
</pre></div><p>The exit code of the job execution represents the status of the batch job after run, where <code class="literal">0</code> represents <code class="literal">COMPLETED</code>, <code class="literal">1</code> represents <code class="literal">FAILED</code>, and <code class="literal">2</code> represents an error from the command-line job <a id="id142" class="indexterm"/>runner, such as not being able to find a job <a id="id143" class="indexterm"/>in the provided context.</p></div><div class="section" title="Launching a job from within a web application"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Launching a job from within a web application</h2></div></div></div><p>So far, we <a id="id144" class="indexterm"/>have learned how to launch a batch <a id="id145" class="indexterm"/>job from a Java program and command line. There are scenarios when a job needs to be launched from within a web application. Applications that generate reports from within an application and trigger asynchronous processes from the applications with thread-based configuration are such business scenarios.</p><p>The following is the program to launch the job using Spring MVC framework with Spring dependency:</p><div class="informalexample"><pre class="programlisting">@Controller
public class JobLauncherController {
@Autowired
JobLauncher jobLauncher;
@Autowired
Job job;
@RequestMapping("/jobLauncher.html")
public void handle() throws Exception {
  jobLauncher.run(job, new JobParameters());
}
}</pre></div><p>The controller launches the jobs using <code class="literal">JobController</code> that is auto-wired in the <code class="literal">JobLauncherController</code> through configurations. The controller can be called from a request URL with <code class="literal">RequestMapping</code> configured with the <code class="literal">handle</code> method.</p></div><div class="section" title="Stopping batch jobs gracefully"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Stopping batch jobs gracefully</h2></div></div></div><p>Jobs can be <a id="id146" class="indexterm"/>gracefully stopped when necessary from within a program with the help of the <code class="literal">JobOperator</code> interface. <code class="literal">JobOperator</code> provides the CRUD <a id="id147" class="indexterm"/>operations of the job.</p><p>The following is the syntax to stop a job using <code class="literal">JobOperator</code>:</p><div class="informalexample"><pre class="programlisting">Set&lt;Long&gt; executions =jobOperator.getRunningExecutions("jobName");
If( executions.iterator().hasNext()) {
jobOperator.stop(executions.iterator().next());
}</pre></div><p>
<code class="literal">JobOperator</code> identifies the running job with the given <code class="literal">jobName</code> and calls the <code class="literal">stop</code> method by attaining the job <code class="literal">id</code> from executions.</p><p>The <code class="literal">JobOperator</code> needs to be configured to be available for the program. The following is the sample configuration of the <code class="literal">jobOperator</code> with the resources, job explorer (the entry point to browse <a id="id148" class="indexterm"/>executions of running, or historical jobs and steps), registry, and <a id="id149" class="indexterm"/>repository properties.</p><div class="informalexample"><pre class="programlisting">&lt;bean id="jobOperator" class="org.springframework.batch.core.launch.support. SimpleJobOperator"&gt;
&lt;property name="jobExplorer"&gt;
&lt;bean class=" org.springframework.batch.core.explore.support. JobExplorerFactoryBean"&gt;
&lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="jobRepository" ref="jobRepository"/&gt;
&lt;property name="jobRegistry" ref="jobRegistry"/&gt;
&lt;property name="jobLauncher" ref="jobLauncher"/&gt;
&lt;/bean&gt;</pre></div><p>The job configuration supports the stop setup at tasklet and the chunk-oriented step level as well.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Schedulers</h1></div></div></div><p>Schedulers are the <a id="id150" class="indexterm"/>programs that can periodically launch other programs. As mentioned earlier, Spring Batch is not a scheduling framework. Spring Batch can work in conjunction with a scheduler (such as Quartz/Control-M), but cannot replace a scheduler.</p><p>The following are popular schedulers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cron</strong></span>: This is an <a id="id151" class="indexterm"/>expression-based job scheduler available on <a id="id152" class="indexterm"/>Unix-like systems to launch other programs</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Control-M</strong></span>: This is a <a id="id153" class="indexterm"/>batch scheduling software <a id="id154" class="indexterm"/>available for distributed computing platforms including Unix, Windows, Linux, and OpenVMS environments</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Spring scheduler</strong></span>: This scheduler <a id="id155" class="indexterm"/>from Spring <a id="id156" class="indexterm"/>supports XML, or annotation-based or cron expressions to launch a batch job</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Quartz</strong></span>: Quartz is a <a id="id157" class="indexterm"/>richly featured, open source job scheduling <a id="id158" class="indexterm"/>library that can be integrated within virtually any <a id="id159" class="indexterm"/>Java application</li></ul></div><p>While Cron and Control-M can use <code class="literal">CommandLineJobRunner</code> to launch a batch job, Quartz and Spring scheduler can launch the batch job from within the application programmatically. One can choose between these options based on the frequency of job execution and the way it is to be invoked.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we learned the configuration details of the Spring Batch jobs and their components to be able to effectively use them for business needs. We learned how to make the batch programming more efficient and flexible using XML- and annotation-based configurations. We also learned different ways of launching the batch job, such as from a command-line, a Java program, and within a web application, and also how to stop a batch job gracefully from within a program. We completed this chapter with an understanding of the different job schedulers available in the market and which launching solution can be used in combination with these schedulers.</p><p>In the next chapter, we will learn in detail about reading, processing, and writing different forms of data using Spring Batch.</p></div></div>



  </body></html>