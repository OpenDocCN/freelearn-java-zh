- en: Chapter 4. Detour – Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning of this book, we saw that an algorithm is a sequence of steps
    to achieve a result. This way of solving a problem by following a sequence of
    instructions is called imperative programming. Each statement in the program can
    be thought of as an imperative sentence asking the computer to do something. However,
    this is not the only way of looking at it. Functional programming sees an algorithm
    as a composition of components rather than as a sequence of steps. A problem to
    solve is seen as a composition of smaller-sized problems. Instead of using a loop,
    we combine smaller versions of the same problem. Functional programming uses recursion
    as a basic component. A recursion is nothing but solving the same problem for
    a smaller size and then composing the result with something else to get the solution
    for the given size of the problem. This has a far-reaching implication in how
    easy it is to read and understand a program. This makes it very important to study.
  prefs: []
  type: TYPE_NORMAL
- en: There are really two worlds in the programming paradigm. The imperative style
    of programming is favored by C-like languages, such as C, C++, and Java. On the
    purely functional side, there are languages such as Lisp, Haskell, and Scheme.
    Apart from these, some languages try to have the best of both worlds, such as
    Python or Scala. This is easier said than done; trying to mix both ideas in a
    language means you have features to support both, but to use them effectively
    is truly an art.
  prefs: []
  type: TYPE_NORMAL
- en: So, if Java is imperative in nature, why are we talking about functional programming
    in this book? Well, as I pointed out, sometimes, it is better to mix both concepts
    and get the best of both worlds. Recently, the Java community has taken note of
    this fact and has introduced a feature lambda from Java version 8 to provide some
    level of functional programming support. So, our intention is not to program completely
    in functional style, as that is not the preferred programming style of Java, but
    we will do it just enough to make our programs more beautiful and to aid our understanding
    of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce this rather foreign concept to you and provide
    some basic tools that are commonly used in functional programming. You will learn
    the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive algorithms and the immutability of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregations on monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java's support for functional programming, that is, lambda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I have already pointed out, recursive algorithms are a different way of
    thinking about solving a problem. For example, say our problem is to write a program
    that, given a positive integer `n`, returns the sum of numbers from zero to `n`.
    The known imperative way of writing it is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following would be the functional version of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it–just a one-liner! This is probably nothing new to Java programmers,
    as they do understand recursive functions. However, an imperative programmer would
    use recursion only when nothing else worked. But this is a different way of thinking.
    How do we justify that it is equivalent to solving the problem for a smaller input
    and then composing it with something else? Well, we are certainly first computing
    the same function for an input that is smaller by one and then just adding *n*
    to it. There is one more thing to note here: in the imperative version, we are
    updating the variable called `sum` for each value of the loop variable `i`. However,
    in the functional version, we are not updating any variable. What do we achieve
    by that? When a variable is updated multiple times in a program, it is hard to
    understand or debug it because you need to keep track of the latest value. When
    this does not happen, it is far easier to understand what is happening. In fact,
    it makes it simpler in such a way that we can even prove the correctness of the
    program completely formally, which is rather hard to do for imperative programs
    where variables change values.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out another example. This one is about choosing *r* objects from
    *n* objects, where the order does not matter. Let's have a set *A* of a finite
    amount of objects. Let the number of objects in this set be *n*. How many subsets
    *B* of this set *A* have exactly *r* elements? Of course, the maximum number of
    elements any subset of *A* can have is *n*; hence *r ≤ n*. We will call this function
    `choose`. So, we write this as `choose(n,r)`. Now, the only subset that has an
    equal number of elements as *A* is *A* itself. So, `choose(n,n)` equals 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we break this problem into subproblems of a similar nature but with
    smaller input? To find out how many subsets *B* have *r* elements, we first think
    of the set *A* as a combination of a subset *C* with `n-1` elements and one particular
    element *a*. So, we can say *A = C* *⋃* *{a}*. Now, we consider two disjoint cases:
    the element *a* is a member of the subset *B* and when it is not a member of the
    subset *B*. When *a* is not a member of the subset *B*, *B* is also a subset of
    *C*. The number of such subsets *B* with exactly `r` elements is `choose(n-1,r)`,
    since *C* has `n-1` elements. On the other hand, when *a* is a member of the set
    *B*, then *B* can be thought of as a union of two sets – a set *D* that has all
    the elements of *B* except *a*, and the other is just *{a}*. So, *B = D* *⋃* *{a}*.
    Now, you can see that *D* is a subset of *C* that we defined. How many such subsets
    *D* are there of *C*? There are `choose(n-1,r-1)` subsets, since *C* has `n-1`
    elements and *D* has `r-1` elements. So, the number of such subsets *B* is `choose(n-1,r-1)`.
    This means that the total number of sets *B* with or without *a* as an element
    is `choose(n-1,r) + choose(n-1,r-1)`. If we put this in recursive calls, the `r`
    and `n` will get reduced until `r` equals zero or `n` equals `r`. We have already
    considered the case when `n` equals `r`, that is, `choose(n,n)`. When `r` equals
    zero, it means *B* is the null set. Since there is only one null set, `choose(n,0)`
    equals `1`. Now, we put this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That was a little complex, but note that not only did we compute the value of
    the `choose` function, we also sort of proved that it will work. The `choose`
    function is the binomial coefficient function for integral exponents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned implementation is not efficient. To see why, just consider
    what each recursive call of the `choose` function will evaluate to when they both
    fall in the final else case: `choose(n-1,r) = choose(n-2,r) + choose(n-2,r-1)`
    and `choose(n-1,r-1) = choose(n-2,r-1) + choose(n-2,r-2)`. Now note that `choose(n-2,r-1)`
    is being evaluated in both cases, which then would have its own recursive calls.
    This actually significantly increases the asymptotic complexity. We''ll defer
    the analysis of this complexity to the end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on, we need to learn about a feature in Java called **Lambda**.
    Many of you may already know about it. However, since the feature was only introduced
    in version 8, it is better to get familiar with it if you aren't already. It lets
    you pass a block of code, called a lambda expression, as an argument to another
    function. To talk about lambda, we must first see what a functional interface
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Functional interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A functional interface is an interface that has only one unimplemented method,
    that is to say, a class that implements it needs to implement exactly one method.
    The functional interface may have more than one method declared or inherited,
    but as long as we can implement it by implementing exactly one method, it is a
    functional interface. The following example shows one such interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we also marked it as a functional interface with an annotation, but
    it is not necessary. Marking it ensures that Java will show a compile-time error
    if the interface does not have exactly one method that needs to be implemented.
    The following example shows another valid functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are two methods in it. However, since the `toString()` method is already
    implemented in the object class, you need to implement only one method.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an interface with more than one method can be a functional interface
    if all but one has a default implementation. For example, look at the following
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even though this interface has two methods, only one needs to be implemented
    by any implementation. This makes it a functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a functional interface with lambda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what happens if we have a functional interface? We can provide an inline
    implementation of it using a cool syntax called lambda, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the parentheses and the arrow sign. The parentheses contain all
    the parameters. The types of parameters are not specified because they are already
    specified in the interface method. There can be zero or more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of lambda syntax–one that has an expression as the body
    and one that has one or more steps as the body. These lambdas look a bit different
    from each other. A lambda that is implemented as a one liner looks like the one
    we just saw. This is called an **expression** syntax. The expression syntax can
    be used if the lambda expression is a one liner. For multi-line code, we use the
    block syntax as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One can use block syntax for functions that return a value as well, especially
    when using multiple lines of code. In that case, one just needs to use a return
    statement to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since in a functional program all variables must not ever be reassigned, we
    should declare them final to avoid accidentally modifying them. However, since
    typing `final` for every variable clutters the code a bit, we avoid doing so.
    In a purely functional language, the variables are immutable by default. Even
    in a semifunctional language, such as Scala, it is so if it generally encourages
    the functional style. However, since Java mostly prefers an imperative style,
    the `final` keyword is necessary, causing a little clutter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about lambda, we can start learning about functional data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Functional data structures and monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional data structures are data structures that follow the principle of
    immutability and inductive (or recursive) definition. Immutability means that
    any modification of the data structure would result in a new data structure, and
    any old reference to the original version would still have access to the original
    version. Inductive definition means that the definition of the structure is defined
    as a composition of smaller versions of the same data structure. Take, for example,
    our linked list. When we add an element to or remove an element from the beginning
    of the list, it will modify the linked list. That means any reference to the linked
    list will now hold a reference to the modified linked list. This doesn't conform
    to the principle of immutability. A functional linked list would make sure that
    the older references still held reference to an unmodified version. We will discuss
    how to do it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Functional linked lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a linked list that is immutable, we consider a linked list to be made
    of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A head containing the first element of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tail containing another linked list containing the rest of the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that we have now defined the linked list recursively, being true to our
    functional design. This recursion says that a linked list is:'
  prefs: []
  type: TYPE_NORMAL
- en: Either an empty list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or a set of two objects, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A head containing one element of its element type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A tail containing another linked list of the same type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This version of the definition is the same as the previous simplified one, except
    that we have now specified how we represent where the list terminates. The list
    terminates where there are no more elements, that is, when the tail is an empty
    list. Let's put all these in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a version according to the simplified definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the core of immutability for our linked list. Note that every time
    we add a new value to our linked list, we create a new linked list so that the
    old references still hold references to the unmodified list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is self-explanatory, now that we already know how we think about our
    linked list. But note that we have made the constructors private. We don''t want
    people to create inconsistent versions of our linked lists, such as a null `tail`
    or something. We insist that everyone creates our linked list by first creating
    an empty linked list and then adding elements to it. So, we add the following
    `EmptyList` class and `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the linked list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait, did we just modify the `linkedList` variable in the `while` loop?
    Yes, but that does not comply with the principle of immutability. To solve this,
    let''s see what we would mostly want to do with a list. In general, we would want
    to perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Do something for each element of the list. For example, print all the elements
    to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a new list where each element is transformed using a function that is provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute a function of all the elements in the list. This is an aggregation of
    the elements. For example, find the sum of all the elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new list containing only selected elements of the list. This is called
    **filtering**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will deal with them one by one. At the end of the next section, you will
    be prepared to learn about monads as well.
  prefs: []
  type: TYPE_NORMAL
- en: The forEach method for a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `forEach()` method on a linked list would do something for each element
    of the list. This something would be passed as a lambda. For this purpose, we
    will first create a functional interface that consumes one parameter but does
    not return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this interface available, we will define the `forEach()` method for a
    list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ellipsis represent more code that we have already discussed and need not
    be repeated. The `forEach()` method simply processes the head and then recursively
    calls itself on the tail. Note again that, true to our philosophy of recursion,
    we have implemented the `forEach()` method using recursion. Of course, this will
    not work on an empty list because the head and tail are null. The empty list represents
    when the method needs to stop calling itself. We achieve this by overriding the
    `forEach()` method in the `EmptyList` class to not do anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can print all the elements using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass a lambda that, given any element `x`, calls `System.out.println` on
    `x`. But, if you see, this lambda just works as a delegation to the `System.out.println`
    method that already has the required form of the lambda. Java allows you to use
    a method as a lambda with the following syntax. The `::` operator is used to tell
    the compiler that you are not looking for a field with that name; instead you
    are looking for a method with that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that this time we did not even modify the list while printing the elements,
    unlike last time, when we did it using a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Map for a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we move on to the next thing we want to do with a list, which is to create
    a new list where all the elements are transformed according to a lambda that is
    provided. What I mean is that we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to implement the `map()` method in a way that `transformedList` holds
    all the elements of `linkedList` multiplied by `2`, in the same order. The following
    is the implementation of the `map()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the method is defined recursively. The transformed list is just the
    head transformed followed by the tail transformed. We have also overridden the
    method in the `EmptyList` class to return an empty list because an empty list
    transformed is just another empty list of a possibly different type. With this
    implementation in place, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should print a list with all the values multiplied by `2`. You can even
    change the type of the elements by transformation, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `tranformedListString` list is a list of strings, and printing each element
    on the next line shows the strings obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Now we move on to the next thing we want to do with a list, which is to compute
    some function that uses all the values in the list. This is called an **aggregation**
    operation. But before looking at a general case, we will concentrate on a specific
    one, called a **fold** operation.
  prefs: []
  type: TYPE_NORMAL
- en: Fold operation on a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fold operation on a list is an aggregation operation that can be done element
    by element. For example, if we want to compute the sum of all the elements of
    a list, we can do it by taking each element of the list and adding it to a moving
    sum, so when we are done with processing all the elements, we will have the sum
    of all elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two operations that suit this purpose: `foldLeft` and `foldRight`.
    The `foldLeft` operation aggregates the head first and moves on to the tail. The
    `foldRight` method aggregates the tail first and then moves on to the head. Let''s
    start with `foldLeft`. But before doing anything, we need a functional interface
    that represents an expression of two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this interface available, we define the `foldLeft` method in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We compute a new value from `initialValue` and the head using the lambda passed,
    and then we use this updated value to compute `foldLeft` on the tail. The empty
    list overrides this method to just return the `initialValue` itself because it
    just marks the end of the list. Now we can compute the sum of all elements as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have passed `0` as the initial value and the lambda that sums up the values
    passed. This looks complicated until you get used to this idea, but once you get
    used to it, it is very simple. Let''s see what is happening step by step; the
    list from `head` to `tail` is `{0,3,5}`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first invocation, we pass the initial value `0`. The computed `newInitialValue`
    is `0+0 = 0`. Now, we pass this `newInitialValue` to the tail to `foldLeft`, which
    is `{3,5}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `{3,5}` has a `head 3` and `tail {5}`. `3` is added to the `initialValue`
    `0` to give a `newInitialValue 0+3=3`. Now, this new value `3` is passed to the
    tail `{5}` to `foldLeft`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `{5}` has a `head 5` and `tail` and empty list. `5` is added to the `initialValue
    3` to get `8`. Now this `8` is passed as `initialValue` to the `tail`, which is
    an empty list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The empty list, of course, just returns the initial value for a `foldLeft` operation.
    So it returns `8`, and we get the `sum`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instead of computing one value, we can even compute a list as a result. The
    following code reverses a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have simply passed an empty list as an initial operation, and then our operation
    simply adds a new element to the list. In the case of `foldLeft`, the head will
    be added before the tail, causing it to be placed more in the tail side in the
    newly constructed list.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to process the right-most end (or away from the head) first
    and move to the left? This operation is called `foldRight`. This can be implemented
    in a very similar manner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have switched the order of the arguments to make it intuitive that the `initialValue`
    is being combined from the right end of the list. The difference from `foldLeft`
    is that we compute the value on the tail first, calling a `foldRight` on it. Then
    we return the result of the computed value from the tail being combined with the
    head to get the result. In the case of computing a sum, it does not make any difference
    which fold you invoke because sum is commutative, that is, `a+b` always equals
    `b+a`. We can call the `foldRight` operation for the computation of sum in the
    following way, which will give the same sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we use an operator that is not commutative, we will get a different
    result. For example, if we try reversing the list with the `foldRight` method,
    it will give the same list instead of being reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The final thing we wanted to do with a list was filtering. You will learn it
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Filter operation for a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filter is an operation that takes a lambda as a condition and creates a new
    list that has only those elements that satisfy the condition. To demonstrate this,
    we will create a utility method that creates a list of a range of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a helper method that appends a range of numbers to the head
    of an existing list. This method can call itself recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the helper method to generate a list of a range of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us create a list of a range of integers. The range includes the
    start and excludes the end. For example, the following code will create a list
    of numbers from 1 to 99 and then print the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to create a list of all even numbers, say. For that, we create
    a `filter` method in the `LinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter()` method checks whether the the condition is met. If yes, then
    it includes the `head` and calls the `filter()` method on the `tail`. If not,
    then it just calls the `filter()` method on the `tail`. The `EmptyList` of course
    needs to override this method to just return itself because all we need is an
    empty list. Now, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print all the even numbers between 1 and 99\. Let''s go through some
    more examples in order to get used to all this stuff. How do we add all numbers
    from 1 to 100? The following code will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have used the range of `(1,101)` because the end number is not
    included in the generated linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we compute the factorial of a number using this? We define a `factorial`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used Java''s `BigInteger` class because factorials grow too fast and
    an `int` or a `long` cannot hold much. This code demonstrates how we converted
    the list of integers to a list of `BigIntegers` using the `map` method before
    multiplying them with the `foldLeft` method. We can now compute the `factorial`
    of `100` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This example also demonstrates the idea that we can combine the methods we developed
    to solve more complicated problems. Once you get used to this, reading a functional
    program and understanding what it does is a lot simpler than doing the same for
    their imperative versions. We have even used one-character variable names. Actually,
    we could use meaningful names, and in some cases, we should. But here the program
    is so simple and the variables used are so close to where they are defined that
    it's not even necessary to name them descriptively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to repeat a string. Given an integer, `n`, and a string,
    we want the resultant string to be a repetition of the original string `n` number
    of times. For example, given an integer `5` and a string `Hello`, we want the
    output to be `HelloHello HelloHello Hello`. We can do this with the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is first creating a list of length `count` and then
    replacing all its elements with the `seed`. This gives us a new list with all
    the elements equal to the `seed`. This can be folded to get the desired repeated
    string. This is easy to understand because it is very much like the `sum` method,
    except we are adding strings instead of integers, which causes repetition of the
    string. But we don''t even need to do this. We can do this even without creating
    a new list with all the elements replaced. The following will do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just ignore the integer in the list and add the `seed` instead. In
    the first iteration, `a` would be set to the initial value, which is an empty
    string. Every time, we just ignore the content and instead add the `seed` to this
    string. Note that in this case, variable `a` is of the `String` type and variable
    `b` is of the `Integer` type.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can do a lot of things using a linked list, using its special methods
    with lambda parameters. This is the power of functional programming. What we are
    doing with lambda, though, is that we are passing the implementation of interfaces
    as pluggable code. This is not a new concept in an object-oriented language. However,
    without the lambda syntax, it would take a lot of code to define an anonymous
    class to do the equivalent, which would clutter the code a lot, thus undermining
    the simplicity. What has changed though is the immutability, leading to chaining
    of methods and other concepts. We are not thinking about state while analyzing
    the programs; we are simply thinking of it as a chain of transformations. The
    variables are more like variables in algebra, where the value of `x` stays the
    same throughout a formula.
  prefs: []
  type: TYPE_NORMAL
- en: Append on a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have completed all the things that were in the list of the things we wanted
    to do. There may be a few more. One important thing, for example, is `append`.
    This operation sticks one list to another. This can be done using the `foldRight`
    method that we have already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will output `035986`, which is the first list stuck in front of the second
    list.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how it works, first remember what a `foldRight` operation does.
    It starts with an initial value–in this case, the **right hand side** (**RHS**).
    Then it takes one element at a time from the tail end of the list and operates
    on that with the initial list using the provided operation. In our case, the operation
    simply adds an element to the head of the initial list. So, in the end, we get
    the entire list appended to the beginning of the RHS.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing that we want to do with a list, but we have not talked
    about it until now. This concept requires an understanding of the earlier concepts.
    This is called a `flatMap` operation, and we will explore it in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap method on a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flatMap` operation is just like the `map` operation, except we expect
    the operation passed to return a list itself instead of a value. The job of the
    `flatMap` operation is to flatten the lists thus obtained and append them one
    after another. Take for example the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The operation passed returns a range of numbers starting from `0` to `x-1`.
    Since we started the `flatMap` on a list of numbers from 1 to 9, `x` will get
    values from 1 to 9\. Our operation will then return a list containing 0,x-1 for
    each value of `x`. The job of the `flatMap` operation is to then flatten all these
    lists and stick them one after another. Take a look at the following line of code,
    where we print `funnyList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It will print `001012012301234012345012345601234567012345678` on the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we implement the `flatMap` operation? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So what is happening here? First, we compute the list obtained by the `head`
    and the result of the `flatMap` operation on the `tail`. Then we `append` the
    result of the operation on the `head` of the list in front of the list obtained
    by `flatMap` on the tail. In case of an empty list, the `flatMap` operation just
    returns an empty list because there is nothing for the transformation to be called
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw quite a few operations for a linked list. A
    few of them, namely `map` and `flatMap`, are a common theme in many objects in
    functional programming. They have a meaning outside of the list. The `map` and
    `flatMap` methods, and a method to construct a monad from a value are what make
    such a wrapper object a monad. A monad is a common design pattern that is followed
    in functional programming. It is a sort of container, something that stores objects
    of some other class. It can contain one object directly as we will see; it can
    contain multiple objects as we have seen in the case of a linked list, it can
    contain objects that are only going to be available in the future after calling
    some function, and so on. There is a formal definition of monad, and different
    languages name its methods differently. We will only consider the way Java defines
    the methods. A monad must have two methods, called `map()` and `flatMap()`. The
    `map()` method accepts a lambda that works as a transformation for all the contents
    of the monad. The `flatMap` method also takes a method, but instead of returning
    the transformed value, it returns another monad. The `flatMap()` method then extracts
    the output from the monad and creates a transformed monad. We have already seen
    an example of a monad in the form of a linked list. But the general theme does
    not become clear until you have seen a few examples instead of just one. In the
    next section, we will see another kind of monad: an option monad.'
  prefs: []
  type: TYPE_NORMAL
- en: Option monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An option monad is a monad containing a single value. The whole point of this
    is to avoid handling null pointers in our code, which sort of masks the actual
    logic. The point of an option monad is to be able to hold a null value in a way
    that null checks are not required in every step. In some way, an option monad
    can be thought of as a list of zero or one objects. If it contains just zero objects,
    then it represents a null value. If it contains one object, then it works as the
    wrapper of that object. The `map` and `flatMap` methods then behave exactly like
    they would behave in the case of a one-argument list. The class that represents
    an empty option is called `None`. First, we create an abstract class for an option
    monad. Then, we create two inner classes called `Some` and `None` to represent
    an `Option` containing a value and one without a value, respectively. This is
    a more general pattern for developing a monad and can cater to the fact that the
    non-empty `Option` has to store a value. We could do this with a list as well.
    Let''s first see our abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A static method `optionOf` returns the appropriate instance of the `Option`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define the inner class, called `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We create another class, `Some`, to represent a non-empty list. We store the
    value as a single object in the class `Some`, and there is no recursive tail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map` and `flatMap` methods are pretty intuitive. The `map` method accepts
    a transformer and returns a new `Option` where the value is transformed. The `flatMap`
    method does the same, except it expects the transformer to wrap the returned value
    inside another `Option`. This is useful when the transformer can sometimes return
    a null value, in which case the `map` method will return an inconsistent `Option`.
    Instead, the transformer should wrap it in an `Option`, for which we need to use
    a `flatMap` operation. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the usage of an `Option` monad, we will first create a **JavaBean**.
    A JavaBean is an object exclusively intended to store data. It is the equivalent
    of a structure in C. However, since encapsulation is a defining principle of Java,
    the members of the JavaBean are not accessed directly. They are instead accessed
    through special methods called getters and setters. However, our functional style
    dictates that the beans be immutable, so there won''t be any setter methods. The
    following set of classes gives a few examples of JavaBeans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There is not much to understand in these four classes. They are there to store
    a person's data. In Java, it is not very uncommon to hit a case where you will
    hit a very similar kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say, given a variable `person` of type `Person`, we want to print
    the name of the country he/she lives in. If the case is that any of the state
    variables can be null, the correct way to do it with all null checks would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would work, but let''s face it–it''s a whole bunch of null checks.
    We can get a hold of the address simply by using our `Options` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we just print this address, there is a chance that we will print
    null. But it would not result in a null-pointer exception. If we don''t want to
    print null, we need a `forEach` method just like the one in our linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forEach` method just calls the lambda passed on the value it contains,
    and the `None` class overrides it to do nothing. Now, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This code will now not print anything in case of a null name in `country`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what happens if the `Person` class itself is functionally aware and returns
    `Options` to avoid returning null values? This is where we need a `flatMap`. Let''s
    make a new version of all the classes that were a part of the `Person` class.
    For brevity, I will only show the modifications in the `Person` class and show
    how it works. You can then check the modifications on the other classes. Here''s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the code will be modified to use `flatMap` instead of `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The code now fully uses the `Option` monad.
  prefs: []
  type: TYPE_NORMAL
- en: Try monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another monad we can discuss is the `Try` monad. The point of this monad is
    to make exception handing a lot more compact and avoid hiding the details of the
    actual program logic. The semantics of the `map` and `flatMap` methods are self-evident.
    Again, we create two subclasses, one for success and one for failure. The `Success`
    class holds the value that was computed, and the `Failure` class holds the exception
    that was thrown. As usual, `Try` is an abstract class here, containing one static
    method to return the appropriate subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a new `NoArgumentExpressionWithException` class and a `OneArgumentExpressionWithException`
    class that allows exceptions in its body. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `Success` class stores the value of the expression passed to the `of()`
    method. Note that the `of()` method already executes the expression to extract
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact is that this is a class that represents the success of the earlier
    expression; the `flatMap` has to only handle exceptions in the following expression,
    which the following `Try` passed to it handles itself, so we can just return that
    `Try` instance itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map()` method, however, has to execute the expression passed. If there
    is an exception, it returns a `Failure`; otherwise it returns a `Success`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get()` method returns the value as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forEach()` method lets you run another piece of code on the value without
    returning anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This method does not do anything. The same method on the `Failure` class runs
    some code on the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the `Failure` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in both the `flatMap()` and `map()` methods, we just change the type
    of `Failure`, but return one with the same exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no value to be returned in the case of a `Failure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t do anything in the `forEach()` method because there is no value to
    be worked on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method runs some code on the exception contained in the `Failure`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation of the `Try` monad, we can now go ahead and write
    some code that involves handing exceptions. The following code will print the
    first line of the file demo if it exists. Otherwise, it will print the exception.
    It will print any other exception as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note how it removes the clutter in handling exceptions. You should, at this
    stage, be able to see what is going on. Each `map()` method, as usual, transforms
    a value obtained earlier, only, in this case, the code in the `map()` method may
    throw an exception and that would be gracefully contained. The first two `map()`
    methods create a `BufferedReader` in from a `FileInputStream`, while the final
    `map()` method reads a line from the `Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: With this example, I am concluding the monad section. The monadic design pattern
    is ubiquitous in functional programming and it's important to understand this
    concept. We will see a few more monads and some related ideas in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of the complexity of a recursive algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapter, I have conveniently skipped over the complexity analysis
    of the algorithms I have discussed. This was to ensure that you grasp the concepts
    of functional programming before being distracted by something else. Now is the
    time to get back to it.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the complexity of a recursive algorithm involves first creating an
    equation. This is naturally the case because the function is defined in terms
    of itself for a smaller input, and the complexity is also expressed as a function
    of itself being calculated for a smaller input.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we are trying to find the complexity of the `foldLeft`
    operation. The `foldLeft` operation is actually two operations, the first one
    being a fixed operation on the current initial value and the head of the list,
    and then a `foldLeft` operation on the tail. Suppose *T(n)* represents the time
    taken to run a `foldLeft` operation on a list of length *n*. Now, let''s assume
    that the fixed operation takes a time *A*. Then, the definition of the `foldLeft`
    operation suggests that *T(n) = A + T(n-1)*. Now, we would try to find a function
    that solves this equation. In this case, it is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = A + T(n-1)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*=> T(n) – T(n-1) = A*'
  prefs: []
  type: TYPE_NORMAL
- en: This means *T(n)* is an arithmetic progression and thus can be represented as
    *T(n) = An + C*, where *C* is the initial starting point, or *T(0)*.
  prefs: []
  type: TYPE_NORMAL
- en: This means *T(n) = O(n)*. We have already seen how the `foldLeft` operation
    works in linear time. Of course, we have assumed that the the operation involved
    is constant with time. A more complex operation will result in a different complexity.
  prefs: []
  type: TYPE_NORMAL
- en: You are advised to try to compute the complexity of the other algorithms, which
    are not very different from this one. However, I will provide a few more of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we implemented the `choose` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we assume that the time taken is given by the function `T(n,r)`, then `T(n,r)
    = T(n-1,r) + T(n-1,r-1) + C`, where `C` is a constant. Now we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `T(n-1,r) - T(n-2,r) = T(n-2,r-1) + C`, by simply having `n-1` in
    place of *n*. By stacking such values, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding equation considers *n-r* such steps in total. If we sum both
    sides of the stack, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, *T(r,r)* is constant time. Let''s call it *B*. Hence, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can apply the same formula to *T(i,r-1)* too. This will give us
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives the the following after simplification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can continue this way and we will eventually get an expression with multiple
    nested summations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here A''s and D''s are also constants. When we are talking about asymptotic
    complexity, we need to assume that a variable is sufficiently large. In this case,
    there are two variables, with the condition that *r* is always less than or equal
    to *n*. So, first we consider the case where *r* is fixed and *n* is being increased
    and being made sufficiently large. In this case, there would be a total of *r*
    summations nested in one another. *T(t,0)* is a constant time. The summation has
    *r* depth, each having a maximum of *(n-r)* elements, so it is *O((n-r)r)*. The
    other terms are *O((n-r)r)*. Hence we can say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The size of the input is of course not *n*; it is *log n = u (say)*. Then, we
    have the complexity of computation of *T(n,r) = O(2sr)*.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting case would be when we increase both *r* and *n* while also
    increasing the difference between them. To do that, we may want a particular ratio
    between the two, we assume *r/n= k, k<1* always. Then we can see the asymptotic
    growth of the function *T(n, kn)*. But computing this requires calculus and is
    outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that even though the analysis of algorithms in functional form can
    be easier, the analysis of the time complexity can be fairly difficult. It is
    easy to understand why it is more difficult to compute the complexity of a functional
    algorithm. At the end of the day, computing complexity involves counting the number
    of steps required to do the computation. In the imperative style, steps of computation
    are direct, so it is easy to count them. On the other hand, a recursive style
    is a higher level of abstraction, and hence, counting the number of steps is harder.
    In the succeeding chapters, we will see more of these analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Performance of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think about it, the whole point of functional programming is to have immutability
    and recursive definitions (or inductive definitions) of programs so that they
    can be analyzed easily. In general, adding additional constraints on your program
    would make it simpler to analyze but would reduce what you can do with it. Functional
    programming, of course, adds additional constraints on imperative programming
    in the form of immutability, that is, you are no longer allowed to reassign a
    variable. This is done so that the analysis of the program, that is, understanding
    how the program works, is now simpler. It is also simpler to prove theorems about
    the programs. However, we also lose some of the things that we could do without
    such restrictions. It turns out that any program can be rewritten in a functional
    style in a way to produce the same results. However, no guarantees are made about
    their performance or complexity in general. So, a functional version of a program
    can be a lot less efficient than its imperative counterpart. And indeed, in real
    life, we face many such scenarios. So, it is really a tradeoff between performance
    and simplicity. The general direction should then be that when working with a
    large input size, it is better to do away with restrictions in order to be able
    to optimize more. On the other hand, when the input sizes are small, it makes
    sense to stick to a functional style because the performance is probably not affected
    much by it.
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases, though, where the functional version has the same running
    time complexity as the imperative version. In such a case, a functional version
    might be preferred because of its simplicity. It should be noted that since Java
    does not provide any explicit way of garbage collection and really, it happens
    by chance or outside the control of the programmer, a functional programming style
    will fill up the heap very quickly because of being immutable and thus being thrown
    away right after being created. So, it will not be advisable to use them where
    performance is really a problem.
  prefs: []
  type: TYPE_NORMAL
- en: This would seem really contrary to the fact that many large data processing
    systems, such as Spark, use a functional programming style. However, these systems
    only have a specialized language that gives an appearance of a functional programming
    style; they get translated to an almost non-functional form before they are even
    executed. To elaborate a little more, a map method in a monad may not evaluate
    anything at all; instead, it may just create a new object that contains this operator.
    A general program can then analyze these structures and construct an imperative
    program that does the same work. This provides a simple interface to the person
    using the framework as well as keeping the resource usage under control. In the
    next chapter, we will explore some of these ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a new way of looking at algorithms. The functional
    style of writing a program can simplify the analysis of its correctness, that
    is, you can easily understand why the program produces correct output. We saw
    a few patterns in functional programming, especially monads. We also saw how Java
    provides support for the functional style of programming through the syntax called
    lambda, which has existed from version 9 of Java. Finally, we saw how to use lambda
    effectively for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programs are, in general, easier to verify for correctness, but it
    is harder to compute their complexity. They generally perform either at the same
    speed as or slower than their imperative counterparts. It is a trade-off between
    development effort and computational efficiency. For smaller inputs, it is thus
    desirable to have a functional style of programming, whereas for processing large
    inputs, imperative style may be preferred.
  prefs: []
  type: TYPE_NORMAL
