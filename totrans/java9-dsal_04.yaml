- en: Chapter 4. Detour – Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。绕道——函数式编程
- en: In the beginning of this book, we saw that an algorithm is a sequence of steps
    to achieve a result. This way of solving a problem by following a sequence of
    instructions is called imperative programming. Each statement in the program can
    be thought of as an imperative sentence asking the computer to do something. However,
    this is not the only way of looking at it. Functional programming sees an algorithm
    as a composition of components rather than as a sequence of steps. A problem to
    solve is seen as a composition of smaller-sized problems. Instead of using a loop,
    we combine smaller versions of the same problem. Functional programming uses recursion
    as a basic component. A recursion is nothing but solving the same problem for
    a smaller size and then composing the result with something else to get the solution
    for the given size of the problem. This has a far-reaching implication in how
    easy it is to read and understand a program. This makes it very important to study.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们看到了算法是一系列步骤以实现结果。通过遵循一系列指令来解决问题的这种方式被称为命令式编程。程序中的每个语句都可以被视为一个命令句，要求计算机做某事。然而，这并不是看待问题的唯一方式。函数式编程将算法视为组件的组合，而不是步骤的序列。要解决的问题被视为更小问题的组合。我们不是使用循环，而是将相同问题的较小版本组合起来。函数式编程使用递归作为基本组件。递归不过是针对较小规模的问题进行求解，然后将结果与其它东西组合起来以获得给定规模问题的解决方案。这在如何轻松阅读和理解程序方面有着深远的影响。这使得研究它变得非常重要。
- en: There are really two worlds in the programming paradigm. The imperative style
    of programming is favored by C-like languages, such as C, C++, and Java. On the
    purely functional side, there are languages such as Lisp, Haskell, and Scheme.
    Apart from these, some languages try to have the best of both worlds, such as
    Python or Scala. This is easier said than done; trying to mix both ideas in a
    language means you have features to support both, but to use them effectively
    is truly an art.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程范式中有两个世界。命令式编程风格受到C语言族，如C、C++和Java的青睐。在纯函数式方面，有Lisp、Haskell和Scheme等语言。除此之外，一些语言试图兼得两者之优，如Python或Scala。这说起来容易做起来难；试图在语言中混合这两种思想意味着你需要有支持两者的特性，但有效地使用它们确实是一种艺术。
- en: So, if Java is imperative in nature, why are we talking about functional programming
    in this book? Well, as I pointed out, sometimes, it is better to mix both concepts
    and get the best of both worlds. Recently, the Java community has taken note of
    this fact and has introduced a feature lambda from Java version 8 to provide some
    level of functional programming support. So, our intention is not to program completely
    in functional style, as that is not the preferred programming style of Java, but
    we will do it just enough to make our programs more beautiful and to aid our understanding
    of algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果Java本质上是命令式的，为什么我们在这本书中要讨论函数式编程呢？好吧，正如我指出的，有时候，混合这两种概念会更好，取其精华。最近，Java社区已经注意到这一点，并在Java
    8版本中引入了lambda特性，以提供一定程度的函数式编程支持。因此，我们的意图并不是完全以函数式风格编程，因为那不是Java首选的编程风格，但我们会做到足以使我们的程序更加美观，并有助于我们理解算法。
- en: 'This chapter will introduce this rather foreign concept to you and provide
    some basic tools that are commonly used in functional programming. You will learn
    the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍这个相对陌生的概念，并提供一些在函数式编程中常用的一些基本工具。您将学习以下概念：
- en: Recursive algorithms and the immutability of variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归算法和变量的不可变性
- en: Monads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子
- en: Aggregations on monads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子上的聚合
- en: Java's support for functional programming, that is, lambda.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java对函数式编程的支持，即lambda。
- en: Recursive algorithms
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归算法
- en: 'As I have already pointed out, recursive algorithms are a different way of
    thinking about solving a problem. For example, say our problem is to write a program
    that, given a positive integer `n`, returns the sum of numbers from zero to `n`.
    The known imperative way of writing it is simple:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经指出的，递归算法是解决问题的一种不同思维方式。例如，假设我们的问题是编写一个程序，给定一个正整数 `n`，返回从零到 `n` 的数字之和。已知的过程式编写方式很简单：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following would be the functional version of the problem:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是该问题的函数式版本：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That''s it–just a one-liner! This is probably nothing new to Java programmers,
    as they do understand recursive functions. However, an imperative programmer would
    use recursion only when nothing else worked. But this is a different way of thinking.
    How do we justify that it is equivalent to solving the problem for a smaller input
    and then composing it with something else? Well, we are certainly first computing
    the same function for an input that is smaller by one and then just adding *n*
    to it. There is one more thing to note here: in the imperative version, we are
    updating the variable called `sum` for each value of the loop variable `i`. However,
    in the functional version, we are not updating any variable. What do we achieve
    by that? When a variable is updated multiple times in a program, it is hard to
    understand or debug it because you need to keep track of the latest value. When
    this does not happen, it is far easier to understand what is happening. In fact,
    it makes it simpler in such a way that we can even prove the correctness of the
    program completely formally, which is rather hard to do for imperative programs
    where variables change values.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——只是一行代码！这或许对Java程序员来说并不新鲜，因为他们确实理解递归函数。然而，命令式程序员只有在其他方法都不奏效时才会使用递归。但这是一种不同的思维方式。我们如何证明这种方法等同于先解决一个较小输入的问题，然后再将其与其他东西组合起来？嗯，我们当然首先计算一个比输入小一的相同函数，然后仅仅给它加上*n*。这里还有一点需要注意：在命令式版本中，我们为循环变量*i*的每个值更新名为`sum`的变量。然而，在函数式版本中，我们并没有更新任何变量。我们通过这样做达到了什么效果？当一个变量在程序中被多次更新时，理解或调试它都很困难，因为你需要跟踪最新的值。当这种情况没有发生时，理解正在发生的事情就简单得多。事实上，它使事情变得如此简单，以至于我们甚至可以完全形式化地证明程序的正确性，这对于变量值变化的命令式程序来说是非常困难的。
- en: Let's check out another example. This one is about choosing *r* objects from
    *n* objects, where the order does not matter. Let's have a set *A* of a finite
    amount of objects. Let the number of objects in this set be *n*. How many subsets
    *B* of this set *A* have exactly *r* elements? Of course, the maximum number of
    elements any subset of *A* can have is *n*; hence *r ≤ n*. We will call this function
    `choose`. So, we write this as `choose(n,r)`. Now, the only subset that has an
    equal number of elements as *A* is *A* itself. So, `choose(n,n)` equals 1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。这个例子是关于从*n*个对象中选择*r*个对象，其中顺序并不重要。让我们有一个包含有限数量对象的集合*A*。设这个集合中的对象数量为*n*。这个集合*A*有多少个子集*B*恰好有*r*个元素？当然，任何子集*A*的最大元素数量是*n*；因此*r
    ≤ n*。我们将这个函数称为`choose`。所以，我们写成`choose(n,r)`。现在，唯一与*A*具有相同元素数量的子集就是*A*本身。所以，`choose(n,n)`等于1。
- en: 'How do we break this problem into subproblems of a similar nature but with
    smaller input? To find out how many subsets *B* have *r* elements, we first think
    of the set *A* as a combination of a subset *C* with `n-1` elements and one particular
    element *a*. So, we can say *A = C* *⋃* *{a}*. Now, we consider two disjoint cases:
    the element *a* is a member of the subset *B* and when it is not a member of the
    subset *B*. When *a* is not a member of the subset *B*, *B* is also a subset of
    *C*. The number of such subsets *B* with exactly `r` elements is `choose(n-1,r)`,
    since *C* has `n-1` elements. On the other hand, when *a* is a member of the set
    *B*, then *B* can be thought of as a union of two sets – a set *D* that has all
    the elements of *B* except *a*, and the other is just *{a}*. So, *B = D* *⋃* *{a}*.
    Now, you can see that *D* is a subset of *C* that we defined. How many such subsets
    *D* are there of *C*? There are `choose(n-1,r-1)` subsets, since *C* has `n-1`
    elements and *D* has `r-1` elements. So, the number of such subsets *B* is `choose(n-1,r-1)`.
    This means that the total number of sets *B* with or without *a* as an element
    is `choose(n-1,r) + choose(n-1,r-1)`. If we put this in recursive calls, the `r`
    and `n` will get reduced until `r` equals zero or `n` equals `r`. We have already
    considered the case when `n` equals `r`, that is, `choose(n,n)`. When `r` equals
    zero, it means *B* is the null set. Since there is only one null set, `choose(n,0)`
    equals `1`. Now, we put this in code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个问题分解成具有相似性质但输入更小的子问题？为了找出有多少个包含 *r* 个元素的子集 *B*，我们首先将集合 *A* 视为包含一个具有 `n-1`
    个元素的子集 *C* 和一个特定元素 *a* 的组合。因此，我们可以表示 *A = C* *⋃* *{a}*. 现在，我们考虑两种不相交的情况：元素 *a*
    是子集 *B* 的成员，以及当它不是子集 *B* 的成员时。当 *a* 不是子集 *B* 的成员时，*B* 也是子集 *C* 的一个子集。具有恰好 `r`
    个元素的这种子集 *B* 的数量是 `choose(n-1,r)`，因为 *C* 有 `n-1` 个元素。另一方面，当 *a* 是集合 *B* 的成员时，那么
    *B* 可以被视为两个集合的并集——一个是除了 *a* 以外包含 *B* 所有元素的集合 *D*，另一个是仅包含 *{a}* 的集合。因此，*B = D*
    *⋃* *{a}*. 现在，你可以看到 *D* 是我们定义的 *C* 的一个子集。*C* 中有多少个这样的子集 *D*？有 `choose(n-1,r-1)`
    个子集，因为 *C* 有 `n-1` 个元素，而 *D* 有 `r-1` 个元素。因此，这种子集 *B* 的数量是 `choose(n-1,r-1)`。这意味着包含或不包含
    *a* 作为元素的子集 *B* 的总数是 `choose(n-1,r) + choose(n-1,r-1)`。如果我们将其放入递归调用中，`r` 和 `n`
    将会减少，直到 `r` 等于零或 `n` 等于 `r`。我们已经考虑了 `n` 等于 `r` 的情况，即 `choose(n,n)`。当 `r` 等于零时，这意味着
    *B* 是空集。由于只有一个空集，`choose(n,0)` 等于 `1`。现在，我们将这个结果放入代码中：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That was a little complex, but note that not only did we compute the value of
    the `choose` function, we also sort of proved that it will work. The `choose`
    function is the binomial coefficient function for integral exponents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，但请注意，我们不仅计算了 `choose` 函数的值，我们还证明了它将如何工作。`choose` 函数是整数指数的二项式系数函数。
- en: 'The aforementioned implementation is not efficient. To see why, just consider
    what each recursive call of the `choose` function will evaluate to when they both
    fall in the final else case: `choose(n-1,r) = choose(n-2,r) + choose(n-2,r-1)`
    and `choose(n-1,r-1) = choose(n-2,r-1) + choose(n-2,r-2)`. Now note that `choose(n-2,r-1)`
    is being evaluated in both cases, which then would have its own recursive calls.
    This actually significantly increases the asymptotic complexity. We''ll defer
    the analysis of this complexity to the end of this chapter.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现并不高效。为了了解原因，只需考虑当 `choose` 函数的每次递归调用都落在最终的 else 情况时，它们将评估为什么：`choose(n-1,r)
    = choose(n-2,r) + choose(n-2,r-1)` 和 `choose(n-1,r-1) = choose(n-2,r-1) + choose(n-2,r-2)`。现在请注意，`choose(n-2,r-1)`
    在两种情况下都被评估，这将导致它自己的递归调用。这实际上显著增加了渐近复杂度。我们将把对这种复杂度的分析推迟到本章的末尾。
- en: Lambda expressions in Java
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 中的 Lambda 表达式
- en: Before moving on, we need to learn about a feature in Java called **Lambda**.
    Many of you may already know about it. However, since the feature was only introduced
    in version 8, it is better to get familiar with it if you aren't already. It lets
    you pass a block of code, called a lambda expression, as an argument to another
    function. To talk about lambda, we must first see what a functional interface
    is.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要了解 Java 中一个名为 **Lambda** 的特性。你们中的许多人可能已经了解它了。然而，由于该特性仅在版本 8 中引入，如果你还不熟悉它，最好了解一下。它允许你将一个称为
    lambda 表达式的代码块作为参数传递给另一个函数。为了讨论 lambda，我们首先必须了解什么是函数式接口。
- en: Functional interface
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式接口
- en: 'A functional interface is an interface that has only one unimplemented method,
    that is to say, a class that implements it needs to implement exactly one method.
    The functional interface may have more than one method declared or inherited,
    but as long as we can implement it by implementing exactly one method, it is a
    functional interface. The following example shows one such interface:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口是一个只有一个未实现方法的接口，也就是说，实现它的类需要恰好实现一个方法。功能接口可以声明或继承多个方法，但只要我们可以通过实现一个方法来实现它，它就是一个功能接口。以下示例显示了一个这样的接口：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that we also marked it as a functional interface with an annotation, but
    it is not necessary. Marking it ensures that Java will show a compile-time error
    if the interface does not have exactly one method that needs to be implemented.
    The following example shows another valid functional interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将它标记为一个带有注解的功能接口，但这并不是必需的。标记它确保如果接口没有恰好一个需要实现的方法，Java 将在编译时显示错误。以下示例显示了另一个有效的功能接口：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are two methods in it. However, since the `toString()` method is already
    implemented in the object class, you need to implement only one method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它中有两个方法。然而，由于 `toString()` 方法已经在对象类中实现，你只需要实现一个方法。
- en: Similarly, an interface with more than one method can be a functional interface
    if all but one has a default implementation. For example, look at the following
    interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个接口有多个方法，但除了一个之外都有默认实现，那么它也可以是一个功能接口。例如，看看以下接口。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this interface has two methods, only one needs to be implemented
    by any implementation. This makes it a functional interface.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个接口有两个方法，但任何实现只需要实现一个。这使得它成为一个功能接口。
- en: Implementing a functional interface with lambda
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 lambda 实现功能接口
- en: 'So, what happens if we have a functional interface? We can provide an inline
    implementation of it using a cool syntax called lambda, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们有一个功能接口会发生什么呢？我们可以使用一个称为 lambda 的酷语法来提供它的内联实现，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Take note of the parentheses and the arrow sign. The parentheses contain all
    the parameters. The types of parameters are not specified because they are already
    specified in the interface method. There can be zero or more parameters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意括号和箭头符号。括号包含所有参数。参数的类型没有指定，因为它们已经在接口方法中指定了。可以有零个或多个参数。
- en: 'There are two kinds of lambda syntax–one that has an expression as the body
    and one that has one or more steps as the body. These lambdas look a bit different
    from each other. A lambda that is implemented as a one liner looks like the one
    we just saw. This is called an **expression** syntax. The expression syntax can
    be used if the lambda expression is a one liner. For multi-line code, we use the
    block syntax as shown below:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的 lambda 语法——一种是以表达式作为主体，另一种是以一个或多个步骤作为主体。这些 lambda 表达式看起来略有不同。作为一行代码实现的
    lambda 表达式看起来就像我们刚才看到的。这被称为**表达式**语法。如果 lambda 表达式是一行代码，则可以使用表达式语法。对于多行代码，我们使用如下所示的块语法：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One can use block syntax for functions that return a value as well, especially
    when using multiple lines of code. In that case, one just needs to use a return
    statement to return a value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回值的函数，也可以使用块语法，尤其是在使用多行代码时。在这种情况下，只需要使用一个返回语句来返回值。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since in a functional program all variables must not ever be reassigned, we
    should declare them final to avoid accidentally modifying them. However, since
    typing `final` for every variable clutters the code a bit, we avoid doing so.
    In a purely functional language, the variables are immutable by default. Even
    in a semifunctional language, such as Scala, it is so if it generally encourages
    the functional style. However, since Java mostly prefers an imperative style,
    the `final` keyword is necessary, causing a little clutter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在函数式程序中所有变量都不应该被重新赋值，我们应该将它们声明为 final 以避免意外修改它们。然而，由于为每个变量键入 `final` 会使代码略显杂乱，我们避免这样做。在纯函数式语言中，变量默认是不可变的。即使在半函数式语言，如
    Scala 中，如果它通常鼓励函数式风格，也是如此。然而，由于 Java 主要偏好命令式风格，`final` 关键字是必要的，这导致了一点点杂乱。
- en: Now that we know about lambda, we can start learning about functional data structures.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 lambda，我们可以开始学习功能数据结构。
- en: Functional data structures and monads
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能数据结构和单子
- en: Functional data structures are data structures that follow the principle of
    immutability and inductive (or recursive) definition. Immutability means that
    any modification of the data structure would result in a new data structure, and
    any old reference to the original version would still have access to the original
    version. Inductive definition means that the definition of the structure is defined
    as a composition of smaller versions of the same data structure. Take, for example,
    our linked list. When we add an element to or remove an element from the beginning
    of the list, it will modify the linked list. That means any reference to the linked
    list will now hold a reference to the modified linked list. This doesn't conform
    to the principle of immutability. A functional linked list would make sure that
    the older references still held reference to an unmodified version. We will discuss
    how to do it in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式数据结构是遵循不可变性和归纳（或递归）定义原则的数据结构。不可变性意味着对数据结构的任何修改都会导致一个新的数据结构，并且任何对原始版本的旧引用仍然可以访问原始版本。归纳定义意味着结构的定义被定义为相同数据结构较小版本的组合。以我们的链表为例。当我们向列表的起始位置添加一个元素或从列表的起始位置删除一个元素时，它会修改链表。这意味着对链表的任何引用现在都将持有对修改后链表的引用。这不符合不可变性的原则。一个函数式链表将确保旧引用仍然引用未修改的版本。我们将在下一节讨论如何实现它。
- en: Functional linked lists
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式链表
- en: 'To make a linked list that is immutable, we consider a linked list to be made
    of two parts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变的链表，我们考虑链表由两部分组成：
- en: A head containing the first element of the list
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含列表第一个元素的头部
- en: A tail containing another linked list containing the rest of the elements
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含另一个包含剩余元素的链表的尾部
- en: 'Note that we have now defined the linked list recursively, being true to our
    functional design. This recursion says that a linked list is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在已经递归地定义了链表，忠实于我们的函数式设计。这种递归表明，链表是：
- en: Either an empty list
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空列表
- en: 'Or a set of two objects, as follows:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者是一组两个对象，如下所示：
- en: A head containing one element of its element type
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含其元素类型的一个元素的头部
- en: A tail containing another linked list of the same type
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含另一个相同类型链表的尾部
- en: This version of the definition is the same as the previous simplified one, except
    that we have now specified how we represent where the list terminates. The list
    terminates where there are no more elements, that is, when the tail is an empty
    list. Let's put all these in code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义版本与之前的简化版本相同，只是我们现在已经指定了如何表示列表的终止位置。列表在元素不再存在时终止，即当尾部是一个空列表时。让我们将这些全部放入代码中。
- en: 'First, we define a version according to the simplified definition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据简化的定义定义一个版本：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the core of immutability for our linked list. Note that every time
    we add a new value to our linked list, we create a new linked list so that the
    old references still hold references to the unmodified list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的链表不可变性的核心。请注意，每次我们向链表添加新值时，我们都会创建一个新的链表，这样旧引用仍然持有对未修改列表的引用：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code is self-explanatory, now that we already know how we think about our
    linked list. But note that we have made the constructors private. We don''t want
    people to create inconsistent versions of our linked lists, such as a null `tail`
    or something. We insist that everyone creates our linked list by first creating
    an empty linked list and then adding elements to it. So, we add the following
    `EmptyList` class and `add()` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在已经很直观了，因为我们已经知道我们是如何思考我们的链表的。但请注意，我们已经将构造函数设为私有。我们不希望人们创建不一致的链表版本，比如一个空的`tail`或类似的东西。我们坚持要求每个人都通过首先创建一个空链表然后向其中添加元素来创建我们的链表。因此，我们添加以下`EmptyList`类和`add()`方法：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can use the linked list as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样使用链表：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But wait, did we just modify the `linkedList` variable in the `while` loop?
    Yes, but that does not comply with the principle of immutability. To solve this,
    let''s see what we would mostly want to do with a list. In general, we would want
    to perform the following operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们在`while`循环中是否修改了`linkedList`变量？是的，但那并不符合不可变性的原则。为了解决这个问题，让我们看看我们通常会对列表做什么。一般来说，我们想要执行以下操作：
- en: Do something for each element of the list. For example, print all the elements
    to the console.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表的每个元素执行某些操作。例如，将所有元素打印到控制台。
- en: Get a new list where each element is transformed using a function that is provided.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个新列表，其中每个元素都使用提供的函数进行转换。
- en: Compute a function of all the elements in the list. This is an aggregation of
    the elements. For example, find the sum of all the elements.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算列表中所有元素的函数。这是元素的总和。例如，找出所有元素的总和。
- en: Create a new list containing only selected elements of the list. This is called
    **filtering**.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个只包含列表中选定元素的新列表。这被称为**过滤**。
- en: We will deal with them one by one. At the end of the next section, you will
    be prepared to learn about monads as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个处理它们。在下一节的末尾，你将准备好学习关于单子（monads）的内容。
- en: The forEach method for a linked list
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链表的`forEach`方法
- en: 'The `forEach()` method on a linked list would do something for each element
    of the list. This something would be passed as a lambda. For this purpose, we
    will first create a functional interface that consumes one parameter but does
    not return anything:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 链表上的`forEach()`方法将对列表的每个元素执行某些操作。这个操作将作为lambda传递。为此，我们首先创建一个功能接口，它消耗一个参数但不返回任何内容：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this interface available, we will define the `forEach()` method for a
    list, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此接口，我们将为列表定义`forEach()`方法，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ellipsis represent more code that we have already discussed and need not
    be repeated. The `forEach()` method simply processes the head and then recursively
    calls itself on the tail. Note again that, true to our philosophy of recursion,
    we have implemented the `forEach()` method using recursion. Of course, this will
    not work on an empty list because the head and tail are null. The empty list represents
    when the method needs to stop calling itself. We achieve this by overriding the
    `forEach()` method in the `EmptyList` class to not do anything.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号表示我们已讨论过的更多代码，无需重复。`forEach()`方法简单地处理头部，然后递归地对自己调用尾部。再次强调，根据我们的递归哲学，我们使用递归实现了`forEach()`方法。当然，这不会在空列表上工作，因为头部和尾部都是null。空列表表示当方法需要停止调用自身时的情况。我们通过在`EmptyList`类中重写`forEach()`方法来不执行任何操作来实现这一点。
- en: 'Now we can print all the elements using the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下代码打印所有元素：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We pass a lambda that, given any element `x`, calls `System.out.println` on
    `x`. But, if you see, this lambda just works as a delegation to the `System.out.println`
    method that already has the required form of the lambda. Java allows you to use
    a method as a lambda with the following syntax. The `::` operator is used to tell
    the compiler that you are not looking for a field with that name; instead you
    are looking for a method with that name:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个lambda，它对任何元素`x`调用`System.out.println`。但是，如果你看到，这个lambda只是作为对已经具有所需lambda形式的`System.out.println`方法的代理。Java允许你使用以下语法将方法用作lambda：`::`运算符用于告诉编译器你正在寻找的不是具有该名称的字段，而是具有该名称的方法：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this time we did not even modify the list while printing the elements,
    unlike last time, when we did it using a loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们在打印元素时甚至没有修改列表，与上次不同，上次我们是使用循环来做的。
- en: Map for a linked list
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链表的映射
- en: 'Now we move on to the next thing we want to do with a list, which is to create
    a new list where all the elements are transformed according to a lambda that is
    provided. What I mean is that we want to do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续进行下一项我们想要对列表做的事情，那就是创建一个新列表，其中所有元素都根据提供的lambda表达式进行了转换。我的意思是，我们想要做以下事情：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to implement the `map()` method in a way that `transformedList` holds
    all the elements of `linkedList` multiplied by `2`, in the same order. The following
    is the implementation of the `map()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以这种方式实现`map()`方法，即`transformedList`包含`linkedList`中所有元素乘以`2`，顺序保持不变。以下是`map()`方法的实现：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As usual, the method is defined recursively. The transformed list is just the
    head transformed followed by the tail transformed. We have also overridden the
    method in the `EmptyList` class to return an empty list because an empty list
    transformed is just another empty list of a possibly different type. With this
    implementation in place, we can do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，方法是通过递归定义的。转换后的列表只是头部转换后跟尾部转换。我们还在`EmptyList`类中重写了该方法，以返回一个空列表，因为转换后的空列表只是另一个可能不同类型的空列表。有了这种实现，我们可以做以下事情：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should print a list with all the values multiplied by `2`. You can even
    change the type of the elements by transformation, such as the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打印出一个所有值都乘以`2`的列表。你甚至可以通过转换来更改元素的类型，如下所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `tranformedListString` list is a list of strings, and printing each element
    on the next line shows the strings obtained.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`tranformedListString`列表是一个字符串列表，打印每个元素到下一行显示了获得的字符串。'
- en: Now we move on to the next thing we want to do with a list, which is to compute
    some function that uses all the values in the list. This is called an **aggregation**
    operation. But before looking at a general case, we will concentrate on a specific
    one, called a **fold** operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续进行下一件事，我们想要对列表做的，那就是计算使用列表中所有值的函数。这被称为**聚合**操作。但在看一般情况之前，我们将专注于一个特定的操作，称为**折叠**操作。
- en: Fold operation on a list
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的折叠操作
- en: A fold operation on a list is an aggregation operation that can be done element
    by element. For example, if we want to compute the sum of all the elements of
    a list, we can do it by taking each element of the list and adding it to a moving
    sum, so when we are done with processing all the elements, we will have the sum
    of all elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的折叠操作是一种可以逐个元素进行的聚合操作。例如，如果我们想要计算列表中所有元素的总和，我们可以通过将列表的每个元素加到一个移动的总和中来实现，这样当我们处理完所有元素后，我们将得到所有元素的总和。
- en: 'There are two operations that suit this purpose: `foldLeft` and `foldRight`.
    The `foldLeft` operation aggregates the head first and moves on to the tail. The
    `foldRight` method aggregates the tail first and then moves on to the head. Let''s
    start with `foldLeft`. But before doing anything, we need a functional interface
    that represents an expression of two parameters:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个操作适合这个目的：`foldLeft`和`foldRight`。`foldLeft`操作首先聚合头部，然后移动到尾部。`foldRight`方法首先聚合尾部，然后移动到头部。让我们从`foldLeft`开始。但在做任何事情之前，我们需要一个表示两个参数表达式的函数接口：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this interface available, we define the `foldLeft` method in the following
    way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个接口，我们以下这种方式定义了`foldLeft`方法：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We compute a new value from `initialValue` and the head using the lambda passed,
    and then we use this updated value to compute `foldLeft` on the tail. The empty
    list overrides this method to just return the `initialValue` itself because it
    just marks the end of the list. Now we can compute the sum of all elements as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用传递的lambda从`initialValue`和头部计算一个新的值，然后我们使用这个更新的值来计算尾部的`foldLeft`。空列表覆盖了这个方法，只返回`initialValue`本身，因为它只是标记了列表的结束。现在我们可以如下计算所有元素的总和：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have passed `0` as the initial value and the lambda that sums up the values
    passed. This looks complicated until you get used to this idea, but once you get
    used to it, it is very simple. Let''s see what is happening step by step; the
    list from `head` to `tail` is `{0,3,5}`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`0`作为初始值，并将求和的lambda传递给这个值。这个看起来很复杂，直到你习惯了这个想法，但一旦习惯了，它就非常简单。让我们一步一步地看看发生了什么；从`head`到`tail`的列表是`{0,3,5}`：
- en: In the first invocation, we pass the initial value `0`. The computed `newInitialValue`
    is `0+0 = 0`. Now, we pass this `newInitialValue` to the tail to `foldLeft`, which
    is `{3,5}`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次调用中，我们传递了初始值`0`。计算出的`newInitialValue`是`0+0 = 0`。现在，我们将这个`newInitialValue`传递给尾部进行`foldLeft`，即`{3,5}`。
- en: The `{3,5}` has a `head 3` and `tail {5}`. `3` is added to the `initialValue`
    `0` to give a `newInitialValue 0+3=3`. Now, this new value `3` is passed to the
    tail `{5}` to `foldLeft`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{3,5}`有一个`head 3`和`tail {5}`。`3`被加到`initialValue 0`上得到`newInitialValue 0+3=3`。现在，这个新值`3`被传递到尾部进行`foldLeft`。'
- en: The `{5}` has a `head 5` and `tail` and empty list. `5` is added to the `initialValue
    3` to get `8`. Now this `8` is passed as `initialValue` to the `tail`, which is
    an empty list.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{5}`有一个`head 5`和空`tail`。`5`被加到`initialValue 3`上得到`8`。现在这个`8`被作为`initialValue`传递给尾部，它是一个空列表。'
- en: The empty list, of course, just returns the initial value for a `foldLeft` operation.
    So it returns `8`, and we get the `sum`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，空列表在`foldLeft`操作中只返回初始值。因此它返回`8`，我们得到了`sum`。
- en: 'Instead of computing one value, we can even compute a list as a result. The
    following code reverses a list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以计算一个列表作为结果，而不是计算一个值。以下代码反转了一个列表：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have simply passed an empty list as an initial operation, and then our operation
    simply adds a new element to the list. In the case of `foldLeft`, the head will
    be added before the tail, causing it to be placed more in the tail side in the
    newly constructed list.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是传递了一个空列表作为初始操作，然后我们的操作简单地添加一个新元素到列表中。在`foldLeft`的情况下，头部将添加到尾部之前，导致它在新构造的列表中更靠近尾部。
- en: 'What if we want to process the right-most end (or away from the head) first
    and move to the left? This operation is called `foldRight`. This can be implemented
    in a very similar manner, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要首先处理最右侧的端点（或远离头部）并移动到左侧，这个操作被称为 `foldRight`。这可以通过非常相似的方式实现，如下所示：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have switched the order of the arguments to make it intuitive that the `initialValue`
    is being combined from the right end of the list. The difference from `foldLeft`
    is that we compute the value on the tail first, calling a `foldRight` on it. Then
    we return the result of the computed value from the tail being combined with the
    head to get the result. In the case of computing a sum, it does not make any difference
    which fold you invoke because sum is commutative, that is, `a+b` always equals
    `b+a`. We can call the `foldRight` operation for the computation of sum in the
    following way, which will give the same sum:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交换了参数的顺序，使其直观地表明 `initialValue` 是从列表的右侧开始组合的。与 `foldLeft` 的区别在于我们首先在尾部计算值，然后调用
    `foldRight`。然后我们返回从尾部组合到头部以获得结果的计算值的结果。在计算总和的情况下，调用哪个折叠没有区别，因为总和是交换的，即 `a+b` 总是等于
    `b+a`。我们可以以下方式调用 `foldRight` 操作来计算总和，这将给出相同的总和：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, if we use an operator that is not commutative, we will get a different
    result. For example, if we try reversing the list with the `foldRight` method,
    it will give the same list instead of being reversed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用一个非交换的运算符，我们将得到不同的结果。例如，如果我们尝试使用 `foldRight` 方法反转列表，它将给出相同的列表而不是反转：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The final thing we wanted to do with a list was filtering. You will learn it
    in the next subsection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要对列表做的最后一件事是过滤。你将在下一小节中学习它。
- en: Filter operation for a linked list
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链表过滤操作
- en: Filter is an operation that takes a lambda as a condition and creates a new
    list that has only those elements that satisfy the condition. To demonstrate this,
    we will create a utility method that creates a list of a range of elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是一个操作，它接受一个lambda作为条件，并创建一个新的列表，其中只包含满足条件的元素。为了演示这一点，我们将创建一个实用方法，用于创建一系列元素的列表。
- en: 'First, we create a helper method that appends a range of numbers to the head
    of an existing list. This method can call itself recursively:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个辅助方法，将一系列数字追加到现有列表的头部。此方法可以递归地调用自己：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we use the helper method to generate a list of a range of numbers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用辅助方法生成一系列数字的列表：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will let us create a list of a range of integers. The range includes the
    start and excludes the end. For example, the following code will create a list
    of numbers from 1 to 99 and then print the list:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够创建一个整数范围的列表。范围包括起始值，但不包括结束值。例如，以下代码将创建一个从1到99的数字列表，然后打印该列表：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We now want to create a list of all even numbers, say. For that, we create
    a `filter` method in the `LinkedList` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要创建一个包含所有偶数的列表，比如说。为此，我们在 `LinkedList` 类中创建一个 `filter` 方法：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `filter()` method checks whether the the condition is met. If yes, then
    it includes the `head` and calls the `filter()` method on the `tail`. If not,
    then it just calls the `filter()` method on the `tail`. The `EmptyList` of course
    needs to override this method to just return itself because all we need is an
    empty list. Now, we can do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 方法检查条件是否满足。如果是，则包括 `head` 并在 `tail` 上调用 `filter()` 方法。如果不是，则仅调用
    `tail` 上的 `filter()` 方法。当然，`EmptyList` 需要重写此方法以仅返回自身，因为我们只需要一个空列表。现在，我们可以做以下操作：'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will print all the even numbers between 1 and 99\. Let''s go through some
    more examples in order to get used to all this stuff. How do we add all numbers
    from 1 to 100? The following code will do that:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出1到99之间的所有偶数。让我们通过一些更多示例来熟悉所有这些内容。我们如何计算从1到100的所有数字之和？以下代码将完成这个任务：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that we have used the range of `(1,101)` because the end number is not
    included in the generated linked list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `(1,101)` 的范围，因为生成的链表不包括结束数字。
- en: 'How do we compute the factorial of a number using this? We define a `factorial`
    method as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个方法来计算一个数的阶乘？我们定义一个 `factorial` 方法如下：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have used Java''s `BigInteger` class because factorials grow too fast and
    an `int` or a `long` cannot hold much. This code demonstrates how we converted
    the list of integers to a list of `BigIntegers` using the `map` method before
    multiplying them with the `foldLeft` method. We can now compute the `factorial`
    of `100` with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example also demonstrates the idea that we can combine the methods we developed
    to solve more complicated problems. Once you get used to this, reading a functional
    program and understanding what it does is a lot simpler than doing the same for
    their imperative versions. We have even used one-character variable names. Actually,
    we could use meaningful names, and in some cases, we should. But here the program
    is so simple and the variables used are so close to where they are defined that
    it's not even necessary to name them descriptively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to repeat a string. Given an integer, `n`, and a string,
    we want the resultant string to be a repetition of the original string `n` number
    of times. For example, given an integer `5` and a string `Hello`, we want the
    output to be `HelloHello HelloHello Hello`. We can do this with the following
    function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What we are doing here is first creating a list of length `count` and then
    replacing all its elements with the `seed`. This gives us a new list with all
    the elements equal to the `seed`. This can be folded to get the desired repeated
    string. This is easy to understand because it is very much like the `sum` method,
    except we are adding strings instead of integers, which causes repetition of the
    string. But we don''t even need to do this. We can do this even without creating
    a new list with all the elements replaced. The following will do it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we just ignore the integer in the list and add the `seed` instead. In
    the first iteration, `a` would be set to the initial value, which is an empty
    string. Every time, we just ignore the content and instead add the `seed` to this
    string. Note that in this case, variable `a` is of the `String` type and variable
    `b` is of the `Integer` type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: So, we can do a lot of things using a linked list, using its special methods
    with lambda parameters. This is the power of functional programming. What we are
    doing with lambda, though, is that we are passing the implementation of interfaces
    as pluggable code. This is not a new concept in an object-oriented language. However,
    without the lambda syntax, it would take a lot of code to define an anonymous
    class to do the equivalent, which would clutter the code a lot, thus undermining
    the simplicity. What has changed though is the immutability, leading to chaining
    of methods and other concepts. We are not thinking about state while analyzing
    the programs; we are simply thinking of it as a chain of transformations. The
    variables are more like variables in algebra, where the value of `x` stays the
    same throughout a formula.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Append on a linked list
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have completed all the things that were in the list of the things we wanted
    to do. There may be a few more. One important thing, for example, is `append`.
    This operation sticks one list to another. This can be done using the `foldRight`
    method that we have already defined:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we perform the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will output `035986`, which is the first list stuck in front of the second
    list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To understand how it works, first remember what a `foldRight` operation does.
    It starts with an initial value–in this case, the **right hand side** (**RHS**).
    Then it takes one element at a time from the tail end of the list and operates
    on that with the initial list using the provided operation. In our case, the operation
    simply adds an element to the head of the initial list. So, in the end, we get
    the entire list appended to the beginning of the RHS.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: There is one more thing that we want to do with a list, but we have not talked
    about it until now. This concept requires an understanding of the earlier concepts.
    This is called a `flatMap` operation, and we will explore it in the next subsection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap method on a linked list
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flatMap` operation is just like the `map` operation, except we expect
    the operation passed to return a list itself instead of a value. The job of the
    `flatMap` operation is to flatten the lists thus obtained and append them one
    after another. Take for example the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The operation passed returns a range of numbers starting from `0` to `x-1`.
    Since we started the `flatMap` on a list of numbers from 1 to 9, `x` will get
    values from 1 to 9\. Our operation will then return a list containing 0,x-1 for
    each value of `x`. The job of the `flatMap` operation is to then flatten all these
    lists and stick them one after another. Take a look at the following line of code,
    where we print `funnyList`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It will print `001012012301234012345012345601234567012345678` on the output.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we implement the `flatMap` operation? Let''s have a look:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So what is happening here? First, we compute the list obtained by the `head`
    and the result of the `flatMap` operation on the `tail`. Then we `append` the
    result of the operation on the `head` of the list in front of the list obtained
    by `flatMap` on the tail. In case of an empty list, the `flatMap` operation just
    returns an empty list because there is nothing for the transformation to be called
    on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a monad
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw quite a few operations for a linked list. A
    few of them, namely `map` and `flatMap`, are a common theme in many objects in
    functional programming. They have a meaning outside of the list. The `map` and
    `flatMap` methods, and a method to construct a monad from a value are what make
    such a wrapper object a monad. A monad is a common design pattern that is followed
    in functional programming. It is a sort of container, something that stores objects
    of some other class. It can contain one object directly as we will see; it can
    contain multiple objects as we have seen in the case of a linked list, it can
    contain objects that are only going to be available in the future after calling
    some function, and so on. There is a formal definition of monad, and different
    languages name its methods differently. We will only consider the way Java defines
    the methods. A monad must have two methods, called `map()` and `flatMap()`. The
    `map()` method accepts a lambda that works as a transformation for all the contents
    of the monad. The `flatMap` method also takes a method, but instead of returning
    the transformed value, it returns another monad. The `flatMap()` method then extracts
    the output from the monad and creates a transformed monad. We have already seen
    an example of a monad in the form of a linked list. But the general theme does
    not become clear until you have seen a few examples instead of just one. In the
    next section, we will see another kind of monad: an option monad.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Option monad
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An option monad is a monad containing a single value. The whole point of this
    is to avoid handling null pointers in our code, which sort of masks the actual
    logic. The point of an option monad is to be able to hold a null value in a way
    that null checks are not required in every step. In some way, an option monad
    can be thought of as a list of zero or one objects. If it contains just zero objects,
    then it represents a null value. If it contains one object, then it works as the
    wrapper of that object. The `map` and `flatMap` methods then behave exactly like
    they would behave in the case of a one-argument list. The class that represents
    an empty option is called `None`. First, we create an abstract class for an option
    monad. Then, we create two inner classes called `Some` and `None` to represent
    an `Option` containing a value and one without a value, respectively. This is
    a more general pattern for developing a monad and can cater to the fact that the
    non-empty `Option` has to store a value. We could do this with a list as well.
    Let''s first see our abstract class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A static method `optionOf` returns the appropriate instance of the `Option`
    class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We now define the inner class, called `None`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We create another class, `Some`, to represent a non-empty list. We store the
    value as a single object in the class `Some`, and there is no recursive tail:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `map` and `flatMap` methods are pretty intuitive. The `map` method accepts
    a transformer and returns a new `Option` where the value is transformed. The `flatMap`
    method does the same, except it expects the transformer to wrap the returned value
    inside another `Option`. This is useful when the transformer can sometimes return
    a null value, in which case the `map` method will return an inconsistent `Option`.
    Instead, the transformer should wrap it in an `Option`, for which we need to use
    a `flatMap` operation. Have a look at the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To understand the usage of an `Option` monad, we will first create a **JavaBean**.
    A JavaBean is an object exclusively intended to store data. It is the equivalent
    of a structure in C. However, since encapsulation is a defining principle of Java,
    the members of the JavaBean are not accessed directly. They are instead accessed
    through special methods called getters and setters. However, our functional style
    dictates that the beans be immutable, so there won''t be any setter methods. The
    following set of classes gives a few examples of JavaBeans:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is not much to understand in these four classes. They are there to store
    a person's data. In Java, it is not very uncommon to hit a case where you will
    hit a very similar kind of object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s say, given a variable `person` of type `Person`, we want to print
    the name of the country he/she lives in. If the case is that any of the state
    variables can be null, the correct way to do it with all null checks would look
    like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This code would work, but let''s face it–it''s a whole bunch of null checks.
    We can get a hold of the address simply by using our `Options` class, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that if we just print this address, there is a chance that we will print
    null. But it would not result in a null-pointer exception. If we don''t want to
    print null, we need a `forEach` method just like the one in our linked list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `forEach` method just calls the lambda passed on the value it contains,
    and the `None` class overrides it to do nothing. Now, we can do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code will now not print anything in case of a null name in `country`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what happens if the `Person` class itself is functionally aware and returns
    `Options` to avoid returning null values? This is where we need a `flatMap`. Let''s
    make a new version of all the classes that were a part of the `Person` class.
    For brevity, I will only show the modifications in the `Person` class and show
    how it works. You can then check the modifications on the other classes. Here''s
    the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, the code will be modified to use `flatMap` instead of `map`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The code now fully uses the `Option` monad.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Try monad
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another monad we can discuss is the `Try` monad. The point of this monad is
    to make exception handing a lot more compact and avoid hiding the details of the
    actual program logic. The semantics of the `map` and `flatMap` methods are self-evident.
    Again, we create two subclasses, one for success and one for failure. The `Success`
    class holds the value that was computed, and the `Failure` class holds the exception
    that was thrown. As usual, `Try` is an abstract class here, containing one static
    method to return the appropriate subclass:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We need a new `NoArgumentExpressionWithException` class and a `OneArgumentExpressionWithException`
    class that allows exceptions in its body. They are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Success` class stores the value of the expression passed to the `of()`
    method. Note that the `of()` method already executes the expression to extract
    the value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The fact is that this is a class that represents the success of the earlier
    expression; the `flatMap` has to only handle exceptions in the following expression,
    which the following `Try` passed to it handles itself, so we can just return that
    `Try` instance itself:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `map()` method, however, has to execute the expression passed. If there
    is an exception, it returns a `Failure`; otherwise it returns a `Success`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `get()` method returns the value as expected:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `forEach()` method lets you run another piece of code on the value without
    returning anything:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This method does not do anything. The same method on the `Failure` class runs
    some code on the exception:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s look at the `Failure` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, in both the `flatMap()` and `map()` methods, we just change the type
    of `Failure`, but return one with the same exception:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is no value to be returned in the case of a `Failure`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We don''t do anything in the `forEach()` method because there is no value to
    be worked on, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following method runs some code on the exception contained in the `Failure`
    instance:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With this implementation of the `Try` monad, we can now go ahead and write
    some code that involves handing exceptions. The following code will print the
    first line of the file demo if it exists. Otherwise, it will print the exception.
    It will print any other exception as well:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note how it removes the clutter in handling exceptions. You should, at this
    stage, be able to see what is going on. Each `map()` method, as usual, transforms
    a value obtained earlier, only, in this case, the code in the `map()` method may
    throw an exception and that would be gracefully contained. The first two `map()`
    methods create a `BufferedReader` in from a `FileInputStream`, while the final
    `map()` method reads a line from the `Reader`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: With this example, I am concluding the monad section. The monadic design pattern
    is ubiquitous in functional programming and it's important to understand this
    concept. We will see a few more monads and some related ideas in the next chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of the complexity of a recursive algorithm
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapter, I have conveniently skipped over the complexity analysis
    of the algorithms I have discussed. This was to ensure that you grasp the concepts
    of functional programming before being distracted by something else. Now is the
    time to get back to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the complexity of a recursive algorithm involves first creating an
    equation. This is naturally the case because the function is defined in terms
    of itself for a smaller input, and the complexity is also expressed as a function
    of itself being calculated for a smaller input.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we are trying to find the complexity of the `foldLeft`
    operation. The `foldLeft` operation is actually two operations, the first one
    being a fixed operation on the current initial value and the head of the list,
    and then a `foldLeft` operation on the tail. Suppose *T(n)* represents the time
    taken to run a `foldLeft` operation on a list of length *n*. Now, let''s assume
    that the fixed operation takes a time *A*. Then, the definition of the `foldLeft`
    operation suggests that *T(n) = A + T(n-1)*. Now, we would try to find a function
    that solves this equation. In this case, it is very simple:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = A + T(n-1)*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '*=> T(n) – T(n-1) = A*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This means *T(n)* is an arithmetic progression and thus can be represented as
    *T(n) = An + C*, where *C* is the initial starting point, or *T(0)*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: This means *T(n) = O(n)*. We have already seen how the `foldLeft` operation
    works in linear time. Of course, we have assumed that the the operation involved
    is constant with time. A more complex operation will result in a different complexity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: You are advised to try to compute the complexity of the other algorithms, which
    are not very different from this one. However, I will provide a few more of these.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we implemented the `choose` function as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we assume that the time taken is given by the function `T(n,r)`, then `T(n,r)
    = T(n-1,r) + T(n-1,r-1) + C`, where `C` is a constant. Now we can do the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Similarly, `T(n-1,r) - T(n-2,r) = T(n-2,r-1) + C`, by simply having `n-1` in
    place of *n*. By stacking such values, we have the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding equation considers *n-r* such steps in total. If we sum both
    sides of the stack, we have the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00022.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Of course, *T(r,r)* is constant time. Let''s call it *B*. Hence, we have the
    following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00023.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can apply the same formula to *T(i,r-1)* too. This will give us
    the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00024.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'This gives the the following after simplification:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00025.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'We can continue this way and we will eventually get an expression with multiple
    nested summations, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Analysis of the complexity of a recursive algorithm](img/00026.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Here A''s and D''s are also constants. When we are talking about asymptotic
    complexity, we need to assume that a variable is sufficiently large. In this case,
    there are two variables, with the condition that *r* is always less than or equal
    to *n*. So, first we consider the case where *r* is fixed and *n* is being increased
    and being made sufficiently large. In this case, there would be a total of *r*
    summations nested in one another. *T(t,0)* is a constant time. The summation has
    *r* depth, each having a maximum of *(n-r)* elements, so it is *O((n-r)r)*. The
    other terms are *O((n-r)r)*. Hence we can say the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The size of the input is of course not *n*; it is *log n = u (say)*. Then, we
    have the complexity of computation of *T(n,r) = O(2sr)*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting case would be when we increase both *r* and *n* while also
    increasing the difference between them. To do that, we may want a particular ratio
    between the two, we assume *r/n= k, k<1* always. Then we can see the asymptotic
    growth of the function *T(n, kn)*. But computing this requires calculus and is
    outside the scope of this book.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: This shows that even though the analysis of algorithms in functional form can
    be easier, the analysis of the time complexity can be fairly difficult. It is
    easy to understand why it is more difficult to compute the complexity of a functional
    algorithm. At the end of the day, computing complexity involves counting the number
    of steps required to do the computation. In the imperative style, steps of computation
    are direct, so it is easy to count them. On the other hand, a recursive style
    is a higher level of abstraction, and hence, counting the number of steps is harder.
    In the succeeding chapters, we will see more of these analyses.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Performance of functional programming
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think about it, the whole point of functional programming is to have immutability
    and recursive definitions (or inductive definitions) of programs so that they
    can be analyzed easily. In general, adding additional constraints on your program
    would make it simpler to analyze but would reduce what you can do with it. Functional
    programming, of course, adds additional constraints on imperative programming
    in the form of immutability, that is, you are no longer allowed to reassign a
    variable. This is done so that the analysis of the program, that is, understanding
    how the program works, is now simpler. It is also simpler to prove theorems about
    the programs. However, we also lose some of the things that we could do without
    such restrictions. It turns out that any program can be rewritten in a functional
    style in a way to produce the same results. However, no guarantees are made about
    their performance or complexity in general. So, a functional version of a program
    can be a lot less efficient than its imperative counterpart. And indeed, in real
    life, we face many such scenarios. So, it is really a tradeoff between performance
    and simplicity. The general direction should then be that when working with a
    large input size, it is better to do away with restrictions in order to be able
    to optimize more. On the other hand, when the input sizes are small, it makes
    sense to stick to a functional style because the performance is probably not affected
    much by it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases, though, where the functional version has the same running
    time complexity as the imperative version. In such a case, a functional version
    might be preferred because of its simplicity. It should be noted that since Java
    does not provide any explicit way of garbage collection and really, it happens
    by chance or outside the control of the programmer, a functional programming style
    will fill up the heap very quickly because of being immutable and thus being thrown
    away right after being created. So, it will not be advisable to use them where
    performance is really a problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This would seem really contrary to the fact that many large data processing
    systems, such as Spark, use a functional programming style. However, these systems
    only have a specialized language that gives an appearance of a functional programming
    style; they get translated to an almost non-functional form before they are even
    executed. To elaborate a little more, a map method in a monad may not evaluate
    anything at all; instead, it may just create a new object that contains this operator.
    A general program can then analyze these structures and construct an imperative
    program that does the same work. This provides a simple interface to the person
    using the framework as well as keeping the resource usage under control. In the
    next chapter, we will explore some of these ideas.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a new way of looking at algorithms. The functional
    style of writing a program can simplify the analysis of its correctness, that
    is, you can easily understand why the program produces correct output. We saw
    a few patterns in functional programming, especially monads. We also saw how Java
    provides support for the functional style of programming through the syntax called
    lambda, which has existed from version 9 of Java. Finally, we saw how to use lambda
    effectively for functional programming.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Functional programs are, in general, easier to verify for correctness, but it
    is harder to compute their complexity. They generally perform either at the same
    speed as or slower than their imperative counterparts. It is a trade-off between
    development effort and computational efficiency. For smaller inputs, it is thus
    desirable to have a functional style of programming, whereas for processing large
    inputs, imperative style may be preferred.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
