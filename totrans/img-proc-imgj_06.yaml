- en: Chapter 6. Developing Macros in ImageJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：在ImageJ中开发宏
- en: 'In this chapter, we will take a look at ways to automate our image processing
    to allow for faster and more efficient processing. The processing we did earlier
    was adequate, but time consuming. When dealing with very large stacks or time
    series, or with many individual files, the processing we performed was good but
    inefficient. We will look at macros in ImageJ and understand how they will help
    us with the processing. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨自动化图像处理的方法，以便实现更快、更高效的图像处理。我们之前所做的处理是足够的，但耗时较长。当处理非常大的堆栈或时间序列，或者处理许多单个文件时，我们执行的处理是好的，但效率不高。我们将探讨ImageJ中的宏，并了解它们如何帮助我们进行图像处理。在本章中，我们将涵盖以下主题：
- en: Recording and running macros
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和运行宏
- en: Modifying macros
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改宏
- en: User input in macros
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏中的用户输入
- en: Progress in macros
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的进度
- en: Running macros in batch mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量运行宏
- en: Installing macros
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装宏
- en: Recording macros
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录宏
- en: Macros are sets of commands that allow you to perform a series of tasks on a
    single image or multiple images. In a macro, you can place all the commands you
    can find in the ImageJ menu structure. A very basic application of a macro is
    to convert images from one specific type into another type. In order to create
    a macro, we could create one from scratch by typing all the commands in a text
    file, which we can then execute. However, if we are using commands from the menu
    structure, an easier way would be to use the macro recorder.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是一系列命令的集合，允许您对单个图像或多个图像执行一系列任务。在宏中，您可以放置ImageJ菜单结构中可以找到的所有命令。宏的一个非常基本的应用是将图像从一种特定类型转换为另一种类型。为了创建一个宏，我们可以从头开始创建，在文本文件中键入所有命令，然后执行。然而，如果我们使用菜单结构中的命令，一个更简单的方法是使用宏记录器。
- en: 'The macro recorder will register every command and selection you make, and
    place them in a simple editor. This is a very simple and fast way to create a
    macro that will perform a basic set of tasks on an image. To begin recording,
    go to **Plugins** | **Macros** | **Record…** from the menu, which will open a
    new recorder window:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 宏记录器将记录您所做的每个命令和选择，并将它们放置在一个简单的编辑器中。这是一种非常简单快捷的方法来创建一个宏，该宏将在图像上执行一组基本任务。要开始记录，从菜单中选择**插件**
    | **宏** | **记录…**，这将打开一个新的记录窗口：
- en: '![Recording macros](img/Insert_image_4909_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![记录宏](img/Insert_image_4909_06_01.jpg)'
- en: The recorder window has a list to allow different types of recordings. The default
    is macro, but it is also possible to record commands for a plugin using Java as
    the recording type. ImageJ also supports JavaScript code and Beanshell scripts
    to run, and these types can also be created here. When JavaScript or BeanShell
    is selected, the commands recorded will look slightly different from the default
    macro commands. There is also an option to set the name of the new macro you are
    creating. Macros in ImageJ do not require an underscore in their names and have
    the `.ijm` extension to indicate that they are ImageJ macros. When you have performed
    all the processing steps you wish to unleash on your image, you can press the
    **Create** button to finalize the macro for saving.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记录窗口有一个列表，允许记录不同类型的记录。默认为宏，但也可以使用Java作为记录类型来记录插件命令。ImageJ还支持JavaScript代码和Beanshell脚本以运行，这些类型也可以在此创建。当选择JavaScript或Beanshell时，记录的命令将与默认宏命令略有不同。还有一个选项可以设置您正在创建的新宏的名称。ImageJ中的宏名称不需要下划线，并且具有`.ijm`扩展名，以表明它们是ImageJ宏。当您完成了所有希望应用于图像的处理步骤后，您可以按**创建**按钮来保存宏。
- en: Recording a macro for conversion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录转换宏
- en: 'Let''s take a look at a simple recording of a macro that will take a multichannel
    image, change the lookup table of the blue channel, and convert it to an RGB image.
    We will use the sample image of the HeLa cells. For better processing, we will
    not include the open image command. So, we will first open the image by going
    to **File** | **Open Samples** | **HeLa Cells**. We will then start the macro
    recorder by going to **Plugins** | **Macros** | **Record…** from the ImageJ menu.
    Make sure that the type is set to **Macro**, and enter a name for your macro.
    Next, we will perform the steps we wish to record in the order we wish to use
    them. To start with, activate the image window and select the blue channel by
    pressing the right arrow key twice. You will see that there are now two commands
    in the recorder window:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的宏录制，该宏将获取多通道图像，更改蓝色通道的查找表，并将其转换为RGB图像。我们将使用HeLa细胞的样本图像。为了更好的处理，我们不会包括打开图像命令。因此，我们首先通过转到**文件**
    | **打开样本** | **HeLa细胞**来打开图像。然后，我们将通过从ImageJ菜单转到**插件** | **宏** | **记录…**来开始宏记录器。确保类型设置为**宏**，并为你的宏输入一个名称。接下来，我们将按照我们希望使用的顺序执行我们希望记录的步骤。首先，激活图像窗口，并通过按两次右箭头键选择蓝色通道。你会看到现在记录器窗口中有两个命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that when you click on the channel bar with the mouse, nothing will be
    recorded and no commands are added to the recorder window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你用鼠标点击通道栏时，不会记录任何内容，也不会向记录器窗口添加任何命令。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The recorder does not record mouse clicks that change the state of the display.
    It does not record mouse clicks to change the channel, frames, or slices in stacks
    nor when you adjust the brightness/contrast. Only the **Set** and **Apply** commands
    will show up in the recorder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器不会记录改变显示状态的鼠标点击。它不会记录用于更改通道、帧或堆栈切片的鼠标点击，也不会记录调整亮度/对比度的操作。只有**设置**和**应用**命令会显示在记录器中。
- en: 'With the blue channel selected, we will now change the LUT of this channel
    to **Cyan** by going to **Image** | **Lookup Tables** | **Cyan** from the menu.
    This will add a new command to the recorder, corresponding to the action we just
    performed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择蓝色通道时，我们将通过从菜单中选择**图像** | **查找表** | **青色**来将此通道的LUT更改为**青色**。这将在记录器中添加一个新命令，对应于我们刚刚执行的操作：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will now perform the last step in this process, which is converting the
    image to an RGB image. To do so, go to **Image** | **Type** | **RGB Color** from
    the menu. A new image will be created of the RGB type, and a new command is added
    to the recorder window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将执行此过程的最后一步，即将图像转换为RGB图像。要做到这一点，请从菜单中选择**图像** | **类型** | **RGB颜色**。将创建一个新的RGB类型图像，并在记录器窗口中添加一个新命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we have a complete macro to convert a three-channel image into an RGB
    image, with a change of the LUT in one channel. The final recorder window will
    look like the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完整的宏，可以将三通道图像转换为RGB图像，并改变一个通道的LUT。最终的记录窗口将类似于以下截图：
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![录制转换宏的截图](img/Insert_image_4909_06_02.jpg)'
- en: 'The name of the macro I have selected is `convert_3ch_rgb.ijm`. When you create
    the macro, this will be the default name used when you save the macro. When you
    push the **Create** button, a new window will open that will look a little different,
    depending on the distribution of ImageJ that you are using. When using Fiji, the
    **Script Editor** window will open, with the commands that we recorded in the
    editor:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的宏名称是 `convert_3ch_rgb.ijm`。当你创建宏时，这将是你保存宏时使用的默认名称。当你点击**创建**按钮时，将打开一个新窗口，其外观会根据你使用的ImageJ版本有所不同。当使用Fiji时，将打开**脚本编辑器**窗口，其中包含我们在编辑器中记录的命令：
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![录制转换宏的截图](img/Insert_image_4909_06_03.jpg)'
- en: The advantage of the Fiji script editor is that it has **syntax highlighting**
    (indicated by the colors for different elements) and line numbering. It also supports
    a tabbed interface, allowing multiple macros to be opened at the same time within
    the same window. This editor also has a run button at the bottom of the window
    to let you run the macro directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Fiji脚本编辑器的优点是它具有**语法高亮**（由不同元素的颜色表示）和行号。它还支持标签式界面，允许在同一窗口中同时打开多个宏。此编辑器在窗口底部还有一个运行按钮，可以直接运行宏。
- en: 'In the standard ImageJ distribution, the editor will look a little more basic,
    and it does not have the added features that the Fiji script editor provides:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的ImageJ发行版中，编辑器看起来会更基础一些，并且它没有Fiji脚本编辑器提供的附加功能：
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![录制转换宏](img/Insert_image_4909_06_04.jpg)'
- en: Notice the lack of highlighting and the absence of line numbers in the editor.
    Once we have created the macro, we can run it using the keyboard shortcut *Ctrl*
    + *R* or by going to **Macros** | **Run** (standard ImageJ) or **Run** | **Run
    (Fiji)**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意编辑器中缺少高亮显示和行号。一旦我们创建了宏，我们可以使用键盘快捷键*Ctrl* + *R*或通过转到**宏** | **运行**（标准ImageJ）或**运行**
    | **运行（Fiji）**来运行它。
- en: 'The recording of the macro allows for many steps to be recorded in sequence.
    However, there is a drawback to the macro as we have it now: we need to open the
    image we want to process ourselves, and we need to save the resulting image as
    well. Furthermore, the macro in its current form only processes the currently
    active image. As long as only one image is open, this will not pose a problem.
    However, when we have more than one image open when we run the macro, we have
    to make sure that the window that we want to process is selected before we run
    the macro. In the next section, we will try to add some commands to deal with
    opening and closing images to allow for more robust processing.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的录制允许按顺序记录多个步骤。然而，我们现在所拥有的宏存在一个缺点：我们需要自己打开我们想要处理的图像，并且我们还需要保存处理后的图像。此外，当前形式的宏只处理当前活动的图像。只要只有一个图像打开，这不会造成问题。然而，当我们运行宏时打开多个图像，我们必须确保在运行宏之前选择我们想要处理的窗口。在下一节中，我们将尝试添加一些命令来处理打开和关闭图像，以便进行更稳健的处理。
- en: Modifying macros
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改宏
- en: The macro we created in the previous section was effective. However, it does
    not deal with opening and closing images. So now, we will look at the process
    of modifying the current macro we now have. Most of the work will be done in the
    editor window, but we will still use the recorder window to discover the functions
    required to open and close images.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中创建的宏是有效的。然而，它没有处理打开和关闭图像。因此，现在，我们将查看修改我们现在拥有的当前宏的过程。大部分工作将在编辑器窗口中完成，但我们仍然会使用录制窗口来发现打开和关闭图像所需的函数。
- en: Let's start by adding an option to open the image you wish to process to the
    macro that we have. I will use the image we used earlier. However, since you are
    more likely to have images saved locally on a disk, we will save the **HeLa Cells**
    image to the local disk. Let's make a folder named `processing` on the desktop
    and store the **HeLa Cells** image in it. To save the image, go to **File** |
    **Save** or press *Ctrl* + *S* and select the folder on the desktop as the destination.
    After saving the image, we can start with the process of opening an image within
    our macro.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给我们的宏添加一个选项开始，以便打开你想要处理的图像。我将使用我们之前使用的图像。然而，由于你更有可能在磁盘上本地保存图像，我们将把**HeLa细胞**图像保存到本地磁盘上。让我们在桌面上创建一个名为`processing`的文件夹，并将**HeLa细胞**图像保存在其中。要保存图像，转到**文件**
    | **保存**或按*Ctrl* + *S*，然后选择桌面上的文件夹作为目标。保存图像后，我们可以在宏中开始打开图像的过程。
- en: 'To start with, we need to make sure our previous macro is opened in the editor
    window and start the macro recorder. We also need to make sure that there are
    no images open. Now, we will start by opening the image we saved by selecting
    **File** | **Open…**. Then, we will select the image from the folder we created
    in the previous step. In the recorder window, we will now see a line that tells
    ImageJ to open the image. When done on our computer, `<username>` will be set
    to the user name that was used when you logged in:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保我们的上一个宏在编辑器窗口中打开，并开始宏录制器。我们还需要确保没有打开任何图像。现在，我们将通过选择**文件** | **打开…**来打开我们保存的图像。然后，我们将从之前步骤中创建的文件夹中选择图像。在录制窗口中，我们现在将看到一行告诉ImageJ打开图像。在我们的计算机上完成时，`<username>`将设置为登录时使用的用户名：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells us that ImageJ requires the `open()`function with a single parameter,
    which is a line of text (called a `string`, delimited by double quotes in Java/ImageJ).
    This line of text contains the full path of the file you wish to open. To implement
    this command into our macro, we need to copy or type this command into the editor
    window on the first line. We can now test whether everything works as we expect
    by running the macro. To do so, we need to close the image and run the macro by
    selecting the editor window and pressing *Ctrl* + *R* to run the macro. If all
    goes well, the image will open, the blue channel will be selected and changed
    to cyan, and finally, the image will be converted to an RGB image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们ImageJ需要带有单个参数的`open()`函数，这个参数是一行文本（在Java/ImageJ中称为“字符串”，由双引号分隔）。这一行文本包含您希望打开的文件的完整路径。为了将此命令实现到我们的宏中，我们需要将此命令复制或输入到编辑窗口的第一行。现在我们可以通过运行宏来测试一切是否按预期工作。为此，我们需要关闭图像并运行宏，通过选择编辑窗口并按*Ctrl*
    + *R*来运行宏。如果一切顺利，图像将打开，蓝色通道将被选中并变为青色，最后，图像将被转换为RGB图像。
- en: 'Next, we will look at how to save the new image to the same folder but with
    a different name. We need to make sure the recorder window is still open, and
    then click on the newly created image to activate it. Next, we will save the image
    as a TIFF file by going to **File** | **Save**. We will keep the name as it was
    set by ImageJ. In the recorder window, we should now see a new line with the save
    command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何将新图像保存到同一文件夹，但使用不同的名称。我们需要确保记录器窗口仍然打开，然后点击新创建的图像以激活它。接下来，我们将通过访问**文件**
    | **保存**将图像保存为TIFF文件。我们将保留ImageJ设置的名称。在记录器窗口中，我们现在应该看到一条新行，包含保存命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command is a little more complex than the open command, as it uses the
    more general `run()` method. The run method takes two parameters: a string with
    the command, (in this case **Save**) and a string with the form `save=[]`, with
    the filename between the square brackets for saving. Note that the user name was
    replaced with `<username>` in this command. It should be changed to the user name
    of your logged-in account. We can now add this command to our script to perform
    the save function.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令比打开命令复杂一些，因为它使用了更通用的`run()`方法。`run()`方法接受两个参数：一个包含命令的字符串（在这种情况下为**保存**）和一个形式为`save=[]`的字符串，其中方括号内为保存的文件名。请注意，在此命令中用户名被替换为`<username>`。它应该更改为您登录账户的用户名。现在我们可以将此命令添加到我们的脚本中，以执行保存功能。
- en: 'Next, to complete the process, we will close all the images that are currently
    open. To do so, we will select the recently saved image and close it. Alternatively,
    we will select **File** | **Close All** from the menu. If we close an image or
    use close all, the following line will be placed in the recorder window, respectively:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了完成这个过程，我们将关闭当前所有打开的图像。为此，我们将选择最近保存的图像并关闭它。或者，我们可以从菜单中选择**文件** | **关闭所有**。如果我们关闭一个图像或使用关闭所有，记录器窗口中分别将放置以下行：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first line means the currently active window will be closed, while the
    second command will close all open images. Since we want to close all the images
    that are open, when we are finished processing, the second command is more suited
    for our macro. We will add the `Close All` command to the script, which means
    our final macro will look as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示当前激活的窗口将被关闭，而第二个命令将关闭所有打开的图像。由于我们希望在处理完毕后关闭所有打开的图像，因此第二个命令更适合我们的宏。我们将添加“关闭所有”命令到脚本中，这意味着我们的最终宏将如下所示：
- en: '![Modifying macros](img/Insert_image_4909_06_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![修改宏](img/Insert_image_4909_06_05.jpg)'
- en: 'When using the script editor in Fiji, we can also see the runs that were performed
    with the current macro in the list below the editor. Using the **Clear** button
    allows us to reset this history. When you open this macro as it is now, it will
    open the image, change the LUT of the third channel, convert it to RGB, save the
    resulting image, and then close all the images. Even though this macro is very
    simple, it processes this image much faster than we will ever be able to do by
    hand. There is only one problem with this macro: it only works for a single image
    in a specific location. If we want to process many different images, this macro
    will not be very practical. We would have to manually change the macro for each
    file that we wish to process. So, in the next section, we will add the possibility
    for the user to select a file when the macro is run.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Fiji中使用脚本编辑器时，我们还可以在编辑器下方的列表中看到使用当前宏执行的操作。使用**清除**按钮可以重置此历史记录。当你以当前形式打开此宏时，它将打开图像，更改第三通道的LUT，将其转换为RGB，保存结果图像，然后关闭所有图像。尽管这个宏非常简单，但它处理图像的速度比我们手动处理要快得多。这个宏只有一个问题：它只适用于特定位置的单个图像。如果我们想处理许多不同的图像，这个宏将不太实用。我们不得不手动为每个要处理的文件更改宏。因此，在下一节中，我们将添加在宏运行时允许用户选择文件的功能。
- en: User input in macros
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏中的用户输入
- en: Our previous macro was very efficient at processing a specific image, but it
    would be more efficient if the macro asked for the file to be processed. To do
    this, we will need to add a method that will ask the user for a file. The only
    problem is that we cannot use the recorder to get this function. We need to find
    a function that asks the user for a file location, which can be done with the
    built-in macro functions available in ImageJ. On the ImageJ website, there is
    an extensive list of all the macro functions that you can access at [http://imagej.nih.gov/ij/developer/macro/functions.html](http://imagej.nih.gov/ij/developer/macro/functions.html).
    The functions are sorted alphabetically.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的宏在处理特定图像方面非常高效，但如果宏要求用户指定要处理的文件，它将更高效。为此，我们需要添加一个方法来要求用户选择文件。唯一的问题是，我们无法使用记录器来获取此功能。我们需要找到一个要求用户输入文件位置的函数，这可以通过ImageJ中可用的内置宏函数来完成。在ImageJ网站上，有一个所有可访问宏函数的详尽列表，您可以在[http://imagej.nih.gov/ij/developer/macro/functions.html](http://imagej.nih.gov/ij/developer/macro/functions.html)找到。函数按字母顺序排序。
- en: Opening a specific file
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开特定文件
- en: 'The function we want is a file open dialog that asks the user to locate an
    image file. The easiest way to find a function on this page is to use the find
    function of your browser to search for relevant keywords. To find the function
    we need, we will use the search term "file open dialog" in the search box. When
    we enter the search term, there will be multiple occurrences on the page, so we
    will look at all the descriptions for each occurrence. In this case, the function
    that describes what we need is a function called `File.openDialog(title)`, and
    the description says that it will display a file open dialog that returns the
    path of the file that the user selects. We will now change our current macro to
    use this function to allow us to change any file that we select. We will change
    the first line of our macro into the following two lines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的函数是一个文件打开对话框，提示用户定位图像文件。在这个页面上找到函数的最简单方法是使用浏览器中的查找功能搜索相关关键词。为了找到我们需要的函数，我们将在搜索框中使用搜索词“file
    open dialog”。当我们输入搜索词时，页面上会有多个出现，因此我们将查看每个出现的所有描述。在这种情况下，描述我们所需功能的函数是名为`File.openDialog(title)`的函数，描述说明它将显示一个文件打开对话框，返回用户选择的文件路径。我们现在将修改当前的宏，使用此函数允许我们更改我们选择的任何文件。我们将修改宏的第一行，变成以下两行：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line tells ImageJ to display a file open dialog with the title **Select
    3 channel image** and then store the path that the user selected in a variable
    called `fname`. On the next line, we modified the `open()` command to use the
    `fname` variable to open the image that the user selected. One thing to note in
    this example is that the variable type is not specified. Macros in ImageJ are
    weakly typed and do not require that you specify the type beforehand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指示ImageJ显示一个标题为**选择3通道图像**的文件打开对话框，并将用户选择的路径存储在一个名为`fname`的变量中。在下一行，我们修改了`open()`命令，使用`fname`变量打开用户选择的图像。在这个例子中需要注意的一点是，没有指定变量类型。ImageJ中的宏是弱类型，不需要事先指定类型。
- en: Saving an image to a folder
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图像保存到文件夹
- en: 'So now, we made the macro a little bit more flexible. We can now select any
    file we wish at any location on the hard disk or attached storage. The only problem
    is that the image is still saved to a fixed location with a fixed name. So now,
    we have to change the portion of our macro that deals with saving the image. There
    are many possible solutions to this problem. We can save the new image in the
    same folder as the image we opened, or we could save it in a different folder
    where we collect all the processed images. We will start with the first option:
    saving it to the same folder as the image that we opened.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在使宏变得更加灵活。我们现在可以选中硬盘或附加存储上任何位置的任何文件。唯一的问题是图像仍然被保存到固定位置和固定名称。所以现在，我们必须更改处理保存图像的宏的部分。这个问题有多个可能的解决方案。我们可以将新图像保存到打开的图像所在的同一文件夹中，或者我们可以将其保存到我们收集所有处理过的图像的不同文件夹中。我们将从第一个选项开始：将其保存到打开的图像所在的同一文件夹中。
- en: 'To get the name of the folder we selected, we can use a function called `File.directory()`,
    which will give us the directory of the last file that was opened using a file
    open dialog. This is exactly what we need for our save function, so let''s start
    by adding this function in our code. To do so, we will add a new line before the
    `run("Save", …)` command and add the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取我们选择的文件夹的名称，我们可以使用一个名为 `File.directory()` 的函数，它将给出使用文件打开对话框打开的最后一个文件的目录。这正是我们保存函数所需要的，所以让我们首先在我们的代码中添加这个函数。为此，我们将在
    `run("Save", …)` 命令之前添加一行，并添加以下代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will store the path of the last opened image in a variable named `fdir`.
    In order to save a file, we need the path but also the filename of the new file.
    The filename in this case is just the title of the created image, so we will use
    a function to get the title of the current image by adding this line underneath
    the `fdir` line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把最后一个打开的图像的路径存储在一个名为 `fdir` 的变量中。为了保存一个文件，我们需要路径以及新文件的文件名。在这个情况下，文件名只是创建的图像的标题，所以我们将使用一个函数通过在
    `fdir` 行下面添加这一行来获取当前图像的标题：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will store the value of the new filename in a variable named `newName`.
    We are now ready to modify the `save` function to use the two variables that we
    created. What we need to do is combine the `fdir` and `newName` variables. We
    can do this within the `save` command, so we will change the old `save` command
    to the following line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新文件名的值存储在一个名为 `newName` 的变量中。我们现在已经准备好修改 `save` 函数以使用我们创建的两个变量。我们需要做的是合并
    `fdir` 和 `newName` 变量。我们可以在 `save` 命令中这样做，所以我们将旧的 `save` 命令更改为以下行：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have replaced the path that was specified between the square brackets with
    the two variables. We had to add a set of quotes between the square brackets to
    interrupt the string, and we used the `+` operator to concatenate the strings.
    We specified the extension of the file we wished to save. As the title of the
    image does not contain an extension at the end of the name, we need to add it.
    Alternatively, we could use the `saveAs` macro command to achieve the same result
    (adding the extension is not required because we will save the image as a TIFF
    file):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用两个变量替换了方括号中指定的路径。我们必须在方括号之间添加一组引号来中断字符串，我们使用了 `+` 操作符来连接字符串。我们指定了要保存的文件的扩展名。由于图像的标题名称末尾不包含扩展名，我们需要添加它。或者，我们可以使用
    `saveAs` 宏命令来实现相同的结果（添加扩展名不是必需的，因为我们将以 TIFF 文件保存图像）：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this case, the `RGB Color` command creates a new image. When calling `Save`
    on a new image, we can change the name, and it will work the same way as the `saveAs`
    command. If your function does not create a new image but you would still like
    to store the result as a separate file, use the `saveAs` command. Otherwise, the
    save function will overwrite the image on the disk with the modified data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`RGB Color` 命令创建了一个新的图像。当在新的图像上调用 `Save` 时，我们可以更改名称，它将以与 `saveAs` 命令相同的方式工作。如果你的函数没有创建新的图像，但你仍然想将结果作为单独的文件存储，请使用
    `saveAs` 命令。否则，保存函数将用修改后的数据覆盖磁盘上的图像。
- en: 'Our macro should now look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们宏现在应该看起来像这样：
- en: '![Saving an image to a folder](img/Insert_image_4909_06_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![将图片保存到文件夹中](img/Insert_image_4909_06_06.jpg)'
- en: Our macro is now more flexible. We can select any file for processing, and the
    result will be stored in the same folder as the original but with a modified name.
    The next step is to modify the code to control which channel will be modified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宏现在更加灵活。我们可以选择任何文件进行处理，结果将存储在原始文件相同的文件夹中，但名称已更改。下一步是修改代码以控制哪个通道将被修改。
- en: Adding choices
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加选择
- en: 'Our macro now allows us to modify any image that we can locate and save the
    result in the same folder. In the next step, we will ask the user which channel
    we wish to change. We need to ask the user for a number between 1 and 3, which
    will be the channel that will be updated. There are two basic ways of retrieving
    a number: we could use a text field where the user can enter a number, or we could
    present a list of numbers where the user can select the correct one. The first
    method is very easy, but also requires additional checking. What if the user enters
    a value larger than the number of channels (or not a number at all)? A slightly
    safer method is to give the user a limited set of choices where only one can be
    selected.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的宏允许我们修改任何我们可以定位并保存结果在同一文件夹中的图像。在下一步中，我们将询问用户我们希望更改哪个频道。我们需要询问用户一个介于1到3之间的数字，这将是要更新的频道。有两种基本的方法来获取一个数字：我们可以使用一个文本字段，用户可以输入一个数字，或者我们可以展示一个数字列表，用户可以从中选择正确的数字。第一种方法非常简单，但也需要额外的检查。如果用户输入的值大于频道数量（或者根本不是数字），会怎样？一个稍微安全的方法是给用户一个有限的选项集，其中只有一个可以被选中。
- en: 'We will use a set of functions related to creating a dialog and adding fields
    to it. We will need to place this code somewhere at the beginning of the macro,
    before we call the next slice command. We will place the following code directly
    after the open command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一组与创建对话框和向其中添加字段相关的函数。我们需要在宏的开始部分放置此代码，在我们调用下一个切片命令之前。我们将以下代码直接放置在打开命令之后：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line will create a dialog with the title `Select a channel`. Next,
    we added a choice list to the newly created dialog with an array containing the
    options `1`, `2`, and `3` as strings. Finally, we called the `show()` method to
    display the dialog we created.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将创建一个标题为`选择一个频道`的对话框。接下来，我们在新创建的对话框中添加了一个选择列表，其中包含选项`1`、`2`和`3`作为字符串。最后，我们调用了`show()`方法来显示我们创建的对话框。
- en: 'We created a dialog that asks the user to select a channel number, but we did
    not use the selection yet. If we run the code as it is now, the result would be
    the same regardless of the selection we make in the dialog. So, our next step
    is to retrieve the user selection and extract the number that the user selected.
    The function to do this is `getChoice()`, which is part of the dialog function.
    We will add it directly after the show command as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个对话框，让用户选择一个频道编号，但我们还没有使用这个选择。如果我们现在运行代码，结果将与我们对话框中做出的选择无关。因此，我们的下一步是检索用户选择并提取用户选择的数字。执行此操作的功能是`getChoice()`，它是对话框功能的一部分。我们将直接在显示命令之后添加它，如下所示：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will store the selected choice in a variable called `chChoice`.
    However, if we look at the description of the function, this function returns
    a string. This is a problem, because we need it to be a number in order to select
    the correct slice. There is a function available to convert a string to an integer
    in the macro language. It is called `parseInt()`, and we can implement it as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将把选定的选择存储在一个名为`chChoice`的变量中。然而，如果我们查看该函数的描述，这个函数返回一个字符串。这是一个问题，因为我们需要它是一个数字，以便选择正确的切片。在宏语言中有一个函数可以将字符串转换为整数。它被称为`parseInt()`，我们可以这样实现它：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `sliceNumber` variable now contains the user''s channel selection. Next,
    we will use this number to select the correct slice in our image. We could use
    a small loop combined with our next slice commands. However, there is a faster
    and simpler method using a built-in macro function called `setSlice()`. To do
    this, replace the two lines with `run("Next Slice [>]")` with the following line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`sliceNumber`变量现在包含用户的频道选择。接下来，我们将使用这个数字来选择我们图像中的正确切片。我们可以使用一个小循环结合我们的下一个切片命令。然而，有一个更快更简单的方法，使用一个内置的宏函数，称为`setSlice()`。为此，将带有`run("Next
    Slice [>]")`的两行替换为以下行：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we wish to also change the color of the lookup table that will be used,
    we could add a second choice list to our dialog using the same methodology. We
    could just add another `addChoice()` command, but this time, with several choices
    of LUTs (for example, cyan, yellow, magenta, and so on). The `getChoice()` function
    retrieves the results of each choice list in the order they are added to the dialog.
    If you add the LUT choice after the channel number, it would be retrieved with
    the second call to `getChoice()`. Our macro will now look as follows (I have added
    the color choice as well):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望更改将要使用的查找表的颜色，我们可以使用相同的方法在我们的对话框中添加第二个选择列表。我们只需添加另一个 `addChoice()` 命令，但这次，提供几个
    LUT（例如，青色、黄色、品红色等）的选择。`getChoice()` 函数按它们添加到对话框中的顺序检索每个选择列表的结果。如果您在通道号之后添加 LUT
    选择，它将通过 `getChoice()` 的第二次调用检索。现在，我们的宏将如下所示（我已添加颜色选择）：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Adding choices](img/Insert_image_4909_06_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![添加选项](img/Insert_image_4909_06_07.jpg)'
- en: There is now a new variable called `clrChoice`, which holds the value of the
    color selection that the user makes. If you run the modified macro, you would
    have to select the image you wish to process and then set the channel and LUT
    color. After this, the image will be processed according to the values you set.
    The macro is now quite flexible and allows for different types of conversions
    of a specific channel with a specific color. We now only need one more modification
    to make it a little more robust. We need to check whether the image that the user
    selected actually has three channels or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个名为 `clrChoice` 的新变量，它保存用户所做的颜色选择的值。如果您运行修改后的宏，您将必须选择要处理的图像，然后设置通道和 LUT
    颜色。之后，图像将根据您设置的值进行处理。现在，宏相当灵活，允许对特定通道进行不同类型的特定颜色转换。我们现在只需要进行一项修改，使其更加健壮。我们需要检查用户选择的图像实际上是否有三个通道。
- en: Performing input checking
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行输入检查
- en: 'To add a check for the number of slices in the selected image, we need a simple
    conditional statement. The `if` statement will perform this check. We will add
    this conditional after we open the image, but before we ask the user for input.
    If there are less than three channels, we need to stop the execution of the macro
    and close the image we opened:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所选图像中添加对切片数量的检查，我们需要一个简单的条件语句。`if` 语句将执行此检查。我们将在打开图像后、请求用户输入之前添加此条件语句。如果通道数少于三个，我们需要停止宏的执行并关闭我们打开的图像：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `nSlices` function is a built-in macro function that returns the number
    of slices of the current image. We will check the value of the number of slices
    against the value that we require. If there are insufficient channels, we would
    close all images and abort the macro using the `exit()` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`nSlices` 函数是一个内置的宏函数，它返回当前图像的切片数。我们将检查切片数的值与所需的值进行比较。如果通道不足，我们将关闭所有图像并使用 `exit()`
    函数终止宏。'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `nSlices` function, remember that ImageJ calculates this value
    by multiplying the number of slices, frames, and channels of an image. When working
    with (hyper)stacks, the `nSlices` function does not return the value you might
    expect. For example, a 5D image with two channels, five slices, and 51 frames
    will return a value of 510 (*2*5*51*). For stacks, you can use the `Stack` methods.
    To count the number of channels, you can use the `Stack.getDimensions()` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `nSlices` 函数时，请记住，ImageJ 通过乘以图像的切片数、帧数和通道数来计算此值。当处理（超）栈时，`nSlices` 函数不会返回您可能期望的值。例如，一个具有两个通道、五个切片和
    51 帧的 5D 图像将返回 510（*2*5*51*）的值。对于栈，您可以使用 `Stack` 方法。要计算通道数，您可以使用 `Stack.getDimensions()`
    函数。
- en: 'There are two forms of the exit function: one without a parameter and one with
    a string parameter. The string parameter will display a message indicating why
    the macro was aborted. It is recommended that you use the latter form to make
    a user understand why the macro is not performing a task by providing feedback.
    Our macro should now look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit` 函数有两种形式：一种不带参数，另一种带字符串参数。字符串参数将显示一条消息，说明为什么宏被终止。建议您使用后者，通过提供反馈让用户了解为什么宏没有执行任务。现在，我们的宏应该如下所示：'
- en: '![Performing input checking](img/Insert_image_4909_06_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![执行输入检查](img/Insert_image_4909_06_08.jpg)'
- en: Our macro is now robust and will run in a predictable way every time we run
    it. If our image has very few slices, it would abort. If it has more slices, it
    would run correctly. However, we will be unable to modify any slice beyond the
    third slice. So, our final modification will check for the number of slices in
    the image and adjust our choices accordingly by manipulating the array of slice
    numbers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宏现在很健壮，每次运行时都会以可预测的方式运行。如果我们的图像切片非常少，它将终止。如果它有更多的切片，它将正确运行。然而，我们将无法修改第三层以上的任何切片。因此，我们的最终修改将检查图像中的切片数量，并通过操作切片号码数组相应地调整我们的选择。
- en: 'To change the content of the choice list, we first need to create an array
    that is slightly longer than the one that is currently specified. We want to limit
    the number of channels somewhat, so we will create an array with five channels
    as a maximum. We will also adjust the check for the number of channels to reflect
    this alteration. We will start by creating an array containing numbers `1` through
    `5` as strings and modify the conditional statement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改选择列表的内容，我们首先需要创建一个比当前指定的数组稍长的数组。我们希望限制通道数量，因此我们将创建一个最大通道数为五个的数组。我们还将调整对通道数量的检查，以反映这种更改。我们将首先创建一个包含数字`1`到`5`的字符串数组，并修改条件语句：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will store the channel numbers in the `chNumbers` array, and the conditional
    array will now check whether the number of slices is not larger than the length
    of that array. This method allows us to easily enter additional channel numbers
    in the future to the array, without having to modify any other code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将存储通道号码在`chNumbers`数组中，条件数组现在将检查切片数量是否不大于该数组的长度。这种方法允许我们轻松地将额外的通道号码添加到数组中，而无需修改任何其他代码。
- en: 'Next, we added the list of channel numbers to our choice list in the dialog.
    However, we have to take into account that the user can select an image with fewer
    channels than five, so we need to change the array that we add to the choice list
    to reflect the number of channels that are present in the selected image. To do
    this, we can use the `trim` function that works on arrays. The `trim` function
    takes two parameters: the first one is the array, and the second one is an integer
    that specifies the number of elements that need to be returned, starting from
    the first element. We can use the `nSlices` function to give us the number of
    elements we want the `trim` function to return:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在对话框中的选择列表中添加了通道号码列表。然而，我们必须考虑到用户可以选择比五个通道更少的图像，因此我们需要更改添加到选择列表中的数组，以反映所选图像中存在的通道数量。为此，我们可以使用在数组上工作的`trim`函数。`trim`函数接受两个参数：第一个是数组，第二个是一个整数，指定需要从第一个元素开始返回的元素数量。我们可以使用`nSlices`函数来给出我们希望`trim`函数返回的元素数量：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we now run the modified macro on our **HeLa Cells** file, we would see that
    the choice list for the channel number only contains the values `1`, `2`, and
    `3`, which is exactly what we would expect for this image. If we opened another
    image with five channels, we could choose from five options in the list. You can
    try this by saving the **Neuron (1.6M 5 channels)** sample image to test this.
    The final macro will now look like the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在我们的**HeLa Cells**文件上运行修改后的宏，我们会看到通道号码的选择列表只包含`1`、`2`和`3`这三个值，这正是我们预期在这个图像中会看到的。如果我们打开一个具有五个通道的另一个图像，我们可以在列表中选择五个选项。你可以通过保存**Neuron
    (1.6M 5 channels)**样本图像来测试这一点。最终的宏现在看起来就像以下截图：
- en: '![Performing input checking](img/Insert_image_4909_06_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![执行输入检查](img/Insert_image_4909_06_09.jpg)'
- en: For the next step in processing using macros, we will create a macro that will
    perform processing steps on a list of files contained within a folder. This process
    will require some form of progress to let the user know that something is happening
    and to give a hint of how long the processing will take.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用宏处理下一步之前，我们将创建一个宏，该宏将对文件夹内包含的文件列表执行处理步骤。这个过程需要某种形式的进度，以便让用户知道正在发生什么，并给出处理将花费多长时间的提示。
- en: Showing progress in macros
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在宏中显示进度
- en: In the previous sections, we saw that we can process a single image file using
    a (relatively) simple macro. Although the macro is quite flexible, it still requires
    the user to select each file individually and to set the values each time. Many
    times, you wish to perform the same processing steps on a collection of many similar
    images. The images have the same specifications (number of channels, colors, and
    so on) but are of different samples or individuals. When processing large numbers
    of images, it is useful to show progress to indicate how far we are in the processing
    and provide some visual feedback of how many items have been processed. The easiest
    type of feedback is to present the percentage of files that have been processed.
    Any value lower than 100 percent indicates that we are not done yet. If we keep
    track of how long it takes to process 10 percent of the images, we can (roughly)
    estimate the time required to finish the processing. Another useful type of feedback
    is to provide a message at the end of processing that we are finished.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了我们可以使用一个（相对）简单的宏来处理单个图像文件。尽管这个宏非常灵活，但它仍然需要用户每次都单独选择每个文件并设置值。很多时候，你希望对一组许多相似的图像执行相同的处理步骤。这些图像具有相同的规格（通道数、颜色等），但属于不同的样本或个体。在处理大量图像时，显示进度以指示我们处理到了哪一步，并提供一些视觉反馈，表明已经处理了多少项目，是非常有用的。最简单的反馈类型是显示已处理的文件百分比。任何低于100%的值都表示我们还没有完成。如果我们跟踪处理10%的图像所需的时间，我们可以（大致）估计完成处理所需的时间。另一种有用的反馈类型是在处理结束时提供一条消息，表明我们已经完成。
- en: For this section, we will create a different macro that will take a folder with
    time series images, each containing 20 frames and two channels. We will take the
    first channel of each image and create an average projection of the first five
    frames and save the result in the same folder. We will then take the second channel
    of each image, create a maximum projection, and store it in the same folder as
    well. The folder will contain 10 files that need to be processed, as well as a
    single text file that contains a description of the files in the folder. We will
    start by creating a macro for the processing steps in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将创建一个不同的宏，该宏将接受一个包含时间序列图像的文件夹，每个文件夹包含20帧和两个通道。我们将取每个图像的第一个通道，创建前五帧的平均投影，并将结果保存在同一文件夹中。然后我们将取每个图像的第二个通道，创建最大投影，并将其保存在同一文件夹中。该文件夹将包含10个需要处理的文件，以及一个包含文件夹中文件描述的单个文本文件。我们将首先创建下一节中处理步骤的宏。
- en: Processing the time series
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理时间序列
- en: We will begin by creating the steps to perform the processing. We can use the
    recorder as well as the built-in macro function reference page in the ImageJ website
    to help us with the processing. We will first open the image in ImageJ in the
    regular way. The code to open the images one by one from a folder will be written
    later on. Once the image is open, we will create the code that will process each
    channel. I will introduce some useful constructs that will make the code a little
    more clear. I will add comments to the code to indicate what is happening, and
    I will encapsulate the processing in functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建执行处理的步骤。我们可以使用记录器以及ImageJ网站上的内置宏函数参考页面来帮助我们处理。我们首先以常规方式在ImageJ中打开图像。从文件夹中逐个打开图像的代码将在稍后编写。一旦图像打开，我们将创建处理每个通道的代码。我将介绍一些有用的结构，使代码更加清晰。我将在代码中添加注释以指示正在发生的事情，并将处理封装在函数中。
- en: 'Let''s start by creating a function that will generate the average projection
    of the green channel and save it. Creating a function in an ImageJ macro is very
    simple. To declare a function, we will use the `function` keyword, followed by
    the name of the function and the parameter list. For our green channel, the function
    declaration is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个生成绿色通道平均投影并保存它的函数开始。在ImageJ宏中创建一个函数非常简单。为了声明一个函数，我们将使用`function`关键字，后跟函数名称和参数列表。对于我们的绿色通道，函数声明如下：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function is called `processGreenChannel` and has no parameters (this will
    change later on, but for now it is fine). Our first processing step is to generate
    an average of the green channel. There are many ways of doing this, but for now,
    we will use the most basic one. We will create an average for both channels and
    remove the channel we do not want before saving. To create an average projection,
    we need the recorder to discover the format of the command. Start the recorder
    by going to **Plugins** | **Macros** | **Record…** if it is not already open.
    Next, we will go to **Image** | **Stacks** | **Z Project...** from the menu and
    enter `5` for **Stop slice**, and **Average intensity** for the method. We will
    see that the command that gives us the result is shown in the recorder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名为 `processGreenChannel`，它没有参数（稍后将会改变，但现在这样是可以的）。我们的第一个处理步骤是生成绿色通道的平均值。有好多方法可以做到这一点，但现在我们将使用最基本的方法。我们将为两个通道创建平均值，并在保存之前移除我们不需要的通道。为了创建平均投影，我们需要记录器来发现命令的格式。如果记录器还没有打开，请通过访问
    **插件** | **宏** | **记录…** 来启动记录器。接下来，我们将从菜单中选择 **图像** | **堆栈** | **Z投影...**，并将
    `5` 输入为 **停止切片**，将 **平均强度** 作为方法。我们会看到记录器中显示给我们结果的命令：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will be the first command we will add to our function to process the green
    channel. Next, we wish to remove the red channel from this average projection.
    To do this, we will go to **Image** | **Stacks** | **Delete Slice** from the menu.
    A dialog will open, giving us a choice to delete the channel (there is not really
    a choice here). By pressing **OK**, the first channel (the red one) will be removed.
    The recorder shows us that the command used for this is the following one:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们将添加到处理绿色通道函数中的第一个命令。接下来，我们希望从平均投影中移除红色通道。为此，我们将从菜单中选择 **图像** | **堆栈** |
    **删除切片**。将打开一个对话框，让我们选择删除通道（这里实际上没有选择）。通过按 **确定**，第一个通道（红色通道）将被移除。记录器显示我们使用的命令如下：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can add the same code we used to save the image in our previous macro to
    apply here as well. Our function will now look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们在上一个宏中用于保存图像的相同代码添加到这里。现在我们的函数将如下所示：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that we do not require the extension at the end of the name. The projection
    command used a prefix to change the name (`AVG_`), and our original image already
    had an extension at the end, which was preserved by the `projection` command.
    The final step in the processing of the green channel is to close the image we
    have created and saved. This time, however, we cannot use the `close all` command,
    as we are not done yet with the processing of the original image. We will just
    use the `close` command, which only closes the currently active image as indicated
    by the last line of our function. I have included single-line comments in the
    function to indicate what is going to happen in the next line(s) as an aid to
    understanding what will happen next. This is a very basic programming tool that
    can save a lot of time when we examine our code after weeks or months. Single-line
    comments are indicated by text preceded by two forward slashes. If you need more
    text over multiple lines for readability, there are multiline comments, which
    start with `/*` and end with `*/`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在名称末尾添加扩展名。投影命令使用前缀来更改名称（`AVG_`），而我们的原始图像已经有一个末尾的扩展名，该扩展名被 `projection`
    命令保留。处理绿色通道的最后一步是关闭我们创建并保存的图像。然而，这次我们不能使用 `close all` 命令，因为我们还没有完成原始图像的处理。我们只需使用
    `close` 命令，该命令仅关闭由我们函数的最后一行指示的当前活动图像。我在函数中包含了一行注释，以指示下一行（几行）将要发生的事情，作为理解接下来会发生什么的辅助。这是一个非常基础的编程工具，在我们几周或几个月后检查代码时可以节省很多时间。单行注释由前面带有两个正斜杠的文本表示。如果您需要多行文本以提高可读性，可以使用多行注释，它们以
    `/*` 开始，以 `*/` 结束：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The function we will create for our red channel is very similar, except we
    will now use a different projection method. Also, we must delete a different channel
    compared to the previous function. The complete function to process the red channel
    is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要为红色通道创建的函数非常相似，但我们将现在使用不同的投影方法。此外，我们必须删除与上一个函数不同的通道。处理红色通道的完整函数如下：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are only two minor alterations compared to the processing of the green
    channel. The type of projection was changed from `Average Intensity` to `Max Intensity`,
    and the `setSlice` command was added to select the green channel before calling
    the delete channel function. Note that if we also wanted to perform a measurement
    on each of the channels, we could add some measurement code or a function call
    before the `close()` statement to perform the measurement on the selected channel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理绿色通道相比，只有两个小的改动。投影类型从`平均强度`更改为`最大强度`，并且在调用删除通道函数之前添加了`setSlice`命令来选择绿色通道。请注意，如果我们还想对每个通道进行测量，我们可以在`close()`语句之前添加一些测量代码或函数调用，以在所选通道上执行测量。
- en: 'Now that we have completed the processing code for each channel, we can already
    see that there are many similarities between the two functions. It would be possible
    to create a single function that will process each channel accordingly using a
    few input parameters. In this case, you would need three parameters: one for the
    stop point you wish to use for the projection, one for the type of projection,
    and one for the slice number you wish to remove. We could do this for the current
    function, but it may be simpler to keep separate functions. If we want to change
    something in the green channel, processing it might mean we have to introduce
    even more parameters to the function to make it work. This would make the function
    call very complex. Therefore, it is easier to keep two separate functions. The
    only parameter that would be useful in this context is the directory where the
    image will be saved. As we will write code to process an entire directory, we
    will have the path to that folder already present, so we can easily add it as
    a parameter. We will modify the function definition as follows for the green channel
    processing function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了每个通道的处理代码，我们可以看到这两个函数之间有很多相似之处。我们可以创建一个单一函数，使用几个输入参数来相应地处理每个通道。在这种情况下，你需要三个参数：一个用于投影的停止点，一个用于投影类型，以及一个用于要移除的切片号。我们可以对当前函数这样做，但可能更简单的是保持函数分开。如果我们想在绿色通道中更改某些内容，处理它可能意味着我们必须向函数中引入更多的参数来使其工作。这将使函数调用非常复杂。因此，保持两个单独的函数更容易。在这个上下文中，唯一有用的参数是保存图像的目录。因为我们将要编写处理整个目录的代码，所以我们将已经拥有那个文件夹的路径，因此我们可以轻松地将它作为参数添加。我们将按如下方式修改绿色通道处理函数的函数定义：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This means that we can remove (or comment out) the line that provides a value
    to `fdir` within the body of the function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以移除（或注释掉）在函数体内为`fdir`提供值的行：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, I've commented out the line instead of removing it. This is generally
    a good practice if it involves only a few lines, as it shows how the function
    should work and what the function of the variable is. However, this is not advised
    for large sections, as the code will become very long with dead code that you
    need to skip.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我选择注释掉该行而不是直接删除它。如果只涉及几行代码，这通常是一个好的做法，因为它展示了函数应该如何工作以及变量的功能是什么。然而，对于大段代码，不建议这样做，因为代码会变得非常长，而且需要跳过的死代码也会很多。
- en: 'Our next step will deal with selecting the folder to create a list of files
    that need to be processed. For the sake of overview, we will also create a function
    for this part. The first step in this function will be to ask the user for a folder
    that contains the files that need to be processed. When we search the reference
    web page, we will find a function called `getDirectory(string)` that provides
    the functionality we need. In the description, there is also a reference to the
    `getFileList` function. This function will return a list of files in a specified
    directory path. We need both of them for our folder processing function, which
    will look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是选择文件夹，以创建需要处理的文件列表。为了概述，我们也将为此创建一个函数。这个函数的第一步是要求用户输入包含需要处理的文件的文件夹。当我们搜索参考网页时，我们会找到一个名为`getDirectory(string)`的函数，它提供了我们需要的功能。在描述中，还有一个对`getFileList`函数的引用。这个函数将返回指定目录路径中的文件列表。我们需要这两个函数来处理文件夹，该函数看起来如下：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The point where we add this function description is not important for the processing
    in our macro. The declaration can be anywhere within the macro, but I will place
    it at the beginning of the code. It makes sense to place the function declarations
    in the order that you expect them to be called.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加这个函数描述的位置对我们宏中的处理并不重要。声明可以在宏内的任何位置，但我会将其放置在代码的开头。按照你期望它们被调用的顺序放置函数声明是有意义的。
- en: 'At this point, it might be useful to introduce a simple tool that is available
    to debug macros in ImageJ: the **log window**. The log window is a text window
    that can print the value of a variable, allowing you to see whether the value
    is what you expect it to be. It can also be used as a reference for the user to
    see which folders have been processed, thus avoiding a folder being processed
    more than once. We will add a log call to our function, showing the folder that
    is being processed as well as the number of files that are present in that folder.
    Placing the following lines directly below the `flist` statement will result in
    the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，介绍一个可用于调试ImageJ宏的简单工具可能是有用的：**日志窗口**。日志窗口是一个文本窗口，可以打印变量的值，让你看到该值是否是你期望的。它还可以用作用户参考，以查看哪些文件夹已被处理，从而避免一个文件夹被处理多次。我们将在我们的函数中添加一个日志调用，显示正在处理的文件夹以及该文件夹中存在的文件数量。将以下行直接放在`flist`语句下面将产生以下输出：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last step is to go over each of the files and run our processing functions
    on the image that we open. To do this, we will use a basic loop structure, the
    `for` loop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是遍历每个文件并在我们打开的图像上运行我们的处理函数。为此，我们将使用一个基本的循环结构，即`for`循环：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We ended the loop with a `Close All` statement to make sure that all images
    are closed before we go on to the next file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Close All`语句结束循环，以确保在继续处理下一个文件之前所有图像都已关闭。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fiji also provides a small list of templates that allow a general framework
    for image processing in macros. For Fiji, two templates are very useful. The first
    is the **Process Folder** template (**Templates** | **IJ1 Macro** | **Process
    Folder**), which can be used for the same purpose as I am using for this example.
    The other template is the **Scale All ROIs** template (**Templates** | **IJ1 Macro**
    | **Scale All ROIs**). This template tells us how to go over a list of ROIs in
    the ROI manager and alter the size of the ROIs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Fiji还提供了一小部分模板，这些模板允许在宏中为图像处理提供一个通用框架。对于Fiji来说，有两个模板非常有用。第一个是**Process Folder**模板（**Templates**
    | **IJ1 Macro** | **Process Folder**），它可以用于与我在这例子中使用相同的目的。另一个模板是**Scale All ROIs**模板（**Templates**
    | **IJ1 Macro** | **Scale All ROIs**）。这个模板告诉我们如何在ROI管理器中遍历一系列ROI并改变ROI的大小。
- en: 'For this loop, we might also want to show the processing progress to indicate
    how many files we have processed. To do this, we will add a call to the `showProgress()`
    function, which takes a single parameter between `0` and `1`, indicating the fraction
    of files that have been processed. We can place the call directly after the `close
    all` command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个循环，我们可能还想显示处理进度，以指示我们已经处理了多少文件。为此，我们将添加对`showProgress()`函数的调用，该函数接受一个介于`0`和`1`之间的单个参数，表示已处理的文件比例。我们可以在`close
    all`命令之后直接放置这个调用：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As arrays in Java are zero-based, we added a value of `1` to the index to indicate
    the file number that was processed. The progress bar will be shown in the bottom-right
    corner of the ImageJ window. This completes the macro to process an entire folder,
    except that in the current state, we will still have two problems when we wish
    to run it. We only have function definitions, but we don't have any direct calls
    to those functions. We are missing the entry point for our macro. This point is
    easily resolved by adding a call to our `processFolder` function at the beginning
    of the macro.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java中的数组是从零开始的，我们在索引中添加了一个`1`的值来指示已处理的文件编号。进度条将在ImageJ窗口的右下角显示。这完成了处理整个文件夹的宏，但在当前状态下，当我们运行它时，我们仍然会遇到两个问题。我们只有函数定义，但没有直接调用这些函数。我们缺少宏的入口点。这个问题很容易通过在宏的开头添加对`processFolder`函数的调用来解决。
- en: The second problem is a little harder to solve. As specified at the beginning
    of this section, we also have a text file in the folder we wish to process. If
    we run the code as it is now, this text file would also be opened by our macro.
    This will result in an error when we try to process our channels using our functions.
    If our text file was the last file being processed, this would not be a huge problem
    (just a little sloppy). However, when our text file is in the beginning or somewhere
    halfway, the macro will terminate at an undetermined point, and we would have
    to manually correct it. This would negate the entire benefit of having a macro
    to process a folder. It will result in us still having to manually go over each
    file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题解决起来稍微困难一些。如本节开头所述，我们希望在处理的文件夹中也有一个文本文件。如果我们现在运行代码，这个文本文件也会被我们的宏打开。这将导致我们在尝试使用我们的函数处理通道时出现错误。如果我们的文本文件是最后处理的文件，这不会是一个大问题（只是有点马虎）。然而，当我们的文本文件在开头或中间某个位置时，宏将在一个不确定的点终止，我们不得不手动纠正它。这将抵消使用宏处理文件夹的全部好处。这将导致我们仍然需要手动检查每个文件。
- en: We could solve the problem by removing the text file from our folder, which
    may be a good solution if it is only one folder. However, if you have many folders
    that you wish to process, this method would not be very useful. Also, deleting
    the text file means you will lose the information that was contained within it,
    which might be important. Another option would be to create a subfolder in your
    processing folder and place the text file there. There is a problem with this
    solution as well. Folders are also seen by Java as types of files. When creating
    the file list, the subfolder would still be included. Trying to open the subfolder
    using the open command might have unexpected side effects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从我们的文件夹中删除文本文件来解决这个问题，如果只有一个文件夹，这可能是一个不错的解决方案。然而，如果您有多个文件夹需要处理，这种方法可能不太有用。此外，删除文本文件意味着您将丢失其中包含的信息，这可能是重要的。另一个选择是在您的处理文件夹中创建一个子文件夹并将文本文件放在那里。这个解决方案也存在问题。文件夹也被Java视为文件类型。在创建文件列表时，子文件夹仍然会被包括在内。尝试使用打开命令打开子文件夹可能会产生意外的副作用。
- en: 'We can solve all these problems by adding a conditional statement inside the
    loop that checks the type of file that we are currently processing. This `if`
    statement needs to check two conditions: whether the current file a directory
    and whether it is an image. To do this, we will add the following `if` statement
    around our open and process commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在循环中添加一个条件语句来检查我们正在处理的文件类型来解决所有这些问题。这个`if`语句需要检查两个条件：当前文件是否是目录以及它是否是图像。为此，我们将在打开和处理命令周围添加以下`if`语句：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `if` statement checks whether the full path stored in the `fname` variable
    is not a directory and the current file name ends with `.tif`. This check will
    exclude any directories from being processed as well as any file that does not
    have the `.tif` extension. The `showProgress` call can stay outside of the `if`
    statement. The completed macro can be downloaded from the Packt Publishing's website
    for comparison (`batch_project.ijm`). When we run the macro, we will see that
    processing occurs fairly rapidly and the progress bar in the main ImageJ window
    is displayed while the processing occurs. Depending on the number of images and
    the processing power of your computer, processing might go too fast to see everything.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if`语句检查存储在`fname`变量中的完整路径是否不是目录，以及当前文件名是否以`.tif`结尾。这个检查将排除任何目录以及任何没有`.tif`扩展名的文件。`showProgress`调用可以保持在`if`语句之外。完成的宏可以从Packt
    Publishing的网站下载以供比较（`batch_project.ijm`）。当我们运行宏时，我们会看到处理过程相当迅速，并且在处理过程中主ImageJ窗口中会显示进度条。根据图像数量和您计算机的处理能力，处理可能太快而无法看到所有内容。
- en: 'There is one argument that we can add to the current macro. This argument may
    speed up the process and also prevent all the images being shown when they''re
    being processed. This can be controlled using the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向当前的宏添加一个参数。这个参数可能会加快处理速度，并在处理时防止显示所有图像。这可以通过以下命令来控制：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the batch mode is set to `true`, the images will not be shown, and only
    the newly created images will be visible. If the value is set to `false`, the
    images will be shown. By setting the batch mode to `true`, a 20-fold speed increase
    can be achieved in some cases. In the next section, we will look at another way
    to run a macro over multiple files using the built-in method that comes with ImageJ:
    batch process mode.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当批处理模式设置为`true`时，图片将不会显示，只有新创建的图片将可见。如果值设置为`false`，则图片将显示。通过将批处理模式设置为`true`，在某些情况下可以实现20倍的速度提升。在下一节中，我们将探讨使用ImageJ内置方法运行宏的另一种方式：批处理模式。
- en: Running macros in batch process mode
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理模式下运行宏
- en: 'In the previous sections, we looked at processing a folder using a macro with
    different processing functions. The method described earlier is very flexible
    and powerful, and allows a great deal of control over the processing flow and
    what will be processed. ImageJ, however, also has a method that can perform a
    similar task, which is the batch process command. This command allows you to run
    a specified macro that you created over a folder and allows you to store the results
    in the same or a different folder. To start the batch process command, go to **Process**
    | **Batch** | **Macro…** in the ImageJ menu, which will open the following dialog:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了使用具有不同处理功能的宏处理文件夹。前面描述的方法非常灵活且强大，允许对处理流程和要处理的内容有很高的控制。然而，ImageJ还有一个可以执行类似任务的方法，即批处理命令。此命令允许您在文件夹上运行您创建的指定宏，并允许您将结果存储在同一个文件夹或不同的文件夹中。要启动批处理命令，请转到ImageJ菜单中的**处理**
    | **批处理** | **宏…**，这将打开以下对话框：
- en: '![Running macros in batch process mode](img/Insert_image_4909_06_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![批处理模式下运行宏](img/Insert_image_4909_06_10.jpg)'
- en: You can set the input and output folders using the buttons. You can also set
    the output format. If you don't set the output folder, the image would not be
    saved unless you saved it within your own code. You can use one of the macros
    that come with ImageJ using the **Add Macro Code** selector, or you can use the
    **Open…** button to load your own code file. To specify that you only wish to
    process image files, you could use the **File name contains** field to specify
    a pattern that indicates you only wish to process TIFF files by typing (`.tif`)
    with the brackets included. When you press the **Process** button, the code that
    is shown in the text field will be run for each image that matches the pattern.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用按钮设置输入和输出文件夹。您还可以设置输出格式。如果您没有设置输出文件夹，图片将不会保存，除非您在自己的代码中保存它。您可以使用ImageJ附带的一个宏，通过**添加宏代码**选择器，或者您可以使用**打开…**按钮来加载自己的代码文件。为了指定您只想处理图像文件，您可以使用**文件名包含**字段来指定一个模式，通过输入（`.tif`）并包含括号来表示您只想处理TIFF文件。当您按下**处理**按钮时，文本字段中显示的代码将为每个匹配该模式的图片运行。
- en: 'Note that your macro needs to conform to a few rules to be able to use it in
    the batch mode. If you wish to perform the saving yourself inside the macro, you
    need to place code to save the results in your macro and leave the **Output**
    field in the **Batch Process** dialog empty. To perform the same task that we
    did in our previous macro, we will copy the entire code to the **Batch Process**
    dialog. Then, we will remove the `processFolder()` function and the function call,
    replace it with a line that gives us the current directory of the opened image,
    and then call the processing functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您的宏需要遵循一些规则才能在批处理模式下使用。如果您希望在宏内部自行执行保存操作，您需要在宏中放置保存结果的代码，并在**批处理**对话框的**输出**字段中留空。为了执行我们之前宏中执行的任务，我们将整个代码复制到**批处理**对话框中。然后，我们将删除`processFolder()`函数及其调用，用一行代码替换它，该代码提供打开图像的当前目录，然后调用处理函数：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can leave the output field in the process dialog empty, as images are saved
    inside our processing functions. We can add `(.tif)` to the **File name contains**
    field to ensure that the text file will be skipped. When we click the **Process**
    button, the folder will be processed in a similar way, and the results will be
    stored as we described in our macro's processing functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在处理对话框中留空输出字段，因为图片是在我们的处理函数中保存的。我们可以在**文件名包含**字段中添加`(.tif)`以确保文本文件被跳过。当我们点击**处理**按钮时，文件夹将以类似的方式进行处理，并将结果存储在我们宏的处理函数中描述的方式。
- en: Both methods are very suitable for processing entire folders, and the results
    are similar. The biggest difference is that the **Batch Process** mode allows
    slightly less control over the processing steps, and it does not allow recursive
    processing of folders and subfolders. Also, it is not possible to include multiple
    user inputs or dialogs before the folder is processed. The code within the **Batch
    Process** command needs to be self-sufficient. Any user input will have to be
    entered every iteration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都非常适合处理整个文件夹，并且结果相似。最大的区别在于**批量处理**模式对处理步骤的控制略少，并且不允许递归处理文件夹和子文件夹。此外，在处理文件夹之前，无法包含多个用户输入或对话框。**批量处理**命令中的代码需要自给自足。任何用户输入都将在每次迭代中输入。
- en: Installing macros
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装宏
- en: Once you have created your macro, you can save it in the macros folder within
    the ImageJ folder. When you wish to run your macro, you can go to **Plugins**
    | **Macros** | **Open** or **Plugins** | **Macros** | **Run** to open and run
    your macro. It is also possible to add your macros to the macros menu. You can
    do this by installing a macro in ImageJ by selecting **Plugins** | **Macros**
    | **Install…** from the menu. Once you have selected your macro, it will be added
    at the bottom of the macros menu. It is also possible to add your macro to the
    `StartupMacros.txt` file in the `macros` folder. All macros mentioned in this
    file will be added to the macros menu automatically.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的宏，你可以在ImageJ文件夹中的宏文件夹中保存它。当你想运行你的宏时，你可以转到**插件** | **宏** | **打开**或**插件**
    | **宏** | **运行**来打开和运行你的宏。你还可以将你的宏添加到宏菜单中。你可以通过从菜单中选择**插件** | **宏** | **安装…**来在ImageJ中安装一个宏。一旦你选择了你的宏，它将被添加到宏菜单的底部。你还可以将你的宏添加到`macros`文件夹中的`StartupMacros.txt`文件中。在此文件中提到的所有宏都将自动添加到宏菜单中。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in Fiji, when you use the install option, the macro is only added
    for the duration of the session. As soon as you restart Fiji, the macro menu will
    be reset to the default content. It is, therefore, advised that you always place
    your macros and script in the macros or scripts folder of Fiji. To always load
    it when Fiji runs, use the `StartupMacros.fiji.ijm` file as described in the following
    code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Fiji中，当你使用安装选项时，宏仅在该会话期间添加。一旦重启Fiji，宏菜单将重置为默认内容。因此，建议你始终将你的宏和脚本放在Fiji的宏或脚本文件夹中。要始终在Fiji运行时加载它，请使用以下代码中描述的`StartupMacros.fiji.ijm`文件。
- en: 'If you wish to make a toolbar button with a list of your macros that you often
    use, you can do so by modifying the `StartupMacros.txt` file (or `StartupMacros.fiji.ijm`
    file for Fiji). This could be very handy if you have multiple macros that you
    use frequently. To add your macros as a toolbar menu, add the following structure
    somewhere in the startup file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个包含你经常使用的宏的按钮栏，你可以通过修改`StartupMacros.txt`文件（或Fiji的`StartupMacros.fiji.ijm`文件）来实现。如果你经常使用多个宏，这将非常有用。要将你的宏作为工具栏菜单添加，请在启动文件中的某个位置添加以下结构：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first argument for the `newMenu` method is a name for your menu item; in
    this case, I used `My awesome tools`. The second argument adds an array of macro
    commands to the menu, which will be displayed within the toolbar menu when added.
    If you add a dash in the array, a horizontal divider will be added to the menu
    at that location. This can be useful to group macros with similar functions. After
    defining the menu, we can implement the menu items using an `if...else` structure,
    where we compare the command that was selected using the `getArgument` method
    to see which tool needs to be launched. If we want to know the command necessary
    to run our macro, we can start the macro recorder and then go to **Plugins** |
    **Macros** | **Run…**, select our macro, and see what the command for our macro
    is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`newMenu`方法的第一个参数是菜单项的名称；在这种情况下，我使用了`My awesome tools`。第二个参数向菜单添加一个宏命令数组，当添加到菜单中时，这些命令将在工具栏菜单中显示。如果在数组中添加破折号，则在该位置在菜单中添加水平分隔线。这可以用来将具有相似功能的宏分组。在定义菜单后，我们可以使用`if...else`结构实现菜单项，通过使用`getArgument`方法比较所选命令，以确定需要启动哪个工具。如果我们想知道运行宏所需的命令，我们可以启动宏记录器，然后转到**插件**
    | **宏** | **运行…**，选择我们的宏，并查看我们的宏命令是什么。'
- en: 'It is also possible to add an icon to our menu, which needs to be specified
    as a string behind our macro implementation. This string consists of instructions
    to draw elements that we specify using a letter followed by coordinates. For instance,
    if we wish to write the string **Mat** (**My awesome tools**), we could use the
    following string for the icon:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能给我们的菜单添加一个图标，这个图标需要在我们的宏实现后面指定为一个字符串。这个字符串由一系列指令组成，用于绘制我们用字母和坐标指定的元素。例如，如果我们想写出字符串**Mat**（**我的神奇工具**），我们可以使用以下字符串作为图标：
- en: '![Installing macros](img/chap6.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![安装宏](img/chap6.jpg)'
- en: 'The underlined characters are the letters we wish to add, while the value preceding
    it is the font size in points (`11`, `09`, and `09`, respectively). The alphabet
    `T` indicates that a character must be drawn, and the value next to it indicates
    the position of the character. It is also possible to draw a polygon using the
    following format (this requires ImageJ 1.48k):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的字符是我们希望添加的字母，而它前面的值是字体大小（分别为`11`、`09`和`09`）。字母`T`表示必须绘制字符，而它旁边的值表示字符的位置。还可以使用以下格式绘制多边形（这需要ImageJ
    1.48k）：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Drawing this icon can be somewhat complicated, and in Fiji, there is a **Beanshell**
    script that can convert an image to a toolbar icon string. This can be used by
    opening an image and going to **Plugins** | **Examples** | **Image To Tool Icon**.
    There is also an alternative that provides more flexibility and higher quality
    buttons in a separate toolbar. This alternative is **ActionBar** by *Jerome Mutterer*,
    which is a plugin that creates separate toolbars that can be set up to your own
    liking. It also supports icons in the PNG format.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这个图标可能有些复杂，在Fiji中有一个**Beanshell**脚本可以将图像转换为工具栏图标字符串。这可以通过打开一个图像并转到**插件** |
    **示例** | **图像到工具图标**来实现。还有一个提供更多灵活性和更高质量按钮的替代方案，这个替代方案是**ActionBar**，由*Jerome
    Mutterer*开发，这是一个创建可以按个人喜好设置的独立工具栏的插件。它还支持PNG格式的图标。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Documentation for ActionBar can be found at [http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start](http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start).
    It also contains an example of how to create your own toolbar and how to auto-load
    your tool bar when you start ImageJ.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ActionBar的文档可以在[http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start](http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start)找到。它还包含了一个如何创建自己的工具栏以及如何在启动ImageJ时自动加载工具栏的示例。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at how to create a macro using the recorder to discover
    commands and functions that we could apply. We made a basic macro that processed
    an image and generated a new image. Next, we looked at processing a folder full
    of images and created resulting images that were saved to a disk. Finally, we
    looked at batch process mode that allows ImageJ to process a folder in a similar
    way. In the next chapter, we will take a closer look at the constructs available
    for developing plugins and how to set up an environment for developing plugins.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用记录器创建宏，以发现我们可以应用的操作和函数。我们创建了一个基本的宏，该宏处理图像并生成新的图像。接下来，我们查看处理一个图像文件夹，并将生成的图像保存到磁盘上。最后，我们查看批处理模式，该模式允许ImageJ以类似的方式处理文件夹。在下一章中，我们将更详细地探讨可用于开发插件的构造以及如何设置插件开发环境。
