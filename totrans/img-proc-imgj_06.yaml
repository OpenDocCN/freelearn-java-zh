- en: Chapter 6. Developing Macros in ImageJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at ways to automate our image processing
    to allow for faster and more efficient processing. The processing we did earlier
    was adequate, but time consuming. When dealing with very large stacks or time
    series, or with many individual files, the processing we performed was good but
    inefficient. We will look at macros in ImageJ and understand how they will help
    us with the processing. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Recording and running macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input in macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progress in macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running macros in batch mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are sets of commands that allow you to perform a series of tasks on a
    single image or multiple images. In a macro, you can place all the commands you
    can find in the ImageJ menu structure. A very basic application of a macro is
    to convert images from one specific type into another type. In order to create
    a macro, we could create one from scratch by typing all the commands in a text
    file, which we can then execute. However, if we are using commands from the menu
    structure, an easier way would be to use the macro recorder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro recorder will register every command and selection you make, and
    place them in a simple editor. This is a very simple and fast way to create a
    macro that will perform a basic set of tasks on an image. To begin recording,
    go to **Plugins** | **Macros** | **Record…** from the menu, which will open a
    new recorder window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording macros](img/Insert_image_4909_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The recorder window has a list to allow different types of recordings. The default
    is macro, but it is also possible to record commands for a plugin using Java as
    the recording type. ImageJ also supports JavaScript code and Beanshell scripts
    to run, and these types can also be created here. When JavaScript or BeanShell
    is selected, the commands recorded will look slightly different from the default
    macro commands. There is also an option to set the name of the new macro you are
    creating. Macros in ImageJ do not require an underscore in their names and have
    the `.ijm` extension to indicate that they are ImageJ macros. When you have performed
    all the processing steps you wish to unleash on your image, you can press the
    **Create** button to finalize the macro for saving.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a macro for conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple recording of a macro that will take a multichannel
    image, change the lookup table of the blue channel, and convert it to an RGB image.
    We will use the sample image of the HeLa cells. For better processing, we will
    not include the open image command. So, we will first open the image by going
    to **File** | **Open Samples** | **HeLa Cells**. We will then start the macro
    recorder by going to **Plugins** | **Macros** | **Record…** from the ImageJ menu.
    Make sure that the type is set to **Macro**, and enter a name for your macro.
    Next, we will perform the steps we wish to record in the order we wish to use
    them. To start with, activate the image window and select the blue channel by
    pressing the right arrow key twice. You will see that there are now two commands
    in the recorder window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you click on the channel bar with the mouse, nothing will be
    recorded and no commands are added to the recorder window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The recorder does not record mouse clicks that change the state of the display.
    It does not record mouse clicks to change the channel, frames, or slices in stacks
    nor when you adjust the brightness/contrast. Only the **Set** and **Apply** commands
    will show up in the recorder.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the blue channel selected, we will now change the LUT of this channel
    to **Cyan** by going to **Image** | **Lookup Tables** | **Cyan** from the menu.
    This will add a new command to the recorder, corresponding to the action we just
    performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now perform the last step in this process, which is converting the
    image to an RGB image. To do so, go to **Image** | **Type** | **RGB Color** from
    the menu. A new image will be created of the RGB type, and a new command is added
    to the recorder window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a complete macro to convert a three-channel image into an RGB
    image, with a change of the LUT in one channel. The final recorder window will
    look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The name of the macro I have selected is `convert_3ch_rgb.ijm`. When you create
    the macro, this will be the default name used when you save the macro. When you
    push the **Create** button, a new window will open that will look a little different,
    depending on the distribution of ImageJ that you are using. When using Fiji, the
    **Script Editor** window will open, with the commands that we recorded in the
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of the Fiji script editor is that it has **syntax highlighting**
    (indicated by the colors for different elements) and line numbering. It also supports
    a tabbed interface, allowing multiple macros to be opened at the same time within
    the same window. This editor also has a run button at the bottom of the window
    to let you run the macro directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the standard ImageJ distribution, the editor will look a little more basic,
    and it does not have the added features that the Fiji script editor provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording a macro for conversion](img/Insert_image_4909_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the lack of highlighting and the absence of line numbers in the editor.
    Once we have created the macro, we can run it using the keyboard shortcut *Ctrl*
    + *R* or by going to **Macros** | **Run** (standard ImageJ) or **Run** | **Run
    (Fiji)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recording of the macro allows for many steps to be recorded in sequence.
    However, there is a drawback to the macro as we have it now: we need to open the
    image we want to process ourselves, and we need to save the resulting image as
    well. Furthermore, the macro in its current form only processes the currently
    active image. As long as only one image is open, this will not pose a problem.
    However, when we have more than one image open when we run the macro, we have
    to make sure that the window that we want to process is selected before we run
    the macro. In the next section, we will try to add some commands to deal with
    opening and closing images to allow for more robust processing.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The macro we created in the previous section was effective. However, it does
    not deal with opening and closing images. So now, we will look at the process
    of modifying the current macro we now have. Most of the work will be done in the
    editor window, but we will still use the recorder window to discover the functions
    required to open and close images.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding an option to open the image you wish to process to the
    macro that we have. I will use the image we used earlier. However, since you are
    more likely to have images saved locally on a disk, we will save the **HeLa Cells**
    image to the local disk. Let's make a folder named `processing` on the desktop
    and store the **HeLa Cells** image in it. To save the image, go to **File** |
    **Save** or press *Ctrl* + *S* and select the folder on the desktop as the destination.
    After saving the image, we can start with the process of opening an image within
    our macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to make sure our previous macro is opened in the editor
    window and start the macro recorder. We also need to make sure that there are
    no images open. Now, we will start by opening the image we saved by selecting
    **File** | **Open…**. Then, we will select the image from the folder we created
    in the previous step. In the recorder window, we will now see a line that tells
    ImageJ to open the image. When done on our computer, `<username>` will be set
    to the user name that was used when you logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that ImageJ requires the `open()`function with a single parameter,
    which is a line of text (called a `string`, delimited by double quotes in Java/ImageJ).
    This line of text contains the full path of the file you wish to open. To implement
    this command into our macro, we need to copy or type this command into the editor
    window on the first line. We can now test whether everything works as we expect
    by running the macro. To do so, we need to close the image and run the macro by
    selecting the editor window and pressing *Ctrl* + *R* to run the macro. If all
    goes well, the image will open, the blue channel will be selected and changed
    to cyan, and finally, the image will be converted to an RGB image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at how to save the new image to the same folder but with
    a different name. We need to make sure the recorder window is still open, and
    then click on the newly created image to activate it. Next, we will save the image
    as a TIFF file by going to **File** | **Save**. We will keep the name as it was
    set by ImageJ. In the recorder window, we should now see a new line with the save
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is a little more complex than the open command, as it uses the
    more general `run()` method. The run method takes two parameters: a string with
    the command, (in this case **Save**) and a string with the form `save=[]`, with
    the filename between the square brackets for saving. Note that the user name was
    replaced with `<username>` in this command. It should be changed to the user name
    of your logged-in account. We can now add this command to our script to perform
    the save function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to complete the process, we will close all the images that are currently
    open. To do so, we will select the recently saved image and close it. Alternatively,
    we will select **File** | **Close All** from the menu. If we close an image or
    use close all, the following line will be placed in the recorder window, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line means the currently active window will be closed, while the
    second command will close all open images. Since we want to close all the images
    that are open, when we are finished processing, the second command is more suited
    for our macro. We will add the `Close All` command to the script, which means
    our final macro will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying macros](img/Insert_image_4909_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using the script editor in Fiji, we can also see the runs that were performed
    with the current macro in the list below the editor. Using the **Clear** button
    allows us to reset this history. When you open this macro as it is now, it will
    open the image, change the LUT of the third channel, convert it to RGB, save the
    resulting image, and then close all the images. Even though this macro is very
    simple, it processes this image much faster than we will ever be able to do by
    hand. There is only one problem with this macro: it only works for a single image
    in a specific location. If we want to process many different images, this macro
    will not be very practical. We would have to manually change the macro for each
    file that we wish to process. So, in the next section, we will add the possibility
    for the user to select a file when the macro is run.'
  prefs: []
  type: TYPE_NORMAL
- en: User input in macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our previous macro was very efficient at processing a specific image, but it
    would be more efficient if the macro asked for the file to be processed. To do
    this, we will need to add a method that will ask the user for a file. The only
    problem is that we cannot use the recorder to get this function. We need to find
    a function that asks the user for a file location, which can be done with the
    built-in macro functions available in ImageJ. On the ImageJ website, there is
    an extensive list of all the macro functions that you can access at [http://imagej.nih.gov/ij/developer/macro/functions.html](http://imagej.nih.gov/ij/developer/macro/functions.html).
    The functions are sorted alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a specific file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function we want is a file open dialog that asks the user to locate an
    image file. The easiest way to find a function on this page is to use the find
    function of your browser to search for relevant keywords. To find the function
    we need, we will use the search term "file open dialog" in the search box. When
    we enter the search term, there will be multiple occurrences on the page, so we
    will look at all the descriptions for each occurrence. In this case, the function
    that describes what we need is a function called `File.openDialog(title)`, and
    the description says that it will display a file open dialog that returns the
    path of the file that the user selects. We will now change our current macro to
    use this function to allow us to change any file that we select. We will change
    the first line of our macro into the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line tells ImageJ to display a file open dialog with the title **Select
    3 channel image** and then store the path that the user selected in a variable
    called `fname`. On the next line, we modified the `open()` command to use the
    `fname` variable to open the image that the user selected. One thing to note in
    this example is that the variable type is not specified. Macros in ImageJ are
    weakly typed and do not require that you specify the type beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Saving an image to a folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So now, we made the macro a little bit more flexible. We can now select any
    file we wish at any location on the hard disk or attached storage. The only problem
    is that the image is still saved to a fixed location with a fixed name. So now,
    we have to change the portion of our macro that deals with saving the image. There
    are many possible solutions to this problem. We can save the new image in the
    same folder as the image we opened, or we could save it in a different folder
    where we collect all the processed images. We will start with the first option:
    saving it to the same folder as the image that we opened.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the name of the folder we selected, we can use a function called `File.directory()`,
    which will give us the directory of the last file that was opened using a file
    open dialog. This is exactly what we need for our save function, so let''s start
    by adding this function in our code. To do so, we will add a new line before the
    `run("Save", …)` command and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will store the path of the last opened image in a variable named `fdir`.
    In order to save a file, we need the path but also the filename of the new file.
    The filename in this case is just the title of the created image, so we will use
    a function to get the title of the current image by adding this line underneath
    the `fdir` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will store the value of the new filename in a variable named `newName`.
    We are now ready to modify the `save` function to use the two variables that we
    created. What we need to do is combine the `fdir` and `newName` variables. We
    can do this within the `save` command, so we will change the old `save` command
    to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have replaced the path that was specified between the square brackets with
    the two variables. We had to add a set of quotes between the square brackets to
    interrupt the string, and we used the `+` operator to concatenate the strings.
    We specified the extension of the file we wished to save. As the title of the
    image does not contain an extension at the end of the name, we need to add it.
    Alternatively, we could use the `saveAs` macro command to achieve the same result
    (adding the extension is not required because we will save the image as a TIFF
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, the `RGB Color` command creates a new image. When calling `Save`
    on a new image, we can change the name, and it will work the same way as the `saveAs`
    command. If your function does not create a new image but you would still like
    to store the result as a separate file, use the `saveAs` command. Otherwise, the
    save function will overwrite the image on the disk with the modified data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our macro should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving an image to a folder](img/Insert_image_4909_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our macro is now more flexible. We can select any file for processing, and the
    result will be stored in the same folder as the original but with a modified name.
    The next step is to modify the code to control which channel will be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Adding choices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our macro now allows us to modify any image that we can locate and save the
    result in the same folder. In the next step, we will ask the user which channel
    we wish to change. We need to ask the user for a number between 1 and 3, which
    will be the channel that will be updated. There are two basic ways of retrieving
    a number: we could use a text field where the user can enter a number, or we could
    present a list of numbers where the user can select the correct one. The first
    method is very easy, but also requires additional checking. What if the user enters
    a value larger than the number of channels (or not a number at all)? A slightly
    safer method is to give the user a limited set of choices where only one can be
    selected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a set of functions related to creating a dialog and adding fields
    to it. We will need to place this code somewhere at the beginning of the macro,
    before we call the next slice command. We will place the following code directly
    after the open command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line will create a dialog with the title `Select a channel`. Next,
    we added a choice list to the newly created dialog with an array containing the
    options `1`, `2`, and `3` as strings. Finally, we called the `show()` method to
    display the dialog we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a dialog that asks the user to select a channel number, but we did
    not use the selection yet. If we run the code as it is now, the result would be
    the same regardless of the selection we make in the dialog. So, our next step
    is to retrieve the user selection and extract the number that the user selected.
    The function to do this is `getChoice()`, which is part of the dialog function.
    We will add it directly after the show command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will store the selected choice in a variable called `chChoice`.
    However, if we look at the description of the function, this function returns
    a string. This is a problem, because we need it to be a number in order to select
    the correct slice. There is a function available to convert a string to an integer
    in the macro language. It is called `parseInt()`, and we can implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sliceNumber` variable now contains the user''s channel selection. Next,
    we will use this number to select the correct slice in our image. We could use
    a small loop combined with our next slice commands. However, there is a faster
    and simpler method using a built-in macro function called `setSlice()`. To do
    this, replace the two lines with `run("Next Slice [>]")` with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to also change the color of the lookup table that will be used,
    we could add a second choice list to our dialog using the same methodology. We
    could just add another `addChoice()` command, but this time, with several choices
    of LUTs (for example, cyan, yellow, magenta, and so on). The `getChoice()` function
    retrieves the results of each choice list in the order they are added to the dialog.
    If you add the LUT choice after the channel number, it would be retrieved with
    the second call to `getChoice()`. Our macro will now look as follows (I have added
    the color choice as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding choices](img/Insert_image_4909_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is now a new variable called `clrChoice`, which holds the value of the
    color selection that the user makes. If you run the modified macro, you would
    have to select the image you wish to process and then set the channel and LUT
    color. After this, the image will be processed according to the values you set.
    The macro is now quite flexible and allows for different types of conversions
    of a specific channel with a specific color. We now only need one more modification
    to make it a little more robust. We need to check whether the image that the user
    selected actually has three channels or not.
  prefs: []
  type: TYPE_NORMAL
- en: Performing input checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a check for the number of slices in the selected image, we need a simple
    conditional statement. The `if` statement will perform this check. We will add
    this conditional after we open the image, but before we ask the user for input.
    If there are less than three channels, we need to stop the execution of the macro
    and close the image we opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `nSlices` function is a built-in macro function that returns the number
    of slices of the current image. We will check the value of the number of slices
    against the value that we require. If there are insufficient channels, we would
    close all images and abort the macro using the `exit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `nSlices` function, remember that ImageJ calculates this value
    by multiplying the number of slices, frames, and channels of an image. When working
    with (hyper)stacks, the `nSlices` function does not return the value you might
    expect. For example, a 5D image with two channels, five slices, and 51 frames
    will return a value of 510 (*2*5*51*). For stacks, you can use the `Stack` methods.
    To count the number of channels, you can use the `Stack.getDimensions()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of the exit function: one without a parameter and one with
    a string parameter. The string parameter will display a message indicating why
    the macro was aborted. It is recommended that you use the latter form to make
    a user understand why the macro is not performing a task by providing feedback.
    Our macro should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing input checking](img/Insert_image_4909_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our macro is now robust and will run in a predictable way every time we run
    it. If our image has very few slices, it would abort. If it has more slices, it
    would run correctly. However, we will be unable to modify any slice beyond the
    third slice. So, our final modification will check for the number of slices in
    the image and adjust our choices accordingly by manipulating the array of slice
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the content of the choice list, we first need to create an array
    that is slightly longer than the one that is currently specified. We want to limit
    the number of channels somewhat, so we will create an array with five channels
    as a maximum. We will also adjust the check for the number of channels to reflect
    this alteration. We will start by creating an array containing numbers `1` through
    `5` as strings and modify the conditional statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will store the channel numbers in the `chNumbers` array, and the conditional
    array will now check whether the number of slices is not larger than the length
    of that array. This method allows us to easily enter additional channel numbers
    in the future to the array, without having to modify any other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we added the list of channel numbers to our choice list in the dialog.
    However, we have to take into account that the user can select an image with fewer
    channels than five, so we need to change the array that we add to the choice list
    to reflect the number of channels that are present in the selected image. To do
    this, we can use the `trim` function that works on arrays. The `trim` function
    takes two parameters: the first one is the array, and the second one is an integer
    that specifies the number of elements that need to be returned, starting from
    the first element. We can use the `nSlices` function to give us the number of
    elements we want the `trim` function to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the modified macro on our **HeLa Cells** file, we would see that
    the choice list for the channel number only contains the values `1`, `2`, and
    `3`, which is exactly what we would expect for this image. If we opened another
    image with five channels, we could choose from five options in the list. You can
    try this by saving the **Neuron (1.6M 5 channels)** sample image to test this.
    The final macro will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing input checking](img/Insert_image_4909_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the next step in processing using macros, we will create a macro that will
    perform processing steps on a list of files contained within a folder. This process
    will require some form of progress to let the user know that something is happening
    and to give a hint of how long the processing will take.
  prefs: []
  type: TYPE_NORMAL
- en: Showing progress in macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we saw that we can process a single image file using
    a (relatively) simple macro. Although the macro is quite flexible, it still requires
    the user to select each file individually and to set the values each time. Many
    times, you wish to perform the same processing steps on a collection of many similar
    images. The images have the same specifications (number of channels, colors, and
    so on) but are of different samples or individuals. When processing large numbers
    of images, it is useful to show progress to indicate how far we are in the processing
    and provide some visual feedback of how many items have been processed. The easiest
    type of feedback is to present the percentage of files that have been processed.
    Any value lower than 100 percent indicates that we are not done yet. If we keep
    track of how long it takes to process 10 percent of the images, we can (roughly)
    estimate the time required to finish the processing. Another useful type of feedback
    is to provide a message at the end of processing that we are finished.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we will create a different macro that will take a folder with
    time series images, each containing 20 frames and two channels. We will take the
    first channel of each image and create an average projection of the first five
    frames and save the result in the same folder. We will then take the second channel
    of each image, create a maximum projection, and store it in the same folder as
    well. The folder will contain 10 files that need to be processed, as well as a
    single text file that contains a description of the files in the folder. We will
    start by creating a macro for the processing steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the time series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin by creating the steps to perform the processing. We can use the
    recorder as well as the built-in macro function reference page in the ImageJ website
    to help us with the processing. We will first open the image in ImageJ in the
    regular way. The code to open the images one by one from a folder will be written
    later on. Once the image is open, we will create the code that will process each
    channel. I will introduce some useful constructs that will make the code a little
    more clear. I will add comments to the code to indicate what is happening, and
    I will encapsulate the processing in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a function that will generate the average projection
    of the green channel and save it. Creating a function in an ImageJ macro is very
    simple. To declare a function, we will use the `function` keyword, followed by
    the name of the function and the parameter list. For our green channel, the function
    declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is called `processGreenChannel` and has no parameters (this will
    change later on, but for now it is fine). Our first processing step is to generate
    an average of the green channel. There are many ways of doing this, but for now,
    we will use the most basic one. We will create an average for both channels and
    remove the channel we do not want before saving. To create an average projection,
    we need the recorder to discover the format of the command. Start the recorder
    by going to **Plugins** | **Macros** | **Record…** if it is not already open.
    Next, we will go to **Image** | **Stacks** | **Z Project...** from the menu and
    enter `5` for **Stop slice**, and **Average intensity** for the method. We will
    see that the command that gives us the result is shown in the recorder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the first command we will add to our function to process the green
    channel. Next, we wish to remove the red channel from this average projection.
    To do this, we will go to **Image** | **Stacks** | **Delete Slice** from the menu.
    A dialog will open, giving us a choice to delete the channel (there is not really
    a choice here). By pressing **OK**, the first channel (the red one) will be removed.
    The recorder shows us that the command used for this is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add the same code we used to save the image in our previous macro to
    apply here as well. Our function will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we do not require the extension at the end of the name. The projection
    command used a prefix to change the name (`AVG_`), and our original image already
    had an extension at the end, which was preserved by the `projection` command.
    The final step in the processing of the green channel is to close the image we
    have created and saved. This time, however, we cannot use the `close all` command,
    as we are not done yet with the processing of the original image. We will just
    use the `close` command, which only closes the currently active image as indicated
    by the last line of our function. I have included single-line comments in the
    function to indicate what is going to happen in the next line(s) as an aid to
    understanding what will happen next. This is a very basic programming tool that
    can save a lot of time when we examine our code after weeks or months. Single-line
    comments are indicated by text preceded by two forward slashes. If you need more
    text over multiple lines for readability, there are multiline comments, which
    start with `/*` and end with `*/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The function we will create for our red channel is very similar, except we
    will now use a different projection method. Also, we must delete a different channel
    compared to the previous function. The complete function to process the red channel
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are only two minor alterations compared to the processing of the green
    channel. The type of projection was changed from `Average Intensity` to `Max Intensity`,
    and the `setSlice` command was added to select the green channel before calling
    the delete channel function. Note that if we also wanted to perform a measurement
    on each of the channels, we could add some measurement code or a function call
    before the `close()` statement to perform the measurement on the selected channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed the processing code for each channel, we can already
    see that there are many similarities between the two functions. It would be possible
    to create a single function that will process each channel accordingly using a
    few input parameters. In this case, you would need three parameters: one for the
    stop point you wish to use for the projection, one for the type of projection,
    and one for the slice number you wish to remove. We could do this for the current
    function, but it may be simpler to keep separate functions. If we want to change
    something in the green channel, processing it might mean we have to introduce
    even more parameters to the function to make it work. This would make the function
    call very complex. Therefore, it is easier to keep two separate functions. The
    only parameter that would be useful in this context is the directory where the
    image will be saved. As we will write code to process an entire directory, we
    will have the path to that folder already present, so we can easily add it as
    a parameter. We will modify the function definition as follows for the green channel
    processing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can remove (or comment out) the line that provides a value
    to `fdir` within the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I've commented out the line instead of removing it. This is generally
    a good practice if it involves only a few lines, as it shows how the function
    should work and what the function of the variable is. However, this is not advised
    for large sections, as the code will become very long with dead code that you
    need to skip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step will deal with selecting the folder to create a list of files
    that need to be processed. For the sake of overview, we will also create a function
    for this part. The first step in this function will be to ask the user for a folder
    that contains the files that need to be processed. When we search the reference
    web page, we will find a function called `getDirectory(string)` that provides
    the functionality we need. In the description, there is also a reference to the
    `getFileList` function. This function will return a list of files in a specified
    directory path. We need both of them for our folder processing function, which
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The point where we add this function description is not important for the processing
    in our macro. The declaration can be anywhere within the macro, but I will place
    it at the beginning of the code. It makes sense to place the function declarations
    in the order that you expect them to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it might be useful to introduce a simple tool that is available
    to debug macros in ImageJ: the **log window**. The log window is a text window
    that can print the value of a variable, allowing you to see whether the value
    is what you expect it to be. It can also be used as a reference for the user to
    see which folders have been processed, thus avoiding a folder being processed
    more than once. We will add a log call to our function, showing the folder that
    is being processed as well as the number of files that are present in that folder.
    Placing the following lines directly below the `flist` statement will result in
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to go over each of the files and run our processing functions
    on the image that we open. To do this, we will use a basic loop structure, the
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We ended the loop with a `Close All` statement to make sure that all images
    are closed before we go on to the next file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fiji also provides a small list of templates that allow a general framework
    for image processing in macros. For Fiji, two templates are very useful. The first
    is the **Process Folder** template (**Templates** | **IJ1 Macro** | **Process
    Folder**), which can be used for the same purpose as I am using for this example.
    The other template is the **Scale All ROIs** template (**Templates** | **IJ1 Macro**
    | **Scale All ROIs**). This template tells us how to go over a list of ROIs in
    the ROI manager and alter the size of the ROIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this loop, we might also want to show the processing progress to indicate
    how many files we have processed. To do this, we will add a call to the `showProgress()`
    function, which takes a single parameter between `0` and `1`, indicating the fraction
    of files that have been processed. We can place the call directly after the `close
    all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As arrays in Java are zero-based, we added a value of `1` to the index to indicate
    the file number that was processed. The progress bar will be shown in the bottom-right
    corner of the ImageJ window. This completes the macro to process an entire folder,
    except that in the current state, we will still have two problems when we wish
    to run it. We only have function definitions, but we don't have any direct calls
    to those functions. We are missing the entry point for our macro. This point is
    easily resolved by adding a call to our `processFolder` function at the beginning
    of the macro.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is a little harder to solve. As specified at the beginning
    of this section, we also have a text file in the folder we wish to process. If
    we run the code as it is now, this text file would also be opened by our macro.
    This will result in an error when we try to process our channels using our functions.
    If our text file was the last file being processed, this would not be a huge problem
    (just a little sloppy). However, when our text file is in the beginning or somewhere
    halfway, the macro will terminate at an undetermined point, and we would have
    to manually correct it. This would negate the entire benefit of having a macro
    to process a folder. It will result in us still having to manually go over each
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We could solve the problem by removing the text file from our folder, which
    may be a good solution if it is only one folder. However, if you have many folders
    that you wish to process, this method would not be very useful. Also, deleting
    the text file means you will lose the information that was contained within it,
    which might be important. Another option would be to create a subfolder in your
    processing folder and place the text file there. There is a problem with this
    solution as well. Folders are also seen by Java as types of files. When creating
    the file list, the subfolder would still be included. Trying to open the subfolder
    using the open command might have unexpected side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve all these problems by adding a conditional statement inside the
    loop that checks the type of file that we are currently processing. This `if`
    statement needs to check two conditions: whether the current file a directory
    and whether it is an image. To do this, we will add the following `if` statement
    around our open and process commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This `if` statement checks whether the full path stored in the `fname` variable
    is not a directory and the current file name ends with `.tif`. This check will
    exclude any directories from being processed as well as any file that does not
    have the `.tif` extension. The `showProgress` call can stay outside of the `if`
    statement. The completed macro can be downloaded from the Packt Publishing's website
    for comparison (`batch_project.ijm`). When we run the macro, we will see that
    processing occurs fairly rapidly and the progress bar in the main ImageJ window
    is displayed while the processing occurs. Depending on the number of images and
    the processing power of your computer, processing might go too fast to see everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one argument that we can add to the current macro. This argument may
    speed up the process and also prevent all the images being shown when they''re
    being processed. This can be controlled using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When the batch mode is set to `true`, the images will not be shown, and only
    the newly created images will be visible. If the value is set to `false`, the
    images will be shown. By setting the batch mode to `true`, a 20-fold speed increase
    can be achieved in some cases. In the next section, we will look at another way
    to run a macro over multiple files using the built-in method that comes with ImageJ:
    batch process mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Running macros in batch process mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we looked at processing a folder using a macro with
    different processing functions. The method described earlier is very flexible
    and powerful, and allows a great deal of control over the processing flow and
    what will be processed. ImageJ, however, also has a method that can perform a
    similar task, which is the batch process command. This command allows you to run
    a specified macro that you created over a folder and allows you to store the results
    in the same or a different folder. To start the batch process command, go to **Process**
    | **Batch** | **Macro…** in the ImageJ menu, which will open the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running macros in batch process mode](img/Insert_image_4909_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can set the input and output folders using the buttons. You can also set
    the output format. If you don't set the output folder, the image would not be
    saved unless you saved it within your own code. You can use one of the macros
    that come with ImageJ using the **Add Macro Code** selector, or you can use the
    **Open…** button to load your own code file. To specify that you only wish to
    process image files, you could use the **File name contains** field to specify
    a pattern that indicates you only wish to process TIFF files by typing (`.tif`)
    with the brackets included. When you press the **Process** button, the code that
    is shown in the text field will be run for each image that matches the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that your macro needs to conform to a few rules to be able to use it in
    the batch mode. If you wish to perform the saving yourself inside the macro, you
    need to place code to save the results in your macro and leave the **Output**
    field in the **Batch Process** dialog empty. To perform the same task that we
    did in our previous macro, we will copy the entire code to the **Batch Process**
    dialog. Then, we will remove the `processFolder()` function and the function call,
    replace it with a line that gives us the current directory of the opened image,
    and then call the processing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can leave the output field in the process dialog empty, as images are saved
    inside our processing functions. We can add `(.tif)` to the **File name contains**
    field to ensure that the text file will be skipped. When we click the **Process**
    button, the folder will be processed in a similar way, and the results will be
    stored as we described in our macro's processing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods are very suitable for processing entire folders, and the results
    are similar. The biggest difference is that the **Batch Process** mode allows
    slightly less control over the processing steps, and it does not allow recursive
    processing of folders and subfolders. Also, it is not possible to include multiple
    user inputs or dialogs before the folder is processed. The code within the **Batch
    Process** command needs to be self-sufficient. Any user input will have to be
    entered every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created your macro, you can save it in the macros folder within
    the ImageJ folder. When you wish to run your macro, you can go to **Plugins**
    | **Macros** | **Open** or **Plugins** | **Macros** | **Run** to open and run
    your macro. It is also possible to add your macros to the macros menu. You can
    do this by installing a macro in ImageJ by selecting **Plugins** | **Macros**
    | **Install…** from the menu. Once you have selected your macro, it will be added
    at the bottom of the macros menu. It is also possible to add your macro to the
    `StartupMacros.txt` file in the `macros` folder. All macros mentioned in this
    file will be added to the macros menu automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in Fiji, when you use the install option, the macro is only added
    for the duration of the session. As soon as you restart Fiji, the macro menu will
    be reset to the default content. It is, therefore, advised that you always place
    your macros and script in the macros or scripts folder of Fiji. To always load
    it when Fiji runs, use the `StartupMacros.fiji.ijm` file as described in the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to make a toolbar button with a list of your macros that you often
    use, you can do so by modifying the `StartupMacros.txt` file (or `StartupMacros.fiji.ijm`
    file for Fiji). This could be very handy if you have multiple macros that you
    use frequently. To add your macros as a toolbar menu, add the following structure
    somewhere in the startup file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first argument for the `newMenu` method is a name for your menu item; in
    this case, I used `My awesome tools`. The second argument adds an array of macro
    commands to the menu, which will be displayed within the toolbar menu when added.
    If you add a dash in the array, a horizontal divider will be added to the menu
    at that location. This can be useful to group macros with similar functions. After
    defining the menu, we can implement the menu items using an `if...else` structure,
    where we compare the command that was selected using the `getArgument` method
    to see which tool needs to be launched. If we want to know the command necessary
    to run our macro, we can start the macro recorder and then go to **Plugins** |
    **Macros** | **Run…**, select our macro, and see what the command for our macro
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to add an icon to our menu, which needs to be specified
    as a string behind our macro implementation. This string consists of instructions
    to draw elements that we specify using a letter followed by coordinates. For instance,
    if we wish to write the string **Mat** (**My awesome tools**), we could use the
    following string for the icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing macros](img/chap6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The underlined characters are the letters we wish to add, while the value preceding
    it is the font size in points (`11`, `09`, and `09`, respectively). The alphabet
    `T` indicates that a character must be drawn, and the value next to it indicates
    the position of the character. It is also possible to draw a polygon using the
    following format (this requires ImageJ 1.48k):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Drawing this icon can be somewhat complicated, and in Fiji, there is a **Beanshell**
    script that can convert an image to a toolbar icon string. This can be used by
    opening an image and going to **Plugins** | **Examples** | **Image To Tool Icon**.
    There is also an alternative that provides more flexibility and higher quality
    buttons in a separate toolbar. This alternative is **ActionBar** by *Jerome Mutterer*,
    which is a plugin that creates separate toolbars that can be set up to your own
    liking. It also supports icons in the PNG format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation for ActionBar can be found at [http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start](http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start).
    It also contains an example of how to create your own toolbar and how to auto-load
    your tool bar when you start ImageJ.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked at how to create a macro using the recorder to discover
    commands and functions that we could apply. We made a basic macro that processed
    an image and generated a new image. Next, we looked at processing a folder full
    of images and created resulting images that were saved to a disk. Finally, we
    looked at batch process mode that allows ImageJ to process a folder in a similar
    way. In the next chapter, we will take a closer look at the constructs available
    for developing plugins and how to set up an environment for developing plugins.
  prefs: []
  type: TYPE_NORMAL
