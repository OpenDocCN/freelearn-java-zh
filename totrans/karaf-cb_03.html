<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Deploying a Message Broker with Apache ActiveMQ"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Deploying a Message Broker with Apache ActiveMQ</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Apache ActiveMQ modules into Apache Karaf</li><li class="listitem" style="list-style-type: disc">Using the ActiveMQ query command</li><li class="listitem" style="list-style-type: disc">Using the ActiveMQ list command</li><li class="listitem" style="list-style-type: disc">Using the ActiveMQ dstat command</li><li class="listitem" style="list-style-type: disc">Using the ActiveMQ purge command</li><li class="listitem" style="list-style-type: disc">Using the JMS connection factory command</li><li class="listitem" style="list-style-type: disc">Using the JMS send command</li><li class="listitem" style="list-style-type: disc">Using the JMS browse command</li><li class="listitem" style="list-style-type: disc">Configuring and deploying a master/slave broker with Apache Karaf</li><li class="listitem" style="list-style-type: disc">Configuring and deploying a Network of Brokers with Apache Karaf</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Introduction</h1></div></div></div><p>ActiveMQ<a id="id197" class="indexterm"/> is a common framework used in enterprise software solutions to implement JMS messaging via TCP, SSL, HTTP(s), VM, and STOMP, which is one of the many ways to allow inter-bundle communications. ActiveMQ provides a lot of benefits, from handling data bursts to providing failover and scaling. In this chapter, we will cover the why and how of implementing the embedded ActiveMQ broker in a Karaf environment. We will also look at how to administer the broker under different deployment topologies.</p><p>Before <a id="id198" class="indexterm"/>we begin, we should discuss <a id="id199" class="indexterm"/>when to use the embedded broker deployment strategy versus standalone. This is just as important as learning how, since an embedded broker can bring the system to its knees just as fast as bad architecture. In many cases, the initial thought is embedding ActiveMQ is easier to deploy and will make messaging faster. While there is some truth to this, in most cases, the benefit does not outweigh the cost. Allowing ActiveMQ to share the JVM resources will <a id="id200" class="indexterm"/>cause contention in higher load systems. Also, if there is an issue with <a id="id201" class="indexterm"/>ActiveMQ that causes it to fail, it will more than likely have a direct impact on the Karaf instance, which will in turn cause the application to fail, or vice versa. Embedded ActiveMQ brings a lot of value to enterprise applications; just make sure it is used for the right purposes.</p><p>A common embedded solution is for geographically separated client/server applications. One example is the client application resides in a Karaf instance across a WAN and intermittent outages can occur. Then, it might be a good idea to have a local embedded ActiveMQ to allow the client to continue functioning while the broker re-establishes communications with the server. The following diagram demonstrates this:</p><div class="mediaobject"><img src="graphics/Image_01.jpg" alt="Introduction"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>Give a lot of thought as to whether or not an embedded broker is needed.</p></div></div></div></div>
<div class="section" title="Installing Apache ActiveMQ modules into Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Installing Apache ActiveMQ modules into Apache Karaf</h1></div></div></div><p>Installing <a id="id202" class="indexterm"/>an ActiveMQ broker<a id="id203" class="indexterm"/> into a Karaf instance requires very little effort. This recipe will show you how easy it is to get ActiveMQ embedded and running. In order to install the ActiveMQ broker in Karaf, we first need to add the feature URL.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How to do it…</h2></div></div></div><p>Out of the box, Karaf does not come with ActiveMQ installed. But do not fret, for Karaf makes it very easy to install it. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we need to install the XML features by adding the repo for the version we expect to use. This can be done using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:repo-add activemq &lt;version&gt;</strong></span>
</pre></div><p>The following screenshot shows us how to start:</p><div class="mediaobject"><img src="graphics/5081OS_03_02.jpg" alt="How to do it…"/></div></li><li class="listitem">Now that we have the features available, we can list them using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:list | grep activemq</strong></span>
</pre></div><p>The screenshot should look like the following:</p><div class="mediaobject"><img src="graphics/5081OS_03_04.jpg" alt="How to do it…"/></div></li></ol></div><p>There <a id="id204" class="indexterm"/>are several options <a id="id205" class="indexterm"/>for installing only what we need. If your application is connecting to any ActiveMQ instance, then all you need in the OSGi environment is the client APIs for connecting. Simply install the <code class="literal">activemq-client</code> feature; this provides the necessary classes for instantiating a connection and sending or receiving messages. You can do this using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install activemq-client</strong></span>
</pre></div><p>But, since we are embedding a broker in the Karaf instance, we need to run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install activemq-broker</strong></span>
</pre></div><p>Notice in the following screenshot that the <code class="literal">activemq-client</code>, <code class="literal">activemq</code>, <code class="literal">activemq-broker</code>, and <code class="literal">activemq-web-console</code> features have been installed. This is indicated by 'X' in the third column.</p><div class="mediaobject"><img src="graphics/5081OS_03_03.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec89"/>How it works…</h2></div></div></div><p>If we install the ActiveMQ broker, the instantiation is configured in the file <code class="literal">etc/org.apache.activemq.server-default.cfg</code>. This file is read at the time the embedded broker is started and will use the referenced <code class="literal">activemq.xml</code> file to define how the ActiveMQ broker will be initialized. Various other JVM parameters are also configured in this file. The default configuration file will look like the following code:</p><div class="informalexample"><pre class="programlisting">broker-name=amq-broker
data=${karaf.data}/${broker-name}
config=${karaf.base}/etc/activemq.xml</pre></div><p>A big <a id="id206" class="indexterm"/>benefit to having<a id="id207" class="indexterm"/> the configuration settings in the <code class="literal">.cfg</code> file is that any changes to the values in the configuration file will cause the broker to stop and restart, thereby incorporating the changes. Changes to the <code class="literal">activemq.xml</code> file require a manual stop and start of the broker. A good update to the configuration file is to add memory settings such as the following:</p><div class="informalexample"><pre class="programlisting">jvmMemory=50
storage=100gb
tempStorage=10gb</pre></div><p>Then, add the properties in the <code class="literal">activemq.xml</code> file using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;memoryUsage&gt;
   &lt;memoryUsage percentOfJvmHeap="${jvmMemory}"/&gt;
&lt;/memoryUsage&gt;
&lt;storeUsage&gt;
   &lt;storeUsage limit="${storage}"/&gt;
&lt;/storeUsage&gt;
&lt;tempUsage&gt;
   &lt;tempUsage limit="${tempStorage}"/&gt;
&lt;/tempUsage&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>The more configurations you can set as properties, the easier it is to administer the runtime.</p></div></div></div></div>
<div class="section" title="Using the ActiveMQ query command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Using the ActiveMQ query command</h1></div></div></div><p>A convenient <a id="id208" class="indexterm"/>feature of an embedded ActiveMQ<a id="id209" class="indexterm"/> is the ability to run commands against the broker for monitoring broker activity. The <code class="literal">query</code> command provides basic information about the broker.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec90"/>Getting ready</h2></div></div></div><p>In order to get started, we need to get the <code class="literal">activemq-broker</code> feature installed as outlined in the previous recipe. Once that is installed, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq</strong></span>
</pre></div><p>After typing the command, press the <span class="emphasis"><em>Tab</em></span> key. This will list out all the available ActiveMQ commands as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_05.jpg" alt="Getting ready"/></div><p>Now, just <a id="id210" class="indexterm"/>running the command is pretty boring; there <a id="id211" class="indexterm"/>is not much to see in an empty broker.</p><p>Let's get some data loaded so that we can see what is happening.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec91"/>How to do it…</h2></div></div></div><p>Now, let's start sending some data through the broker in order to make this more entertaining and realistic. This recipe has some helper classes we can use to load the broker with data:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the <code class="literal">mvn clean install</code> command in the example code under the <span class="emphasis"><em>Installing Apache ActiveMQ modules into Apache Karaf</em></span> recipe. Then, you can run the Publisher against the embedded ActiveMQ. If no defaults have been changed from the <code class="literal">activemq.xml</code> file, then the defaults in the publisher code will work. We can run the publisher using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -cp target/openwire-example-0.1-SNAPSHOT.jar example.Publisher</strong></span>
</pre></div><p>This will send 10001 messages to the broker including the shutdown message.</p></li><li class="listitem">Now that we can see we have 10001 messages waiting in the test queue, let's go ahead and consume them using our <code class="literal">Listener</code> as shown in the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -cp target/openwire-example-0.1-SNAPSHOT.jar example.Listener</strong></span>
</pre></div><p>This will create a consumer on the queue and pull the messages off.</p></li><li class="listitem">It is nice to be able to see a queue at a glance, but what if we need to see more information about the queue? In many cases, we need to see how much memory a queue is consuming, or the consumer count, or any number of parameters. A good way is to use the query command as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:query -QQueue=test</strong></span>
</pre></div></li></ol></div><p>This will list out the properties of a queue much like you might find in JConsole, which is a JMX monitoring tool provided by Java. This is a nice way to be able to monitor queue properties using scripts, or for continuous integration tests to monitor results. We can look at a few of the properties that are often looked at in JConsole when debugging. We can see that the depth of the queue is 10001. This is found under the <span class="strong"><strong>QueueSize</strong></span> parameter in JConsole. But if we want to see a parameter that tells us a little more about the health<a id="id212" class="indexterm"/> of the queue, let's look at the <span class="strong"><strong>MemoryPercentageUsage</strong></span> parameter. </p><p>We can see in JConsole that the value is currently <span class="strong"><strong>3</strong></span>, as<a id="id213" class="indexterm"/> shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_06.jpg" alt="How to do it…"/></div><p>An easier way to see these parameters is to use the Karaf console command <code class="literal">activemq:query</code>. This saves us from having to open JConsole and enter the long remote process URL: <code class="literal">service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root</code>.</p><p>Then, we can type in the username and password. Alternatively, we can simply use the <code class="literal">activemq:query –QQueue=&lt;queue_name&gt;</code> command to query the queue statistics using<a id="id214" class="indexterm"/> JMX. The following screenshot shows what<a id="id215" class="indexterm"/> will be displayed in the console:</p><div class="mediaobject"><img src="graphics/5081OS_03_07.jpg" alt="How to do it…"/></div><p>Since we are command-line gurus, we can use the <code class="literal">|</code> command to grep for information we are interested in. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_08.jpg" alt="How to do it…"/></div><p>Notice <a id="id216" class="indexterm"/>the statistics for <span class="strong"><strong>MemoryPercentUsage</strong></span> (shown in the previous screenshot) are in there, along with all the other<a id="id217" class="indexterm"/> memory-based properties. Another useful filter is Count. This will show all the counts for <code class="literal">enqueue</code>, <code class="literal">dequeue</code>, <code class="literal">inflight</code>, <code class="literal">producer</code>, <code class="literal">consumer</code>, and so on.</p><p>The query command has many options. These can be seen by using the <code class="literal">--help</code> parameter as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:query --help</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How it works…</h2></div></div></div><p>The <span class="strong"><strong>QueueSize</strong></span> column shows the number of messages that are currently in the queue waiting to be consumed. The <span class="strong"><strong>Dequeue</strong></span> column is the total number of messages that have been consumed by a listener. If we were to run the publisher code again, we would see that the queue size increased again to 10001 but the <span class="strong"><strong>Dequeue</strong></span> value has not moved, indicating we have 10001 messages in the queue.</p><p>Most of the ActiveMQ commands are provided via MBeans or JMX. Many of the same functions are available through JConsole.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec93"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ list command</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ dstat command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the ActiveMQ list command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Using the ActiveMQ list command</h1></div></div></div><p>The <code class="literal">list</code> command <a id="id218" class="indexterm"/>can be used to list out the brokers <a id="id219" class="indexterm"/>currently running inside the Karaf container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec94"/>Getting ready</h2></div></div></div><p>In order to get started, we need to get the <code class="literal">activemq-broker</code> feature installed. Reference the <code class="literal">activemq:query</code> command, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_09.jpg" alt="Getting ready"/></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec95"/>How to do it…</h2></div></div></div><p>To list <a id="id220" class="indexterm"/>out all brokers currently running embedded<a id="id221" class="indexterm"/> inside this instance of Karaf, we can simply run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; activemq:list</strong></span>
</pre></div><p>This will list out the embedded broker names as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>brokerName = amq-broker</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How it works…</h2></div></div></div><p>This <code class="literal">activemq</code> command<a id="id222" class="indexterm"/> will invoke the <code class="literal">JmxMBeansUtil.getAllBrokers</code> class on the JMX connection and retrieve the name of any broker currently running.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec97"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ query command</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ dstat command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the ActiveMQ dstat command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Using the ActiveMQ dstat command</h1></div></div></div><p>The <code class="literal">dstat</code> command is a convenient way to see queue message statistics at a glance. It will list <a id="id223" class="indexterm"/>out the queues with queue size, the number of producers<a id="id224" class="indexterm"/> and consumers, the number of messages enqueued and dequeued, and the percentage of memory used.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec98"/>Getting ready</h2></div></div></div><p>In order to get started, we need to get the <code class="literal">activemq-broker</code> feature installed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>If you have run any previous recipes, a good way to get a clean environment is to stop Karaf, delete the data directory, and restart. This will clean up any data from the previous runs. Remember to reinstall the <code class="literal">activemq-broker</code> feature after restarting.</p></div></div><p>As an example, let's run the <code class="literal">activemq:dstat</code> command, as shown in the following screenshot.</p><div class="mediaobject"><img src="graphics/5081OS_03_11.jpg" alt="Getting ready"/></div><p>Not very impressive. Without data, these commands can be pretty boring. In the previous screenshot, we can see that we have one queue defined at this moment with no message, no producers, and no consumers. So, let's get some data loaded to see what is happening.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec99"/>How to do it…</h2></div></div></div><a id="id225" class="indexterm"/><p>We need to start sending some data through<a id="id226" class="indexterm"/> the brokers in order to make this more entertaining and realistic. This recipe has some helper classes we can use to load the broker with data. This can be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the <code class="literal">mvn clean install</code> command in the example code under the <span class="emphasis"><em>Installing Apache ActiveMQ modules into Apache Karaf</em></span> recipe. Then, you can run the publisher against the embedded ActiveMQ.</li><li class="listitem">If no defaults have been changed from the <code class="literal">activemq.xml</code> file, then the defaults in the publisher code will work. We can run the publisher using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -cp target/openwire-example-0.1-SNAPSHOT.jar example.Publisher</strong></span>
</pre></div><p>This will send 10001 messages to the broker. Now we can look at the <code class="literal">dstat</code> broker and see if there are any changes. The following screenshot shows the result from the <code class="literal">dstat</code> broker:</p><div class="mediaobject"><img src="graphics/5081OS_03_12.jpg" alt="How to do it…"/></div><p>Using the <code class="literal">dstat</code> command, we can see that the publisher has put 10001 messages on the test queue and that several advisory messages have been enqueued too.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>Advisory messages are specific ActiveMQ messages that are meant to inform you of an event.</p></div></div></li><li class="listitem">Now <a id="id227" class="indexterm"/>that we can see we have 10001<a id="id228" class="indexterm"/> messages waiting in the test queue, let's go ahead and consume them using our listener, using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -cp target/openwire-example-0.1-SNAPSHOT.jar example.Listener</strong></span>
</pre></div><p>This will create a consumer on the queue and pull the messages off. We can see through the <code class="literal">dstat</code> command what is happening on our queue. This is displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_13.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec100"/>How it works…</h2></div></div></div><p>The <code class="literal">dstat</code> command uses the ServerInvocationHandler interface to create an instance of the QueueViewMBean interface or the TopicViewMBean interface using the JMX connection. These provide statistics on the queues or topics. The stats are simply listed out to the console in order to provide a high level snapshot of the queues/topics.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec101"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ purge command</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ query command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the ActiveMQ purge command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Using the ActiveMQ purge command</h1></div></div></div><p>A <a id="id229" class="indexterm"/>useful command for clearing data is the <code class="literal">purge</code> command. This<a id="id230" class="indexterm"/> can be used in conjunction with wildcards to clear out large numbers of queues.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec102"/>Getting ready</h2></div></div></div><p>Have the <code class="literal">activemq-broker</code> feature installed in a similar way as done in the <span class="emphasis"><em>Using the ActiveMQ dstat command</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec103"/>How to do it…</h2></div></div></div><p>Before we can purge the data, we first need to load some data. We can load data using the example code provided in the earlier recipes. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can run the publisher again using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -cp target/openwire-example-0.1-SNAPSHOT.jar example.Publisher</strong></span>
</pre></div></li><li class="listitem">Using the <code class="literal">dstat</code> command from the earlier recipe, we can see in the following screenshot that we loaded 10001 messages into the test queue of our embedded broker:<div class="mediaobject"><img src="graphics/5081OS_03_10.jpg" alt="How to do it…"/></div><p>The <code class="literal">purge</code> command will remove data from any number of queues using wildcards and SQL92 syntax.</p></li><li class="listitem">Now, add messages to the queue using the publisher we saw in the <span class="emphasis"><em>Installing Apache ActiveMQ modules into Apache Karaf</em></span> recipe. Run it a couple of times for fun. Now, query the queue using the following command to see how many messages we have:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:query -QQueue=* --view EnqueueCount</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Using the <code class="literal">*</code> character for the queue name will return the <code class="literal">EnqueueCount</code> value for all queues, but in this example, we only have the test queue anyway.</p></div></div><p>We can see that after two runs we have <span class="strong"><strong>20002</strong></span> as the <span class="strong"><strong>EnqueueCount</strong></span> value, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_14.jpg" alt="How to do it…"/></div></li><li class="listitem">We can see thousands of messages now in the queue after running the publisher a couple of times. Now run the following <code class="literal">purge</code> command against the test queue:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:purge test</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/5081OS_03_15.jpg" alt="How to do it…"/></div><p>The <code class="literal">purge</code> command removes all messages in the given queue. Let's rerun the following <code class="literal">query</code> command to see if the queues were cleared out:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:query -QQueue=* --view EnqueueCount</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec104"/>How it works…</h2></div></div></div><p>The <code class="literal">PurgeCommand</code> class in the ActiveMQ code base is used to purge messages in the selected <a id="id231" class="indexterm"/>queue. If no queue is defined, as shown<a id="id232" class="indexterm"/> in the following command, it will purge all <a id="id233" class="indexterm"/>messages from all queues:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activemq:purge</strong></span>
</pre></div><p>We can use both an AMQ-specific language, which looks like <code class="literal">JMSPriority&gt;2,MyHeader='Foo'</code>, or we can use the SQL-92 syntax <code class="literal">(JMSPriority&gt;2) AND (MyHeader='Foo')</code> to select specific messages for deletion.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec105"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ list command</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the ActiveMQ query command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the JMS connection factory commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Using the JMS connection factory commands</h1></div></div></div><p>Now<a id="id234" class="indexterm"/> that we have an embedded broker and have looked at some of the commands for viewing the broker properties and statistics, let's look at how to interact with the broker using JMS commands. In this recipe, we will look at the command for creating and interacting with the broker by creating a connection factory.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec106"/>Getting ready</h2></div></div></div><p>In <a id="id235" class="indexterm"/>order for us to control the connection factory and send messages to the embedded broker, first we need to install the required commands using the following JMS feature command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install jms</strong></span>
</pre></div><p>Using the <span class="emphasis"><em>Tab</em></span> key, we will see a list of the JMS commands available for creating, sending, and browsing messages as well as creating connection factories. These commands are listed in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_03_16.jpg" alt="Getting ready"/></div><p>First, let's create a connection factory for our embedded broker. We do this using the <code class="literal">jms:create</code> command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Be sure to reference the <code class="literal">--help</code> command for required and optional parameters.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec107"/>How to do it…</h2></div></div></div><p>Let's create a connection factory first so that we can mess around with sending messages. All that is needed to create a connection factory is the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jms:create [options] name</strong></span>
</pre></div><p>So, for this example, a command like the following will work to make a connection of type <code class="literal">-t activemq</code> to the URL <code class="literal">-u tcp://localhost:61616</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jms:create -t activemq --url tcp://localhost:61616 cookbook</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec108"/>How it works…</h2></div></div></div><p>This will create a connection factory using the ActiveMQConnectionFactory as defined by the <code class="literal">–t</code> option (the other option is WebsphereMQ). We can verify that our factory was indeed set up by performing a <code class="literal">la</code> command from the command line. Your last entry should look something like the following command-line output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>51 | Active   |  80 | 0.0.0 | connectionfactory-cookbook.xml</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Notice that the pattern for the XML file naming is <code class="literal">connectionfactory-&lt;name&gt;.xml</code>. In the case of our example, we used the name 'cookbook'. If this is not the last entry, or you do not see it, try using the <code class="literal">la | grep cookbook</code> command.</p></div></div><p>A file called <code class="literal">connectionfactory-cookbook.xml</code> was created in the <code class="literal">deploy</code> directory of the <a id="id236" class="indexterm"/>Karaf instance, which is shown in the following code. This file is a Blueprint XML file that will instantiate the connection factory, pooled connection factory, the resource manager, and the transaction manager.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

    &lt;bean id="activemqConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;
    &lt;/bean&gt;

    &lt;bean id="pooledConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;
        &lt;property name="maxConnections" value="8" /&gt;
        &lt;property name="connectionFactory" ref="activemqConnectionFactory" /&gt;
    &lt;/bean&gt;

    &lt;bean id="resourceManager" class="org.apache.activemq.pool.ActiveMQResourceManager" init-method="recoverResource"&gt;
        &lt;property name="transactionManager" ref="transactionManager" /&gt;
        &lt;property name="connectionFactory" ref="activemqConnectionFactory" /&gt;
        &lt;property name="resourceName" value="activemq.localhost" /&gt;
    &lt;/bean&gt;

    &lt;reference id="transactionManager" interface="javax.transaction.TransactionManager" /&gt;

    &lt;service ref="pooledConnectionFactory" interface="javax.jms.ConnectionFactory"&gt;
        &lt;service-properties&gt;
            &lt;entry key="name" value="cookbook" /&gt;
            &lt;entry key="osgi.jndi.service.name" value="/jms/cookbook" /&gt;
        &lt;/service-properties&gt;
    &lt;/service&gt;

&lt;/blueprint&gt;</pre></div><p>The pooled connection factory is added to the services with a JNDI name of <code class="literal">jms/cookbook</code>. The important piece of information to note here is the <code class="literal">–u</code> option that is used to <a id="id237" class="indexterm"/>define the URL for the connection based on which the connection pool is also created. This is an important input from a system resource management perspective.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec109"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the JMS send command</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Using the JMS send command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Using the JMS send command</h1></div></div></div><p>When <a id="id238" class="indexterm"/>debugging or testing code, it is very handy to be able to send messages to a specific queue. This can be done from the command console in Karaf using the JMS subshell.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec110"/>Getting ready</h2></div></div></div><p>Make sure that the JMS feature is installed and available. In order to use most of the commands via JMS, we need to have a connection factory created (see the <span class="emphasis"><em>Using the JMS connection factory commands</em></span> recipe).</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec111"/>How to do it…</h2></div></div></div><p>First, let's make sure the service is in place using the <code class="literal">info</code> command. The connection factory can be referenced either from the specified name <code class="literal">cookbook</code> or by the JNDI service name <code class="literal">jms/cookbook</code>, as we can see in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; jms:info jms/cookbook</strong></span>

<span class="strong"><strong>Property | Value   </strong></span>
<span class="strong"><strong>-------------------</strong></span>
<span class="strong"><strong>product  | ActiveMQ</strong></span>
<span class="strong"><strong>version  | 5.9.0</strong></span>
</pre></div><p>Now that we have verified the JMS connection factory, we can use it to send messages to the broker. This can be done using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; jms:send jms/cookbook cookbookQueue "the recipes are sweet"</strong></span>
</pre></div><p>This will send a message, <code class="literal">the recipes are sweet</code>, to <code class="literal">cookbookQueue</code> using the JNDI name for our connection factory <code class="literal">jms/cookbook</code>.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec112"/>How it works…</h2></div></div></div><p>The <code class="literal">send</code> command will package up the string variable in the command line and put it in a JMS <a id="id239" class="indexterm"/>message, and then send the message to the specified <a id="id240" class="indexterm"/>queue. If you look at the command line, there are three parameters, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The JNDI reference to the connection factory</li><li class="listitem" style="list-style-type: disc">The name of the queue we are sending the message to</li><li class="listitem" style="list-style-type: disc">The message body</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec113"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check <a id="id241" class="indexterm"/>out the <code class="literal">browse</code> command to see how to view the message you just sent to the broker. You can also see it at <a class="ulink" href="http://karaf.apache.org/manual/latest/users-guide/jms.html">http://karaf.apache.org/manual/latest/users-guide/jms.html</a>.</li></ul></div></div></div>
<div class="section" title="Using the JMS browse command"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Using the JMS browse command</h1></div></div></div><p>Now that we have an embedded broker and have looked at some of the commands for viewing the <a id="id242" class="indexterm"/>broker properties and statistics, let's look at how to interact with the broker using commands. In this recipe, we will look at the command for browsing messages.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec114"/>Getting ready</h2></div></div></div><p>In order for us to control the connection factory and send messages to the embedded broker, first we need to get the commands installed using the following JMS feature command, like we did in the previous recipe:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install jms</strong></span>
</pre></div><p>First, let's create <a id="id243" class="indexterm"/>a connection factory for our embedded broker. We do this using the <code class="literal">jms:create</code> command.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Be sure to reference the <code class="literal">--help</code> command for required or optional parameters.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec115"/>How to do it…</h2></div></div></div><p>The real meat and potatoes of this command is the ability to browse the messages in the queue. An example <code class="literal">browse</code> command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; jms:browse jms/cookbook cookbookQueue</strong></span>
</pre></div><p>This<a id="id244" class="indexterm"/> allows you to see the message content, persistence (delivery mode), expiration, ID, the replyTo value, destination, and so on. It is a quick way to monitor what is in the queue at any given time. The output of the preceding <code class="literal">browse</code> command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ID:mbp.pk5001z-55253-1393261878969-4:2:1:1:1 | the recipes are sweet | UTF-8   |   |   | Persistent    | queue://cookbookQueue | Never      | 4        | false       |         | Mon Feb 24 14:55:21 MST 2014</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec116"/>How it works…</h2></div></div></div><p>Browsing messages in the queue is simple. The parameters on the command line tell the <code class="literal">browse</code> command what connection factory to use and what queue to browse.</p></div></div>
<div class="section" title="Configuring and deploying a master/slave broker with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Configuring and deploying a master/slave broker with Apache Karaf</h1></div></div></div><p>In<a id="id245" class="indexterm"/> this recipe, we will set up and <a id="id246" class="indexterm"/>deploy two Karaf instances <a id="id247" class="indexterm"/>with embedded ActiveMQ in<a id="id248" class="indexterm"/> a master/slave configuration. This is used for high availability in messaging systems. This will allow systems to continue functioning in case of a failure of the active instance.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec117"/>Getting ready</h2></div></div></div><p>First we need to get two instances of Karaf started up with an embedded broker. If we are doing this on two different machines, it is actually easier since we will not have port conflicts when using the defaults on both machines. Keep in mind that if you decide to run this deployment on a single machine, one of the instances of Jetty and ActiveMQ embedded in Karaf needs to have its ports changed.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec118"/>How to do it…</h2></div></div></div><p>Since we can only assume that we have one machine to work with, we will go over how to get two instances of Karaf running on a single machine. We can create a second instance by unzipping the Karaf <code class="literal">.zip</code> or <code class="literal">.tar</code> file to a new directory or just copy and paste the current instance to a new directory. Now, we have to change the port setting on one of the instances. This can be done using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">org.apache.karaf.management.cfg</code> file and locate the following lines of code:<div class="informalexample"><pre class="programlisting">#
# Port number for RMI registry connection
#
rmiRegistryPort = 1099</pre></div></li><li class="listitem">Alter the port to something not in use, say <code class="literal">1096</code>. Then, alter the RMI server connection port as shown in the following code:<div class="informalexample"><pre class="programlisting">#
# Port number for RMI server connection
#
rmiServerPort = 44444</pre></div></li><li class="listitem">We <a id="id249" class="indexterm"/>can change this<a id="id250" class="indexterm"/> to something like <code class="literal">44446</code>. Now, we can start up the second instance without port conflicts. But<a id="id251" class="indexterm"/> we are not done<a id="id252" class="indexterm"/> yet. We still have to configure the ActiveMQ instances for failover.</li></ol></div><p>Make the following changes to instance 1 and instance 2 of Karaf:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">org.apache.activemq.server-default.cfg</code> file of the <code class="literal">&lt;karaf-home&gt;/etc/</code> folder and change the following code to a hardcoded location on the disk:<div class="informalexample"><pre class="programlisting">data=${karaf.data}/${broker-name}</pre></div><p>An example might be something like the following code:</p><div class="informalexample"><pre class="programlisting">data=/Users/default/data</pre></div></li><li class="listitem">Open the <code class="literal">jetty.xml</code> file of the <code class="literal">&lt;karaf-home&gt;/etc/</code> folder and change the value of <code class="literal">jetty.port</code> to something like <code class="literal">8186</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;Property name="jetty.port" default="8186" /&gt;</pre></div></li><li class="listitem">Open the <code class="literal">org.apache.karaf.shell.cfg</code> file of the <code class="literal">&lt;karaf-home&gt;/etc/</code> folder and change the value of <code class="literal">sshPort</code> to something like <code class="literal">8106</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">sshPort = 8106
sshHost = 0.0.0.0</pre></div></li><li class="listitem">Since we are running both ActiveMQ instances on the same machine, it would be more complete to change the port on the second ActiveMQ instance to a different port, although this is not required since the port is not allocated until ActiveMQ gets a lock on the file location (this step is optional in this configuration; however, it is more important in a Network of Brokers configuration on a single machine as both instances are active). This can be done as follows:<div class="informalexample"><pre class="programlisting">&lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;</pre></div></li><li class="listitem">After <a id="id253" class="indexterm"/>changing the <a id="id254" class="indexterm"/>configuration files, save<a id="id255" class="indexterm"/> them and <a id="id256" class="indexterm"/>start both instances of Karaf. Install the <code class="literal">activemq-broker</code> feature on instance 1 as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf&gt; feature:repo-add activemq 5.9.0</strong></span>
<span class="strong"><strong>karaf&gt; feature:install activemq-broker</strong></span>
</pre></div></li><li class="listitem">We will see that the embedded ActiveMQ instance starts up without issue. Now do the same on instance 2 and look at the log of instance 2 in the <code class="literal">karaf.log</code> file in the <code class="literal">data/log</code> folder.</li><li class="listitem">Search the logfile of instance 2 for the phrase <code class="literal">could not be locked</code>. We will see the following output line:<div class="informalexample"><pre class="programlisting">2014-02-23 20:37:12,472 | INFO  | ctivemq.server]) | SharedFileLocker                 | 103 - org.apache.activemq.activemq-osgi - 5.9.0 | Database /Users/default/data/kahadb/lock is locked... waiting 10 seconds for the database to be unlocked. Reason: java.io.IOException: File '/Users/default/data/kahadb/lock' could not be locked.</pre></div></li><li class="listitem">This indicates that the second embedded broker instance is in a wait state and not fully instantiated. To see instance 2 start up and initialize, press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> on instance 1 (to shut down the instance). If you are tailing the logfile or you refresh the logfile in your viewer, you will see the following output:<div class="informalexample"><pre class="programlisting">2014-02-23 20:40:02,909 | INFO  | ctivemq.server]) | TransportServerThreadSupport     | 103 - org.apache.activemq.activemq-osgi - 5.9.0 | Listening for connections at: tcp:// mbp.pk5001z:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600
2014-02-23 20:40:02,909 | INFO  | ctivemq.server]) | TransportConnector               | 103 - org.apache.activemq.activemq-osgi - 5.9.0 | Connector openwire started
2014-02-23 20:40:02,909 | INFO  | ctivemq.server]) | BrokerService                    | 103 - org.apache.activemq.activemq-osgi - 5.9.0 | Apache ActiveMQ 5.9.0 (cookbook-broker, ID: mbp.pk5001z-53046-1393213202778-0:1) started</pre></div></li></ol></div><p>This indicates that the slave broker on instance 2 has started up and initialized the connections.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec119"/>How it works…</h2></div></div></div><p>ActiveMQ gives us high availability via a couple of options. In the case of this recipe, we are using file-based persistence (<code class="literal">kahadb</code>). This allows us to point both instances at the same <a id="id257" class="indexterm"/>data file location to establish<a id="id258" class="indexterm"/> the master or the slave. The <a id="id259" class="indexterm"/>first instance to start<a id="id260" class="indexterm"/> up will get a lock on the file location and then finish initializing. The other instance will look at the same file location and see that a lock has already been established. Then, it will log the IOException and wait for the default 10 seconds before trying again.</p><div class="mediaobject"><img src="graphics/5081OS_03_17.jpg" alt="How it works…"/></div><p>The previous diagram shows that the master ActiveMQ instance has established a lock from the file location. It has instantiated all the connections configured in the <code class="literal">activemq.xml</code> file under the <code class="literal">etc</code> folder as defined by the transport connection elements. This allows clients to now connect to the master instance. Once an instance is shut down, those connections are killed.</p><p>Consider that the <a id="id261" class="indexterm"/>clients are configured with a <a id="id262" class="indexterm"/>failover protocol to the slave instance as follows:</p><div class="informalexample"><pre class="programlisting">failover:(tcp://master:61616,tcp://slave:61617)?options</pre></div><p>The <a id="id263" class="indexterm"/>client machines will automatically <a id="id264" class="indexterm"/>reconnect to the slave machine once the secondary broker finishes initializing. This is demonstrated in the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_03_18.jpg" alt="How it works…"/></div><p>At this <a id="id265" class="indexterm"/>point, we can restart the <a id="id266" class="indexterm"/>original master (instance 1) and that will now wait to get a lock on the file. This gives us the master/slave setup without having to restart instances or restore data.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec120"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Configuring and deploying a Network of Brokers with Apache Karaf</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Configuring and deploying a Network of Brokers with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Configuring and deploying a Network of Brokers with Apache Karaf</h1></div></div></div><p>Many times, a single system may not be enough to handle the load of the applications. In this case, scaling is needed to balance load across multiple systems. We can scale applications using embedded ActiveMQ instances in a <span class="strong"><strong>Network of Brokers</strong></span> (<span class="strong"><strong>NoB</strong></span>) configuration.</p><p>This is different from a master/slave configuration <a id="id267" class="indexterm"/>because we will have two active<a id="id268" class="indexterm"/> instances rather than an active and passive pair.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec121"/>Getting ready</h2></div></div></div><p>By following the same initial setup in the previous recipe, we need to have two instances of Karaf running. We can prove this concept on a single machine or multiple machines. For this recipe, we will again be showing you how to set up two instances on the same machine, which requires different ports to be used for the different Karaf instances.</p><p>Ensure that the defaults for the two instances are in place.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec122"/>How to do it…</h2></div></div></div><p>Please follow these steps to configure and deploy a Network of Brokers configuration:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">org.apache.activemq.server-defaults.cfg</code> file of the <code class="literal">&lt;karaf-home&gt;/etc/</code> folder and make sure the following data value is set:<div class="informalexample"><pre class="programlisting">data=${karaf.data}/${broker-name}</pre></div><p>This will tell the embedded ActiveMQ instance to use a local data folder defined by the parameters mentioned earlier.</p></li><li class="listitem">Change the instance 1 option for broker name to <code class="literal">recipe-3-broker-1</code> and change <a id="id269" class="indexterm"/>the instance 2 option for <a id="id270" class="indexterm"/>broker name to <code class="literal">recipe-3-broker-2</code>. So, the values in the file should look like the following code:<div class="informalexample"><pre class="programlisting">Instance 1:
broker-name=recipe-3-broker-1
Instance 2:
broker-name=recipe-3-broker-2</pre></div><p>That way, it is easy to differentiate between brokers when looking at them using JMX. The <code class="literal">karaf.data</code> property is a system property that is set based on the Karaf location.</p></li><li class="listitem">For this recipe, let's work with instance 2. First, we have to alter the <code class="literal">etc/activemq.xml</code> file to have a network connector that links it with the instance. The following is the XML code that needs to be added:<div class="informalexample"><pre class="programlisting">&lt;networkConnectors&gt;
  &lt;networkConnector  uri="static:(tcp://0.0.0.0:61616)"
                     duplex="true"
                     userName="karaf"
                     password="karaf"/&gt;
&lt;/networkConnectors&gt;</pre></div><p>Note the URI has the static protocol with a TCP connection to the instance 1 port (in this case, the default port was left on instance 1 as <code class="literal">61616</code>). We turn on duplex to allow two-way communication through a single pipe and pass the username and password.</p></li><li class="listitem">In order to avoid port conflicts, we need to change the transport connector port on instance 2 to something other than <code class="literal">61616</code>, as follows:<div class="informalexample"><pre class="programlisting">&lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61617?
maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;</pre></div></li><li class="listitem">One more change and we are ready to test. We need to change the port in the <code class="literal">jetty.xml</code> file under the <code class="literal">etc</code> folder. By default, the port is <code class="literal">8181</code>, but since instance 1 is using that, we need to change instance 2 to something else. For this recipe, I have used <code class="literal">8182</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;Set name="port"&gt;
   &lt;Property name="jetty.port" default="8182" /&gt;
&lt;/Set&gt;</pre></div></li><li class="listitem">We can start up both instances now. If we monitor the logs for instance 2, we will see the following output:<div class="informalexample"><pre class="programlisting">Establishing network connection from vm://recipe-3-broker-1?async=false&amp;network=true to tcp://0.0.0.0:61616

vm:// recipe-3-broker-1 started

Network connection between vm:// recipe-3-broker-1#24 and tcp://mbp.pk5001z/192.168.0.97:61616@55254 (recipe-3-broker-2) has been established.</pre></div><p>The log entries indicate that instance 2 has found instance 1 and established a connection between the two.</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec123"/>How it works…</h2></div></div></div><p>The<a id="id271" class="indexterm"/> Network of Brokers configuration can be used<a id="id272" class="indexterm"/> for two different topologies: vertical or horizontal. First, let's look at horizontal, which is more for scaling purposes. This type of topology will often be used to provide great throughput for a system. The main idea is to NOT increase the number of brokers a message must pass through in order to be consumed by your application. Rather, it is designed to balance load across multiple servers. Notice in the following diagram that there are two client machines attached to each instance allowing each broker/Karaf pair to only have to process the messages for two clients.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>Each broker instance has its own message store and is not considered a highly available topology.</p></div></div><p>Even though clients can failover from one client to the other, persisted data is not shared between the instances. This means that if one instance of the broker dies, then the pending messages in that store are not processed until the broker is restarted, even though the clients move over to the one active broker instance. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_03_19.jpg" alt="How it works…"/></div><p>The <a id="id273" class="indexterm"/>benefit to having a network of brokers is the <a id="id274" class="indexterm"/>ability to forward messages to idle clients. If a message is produced to the local <span class="strong"><strong>broker 1</strong></span> but all the clients are busy, then ActiveMQ will forward the message to any idle clients on <span class="strong"><strong>broker 2</strong></span>. This is considered horizontal scaling.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec124"/>There's more…</h2></div></div></div><p>There is also the notion of vertical scaling. But this has an entirely different use case. When using vertical scaling, the obstacle is usually not performance. In most cases, vertical scaling is used for communication problems over a WAN. A good example of this is outlined in the following diagram:</p><div class="mediaobject"><img src="graphics/5081OS_03_20.jpg" alt="There's more…"/></div><p>In the <a id="id275" class="indexterm"/>previous diagram, an embedded ActiveMQ is<a id="id276" class="indexterm"/> used locally to avoid application downtime if the connection between Los Angeles and Dallas is lost. So, the local application will communicate directly with the local instance without worrying if the WAN is up or down. Then, the local ActiveMQ will be in charge of establishing and maintaining the connection to the backend service.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>There is a performance cost to vertical scaling.</p></div></div><p>Vertical scaling is forcing a two-broker hop. So, you have to figure out which is more important from the requirements: performance or stability.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec125"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Configuring </em></span><a id="id277" class="indexterm"/><span class="emphasis"><em>and deploying a master/slave broker with Apache Karaf</em></span> <a id="id278" class="indexterm"/>recipe</li></ul></div></div></div></body></html>