["```java\n  lazy val scalatraVersion = \"2.3.0\"\n  val backendDeps = Seq(\n   \"org.scalatra\"      %% \"scalatra\"          % scalatraVersion,\n   \"ch.qos.logback\"    %  \"logback-classic\"   % \"1.1.3\",\n   \"org.eclipse.jetty\" %  \"jetty-webapp\"      % \"9.2.10.v20150310\"  \n  )\n```", "```java\n  object JettyLauncher {\n\n    def launch(bootstrapClass: String): Server = {\n\n      // define the servlet context, point to our Scalatra servlet\n      val context = new WebAppContext()\n      context.setContextPath \"/\"\n      context.setResourceBase(\"src/main/webapp\")\n      context.setInitParameter(ScalatraListener\n                              .LifeCycleKey, bootstrapClass)\n      context.addEventListener(new ScalatraListener)\n      context.addServlet(classOf[DefaultServlet], \"/\")\n\n      // create a server and attach the context\n      val server = new Server(8080)\n      server.setHandler(context)\n\n      // add a lifecycle listener so to stop the server from console\n      server.addLifeCycleListener(new AbstractLifeCycleListener() {\n        override def lifeCycleStarted(event: LifeCycle): Unit = {\n          println(\"Press <enter> to exit.\")\n          Console.in.read.toChar\n          server.stop()\n        }\n      })\n\n      // start and return the server\n      server.start\n      server.join\n      server\n    }\n  }\n```", "```java\npackage org.restwithscala.chapter4.gettingstarted\n\nimport org.restwithscala.chapter4.JettyLauncher\nimport org.scalatra.{ScalatraServlet, LifeCycle}\nimport javax.servlet.ServletContext\n\n// run this example by specifying the name of the bootstrap to use\nobject ScalatraRunner extends App {\n  JettyLauncher.launch(\n      \"org.restwithscala.chapter4.gettingstarted.ScalatraBootstrap\")\n}\n\n// used by jetty to mount the specified servlet\nclass ScalatraBootstrap extends LifeCycle {\n  override def init(context: ServletContext) {\n    context mount (new HelloScalatra, \"/*\")\n  }\n}\n\n// the real servlet code\nclass HelloScalatra extends ScalatraServlet  {\n\n  notFound {\n    \"Route not found\"\n  }\n\n  get(\"/\") {\n    \"Hello from scalatra\"\n  }\n}\n```", "```java\n$ sbt runCH04-HelloScalatra\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter4.gettingstarted.ScalatraRunner \n20:42:09.020 [run-main-0] INFO  org.eclipse.jetty.util.log - Logging initialized @31722ms\n20:42:09.536 [run-main-0] INFO  org.eclipse.jetty.server.Server - jetty-9.2.10.v20150310\n20:42:09.940 [run-main-0] INFO  o.e.j.w.StandardDescriptorProcessor - NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet\n20:42:10.015 [run-main-0] INFO  o.scalatra.servlet.ScalatraListener - The cycle class name from the config: org.restwithscala.chapter4.gettingstarted.ScalatraBootstrap\n20:42:10.304 [run-main-0] INFO  o.scalatra.servlet.ScalatraListener - Initializing life cycle class: ScalatraBootstrap\n20:42:10.643 [run-main-0] INFO  o.e.j.server.handler.ContextHandler - Started o.e.j.w.WebAppContext@78dac2c7{/,file:/Users/jos/dev/git/rest-with-scala/src/main/webapp,AVAILABLE}\n20:42:10.924 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@15f336ae{HTTP/1.1}{0.0.0.0:8080}\n20:42:10.925 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @33637ms\nPress <enter> to exit.\n\n```", "```java\n$ sbt runCH04-runCH04Step1\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter4.steps.ScalatraRunnerStep1 \n10:51:40.313 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@538c2499{HTTP/1.1}{0.0.0.0:8080}\n10:51:40.315 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @23816ms\nPress <enter> to exit.\n\n```", "```java\npackage org.restwithscala.chapter4.steps\n\nimport javax.servlet.ServletContext\n\nimport org.restwithscala.chapter4.JettyLauncher\nimport org.scalatra.{NotFound, BadRequest, ScalatraServlet, LifeCycle}\n\nimport scala.util.{Failure, Success, Try}\n\n// run this example by specifying the name of the bootstrap to use\nobject ScalatraRunnerStep1 extends App {\n  JettyLauncher.launch(\n    \"org.restwithscala.chapter4.steps.ScalatraBootstrapStep1\")\n}\n\nclass ScalatraBootstrapStep1 extends LifeCycle {\n  override def init(context: ServletContext) {\n    context mount (new ScalatraStep1, \"/*\")\n  }\n}\n\nclass ScalatraStep1 extends ScalatraServlet  {\n\n  notFound { \"Route not implemented\" }\n\n  post(\"/tasks\") { s\"create a new task with body ${request.body}\"}\n  get(\"/tasks\") { \"Get all the tasks\" }\n  get(\"/tasks/:id\") {\n    Try { params(\"id\").toInt }  match {\n      case Success(id) => s\"Get task with id: ${params(\"id\")} \"\n      case Failure(e) => BadRequest(reason = \"Can't parse id\")\n    }\n  }\n  delete(\"/tasks/:id\") { s\"Delete task with id: ${params(\"id\")} \"}\n  put(\"/tasks/:id\") { s\"Update an existing task \" +\n    s\"with id:  ${params(\"id\")} \" +\n    s\"and body ${request.body}\"}\n}\n```", "```java\n  get(\"/tasks/:id\") {\n    Try { params(\"id\").toInt }  match {\n      case Success(id) => s\"Get task with id: ${params(\"id\")} \"\n      case Failure(e) => BadRequest(reason = \"Can't parse id\")\n    }\n  }\n  ...\n  put(\"tasks/:id\") { s\"Update an existing task \" +\n    s\"with id:  ${params(\"id\")} \" +\n    s\"and body ${request.body}\"}\n```", "```java\n  lazy val scalatraVersion = \"2.3.0\"\n  val backendDeps = Seq(\n      \"org.scalatra\" %% \"scalatra\" % scalatraVersion,\n      \"ch.qos.logback\"% \"logback-classic\" % \"1.1.3\",\n      \"org.eclipse.jetty\" %  \"jetty-webapp\" % \"9.2.10.v20150310\",\n      \"com.typesafe.akka\" %% \"akka-actor\" % \"2.3.4\"\n```", "```java\npackage org.restwithscala.chapter4.steps\n\nimport javax.servlet.ServletContext\n\nimport akka.actor.ActorSystem\nimport org.restwithscala.chapter4.JettyLauncher\nimport org.restwithscala.common.model.{Status, Task}\nimport org.restwithscala.common.service.TaskService\nimport org.scalatra._\nimport org.slf4j.LoggerFactory\n\nimport scala.concurrent.{Future, ExecutionContext}\nimport scala.util.{Failure, Success, Try}\n\nobject ScalatraRunnerStep2 extends App {\n  JettyLauncher.launch(\n       \"org.restwithscala.chapter4.steps.ScalatraBootstrapStep2\")\n}\n\nclass ScalatraBootstrapStep2 extends LifeCycle {\n\n  val system = ActorSystem()\n\n  override def init(context: ServletContext) {\n    context.mount(new ScalatraStep2(system), \"/*\")\n  }\n\n  override def destroy(context: ServletContext) {\n    system.shutdown()\n  }\n}\n\nclass ScalatraStep2(system: ActorSystem) extends ScalatraServlet \n                                            with FutureSupport {\n\n  protected implicit def executor: ExecutionContext \n                                      = system.dispatcher\n  val Log = LoggerFactory.getLogger(this.getClass)\n\n  ...\n}\n```", "```java\nclass ScalatraBootstrapStep2 extends LifeCycle {\n\n  val system = ActorSystem()\n\n  override def init(context: ServletContext) {\n    context.mount(new ScalatraStep2(system), \"/*\")\n  }\n\n  override def destroy(context: ServletContext) {\n    system.shutdown()\n  }\n}\n```", "```java\n$ sbt runCH04-runCH04Step2\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter4.steps.ScalatraRunnerStep2 \n17:46:00.339 [run-main-0] INFO  org.eclipse.jetty.util.log - Logging initialized @19201ms\n17:46:00.516 [run-main-0] INFO  org.eclipse.jetty.server.Server - jetty-9.2.10.v20150310\n17:46:01.572 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@5c3c276c{HTTP/1.1}{0.0.0.0:8080}\n17:46:01.572 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @20436ms\nPress <enter> to exit.\n\n```", "```java\nclass ScalatraStep2(system: ActorSystem) extends ScalatraServlet \n                                            with FutureSupport {\n\n  protected implicit def executor: ExecutionContext \n                                      = system.dispatcher\n  val Log = LoggerFactory.getLogger(this.getClass)\n\n  before(\"/*\") {\n    Log.info(s\"Processing request for: ${params(\"splat\")}\")\n  }\n\n  after(\"\"\"\"^\\/tasks\\/(.*)\"\"\"\".r) {\n    Log.info(s\"Processed request for tasks: ${params(\"captures\")}\")\n  }\n\n  notFound {\n    \"Route not implemented\"\n  }\n\n  post(\"/tasks\") {\n    new AsyncResult() { \n      // we use a AsyncResult since we access the parameters\n      override val is  = {\n        // convert provided request parameters to a task and store it\n        val createdTask = TaskService.insert(Task( -1,\n          params.getOrElse(\"title\", \n                          halt(status = 400, \n                               reason=\"Title is required\")), request.body, None, List.empty, Status(params.getOrElse(\"status\", \"new\"))))\n\n        // the result is a Future[Task]; map this to a string\n        createdTask.map(_.toString)\n      }\n    }\n  }\n\n  get(\"/tasks\") {\n      // directly return Future since we don't access request\n      TaskService.all.map(_.toString) }\n\n  delete(\"/tasks/:id\") {\n    new AsyncResult() {\n      override val is = Try { params(\"id\").toLong } match {\n        case Success(id) => TaskService.delete(id).map(_.toString)\n        case Failure(e) => Future{BadRequest(\n                       reason = s\"Can't parse id: ${e.getMessage}\")}\n      }\n    }\n  }\n}\n```", "```java\nclass ScalatraStep2(system: ActorSystem) extends ScalatraServlet \n                                            with FutureSupport {\n\n  protected implicit def executor: ExecutionContext \n                                      = system.dispatcher\n```", "```java\n  get(\"/tasks\") {\n      // directly return future since we don't access request\n      TaskService.all.map(_.toString) }\n```", "```java\n  delete(\"/tasks/:id\") {\n    new AsyncResult() {\n      override val is = Try { params(\"id\").toLong } match {\n        case Success(id) => TaskService.delete(id).map(_.toString)\n        case Failure(e) => Future{BadRequest(\n                       reason = s\"Can't parse id: ${e.getMessage}\")}\n      }\n    }\n  }\n```", "```java\n       val createdTask = TaskService.insert(Task( -1,\n          params.getOrElse(\"title\", \n                          halt(status = 400, \n                               reason=\"Title is required\")), request.body, None, List.empty, Status(params.getOrElse(\"status\", \"new\"))))\n\n          // the result is a Future[Task]; map this to a string\n          createdTask.map(_.toString)\n      }\n```", "```java\n\"org.json4s\"   %% \"json4s-jackson\" % \"3.2.9\",\n\"org.scalatra\" %% \"scalatra-json\" % scalatraVersion,\n```", "```java\nclass ScalatraStep3(system: ActorSystem) extends ScalatraServlet\n                  with FutureSupport\n                  with JacksonJsonSupport {\n```", "```java\nprotected implicit val jsonFormats: Formats = DefaultFormats\n```", "```java\n  before(\"/*\") {\n    contentType = formats(\"json\")\n}\n```", "```java\n  get(\"/tasks\") {\n      TaskService.all // we use json4s serialization to json.\n  }\n```", "```java\n  post(\"/tasks\") {\n    new AsyncResult() { \n      override val is  = {\n        // convert provided request parameters to a task and store it\n        TaskService.insert(parsedBody.extract[Task])\n      }\n    }\n  }\n```", "```java\nlazy val scalatraVersion = \"2.3.0\"\nval backendDeps = Seq(\n    \"org.scalatra\" %% \"scalatra\" % scalatraVersion,\n    \"org.scalatra\" %% \"scalatra-json\" % scalatraVersion,\n    \"org.scalatra\" %% \"scalatra-commands\" % scalatraVersion,\n    \"org.json4s\"   %% \"json4s-jackson\" % \"3.2.9\",\n    \"ch.qos.logback\"    %  \"logback-classic\"   % \"1.1.3\",\n    \"org.eclipse.jetty\" %  \"jetty-webapp\"      % \"9.2.10.v20150310\",\n    \"com.typesafe.akka\" %% \"akka-actor\" % \"2.3.4\"\n)\n```", "```java\nclass ScalatraStep3(system: ActorSystem) extends ScalatraServlet\n                  with FutureSupport\n                  with JacksonJsonSupport with CommandSupport {\n```", "```java\noverride type CommandType = SearchTasksCommand\n```", "```java\nobject SearchCommands {\n\n  object SearchTasksCommand {\n   implicit def createSearchParams(cmd: SearchTasksCommand):  \n                SearchParams = \n                SearchParams(cmd.status.value.get, cmd.text.value)\n  }\n\n  class ValidStatusValidations(b: FieldDescriptor[String]) {\n\n    def validStatus(message: String = \n        \"%s be either 'new' or 'in progress'.\") = \n        b.validateWith(_ =>\n               _ flatMap { new PredicateValidator[String](\n                    b.name, \n                    List[String](\"new\", \n                                 \"in progress\").contains(_),\n                                  message).validate(_) }\n    )\n  }\n\n  /**\n   * Params only command parses incoming parameters\n   */\n  class SearchTasksCommand extends ParamsOnlyCommand {\n    implicit def statusValidator(b: FieldDescriptor[String]) \n                      = new ValidStatusValidations(b)\n\n    val text: Field[String] = asType[String](\"text\")\n    val status: Field[String] =  \n                asType[String](\"status\").\n                    notBlank.\n                    minLength(3).\n                    validStatus()\n  }\n\n}\n```", "```java\n  get(\"/tasks/search\") {\n    new AsyncResult() {\n      override val is = (command[SearchTasksCommand] >> \n                  (TaskServiceWrapper.WrapSearch(_))).fold (\n        errors => halt(400, errors),\n        tasks => tasks\n      )\n    }\n  }\n```", "```java\nobject TaskServiceWrapper {\n\n  def WrapSearch(search: SearchParams): ModelValidation[Future[List[Task]]] = {\n    allCatch.withApply(errorFail) {\n      println(search)\n      TaskService.search(search).successNel\n    }\n  }\n\ndef errorFail(ex: Throwable) = ValidationError(ex.getMessage, UnknownError).failNel\n}\n```"]