- en: Chapter 4. Collections and Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：集合和函数式编程
- en: We are now comfortable with using Java code from our Clojure programs, and we
    also know how to expose our Clojure programs with a Java API. However, we need
    to take a deeper look at Clojure and its true nature, which is functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用Java代码从Clojure程序中感到很舒适，我们也知道如何通过Java API公开我们的Clojure程序。然而，我们需要更深入地了解Clojure及其真正的本质，即函数式编程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics of functional programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的基础
- en: Persistent collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化集合
- en: Sequential and associative collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序和关联集合
- en: The sequence abstraction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列抽象
- en: Collection types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合类型
- en: Applying functional programming to collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数式编程应用于集合
- en: Basics of functional programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的基础
- en: 'This is a topic that you can read about in lots of different places, and it
    seems that everyone has their own opinion of what functional programming is. There
    is however, some common ground that you will find in almost every definition,
    which relates to the benefits you gain from functional programming, such as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可以在很多不同地方阅读的主题，似乎每个人都有自己关于函数式编程的看法。然而，在几乎每个定义中，你都会找到一个共同点，这与你从函数式编程中获得的好处相关，例如：
- en: Easier code reuse
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的代码重用
- en: Functions are easier to test
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数更容易测试
- en: Functions are easier to reason about
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数更容易推理
- en: 'In order to get these benefits, you need to take into account the following
    things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些好处，你需要考虑以下事项：
- en: You should think of functions as first class citizens
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该将函数视为一等公民
- en: Functions should minimize side effects (they shouldn't change any state)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该最小化副作用（它们不应该改变任何状态）
- en: Functions should only depend on their parameters (this is called referential
    transparency)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该只依赖于它们的参数（这被称为引用透明性）
- en: Lets take a look at two examples of functions (or methods) in Java to illustrate
    how, even in Java, you can get benefits from writing functions without side effects
    and context dependency.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java中函数（或方法）的两个例子，以说明即使在Java中，你也可以从编写无副作用和上下文依赖的函数中获得好处。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Imagine you had to test the preceding function; you might have a number of
    problems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须测试上述函数；你可能会遇到一些问题：
- en: You need to know how to get the current user; you might need to mock a database,
    or session storage. Or in the worst case scenario, you might need a real session
    storage service.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要知道如何获取当前用户；你可能需要模拟数据库或会话存储。或者在最坏的情况下，你可能需要一个真实的会话存储服务。
- en: How can you know if something was paid for or not?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何知道某物是否已付费？
- en: 'Now, look at this other example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个其他例子：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is easier to test; you can create a user instance any way
    you want and with the `ValidateStrategy` class (or interface) you could do whatever
    you need.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码更容易测试；你可以以任何方式创建用户实例，并且使用`ValidateStrategy`类（或接口），你可以做你需要做的任何事情。
- en: In the end, instead of a side-effect you get a return value stating if the action
    was possible or not. This way you don't need to mock and you can reuse it in different
    contexts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你得到一个返回值，表明操作是否可行，而不是副作用。这样你就不需要模拟，并且可以在不同的上下文中重用它。
- en: 'Now that we have seen some common ground for functional programming, let''s
    take a look at Clojure''s value proposition for functional programming:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了函数式编程的一些共同点，让我们看看Clojure为函数式编程提供的价值主张：
- en: Functions are first class citizens or values. The same as with integers or strings,
    you can create them in runtime, pass them around, and receive them in other functions.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是一等公民或值。就像整数或字符串一样，你可以在运行时创建它们，传递它们，并在其他函数中接收它们。
- en: The same way that functions are values, the data structures are also values;
    they can't be modified in the sense that they can be modified in Java but they
    are a fixed value, just as an integer is a fixed value.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数是值一样，数据结构也是值；它们不能像Java中那样被修改，但它们是一个固定值，就像整数是一个固定值一样。
- en: Immutable data structures are very important, they allow for safe and simple
    multithreaded code.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变的数据结构非常重要，它们允许编写安全且简单的多线程代码。
- en: Laziness (of data structures) allows deferring evaluation until needed, to execute
    just what you must.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性（数据结构）允许延迟评估直到需要时，只执行你必须执行的操作。
- en: Persistent collections
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化集合
- en: One of the most important features in Clojure is that collections are persistent.
    That does not mean that they are persistent to disk, it means that you can have
    several historical versions of a collection with the guarantee that updating or
    looking for something in any of those versions is going to have the same effort
    (complexity). You get all this with very little extra memory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中最重要的一项特性是集合的持久性。这并不意味着它们对磁盘是持久的，这意味着您可以有多个集合的历史版本，并保证更新或在这些版本中查找任何内容都将具有相同的努力（复杂度）。您只需很少的额外内存就能获得所有这些。
- en: How? It is actually pretty simple. Clojure shares a common structure between
    several different data structures. If you add a single element to a data structure,
    Clojure shares the common part between the two structures and keeps track of the
    differences.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现？实际上非常简单。Clojure在几个不同的数据结构之间共享一个公共结构。如果您向一个数据结构添加单个元素，Clojure会在两个结构之间共享公共部分，并跟踪差异。
- en: 'Let''s see what we mean with an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看我们的意思：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, when you `conj` a new item into a collection, or even when you
    replace some elements from it, you aren't changing the original collection, you
    are just generating a new version of it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当您将一个新项目`conj`到一个集合中，或者甚至替换其中的某些元素时，您并没有改变原始集合，您只是生成了一个新的版本。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, you can use `conj(conjoin)` as a verb. It means adding new elements
    into a collection in an efficient manner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，您可以使用`conj(conjoin)`作为一个动词。这意味着以高效的方式将新元素添加到集合中。
- en: This new version doesn't modify the previous collections you had in any way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本不会以任何方式修改您之前拥有的任何集合。
- en: 'This is a big difference from how common imperative languages work and at the
    first glance it might seem like a bad idea, but Clojure uses efficient algorithms
    that give us a couple of advantages, specifically:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与常见的命令式语言的工作方式有很大不同，乍一看可能像是一个坏主意，但Clojure使用高效的算法，给我们带来了一些优势，特别是：
- en: Different versions of the same collection share common parts, allowing us to
    use little memory
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一集合的不同版本共享公共部分，使我们能够使用很少的内存。
- en: When some part of the collection is not visible it gets garbage collected
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合的某部分不可见时，它会被垃圾回收。
- en: What you get out of this is similar memory usage to what you would have with
    a mutable collection. Remember that there is a cost in space and time but it is
    negligible for most use cases.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您从这得到的是与可变集合相似的内存使用量。记住，在空间和时间上都有成本，但对于大多数用例来说可以忽略不计。
- en: Why would you want to have an immutable data collection? The main advantage
    is that it is simple to reason about them; passing them around to functions does
    not change them and when you are writing concurrent code, there is no chance that
    some other thread has modified your collection and you don't need to worry about
    explicitly handling locks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您为什么想要有一个不可变的数据集合？主要优势是它们很容易理解；将它们传递给函数不会改变它们，当您编写并发代码时，没有其他线程会修改您的集合，您也不需要担心显式处理锁。
- en: Types of collections in Clojure
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中集合的类型
- en: 'There are three types of collections in Clojure: counted, sequential, and associative.
    They are not mutually exclusive, meaning one collection might be any.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中有三种类型的集合：计数、顺序和关联。它们不是互斥的，这意味着一个集合可能是任何一种。
- en: 'Let''s look at each type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种类型：
- en: '**Counted collection**: A counted collection is a collection which knows its
    size in constant time. It doesn''t need to traverse its elements to get a count.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数集合**：计数集合是一个知道其大小在常数时间内的集合。它不需要遍历其元素来获取计数。'
- en: '**Sequential collection**: A sequential collection can be traversed sequentially;
    it''s the most common approach that you would use for a list. The easiest way
    to think about this is similar to Java''s list, which you can traverse with a
    for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential
    collections.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序集合**：顺序集合可以顺序遍历；这是您在列表中使用最常见的方法。最容易想到的是类似于Java的列表，您可以使用for循环或迭代器遍历它。在Clojure中，向量、列表和惰性序列都是顺序集合。'
- en: '**Associative collections**: Associative collections can be accessed by keys;
    maps are the natural choice here. We said that one collection can be of any type;
    Clojure''s vectors can also be used as associative collections, and each element
    index can be used as a key. You can think of it as a map where the keys are 0,
    1, 2, 3, and so on.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联集合**：关联集合可以通过键来访问；映射是这里的首选。我们说过一个集合可以是任何类型；Clojure的向量也可以用作关联集合，每个元素索引可以用作键。你可以将其视为一个映射，其键为0、1、2、3等。'
- en: 'Clojure has some functions that tell us if a given collection is of each type,
    sequential or associative. As you can guess, vectors return true for both. The
    following are those functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一些函数可以告诉我们给定的集合是否属于每种类型，顺序的还是关联的。正如你所猜测的，向量对两者都返回true。以下就是那些函数：
- en: '| Function name | List | Vector | Map | Lazy sequence | Set |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 列表 | 向量 | 映射 | 惰性序列 | 集合 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| counted? | true | true | true | false | true |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| counted? | true | true | true | false | true |'
- en: '| sequential? | true | true | false | true | false |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| sequential? | true | true | false | true | false |'
- en: '| associative? | false | true | true | false | false |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| associative? | false | true | true | false | false |'
- en: '![Types of collections in Clojure](img/00013.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Clojure中集合的类型](img/00013.jpeg)'
- en: In the previous table and diagram, you can see that we take **Set** into account
    and as you can see, it's neither sequential nor associative.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的表格和图中，你可以看到我们考虑了**集合**，并且正如你所见，它既不是顺序的也不是关联的。
- en: We should look at another property; whether a collection is counted or not.
    It means that a collection knows how many elements it has. Lists, vectors, maps,
    and sets are all counted; lazy sequences are not counted, since they are generated
    on the fly and they could even be infinite sequences.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看看另一个属性；集合是否计数。这意味着集合知道它有多少个元素。列表、向量、映射和集合都是计数的；惰性序列不是计数的，因为它们是即时生成的，甚至可能是无限序列。
- en: We will learn more about all of these sequences in the later sections of this
    chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的部分中学习更多关于所有这些序列的内容。
- en: The sequence abstraction
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列抽象
- en: 'Clojure has some unique features that make it different from other Lisps; one
    of them is the sequence abstraction. You can think of it as an interface that
    collections comply with. Clojure has a standard API of functions that you can
    use with sequences. Here are some examples of those functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一些独特的特性使其与其他Lisp不同；其中之一就是序列抽象。你可以将其视为集合遵守的接口。Clojure有一个标准的函数API，你可以与序列一起使用。以下是一些这些函数的示例：
- en: 'The `distinct` function: This function returns a sequence that includes each
    element of the original sequence just once:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`函数：这个函数返回一个序列，包含原始序列中的每个元素，但每个元素只出现一次：'
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `take` function: This function takes a number of elements from the original
    sequence:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`函数：这个函数从原始序列中取出一定数量的元素：'
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `map` function: This function applies a function to each element of a sequence
    and creates a new sequence with these elements:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`函数：这个函数将一个函数应用于序列中的每个元素，并创建一个包含这些元素的新序列：'
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The interesting part here is that these functions receive and return sequences
    and you can compose them together. It can be seen in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是这些函数接收并返回序列，并且你可以将它们组合在一起。以下代码中可以看得到：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These are just some functions that accept and return sequences, but there are
    a lot more that you can use out of the box. The only assumption is that your sequence
    argument can respond to three functions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是接受和返回序列的一些函数，但还有很多其他你可以直接使用的函数。唯一的假设是你的序列参数可以响应三个函数：
- en: '`first`: This function returns the first of a sequence'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`: 这个函数返回序列的第一个元素'
- en: '`rest`: This function returns another sequence, containing everything but the
    first element'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest`: 这个函数返回另一个序列，包含除了第一个元素之外的所有元素'
- en: '`cons`: This function receives two parameters, an item and another `seq` and
    returns a new `seq` containing the item followed by all the items in the second
    parameter'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cons`: 这个函数接收两个参数，一个项和另一个`seq`，然后返回一个新的`seq`，包含该项以及第二个参数中的所有项'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of the functions that you'll find yourself using more is the `seq` function,
    it can convert any collection to a seq, even Java native arrays and objects that
    implement the `java.util.Iterable` interface. One of its main uses is to test
    a collection for emptiness.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现使用频率较高的一个函数是`seq`函数，它可以转换任何集合为序列，甚至Java原生的数组和实现了`java.util.Iterable`接口的对象。其主要用途之一是测试集合是否为空。
- en: Specific collection types in Clojure
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的特定集合类型
- en: Now that you know about Clojure's general collection properties and the sequence
    abstraction, it is a good time to get to know about Clojure's specific collection
    implementations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Clojure的一般集合属性和序列抽象，现在是时候了解Clojure的具体集合实现了。
- en: Vectors
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: Vectors are Clojure's workhorse; together with map, it is the most used collection.
    Don't be afraid of them; they have nothing to do with Java's `java.util.Vector`.
    They are just a series of ordered values, such as a list or an array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是Clojure的工作马；与map一起，它是使用最多的集合。不要害怕它们；它们与Java的`java.util.Vector`无关。它们只是一系列有序值，如列表或数组。
- en: 'They have the following properties:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有以下属性：
- en: They are immutable
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They can be accessed sequentially
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以按顺序访问
- en: They are associative (they are maps of their indices, meaning that their keys
    are 0, 1, 2, and so on)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是关联的（它们是它们索引的映射，这意味着它们的键是0、1、2等等）
- en: They are counted, meaning they have a finite size
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是计数的，这意味着它们有有限的大小
- en: They have random access, so you can access any element with almost constant
    time (with the nth function)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有随机访问，因此你可以几乎以常数时间访问任何元素（使用nth函数）
- en: The `conj` function appends a given element to them
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conj`函数将给定的元素追加到它们中'
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The nth function allows us to get the nth element of any `seq`, but you shouldn't
    use it without care. It has no problem handling vectors and it returns in constant
    time, but it takes linear time when used with a list, since it has to traverse
    all the collections looking for the element you asked. Try to use it just with
    vectors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: nth函数允许我们获取任何`seq`的第n个元素，但你不应不加考虑地使用它。它没有问题处理向量，并且以常数时间返回，但与列表一起使用时，它需要线性时间，因为它必须遍历所有集合以找到你请求的元素。尽量只与向量一起使用它。
- en: 'They have a literal syntax; you can define a vector with square brackets, as
    shown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有字面语法；你可以用方括号定义一个向量，如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Besides the literal syntax, there''s another function that you can use to build
    a vector. The `vec` function can build a vector out of any sequence passed to
    it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字面语法之外，还有一个你可以用来构建向量的函数。`vec`函数可以从传递给它的任何序列中构建一个向量：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another important benefit of vectors is that they are used for function arguments
    for declarations and for `let` bindings.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的另一个重要好处是，它们用于函数参数的声明和`let`绑定。
- en: 'Take a look at the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the parameters in the function are defined as a vector, same
    as the `let` binding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数中的参数被定义为向量，这与`let`绑定相同。
- en: One of the main complaints about Lisps is that they use too many parentheses,
    Clojure's decision to use vectors instead in these structures is welcomed and
    makes the code much easier to read.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Lisp的主要抱怨之一是它们使用太多的括号，Clojure在这些结构中使用向量而不是括号的决策受到欢迎，这使得代码更容易阅读。
- en: 'There are several ways to access a certain element of a vector:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以访问向量的某个元素：
- en: '**Using the vector as a function**: Vectors can be used as functions of their
    keys; we haven''t discussed maps yet but you will see that this is because they
    are associative:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用向量作为函数**：向量可以用作其键的函数；我们还没有讨论映射，但你很快就会看到这是因为它们是关联的：'
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**The nth function**: The `nth` function can receive an extra parameter for
    signaling when an index is not found and can be used, as shown:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nth函数**：`nth`函数可以接收一个额外的参数来指示当索引未找到时，它可以被这样使用：'
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**The get function**: The `get` function can receive an extra parameter for
    signaling when an index is not found, it is used as shown. An important thing
    to keep in mind is that unlike nth, `get` cannot be used in sequences:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get函数**：`get`函数可以接收一个额外的参数来指示当索引未找到时，它被这样使用。需要记住的一个重要的事情是，与nth不同，`get`不能用于序列：'
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should use vectors almost always; in particular, if you want to do any
    of the following there is no other way to go:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎应该总是使用向量；特别是，如果你想做以下任何一项，没有其他方法可行：
- en: You need random access to a collection (either modifying or accessing it)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要随机访问集合（无论是修改还是访问它）
- en: You need to add elements at the tail of the collection
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在集合的尾部添加元素
- en: Lists
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are the most important collection type in other Lisps. In Clojure, they
    are used to represent code, but their functionality is almost limited to that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是其他Lisp中最重要的集合类型。在Clojure中，它们用于表示代码，但它们的函数性几乎仅限于这一点。
- en: Lists in Clojure are single linked lists; as you can imagine, this means that
    they are not good for random access (you need to iterate the list until you get
    to the wanted index). That said, you can still use lists as sequences with every
    function of the API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的列表是单链表；正如你可以想象的那样，这意味着它们不适合随机访问（你需要遍历列表直到到达想要的索引）。尽管如此，你仍然可以使用列表作为具有API中每个功能的序列。
- en: 'Let''s list their properties:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出它们的属性：
- en: They are immutable
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They can be accessed sequentially
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以按顺序访问
- en: They are not associative
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是关联的
- en: They are counted, meaning they have a finite size
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是计数的，这意味着它们有有限的大小
- en: They shouldn't be accessed in random order. If you want the 99th element, then
    Clojure will have to visit all the first 98 elements to get the 99th.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不应该以随机顺序访问。如果你想要第99个元素，那么Clojure将不得不访问前98个元素才能得到第99个。
- en: The `conj` function prepends a given element to it
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conj`函数将给定元素添加到其前面'
- en: You can use destructuring with lists, as seen in the previous chapter. You shouldn't
    be afraid to use the first function (or even nth with a small index).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用解构，就像在前一章中看到的那样。你不应该害怕使用第一个函数（甚至可以使用带有小索引的nth）。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Lists have their use cases and as you learn more you'll probably be comfortable
    using them in some places (such as macros), but as a rule of thumb, try to use
    vectors instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有其用例，随着你学习的深入，你可能会在某些地方（如宏）中感到舒适地使用它们，但作为一个经验法则，尽量使用向量。
- en: Maps
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图
- en: Maps are probably the most important collection type across all languages. They
    are also very important in Clojure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 映射可能是所有语言中最重要的集合类型。在Clojure中，它们也非常重要。
- en: Maps are collections of key value pairs, which mean that you can access or store
    an element by a key. We have been calling this type of collection an associative
    collection. Keys can be of any type of value in Clojure, even functions, lists,
    sets, vectors, or other maps.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是键值对的集合，这意味着你可以通过键来访问或存储一个元素。我们一直称这种类型的集合为关联集合。在Clojure中，键可以是任何类型的值，甚至是函数、列表、集合、向量或其他映射。
- en: Sorted maps and hash maps
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序映射和哈希映射
- en: There are two types of maps in Clojure, each one of them with its own advantages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中有两种类型的映射，每种类型都有其自身的优势。
- en: '**Hash maps**: They are the most used form of map in Clojure; the literal syntax
    of maps creates this type of maps. They have a nearly constant lookup time, which
    makes them extremely fast and usable in most scenarios. Their down-side is that
    you can''t access them in an ordered fashion. You can create them, as shown:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希映射**：它们是Clojure中最常用的映射形式；映射的文本语法创建了这种类型的映射。它们具有几乎恒定的查找时间，这使得它们在大多数场景中都非常快且可用。它们的缺点是你不能按顺序访问它们。你可以创建它们，如下所示：'
- en: '[PRE13]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Sorted maps**: If you need to be able to access a map''s key-value pairs
    in a certain order, then you have to use a sorted map. The downside of sorted
    maps is that the lookup time is *not* constant, which means that they are a little
    slower to access by key. However, when you need to traverse a map in the order
    of the keys, then this is the only way to go. A strong constraint here is that
    the keys must be comparable between them. Sorted maps can be created, as shown:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序映射**：如果你需要能够以特定顺序访问映射的键值对，那么你必须使用有序映射。有序映射的缺点是查找时间**不是**常数，这意味着它们通过键访问会稍微慢一些。然而，当你需要按键的顺序遍历映射时，这是唯一的方法。这里的一个强约束是键之间必须是可比较的。有序映射可以创建，如下所示：'
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Comparable objects are the ones that implement the `compareTo` interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可比较的对象是实现了`compareTo`接口的对象。
- en: Common properties
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见属性
- en: 'Associative objects, including maps have the following properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关联对象，包括映射，具有以下属性：
- en: 'They are functions of their keys:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是它们键的函数：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'They can be used with associative destructuring:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用关联解构来使用：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'They can be accessed with the `get` function:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`get`函数来访问它们：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can convert a map to a `seq` with the `seq` function; you will get a sequence
    where each element is a vector representing a key-value pair in the map:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`seq`函数将映射转换为`seq`；你将得到一个序列，其中每个元素都是一个表示映射中键值对的向量：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Doseq` is similar to Java''s for-each loop. It executes the body for each
    element in a sequence.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Doseq`类似于Java的for-each循环。它对序列中的每个元素执行主体。'
- en: 'It works as shown: `(doseq [x sequence] ;;`. This works the same way as the
    let statement, you can use destructuring if needed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式如下：`(doseq [x sequence] ;;`。这与let语句的工作方式相同，如果需要，你可以使用解构：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sets
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Clojure sets are a collection of unique elements. You can think of them as mathematical
    sets and as such, Clojure has operations, such as union intersection and difference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure集合是一组唯一的元素。你可以把它们看作是数学集合，因此Clojure有并集、交集和差集等操作。
- en: 'Let''s look at the properties of sets:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集合的性质：
- en: They are immutable
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They are associative (their keys are their elements)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是关联的（它们的键是它们的元素）
- en: They are counted, meaning they have a finite size
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是有计数的，这意味着它们有有限的大小
- en: Their elements are unique (contained at most once)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的元素是唯一的（最多包含一次）
- en: Sorted sets and hash sets
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序集合和无序集合
- en: 'There are two kinds of sets: hash-sets and sorted-sets.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种集合：哈希集合和有序集合。
- en: '**Hash-set**: Besides the properties that we already saw, hash-sets are unordered.
    They are implemented using a hash map as a backing implementation.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希集合**：除了我们已经看到的属性外，哈希集合是无序的。它们使用哈希表作为后端实现。'
- en: '**Sorted-set**: Besides the properties that we already saw, sorted-sets are
    sorted. They can be used as a parameter to all the functions that expect a sorted
    `seq`. They can be accessed sequentially in sorted order:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序集合**：除了我们已经看到的属性外，有序集合是有序的。它们可以用作所有期望有序`seq`的函数的参数。它们可以按顺序访问：'
- en: '[PRE20]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also reverse them without problems, filter them, or map them similarly
    to a vector or list.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以无问题地反转它们，过滤它们，或者像向量或列表一样映射它们。
- en: Common properties
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见属性
- en: 'Sets are associative, which gives them some properties of maps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是关联的，这赋予它们一些映射的性质：
- en: 'They are functions of their elements:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是它们元素的函数：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'They can be used with map destructuring:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与映射解构一起使用：
- en: '[PRE22]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `get` function can be used to access their elements:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`get`函数来访问它们的元素：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Union, difference, and intersection
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并集、差集和交集
- en: 'If you remember mathematical sets, you''ll know that the three main operations
    you can execute on them are the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得数学集合，你会知道你可以对它们执行以下三个主要操作：
- en: '**Union** (`union a b`): The union includes all of the elements both in `a`
    and `b`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集** (`union a b`): 并集包含`a`和`b`中的所有元素'
- en: '**Difference** (`difference a b`): The difference is all the elements that
    are in `a` except for the elements that are also in `b`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差集** (`difference a b`): 差集是`a`中所有不在`b`中的元素'
- en: '**Intersection** (`intersection a b`): It includes only the elements that are
    both in `a` and `b`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集** (`intersection a b`): 它只包含`a`和`b`中都有的元素'
- en: 'Here are some examples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Applying functional programming to collections
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数式编程应用于集合
- en: Now that we have a better understanding of how collections work, we have a better
    foundation to understand functional programming and how to make the most out of
    it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对集合的工作方式有了更好的理解，我们就有了更好的基础来理解函数式编程以及如何充分利用它。
- en: This requires a different way of thinking about how to solve problems and you
    should keep your mind open.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要以不同的方式思考如何解决问题，你应该保持开放的心态。
- en: 'Something that you might have found really strange about all of the collections
    is this feature: *They are immutable*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现所有这些集合中有一个非常奇怪的特性：*它们是不可变的*。
- en: This is indeed something quite strange; if you are used to Java, how can you
    possibly write programs without adding or removing elements from a list or set?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一件相当奇怪的事情；如果你习惯了Java，你怎么可能编写不添加或删除列表或集合元素的程序呢？
- en: How is that even possible? In Java, we are used to writing `for` and `while`
    loops. We are used to mutating variables every step of the way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能呢？在Java中，我们习惯于编写`for`和`while`循环。我们习惯于每一步都修改变量。
- en: How can we cope with immutable data structures? Let's find out in the subsequent
    sections.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何应对不可变的数据结构？让我们在接下来的章节中一探究竟。
- en: The imperative programming model
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式编程模型
- en: The software industry has been using a single software paradigm for a long time;
    this paradigm is an imperative programming model.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业长期以来一直使用单一的软件范式；这个范式是命令式编程模型。
- en: In the imperative paradigm, you have to tell the computer what to do at every
    single step. You are responsible for how the memory works, for whether it is running
    in a single core or multi core and, if you want to use multi core, you need to
    make sure that you change the program state correctly and avoid concurrency problems.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式范式下，你必须告诉计算机在每一步要做什么。你负责内存的工作方式，是单核运行还是多核运行，如果你想使用多核，你需要确保正确地改变程序状态并避免并发问题。
- en: 'Let''s see how you would calculate the factorial in an imperative style:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你将如何以命令式风格计算阶乘：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You are creating a variable result and a variable `i`. You change the variable
    `i` each time by assigning it the value `i + 1`. You can change the result by
    multiplying by `i`. The computer just executes your orders, comparing, adding,
    and multiplying. This is what we call the imperative programming model, because
    you need to tell the computer the exact commands it needs to execute.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在创建一个变量`result`和一个变量`i`。你每次通过将其值赋为`i + 1`来改变变量`i`。你可以通过乘以`i`来改变结果。计算机只是执行你的命令，比较、加法和乘法。这就是我们所说的命令式编程模型，因为你需要告诉计算机它需要执行的精确命令。
- en: 'This has worked fine in the past for various reasons, such as:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这在过去由于各种原因一直工作得很好，例如：
- en: The tight constraints of memory size forced programmers to make use of the memory
    as efficient as possible
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧张的内存大小限制迫使程序员尽可能高效地使用内存
- en: It was easier to think about a single thread of execution and how the computer
    executes it step-by-step
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到单个执行线程以及计算机如何逐步执行它，这更容易思考
- en: Of course, there were some drawbacks. A code can get complicated easily and
    the world has changed; the constraints that existed many years ago are gone. In
    addition, most of today's computers have more than one CPU. Multi-threading with
    shared mutable states is burdensome.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一些缺点。代码可以很容易地变得复杂，世界已经改变；多年前存在的约束已经消失。此外，今天的大多数计算机都有多个CPU。使用共享可变状态的多线程是负担。
- en: This makes thinking about this complicated. We get in trouble even in single
    threaded programs; just think, what would be the outcome of the following code?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得思考变得复杂。即使在单线程程序中我们也会遇到麻烦；想想看，以下代码的结果会是什么？
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Is it `0`? You can't possibly know because the `doSomething` method gets the
    list by reference and it can add or remove things without you knowing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它是`0`吗？你不可能知道，因为`doSomething`方法通过引用获取列表，并且可以在你不知道的情况下添加或删除东西。
- en: Now, imagine that you have a multithreaded program and a single `List` that
    can be modified by any of the threads. In the Java world, you have to know about
    `java.util.concurrent.CopyOnWriteArrayList` and you need to know about its implementation
    details to know when it's a good idea to use it and when not to use it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你有一个多线程程序和一个可以被任何线程修改的单个`List`。在Java世界中，你必须了解`java.util.concurrent.CopyOnWriteArrayList`，并且你需要了解其实现细节，以便知道何时使用它以及何时不使用它。
- en: Even with these structures, it is difficult to think about multithreaded code.
    You still need to think about semaphores, locks, synchronizers, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些结构，思考多线程代码也很困难。你仍然需要考虑信号量、锁、同步器等等。
- en: The imperative world might be easy for the easy case, but it is not simple.
    The whole industry has realized this and there are many new languages and technologies
    that take ideas from other places. Java 8 has the streaming API and it includes
    lambda blocks, which are essentially functions. All these ideas are taken from
    the functional world.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式世界可能对简单情况来说很容易，但它并不简单。整个行业已经意识到这一点，有许多新的语言和技术从其他地方汲取了灵感。Java 8有流式API，它包括lambda块，本质上就是函数。所有这些想法都是从函数式世界借鉴的。
- en: The functional paradigm
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式范式
- en: There are other ways of thinking about how to solve a problem; in particular,
    the functional paradigm has become important lately. It is nothing new; Lisp has
    supported this kind of programming since it was conceived in 1958\. It has probably
    not been strong until recently, as it requires a more abstract way of thinking.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他思考解决问题的方法；特别是，函数式范式最近变得很重要。这并不是什么新鲜事；Lisp自从1958年构想以来就支持这种编程。它可能直到最近才变得强大，因为它需要一种更抽象的思维方式。
- en: 'For you to get a better idea, let''s see a couple of examples of how functional
    programming looks similar to the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更好地理解，让我们看看几个函数式编程看起来与以下代码相似示例：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, it looks quite different; in the first case, we are passing
    the `str` function to another function called map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它看起来相当不同；在第一种情况下，我们将`str`函数传递给另一个名为`map`的函数。
- en: In the second case, we are passing the `*` function to another function called
    reduce. In both cases, we are using functions as you would pass a list or a number,
    they are **first level citizens**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们将`*`函数传递给另一个名为`reduce`的函数。在这两种情况下，我们都是以传递列表或数字的方式使用函数，它们是**第一级公民**。
- en: One important difference in functional programming is that you don't need to
    tell the machine how to do things. In the first case, the map traverses the vector
    and applies the `str` function to each element, converting it to a `seq` of strings.
    You don't have to increment the index, you just need to tell the map what function
    you want to be applied to each element.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个重要区别是你不需要告诉机器如何做事情。在第一种情况下，map 遍历向量并将 `str` 函数应用于每个元素，将其转换为字符串的 `seq`。你不需要递增索引，你只需要告诉
    map 你想要应用于每个元素的函数。
- en: In the factorial case, there is a reduce function that receives the `*` and
    a `seq` from `1` to `n`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在阶乘情况下，有一个接收 `*` 和从 `1` 到 `n` 的 `seq` 的 `reduce` 函数。
- en: It just works, you don't need to tell it how to do anything, just what you want
    done.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它只需工作，你不需要告诉它如何做任何事情，只需告诉它你想做什么。
- en: Both `map` and `reduce` are **higher order functions** because they accept functions
    such as parameters; they are also higher level abstractions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `reduce` 都是 **高阶函数**，因为它们接受函数作为参数；它们也是高级抽象。'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Higher order functions are functions that either accept a function as an argument,
    return a function as result, or both.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是那些接受函数作为参数、返回函数作为结果，或者两者都接受的函数。
- en: You need to think on another level of abstraction and you don't care how things
    are really done, just that it gets the work done.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在一个更高级的抽象层面上思考，你不在乎事情是如何真正完成的，只在乎它完成了工作。
- en: This comes with some benefit, if the implementation of a map someday changes
    to become multithreaded, you would just need to update the versions and you would
    be ready to go!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一些好处，如果某天映射的实现变成了多线程，你只需更新版本，就可以准备出发了！
- en: Functional programming and immutability
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程和不可变性
- en: You may have also noticed that functional programming makes working with immutable
    structures necessary, because you can't mutate some or the other state in every
    step; you can just describe how you want to create a new collection based on some
    other collection and then get it. Clojure's efficient collections make it possible
    to share pieces of collections to keep memory usage at a minimum.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，函数式编程使得使用不可变结构成为必要，因为你不能在每一步中改变某些或所有状态；你只能描述你想要基于其他集合创建新集合的方式，然后获取它。Clojure
    的有效集合使得在最小内存使用的情况下共享集合的片段成为可能。
- en: 'There are some other benefits to immutability:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性还有一些其他的好处：
- en: You can share your data structures with anyone you want because you are certain
    that nobody can change your copy.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以与任何你想分享的人分享你的数据结构，因为你确信没有人会更改你的副本。
- en: Debugging is simpler because you can test the program with some immutable value
    instead of some mutating state. When you get a value, you can find out which function
    returned the value that you got; there are not multiple places where a collection
    was mutated for you to check.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试更简单，因为你可以用一些不可变值来测试程序，而不是一些可变状态。当你得到一个值时，你可以找出哪个函数返回了你得到的值；没有多个地方会修改集合供你检查。
- en: Concurrent programming is simpler; again being certain that nobody can change
    your copy, even in other concurrently running threads, makes reasoning about your
    program simpler.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程更简单；再次确定没有人可以更改你的副本，即使在其他并发运行的线程中，这也使得对程序的推理更简单。
- en: Laziness
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒惰性
- en: 'Clojure also supports lazy evaluation of transformations of sequences. Let''s
    take a look at the `range` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 也支持序列转换的惰性评估。让我们看看 `range` 函数：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When running this function without parameters, you are creating an infinite
    sequence starting from `0`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此函数而不带参数时，你正在创建一个从 `0` 开始的无限序列。
- en: It is an infinite sequence; so why does the Clojure REPL return automatically?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个无限序列；那么为什么 Clojure REPL 会自动返回？
- en: 'Clojure doesn''t compute a collection value until needed, so in order to get
    a value you would have to do something, such as this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 不会在需要之前计算集合值，所以为了获取一个值，你必须做些什么，比如这样：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you try to print an infinite sequence at the REPL, it will freeze.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在 REPL 中打印一个无限序列，它将会冻结。
- en: Here, Clojure is resolving first one element and then five of the collection
    `r` because it needs to print them in the REPL.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Clojure 首先解析一个元素，然后解析集合 `r` 中的五个元素，因为它需要在 REPL 中打印它们。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Lazy evaluation just works for collections and for sequence processing. Other
    operations (such as additions, method calls, and so on), are executed eagerly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估对集合和序列处理都适用。其他操作（如加法、方法调用等）都是立即执行的。
- en: The interesting part is that you can define a new lazy collection by applying
    functions like filter and map to a certain collection.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你可以通过将filter和map等函数应用于某个集合来定义一个新的惰性集合。
- en: 'For instance, let''s get a new collection that contains all odd numbers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取一个包含所有奇数的新的集合：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, `odd-numbers` is an infinite sequence of odd numbers and we have just
    asked for three of them. Whenever a number is already computed, it is not computed
    again. Let''s change our collection a little bit in order to understand how this
    works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`odd-numbers`是一个包含奇数的无限序列，我们刚刚请求了其中的三个。每当一个数字已经被计算，它就不会再次被计算。让我们稍微改变一下我们的集合，以便理解它是如何工作的：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, some numbers get calculated first; you shouldn't expect or rely
    on a particular number of elements to be precomputed at a certain time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一些数字首先被计算；你不应该期望或依赖于在特定时间预先计算特定数量的元素。
- en: Also, keep in mind that the computation isn't executed again when we ask for
    the same number of elements, since it has been already cached.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当我们请求相同数量的元素时，计算不会再次执行，因为它已经被缓存了。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Collections and functional programming in Clojure are extremely powerful tools
    that allow us to use a completely different paradigm of programming.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的集合和函数式编程是极其强大的工具，使我们能够使用完全不同的编程范式。
- en: 'Here''s what we have learned so far:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了以下内容：
- en: The mechanics of immutable collections and what each collection type in Clojure
    is best for
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合的机制以及Clojure中每种集合类型最适合做什么
- en: How sequence abstraction and how a lot of Clojure functions are available to
    work on collections, using this abstraction
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列抽象以及许多Clojure函数如何利用这种抽象在集合上工作
- en: How functional programming enables us to write simpler programs that work better
    in parallel environments and help us save resources using laziness
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程如何使我们能够编写更简单的程序，这些程序在并行环境中表现更好，并帮助我们通过惰性节省资源
- en: In the subsequent chapters, we will learn about other new Clojure features that
    give us a new and much more powerful way to implement polymorphism than what Java
    offers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将学习其他新的Clojure特性，这些特性为我们提供了比Java更强大和新的实现多态性的方法。
